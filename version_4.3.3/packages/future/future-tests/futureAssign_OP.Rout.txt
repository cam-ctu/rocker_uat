
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:32:41.696] plan(): Setting new future strategy stack:
[10:32:41.697] List of future strategies:
[10:32:41.697] 1. sequential:
[10:32:41.697]    - args: function (..., envir = parent.frame())
[10:32:41.697]    - tweaked: FALSE
[10:32:41.697]    - call: future::plan("sequential")
[10:32:41.711] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[10:32:41.766] plan(): Setting new future strategy stack:
[10:32:41.766] List of future strategies:
[10:32:41.766] 1. sequential:
[10:32:41.766]    - args: function (..., envir = parent.frame())
[10:32:41.766]    - tweaked: FALSE
[10:32:41.766]    - call: plan(strategy)
[10:32:41.778] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[10:32:41.780] getGlobalsAndPackages() ...
[10:32:41.780] Searching for globals...
[10:32:41.784] - globals found: [2] ‘{’, ‘<-’
[10:32:41.785] Searching for globals ... DONE
[10:32:41.785] Resolving globals: FALSE
[10:32:41.785] 
[10:32:41.785] 
[10:32:41.785] getGlobalsAndPackages() ... DONE
[10:32:41.786] run() for ‘Future’ ...
[10:32:41.786] - state: ‘created’
[10:32:41.786] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.787] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.787]   - Field: ‘label’
[10:32:41.787]   - Field: ‘local’
[10:32:41.787]   - Field: ‘owner’
[10:32:41.787]   - Field: ‘envir’
[10:32:41.787]   - Field: ‘packages’
[10:32:41.788]   - Field: ‘gc’
[10:32:41.788]   - Field: ‘conditions’
[10:32:41.788]   - Field: ‘expr’
[10:32:41.788]   - Field: ‘uuid’
[10:32:41.788]   - Field: ‘seed’
[10:32:41.788]   - Field: ‘version’
[10:32:41.788]   - Field: ‘result’
[10:32:41.788]   - Field: ‘asynchronous’
[10:32:41.788]   - Field: ‘calls’
[10:32:41.788]   - Field: ‘globals’
[10:32:41.788]   - Field: ‘stdout’
[10:32:41.789]   - Field: ‘earlySignal’
[10:32:41.789]   - Field: ‘lazy’
[10:32:41.789]   - Field: ‘state’
[10:32:41.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.789] - Launch lazy future ...
[10:32:41.790] Packages needed by the future expression (n = 0): <none>
[10:32:41.790] Packages needed by future strategies (n = 0): <none>
[10:32:41.791] {
[10:32:41.791]     {
[10:32:41.791]         {
[10:32:41.791]             ...future.startTime <- base::Sys.time()
[10:32:41.791]             {
[10:32:41.791]                 {
[10:32:41.791]                   {
[10:32:41.791]                     base::local({
[10:32:41.791]                       has_future <- base::requireNamespace("future", 
[10:32:41.791]                         quietly = TRUE)
[10:32:41.791]                       if (has_future) {
[10:32:41.791]                         ns <- base::getNamespace("future")
[10:32:41.791]                         version <- ns[[".package"]][["version"]]
[10:32:41.791]                         if (is.null(version)) 
[10:32:41.791]                           version <- utils::packageVersion("future")
[10:32:41.791]                       }
[10:32:41.791]                       else {
[10:32:41.791]                         version <- NULL
[10:32:41.791]                       }
[10:32:41.791]                       if (!has_future || version < "1.8.0") {
[10:32:41.791]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.791]                           "", base::R.version$version.string), 
[10:32:41.791]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.791]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.791]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.791]                             "release", "version")], collapse = " "), 
[10:32:41.791]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.791]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.791]                           info)
[10:32:41.791]                         info <- base::paste(info, collapse = "; ")
[10:32:41.791]                         if (!has_future) {
[10:32:41.791]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.791]                             info)
[10:32:41.791]                         }
[10:32:41.791]                         else {
[10:32:41.791]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.791]                             info, version)
[10:32:41.791]                         }
[10:32:41.791]                         base::stop(msg)
[10:32:41.791]                       }
[10:32:41.791]                     })
[10:32:41.791]                   }
[10:32:41.791]                   ...future.strategy.old <- future::plan("list")
[10:32:41.791]                   options(future.plan = NULL)
[10:32:41.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.791]                 }
[10:32:41.791]                 ...future.workdir <- getwd()
[10:32:41.791]             }
[10:32:41.791]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.791]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.791]         }
[10:32:41.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.791]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.791]             base::names(...future.oldOptions))
[10:32:41.791]     }
[10:32:41.791]     if (FALSE) {
[10:32:41.791]     }
[10:32:41.791]     else {
[10:32:41.791]         if (TRUE) {
[10:32:41.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.791]                 open = "w")
[10:32:41.791]         }
[10:32:41.791]         else {
[10:32:41.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.791]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.791]         }
[10:32:41.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.791]             base::sink(type = "output", split = FALSE)
[10:32:41.791]             base::close(...future.stdout)
[10:32:41.791]         }, add = TRUE)
[10:32:41.791]     }
[10:32:41.791]     ...future.frame <- base::sys.nframe()
[10:32:41.791]     ...future.conditions <- base::list()
[10:32:41.791]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.791]     if (FALSE) {
[10:32:41.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.791]     }
[10:32:41.791]     ...future.result <- base::tryCatch({
[10:32:41.791]         base::withCallingHandlers({
[10:32:41.791]             ...future.value <- base::withVisible(base::local({
[10:32:41.791]                 x <- 1
[10:32:41.791]             }))
[10:32:41.791]             future::FutureResult(value = ...future.value$value, 
[10:32:41.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.791]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.791]                     ...future.globalenv.names))
[10:32:41.791]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.791]         }, condition = base::local({
[10:32:41.791]             c <- base::c
[10:32:41.791]             inherits <- base::inherits
[10:32:41.791]             invokeRestart <- base::invokeRestart
[10:32:41.791]             length <- base::length
[10:32:41.791]             list <- base::list
[10:32:41.791]             seq.int <- base::seq.int
[10:32:41.791]             signalCondition <- base::signalCondition
[10:32:41.791]             sys.calls <- base::sys.calls
[10:32:41.791]             `[[` <- base::`[[`
[10:32:41.791]             `+` <- base::`+`
[10:32:41.791]             `<<-` <- base::`<<-`
[10:32:41.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.791]                   3L)]
[10:32:41.791]             }
[10:32:41.791]             function(cond) {
[10:32:41.791]                 is_error <- inherits(cond, "error")
[10:32:41.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.791]                   NULL)
[10:32:41.791]                 if (is_error) {
[10:32:41.791]                   sessionInformation <- function() {
[10:32:41.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.791]                       search = base::search(), system = base::Sys.info())
[10:32:41.791]                   }
[10:32:41.791]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.791]                     cond$call), session = sessionInformation(), 
[10:32:41.791]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.791]                   signalCondition(cond)
[10:32:41.791]                 }
[10:32:41.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.791]                 "immediateCondition"))) {
[10:32:41.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.791]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.791]                   if (TRUE && !signal) {
[10:32:41.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.791]                     {
[10:32:41.791]                       inherits <- base::inherits
[10:32:41.791]                       invokeRestart <- base::invokeRestart
[10:32:41.791]                       is.null <- base::is.null
[10:32:41.791]                       muffled <- FALSE
[10:32:41.791]                       if (inherits(cond, "message")) {
[10:32:41.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.791]                         if (muffled) 
[10:32:41.791]                           invokeRestart("muffleMessage")
[10:32:41.791]                       }
[10:32:41.791]                       else if (inherits(cond, "warning")) {
[10:32:41.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.791]                         if (muffled) 
[10:32:41.791]                           invokeRestart("muffleWarning")
[10:32:41.791]                       }
[10:32:41.791]                       else if (inherits(cond, "condition")) {
[10:32:41.791]                         if (!is.null(pattern)) {
[10:32:41.791]                           computeRestarts <- base::computeRestarts
[10:32:41.791]                           grepl <- base::grepl
[10:32:41.791]                           restarts <- computeRestarts(cond)
[10:32:41.791]                           for (restart in restarts) {
[10:32:41.791]                             name <- restart$name
[10:32:41.791]                             if (is.null(name)) 
[10:32:41.791]                               next
[10:32:41.791]                             if (!grepl(pattern, name)) 
[10:32:41.791]                               next
[10:32:41.791]                             invokeRestart(restart)
[10:32:41.791]                             muffled <- TRUE
[10:32:41.791]                             break
[10:32:41.791]                           }
[10:32:41.791]                         }
[10:32:41.791]                       }
[10:32:41.791]                       invisible(muffled)
[10:32:41.791]                     }
[10:32:41.791]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.791]                   }
[10:32:41.791]                 }
[10:32:41.791]                 else {
[10:32:41.791]                   if (TRUE) {
[10:32:41.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.791]                     {
[10:32:41.791]                       inherits <- base::inherits
[10:32:41.791]                       invokeRestart <- base::invokeRestart
[10:32:41.791]                       is.null <- base::is.null
[10:32:41.791]                       muffled <- FALSE
[10:32:41.791]                       if (inherits(cond, "message")) {
[10:32:41.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.791]                         if (muffled) 
[10:32:41.791]                           invokeRestart("muffleMessage")
[10:32:41.791]                       }
[10:32:41.791]                       else if (inherits(cond, "warning")) {
[10:32:41.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.791]                         if (muffled) 
[10:32:41.791]                           invokeRestart("muffleWarning")
[10:32:41.791]                       }
[10:32:41.791]                       else if (inherits(cond, "condition")) {
[10:32:41.791]                         if (!is.null(pattern)) {
[10:32:41.791]                           computeRestarts <- base::computeRestarts
[10:32:41.791]                           grepl <- base::grepl
[10:32:41.791]                           restarts <- computeRestarts(cond)
[10:32:41.791]                           for (restart in restarts) {
[10:32:41.791]                             name <- restart$name
[10:32:41.791]                             if (is.null(name)) 
[10:32:41.791]                               next
[10:32:41.791]                             if (!grepl(pattern, name)) 
[10:32:41.791]                               next
[10:32:41.791]                             invokeRestart(restart)
[10:32:41.791]                             muffled <- TRUE
[10:32:41.791]                             break
[10:32:41.791]                           }
[10:32:41.791]                         }
[10:32:41.791]                       }
[10:32:41.791]                       invisible(muffled)
[10:32:41.791]                     }
[10:32:41.791]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.791]                   }
[10:32:41.791]                 }
[10:32:41.791]             }
[10:32:41.791]         }))
[10:32:41.791]     }, error = function(ex) {
[10:32:41.791]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.791]                 ...future.rng), started = ...future.startTime, 
[10:32:41.791]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.791]             version = "1.8"), class = "FutureResult")
[10:32:41.791]     }, finally = {
[10:32:41.791]         if (!identical(...future.workdir, getwd())) 
[10:32:41.791]             setwd(...future.workdir)
[10:32:41.791]         {
[10:32:41.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.791]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.791]             }
[10:32:41.791]             base::options(...future.oldOptions)
[10:32:41.791]             if (.Platform$OS.type == "windows") {
[10:32:41.791]                 old_names <- names(...future.oldEnvVars)
[10:32:41.791]                 envs <- base::Sys.getenv()
[10:32:41.791]                 names <- names(envs)
[10:32:41.791]                 common <- intersect(names, old_names)
[10:32:41.791]                 added <- setdiff(names, old_names)
[10:32:41.791]                 removed <- setdiff(old_names, names)
[10:32:41.791]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.791]                   envs[common]]
[10:32:41.791]                 NAMES <- toupper(changed)
[10:32:41.791]                 args <- list()
[10:32:41.791]                 for (kk in seq_along(NAMES)) {
[10:32:41.791]                   name <- changed[[kk]]
[10:32:41.791]                   NAME <- NAMES[[kk]]
[10:32:41.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.791]                     next
[10:32:41.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.791]                 }
[10:32:41.791]                 NAMES <- toupper(added)
[10:32:41.791]                 for (kk in seq_along(NAMES)) {
[10:32:41.791]                   name <- added[[kk]]
[10:32:41.791]                   NAME <- NAMES[[kk]]
[10:32:41.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.791]                     next
[10:32:41.791]                   args[[name]] <- ""
[10:32:41.791]                 }
[10:32:41.791]                 NAMES <- toupper(removed)
[10:32:41.791]                 for (kk in seq_along(NAMES)) {
[10:32:41.791]                   name <- removed[[kk]]
[10:32:41.791]                   NAME <- NAMES[[kk]]
[10:32:41.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.791]                     next
[10:32:41.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.791]                 }
[10:32:41.791]                 if (length(args) > 0) 
[10:32:41.791]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.791]             }
[10:32:41.791]             else {
[10:32:41.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.791]             }
[10:32:41.791]             {
[10:32:41.791]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.791]                   0L) {
[10:32:41.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.791]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.791]                   base::options(opts)
[10:32:41.791]                 }
[10:32:41.791]                 {
[10:32:41.791]                   {
[10:32:41.791]                     NULL
[10:32:41.791]                     RNGkind("Mersenne-Twister")
[10:32:41.791]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.791]                       inherits = FALSE)
[10:32:41.791]                   }
[10:32:41.791]                   options(future.plan = NULL)
[10:32:41.791]                   if (is.na(NA_character_)) 
[10:32:41.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.791]                     .init = FALSE)
[10:32:41.791]                 }
[10:32:41.791]             }
[10:32:41.791]         }
[10:32:41.791]     })
[10:32:41.791]     if (TRUE) {
[10:32:41.791]         base::sink(type = "output", split = FALSE)
[10:32:41.791]         if (TRUE) {
[10:32:41.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.791]         }
[10:32:41.791]         else {
[10:32:41.791]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.791]         }
[10:32:41.791]         base::close(...future.stdout)
[10:32:41.791]         ...future.stdout <- NULL
[10:32:41.791]     }
[10:32:41.791]     ...future.result$conditions <- ...future.conditions
[10:32:41.791]     ...future.result$finished <- base::Sys.time()
[10:32:41.791]     ...future.result
[10:32:41.791] }
[10:32:41.793] plan(): Setting new future strategy stack:
[10:32:41.793] List of future strategies:
[10:32:41.793] 1. sequential:
[10:32:41.793]    - args: function (..., envir = parent.frame())
[10:32:41.793]    - tweaked: FALSE
[10:32:41.793]    - call: NULL
[10:32:41.793] plan(): nbrOfWorkers() = 1
[10:32:41.794] plan(): Setting new future strategy stack:
[10:32:41.794] List of future strategies:
[10:32:41.794] 1. sequential:
[10:32:41.794]    - args: function (..., envir = parent.frame())
[10:32:41.794]    - tweaked: FALSE
[10:32:41.794]    - call: plan(strategy)
[10:32:41.795] plan(): nbrOfWorkers() = 1
[10:32:41.795] SequentialFuture started (and completed)
[10:32:41.795] - Launch lazy future ... done
[10:32:41.796] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[10:32:41.796] getGlobalsAndPackages() ...
[10:32:41.796] Searching for globals...
[10:32:41.797] - globals found: [3] ‘{’, ‘<-’, ‘a’
[10:32:41.797] Searching for globals ... DONE
[10:32:41.798] Resolving globals: FALSE
[10:32:41.798] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:41.799] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:32:41.799] - globals: [1] ‘a’
[10:32:41.799] 
[10:32:41.799] getGlobalsAndPackages() ... DONE
[10:32:41.799] run() for ‘Future’ ...
[10:32:41.799] - state: ‘created’
[10:32:41.800] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.800] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.800]   - Field: ‘label’
[10:32:41.800]   - Field: ‘local’
[10:32:41.800]   - Field: ‘owner’
[10:32:41.800]   - Field: ‘envir’
[10:32:41.800]   - Field: ‘packages’
[10:32:41.801]   - Field: ‘gc’
[10:32:41.801]   - Field: ‘conditions’
[10:32:41.801]   - Field: ‘expr’
[10:32:41.801]   - Field: ‘uuid’
[10:32:41.801]   - Field: ‘seed’
[10:32:41.801]   - Field: ‘version’
[10:32:41.801]   - Field: ‘result’
[10:32:41.801]   - Field: ‘asynchronous’
[10:32:41.801]   - Field: ‘calls’
[10:32:41.801]   - Field: ‘globals’
[10:32:41.802]   - Field: ‘stdout’
[10:32:41.802]   - Field: ‘earlySignal’
[10:32:41.802]   - Field: ‘lazy’
[10:32:41.802]   - Field: ‘state’
[10:32:41.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.802] - Launch lazy future ...
[10:32:41.802] Packages needed by the future expression (n = 0): <none>
[10:32:41.802] Packages needed by future strategies (n = 0): <none>
[10:32:41.803] {
[10:32:41.803]     {
[10:32:41.803]         {
[10:32:41.803]             ...future.startTime <- base::Sys.time()
[10:32:41.803]             {
[10:32:41.803]                 {
[10:32:41.803]                   {
[10:32:41.803]                     base::local({
[10:32:41.803]                       has_future <- base::requireNamespace("future", 
[10:32:41.803]                         quietly = TRUE)
[10:32:41.803]                       if (has_future) {
[10:32:41.803]                         ns <- base::getNamespace("future")
[10:32:41.803]                         version <- ns[[".package"]][["version"]]
[10:32:41.803]                         if (is.null(version)) 
[10:32:41.803]                           version <- utils::packageVersion("future")
[10:32:41.803]                       }
[10:32:41.803]                       else {
[10:32:41.803]                         version <- NULL
[10:32:41.803]                       }
[10:32:41.803]                       if (!has_future || version < "1.8.0") {
[10:32:41.803]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.803]                           "", base::R.version$version.string), 
[10:32:41.803]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.803]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.803]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.803]                             "release", "version")], collapse = " "), 
[10:32:41.803]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.803]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.803]                           info)
[10:32:41.803]                         info <- base::paste(info, collapse = "; ")
[10:32:41.803]                         if (!has_future) {
[10:32:41.803]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.803]                             info)
[10:32:41.803]                         }
[10:32:41.803]                         else {
[10:32:41.803]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.803]                             info, version)
[10:32:41.803]                         }
[10:32:41.803]                         base::stop(msg)
[10:32:41.803]                       }
[10:32:41.803]                     })
[10:32:41.803]                   }
[10:32:41.803]                   ...future.strategy.old <- future::plan("list")
[10:32:41.803]                   options(future.plan = NULL)
[10:32:41.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.803]                 }
[10:32:41.803]                 ...future.workdir <- getwd()
[10:32:41.803]             }
[10:32:41.803]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.803]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.803]         }
[10:32:41.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.803]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.803]             base::names(...future.oldOptions))
[10:32:41.803]     }
[10:32:41.803]     if (FALSE) {
[10:32:41.803]     }
[10:32:41.803]     else {
[10:32:41.803]         if (TRUE) {
[10:32:41.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.803]                 open = "w")
[10:32:41.803]         }
[10:32:41.803]         else {
[10:32:41.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.803]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.803]         }
[10:32:41.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.803]             base::sink(type = "output", split = FALSE)
[10:32:41.803]             base::close(...future.stdout)
[10:32:41.803]         }, add = TRUE)
[10:32:41.803]     }
[10:32:41.803]     ...future.frame <- base::sys.nframe()
[10:32:41.803]     ...future.conditions <- base::list()
[10:32:41.803]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.803]     if (FALSE) {
[10:32:41.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.803]     }
[10:32:41.803]     ...future.result <- base::tryCatch({
[10:32:41.803]         base::withCallingHandlers({
[10:32:41.803]             ...future.value <- base::withVisible(base::local({
[10:32:41.803]                 x <- a
[10:32:41.803]             }))
[10:32:41.803]             future::FutureResult(value = ...future.value$value, 
[10:32:41.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.803]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.803]                     ...future.globalenv.names))
[10:32:41.803]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.803]         }, condition = base::local({
[10:32:41.803]             c <- base::c
[10:32:41.803]             inherits <- base::inherits
[10:32:41.803]             invokeRestart <- base::invokeRestart
[10:32:41.803]             length <- base::length
[10:32:41.803]             list <- base::list
[10:32:41.803]             seq.int <- base::seq.int
[10:32:41.803]             signalCondition <- base::signalCondition
[10:32:41.803]             sys.calls <- base::sys.calls
[10:32:41.803]             `[[` <- base::`[[`
[10:32:41.803]             `+` <- base::`+`
[10:32:41.803]             `<<-` <- base::`<<-`
[10:32:41.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.803]                   3L)]
[10:32:41.803]             }
[10:32:41.803]             function(cond) {
[10:32:41.803]                 is_error <- inherits(cond, "error")
[10:32:41.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.803]                   NULL)
[10:32:41.803]                 if (is_error) {
[10:32:41.803]                   sessionInformation <- function() {
[10:32:41.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.803]                       search = base::search(), system = base::Sys.info())
[10:32:41.803]                   }
[10:32:41.803]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.803]                     cond$call), session = sessionInformation(), 
[10:32:41.803]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.803]                   signalCondition(cond)
[10:32:41.803]                 }
[10:32:41.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.803]                 "immediateCondition"))) {
[10:32:41.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.803]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.803]                   if (TRUE && !signal) {
[10:32:41.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.803]                     {
[10:32:41.803]                       inherits <- base::inherits
[10:32:41.803]                       invokeRestart <- base::invokeRestart
[10:32:41.803]                       is.null <- base::is.null
[10:32:41.803]                       muffled <- FALSE
[10:32:41.803]                       if (inherits(cond, "message")) {
[10:32:41.803]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.803]                         if (muffled) 
[10:32:41.803]                           invokeRestart("muffleMessage")
[10:32:41.803]                       }
[10:32:41.803]                       else if (inherits(cond, "warning")) {
[10:32:41.803]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.803]                         if (muffled) 
[10:32:41.803]                           invokeRestart("muffleWarning")
[10:32:41.803]                       }
[10:32:41.803]                       else if (inherits(cond, "condition")) {
[10:32:41.803]                         if (!is.null(pattern)) {
[10:32:41.803]                           computeRestarts <- base::computeRestarts
[10:32:41.803]                           grepl <- base::grepl
[10:32:41.803]                           restarts <- computeRestarts(cond)
[10:32:41.803]                           for (restart in restarts) {
[10:32:41.803]                             name <- restart$name
[10:32:41.803]                             if (is.null(name)) 
[10:32:41.803]                               next
[10:32:41.803]                             if (!grepl(pattern, name)) 
[10:32:41.803]                               next
[10:32:41.803]                             invokeRestart(restart)
[10:32:41.803]                             muffled <- TRUE
[10:32:41.803]                             break
[10:32:41.803]                           }
[10:32:41.803]                         }
[10:32:41.803]                       }
[10:32:41.803]                       invisible(muffled)
[10:32:41.803]                     }
[10:32:41.803]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.803]                   }
[10:32:41.803]                 }
[10:32:41.803]                 else {
[10:32:41.803]                   if (TRUE) {
[10:32:41.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.803]                     {
[10:32:41.803]                       inherits <- base::inherits
[10:32:41.803]                       invokeRestart <- base::invokeRestart
[10:32:41.803]                       is.null <- base::is.null
[10:32:41.803]                       muffled <- FALSE
[10:32:41.803]                       if (inherits(cond, "message")) {
[10:32:41.803]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.803]                         if (muffled) 
[10:32:41.803]                           invokeRestart("muffleMessage")
[10:32:41.803]                       }
[10:32:41.803]                       else if (inherits(cond, "warning")) {
[10:32:41.803]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.803]                         if (muffled) 
[10:32:41.803]                           invokeRestart("muffleWarning")
[10:32:41.803]                       }
[10:32:41.803]                       else if (inherits(cond, "condition")) {
[10:32:41.803]                         if (!is.null(pattern)) {
[10:32:41.803]                           computeRestarts <- base::computeRestarts
[10:32:41.803]                           grepl <- base::grepl
[10:32:41.803]                           restarts <- computeRestarts(cond)
[10:32:41.803]                           for (restart in restarts) {
[10:32:41.803]                             name <- restart$name
[10:32:41.803]                             if (is.null(name)) 
[10:32:41.803]                               next
[10:32:41.803]                             if (!grepl(pattern, name)) 
[10:32:41.803]                               next
[10:32:41.803]                             invokeRestart(restart)
[10:32:41.803]                             muffled <- TRUE
[10:32:41.803]                             break
[10:32:41.803]                           }
[10:32:41.803]                         }
[10:32:41.803]                       }
[10:32:41.803]                       invisible(muffled)
[10:32:41.803]                     }
[10:32:41.803]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.803]                   }
[10:32:41.803]                 }
[10:32:41.803]             }
[10:32:41.803]         }))
[10:32:41.803]     }, error = function(ex) {
[10:32:41.803]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.803]                 ...future.rng), started = ...future.startTime, 
[10:32:41.803]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.803]             version = "1.8"), class = "FutureResult")
[10:32:41.803]     }, finally = {
[10:32:41.803]         if (!identical(...future.workdir, getwd())) 
[10:32:41.803]             setwd(...future.workdir)
[10:32:41.803]         {
[10:32:41.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.803]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.803]             }
[10:32:41.803]             base::options(...future.oldOptions)
[10:32:41.803]             if (.Platform$OS.type == "windows") {
[10:32:41.803]                 old_names <- names(...future.oldEnvVars)
[10:32:41.803]                 envs <- base::Sys.getenv()
[10:32:41.803]                 names <- names(envs)
[10:32:41.803]                 common <- intersect(names, old_names)
[10:32:41.803]                 added <- setdiff(names, old_names)
[10:32:41.803]                 removed <- setdiff(old_names, names)
[10:32:41.803]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.803]                   envs[common]]
[10:32:41.803]                 NAMES <- toupper(changed)
[10:32:41.803]                 args <- list()
[10:32:41.803]                 for (kk in seq_along(NAMES)) {
[10:32:41.803]                   name <- changed[[kk]]
[10:32:41.803]                   NAME <- NAMES[[kk]]
[10:32:41.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.803]                     next
[10:32:41.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.803]                 }
[10:32:41.803]                 NAMES <- toupper(added)
[10:32:41.803]                 for (kk in seq_along(NAMES)) {
[10:32:41.803]                   name <- added[[kk]]
[10:32:41.803]                   NAME <- NAMES[[kk]]
[10:32:41.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.803]                     next
[10:32:41.803]                   args[[name]] <- ""
[10:32:41.803]                 }
[10:32:41.803]                 NAMES <- toupper(removed)
[10:32:41.803]                 for (kk in seq_along(NAMES)) {
[10:32:41.803]                   name <- removed[[kk]]
[10:32:41.803]                   NAME <- NAMES[[kk]]
[10:32:41.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.803]                     next
[10:32:41.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.803]                 }
[10:32:41.803]                 if (length(args) > 0) 
[10:32:41.803]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.803]             }
[10:32:41.803]             else {
[10:32:41.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.803]             }
[10:32:41.803]             {
[10:32:41.803]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.803]                   0L) {
[10:32:41.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.803]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.803]                   base::options(opts)
[10:32:41.803]                 }
[10:32:41.803]                 {
[10:32:41.803]                   {
[10:32:41.803]                     NULL
[10:32:41.803]                     RNGkind("Mersenne-Twister")
[10:32:41.803]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.803]                       inherits = FALSE)
[10:32:41.803]                   }
[10:32:41.803]                   options(future.plan = NULL)
[10:32:41.803]                   if (is.na(NA_character_)) 
[10:32:41.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.803]                     .init = FALSE)
[10:32:41.803]                 }
[10:32:41.803]             }
[10:32:41.803]         }
[10:32:41.803]     })
[10:32:41.803]     if (TRUE) {
[10:32:41.803]         base::sink(type = "output", split = FALSE)
[10:32:41.803]         if (TRUE) {
[10:32:41.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.803]         }
[10:32:41.803]         else {
[10:32:41.803]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.803]         }
[10:32:41.803]         base::close(...future.stdout)
[10:32:41.803]         ...future.stdout <- NULL
[10:32:41.803]     }
[10:32:41.803]     ...future.result$conditions <- ...future.conditions
[10:32:41.803]     ...future.result$finished <- base::Sys.time()
[10:32:41.803]     ...future.result
[10:32:41.803] }
[10:32:41.804] assign_globals() ...
[10:32:41.804] List of 1
[10:32:41.804]  $ a: num 2
[10:32:41.804]  - attr(*, "where")=List of 1
[10:32:41.804]   ..$ a:<environment: R_EmptyEnv> 
[10:32:41.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:41.804]  - attr(*, "resolved")= logi FALSE
[10:32:41.804]  - attr(*, "total_size")= num 56
[10:32:41.804]  - attr(*, "already-done")= logi TRUE
[10:32:41.812] - copied ‘a’ to environment
[10:32:41.813] assign_globals() ... done
[10:32:41.813] plan(): Setting new future strategy stack:
[10:32:41.813] List of future strategies:
[10:32:41.813] 1. sequential:
[10:32:41.813]    - args: function (..., envir = parent.frame())
[10:32:41.813]    - tweaked: FALSE
[10:32:41.813]    - call: NULL
[10:32:41.813] plan(): nbrOfWorkers() = 1
[10:32:41.814] plan(): Setting new future strategy stack:
[10:32:41.814] List of future strategies:
[10:32:41.814] 1. sequential:
[10:32:41.814]    - args: function (..., envir = parent.frame())
[10:32:41.814]    - tweaked: FALSE
[10:32:41.814]    - call: plan(strategy)
[10:32:41.815] plan(): nbrOfWorkers() = 1
[10:32:41.815] SequentialFuture started (and completed)
[10:32:41.815] - Launch lazy future ... done
[10:32:41.815] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[10:32:41.816] getGlobalsAndPackages() ...
[10:32:41.816] Searching for globals...
[10:32:41.819] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[10:32:41.819] Searching for globals ... DONE
[10:32:41.819] Resolving globals: FALSE
[10:32:41.820] 
[10:32:41.820] 
[10:32:41.820] getGlobalsAndPackages() ... DONE
[10:32:41.820] run() for ‘Future’ ...
[10:32:41.820] - state: ‘created’
[10:32:41.820] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.821]   - Field: ‘label’
[10:32:41.821]   - Field: ‘local’
[10:32:41.821]   - Field: ‘owner’
[10:32:41.821]   - Field: ‘envir’
[10:32:41.821]   - Field: ‘packages’
[10:32:41.821]   - Field: ‘gc’
[10:32:41.821]   - Field: ‘conditions’
[10:32:41.822]   - Field: ‘expr’
[10:32:41.822]   - Field: ‘uuid’
[10:32:41.822]   - Field: ‘seed’
[10:32:41.822]   - Field: ‘version’
[10:32:41.822]   - Field: ‘result’
[10:32:41.822]   - Field: ‘asynchronous’
[10:32:41.822]   - Field: ‘calls’
[10:32:41.822]   - Field: ‘globals’
[10:32:41.822]   - Field: ‘stdout’
[10:32:41.822]   - Field: ‘earlySignal’
[10:32:41.822]   - Field: ‘lazy’
[10:32:41.823]   - Field: ‘state’
[10:32:41.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.823] - Launch lazy future ...
[10:32:41.823] Packages needed by the future expression (n = 0): <none>
[10:32:41.823] Packages needed by future strategies (n = 0): <none>
[10:32:41.824] {
[10:32:41.824]     {
[10:32:41.824]         {
[10:32:41.824]             ...future.startTime <- base::Sys.time()
[10:32:41.824]             {
[10:32:41.824]                 {
[10:32:41.824]                   {
[10:32:41.824]                     base::local({
[10:32:41.824]                       has_future <- base::requireNamespace("future", 
[10:32:41.824]                         quietly = TRUE)
[10:32:41.824]                       if (has_future) {
[10:32:41.824]                         ns <- base::getNamespace("future")
[10:32:41.824]                         version <- ns[[".package"]][["version"]]
[10:32:41.824]                         if (is.null(version)) 
[10:32:41.824]                           version <- utils::packageVersion("future")
[10:32:41.824]                       }
[10:32:41.824]                       else {
[10:32:41.824]                         version <- NULL
[10:32:41.824]                       }
[10:32:41.824]                       if (!has_future || version < "1.8.0") {
[10:32:41.824]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.824]                           "", base::R.version$version.string), 
[10:32:41.824]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.824]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.824]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.824]                             "release", "version")], collapse = " "), 
[10:32:41.824]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.824]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.824]                           info)
[10:32:41.824]                         info <- base::paste(info, collapse = "; ")
[10:32:41.824]                         if (!has_future) {
[10:32:41.824]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.824]                             info)
[10:32:41.824]                         }
[10:32:41.824]                         else {
[10:32:41.824]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.824]                             info, version)
[10:32:41.824]                         }
[10:32:41.824]                         base::stop(msg)
[10:32:41.824]                       }
[10:32:41.824]                     })
[10:32:41.824]                   }
[10:32:41.824]                   ...future.strategy.old <- future::plan("list")
[10:32:41.824]                   options(future.plan = NULL)
[10:32:41.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.824]                 }
[10:32:41.824]                 ...future.workdir <- getwd()
[10:32:41.824]             }
[10:32:41.824]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.824]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.824]         }
[10:32:41.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.824]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.824]             base::names(...future.oldOptions))
[10:32:41.824]     }
[10:32:41.824]     if (FALSE) {
[10:32:41.824]     }
[10:32:41.824]     else {
[10:32:41.824]         if (TRUE) {
[10:32:41.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.824]                 open = "w")
[10:32:41.824]         }
[10:32:41.824]         else {
[10:32:41.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.824]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.824]         }
[10:32:41.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.824]             base::sink(type = "output", split = FALSE)
[10:32:41.824]             base::close(...future.stdout)
[10:32:41.824]         }, add = TRUE)
[10:32:41.824]     }
[10:32:41.824]     ...future.frame <- base::sys.nframe()
[10:32:41.824]     ...future.conditions <- base::list()
[10:32:41.824]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.824]     if (FALSE) {
[10:32:41.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.824]     }
[10:32:41.824]     ...future.result <- base::tryCatch({
[10:32:41.824]         base::withCallingHandlers({
[10:32:41.824]             ...future.value <- base::withVisible(base::local({
[10:32:41.824]                 x <- 3
[10:32:41.824]                 stop("Woops!")
[10:32:41.824]                 x
[10:32:41.824]             }))
[10:32:41.824]             future::FutureResult(value = ...future.value$value, 
[10:32:41.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.824]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.824]                     ...future.globalenv.names))
[10:32:41.824]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.824]         }, condition = base::local({
[10:32:41.824]             c <- base::c
[10:32:41.824]             inherits <- base::inherits
[10:32:41.824]             invokeRestart <- base::invokeRestart
[10:32:41.824]             length <- base::length
[10:32:41.824]             list <- base::list
[10:32:41.824]             seq.int <- base::seq.int
[10:32:41.824]             signalCondition <- base::signalCondition
[10:32:41.824]             sys.calls <- base::sys.calls
[10:32:41.824]             `[[` <- base::`[[`
[10:32:41.824]             `+` <- base::`+`
[10:32:41.824]             `<<-` <- base::`<<-`
[10:32:41.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.824]                   3L)]
[10:32:41.824]             }
[10:32:41.824]             function(cond) {
[10:32:41.824]                 is_error <- inherits(cond, "error")
[10:32:41.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.824]                   NULL)
[10:32:41.824]                 if (is_error) {
[10:32:41.824]                   sessionInformation <- function() {
[10:32:41.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.824]                       search = base::search(), system = base::Sys.info())
[10:32:41.824]                   }
[10:32:41.824]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.824]                     cond$call), session = sessionInformation(), 
[10:32:41.824]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.824]                   signalCondition(cond)
[10:32:41.824]                 }
[10:32:41.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.824]                 "immediateCondition"))) {
[10:32:41.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.824]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.824]                   if (TRUE && !signal) {
[10:32:41.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.824]                     {
[10:32:41.824]                       inherits <- base::inherits
[10:32:41.824]                       invokeRestart <- base::invokeRestart
[10:32:41.824]                       is.null <- base::is.null
[10:32:41.824]                       muffled <- FALSE
[10:32:41.824]                       if (inherits(cond, "message")) {
[10:32:41.824]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.824]                         if (muffled) 
[10:32:41.824]                           invokeRestart("muffleMessage")
[10:32:41.824]                       }
[10:32:41.824]                       else if (inherits(cond, "warning")) {
[10:32:41.824]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.824]                         if (muffled) 
[10:32:41.824]                           invokeRestart("muffleWarning")
[10:32:41.824]                       }
[10:32:41.824]                       else if (inherits(cond, "condition")) {
[10:32:41.824]                         if (!is.null(pattern)) {
[10:32:41.824]                           computeRestarts <- base::computeRestarts
[10:32:41.824]                           grepl <- base::grepl
[10:32:41.824]                           restarts <- computeRestarts(cond)
[10:32:41.824]                           for (restart in restarts) {
[10:32:41.824]                             name <- restart$name
[10:32:41.824]                             if (is.null(name)) 
[10:32:41.824]                               next
[10:32:41.824]                             if (!grepl(pattern, name)) 
[10:32:41.824]                               next
[10:32:41.824]                             invokeRestart(restart)
[10:32:41.824]                             muffled <- TRUE
[10:32:41.824]                             break
[10:32:41.824]                           }
[10:32:41.824]                         }
[10:32:41.824]                       }
[10:32:41.824]                       invisible(muffled)
[10:32:41.824]                     }
[10:32:41.824]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.824]                   }
[10:32:41.824]                 }
[10:32:41.824]                 else {
[10:32:41.824]                   if (TRUE) {
[10:32:41.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.824]                     {
[10:32:41.824]                       inherits <- base::inherits
[10:32:41.824]                       invokeRestart <- base::invokeRestart
[10:32:41.824]                       is.null <- base::is.null
[10:32:41.824]                       muffled <- FALSE
[10:32:41.824]                       if (inherits(cond, "message")) {
[10:32:41.824]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.824]                         if (muffled) 
[10:32:41.824]                           invokeRestart("muffleMessage")
[10:32:41.824]                       }
[10:32:41.824]                       else if (inherits(cond, "warning")) {
[10:32:41.824]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.824]                         if (muffled) 
[10:32:41.824]                           invokeRestart("muffleWarning")
[10:32:41.824]                       }
[10:32:41.824]                       else if (inherits(cond, "condition")) {
[10:32:41.824]                         if (!is.null(pattern)) {
[10:32:41.824]                           computeRestarts <- base::computeRestarts
[10:32:41.824]                           grepl <- base::grepl
[10:32:41.824]                           restarts <- computeRestarts(cond)
[10:32:41.824]                           for (restart in restarts) {
[10:32:41.824]                             name <- restart$name
[10:32:41.824]                             if (is.null(name)) 
[10:32:41.824]                               next
[10:32:41.824]                             if (!grepl(pattern, name)) 
[10:32:41.824]                               next
[10:32:41.824]                             invokeRestart(restart)
[10:32:41.824]                             muffled <- TRUE
[10:32:41.824]                             break
[10:32:41.824]                           }
[10:32:41.824]                         }
[10:32:41.824]                       }
[10:32:41.824]                       invisible(muffled)
[10:32:41.824]                     }
[10:32:41.824]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.824]                   }
[10:32:41.824]                 }
[10:32:41.824]             }
[10:32:41.824]         }))
[10:32:41.824]     }, error = function(ex) {
[10:32:41.824]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.824]                 ...future.rng), started = ...future.startTime, 
[10:32:41.824]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.824]             version = "1.8"), class = "FutureResult")
[10:32:41.824]     }, finally = {
[10:32:41.824]         if (!identical(...future.workdir, getwd())) 
[10:32:41.824]             setwd(...future.workdir)
[10:32:41.824]         {
[10:32:41.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.824]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.824]             }
[10:32:41.824]             base::options(...future.oldOptions)
[10:32:41.824]             if (.Platform$OS.type == "windows") {
[10:32:41.824]                 old_names <- names(...future.oldEnvVars)
[10:32:41.824]                 envs <- base::Sys.getenv()
[10:32:41.824]                 names <- names(envs)
[10:32:41.824]                 common <- intersect(names, old_names)
[10:32:41.824]                 added <- setdiff(names, old_names)
[10:32:41.824]                 removed <- setdiff(old_names, names)
[10:32:41.824]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.824]                   envs[common]]
[10:32:41.824]                 NAMES <- toupper(changed)
[10:32:41.824]                 args <- list()
[10:32:41.824]                 for (kk in seq_along(NAMES)) {
[10:32:41.824]                   name <- changed[[kk]]
[10:32:41.824]                   NAME <- NAMES[[kk]]
[10:32:41.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.824]                     next
[10:32:41.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.824]                 }
[10:32:41.824]                 NAMES <- toupper(added)
[10:32:41.824]                 for (kk in seq_along(NAMES)) {
[10:32:41.824]                   name <- added[[kk]]
[10:32:41.824]                   NAME <- NAMES[[kk]]
[10:32:41.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.824]                     next
[10:32:41.824]                   args[[name]] <- ""
[10:32:41.824]                 }
[10:32:41.824]                 NAMES <- toupper(removed)
[10:32:41.824]                 for (kk in seq_along(NAMES)) {
[10:32:41.824]                   name <- removed[[kk]]
[10:32:41.824]                   NAME <- NAMES[[kk]]
[10:32:41.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.824]                     next
[10:32:41.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.824]                 }
[10:32:41.824]                 if (length(args) > 0) 
[10:32:41.824]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.824]             }
[10:32:41.824]             else {
[10:32:41.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.824]             }
[10:32:41.824]             {
[10:32:41.824]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.824]                   0L) {
[10:32:41.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.824]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.824]                   base::options(opts)
[10:32:41.824]                 }
[10:32:41.824]                 {
[10:32:41.824]                   {
[10:32:41.824]                     NULL
[10:32:41.824]                     RNGkind("Mersenne-Twister")
[10:32:41.824]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.824]                       inherits = FALSE)
[10:32:41.824]                   }
[10:32:41.824]                   options(future.plan = NULL)
[10:32:41.824]                   if (is.na(NA_character_)) 
[10:32:41.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.824]                     .init = FALSE)
[10:32:41.824]                 }
[10:32:41.824]             }
[10:32:41.824]         }
[10:32:41.824]     })
[10:32:41.824]     if (TRUE) {
[10:32:41.824]         base::sink(type = "output", split = FALSE)
[10:32:41.824]         if (TRUE) {
[10:32:41.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.824]         }
[10:32:41.824]         else {
[10:32:41.824]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.824]         }
[10:32:41.824]         base::close(...future.stdout)
[10:32:41.824]         ...future.stdout <- NULL
[10:32:41.824]     }
[10:32:41.824]     ...future.result$conditions <- ...future.conditions
[10:32:41.824]     ...future.result$finished <- base::Sys.time()
[10:32:41.824]     ...future.result
[10:32:41.824] }
[10:32:41.825] plan(): Setting new future strategy stack:
[10:32:41.825] List of future strategies:
[10:32:41.825] 1. sequential:
[10:32:41.825]    - args: function (..., envir = parent.frame())
[10:32:41.825]    - tweaked: FALSE
[10:32:41.825]    - call: NULL
[10:32:41.826] plan(): nbrOfWorkers() = 1
[10:32:41.827] plan(): Setting new future strategy stack:
[10:32:41.827] List of future strategies:
[10:32:41.827] 1. sequential:
[10:32:41.827]    - args: function (..., envir = parent.frame())
[10:32:41.827]    - tweaked: FALSE
[10:32:41.827]    - call: plan(strategy)
[10:32:41.827] plan(): nbrOfWorkers() = 1
[10:32:41.827] SequentialFuture started (and completed)
[10:32:41.828] signalConditions() ...
[10:32:41.828]  - include = ‘immediateCondition’
[10:32:41.828]  - exclude = 
[10:32:41.828]  - resignal = FALSE
[10:32:41.828]  - Number of conditions: 1
[10:32:41.828] signalConditions() ... done
[10:32:41.828] - Launch lazy future ... done
[10:32:41.828] run() for ‘SequentialFuture’ ... done
[10:32:41.828] signalConditions() ...
[10:32:41.828]  - include = ‘immediateCondition’
[10:32:41.829]  - exclude = 
[10:32:41.829]  - resignal = FALSE
[10:32:41.829]  - Number of conditions: 1
[10:32:41.829] signalConditions() ... done
[10:32:41.829] Future state: ‘finished’
[10:32:41.829] signalConditions() ...
[10:32:41.829]  - include = ‘condition’
[10:32:41.829]  - exclude = ‘immediateCondition’
[10:32:41.829]  - resignal = TRUE
[10:32:41.830]  - Number of conditions: 1
[10:32:41.830]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:41.830] signalConditions() ... done
[10:32:41.831] getGlobalsAndPackages() ...
[10:32:41.831] Searching for globals...
[10:32:41.833] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:41.833] Searching for globals ... DONE
[10:32:41.833] Resolving globals: FALSE
[10:32:41.833] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:41.834] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:41.834] - globals: [1] ‘ii’
[10:32:41.834] 
[10:32:41.834] getGlobalsAndPackages() ... DONE
[10:32:41.834] run() for ‘Future’ ...
[10:32:41.834] - state: ‘created’
[10:32:41.834] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.835] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.835] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.835]   - Field: ‘label’
[10:32:41.835]   - Field: ‘local’
[10:32:41.835]   - Field: ‘owner’
[10:32:41.835]   - Field: ‘envir’
[10:32:41.835]   - Field: ‘packages’
[10:32:41.835]   - Field: ‘gc’
[10:32:41.836]   - Field: ‘conditions’
[10:32:41.836]   - Field: ‘expr’
[10:32:41.836]   - Field: ‘uuid’
[10:32:41.836]   - Field: ‘seed’
[10:32:41.836]   - Field: ‘version’
[10:32:41.836]   - Field: ‘result’
[10:32:41.836]   - Field: ‘asynchronous’
[10:32:41.836]   - Field: ‘calls’
[10:32:41.836]   - Field: ‘globals’
[10:32:41.836]   - Field: ‘stdout’
[10:32:41.836]   - Field: ‘earlySignal’
[10:32:41.837]   - Field: ‘lazy’
[10:32:41.837]   - Field: ‘state’
[10:32:41.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.837] - Launch lazy future ...
[10:32:41.837] Packages needed by the future expression (n = 0): <none>
[10:32:41.837] Packages needed by future strategies (n = 0): <none>
[10:32:41.838] {
[10:32:41.838]     {
[10:32:41.838]         {
[10:32:41.838]             ...future.startTime <- base::Sys.time()
[10:32:41.838]             {
[10:32:41.838]                 {
[10:32:41.838]                   {
[10:32:41.838]                     base::local({
[10:32:41.838]                       has_future <- base::requireNamespace("future", 
[10:32:41.838]                         quietly = TRUE)
[10:32:41.838]                       if (has_future) {
[10:32:41.838]                         ns <- base::getNamespace("future")
[10:32:41.838]                         version <- ns[[".package"]][["version"]]
[10:32:41.838]                         if (is.null(version)) 
[10:32:41.838]                           version <- utils::packageVersion("future")
[10:32:41.838]                       }
[10:32:41.838]                       else {
[10:32:41.838]                         version <- NULL
[10:32:41.838]                       }
[10:32:41.838]                       if (!has_future || version < "1.8.0") {
[10:32:41.838]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.838]                           "", base::R.version$version.string), 
[10:32:41.838]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.838]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.838]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.838]                             "release", "version")], collapse = " "), 
[10:32:41.838]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.838]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.838]                           info)
[10:32:41.838]                         info <- base::paste(info, collapse = "; ")
[10:32:41.838]                         if (!has_future) {
[10:32:41.838]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.838]                             info)
[10:32:41.838]                         }
[10:32:41.838]                         else {
[10:32:41.838]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.838]                             info, version)
[10:32:41.838]                         }
[10:32:41.838]                         base::stop(msg)
[10:32:41.838]                       }
[10:32:41.838]                     })
[10:32:41.838]                   }
[10:32:41.838]                   ...future.strategy.old <- future::plan("list")
[10:32:41.838]                   options(future.plan = NULL)
[10:32:41.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.838]                 }
[10:32:41.838]                 ...future.workdir <- getwd()
[10:32:41.838]             }
[10:32:41.838]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.838]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.838]         }
[10:32:41.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.838]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.838]             base::names(...future.oldOptions))
[10:32:41.838]     }
[10:32:41.838]     if (FALSE) {
[10:32:41.838]     }
[10:32:41.838]     else {
[10:32:41.838]         if (TRUE) {
[10:32:41.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.838]                 open = "w")
[10:32:41.838]         }
[10:32:41.838]         else {
[10:32:41.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.838]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.838]         }
[10:32:41.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.838]             base::sink(type = "output", split = FALSE)
[10:32:41.838]             base::close(...future.stdout)
[10:32:41.838]         }, add = TRUE)
[10:32:41.838]     }
[10:32:41.838]     ...future.frame <- base::sys.nframe()
[10:32:41.838]     ...future.conditions <- base::list()
[10:32:41.838]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.838]     if (FALSE) {
[10:32:41.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.838]     }
[10:32:41.838]     ...future.result <- base::tryCatch({
[10:32:41.838]         base::withCallingHandlers({
[10:32:41.838]             ...future.value <- base::withVisible(base::local({
[10:32:41.838]                 if (ii%%2 == 0) 
[10:32:41.838]                   stop("Woops!")
[10:32:41.838]                 ii
[10:32:41.838]             }))
[10:32:41.838]             future::FutureResult(value = ...future.value$value, 
[10:32:41.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.838]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.838]                     ...future.globalenv.names))
[10:32:41.838]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.838]         }, condition = base::local({
[10:32:41.838]             c <- base::c
[10:32:41.838]             inherits <- base::inherits
[10:32:41.838]             invokeRestart <- base::invokeRestart
[10:32:41.838]             length <- base::length
[10:32:41.838]             list <- base::list
[10:32:41.838]             seq.int <- base::seq.int
[10:32:41.838]             signalCondition <- base::signalCondition
[10:32:41.838]             sys.calls <- base::sys.calls
[10:32:41.838]             `[[` <- base::`[[`
[10:32:41.838]             `+` <- base::`+`
[10:32:41.838]             `<<-` <- base::`<<-`
[10:32:41.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.838]                   3L)]
[10:32:41.838]             }
[10:32:41.838]             function(cond) {
[10:32:41.838]                 is_error <- inherits(cond, "error")
[10:32:41.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.838]                   NULL)
[10:32:41.838]                 if (is_error) {
[10:32:41.838]                   sessionInformation <- function() {
[10:32:41.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.838]                       search = base::search(), system = base::Sys.info())
[10:32:41.838]                   }
[10:32:41.838]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.838]                     cond$call), session = sessionInformation(), 
[10:32:41.838]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.838]                   signalCondition(cond)
[10:32:41.838]                 }
[10:32:41.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.838]                 "immediateCondition"))) {
[10:32:41.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.838]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.838]                   if (TRUE && !signal) {
[10:32:41.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.838]                     {
[10:32:41.838]                       inherits <- base::inherits
[10:32:41.838]                       invokeRestart <- base::invokeRestart
[10:32:41.838]                       is.null <- base::is.null
[10:32:41.838]                       muffled <- FALSE
[10:32:41.838]                       if (inherits(cond, "message")) {
[10:32:41.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.838]                         if (muffled) 
[10:32:41.838]                           invokeRestart("muffleMessage")
[10:32:41.838]                       }
[10:32:41.838]                       else if (inherits(cond, "warning")) {
[10:32:41.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.838]                         if (muffled) 
[10:32:41.838]                           invokeRestart("muffleWarning")
[10:32:41.838]                       }
[10:32:41.838]                       else if (inherits(cond, "condition")) {
[10:32:41.838]                         if (!is.null(pattern)) {
[10:32:41.838]                           computeRestarts <- base::computeRestarts
[10:32:41.838]                           grepl <- base::grepl
[10:32:41.838]                           restarts <- computeRestarts(cond)
[10:32:41.838]                           for (restart in restarts) {
[10:32:41.838]                             name <- restart$name
[10:32:41.838]                             if (is.null(name)) 
[10:32:41.838]                               next
[10:32:41.838]                             if (!grepl(pattern, name)) 
[10:32:41.838]                               next
[10:32:41.838]                             invokeRestart(restart)
[10:32:41.838]                             muffled <- TRUE
[10:32:41.838]                             break
[10:32:41.838]                           }
[10:32:41.838]                         }
[10:32:41.838]                       }
[10:32:41.838]                       invisible(muffled)
[10:32:41.838]                     }
[10:32:41.838]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.838]                   }
[10:32:41.838]                 }
[10:32:41.838]                 else {
[10:32:41.838]                   if (TRUE) {
[10:32:41.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.838]                     {
[10:32:41.838]                       inherits <- base::inherits
[10:32:41.838]                       invokeRestart <- base::invokeRestart
[10:32:41.838]                       is.null <- base::is.null
[10:32:41.838]                       muffled <- FALSE
[10:32:41.838]                       if (inherits(cond, "message")) {
[10:32:41.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.838]                         if (muffled) 
[10:32:41.838]                           invokeRestart("muffleMessage")
[10:32:41.838]                       }
[10:32:41.838]                       else if (inherits(cond, "warning")) {
[10:32:41.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.838]                         if (muffled) 
[10:32:41.838]                           invokeRestart("muffleWarning")
[10:32:41.838]                       }
[10:32:41.838]                       else if (inherits(cond, "condition")) {
[10:32:41.838]                         if (!is.null(pattern)) {
[10:32:41.838]                           computeRestarts <- base::computeRestarts
[10:32:41.838]                           grepl <- base::grepl
[10:32:41.838]                           restarts <- computeRestarts(cond)
[10:32:41.838]                           for (restart in restarts) {
[10:32:41.838]                             name <- restart$name
[10:32:41.838]                             if (is.null(name)) 
[10:32:41.838]                               next
[10:32:41.838]                             if (!grepl(pattern, name)) 
[10:32:41.838]                               next
[10:32:41.838]                             invokeRestart(restart)
[10:32:41.838]                             muffled <- TRUE
[10:32:41.838]                             break
[10:32:41.838]                           }
[10:32:41.838]                         }
[10:32:41.838]                       }
[10:32:41.838]                       invisible(muffled)
[10:32:41.838]                     }
[10:32:41.838]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.838]                   }
[10:32:41.838]                 }
[10:32:41.838]             }
[10:32:41.838]         }))
[10:32:41.838]     }, error = function(ex) {
[10:32:41.838]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.838]                 ...future.rng), started = ...future.startTime, 
[10:32:41.838]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.838]             version = "1.8"), class = "FutureResult")
[10:32:41.838]     }, finally = {
[10:32:41.838]         if (!identical(...future.workdir, getwd())) 
[10:32:41.838]             setwd(...future.workdir)
[10:32:41.838]         {
[10:32:41.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.838]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.838]             }
[10:32:41.838]             base::options(...future.oldOptions)
[10:32:41.838]             if (.Platform$OS.type == "windows") {
[10:32:41.838]                 old_names <- names(...future.oldEnvVars)
[10:32:41.838]                 envs <- base::Sys.getenv()
[10:32:41.838]                 names <- names(envs)
[10:32:41.838]                 common <- intersect(names, old_names)
[10:32:41.838]                 added <- setdiff(names, old_names)
[10:32:41.838]                 removed <- setdiff(old_names, names)
[10:32:41.838]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.838]                   envs[common]]
[10:32:41.838]                 NAMES <- toupper(changed)
[10:32:41.838]                 args <- list()
[10:32:41.838]                 for (kk in seq_along(NAMES)) {
[10:32:41.838]                   name <- changed[[kk]]
[10:32:41.838]                   NAME <- NAMES[[kk]]
[10:32:41.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.838]                     next
[10:32:41.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.838]                 }
[10:32:41.838]                 NAMES <- toupper(added)
[10:32:41.838]                 for (kk in seq_along(NAMES)) {
[10:32:41.838]                   name <- added[[kk]]
[10:32:41.838]                   NAME <- NAMES[[kk]]
[10:32:41.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.838]                     next
[10:32:41.838]                   args[[name]] <- ""
[10:32:41.838]                 }
[10:32:41.838]                 NAMES <- toupper(removed)
[10:32:41.838]                 for (kk in seq_along(NAMES)) {
[10:32:41.838]                   name <- removed[[kk]]
[10:32:41.838]                   NAME <- NAMES[[kk]]
[10:32:41.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.838]                     next
[10:32:41.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.838]                 }
[10:32:41.838]                 if (length(args) > 0) 
[10:32:41.838]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.838]             }
[10:32:41.838]             else {
[10:32:41.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.838]             }
[10:32:41.838]             {
[10:32:41.838]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.838]                   0L) {
[10:32:41.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.838]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.838]                   base::options(opts)
[10:32:41.838]                 }
[10:32:41.838]                 {
[10:32:41.838]                   {
[10:32:41.838]                     NULL
[10:32:41.838]                     RNGkind("Mersenne-Twister")
[10:32:41.838]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.838]                       inherits = FALSE)
[10:32:41.838]                   }
[10:32:41.838]                   options(future.plan = NULL)
[10:32:41.838]                   if (is.na(NA_character_)) 
[10:32:41.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.838]                     .init = FALSE)
[10:32:41.838]                 }
[10:32:41.838]             }
[10:32:41.838]         }
[10:32:41.838]     })
[10:32:41.838]     if (TRUE) {
[10:32:41.838]         base::sink(type = "output", split = FALSE)
[10:32:41.838]         if (TRUE) {
[10:32:41.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.838]         }
[10:32:41.838]         else {
[10:32:41.838]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.838]         }
[10:32:41.838]         base::close(...future.stdout)
[10:32:41.838]         ...future.stdout <- NULL
[10:32:41.838]     }
[10:32:41.838]     ...future.result$conditions <- ...future.conditions
[10:32:41.838]     ...future.result$finished <- base::Sys.time()
[10:32:41.838]     ...future.result
[10:32:41.838] }
[10:32:41.839] assign_globals() ...
[10:32:41.839] List of 1
[10:32:41.839]  $ ii: int 1
[10:32:41.839]  - attr(*, "where")=List of 1
[10:32:41.839]   ..$ ii:<environment: R_EmptyEnv> 
[10:32:41.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:41.839]  - attr(*, "resolved")= logi FALSE
[10:32:41.839]  - attr(*, "total_size")= num 56
[10:32:41.839]  - attr(*, "already-done")= logi TRUE
[10:32:41.844] - copied ‘ii’ to environment
[10:32:41.844] assign_globals() ... done
[10:32:41.844] plan(): Setting new future strategy stack:
[10:32:41.844] List of future strategies:
[10:32:41.844] 1. sequential:
[10:32:41.844]    - args: function (..., envir = parent.frame())
[10:32:41.844]    - tweaked: FALSE
[10:32:41.844]    - call: NULL
[10:32:41.844] plan(): nbrOfWorkers() = 1
[10:32:41.845] plan(): Setting new future strategy stack:
[10:32:41.845] List of future strategies:
[10:32:41.845] 1. sequential:
[10:32:41.845]    - args: function (..., envir = parent.frame())
[10:32:41.845]    - tweaked: FALSE
[10:32:41.845]    - call: plan(strategy)
[10:32:41.846] plan(): nbrOfWorkers() = 1
[10:32:41.846] SequentialFuture started (and completed)
[10:32:41.846] - Launch lazy future ... done
[10:32:41.846] run() for ‘SequentialFuture’ ... done
[10:32:41.846] getGlobalsAndPackages() ...
[10:32:41.847] Searching for globals...
[10:32:41.848] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:41.848] Searching for globals ... DONE
[10:32:41.848] Resolving globals: FALSE
[10:32:41.849] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:41.849] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:41.849] - globals: [1] ‘ii’
[10:32:41.849] 
[10:32:41.849] getGlobalsAndPackages() ... DONE
[10:32:41.850] run() for ‘Future’ ...
[10:32:41.850] - state: ‘created’
[10:32:41.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.850]   - Field: ‘label’
[10:32:41.850]   - Field: ‘local’
[10:32:41.851]   - Field: ‘owner’
[10:32:41.851]   - Field: ‘envir’
[10:32:41.851]   - Field: ‘packages’
[10:32:41.851]   - Field: ‘gc’
[10:32:41.851]   - Field: ‘conditions’
[10:32:41.851]   - Field: ‘expr’
[10:32:41.851]   - Field: ‘uuid’
[10:32:41.851]   - Field: ‘seed’
[10:32:41.851]   - Field: ‘version’
[10:32:41.851]   - Field: ‘result’
[10:32:41.852]   - Field: ‘asynchronous’
[10:32:41.852]   - Field: ‘calls’
[10:32:41.852]   - Field: ‘globals’
[10:32:41.852]   - Field: ‘stdout’
[10:32:41.852]   - Field: ‘earlySignal’
[10:32:41.852]   - Field: ‘lazy’
[10:32:41.852]   - Field: ‘state’
[10:32:41.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.852] - Launch lazy future ...
[10:32:41.852] Packages needed by the future expression (n = 0): <none>
[10:32:41.853] Packages needed by future strategies (n = 0): <none>
[10:32:41.853] {
[10:32:41.853]     {
[10:32:41.853]         {
[10:32:41.853]             ...future.startTime <- base::Sys.time()
[10:32:41.853]             {
[10:32:41.853]                 {
[10:32:41.853]                   {
[10:32:41.853]                     base::local({
[10:32:41.853]                       has_future <- base::requireNamespace("future", 
[10:32:41.853]                         quietly = TRUE)
[10:32:41.853]                       if (has_future) {
[10:32:41.853]                         ns <- base::getNamespace("future")
[10:32:41.853]                         version <- ns[[".package"]][["version"]]
[10:32:41.853]                         if (is.null(version)) 
[10:32:41.853]                           version <- utils::packageVersion("future")
[10:32:41.853]                       }
[10:32:41.853]                       else {
[10:32:41.853]                         version <- NULL
[10:32:41.853]                       }
[10:32:41.853]                       if (!has_future || version < "1.8.0") {
[10:32:41.853]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.853]                           "", base::R.version$version.string), 
[10:32:41.853]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.853]                             "release", "version")], collapse = " "), 
[10:32:41.853]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.853]                           info)
[10:32:41.853]                         info <- base::paste(info, collapse = "; ")
[10:32:41.853]                         if (!has_future) {
[10:32:41.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.853]                             info)
[10:32:41.853]                         }
[10:32:41.853]                         else {
[10:32:41.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.853]                             info, version)
[10:32:41.853]                         }
[10:32:41.853]                         base::stop(msg)
[10:32:41.853]                       }
[10:32:41.853]                     })
[10:32:41.853]                   }
[10:32:41.853]                   ...future.strategy.old <- future::plan("list")
[10:32:41.853]                   options(future.plan = NULL)
[10:32:41.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.853]                 }
[10:32:41.853]                 ...future.workdir <- getwd()
[10:32:41.853]             }
[10:32:41.853]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.853]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.853]         }
[10:32:41.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.853]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.853]             base::names(...future.oldOptions))
[10:32:41.853]     }
[10:32:41.853]     if (FALSE) {
[10:32:41.853]     }
[10:32:41.853]     else {
[10:32:41.853]         if (TRUE) {
[10:32:41.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.853]                 open = "w")
[10:32:41.853]         }
[10:32:41.853]         else {
[10:32:41.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.853]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.853]         }
[10:32:41.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.853]             base::sink(type = "output", split = FALSE)
[10:32:41.853]             base::close(...future.stdout)
[10:32:41.853]         }, add = TRUE)
[10:32:41.853]     }
[10:32:41.853]     ...future.frame <- base::sys.nframe()
[10:32:41.853]     ...future.conditions <- base::list()
[10:32:41.853]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.853]     if (FALSE) {
[10:32:41.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.853]     }
[10:32:41.853]     ...future.result <- base::tryCatch({
[10:32:41.853]         base::withCallingHandlers({
[10:32:41.853]             ...future.value <- base::withVisible(base::local({
[10:32:41.853]                 if (ii%%2 == 0) 
[10:32:41.853]                   stop("Woops!")
[10:32:41.853]                 ii
[10:32:41.853]             }))
[10:32:41.853]             future::FutureResult(value = ...future.value$value, 
[10:32:41.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.853]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.853]                     ...future.globalenv.names))
[10:32:41.853]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.853]         }, condition = base::local({
[10:32:41.853]             c <- base::c
[10:32:41.853]             inherits <- base::inherits
[10:32:41.853]             invokeRestart <- base::invokeRestart
[10:32:41.853]             length <- base::length
[10:32:41.853]             list <- base::list
[10:32:41.853]             seq.int <- base::seq.int
[10:32:41.853]             signalCondition <- base::signalCondition
[10:32:41.853]             sys.calls <- base::sys.calls
[10:32:41.853]             `[[` <- base::`[[`
[10:32:41.853]             `+` <- base::`+`
[10:32:41.853]             `<<-` <- base::`<<-`
[10:32:41.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.853]                   3L)]
[10:32:41.853]             }
[10:32:41.853]             function(cond) {
[10:32:41.853]                 is_error <- inherits(cond, "error")
[10:32:41.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.853]                   NULL)
[10:32:41.853]                 if (is_error) {
[10:32:41.853]                   sessionInformation <- function() {
[10:32:41.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.853]                       search = base::search(), system = base::Sys.info())
[10:32:41.853]                   }
[10:32:41.853]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.853]                     cond$call), session = sessionInformation(), 
[10:32:41.853]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.853]                   signalCondition(cond)
[10:32:41.853]                 }
[10:32:41.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.853]                 "immediateCondition"))) {
[10:32:41.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.853]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.853]                   if (TRUE && !signal) {
[10:32:41.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.853]                     {
[10:32:41.853]                       inherits <- base::inherits
[10:32:41.853]                       invokeRestart <- base::invokeRestart
[10:32:41.853]                       is.null <- base::is.null
[10:32:41.853]                       muffled <- FALSE
[10:32:41.853]                       if (inherits(cond, "message")) {
[10:32:41.853]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.853]                         if (muffled) 
[10:32:41.853]                           invokeRestart("muffleMessage")
[10:32:41.853]                       }
[10:32:41.853]                       else if (inherits(cond, "warning")) {
[10:32:41.853]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.853]                         if (muffled) 
[10:32:41.853]                           invokeRestart("muffleWarning")
[10:32:41.853]                       }
[10:32:41.853]                       else if (inherits(cond, "condition")) {
[10:32:41.853]                         if (!is.null(pattern)) {
[10:32:41.853]                           computeRestarts <- base::computeRestarts
[10:32:41.853]                           grepl <- base::grepl
[10:32:41.853]                           restarts <- computeRestarts(cond)
[10:32:41.853]                           for (restart in restarts) {
[10:32:41.853]                             name <- restart$name
[10:32:41.853]                             if (is.null(name)) 
[10:32:41.853]                               next
[10:32:41.853]                             if (!grepl(pattern, name)) 
[10:32:41.853]                               next
[10:32:41.853]                             invokeRestart(restart)
[10:32:41.853]                             muffled <- TRUE
[10:32:41.853]                             break
[10:32:41.853]                           }
[10:32:41.853]                         }
[10:32:41.853]                       }
[10:32:41.853]                       invisible(muffled)
[10:32:41.853]                     }
[10:32:41.853]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.853]                   }
[10:32:41.853]                 }
[10:32:41.853]                 else {
[10:32:41.853]                   if (TRUE) {
[10:32:41.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.853]                     {
[10:32:41.853]                       inherits <- base::inherits
[10:32:41.853]                       invokeRestart <- base::invokeRestart
[10:32:41.853]                       is.null <- base::is.null
[10:32:41.853]                       muffled <- FALSE
[10:32:41.853]                       if (inherits(cond, "message")) {
[10:32:41.853]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.853]                         if (muffled) 
[10:32:41.853]                           invokeRestart("muffleMessage")
[10:32:41.853]                       }
[10:32:41.853]                       else if (inherits(cond, "warning")) {
[10:32:41.853]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.853]                         if (muffled) 
[10:32:41.853]                           invokeRestart("muffleWarning")
[10:32:41.853]                       }
[10:32:41.853]                       else if (inherits(cond, "condition")) {
[10:32:41.853]                         if (!is.null(pattern)) {
[10:32:41.853]                           computeRestarts <- base::computeRestarts
[10:32:41.853]                           grepl <- base::grepl
[10:32:41.853]                           restarts <- computeRestarts(cond)
[10:32:41.853]                           for (restart in restarts) {
[10:32:41.853]                             name <- restart$name
[10:32:41.853]                             if (is.null(name)) 
[10:32:41.853]                               next
[10:32:41.853]                             if (!grepl(pattern, name)) 
[10:32:41.853]                               next
[10:32:41.853]                             invokeRestart(restart)
[10:32:41.853]                             muffled <- TRUE
[10:32:41.853]                             break
[10:32:41.853]                           }
[10:32:41.853]                         }
[10:32:41.853]                       }
[10:32:41.853]                       invisible(muffled)
[10:32:41.853]                     }
[10:32:41.853]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.853]                   }
[10:32:41.853]                 }
[10:32:41.853]             }
[10:32:41.853]         }))
[10:32:41.853]     }, error = function(ex) {
[10:32:41.853]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.853]                 ...future.rng), started = ...future.startTime, 
[10:32:41.853]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.853]             version = "1.8"), class = "FutureResult")
[10:32:41.853]     }, finally = {
[10:32:41.853]         if (!identical(...future.workdir, getwd())) 
[10:32:41.853]             setwd(...future.workdir)
[10:32:41.853]         {
[10:32:41.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.853]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.853]             }
[10:32:41.853]             base::options(...future.oldOptions)
[10:32:41.853]             if (.Platform$OS.type == "windows") {
[10:32:41.853]                 old_names <- names(...future.oldEnvVars)
[10:32:41.853]                 envs <- base::Sys.getenv()
[10:32:41.853]                 names <- names(envs)
[10:32:41.853]                 common <- intersect(names, old_names)
[10:32:41.853]                 added <- setdiff(names, old_names)
[10:32:41.853]                 removed <- setdiff(old_names, names)
[10:32:41.853]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.853]                   envs[common]]
[10:32:41.853]                 NAMES <- toupper(changed)
[10:32:41.853]                 args <- list()
[10:32:41.853]                 for (kk in seq_along(NAMES)) {
[10:32:41.853]                   name <- changed[[kk]]
[10:32:41.853]                   NAME <- NAMES[[kk]]
[10:32:41.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.853]                     next
[10:32:41.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.853]                 }
[10:32:41.853]                 NAMES <- toupper(added)
[10:32:41.853]                 for (kk in seq_along(NAMES)) {
[10:32:41.853]                   name <- added[[kk]]
[10:32:41.853]                   NAME <- NAMES[[kk]]
[10:32:41.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.853]                     next
[10:32:41.853]                   args[[name]] <- ""
[10:32:41.853]                 }
[10:32:41.853]                 NAMES <- toupper(removed)
[10:32:41.853]                 for (kk in seq_along(NAMES)) {
[10:32:41.853]                   name <- removed[[kk]]
[10:32:41.853]                   NAME <- NAMES[[kk]]
[10:32:41.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.853]                     next
[10:32:41.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.853]                 }
[10:32:41.853]                 if (length(args) > 0) 
[10:32:41.853]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.853]             }
[10:32:41.853]             else {
[10:32:41.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.853]             }
[10:32:41.853]             {
[10:32:41.853]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.853]                   0L) {
[10:32:41.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.853]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.853]                   base::options(opts)
[10:32:41.853]                 }
[10:32:41.853]                 {
[10:32:41.853]                   {
[10:32:41.853]                     NULL
[10:32:41.853]                     RNGkind("Mersenne-Twister")
[10:32:41.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.853]                       inherits = FALSE)
[10:32:41.853]                   }
[10:32:41.853]                   options(future.plan = NULL)
[10:32:41.853]                   if (is.na(NA_character_)) 
[10:32:41.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.853]                     .init = FALSE)
[10:32:41.853]                 }
[10:32:41.853]             }
[10:32:41.853]         }
[10:32:41.853]     })
[10:32:41.853]     if (TRUE) {
[10:32:41.853]         base::sink(type = "output", split = FALSE)
[10:32:41.853]         if (TRUE) {
[10:32:41.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.853]         }
[10:32:41.853]         else {
[10:32:41.853]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.853]         }
[10:32:41.853]         base::close(...future.stdout)
[10:32:41.853]         ...future.stdout <- NULL
[10:32:41.853]     }
[10:32:41.853]     ...future.result$conditions <- ...future.conditions
[10:32:41.853]     ...future.result$finished <- base::Sys.time()
[10:32:41.853]     ...future.result
[10:32:41.853] }
[10:32:41.855] assign_globals() ...
[10:32:41.855] List of 1
[10:32:41.855]  $ ii: int 2
[10:32:41.855]  - attr(*, "where")=List of 1
[10:32:41.855]   ..$ ii:<environment: R_EmptyEnv> 
[10:32:41.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:41.855]  - attr(*, "resolved")= logi FALSE
[10:32:41.855]  - attr(*, "total_size")= num 56
[10:32:41.855]  - attr(*, "already-done")= logi TRUE
[10:32:41.857] - copied ‘ii’ to environment
[10:32:41.857] assign_globals() ... done
[10:32:41.857] plan(): Setting new future strategy stack:
[10:32:41.857] List of future strategies:
[10:32:41.857] 1. sequential:
[10:32:41.857]    - args: function (..., envir = parent.frame())
[10:32:41.857]    - tweaked: FALSE
[10:32:41.857]    - call: NULL
[10:32:41.858] plan(): nbrOfWorkers() = 1
[10:32:41.859] plan(): Setting new future strategy stack:
[10:32:41.859] List of future strategies:
[10:32:41.859] 1. sequential:
[10:32:41.859]    - args: function (..., envir = parent.frame())
[10:32:41.859]    - tweaked: FALSE
[10:32:41.859]    - call: plan(strategy)
[10:32:41.859] plan(): nbrOfWorkers() = 1
[10:32:41.859] SequentialFuture started (and completed)
[10:32:41.859] signalConditions() ...
[10:32:41.859]  - include = ‘immediateCondition’
[10:32:41.860]  - exclude = 
[10:32:41.860]  - resignal = FALSE
[10:32:41.860]  - Number of conditions: 1
[10:32:41.860] signalConditions() ... done
[10:32:41.860] - Launch lazy future ... done
[10:32:41.860] run() for ‘SequentialFuture’ ... done
[10:32:41.860] getGlobalsAndPackages() ...
[10:32:41.860] Searching for globals...
[10:32:41.862] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:41.862] Searching for globals ... DONE
[10:32:41.862] Resolving globals: FALSE
[10:32:41.863] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:41.863] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:41.863] - globals: [1] ‘ii’
[10:32:41.863] 
[10:32:41.863] getGlobalsAndPackages() ... DONE
[10:32:41.863] run() for ‘Future’ ...
[10:32:41.864] - state: ‘created’
[10:32:41.864] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.864] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.864]   - Field: ‘label’
[10:32:41.864]   - Field: ‘local’
[10:32:41.864]   - Field: ‘owner’
[10:32:41.864]   - Field: ‘envir’
[10:32:41.865]   - Field: ‘packages’
[10:32:41.865]   - Field: ‘gc’
[10:32:41.865]   - Field: ‘conditions’
[10:32:41.865]   - Field: ‘expr’
[10:32:41.865]   - Field: ‘uuid’
[10:32:41.865]   - Field: ‘seed’
[10:32:41.865]   - Field: ‘version’
[10:32:41.865]   - Field: ‘result’
[10:32:41.865]   - Field: ‘asynchronous’
[10:32:41.865]   - Field: ‘calls’
[10:32:41.865]   - Field: ‘globals’
[10:32:41.866]   - Field: ‘stdout’
[10:32:41.866]   - Field: ‘earlySignal’
[10:32:41.866]   - Field: ‘lazy’
[10:32:41.866]   - Field: ‘state’
[10:32:41.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.866] - Launch lazy future ...
[10:32:41.866] Packages needed by the future expression (n = 0): <none>
[10:32:41.866] Packages needed by future strategies (n = 0): <none>
[10:32:41.867] {
[10:32:41.867]     {
[10:32:41.867]         {
[10:32:41.867]             ...future.startTime <- base::Sys.time()
[10:32:41.867]             {
[10:32:41.867]                 {
[10:32:41.867]                   {
[10:32:41.867]                     base::local({
[10:32:41.867]                       has_future <- base::requireNamespace("future", 
[10:32:41.867]                         quietly = TRUE)
[10:32:41.867]                       if (has_future) {
[10:32:41.867]                         ns <- base::getNamespace("future")
[10:32:41.867]                         version <- ns[[".package"]][["version"]]
[10:32:41.867]                         if (is.null(version)) 
[10:32:41.867]                           version <- utils::packageVersion("future")
[10:32:41.867]                       }
[10:32:41.867]                       else {
[10:32:41.867]                         version <- NULL
[10:32:41.867]                       }
[10:32:41.867]                       if (!has_future || version < "1.8.0") {
[10:32:41.867]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.867]                           "", base::R.version$version.string), 
[10:32:41.867]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.867]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.867]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.867]                             "release", "version")], collapse = " "), 
[10:32:41.867]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.867]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.867]                           info)
[10:32:41.867]                         info <- base::paste(info, collapse = "; ")
[10:32:41.867]                         if (!has_future) {
[10:32:41.867]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.867]                             info)
[10:32:41.867]                         }
[10:32:41.867]                         else {
[10:32:41.867]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.867]                             info, version)
[10:32:41.867]                         }
[10:32:41.867]                         base::stop(msg)
[10:32:41.867]                       }
[10:32:41.867]                     })
[10:32:41.867]                   }
[10:32:41.867]                   ...future.strategy.old <- future::plan("list")
[10:32:41.867]                   options(future.plan = NULL)
[10:32:41.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.867]                 }
[10:32:41.867]                 ...future.workdir <- getwd()
[10:32:41.867]             }
[10:32:41.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.867]         }
[10:32:41.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.867]             base::names(...future.oldOptions))
[10:32:41.867]     }
[10:32:41.867]     if (FALSE) {
[10:32:41.867]     }
[10:32:41.867]     else {
[10:32:41.867]         if (TRUE) {
[10:32:41.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.867]                 open = "w")
[10:32:41.867]         }
[10:32:41.867]         else {
[10:32:41.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.867]         }
[10:32:41.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.867]             base::sink(type = "output", split = FALSE)
[10:32:41.867]             base::close(...future.stdout)
[10:32:41.867]         }, add = TRUE)
[10:32:41.867]     }
[10:32:41.867]     ...future.frame <- base::sys.nframe()
[10:32:41.867]     ...future.conditions <- base::list()
[10:32:41.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.867]     if (FALSE) {
[10:32:41.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.867]     }
[10:32:41.867]     ...future.result <- base::tryCatch({
[10:32:41.867]         base::withCallingHandlers({
[10:32:41.867]             ...future.value <- base::withVisible(base::local({
[10:32:41.867]                 if (ii%%2 == 0) 
[10:32:41.867]                   stop("Woops!")
[10:32:41.867]                 ii
[10:32:41.867]             }))
[10:32:41.867]             future::FutureResult(value = ...future.value$value, 
[10:32:41.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.867]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.867]                     ...future.globalenv.names))
[10:32:41.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.867]         }, condition = base::local({
[10:32:41.867]             c <- base::c
[10:32:41.867]             inherits <- base::inherits
[10:32:41.867]             invokeRestart <- base::invokeRestart
[10:32:41.867]             length <- base::length
[10:32:41.867]             list <- base::list
[10:32:41.867]             seq.int <- base::seq.int
[10:32:41.867]             signalCondition <- base::signalCondition
[10:32:41.867]             sys.calls <- base::sys.calls
[10:32:41.867]             `[[` <- base::`[[`
[10:32:41.867]             `+` <- base::`+`
[10:32:41.867]             `<<-` <- base::`<<-`
[10:32:41.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.867]                   3L)]
[10:32:41.867]             }
[10:32:41.867]             function(cond) {
[10:32:41.867]                 is_error <- inherits(cond, "error")
[10:32:41.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.867]                   NULL)
[10:32:41.867]                 if (is_error) {
[10:32:41.867]                   sessionInformation <- function() {
[10:32:41.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.867]                       search = base::search(), system = base::Sys.info())
[10:32:41.867]                   }
[10:32:41.867]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.867]                     cond$call), session = sessionInformation(), 
[10:32:41.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.867]                   signalCondition(cond)
[10:32:41.867]                 }
[10:32:41.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.867]                 "immediateCondition"))) {
[10:32:41.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.867]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.867]                   if (TRUE && !signal) {
[10:32:41.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.867]                     {
[10:32:41.867]                       inherits <- base::inherits
[10:32:41.867]                       invokeRestart <- base::invokeRestart
[10:32:41.867]                       is.null <- base::is.null
[10:32:41.867]                       muffled <- FALSE
[10:32:41.867]                       if (inherits(cond, "message")) {
[10:32:41.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.867]                         if (muffled) 
[10:32:41.867]                           invokeRestart("muffleMessage")
[10:32:41.867]                       }
[10:32:41.867]                       else if (inherits(cond, "warning")) {
[10:32:41.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.867]                         if (muffled) 
[10:32:41.867]                           invokeRestart("muffleWarning")
[10:32:41.867]                       }
[10:32:41.867]                       else if (inherits(cond, "condition")) {
[10:32:41.867]                         if (!is.null(pattern)) {
[10:32:41.867]                           computeRestarts <- base::computeRestarts
[10:32:41.867]                           grepl <- base::grepl
[10:32:41.867]                           restarts <- computeRestarts(cond)
[10:32:41.867]                           for (restart in restarts) {
[10:32:41.867]                             name <- restart$name
[10:32:41.867]                             if (is.null(name)) 
[10:32:41.867]                               next
[10:32:41.867]                             if (!grepl(pattern, name)) 
[10:32:41.867]                               next
[10:32:41.867]                             invokeRestart(restart)
[10:32:41.867]                             muffled <- TRUE
[10:32:41.867]                             break
[10:32:41.867]                           }
[10:32:41.867]                         }
[10:32:41.867]                       }
[10:32:41.867]                       invisible(muffled)
[10:32:41.867]                     }
[10:32:41.867]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.867]                   }
[10:32:41.867]                 }
[10:32:41.867]                 else {
[10:32:41.867]                   if (TRUE) {
[10:32:41.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.867]                     {
[10:32:41.867]                       inherits <- base::inherits
[10:32:41.867]                       invokeRestart <- base::invokeRestart
[10:32:41.867]                       is.null <- base::is.null
[10:32:41.867]                       muffled <- FALSE
[10:32:41.867]                       if (inherits(cond, "message")) {
[10:32:41.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.867]                         if (muffled) 
[10:32:41.867]                           invokeRestart("muffleMessage")
[10:32:41.867]                       }
[10:32:41.867]                       else if (inherits(cond, "warning")) {
[10:32:41.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.867]                         if (muffled) 
[10:32:41.867]                           invokeRestart("muffleWarning")
[10:32:41.867]                       }
[10:32:41.867]                       else if (inherits(cond, "condition")) {
[10:32:41.867]                         if (!is.null(pattern)) {
[10:32:41.867]                           computeRestarts <- base::computeRestarts
[10:32:41.867]                           grepl <- base::grepl
[10:32:41.867]                           restarts <- computeRestarts(cond)
[10:32:41.867]                           for (restart in restarts) {
[10:32:41.867]                             name <- restart$name
[10:32:41.867]                             if (is.null(name)) 
[10:32:41.867]                               next
[10:32:41.867]                             if (!grepl(pattern, name)) 
[10:32:41.867]                               next
[10:32:41.867]                             invokeRestart(restart)
[10:32:41.867]                             muffled <- TRUE
[10:32:41.867]                             break
[10:32:41.867]                           }
[10:32:41.867]                         }
[10:32:41.867]                       }
[10:32:41.867]                       invisible(muffled)
[10:32:41.867]                     }
[10:32:41.867]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.867]                   }
[10:32:41.867]                 }
[10:32:41.867]             }
[10:32:41.867]         }))
[10:32:41.867]     }, error = function(ex) {
[10:32:41.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.867]                 ...future.rng), started = ...future.startTime, 
[10:32:41.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.867]             version = "1.8"), class = "FutureResult")
[10:32:41.867]     }, finally = {
[10:32:41.867]         if (!identical(...future.workdir, getwd())) 
[10:32:41.867]             setwd(...future.workdir)
[10:32:41.867]         {
[10:32:41.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.867]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.867]             }
[10:32:41.867]             base::options(...future.oldOptions)
[10:32:41.867]             if (.Platform$OS.type == "windows") {
[10:32:41.867]                 old_names <- names(...future.oldEnvVars)
[10:32:41.867]                 envs <- base::Sys.getenv()
[10:32:41.867]                 names <- names(envs)
[10:32:41.867]                 common <- intersect(names, old_names)
[10:32:41.867]                 added <- setdiff(names, old_names)
[10:32:41.867]                 removed <- setdiff(old_names, names)
[10:32:41.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.867]                   envs[common]]
[10:32:41.867]                 NAMES <- toupper(changed)
[10:32:41.867]                 args <- list()
[10:32:41.867]                 for (kk in seq_along(NAMES)) {
[10:32:41.867]                   name <- changed[[kk]]
[10:32:41.867]                   NAME <- NAMES[[kk]]
[10:32:41.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.867]                     next
[10:32:41.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.867]                 }
[10:32:41.867]                 NAMES <- toupper(added)
[10:32:41.867]                 for (kk in seq_along(NAMES)) {
[10:32:41.867]                   name <- added[[kk]]
[10:32:41.867]                   NAME <- NAMES[[kk]]
[10:32:41.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.867]                     next
[10:32:41.867]                   args[[name]] <- ""
[10:32:41.867]                 }
[10:32:41.867]                 NAMES <- toupper(removed)
[10:32:41.867]                 for (kk in seq_along(NAMES)) {
[10:32:41.867]                   name <- removed[[kk]]
[10:32:41.867]                   NAME <- NAMES[[kk]]
[10:32:41.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.867]                     next
[10:32:41.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.867]                 }
[10:32:41.867]                 if (length(args) > 0) 
[10:32:41.867]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.867]             }
[10:32:41.867]             else {
[10:32:41.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.867]             }
[10:32:41.867]             {
[10:32:41.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.867]                   0L) {
[10:32:41.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.867]                   base::options(opts)
[10:32:41.867]                 }
[10:32:41.867]                 {
[10:32:41.867]                   {
[10:32:41.867]                     NULL
[10:32:41.867]                     RNGkind("Mersenne-Twister")
[10:32:41.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.867]                       inherits = FALSE)
[10:32:41.867]                   }
[10:32:41.867]                   options(future.plan = NULL)
[10:32:41.867]                   if (is.na(NA_character_)) 
[10:32:41.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.867]                     .init = FALSE)
[10:32:41.867]                 }
[10:32:41.867]             }
[10:32:41.867]         }
[10:32:41.867]     })
[10:32:41.867]     if (TRUE) {
[10:32:41.867]         base::sink(type = "output", split = FALSE)
[10:32:41.867]         if (TRUE) {
[10:32:41.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.867]         }
[10:32:41.867]         else {
[10:32:41.867]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.867]         }
[10:32:41.867]         base::close(...future.stdout)
[10:32:41.867]         ...future.stdout <- NULL
[10:32:41.867]     }
[10:32:41.867]     ...future.result$conditions <- ...future.conditions
[10:32:41.867]     ...future.result$finished <- base::Sys.time()
[10:32:41.867]     ...future.result
[10:32:41.867] }
[10:32:41.868] assign_globals() ...
[10:32:41.868] List of 1
[10:32:41.868]  $ ii: int 3
[10:32:41.868]  - attr(*, "where")=List of 1
[10:32:41.868]   ..$ ii:<environment: R_EmptyEnv> 
[10:32:41.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:41.868]  - attr(*, "resolved")= logi FALSE
[10:32:41.868]  - attr(*, "total_size")= num 56
[10:32:41.868]  - attr(*, "already-done")= logi TRUE
[10:32:41.873] - copied ‘ii’ to environment
[10:32:41.873] assign_globals() ... done
[10:32:41.873] plan(): Setting new future strategy stack:
[10:32:41.873] List of future strategies:
[10:32:41.873] 1. sequential:
[10:32:41.873]    - args: function (..., envir = parent.frame())
[10:32:41.873]    - tweaked: FALSE
[10:32:41.873]    - call: NULL
[10:32:41.873] plan(): nbrOfWorkers() = 1
[10:32:41.874] plan(): Setting new future strategy stack:
[10:32:41.874] List of future strategies:
[10:32:41.874] 1. sequential:
[10:32:41.874]    - args: function (..., envir = parent.frame())
[10:32:41.874]    - tweaked: FALSE
[10:32:41.874]    - call: plan(strategy)
[10:32:41.875] plan(): nbrOfWorkers() = 1
[10:32:41.875] SequentialFuture started (and completed)
[10:32:41.875] - Launch lazy future ... done
[10:32:41.875] run() for ‘SequentialFuture’ ... done
[10:32:41.875] signalConditions() ...
[10:32:41.876]  - include = ‘immediateCondition’
[10:32:41.876]  - exclude = 
[10:32:41.876]  - resignal = FALSE
[10:32:41.876]  - Number of conditions: 1
[10:32:41.876] signalConditions() ... done
[10:32:41.876] Future state: ‘finished’
[10:32:41.876] signalConditions() ...
[10:32:41.876]  - include = ‘condition’
[10:32:41.876]  - exclude = ‘immediateCondition’
[10:32:41.876]  - resignal = TRUE
[10:32:41.877]  - Number of conditions: 1
[10:32:41.877]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:41.877] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:32:41.878] signalConditions() ...
[10:32:41.878]  - include = ‘immediateCondition’
[10:32:41.878]  - exclude = 
[10:32:41.878]  - resignal = FALSE
[10:32:41.878]  - Number of conditions: 1
[10:32:41.878] signalConditions() ... done
[10:32:41.879] Future state: ‘finished’
[10:32:41.879] signalConditions() ...
[10:32:41.879]  - include = ‘condition’
[10:32:41.879]  - exclude = ‘immediateCondition’
[10:32:41.879]  - resignal = TRUE
[10:32:41.879]  - Number of conditions: 1
[10:32:41.879]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:41.879] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:32:41.880] signalConditions() ...
[10:32:41.880]  - include = ‘immediateCondition’
[10:32:41.880]  - exclude = 
[10:32:41.880]  - resignal = FALSE
[10:32:41.880]  - Number of conditions: 1
[10:32:41.880] signalConditions() ... done
[10:32:41.880] Future state: ‘finished’
[10:32:41.880] signalConditions() ...
[10:32:41.880]  - include = ‘condition’
[10:32:41.881]  - exclude = ‘immediateCondition’
[10:32:41.881]  - resignal = TRUE
[10:32:41.881]  - Number of conditions: 1
[10:32:41.881]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:41.881] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[10:32:41.881] getGlobalsAndPackages() ...
[10:32:41.881] Searching for globals...
[10:32:41.883] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[10:32:41.883] Searching for globals ... DONE
[10:32:41.883] Resolving globals: FALSE
[10:32:41.884] 
[10:32:41.884] 
[10:32:41.884] getGlobalsAndPackages() ... DONE
[10:32:41.884] run() for ‘Future’ ...
[10:32:41.884] - state: ‘created’
[10:32:41.884] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.885] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.885]   - Field: ‘label’
[10:32:41.885]   - Field: ‘local’
[10:32:41.885]   - Field: ‘owner’
[10:32:41.885]   - Field: ‘envir’
[10:32:41.885]   - Field: ‘packages’
[10:32:41.885]   - Field: ‘gc’
[10:32:41.886]   - Field: ‘conditions’
[10:32:41.886]   - Field: ‘expr’
[10:32:41.886]   - Field: ‘uuid’
[10:32:41.886]   - Field: ‘seed’
[10:32:41.886]   - Field: ‘version’
[10:32:41.886]   - Field: ‘result’
[10:32:41.886]   - Field: ‘asynchronous’
[10:32:41.886]   - Field: ‘calls’
[10:32:41.886]   - Field: ‘globals’
[10:32:41.886]   - Field: ‘stdout’
[10:32:41.886]   - Field: ‘earlySignal’
[10:32:41.887]   - Field: ‘lazy’
[10:32:41.887]   - Field: ‘state’
[10:32:41.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.887] - Launch lazy future ...
[10:32:41.887] Packages needed by the future expression (n = 0): <none>
[10:32:41.887] Packages needed by future strategies (n = 0): <none>
[10:32:41.888] {
[10:32:41.888]     {
[10:32:41.888]         {
[10:32:41.888]             ...future.startTime <- base::Sys.time()
[10:32:41.888]             {
[10:32:41.888]                 {
[10:32:41.888]                   {
[10:32:41.888]                     base::local({
[10:32:41.888]                       has_future <- base::requireNamespace("future", 
[10:32:41.888]                         quietly = TRUE)
[10:32:41.888]                       if (has_future) {
[10:32:41.888]                         ns <- base::getNamespace("future")
[10:32:41.888]                         version <- ns[[".package"]][["version"]]
[10:32:41.888]                         if (is.null(version)) 
[10:32:41.888]                           version <- utils::packageVersion("future")
[10:32:41.888]                       }
[10:32:41.888]                       else {
[10:32:41.888]                         version <- NULL
[10:32:41.888]                       }
[10:32:41.888]                       if (!has_future || version < "1.8.0") {
[10:32:41.888]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.888]                           "", base::R.version$version.string), 
[10:32:41.888]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.888]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.888]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.888]                             "release", "version")], collapse = " "), 
[10:32:41.888]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.888]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.888]                           info)
[10:32:41.888]                         info <- base::paste(info, collapse = "; ")
[10:32:41.888]                         if (!has_future) {
[10:32:41.888]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.888]                             info)
[10:32:41.888]                         }
[10:32:41.888]                         else {
[10:32:41.888]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.888]                             info, version)
[10:32:41.888]                         }
[10:32:41.888]                         base::stop(msg)
[10:32:41.888]                       }
[10:32:41.888]                     })
[10:32:41.888]                   }
[10:32:41.888]                   ...future.strategy.old <- future::plan("list")
[10:32:41.888]                   options(future.plan = NULL)
[10:32:41.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.888]                 }
[10:32:41.888]                 ...future.workdir <- getwd()
[10:32:41.888]             }
[10:32:41.888]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.888]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.888]         }
[10:32:41.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.888]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.888]             base::names(...future.oldOptions))
[10:32:41.888]     }
[10:32:41.888]     if (FALSE) {
[10:32:41.888]     }
[10:32:41.888]     else {
[10:32:41.888]         if (TRUE) {
[10:32:41.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.888]                 open = "w")
[10:32:41.888]         }
[10:32:41.888]         else {
[10:32:41.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.888]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.888]         }
[10:32:41.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.888]             base::sink(type = "output", split = FALSE)
[10:32:41.888]             base::close(...future.stdout)
[10:32:41.888]         }, add = TRUE)
[10:32:41.888]     }
[10:32:41.888]     ...future.frame <- base::sys.nframe()
[10:32:41.888]     ...future.conditions <- base::list()
[10:32:41.888]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.888]     if (FALSE) {
[10:32:41.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.888]     }
[10:32:41.888]     ...future.result <- base::tryCatch({
[10:32:41.888]         base::withCallingHandlers({
[10:32:41.888]             ...future.value <- base::withVisible(base::local({
[10:32:41.888]                 cat("Processing: ")
[10:32:41.888]                 for (ii in 1:10) {
[10:32:41.888]                   cat(".")
[10:32:41.888]                 }
[10:32:41.888]                 cat(" [100%]\n")
[10:32:41.888]                 4
[10:32:41.888]             }))
[10:32:41.888]             future::FutureResult(value = ...future.value$value, 
[10:32:41.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.888]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.888]                     ...future.globalenv.names))
[10:32:41.888]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.888]         }, condition = base::local({
[10:32:41.888]             c <- base::c
[10:32:41.888]             inherits <- base::inherits
[10:32:41.888]             invokeRestart <- base::invokeRestart
[10:32:41.888]             length <- base::length
[10:32:41.888]             list <- base::list
[10:32:41.888]             seq.int <- base::seq.int
[10:32:41.888]             signalCondition <- base::signalCondition
[10:32:41.888]             sys.calls <- base::sys.calls
[10:32:41.888]             `[[` <- base::`[[`
[10:32:41.888]             `+` <- base::`+`
[10:32:41.888]             `<<-` <- base::`<<-`
[10:32:41.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.888]                   3L)]
[10:32:41.888]             }
[10:32:41.888]             function(cond) {
[10:32:41.888]                 is_error <- inherits(cond, "error")
[10:32:41.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.888]                   NULL)
[10:32:41.888]                 if (is_error) {
[10:32:41.888]                   sessionInformation <- function() {
[10:32:41.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.888]                       search = base::search(), system = base::Sys.info())
[10:32:41.888]                   }
[10:32:41.888]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.888]                     cond$call), session = sessionInformation(), 
[10:32:41.888]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.888]                   signalCondition(cond)
[10:32:41.888]                 }
[10:32:41.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.888]                 "immediateCondition"))) {
[10:32:41.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.888]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.888]                   if (TRUE && !signal) {
[10:32:41.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.888]                     {
[10:32:41.888]                       inherits <- base::inherits
[10:32:41.888]                       invokeRestart <- base::invokeRestart
[10:32:41.888]                       is.null <- base::is.null
[10:32:41.888]                       muffled <- FALSE
[10:32:41.888]                       if (inherits(cond, "message")) {
[10:32:41.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.888]                         if (muffled) 
[10:32:41.888]                           invokeRestart("muffleMessage")
[10:32:41.888]                       }
[10:32:41.888]                       else if (inherits(cond, "warning")) {
[10:32:41.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.888]                         if (muffled) 
[10:32:41.888]                           invokeRestart("muffleWarning")
[10:32:41.888]                       }
[10:32:41.888]                       else if (inherits(cond, "condition")) {
[10:32:41.888]                         if (!is.null(pattern)) {
[10:32:41.888]                           computeRestarts <- base::computeRestarts
[10:32:41.888]                           grepl <- base::grepl
[10:32:41.888]                           restarts <- computeRestarts(cond)
[10:32:41.888]                           for (restart in restarts) {
[10:32:41.888]                             name <- restart$name
[10:32:41.888]                             if (is.null(name)) 
[10:32:41.888]                               next
[10:32:41.888]                             if (!grepl(pattern, name)) 
[10:32:41.888]                               next
[10:32:41.888]                             invokeRestart(restart)
[10:32:41.888]                             muffled <- TRUE
[10:32:41.888]                             break
[10:32:41.888]                           }
[10:32:41.888]                         }
[10:32:41.888]                       }
[10:32:41.888]                       invisible(muffled)
[10:32:41.888]                     }
[10:32:41.888]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.888]                   }
[10:32:41.888]                 }
[10:32:41.888]                 else {
[10:32:41.888]                   if (TRUE) {
[10:32:41.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.888]                     {
[10:32:41.888]                       inherits <- base::inherits
[10:32:41.888]                       invokeRestart <- base::invokeRestart
[10:32:41.888]                       is.null <- base::is.null
[10:32:41.888]                       muffled <- FALSE
[10:32:41.888]                       if (inherits(cond, "message")) {
[10:32:41.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.888]                         if (muffled) 
[10:32:41.888]                           invokeRestart("muffleMessage")
[10:32:41.888]                       }
[10:32:41.888]                       else if (inherits(cond, "warning")) {
[10:32:41.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.888]                         if (muffled) 
[10:32:41.888]                           invokeRestart("muffleWarning")
[10:32:41.888]                       }
[10:32:41.888]                       else if (inherits(cond, "condition")) {
[10:32:41.888]                         if (!is.null(pattern)) {
[10:32:41.888]                           computeRestarts <- base::computeRestarts
[10:32:41.888]                           grepl <- base::grepl
[10:32:41.888]                           restarts <- computeRestarts(cond)
[10:32:41.888]                           for (restart in restarts) {
[10:32:41.888]                             name <- restart$name
[10:32:41.888]                             if (is.null(name)) 
[10:32:41.888]                               next
[10:32:41.888]                             if (!grepl(pattern, name)) 
[10:32:41.888]                               next
[10:32:41.888]                             invokeRestart(restart)
[10:32:41.888]                             muffled <- TRUE
[10:32:41.888]                             break
[10:32:41.888]                           }
[10:32:41.888]                         }
[10:32:41.888]                       }
[10:32:41.888]                       invisible(muffled)
[10:32:41.888]                     }
[10:32:41.888]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.888]                   }
[10:32:41.888]                 }
[10:32:41.888]             }
[10:32:41.888]         }))
[10:32:41.888]     }, error = function(ex) {
[10:32:41.888]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.888]                 ...future.rng), started = ...future.startTime, 
[10:32:41.888]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.888]             version = "1.8"), class = "FutureResult")
[10:32:41.888]     }, finally = {
[10:32:41.888]         if (!identical(...future.workdir, getwd())) 
[10:32:41.888]             setwd(...future.workdir)
[10:32:41.888]         {
[10:32:41.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.888]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.888]             }
[10:32:41.888]             base::options(...future.oldOptions)
[10:32:41.888]             if (.Platform$OS.type == "windows") {
[10:32:41.888]                 old_names <- names(...future.oldEnvVars)
[10:32:41.888]                 envs <- base::Sys.getenv()
[10:32:41.888]                 names <- names(envs)
[10:32:41.888]                 common <- intersect(names, old_names)
[10:32:41.888]                 added <- setdiff(names, old_names)
[10:32:41.888]                 removed <- setdiff(old_names, names)
[10:32:41.888]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.888]                   envs[common]]
[10:32:41.888]                 NAMES <- toupper(changed)
[10:32:41.888]                 args <- list()
[10:32:41.888]                 for (kk in seq_along(NAMES)) {
[10:32:41.888]                   name <- changed[[kk]]
[10:32:41.888]                   NAME <- NAMES[[kk]]
[10:32:41.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.888]                     next
[10:32:41.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.888]                 }
[10:32:41.888]                 NAMES <- toupper(added)
[10:32:41.888]                 for (kk in seq_along(NAMES)) {
[10:32:41.888]                   name <- added[[kk]]
[10:32:41.888]                   NAME <- NAMES[[kk]]
[10:32:41.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.888]                     next
[10:32:41.888]                   args[[name]] <- ""
[10:32:41.888]                 }
[10:32:41.888]                 NAMES <- toupper(removed)
[10:32:41.888]                 for (kk in seq_along(NAMES)) {
[10:32:41.888]                   name <- removed[[kk]]
[10:32:41.888]                   NAME <- NAMES[[kk]]
[10:32:41.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.888]                     next
[10:32:41.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.888]                 }
[10:32:41.888]                 if (length(args) > 0) 
[10:32:41.888]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.888]             }
[10:32:41.888]             else {
[10:32:41.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.888]             }
[10:32:41.888]             {
[10:32:41.888]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.888]                   0L) {
[10:32:41.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.888]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.888]                   base::options(opts)
[10:32:41.888]                 }
[10:32:41.888]                 {
[10:32:41.888]                   {
[10:32:41.888]                     NULL
[10:32:41.888]                     RNGkind("Mersenne-Twister")
[10:32:41.888]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.888]                       inherits = FALSE)
[10:32:41.888]                   }
[10:32:41.888]                   options(future.plan = NULL)
[10:32:41.888]                   if (is.na(NA_character_)) 
[10:32:41.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.888]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.888]                     .init = FALSE)
[10:32:41.888]                 }
[10:32:41.888]             }
[10:32:41.888]         }
[10:32:41.888]     })
[10:32:41.888]     if (TRUE) {
[10:32:41.888]         base::sink(type = "output", split = FALSE)
[10:32:41.888]         if (TRUE) {
[10:32:41.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.888]         }
[10:32:41.888]         else {
[10:32:41.888]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.888]         }
[10:32:41.888]         base::close(...future.stdout)
[10:32:41.888]         ...future.stdout <- NULL
[10:32:41.888]     }
[10:32:41.888]     ...future.result$conditions <- ...future.conditions
[10:32:41.888]     ...future.result$finished <- base::Sys.time()
[10:32:41.888]     ...future.result
[10:32:41.888] }
[10:32:41.889] plan(): Setting new future strategy stack:
[10:32:41.889] List of future strategies:
[10:32:41.889] 1. sequential:
[10:32:41.889]    - args: function (..., envir = parent.frame())
[10:32:41.889]    - tweaked: FALSE
[10:32:41.889]    - call: NULL
[10:32:41.890] plan(): nbrOfWorkers() = 1
[10:32:41.890] plan(): Setting new future strategy stack:
[10:32:41.891] List of future strategies:
[10:32:41.891] 1. sequential:
[10:32:41.891]    - args: function (..., envir = parent.frame())
[10:32:41.891]    - tweaked: FALSE
[10:32:41.891]    - call: plan(strategy)
[10:32:41.891] plan(): nbrOfWorkers() = 1
[10:32:41.891] SequentialFuture started (and completed)
[10:32:41.891] - Launch lazy future ... done
[10:32:41.891] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[10:32:41.893] signalConditions() ...
[10:32:41.893]  - include = ‘immediateCondition’
[10:32:41.893]  - exclude = 
[10:32:41.893]  - resignal = FALSE
[10:32:41.893]  - Number of conditions: 1
[10:32:41.893] signalConditions() ... done
[10:32:41.893] Future state: ‘finished’
[10:32:41.893] signalConditions() ...
[10:32:41.893]  - include = ‘condition’
[10:32:41.894]  - exclude = ‘immediateCondition’
[10:32:41.894]  - resignal = TRUE
[10:32:41.894]  - Number of conditions: 1
[10:32:41.894]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:41.894] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[10:32:41.894] getGlobalsAndPackages() ...
[10:32:41.895] Searching for globals...
[10:32:41.895] 
[10:32:41.895] Searching for globals ... DONE
[10:32:41.895] - globals: [0] <none>
[10:32:41.895] getGlobalsAndPackages() ... DONE
[10:32:41.895] run() for ‘Future’ ...
[10:32:41.895] - state: ‘created’
[10:32:41.896] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.896] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.898] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.898]   - Field: ‘label’
[10:32:41.898]   - Field: ‘local’
[10:32:41.898]   - Field: ‘owner’
[10:32:41.898]   - Field: ‘envir’
[10:32:41.898]   - Field: ‘packages’
[10:32:41.898]   - Field: ‘gc’
[10:32:41.898]   - Field: ‘conditions’
[10:32:41.898]   - Field: ‘expr’
[10:32:41.899]   - Field: ‘uuid’
[10:32:41.899]   - Field: ‘seed’
[10:32:41.899]   - Field: ‘version’
[10:32:41.899]   - Field: ‘result’
[10:32:41.899]   - Field: ‘asynchronous’
[10:32:41.899]   - Field: ‘calls’
[10:32:41.899]   - Field: ‘globals’
[10:32:41.899]   - Field: ‘stdout’
[10:32:41.899]   - Field: ‘earlySignal’
[10:32:41.899]   - Field: ‘lazy’
[10:32:41.900]   - Field: ‘state’
[10:32:41.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.900] - Launch lazy future ...
[10:32:41.900] Packages needed by the future expression (n = 0): <none>
[10:32:41.900] Packages needed by future strategies (n = 0): <none>
[10:32:41.900] {
[10:32:41.900]     {
[10:32:41.900]         {
[10:32:41.900]             ...future.startTime <- base::Sys.time()
[10:32:41.900]             {
[10:32:41.900]                 {
[10:32:41.900]                   {
[10:32:41.900]                     base::local({
[10:32:41.900]                       has_future <- base::requireNamespace("future", 
[10:32:41.900]                         quietly = TRUE)
[10:32:41.900]                       if (has_future) {
[10:32:41.900]                         ns <- base::getNamespace("future")
[10:32:41.900]                         version <- ns[[".package"]][["version"]]
[10:32:41.900]                         if (is.null(version)) 
[10:32:41.900]                           version <- utils::packageVersion("future")
[10:32:41.900]                       }
[10:32:41.900]                       else {
[10:32:41.900]                         version <- NULL
[10:32:41.900]                       }
[10:32:41.900]                       if (!has_future || version < "1.8.0") {
[10:32:41.900]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.900]                           "", base::R.version$version.string), 
[10:32:41.900]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.900]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.900]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.900]                             "release", "version")], collapse = " "), 
[10:32:41.900]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.900]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.900]                           info)
[10:32:41.900]                         info <- base::paste(info, collapse = "; ")
[10:32:41.900]                         if (!has_future) {
[10:32:41.900]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.900]                             info)
[10:32:41.900]                         }
[10:32:41.900]                         else {
[10:32:41.900]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.900]                             info, version)
[10:32:41.900]                         }
[10:32:41.900]                         base::stop(msg)
[10:32:41.900]                       }
[10:32:41.900]                     })
[10:32:41.900]                   }
[10:32:41.900]                   ...future.strategy.old <- future::plan("list")
[10:32:41.900]                   options(future.plan = NULL)
[10:32:41.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.900]                 }
[10:32:41.900]                 ...future.workdir <- getwd()
[10:32:41.900]             }
[10:32:41.900]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.900]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.900]         }
[10:32:41.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.900]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.900]             base::names(...future.oldOptions))
[10:32:41.900]     }
[10:32:41.900]     if (FALSE) {
[10:32:41.900]     }
[10:32:41.900]     else {
[10:32:41.900]         if (TRUE) {
[10:32:41.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.900]                 open = "w")
[10:32:41.900]         }
[10:32:41.900]         else {
[10:32:41.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.900]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.900]         }
[10:32:41.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.900]             base::sink(type = "output", split = FALSE)
[10:32:41.900]             base::close(...future.stdout)
[10:32:41.900]         }, add = TRUE)
[10:32:41.900]     }
[10:32:41.900]     ...future.frame <- base::sys.nframe()
[10:32:41.900]     ...future.conditions <- base::list()
[10:32:41.900]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.900]     if (FALSE) {
[10:32:41.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.900]     }
[10:32:41.900]     ...future.result <- base::tryCatch({
[10:32:41.900]         base::withCallingHandlers({
[10:32:41.900]             ...future.value <- base::withVisible(base::local(1))
[10:32:41.900]             future::FutureResult(value = ...future.value$value, 
[10:32:41.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.900]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.900]                     ...future.globalenv.names))
[10:32:41.900]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.900]         }, condition = base::local({
[10:32:41.900]             c <- base::c
[10:32:41.900]             inherits <- base::inherits
[10:32:41.900]             invokeRestart <- base::invokeRestart
[10:32:41.900]             length <- base::length
[10:32:41.900]             list <- base::list
[10:32:41.900]             seq.int <- base::seq.int
[10:32:41.900]             signalCondition <- base::signalCondition
[10:32:41.900]             sys.calls <- base::sys.calls
[10:32:41.900]             `[[` <- base::`[[`
[10:32:41.900]             `+` <- base::`+`
[10:32:41.900]             `<<-` <- base::`<<-`
[10:32:41.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.900]                   3L)]
[10:32:41.900]             }
[10:32:41.900]             function(cond) {
[10:32:41.900]                 is_error <- inherits(cond, "error")
[10:32:41.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.900]                   NULL)
[10:32:41.900]                 if (is_error) {
[10:32:41.900]                   sessionInformation <- function() {
[10:32:41.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.900]                       search = base::search(), system = base::Sys.info())
[10:32:41.900]                   }
[10:32:41.900]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.900]                     cond$call), session = sessionInformation(), 
[10:32:41.900]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.900]                   signalCondition(cond)
[10:32:41.900]                 }
[10:32:41.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.900]                 "immediateCondition"))) {
[10:32:41.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.900]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.900]                   if (TRUE && !signal) {
[10:32:41.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.900]                     {
[10:32:41.900]                       inherits <- base::inherits
[10:32:41.900]                       invokeRestart <- base::invokeRestart
[10:32:41.900]                       is.null <- base::is.null
[10:32:41.900]                       muffled <- FALSE
[10:32:41.900]                       if (inherits(cond, "message")) {
[10:32:41.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.900]                         if (muffled) 
[10:32:41.900]                           invokeRestart("muffleMessage")
[10:32:41.900]                       }
[10:32:41.900]                       else if (inherits(cond, "warning")) {
[10:32:41.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.900]                         if (muffled) 
[10:32:41.900]                           invokeRestart("muffleWarning")
[10:32:41.900]                       }
[10:32:41.900]                       else if (inherits(cond, "condition")) {
[10:32:41.900]                         if (!is.null(pattern)) {
[10:32:41.900]                           computeRestarts <- base::computeRestarts
[10:32:41.900]                           grepl <- base::grepl
[10:32:41.900]                           restarts <- computeRestarts(cond)
[10:32:41.900]                           for (restart in restarts) {
[10:32:41.900]                             name <- restart$name
[10:32:41.900]                             if (is.null(name)) 
[10:32:41.900]                               next
[10:32:41.900]                             if (!grepl(pattern, name)) 
[10:32:41.900]                               next
[10:32:41.900]                             invokeRestart(restart)
[10:32:41.900]                             muffled <- TRUE
[10:32:41.900]                             break
[10:32:41.900]                           }
[10:32:41.900]                         }
[10:32:41.900]                       }
[10:32:41.900]                       invisible(muffled)
[10:32:41.900]                     }
[10:32:41.900]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.900]                   }
[10:32:41.900]                 }
[10:32:41.900]                 else {
[10:32:41.900]                   if (TRUE) {
[10:32:41.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.900]                     {
[10:32:41.900]                       inherits <- base::inherits
[10:32:41.900]                       invokeRestart <- base::invokeRestart
[10:32:41.900]                       is.null <- base::is.null
[10:32:41.900]                       muffled <- FALSE
[10:32:41.900]                       if (inherits(cond, "message")) {
[10:32:41.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.900]                         if (muffled) 
[10:32:41.900]                           invokeRestart("muffleMessage")
[10:32:41.900]                       }
[10:32:41.900]                       else if (inherits(cond, "warning")) {
[10:32:41.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.900]                         if (muffled) 
[10:32:41.900]                           invokeRestart("muffleWarning")
[10:32:41.900]                       }
[10:32:41.900]                       else if (inherits(cond, "condition")) {
[10:32:41.900]                         if (!is.null(pattern)) {
[10:32:41.900]                           computeRestarts <- base::computeRestarts
[10:32:41.900]                           grepl <- base::grepl
[10:32:41.900]                           restarts <- computeRestarts(cond)
[10:32:41.900]                           for (restart in restarts) {
[10:32:41.900]                             name <- restart$name
[10:32:41.900]                             if (is.null(name)) 
[10:32:41.900]                               next
[10:32:41.900]                             if (!grepl(pattern, name)) 
[10:32:41.900]                               next
[10:32:41.900]                             invokeRestart(restart)
[10:32:41.900]                             muffled <- TRUE
[10:32:41.900]                             break
[10:32:41.900]                           }
[10:32:41.900]                         }
[10:32:41.900]                       }
[10:32:41.900]                       invisible(muffled)
[10:32:41.900]                     }
[10:32:41.900]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.900]                   }
[10:32:41.900]                 }
[10:32:41.900]             }
[10:32:41.900]         }))
[10:32:41.900]     }, error = function(ex) {
[10:32:41.900]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.900]                 ...future.rng), started = ...future.startTime, 
[10:32:41.900]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.900]             version = "1.8"), class = "FutureResult")
[10:32:41.900]     }, finally = {
[10:32:41.900]         if (!identical(...future.workdir, getwd())) 
[10:32:41.900]             setwd(...future.workdir)
[10:32:41.900]         {
[10:32:41.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.900]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.900]             }
[10:32:41.900]             base::options(...future.oldOptions)
[10:32:41.900]             if (.Platform$OS.type == "windows") {
[10:32:41.900]                 old_names <- names(...future.oldEnvVars)
[10:32:41.900]                 envs <- base::Sys.getenv()
[10:32:41.900]                 names <- names(envs)
[10:32:41.900]                 common <- intersect(names, old_names)
[10:32:41.900]                 added <- setdiff(names, old_names)
[10:32:41.900]                 removed <- setdiff(old_names, names)
[10:32:41.900]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.900]                   envs[common]]
[10:32:41.900]                 NAMES <- toupper(changed)
[10:32:41.900]                 args <- list()
[10:32:41.900]                 for (kk in seq_along(NAMES)) {
[10:32:41.900]                   name <- changed[[kk]]
[10:32:41.900]                   NAME <- NAMES[[kk]]
[10:32:41.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.900]                     next
[10:32:41.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.900]                 }
[10:32:41.900]                 NAMES <- toupper(added)
[10:32:41.900]                 for (kk in seq_along(NAMES)) {
[10:32:41.900]                   name <- added[[kk]]
[10:32:41.900]                   NAME <- NAMES[[kk]]
[10:32:41.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.900]                     next
[10:32:41.900]                   args[[name]] <- ""
[10:32:41.900]                 }
[10:32:41.900]                 NAMES <- toupper(removed)
[10:32:41.900]                 for (kk in seq_along(NAMES)) {
[10:32:41.900]                   name <- removed[[kk]]
[10:32:41.900]                   NAME <- NAMES[[kk]]
[10:32:41.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.900]                     next
[10:32:41.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.900]                 }
[10:32:41.900]                 if (length(args) > 0) 
[10:32:41.900]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.900]             }
[10:32:41.900]             else {
[10:32:41.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.900]             }
[10:32:41.900]             {
[10:32:41.900]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.900]                   0L) {
[10:32:41.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.900]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.900]                   base::options(opts)
[10:32:41.900]                 }
[10:32:41.900]                 {
[10:32:41.900]                   {
[10:32:41.900]                     NULL
[10:32:41.900]                     RNGkind("Mersenne-Twister")
[10:32:41.900]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.900]                       inherits = FALSE)
[10:32:41.900]                   }
[10:32:41.900]                   options(future.plan = NULL)
[10:32:41.900]                   if (is.na(NA_character_)) 
[10:32:41.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.900]                     .init = FALSE)
[10:32:41.900]                 }
[10:32:41.900]             }
[10:32:41.900]         }
[10:32:41.900]     })
[10:32:41.900]     if (TRUE) {
[10:32:41.900]         base::sink(type = "output", split = FALSE)
[10:32:41.900]         if (TRUE) {
[10:32:41.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.900]         }
[10:32:41.900]         else {
[10:32:41.900]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.900]         }
[10:32:41.900]         base::close(...future.stdout)
[10:32:41.900]         ...future.stdout <- NULL
[10:32:41.900]     }
[10:32:41.900]     ...future.result$conditions <- ...future.conditions
[10:32:41.900]     ...future.result$finished <- base::Sys.time()
[10:32:41.900]     ...future.result
[10:32:41.900] }
[10:32:41.902] plan(): Setting new future strategy stack:
[10:32:41.902] List of future strategies:
[10:32:41.902] 1. sequential:
[10:32:41.902]    - args: function (..., envir = parent.frame())
[10:32:41.902]    - tweaked: FALSE
[10:32:41.902]    - call: NULL
[10:32:41.903] plan(): nbrOfWorkers() = 1
[10:32:41.903] plan(): Setting new future strategy stack:
[10:32:41.903] List of future strategies:
[10:32:41.903] 1. sequential:
[10:32:41.903]    - args: function (..., envir = parent.frame())
[10:32:41.903]    - tweaked: FALSE
[10:32:41.903]    - call: plan(strategy)
[10:32:41.904] plan(): nbrOfWorkers() = 1
[10:32:41.904] SequentialFuture started (and completed)
[10:32:41.904] - Launch lazy future ... done
[10:32:41.904] run() for ‘SequentialFuture’ ... done
c = 1
[10:32:41.905] getGlobalsAndPackages() ...
[10:32:41.905] Searching for globals...
[10:32:41.905] 
[10:32:41.905] Searching for globals ... DONE
[10:32:41.905] - globals: [0] <none>
[10:32:41.905] getGlobalsAndPackages() ... DONE
[10:32:41.906] run() for ‘Future’ ...
[10:32:41.906] - state: ‘created’
[10:32:41.906] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.906] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.906]   - Field: ‘label’
[10:32:41.906]   - Field: ‘local’
[10:32:41.907]   - Field: ‘owner’
[10:32:41.907]   - Field: ‘envir’
[10:32:41.907]   - Field: ‘packages’
[10:32:41.907]   - Field: ‘gc’
[10:32:41.907]   - Field: ‘conditions’
[10:32:41.907]   - Field: ‘expr’
[10:32:41.907]   - Field: ‘uuid’
[10:32:41.907]   - Field: ‘seed’
[10:32:41.907]   - Field: ‘version’
[10:32:41.907]   - Field: ‘result’
[10:32:41.907]   - Field: ‘asynchronous’
[10:32:41.908]   - Field: ‘calls’
[10:32:41.908]   - Field: ‘globals’
[10:32:41.908]   - Field: ‘stdout’
[10:32:41.908]   - Field: ‘earlySignal’
[10:32:41.908]   - Field: ‘lazy’
[10:32:41.908]   - Field: ‘state’
[10:32:41.908] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.908] - Launch lazy future ...
[10:32:41.908] Packages needed by the future expression (n = 0): <none>
[10:32:41.909] Packages needed by future strategies (n = 0): <none>
[10:32:41.909] {
[10:32:41.909]     {
[10:32:41.909]         {
[10:32:41.909]             ...future.startTime <- base::Sys.time()
[10:32:41.909]             {
[10:32:41.909]                 {
[10:32:41.909]                   {
[10:32:41.909]                     base::local({
[10:32:41.909]                       has_future <- base::requireNamespace("future", 
[10:32:41.909]                         quietly = TRUE)
[10:32:41.909]                       if (has_future) {
[10:32:41.909]                         ns <- base::getNamespace("future")
[10:32:41.909]                         version <- ns[[".package"]][["version"]]
[10:32:41.909]                         if (is.null(version)) 
[10:32:41.909]                           version <- utils::packageVersion("future")
[10:32:41.909]                       }
[10:32:41.909]                       else {
[10:32:41.909]                         version <- NULL
[10:32:41.909]                       }
[10:32:41.909]                       if (!has_future || version < "1.8.0") {
[10:32:41.909]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.909]                           "", base::R.version$version.string), 
[10:32:41.909]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.909]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.909]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.909]                             "release", "version")], collapse = " "), 
[10:32:41.909]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.909]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.909]                           info)
[10:32:41.909]                         info <- base::paste(info, collapse = "; ")
[10:32:41.909]                         if (!has_future) {
[10:32:41.909]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.909]                             info)
[10:32:41.909]                         }
[10:32:41.909]                         else {
[10:32:41.909]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.909]                             info, version)
[10:32:41.909]                         }
[10:32:41.909]                         base::stop(msg)
[10:32:41.909]                       }
[10:32:41.909]                     })
[10:32:41.909]                   }
[10:32:41.909]                   ...future.strategy.old <- future::plan("list")
[10:32:41.909]                   options(future.plan = NULL)
[10:32:41.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.909]                 }
[10:32:41.909]                 ...future.workdir <- getwd()
[10:32:41.909]             }
[10:32:41.909]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.909]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.909]         }
[10:32:41.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.909]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.909]             base::names(...future.oldOptions))
[10:32:41.909]     }
[10:32:41.909]     if (FALSE) {
[10:32:41.909]     }
[10:32:41.909]     else {
[10:32:41.909]         if (TRUE) {
[10:32:41.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.909]                 open = "w")
[10:32:41.909]         }
[10:32:41.909]         else {
[10:32:41.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.909]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.909]         }
[10:32:41.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.909]             base::sink(type = "output", split = FALSE)
[10:32:41.909]             base::close(...future.stdout)
[10:32:41.909]         }, add = TRUE)
[10:32:41.909]     }
[10:32:41.909]     ...future.frame <- base::sys.nframe()
[10:32:41.909]     ...future.conditions <- base::list()
[10:32:41.909]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.909]     if (FALSE) {
[10:32:41.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.909]     }
[10:32:41.909]     ...future.result <- base::tryCatch({
[10:32:41.909]         base::withCallingHandlers({
[10:32:41.909]             ...future.value <- base::withVisible(base::local(1))
[10:32:41.909]             future::FutureResult(value = ...future.value$value, 
[10:32:41.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.909]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.909]                     ...future.globalenv.names))
[10:32:41.909]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.909]         }, condition = base::local({
[10:32:41.909]             c <- base::c
[10:32:41.909]             inherits <- base::inherits
[10:32:41.909]             invokeRestart <- base::invokeRestart
[10:32:41.909]             length <- base::length
[10:32:41.909]             list <- base::list
[10:32:41.909]             seq.int <- base::seq.int
[10:32:41.909]             signalCondition <- base::signalCondition
[10:32:41.909]             sys.calls <- base::sys.calls
[10:32:41.909]             `[[` <- base::`[[`
[10:32:41.909]             `+` <- base::`+`
[10:32:41.909]             `<<-` <- base::`<<-`
[10:32:41.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.909]                   3L)]
[10:32:41.909]             }
[10:32:41.909]             function(cond) {
[10:32:41.909]                 is_error <- inherits(cond, "error")
[10:32:41.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.909]                   NULL)
[10:32:41.909]                 if (is_error) {
[10:32:41.909]                   sessionInformation <- function() {
[10:32:41.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.909]                       search = base::search(), system = base::Sys.info())
[10:32:41.909]                   }
[10:32:41.909]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.909]                     cond$call), session = sessionInformation(), 
[10:32:41.909]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.909]                   signalCondition(cond)
[10:32:41.909]                 }
[10:32:41.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.909]                 "immediateCondition"))) {
[10:32:41.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.909]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.909]                   if (TRUE && !signal) {
[10:32:41.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.909]                     {
[10:32:41.909]                       inherits <- base::inherits
[10:32:41.909]                       invokeRestart <- base::invokeRestart
[10:32:41.909]                       is.null <- base::is.null
[10:32:41.909]                       muffled <- FALSE
[10:32:41.909]                       if (inherits(cond, "message")) {
[10:32:41.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.909]                         if (muffled) 
[10:32:41.909]                           invokeRestart("muffleMessage")
[10:32:41.909]                       }
[10:32:41.909]                       else if (inherits(cond, "warning")) {
[10:32:41.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.909]                         if (muffled) 
[10:32:41.909]                           invokeRestart("muffleWarning")
[10:32:41.909]                       }
[10:32:41.909]                       else if (inherits(cond, "condition")) {
[10:32:41.909]                         if (!is.null(pattern)) {
[10:32:41.909]                           computeRestarts <- base::computeRestarts
[10:32:41.909]                           grepl <- base::grepl
[10:32:41.909]                           restarts <- computeRestarts(cond)
[10:32:41.909]                           for (restart in restarts) {
[10:32:41.909]                             name <- restart$name
[10:32:41.909]                             if (is.null(name)) 
[10:32:41.909]                               next
[10:32:41.909]                             if (!grepl(pattern, name)) 
[10:32:41.909]                               next
[10:32:41.909]                             invokeRestart(restart)
[10:32:41.909]                             muffled <- TRUE
[10:32:41.909]                             break
[10:32:41.909]                           }
[10:32:41.909]                         }
[10:32:41.909]                       }
[10:32:41.909]                       invisible(muffled)
[10:32:41.909]                     }
[10:32:41.909]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.909]                   }
[10:32:41.909]                 }
[10:32:41.909]                 else {
[10:32:41.909]                   if (TRUE) {
[10:32:41.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.909]                     {
[10:32:41.909]                       inherits <- base::inherits
[10:32:41.909]                       invokeRestart <- base::invokeRestart
[10:32:41.909]                       is.null <- base::is.null
[10:32:41.909]                       muffled <- FALSE
[10:32:41.909]                       if (inherits(cond, "message")) {
[10:32:41.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.909]                         if (muffled) 
[10:32:41.909]                           invokeRestart("muffleMessage")
[10:32:41.909]                       }
[10:32:41.909]                       else if (inherits(cond, "warning")) {
[10:32:41.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.909]                         if (muffled) 
[10:32:41.909]                           invokeRestart("muffleWarning")
[10:32:41.909]                       }
[10:32:41.909]                       else if (inherits(cond, "condition")) {
[10:32:41.909]                         if (!is.null(pattern)) {
[10:32:41.909]                           computeRestarts <- base::computeRestarts
[10:32:41.909]                           grepl <- base::grepl
[10:32:41.909]                           restarts <- computeRestarts(cond)
[10:32:41.909]                           for (restart in restarts) {
[10:32:41.909]                             name <- restart$name
[10:32:41.909]                             if (is.null(name)) 
[10:32:41.909]                               next
[10:32:41.909]                             if (!grepl(pattern, name)) 
[10:32:41.909]                               next
[10:32:41.909]                             invokeRestart(restart)
[10:32:41.909]                             muffled <- TRUE
[10:32:41.909]                             break
[10:32:41.909]                           }
[10:32:41.909]                         }
[10:32:41.909]                       }
[10:32:41.909]                       invisible(muffled)
[10:32:41.909]                     }
[10:32:41.909]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.909]                   }
[10:32:41.909]                 }
[10:32:41.909]             }
[10:32:41.909]         }))
[10:32:41.909]     }, error = function(ex) {
[10:32:41.909]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.909]                 ...future.rng), started = ...future.startTime, 
[10:32:41.909]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.909]             version = "1.8"), class = "FutureResult")
[10:32:41.909]     }, finally = {
[10:32:41.909]         if (!identical(...future.workdir, getwd())) 
[10:32:41.909]             setwd(...future.workdir)
[10:32:41.909]         {
[10:32:41.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.909]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.909]             }
[10:32:41.909]             base::options(...future.oldOptions)
[10:32:41.909]             if (.Platform$OS.type == "windows") {
[10:32:41.909]                 old_names <- names(...future.oldEnvVars)
[10:32:41.909]                 envs <- base::Sys.getenv()
[10:32:41.909]                 names <- names(envs)
[10:32:41.909]                 common <- intersect(names, old_names)
[10:32:41.909]                 added <- setdiff(names, old_names)
[10:32:41.909]                 removed <- setdiff(old_names, names)
[10:32:41.909]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.909]                   envs[common]]
[10:32:41.909]                 NAMES <- toupper(changed)
[10:32:41.909]                 args <- list()
[10:32:41.909]                 for (kk in seq_along(NAMES)) {
[10:32:41.909]                   name <- changed[[kk]]
[10:32:41.909]                   NAME <- NAMES[[kk]]
[10:32:41.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.909]                     next
[10:32:41.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.909]                 }
[10:32:41.909]                 NAMES <- toupper(added)
[10:32:41.909]                 for (kk in seq_along(NAMES)) {
[10:32:41.909]                   name <- added[[kk]]
[10:32:41.909]                   NAME <- NAMES[[kk]]
[10:32:41.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.909]                     next
[10:32:41.909]                   args[[name]] <- ""
[10:32:41.909]                 }
[10:32:41.909]                 NAMES <- toupper(removed)
[10:32:41.909]                 for (kk in seq_along(NAMES)) {
[10:32:41.909]                   name <- removed[[kk]]
[10:32:41.909]                   NAME <- NAMES[[kk]]
[10:32:41.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.909]                     next
[10:32:41.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.909]                 }
[10:32:41.909]                 if (length(args) > 0) 
[10:32:41.909]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.909]             }
[10:32:41.909]             else {
[10:32:41.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.909]             }
[10:32:41.909]             {
[10:32:41.909]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.909]                   0L) {
[10:32:41.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.909]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.909]                   base::options(opts)
[10:32:41.909]                 }
[10:32:41.909]                 {
[10:32:41.909]                   {
[10:32:41.909]                     NULL
[10:32:41.909]                     RNGkind("Mersenne-Twister")
[10:32:41.909]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.909]                       inherits = FALSE)
[10:32:41.909]                   }
[10:32:41.909]                   options(future.plan = NULL)
[10:32:41.909]                   if (is.na(NA_character_)) 
[10:32:41.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.909]                     .init = FALSE)
[10:32:41.909]                 }
[10:32:41.909]             }
[10:32:41.909]         }
[10:32:41.909]     })
[10:32:41.909]     if (TRUE) {
[10:32:41.909]         base::sink(type = "output", split = FALSE)
[10:32:41.909]         if (TRUE) {
[10:32:41.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.909]         }
[10:32:41.909]         else {
[10:32:41.909]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.909]         }
[10:32:41.909]         base::close(...future.stdout)
[10:32:41.909]         ...future.stdout <- NULL
[10:32:41.909]     }
[10:32:41.909]     ...future.result$conditions <- ...future.conditions
[10:32:41.909]     ...future.result$finished <- base::Sys.time()
[10:32:41.909]     ...future.result
[10:32:41.909] }
[10:32:41.911] plan(): Setting new future strategy stack:
[10:32:41.911] List of future strategies:
[10:32:41.911] 1. sequential:
[10:32:41.911]    - args: function (..., envir = parent.frame())
[10:32:41.911]    - tweaked: FALSE
[10:32:41.911]    - call: NULL
[10:32:41.911] plan(): nbrOfWorkers() = 1
[10:32:41.912] plan(): Setting new future strategy stack:
[10:32:41.912] List of future strategies:
[10:32:41.912] 1. sequential:
[10:32:41.912]    - args: function (..., envir = parent.frame())
[10:32:41.912]    - tweaked: FALSE
[10:32:41.912]    - call: plan(strategy)
[10:32:41.912] plan(): nbrOfWorkers() = 1
[10:32:41.912] SequentialFuture started (and completed)
[10:32:41.913] - Launch lazy future ... done
[10:32:41.913] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[10:32:41.913] getGlobalsAndPackages() ...
[10:32:41.913] Searching for globals...
[10:32:41.917] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[10:32:41.917] Searching for globals ... DONE
[10:32:41.917] Resolving globals: FALSE
[10:32:41.917] 
[10:32:41.918] - packages: [1] ‘future’
[10:32:41.918] getGlobalsAndPackages() ... DONE
[10:32:41.918] run() for ‘Future’ ...
[10:32:41.918] - state: ‘created’
[10:32:41.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.919]   - Field: ‘label’
[10:32:41.919]   - Field: ‘local’
[10:32:41.919]   - Field: ‘owner’
[10:32:41.919]   - Field: ‘envir’
[10:32:41.919]   - Field: ‘packages’
[10:32:41.919]   - Field: ‘gc’
[10:32:41.919]   - Field: ‘conditions’
[10:32:41.919]   - Field: ‘expr’
[10:32:41.920]   - Field: ‘uuid’
[10:32:41.920]   - Field: ‘seed’
[10:32:41.920]   - Field: ‘version’
[10:32:41.920]   - Field: ‘result’
[10:32:41.920]   - Field: ‘asynchronous’
[10:32:41.920]   - Field: ‘calls’
[10:32:41.920]   - Field: ‘globals’
[10:32:41.920]   - Field: ‘stdout’
[10:32:41.920]   - Field: ‘earlySignal’
[10:32:41.920]   - Field: ‘lazy’
[10:32:41.920]   - Field: ‘state’
[10:32:41.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.921] - Launch lazy future ...
[10:32:41.921] Packages needed by the future expression (n = 1): ‘future’
[10:32:41.921] Packages needed by future strategies (n = 0): <none>
[10:32:41.921] {
[10:32:41.921]     {
[10:32:41.921]         {
[10:32:41.921]             ...future.startTime <- base::Sys.time()
[10:32:41.921]             {
[10:32:41.921]                 {
[10:32:41.921]                   {
[10:32:41.921]                     {
[10:32:41.921]                       base::local({
[10:32:41.921]                         has_future <- base::requireNamespace("future", 
[10:32:41.921]                           quietly = TRUE)
[10:32:41.921]                         if (has_future) {
[10:32:41.921]                           ns <- base::getNamespace("future")
[10:32:41.921]                           version <- ns[[".package"]][["version"]]
[10:32:41.921]                           if (is.null(version)) 
[10:32:41.921]                             version <- utils::packageVersion("future")
[10:32:41.921]                         }
[10:32:41.921]                         else {
[10:32:41.921]                           version <- NULL
[10:32:41.921]                         }
[10:32:41.921]                         if (!has_future || version < "1.8.0") {
[10:32:41.921]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.921]                             "", base::R.version$version.string), 
[10:32:41.921]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:41.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.921]                               "release", "version")], collapse = " "), 
[10:32:41.921]                             hostname = base::Sys.info()[["nodename"]])
[10:32:41.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.921]                             info)
[10:32:41.921]                           info <- base::paste(info, collapse = "; ")
[10:32:41.921]                           if (!has_future) {
[10:32:41.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.921]                               info)
[10:32:41.921]                           }
[10:32:41.921]                           else {
[10:32:41.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.921]                               info, version)
[10:32:41.921]                           }
[10:32:41.921]                           base::stop(msg)
[10:32:41.921]                         }
[10:32:41.921]                       })
[10:32:41.921]                     }
[10:32:41.921]                     base::local({
[10:32:41.921]                       for (pkg in "future") {
[10:32:41.921]                         base::loadNamespace(pkg)
[10:32:41.921]                         base::library(pkg, character.only = TRUE)
[10:32:41.921]                       }
[10:32:41.921]                     })
[10:32:41.921]                   }
[10:32:41.921]                   ...future.strategy.old <- future::plan("list")
[10:32:41.921]                   options(future.plan = NULL)
[10:32:41.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.921]                 }
[10:32:41.921]                 ...future.workdir <- getwd()
[10:32:41.921]             }
[10:32:41.921]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.921]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.921]         }
[10:32:41.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.921]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.921]             base::names(...future.oldOptions))
[10:32:41.921]     }
[10:32:41.921]     if (FALSE) {
[10:32:41.921]     }
[10:32:41.921]     else {
[10:32:41.921]         if (TRUE) {
[10:32:41.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.921]                 open = "w")
[10:32:41.921]         }
[10:32:41.921]         else {
[10:32:41.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.921]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.921]         }
[10:32:41.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.921]             base::sink(type = "output", split = FALSE)
[10:32:41.921]             base::close(...future.stdout)
[10:32:41.921]         }, add = TRUE)
[10:32:41.921]     }
[10:32:41.921]     ...future.frame <- base::sys.nframe()
[10:32:41.921]     ...future.conditions <- base::list()
[10:32:41.921]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.921]     if (FALSE) {
[10:32:41.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.921]     }
[10:32:41.921]     ...future.result <- base::tryCatch({
[10:32:41.921]         base::withCallingHandlers({
[10:32:41.921]             ...future.value <- base::withVisible(base::local({
[10:32:41.921]                 b <- 1
[10:32:41.921]                 c %<-% 2
[10:32:41.921]                 d <- 3
[10:32:41.921]                 4 %->% e
[10:32:41.921]                 b + c + d + e
[10:32:41.921]             }))
[10:32:41.921]             future::FutureResult(value = ...future.value$value, 
[10:32:41.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.921]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.921]                     ...future.globalenv.names))
[10:32:41.921]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.921]         }, condition = base::local({
[10:32:41.921]             c <- base::c
[10:32:41.921]             inherits <- base::inherits
[10:32:41.921]             invokeRestart <- base::invokeRestart
[10:32:41.921]             length <- base::length
[10:32:41.921]             list <- base::list
[10:32:41.921]             seq.int <- base::seq.int
[10:32:41.921]             signalCondition <- base::signalCondition
[10:32:41.921]             sys.calls <- base::sys.calls
[10:32:41.921]             `[[` <- base::`[[`
[10:32:41.921]             `+` <- base::`+`
[10:32:41.921]             `<<-` <- base::`<<-`
[10:32:41.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.921]                   3L)]
[10:32:41.921]             }
[10:32:41.921]             function(cond) {
[10:32:41.921]                 is_error <- inherits(cond, "error")
[10:32:41.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.921]                   NULL)
[10:32:41.921]                 if (is_error) {
[10:32:41.921]                   sessionInformation <- function() {
[10:32:41.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.921]                       search = base::search(), system = base::Sys.info())
[10:32:41.921]                   }
[10:32:41.921]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.921]                     cond$call), session = sessionInformation(), 
[10:32:41.921]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.921]                   signalCondition(cond)
[10:32:41.921]                 }
[10:32:41.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.921]                 "immediateCondition"))) {
[10:32:41.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.921]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.921]                   if (TRUE && !signal) {
[10:32:41.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.921]                     {
[10:32:41.921]                       inherits <- base::inherits
[10:32:41.921]                       invokeRestart <- base::invokeRestart
[10:32:41.921]                       is.null <- base::is.null
[10:32:41.921]                       muffled <- FALSE
[10:32:41.921]                       if (inherits(cond, "message")) {
[10:32:41.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.921]                         if (muffled) 
[10:32:41.921]                           invokeRestart("muffleMessage")
[10:32:41.921]                       }
[10:32:41.921]                       else if (inherits(cond, "warning")) {
[10:32:41.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.921]                         if (muffled) 
[10:32:41.921]                           invokeRestart("muffleWarning")
[10:32:41.921]                       }
[10:32:41.921]                       else if (inherits(cond, "condition")) {
[10:32:41.921]                         if (!is.null(pattern)) {
[10:32:41.921]                           computeRestarts <- base::computeRestarts
[10:32:41.921]                           grepl <- base::grepl
[10:32:41.921]                           restarts <- computeRestarts(cond)
[10:32:41.921]                           for (restart in restarts) {
[10:32:41.921]                             name <- restart$name
[10:32:41.921]                             if (is.null(name)) 
[10:32:41.921]                               next
[10:32:41.921]                             if (!grepl(pattern, name)) 
[10:32:41.921]                               next
[10:32:41.921]                             invokeRestart(restart)
[10:32:41.921]                             muffled <- TRUE
[10:32:41.921]                             break
[10:32:41.921]                           }
[10:32:41.921]                         }
[10:32:41.921]                       }
[10:32:41.921]                       invisible(muffled)
[10:32:41.921]                     }
[10:32:41.921]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.921]                   }
[10:32:41.921]                 }
[10:32:41.921]                 else {
[10:32:41.921]                   if (TRUE) {
[10:32:41.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.921]                     {
[10:32:41.921]                       inherits <- base::inherits
[10:32:41.921]                       invokeRestart <- base::invokeRestart
[10:32:41.921]                       is.null <- base::is.null
[10:32:41.921]                       muffled <- FALSE
[10:32:41.921]                       if (inherits(cond, "message")) {
[10:32:41.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.921]                         if (muffled) 
[10:32:41.921]                           invokeRestart("muffleMessage")
[10:32:41.921]                       }
[10:32:41.921]                       else if (inherits(cond, "warning")) {
[10:32:41.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.921]                         if (muffled) 
[10:32:41.921]                           invokeRestart("muffleWarning")
[10:32:41.921]                       }
[10:32:41.921]                       else if (inherits(cond, "condition")) {
[10:32:41.921]                         if (!is.null(pattern)) {
[10:32:41.921]                           computeRestarts <- base::computeRestarts
[10:32:41.921]                           grepl <- base::grepl
[10:32:41.921]                           restarts <- computeRestarts(cond)
[10:32:41.921]                           for (restart in restarts) {
[10:32:41.921]                             name <- restart$name
[10:32:41.921]                             if (is.null(name)) 
[10:32:41.921]                               next
[10:32:41.921]                             if (!grepl(pattern, name)) 
[10:32:41.921]                               next
[10:32:41.921]                             invokeRestart(restart)
[10:32:41.921]                             muffled <- TRUE
[10:32:41.921]                             break
[10:32:41.921]                           }
[10:32:41.921]                         }
[10:32:41.921]                       }
[10:32:41.921]                       invisible(muffled)
[10:32:41.921]                     }
[10:32:41.921]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.921]                   }
[10:32:41.921]                 }
[10:32:41.921]             }
[10:32:41.921]         }))
[10:32:41.921]     }, error = function(ex) {
[10:32:41.921]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.921]                 ...future.rng), started = ...future.startTime, 
[10:32:41.921]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.921]             version = "1.8"), class = "FutureResult")
[10:32:41.921]     }, finally = {
[10:32:41.921]         if (!identical(...future.workdir, getwd())) 
[10:32:41.921]             setwd(...future.workdir)
[10:32:41.921]         {
[10:32:41.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.921]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.921]             }
[10:32:41.921]             base::options(...future.oldOptions)
[10:32:41.921]             if (.Platform$OS.type == "windows") {
[10:32:41.921]                 old_names <- names(...future.oldEnvVars)
[10:32:41.921]                 envs <- base::Sys.getenv()
[10:32:41.921]                 names <- names(envs)
[10:32:41.921]                 common <- intersect(names, old_names)
[10:32:41.921]                 added <- setdiff(names, old_names)
[10:32:41.921]                 removed <- setdiff(old_names, names)
[10:32:41.921]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.921]                   envs[common]]
[10:32:41.921]                 NAMES <- toupper(changed)
[10:32:41.921]                 args <- list()
[10:32:41.921]                 for (kk in seq_along(NAMES)) {
[10:32:41.921]                   name <- changed[[kk]]
[10:32:41.921]                   NAME <- NAMES[[kk]]
[10:32:41.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.921]                     next
[10:32:41.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.921]                 }
[10:32:41.921]                 NAMES <- toupper(added)
[10:32:41.921]                 for (kk in seq_along(NAMES)) {
[10:32:41.921]                   name <- added[[kk]]
[10:32:41.921]                   NAME <- NAMES[[kk]]
[10:32:41.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.921]                     next
[10:32:41.921]                   args[[name]] <- ""
[10:32:41.921]                 }
[10:32:41.921]                 NAMES <- toupper(removed)
[10:32:41.921]                 for (kk in seq_along(NAMES)) {
[10:32:41.921]                   name <- removed[[kk]]
[10:32:41.921]                   NAME <- NAMES[[kk]]
[10:32:41.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.921]                     next
[10:32:41.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.921]                 }
[10:32:41.921]                 if (length(args) > 0) 
[10:32:41.921]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.921]             }
[10:32:41.921]             else {
[10:32:41.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.921]             }
[10:32:41.921]             {
[10:32:41.921]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.921]                   0L) {
[10:32:41.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.921]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.921]                   base::options(opts)
[10:32:41.921]                 }
[10:32:41.921]                 {
[10:32:41.921]                   {
[10:32:41.921]                     NULL
[10:32:41.921]                     RNGkind("Mersenne-Twister")
[10:32:41.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.921]                       inherits = FALSE)
[10:32:41.921]                   }
[10:32:41.921]                   options(future.plan = NULL)
[10:32:41.921]                   if (is.na(NA_character_)) 
[10:32:41.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.921]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.921]                     .init = FALSE)
[10:32:41.921]                 }
[10:32:41.921]             }
[10:32:41.921]         }
[10:32:41.921]     })
[10:32:41.921]     if (TRUE) {
[10:32:41.921]         base::sink(type = "output", split = FALSE)
[10:32:41.921]         if (TRUE) {
[10:32:41.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.921]         }
[10:32:41.921]         else {
[10:32:41.921]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.921]         }
[10:32:41.921]         base::close(...future.stdout)
[10:32:41.921]         ...future.stdout <- NULL
[10:32:41.921]     }
[10:32:41.921]     ...future.result$conditions <- ...future.conditions
[10:32:41.921]     ...future.result$finished <- base::Sys.time()
[10:32:41.921]     ...future.result
[10:32:41.921] }
[10:32:41.923] plan(): Setting new future strategy stack:
[10:32:41.924] List of future strategies:
[10:32:41.924] 1. sequential:
[10:32:41.924]    - args: function (..., envir = parent.frame())
[10:32:41.924]    - tweaked: FALSE
[10:32:41.924]    - call: NULL
[10:32:41.924] plan(): nbrOfWorkers() = 1
[10:32:41.960] plan(): Setting new future strategy stack:
[10:32:41.960] List of future strategies:
[10:32:41.960] 1. sequential:
[10:32:41.960]    - args: function (..., envir = parent.frame())
[10:32:41.960]    - tweaked: FALSE
[10:32:41.960]    - call: plan(strategy)
[10:32:41.960] plan(): nbrOfWorkers() = 1
[10:32:41.960] SequentialFuture started (and completed)
[10:32:41.961] signalConditions() ...
[10:32:41.961]  - include = ‘immediateCondition’
[10:32:41.961]  - exclude = 
[10:32:41.961]  - resignal = FALSE
[10:32:41.961]  - Number of conditions: 88
[10:32:41.961] signalConditions() ... done
[10:32:41.961] - Launch lazy future ... done
[10:32:41.961] run() for ‘SequentialFuture’ ... done
[10:32:41.962] signalConditions() ...
[10:32:41.962]  - include = ‘immediateCondition’
[10:32:41.962]  - exclude = 
[10:32:41.962]  - resignal = FALSE
[10:32:41.962]  - Number of conditions: 88
[10:32:41.962] signalConditions() ... done
[10:32:41.962] Future state: ‘finished’
[10:32:41.962] signalConditions() ...
[10:32:41.962]  - include = ‘condition’
[10:32:41.962]  - exclude = ‘immediateCondition’
[10:32:41.963]  - resignal = TRUE
[10:32:41.963]  - Number of conditions: 88
[10:32:41.963]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.924] getGlobalsAndPackages() ...
[10:32:41.963]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.925] Searching for globals...
[10:32:41.963]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.940] 
[10:32:41.963]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.940] Searching for globals ... DONE
[10:32:41.963]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.940] - globals: [0] <none>
[10:32:41.963]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.941] getGlobalsAndPackages() ... DONE
[10:32:41.964]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.941] run() for ‘Future’ ...
[10:32:41.964]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.941] - state: ‘created’
[10:32:41.964]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.941] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.964]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.964]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.964]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘label’
[10:32:41.964]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘local’
[10:32:41.965]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘owner’
[10:32:41.965]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘envir’
[10:32:41.965]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘packages’
[10:32:41.965]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘gc’
[10:32:41.965]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘conditions’
[10:32:41.965]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.942]   - Field: ‘expr’
[10:32:41.965]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘uuid’
[10:32:41.966]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘seed’
[10:32:41.966]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘version’
[10:32:41.966]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘result’
[10:32:41.966]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘asynchronous’
[10:32:41.966]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘calls’
[10:32:41.966]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘globals’
[10:32:41.966]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘stdout’
[10:32:41.966]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘earlySignal’
[10:32:41.967]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.943]   - Field: ‘lazy’
[10:32:41.967]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.944]   - Field: ‘state’
[10:32:41.967]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.967]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.944] - Launch lazy future ...
[10:32:41.967]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.944] Packages needed by the future expression (n = 0): <none>
[10:32:41.967]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.944] Packages needed by future strategies (n = 0): <none>
[10:32:41.967]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.945] {
[10:32:41.945]     {
[10:32:41.945]         {
[10:32:41.945]             ...future.startTime <- base::Sys.time()
[10:32:41.945]             {
[10:32:41.945]                 {
[10:32:41.945]                   {
[10:32:41.945]                     base::local({
[10:32:41.945]                       has_future <- base::requireNamespace("future", 
[10:32:41.945]                         quietly = TRUE)
[10:32:41.945]                       if (has_future) {
[10:32:41.945]                         ns <- base::getNamespace("future")
[10:32:41.945]                         version <- ns[[".package"]][["version"]]
[10:32:41.945]                         if (is.null(version)) 
[10:32:41.945]                           version <- utils::packageVersion("future")
[10:32:41.945]                       }
[10:32:41.945]                       else {
[10:32:41.945]                         version <- NULL
[10:32:41.945]                       }
[10:32:41.945]                       if (!has_future || version < "1.8.0") {
[10:32:41.945]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.945]                           "", base::R.version$version.string), 
[10:32:41.945]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.945]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.945]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.945]                             "release", "version")], collapse = " "), 
[10:32:41.945]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.945]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.945]                           info)
[10:32:41.945]                         info <- base::paste(info, collapse = "; ")
[10:32:41.945]                         if (!has_future) {
[10:32:41.945]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.945]                             info)
[10:32:41.945]                         }
[10:32:41.945]                         else {
[10:32:41.945]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.945]                             info, version)
[10:32:41.945]                         }
[10:32:41.945]                         base::stop(msg)
[10:32:41.945]                       }
[10:32:41.945]                     })
[10:32:41.945]                   }
[10:32:41.945]                   ...future.strategy.old <- future::plan("list")
[10:32:41.945]                   options(future.plan = NULL)
[10:32:41.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.945]                 }
[10:32:41.945]                 ...future.workdir <- getwd()
[10:32:41.945]             }
[10:32:41.945]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.945]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.945]         }
[10:32:41.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.945]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.945]             base::names(...future.oldOptions))
[10:32:41.945]     }
[10:32:41.945]     if (FALSE) {
[10:32:41.945]     }
[10:32:41.945]     else {
[10:32:41.945]         if (TRUE) {
[10:32:41.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.945]                 open = "w")
[10:32:41.945]         }
[10:32:41.945]         else {
[10:32:41.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.945]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.945]         }
[10:32:41.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.945]             base::sink(type = "output", split = FALSE)
[10:32:41.945]             base::close(...future.stdout)
[10:32:41.945]         }, add = TRUE)
[10:32:41.945]     }
[10:32:41.945]     ...future.frame <- base::sys.nframe()
[10:32:41.945]     ...future.conditions <- base::list()
[10:32:41.945]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.945]     if (FALSE) {
[10:32:41.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.945]     }
[10:32:41.945]     ...future.result <- base::tryCatch({
[10:32:41.945]         base::withCallingHandlers({
[10:32:41.945]             ...future.value <- base::withVisible(base::local(2))
[10:32:41.945]             future::FutureResult(value = ...future.value$value, 
[10:32:41.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.945]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.945]                     ...future.globalenv.names))
[10:32:41.945]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.945]         }, condition = base::local({
[10:32:41.945]             c <- base::c
[10:32:41.945]             inherits <- base::inherits
[10:32:41.945]             invokeRestart <- base::invokeRestart
[10:32:41.945]             length <- base::length
[10:32:41.945]             list <- base::list
[10:32:41.945]             seq.int <- base::seq.int
[10:32:41.945]             signalCondition <- base::signalCondition
[10:32:41.945]             sys.calls <- base::sys.calls
[10:32:41.945]             `[[` <- base::`[[`
[10:32:41.945]             `+` <- base::`+`
[10:32:41.945]             `<<-` <- base::`<<-`
[10:32:41.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.945]                   3L)]
[10:32:41.945]             }
[10:32:41.945]             function(cond) {
[10:32:41.945]                 is_error <- inherits(cond, "error")
[10:32:41.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.945]                   NULL)
[10:32:41.945]                 if (is_error) {
[10:32:41.945]                   sessionInformation <- function() {
[10:32:41.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.945]                       search = base::search(), system = base::Sys.info())
[10:32:41.945]                   }
[10:32:41.945]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.945]                     cond$call), session = sessionInformation(), 
[10:32:41.945]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.945]                   signalCondition(cond)
[10:32:41.945]                 }
[10:32:41.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.945]                 "immediateCondition"))) {
[10:32:41.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.945]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.945]                   if (TRUE && !signal) {
[10:32:41.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.945]                     {
[10:32:41.945]                       inherits <- base::inherits
[10:32:41.945]                       invokeRestart <- base::invokeRestart
[10:32:41.945]                       is.null <- base::is.null
[10:32:41.945]                       muffled <- FALSE
[10:32:41.945]                       if (inherits(cond, "message")) {
[10:32:41.945]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.945]                         if (muffled) 
[10:32:41.945]                           invokeRestart("muffleMessage")
[10:32:41.945]                       }
[10:32:41.945]                       else if (inherits(cond, "warning")) {
[10:32:41.945]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.945]                         if (muffled) 
[10:32:41.945]                           invokeRestart("muffleWarning")
[10:32:41.945]                       }
[10:32:41.945]                       else if (inherits(cond, "condition")) {
[10:32:41.945]                         if (!is.null(pattern)) {
[10:32:41.945]                           computeRestarts <- base::computeRestarts
[10:32:41.945]                           grepl <- base::grepl
[10:32:41.945]                           restarts <- computeRestarts(cond)
[10:32:41.945]                           for (restart in restarts) {
[10:32:41.945]                             name <- restart$name
[10:32:41.945]                             if (is.null(name)) 
[10:32:41.945]                               next
[10:32:41.945]                             if (!grepl(pattern, name)) 
[10:32:41.945]                               next
[10:32:41.945]                             invokeRestart(restart)
[10:32:41.945]                             muffled <- TRUE
[10:32:41.945]                             break
[10:32:41.945]                           }
[10:32:41.945]                         }
[10:32:41.945]                       }
[10:32:41.945]                       invisible(muffled)
[10:32:41.945]                     }
[10:32:41.945]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.945]                   }
[10:32:41.945]                 }
[10:32:41.945]                 else {
[10:32:41.945]                   if (TRUE) {
[10:32:41.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.945]                     {
[10:32:41.945]                       inherits <- base::inherits
[10:32:41.945]                       invokeRestart <- base::invokeRestart
[10:32:41.945]                       is.null <- base::is.null
[10:32:41.945]                       muffled <- FALSE
[10:32:41.945]                       if (inherits(cond, "message")) {
[10:32:41.945]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.945]                         if (muffled) 
[10:32:41.945]                           invokeRestart("muffleMessage")
[10:32:41.945]                       }
[10:32:41.945]                       else if (inherits(cond, "warning")) {
[10:32:41.945]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.945]                         if (muffled) 
[10:32:41.945]                           invokeRestart("muffleWarning")
[10:32:41.945]                       }
[10:32:41.945]                       else if (inherits(cond, "condition")) {
[10:32:41.945]                         if (!is.null(pattern)) {
[10:32:41.945]                           computeRestarts <- base::computeRestarts
[10:32:41.945]                           grepl <- base::grepl
[10:32:41.945]                           restarts <- computeRestarts(cond)
[10:32:41.945]                           for (restart in restarts) {
[10:32:41.945]                             name <- restart$name
[10:32:41.945]                             if (is.null(name)) 
[10:32:41.945]                               next
[10:32:41.945]                             if (!grepl(pattern, name)) 
[10:32:41.945]                               next
[10:32:41.945]                             invokeRestart(restart)
[10:32:41.945]                             muffled <- TRUE
[10:32:41.945]                             break
[10:32:41.945]                           }
[10:32:41.945]                         }
[10:32:41.945]                       }
[10:32:41.945]                       invisible(muffled)
[10:32:41.945]                     }
[10:32:41.945]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.945]                   }
[10:32:41.945]                 }
[10:32:41.945]             }
[10:32:41.945]         }))
[10:32:41.945]     }, error = function(ex) {
[10:32:41.945]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.945]                 ...future.rng), started = ...future.startTime, 
[10:32:41.945]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.945]             version = "1.8"), class = "FutureResult")
[10:32:41.945]     }, finally = {
[10:32:41.945]         if (!identical(...future.workdir, getwd())) 
[10:32:41.945]             setwd(...future.workdir)
[10:32:41.945]         {
[10:32:41.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.945]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.945]             }
[10:32:41.945]             base::options(...future.oldOptions)
[10:32:41.945]             if (.Platform$OS.type == "windows") {
[10:32:41.945]                 old_names <- names(...future.oldEnvVars)
[10:32:41.945]                 envs <- base::Sys.getenv()
[10:32:41.945]                 names <- names(envs)
[10:32:41.945]                 common <- intersect(names, old_names)
[10:32:41.945]                 added <- setdiff(names, old_names)
[10:32:41.945]                 removed <- setdiff(old_names, names)
[10:32:41.945]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.945]                   envs[common]]
[10:32:41.945]                 NAMES <- toupper(changed)
[10:32:41.945]                 args <- list()
[10:32:41.945]                 for (kk in seq_along(NAMES)) {
[10:32:41.945]                   name <- changed[[kk]]
[10:32:41.945]                   NAME <- NAMES[[kk]]
[10:32:41.945]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.945]                     next
[10:32:41.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.945]                 }
[10:32:41.945]                 NAMES <- toupper(added)
[10:32:41.945]                 for (kk in seq_along(NAMES)) {
[10:32:41.945]                   name <- added[[kk]]
[10:32:41.945]                   NAME <- NAMES[[kk]]
[10:32:41.945]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.945]                     next
[10:32:41.945]                   args[[name]] <- ""
[10:32:41.945]                 }
[10:32:41.945]                 NAMES <- toupper(removed)
[10:32:41.945]                 for (kk in seq_along(NAMES)) {
[10:32:41.945]                   name <- removed[[kk]]
[10:32:41.945]                   NAME <- NAMES[[kk]]
[10:32:41.945]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.945]                     next
[10:32:41.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.945]                 }
[10:32:41.945]                 if (length(args) > 0) 
[10:32:41.945]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.945]             }
[10:32:41.945]             else {
[10:32:41.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.945]             }
[10:32:41.945]             {
[10:32:41.945]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.945]                   0L) {
[10:32:41.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.945]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.945]                   base::options(opts)
[10:32:41.945]                 }
[10:32:41.945]                 {
[10:32:41.945]                   {
[10:32:41.945]                     NULL
[10:32:41.945]                     RNGkind("Mersenne-Twister")
[10:32:41.945]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.945]                       inherits = FALSE)
[10:32:41.945]                   }
[10:32:41.945]                   options(future.plan = NULL)
[10:32:41.945]                   if (is.na(NA_character_)) 
[10:32:41.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.945]                     .init = FALSE)
[10:32:41.945]                 }
[10:32:41.945]             }
[10:32:41.945]         }
[10:32:41.945]     })
[10:32:41.945]     if (TRUE) {
[10:32:41.945]         base::sink(type = "output", split = FALSE)
[10:32:41.945]         if (TRUE) {
[10:32:41.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.945]         }
[10:32:41.945]         else {
[10:32:41.945]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.945]         }
[10:32:41.945]         base::close(...future.stdout)
[10:32:41.945]         ...future.stdout <- NULL
[10:32:41.945]     }
[10:32:41.945]     ...future.result$conditions <- ...future.conditions
[10:32:41.945]     ...future.result$finished <- base::Sys.time()
[10:32:41.945]     ...future.result
[10:32:41.945] }
[10:32:41.968]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.948] plan(): Setting new future strategy stack:
[10:32:41.968]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.948] List of future strategies:
[10:32:41.948] 1. sequential:
[10:32:41.948]    - args: function (..., envir = parent.frame())
[10:32:41.948]    - tweaked: FALSE
[10:32:41.948]    - call: NULL
[10:32:41.968]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.948] plan(): nbrOfWorkers() = 1
[10:32:41.968]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.949] plan(): Setting new future strategy stack:
[10:32:41.968]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.949] List of future strategies:
[10:32:41.949] 1. sequential:
[10:32:41.949]    - args: function (..., envir = parent.frame())
[10:32:41.949]    - tweaked: FALSE
[10:32:41.949]    - call: NULL
[10:32:41.968]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.950] plan(): nbrOfWorkers() = 1
[10:32:41.968]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.950] SequentialFuture started (and completed)
[10:32:41.968]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.950] - Launch lazy future ... done
[10:32:41.969]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.950] run() for ‘SequentialFuture’ ... done
[10:32:41.969]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.950] getGlobalsAndPackages() ...
[10:32:41.969]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.951] Searching for globals...
[10:32:41.969]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.951] 
[10:32:41.969]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.951] Searching for globals ... DONE
[10:32:41.969]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.951] - globals: [0] <none>
[10:32:41.969]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.951] getGlobalsAndPackages() ... DONE
[10:32:41.970]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.951] run() for ‘Future’ ...
[10:32:41.970]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952] - state: ‘created’
[10:32:41.970]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.970]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.970]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.970]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952]   - Field: ‘label’
[10:32:41.970]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952]   - Field: ‘local’
[10:32:41.970]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.952]   - Field: ‘owner’
[10:32:41.971]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘envir’
[10:32:41.971]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘packages’
[10:32:41.971]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘gc’
[10:32:41.971]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘conditions’
[10:32:41.971]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘expr’
[10:32:41.971]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘uuid’
[10:32:41.971]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘seed’
[10:32:41.972]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘version’
[10:32:41.972]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘result’
[10:32:41.974]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.953]   - Field: ‘asynchronous’
[10:32:41.974]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954]   - Field: ‘calls’
[10:32:41.974]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954]   - Field: ‘globals’
[10:32:41.974]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954]   - Field: ‘stdout’
[10:32:41.974]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954]   - Field: ‘earlySignal’
[10:32:41.974]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954]   - Field: ‘lazy’
[10:32:41.974]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954]   - Field: ‘state’
[10:32:41.975]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.975]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.954] - Launch lazy future ...
[10:32:41.975]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.955] Packages needed by the future expression (n = 0): <none>
[10:32:41.975]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.955] Packages needed by future strategies (n = 0): <none>
[10:32:41.975]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.955] {
[10:32:41.955]     {
[10:32:41.955]         {
[10:32:41.955]             ...future.startTime <- base::Sys.time()
[10:32:41.955]             {
[10:32:41.955]                 {
[10:32:41.955]                   {
[10:32:41.955]                     base::local({
[10:32:41.955]                       has_future <- base::requireNamespace("future", 
[10:32:41.955]                         quietly = TRUE)
[10:32:41.955]                       if (has_future) {
[10:32:41.955]                         ns <- base::getNamespace("future")
[10:32:41.955]                         version <- ns[[".package"]][["version"]]
[10:32:41.955]                         if (is.null(version)) 
[10:32:41.955]                           version <- utils::packageVersion("future")
[10:32:41.955]                       }
[10:32:41.955]                       else {
[10:32:41.955]                         version <- NULL
[10:32:41.955]                       }
[10:32:41.955]                       if (!has_future || version < "1.8.0") {
[10:32:41.955]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.955]                           "", base::R.version$version.string), 
[10:32:41.955]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.955]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.955]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.955]                             "release", "version")], collapse = " "), 
[10:32:41.955]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.955]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.955]                           info)
[10:32:41.955]                         info <- base::paste(info, collapse = "; ")
[10:32:41.955]                         if (!has_future) {
[10:32:41.955]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.955]                             info)
[10:32:41.955]                         }
[10:32:41.955]                         else {
[10:32:41.955]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.955]                             info, version)
[10:32:41.955]                         }
[10:32:41.955]                         base::stop(msg)
[10:32:41.955]                       }
[10:32:41.955]                     })
[10:32:41.955]                   }
[10:32:41.955]                   ...future.strategy.old <- future::plan("list")
[10:32:41.955]                   options(future.plan = NULL)
[10:32:41.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.955]                 }
[10:32:41.955]                 ...future.workdir <- getwd()
[10:32:41.955]             }
[10:32:41.955]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.955]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.955]         }
[10:32:41.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.955]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.955]             base::names(...future.oldOptions))
[10:32:41.955]     }
[10:32:41.955]     if (FALSE) {
[10:32:41.955]     }
[10:32:41.955]     else {
[10:32:41.955]         if (TRUE) {
[10:32:41.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.955]                 open = "w")
[10:32:41.955]         }
[10:32:41.955]         else {
[10:32:41.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.955]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.955]         }
[10:32:41.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.955]             base::sink(type = "output", split = FALSE)
[10:32:41.955]             base::close(...future.stdout)
[10:32:41.955]         }, add = TRUE)
[10:32:41.955]     }
[10:32:41.955]     ...future.frame <- base::sys.nframe()
[10:32:41.955]     ...future.conditions <- base::list()
[10:32:41.955]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.955]     if (FALSE) {
[10:32:41.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.955]     }
[10:32:41.955]     ...future.result <- base::tryCatch({
[10:32:41.955]         base::withCallingHandlers({
[10:32:41.955]             ...future.value <- base::withVisible(base::local(4))
[10:32:41.955]             future::FutureResult(value = ...future.value$value, 
[10:32:41.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.955]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.955]                     ...future.globalenv.names))
[10:32:41.955]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.955]         }, condition = base::local({
[10:32:41.955]             c <- base::c
[10:32:41.955]             inherits <- base::inherits
[10:32:41.955]             invokeRestart <- base::invokeRestart
[10:32:41.955]             length <- base::length
[10:32:41.955]             list <- base::list
[10:32:41.955]             seq.int <- base::seq.int
[10:32:41.955]             signalCondition <- base::signalCondition
[10:32:41.955]             sys.calls <- base::sys.calls
[10:32:41.955]             `[[` <- base::`[[`
[10:32:41.955]             `+` <- base::`+`
[10:32:41.955]             `<<-` <- base::`<<-`
[10:32:41.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.955]                   3L)]
[10:32:41.955]             }
[10:32:41.955]             function(cond) {
[10:32:41.955]                 is_error <- inherits(cond, "error")
[10:32:41.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.955]                   NULL)
[10:32:41.955]                 if (is_error) {
[10:32:41.955]                   sessionInformation <- function() {
[10:32:41.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.955]                       search = base::search(), system = base::Sys.info())
[10:32:41.955]                   }
[10:32:41.955]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.955]                     cond$call), session = sessionInformation(), 
[10:32:41.955]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.955]                   signalCondition(cond)
[10:32:41.955]                 }
[10:32:41.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.955]                 "immediateCondition"))) {
[10:32:41.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.955]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.955]                   if (TRUE && !signal) {
[10:32:41.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.955]                     {
[10:32:41.955]                       inherits <- base::inherits
[10:32:41.955]                       invokeRestart <- base::invokeRestart
[10:32:41.955]                       is.null <- base::is.null
[10:32:41.955]                       muffled <- FALSE
[10:32:41.955]                       if (inherits(cond, "message")) {
[10:32:41.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.955]                         if (muffled) 
[10:32:41.955]                           invokeRestart("muffleMessage")
[10:32:41.955]                       }
[10:32:41.955]                       else if (inherits(cond, "warning")) {
[10:32:41.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.955]                         if (muffled) 
[10:32:41.955]                           invokeRestart("muffleWarning")
[10:32:41.955]                       }
[10:32:41.955]                       else if (inherits(cond, "condition")) {
[10:32:41.955]                         if (!is.null(pattern)) {
[10:32:41.955]                           computeRestarts <- base::computeRestarts
[10:32:41.955]                           grepl <- base::grepl
[10:32:41.955]                           restarts <- computeRestarts(cond)
[10:32:41.955]                           for (restart in restarts) {
[10:32:41.955]                             name <- restart$name
[10:32:41.955]                             if (is.null(name)) 
[10:32:41.955]                               next
[10:32:41.955]                             if (!grepl(pattern, name)) 
[10:32:41.955]                               next
[10:32:41.955]                             invokeRestart(restart)
[10:32:41.955]                             muffled <- TRUE
[10:32:41.955]                             break
[10:32:41.955]                           }
[10:32:41.955]                         }
[10:32:41.955]                       }
[10:32:41.955]                       invisible(muffled)
[10:32:41.955]                     }
[10:32:41.955]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.955]                   }
[10:32:41.955]                 }
[10:32:41.955]                 else {
[10:32:41.955]                   if (TRUE) {
[10:32:41.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.955]                     {
[10:32:41.955]                       inherits <- base::inherits
[10:32:41.955]                       invokeRestart <- base::invokeRestart
[10:32:41.955]                       is.null <- base::is.null
[10:32:41.955]                       muffled <- FALSE
[10:32:41.955]                       if (inherits(cond, "message")) {
[10:32:41.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.955]                         if (muffled) 
[10:32:41.955]                           invokeRestart("muffleMessage")
[10:32:41.955]                       }
[10:32:41.955]                       else if (inherits(cond, "warning")) {
[10:32:41.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.955]                         if (muffled) 
[10:32:41.955]                           invokeRestart("muffleWarning")
[10:32:41.955]                       }
[10:32:41.955]                       else if (inherits(cond, "condition")) {
[10:32:41.955]                         if (!is.null(pattern)) {
[10:32:41.955]                           computeRestarts <- base::computeRestarts
[10:32:41.955]                           grepl <- base::grepl
[10:32:41.955]                           restarts <- computeRestarts(cond)
[10:32:41.955]                           for (restart in restarts) {
[10:32:41.955]                             name <- restart$name
[10:32:41.955]                             if (is.null(name)) 
[10:32:41.955]                               next
[10:32:41.955]                             if (!grepl(pattern, name)) 
[10:32:41.955]                               next
[10:32:41.955]                             invokeRestart(restart)
[10:32:41.955]                             muffled <- TRUE
[10:32:41.955]                             break
[10:32:41.955]                           }
[10:32:41.955]                         }
[10:32:41.955]                       }
[10:32:41.955]                       invisible(muffled)
[10:32:41.955]                     }
[10:32:41.955]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.955]                   }
[10:32:41.955]                 }
[10:32:41.955]             }
[10:32:41.955]         }))
[10:32:41.955]     }, error = function(ex) {
[10:32:41.955]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.955]                 ...future.rng), started = ...future.startTime, 
[10:32:41.955]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.955]             version = "1.8"), class = "FutureResult")
[10:32:41.955]     }, finally = {
[10:32:41.955]         if (!identical(...future.workdir, getwd())) 
[10:32:41.955]             setwd(...future.workdir)
[10:32:41.955]         {
[10:32:41.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.955]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.955]             }
[10:32:41.955]             base::options(...future.oldOptions)
[10:32:41.955]             if (.Platform$OS.type == "windows") {
[10:32:41.955]                 old_names <- names(...future.oldEnvVars)
[10:32:41.955]                 envs <- base::Sys.getenv()
[10:32:41.955]                 names <- names(envs)
[10:32:41.955]                 common <- intersect(names, old_names)
[10:32:41.955]                 added <- setdiff(names, old_names)
[10:32:41.955]                 removed <- setdiff(old_names, names)
[10:32:41.955]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.955]                   envs[common]]
[10:32:41.955]                 NAMES <- toupper(changed)
[10:32:41.955]                 args <- list()
[10:32:41.955]                 for (kk in seq_along(NAMES)) {
[10:32:41.955]                   name <- changed[[kk]]
[10:32:41.955]                   NAME <- NAMES[[kk]]
[10:32:41.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.955]                     next
[10:32:41.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.955]                 }
[10:32:41.955]                 NAMES <- toupper(added)
[10:32:41.955]                 for (kk in seq_along(NAMES)) {
[10:32:41.955]                   name <- added[[kk]]
[10:32:41.955]                   NAME <- NAMES[[kk]]
[10:32:41.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.955]                     next
[10:32:41.955]                   args[[name]] <- ""
[10:32:41.955]                 }
[10:32:41.955]                 NAMES <- toupper(removed)
[10:32:41.955]                 for (kk in seq_along(NAMES)) {
[10:32:41.955]                   name <- removed[[kk]]
[10:32:41.955]                   NAME <- NAMES[[kk]]
[10:32:41.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.955]                     next
[10:32:41.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.955]                 }
[10:32:41.955]                 if (length(args) > 0) 
[10:32:41.955]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.955]             }
[10:32:41.955]             else {
[10:32:41.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.955]             }
[10:32:41.955]             {
[10:32:41.955]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.955]                   0L) {
[10:32:41.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.955]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.955]                   base::options(opts)
[10:32:41.955]                 }
[10:32:41.955]                 {
[10:32:41.955]                   {
[10:32:41.955]                     NULL
[10:32:41.955]                     RNGkind("Mersenne-Twister")
[10:32:41.955]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.955]                       inherits = FALSE)
[10:32:41.955]                   }
[10:32:41.955]                   options(future.plan = NULL)
[10:32:41.955]                   if (is.na(NA_character_)) 
[10:32:41.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.955]                     .init = FALSE)
[10:32:41.955]                 }
[10:32:41.955]             }
[10:32:41.955]         }
[10:32:41.955]     })
[10:32:41.955]     if (TRUE) {
[10:32:41.955]         base::sink(type = "output", split = FALSE)
[10:32:41.955]         if (TRUE) {
[10:32:41.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.955]         }
[10:32:41.955]         else {
[10:32:41.955]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.955]         }
[10:32:41.955]         base::close(...future.stdout)
[10:32:41.955]         ...future.stdout <- NULL
[10:32:41.955]     }
[10:32:41.955]     ...future.result$conditions <- ...future.conditions
[10:32:41.955]     ...future.result$finished <- base::Sys.time()
[10:32:41.955]     ...future.result
[10:32:41.955] }
[10:32:41.976]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.957] plan(): Setting new future strategy stack:
[10:32:41.976]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.957] List of future strategies:
[10:32:41.957] 1. sequential:
[10:32:41.957]    - args: function (..., envir = parent.frame())
[10:32:41.957]    - tweaked: FALSE
[10:32:41.957]    - call: NULL
[10:32:41.976]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.957] plan(): nbrOfWorkers() = 1
[10:32:41.976]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.958] plan(): Setting new future strategy stack:
[10:32:41.976]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.958] List of future strategies:
[10:32:41.958] 1. sequential:
[10:32:41.958]    - args: function (..., envir = parent.frame())
[10:32:41.958]    - tweaked: FALSE
[10:32:41.958]    - call: NULL
[10:32:41.976]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.959] plan(): nbrOfWorkers() = 1
[10:32:41.976]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.959] SequentialFuture started (and completed)
[10:32:41.976]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.959] - Launch lazy future ... done
[10:32:41.977]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:41.959] run() for ‘SequentialFuture’ ... done
[10:32:41.977] signalConditions() ... done
a = 10
[10:32:41.977] getGlobalsAndPackages() ...
[10:32:41.977] Searching for globals...
[10:32:41.978] - globals found: [3] ‘{’, ‘+’, ‘a’
[10:32:41.978] Searching for globals ... DONE
[10:32:41.978] Resolving globals: FALSE
[10:32:41.979] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:41.979] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:32:41.979] - globals: [1] ‘a’
[10:32:41.979] 
[10:32:41.979] getGlobalsAndPackages() ... DONE
[10:32:41.980] run() for ‘Future’ ...
[10:32:41.980] - state: ‘created’
[10:32:41.980] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:41.980] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:41.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:41.980]   - Field: ‘label’
[10:32:41.980]   - Field: ‘local’
[10:32:41.981]   - Field: ‘owner’
[10:32:41.981]   - Field: ‘envir’
[10:32:41.981]   - Field: ‘packages’
[10:32:41.981]   - Field: ‘gc’
[10:32:41.981]   - Field: ‘conditions’
[10:32:41.981]   - Field: ‘expr’
[10:32:41.981]   - Field: ‘uuid’
[10:32:41.981]   - Field: ‘seed’
[10:32:41.981]   - Field: ‘version’
[10:32:41.981]   - Field: ‘result’
[10:32:41.982]   - Field: ‘asynchronous’
[10:32:41.982]   - Field: ‘calls’
[10:32:41.982]   - Field: ‘globals’
[10:32:41.982]   - Field: ‘stdout’
[10:32:41.982]   - Field: ‘earlySignal’
[10:32:41.982]   - Field: ‘lazy’
[10:32:41.982]   - Field: ‘state’
[10:32:41.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:41.982] - Launch lazy future ...
[10:32:41.983] Packages needed by the future expression (n = 0): <none>
[10:32:41.983] Packages needed by future strategies (n = 0): <none>
[10:32:41.983] {
[10:32:41.983]     {
[10:32:41.983]         {
[10:32:41.983]             ...future.startTime <- base::Sys.time()
[10:32:41.983]             {
[10:32:41.983]                 {
[10:32:41.983]                   {
[10:32:41.983]                     base::local({
[10:32:41.983]                       has_future <- base::requireNamespace("future", 
[10:32:41.983]                         quietly = TRUE)
[10:32:41.983]                       if (has_future) {
[10:32:41.983]                         ns <- base::getNamespace("future")
[10:32:41.983]                         version <- ns[[".package"]][["version"]]
[10:32:41.983]                         if (is.null(version)) 
[10:32:41.983]                           version <- utils::packageVersion("future")
[10:32:41.983]                       }
[10:32:41.983]                       else {
[10:32:41.983]                         version <- NULL
[10:32:41.983]                       }
[10:32:41.983]                       if (!has_future || version < "1.8.0") {
[10:32:41.983]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:41.983]                           "", base::R.version$version.string), 
[10:32:41.983]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:41.983]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:41.983]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:41.983]                             "release", "version")], collapse = " "), 
[10:32:41.983]                           hostname = base::Sys.info()[["nodename"]])
[10:32:41.983]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:41.983]                           info)
[10:32:41.983]                         info <- base::paste(info, collapse = "; ")
[10:32:41.983]                         if (!has_future) {
[10:32:41.983]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:41.983]                             info)
[10:32:41.983]                         }
[10:32:41.983]                         else {
[10:32:41.983]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:41.983]                             info, version)
[10:32:41.983]                         }
[10:32:41.983]                         base::stop(msg)
[10:32:41.983]                       }
[10:32:41.983]                     })
[10:32:41.983]                   }
[10:32:41.983]                   ...future.strategy.old <- future::plan("list")
[10:32:41.983]                   options(future.plan = NULL)
[10:32:41.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:41.983]                 }
[10:32:41.983]                 ...future.workdir <- getwd()
[10:32:41.983]             }
[10:32:41.983]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:41.983]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:41.983]         }
[10:32:41.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:41.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:41.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:41.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:41.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:41.983]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:41.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:41.983]             base::names(...future.oldOptions))
[10:32:41.983]     }
[10:32:41.983]     if (FALSE) {
[10:32:41.983]     }
[10:32:41.983]     else {
[10:32:41.983]         if (TRUE) {
[10:32:41.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:41.983]                 open = "w")
[10:32:41.983]         }
[10:32:41.983]         else {
[10:32:41.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:41.983]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:41.983]         }
[10:32:41.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:41.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:41.983]             base::sink(type = "output", split = FALSE)
[10:32:41.983]             base::close(...future.stdout)
[10:32:41.983]         }, add = TRUE)
[10:32:41.983]     }
[10:32:41.983]     ...future.frame <- base::sys.nframe()
[10:32:41.983]     ...future.conditions <- base::list()
[10:32:41.983]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:41.983]     if (FALSE) {
[10:32:41.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:41.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:41.983]     }
[10:32:41.983]     ...future.result <- base::tryCatch({
[10:32:41.983]         base::withCallingHandlers({
[10:32:41.983]             ...future.value <- base::withVisible(base::local({
[10:32:41.983]                 a + 1
[10:32:41.983]             }))
[10:32:41.983]             future::FutureResult(value = ...future.value$value, 
[10:32:41.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.983]                   ...future.rng), globalenv = if (FALSE) 
[10:32:41.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:41.983]                     ...future.globalenv.names))
[10:32:41.983]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:41.983]         }, condition = base::local({
[10:32:41.983]             c <- base::c
[10:32:41.983]             inherits <- base::inherits
[10:32:41.983]             invokeRestart <- base::invokeRestart
[10:32:41.983]             length <- base::length
[10:32:41.983]             list <- base::list
[10:32:41.983]             seq.int <- base::seq.int
[10:32:41.983]             signalCondition <- base::signalCondition
[10:32:41.983]             sys.calls <- base::sys.calls
[10:32:41.983]             `[[` <- base::`[[`
[10:32:41.983]             `+` <- base::`+`
[10:32:41.983]             `<<-` <- base::`<<-`
[10:32:41.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:41.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:41.983]                   3L)]
[10:32:41.983]             }
[10:32:41.983]             function(cond) {
[10:32:41.983]                 is_error <- inherits(cond, "error")
[10:32:41.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:41.983]                   NULL)
[10:32:41.983]                 if (is_error) {
[10:32:41.983]                   sessionInformation <- function() {
[10:32:41.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:41.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:41.983]                       search = base::search(), system = base::Sys.info())
[10:32:41.983]                   }
[10:32:41.983]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:41.983]                     cond$call), session = sessionInformation(), 
[10:32:41.983]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:41.983]                   signalCondition(cond)
[10:32:41.983]                 }
[10:32:41.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:41.983]                 "immediateCondition"))) {
[10:32:41.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:41.983]                   ...future.conditions[[length(...future.conditions) + 
[10:32:41.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:41.983]                   if (TRUE && !signal) {
[10:32:41.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.983]                     {
[10:32:41.983]                       inherits <- base::inherits
[10:32:41.983]                       invokeRestart <- base::invokeRestart
[10:32:41.983]                       is.null <- base::is.null
[10:32:41.983]                       muffled <- FALSE
[10:32:41.983]                       if (inherits(cond, "message")) {
[10:32:41.983]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.983]                         if (muffled) 
[10:32:41.983]                           invokeRestart("muffleMessage")
[10:32:41.983]                       }
[10:32:41.983]                       else if (inherits(cond, "warning")) {
[10:32:41.983]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.983]                         if (muffled) 
[10:32:41.983]                           invokeRestart("muffleWarning")
[10:32:41.983]                       }
[10:32:41.983]                       else if (inherits(cond, "condition")) {
[10:32:41.983]                         if (!is.null(pattern)) {
[10:32:41.983]                           computeRestarts <- base::computeRestarts
[10:32:41.983]                           grepl <- base::grepl
[10:32:41.983]                           restarts <- computeRestarts(cond)
[10:32:41.983]                           for (restart in restarts) {
[10:32:41.983]                             name <- restart$name
[10:32:41.983]                             if (is.null(name)) 
[10:32:41.983]                               next
[10:32:41.983]                             if (!grepl(pattern, name)) 
[10:32:41.983]                               next
[10:32:41.983]                             invokeRestart(restart)
[10:32:41.983]                             muffled <- TRUE
[10:32:41.983]                             break
[10:32:41.983]                           }
[10:32:41.983]                         }
[10:32:41.983]                       }
[10:32:41.983]                       invisible(muffled)
[10:32:41.983]                     }
[10:32:41.983]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.983]                   }
[10:32:41.983]                 }
[10:32:41.983]                 else {
[10:32:41.983]                   if (TRUE) {
[10:32:41.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:41.983]                     {
[10:32:41.983]                       inherits <- base::inherits
[10:32:41.983]                       invokeRestart <- base::invokeRestart
[10:32:41.983]                       is.null <- base::is.null
[10:32:41.983]                       muffled <- FALSE
[10:32:41.983]                       if (inherits(cond, "message")) {
[10:32:41.983]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:41.983]                         if (muffled) 
[10:32:41.983]                           invokeRestart("muffleMessage")
[10:32:41.983]                       }
[10:32:41.983]                       else if (inherits(cond, "warning")) {
[10:32:41.983]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:41.983]                         if (muffled) 
[10:32:41.983]                           invokeRestart("muffleWarning")
[10:32:41.983]                       }
[10:32:41.983]                       else if (inherits(cond, "condition")) {
[10:32:41.983]                         if (!is.null(pattern)) {
[10:32:41.983]                           computeRestarts <- base::computeRestarts
[10:32:41.983]                           grepl <- base::grepl
[10:32:41.983]                           restarts <- computeRestarts(cond)
[10:32:41.983]                           for (restart in restarts) {
[10:32:41.983]                             name <- restart$name
[10:32:41.983]                             if (is.null(name)) 
[10:32:41.983]                               next
[10:32:41.983]                             if (!grepl(pattern, name)) 
[10:32:41.983]                               next
[10:32:41.983]                             invokeRestart(restart)
[10:32:41.983]                             muffled <- TRUE
[10:32:41.983]                             break
[10:32:41.983]                           }
[10:32:41.983]                         }
[10:32:41.983]                       }
[10:32:41.983]                       invisible(muffled)
[10:32:41.983]                     }
[10:32:41.983]                     muffleCondition(cond, pattern = "^muffle")
[10:32:41.983]                   }
[10:32:41.983]                 }
[10:32:41.983]             }
[10:32:41.983]         }))
[10:32:41.983]     }, error = function(ex) {
[10:32:41.983]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:41.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:41.983]                 ...future.rng), started = ...future.startTime, 
[10:32:41.983]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:41.983]             version = "1.8"), class = "FutureResult")
[10:32:41.983]     }, finally = {
[10:32:41.983]         if (!identical(...future.workdir, getwd())) 
[10:32:41.983]             setwd(...future.workdir)
[10:32:41.983]         {
[10:32:41.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:41.983]                 ...future.oldOptions$nwarnings <- NULL
[10:32:41.983]             }
[10:32:41.983]             base::options(...future.oldOptions)
[10:32:41.983]             if (.Platform$OS.type == "windows") {
[10:32:41.983]                 old_names <- names(...future.oldEnvVars)
[10:32:41.983]                 envs <- base::Sys.getenv()
[10:32:41.983]                 names <- names(envs)
[10:32:41.983]                 common <- intersect(names, old_names)
[10:32:41.983]                 added <- setdiff(names, old_names)
[10:32:41.983]                 removed <- setdiff(old_names, names)
[10:32:41.983]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:41.983]                   envs[common]]
[10:32:41.983]                 NAMES <- toupper(changed)
[10:32:41.983]                 args <- list()
[10:32:41.983]                 for (kk in seq_along(NAMES)) {
[10:32:41.983]                   name <- changed[[kk]]
[10:32:41.983]                   NAME <- NAMES[[kk]]
[10:32:41.983]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.983]                     next
[10:32:41.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.983]                 }
[10:32:41.983]                 NAMES <- toupper(added)
[10:32:41.983]                 for (kk in seq_along(NAMES)) {
[10:32:41.983]                   name <- added[[kk]]
[10:32:41.983]                   NAME <- NAMES[[kk]]
[10:32:41.983]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.983]                     next
[10:32:41.983]                   args[[name]] <- ""
[10:32:41.983]                 }
[10:32:41.983]                 NAMES <- toupper(removed)
[10:32:41.983]                 for (kk in seq_along(NAMES)) {
[10:32:41.983]                   name <- removed[[kk]]
[10:32:41.983]                   NAME <- NAMES[[kk]]
[10:32:41.983]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:41.983]                     next
[10:32:41.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:41.983]                 }
[10:32:41.983]                 if (length(args) > 0) 
[10:32:41.983]                   base::do.call(base::Sys.setenv, args = args)
[10:32:41.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:41.983]             }
[10:32:41.983]             else {
[10:32:41.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:41.983]             }
[10:32:41.983]             {
[10:32:41.983]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:41.983]                   0L) {
[10:32:41.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:41.983]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:41.983]                   base::options(opts)
[10:32:41.983]                 }
[10:32:41.983]                 {
[10:32:41.983]                   {
[10:32:41.983]                     NULL
[10:32:41.983]                     RNGkind("Mersenne-Twister")
[10:32:41.983]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:41.983]                       inherits = FALSE)
[10:32:41.983]                   }
[10:32:41.983]                   options(future.plan = NULL)
[10:32:41.983]                   if (is.na(NA_character_)) 
[10:32:41.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:41.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:41.983]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:41.983]                     .init = FALSE)
[10:32:41.983]                 }
[10:32:41.983]             }
[10:32:41.983]         }
[10:32:41.983]     })
[10:32:41.983]     if (TRUE) {
[10:32:41.983]         base::sink(type = "output", split = FALSE)
[10:32:41.983]         if (TRUE) {
[10:32:41.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:41.983]         }
[10:32:41.983]         else {
[10:32:41.983]             ...future.result["stdout"] <- base::list(NULL)
[10:32:41.983]         }
[10:32:41.983]         base::close(...future.stdout)
[10:32:41.983]         ...future.stdout <- NULL
[10:32:41.983]     }
[10:32:41.983]     ...future.result$conditions <- ...future.conditions
[10:32:41.983]     ...future.result$finished <- base::Sys.time()
[10:32:41.983]     ...future.result
[10:32:41.983] }
[10:32:41.985] assign_globals() ...
[10:32:41.985] List of 1
[10:32:41.985]  $ a: num 10
[10:32:41.985]  - attr(*, "where")=List of 1
[10:32:41.985]   ..$ a:<environment: R_EmptyEnv> 
[10:32:41.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:41.985]  - attr(*, "resolved")= logi FALSE
[10:32:41.985]  - attr(*, "total_size")= num 56
[10:32:41.985]  - attr(*, "already-done")= logi TRUE
[10:32:41.987] - copied ‘a’ to environment
[10:32:41.987] assign_globals() ... done
[10:32:41.988] plan(): Setting new future strategy stack:
[10:32:41.988] List of future strategies:
[10:32:41.988] 1. sequential:
[10:32:41.988]    - args: function (..., envir = parent.frame())
[10:32:41.988]    - tweaked: FALSE
[10:32:41.988]    - call: NULL
[10:32:41.988] plan(): nbrOfWorkers() = 1
[10:32:41.989] plan(): Setting new future strategy stack:
[10:32:41.989] List of future strategies:
[10:32:41.989] 1. sequential:
[10:32:41.989]    - args: function (..., envir = parent.frame())
[10:32:41.989]    - tweaked: FALSE
[10:32:41.989]    - call: plan(strategy)
[10:32:41.989] plan(): nbrOfWorkers() = 1
[10:32:41.989] SequentialFuture started (and completed)
[10:32:41.989] - Launch lazy future ... done
[10:32:41.990] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[10:32:41.995] plan(): Setting new future strategy stack:
[10:32:41.995] List of future strategies:
[10:32:41.995] 1. multicore:
[10:32:41.995]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:41.995]    - tweaked: FALSE
[10:32:41.995]    - call: plan(strategy)
[10:32:41.999] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[10:32:42.000] getGlobalsAndPackages() ...
[10:32:42.001] Searching for globals...
[10:32:42.002] - globals found: [2] ‘{’, ‘<-’
[10:32:42.002] Searching for globals ... DONE
[10:32:42.003] Resolving globals: FALSE
[10:32:42.003] 
[10:32:42.003] 
[10:32:42.003] getGlobalsAndPackages() ... DONE
[10:32:42.003] run() for ‘Future’ ...
[10:32:42.003] - state: ‘created’
[10:32:42.004] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.007] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.007]   - Field: ‘label’
[10:32:42.007]   - Field: ‘local’
[10:32:42.008]   - Field: ‘owner’
[10:32:42.008]   - Field: ‘envir’
[10:32:42.008]   - Field: ‘workers’
[10:32:42.008]   - Field: ‘packages’
[10:32:42.008]   - Field: ‘gc’
[10:32:42.008]   - Field: ‘job’
[10:32:42.008]   - Field: ‘conditions’
[10:32:42.008]   - Field: ‘expr’
[10:32:42.008]   - Field: ‘uuid’
[10:32:42.008]   - Field: ‘seed’
[10:32:42.009]   - Field: ‘version’
[10:32:42.009]   - Field: ‘result’
[10:32:42.009]   - Field: ‘asynchronous’
[10:32:42.009]   - Field: ‘calls’
[10:32:42.009]   - Field: ‘globals’
[10:32:42.009]   - Field: ‘stdout’
[10:32:42.009]   - Field: ‘earlySignal’
[10:32:42.009]   - Field: ‘lazy’
[10:32:42.009]   - Field: ‘state’
[10:32:42.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.010] - Launch lazy future ...
[10:32:42.011] Packages needed by the future expression (n = 0): <none>
[10:32:42.011] Packages needed by future strategies (n = 0): <none>
[10:32:42.011] {
[10:32:42.011]     {
[10:32:42.011]         {
[10:32:42.011]             ...future.startTime <- base::Sys.time()
[10:32:42.011]             {
[10:32:42.011]                 {
[10:32:42.011]                   {
[10:32:42.011]                     {
[10:32:42.011]                       base::local({
[10:32:42.011]                         has_future <- base::requireNamespace("future", 
[10:32:42.011]                           quietly = TRUE)
[10:32:42.011]                         if (has_future) {
[10:32:42.011]                           ns <- base::getNamespace("future")
[10:32:42.011]                           version <- ns[[".package"]][["version"]]
[10:32:42.011]                           if (is.null(version)) 
[10:32:42.011]                             version <- utils::packageVersion("future")
[10:32:42.011]                         }
[10:32:42.011]                         else {
[10:32:42.011]                           version <- NULL
[10:32:42.011]                         }
[10:32:42.011]                         if (!has_future || version < "1.8.0") {
[10:32:42.011]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.011]                             "", base::R.version$version.string), 
[10:32:42.011]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.011]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.011]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.011]                               "release", "version")], collapse = " "), 
[10:32:42.011]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.011]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.011]                             info)
[10:32:42.011]                           info <- base::paste(info, collapse = "; ")
[10:32:42.011]                           if (!has_future) {
[10:32:42.011]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.011]                               info)
[10:32:42.011]                           }
[10:32:42.011]                           else {
[10:32:42.011]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.011]                               info, version)
[10:32:42.011]                           }
[10:32:42.011]                           base::stop(msg)
[10:32:42.011]                         }
[10:32:42.011]                       })
[10:32:42.011]                     }
[10:32:42.011]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.011]                     base::options(mc.cores = 1L)
[10:32:42.011]                   }
[10:32:42.011]                   ...future.strategy.old <- future::plan("list")
[10:32:42.011]                   options(future.plan = NULL)
[10:32:42.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.011]                 }
[10:32:42.011]                 ...future.workdir <- getwd()
[10:32:42.011]             }
[10:32:42.011]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.011]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.011]         }
[10:32:42.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.011]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.011]             base::names(...future.oldOptions))
[10:32:42.011]     }
[10:32:42.011]     if (FALSE) {
[10:32:42.011]     }
[10:32:42.011]     else {
[10:32:42.011]         if (TRUE) {
[10:32:42.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.011]                 open = "w")
[10:32:42.011]         }
[10:32:42.011]         else {
[10:32:42.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.011]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.011]         }
[10:32:42.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.011]             base::sink(type = "output", split = FALSE)
[10:32:42.011]             base::close(...future.stdout)
[10:32:42.011]         }, add = TRUE)
[10:32:42.011]     }
[10:32:42.011]     ...future.frame <- base::sys.nframe()
[10:32:42.011]     ...future.conditions <- base::list()
[10:32:42.011]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.011]     if (FALSE) {
[10:32:42.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.011]     }
[10:32:42.011]     ...future.result <- base::tryCatch({
[10:32:42.011]         base::withCallingHandlers({
[10:32:42.011]             ...future.value <- base::withVisible(base::local({
[10:32:42.011]                 withCallingHandlers({
[10:32:42.011]                   {
[10:32:42.011]                     x <- 1
[10:32:42.011]                   }
[10:32:42.011]                 }, immediateCondition = function(cond) {
[10:32:42.011]                   save_rds <- function (object, pathname, ...) 
[10:32:42.011]                   {
[10:32:42.011]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.011]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.011]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.011]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.011]                         fi_tmp[["mtime"]])
[10:32:42.011]                     }
[10:32:42.011]                     tryCatch({
[10:32:42.011]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.011]                     }, error = function(ex) {
[10:32:42.011]                       msg <- conditionMessage(ex)
[10:32:42.011]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.011]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.011]                         fi_tmp[["mtime"]], msg)
[10:32:42.011]                       ex$message <- msg
[10:32:42.011]                       stop(ex)
[10:32:42.011]                     })
[10:32:42.011]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.011]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.011]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.011]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.011]                       fi <- file.info(pathname)
[10:32:42.011]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.011]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.011]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.011]                         fi[["size"]], fi[["mtime"]])
[10:32:42.011]                       stop(msg)
[10:32:42.011]                     }
[10:32:42.011]                     invisible(pathname)
[10:32:42.011]                   }
[10:32:42.011]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.011]                     rootPath = tempdir()) 
[10:32:42.011]                   {
[10:32:42.011]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.011]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.011]                       tmpdir = path, fileext = ".rds")
[10:32:42.011]                     save_rds(obj, file)
[10:32:42.011]                   }
[10:32:42.011]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.011]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.011]                   {
[10:32:42.011]                     inherits <- base::inherits
[10:32:42.011]                     invokeRestart <- base::invokeRestart
[10:32:42.011]                     is.null <- base::is.null
[10:32:42.011]                     muffled <- FALSE
[10:32:42.011]                     if (inherits(cond, "message")) {
[10:32:42.011]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.011]                       if (muffled) 
[10:32:42.011]                         invokeRestart("muffleMessage")
[10:32:42.011]                     }
[10:32:42.011]                     else if (inherits(cond, "warning")) {
[10:32:42.011]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.011]                       if (muffled) 
[10:32:42.011]                         invokeRestart("muffleWarning")
[10:32:42.011]                     }
[10:32:42.011]                     else if (inherits(cond, "condition")) {
[10:32:42.011]                       if (!is.null(pattern)) {
[10:32:42.011]                         computeRestarts <- base::computeRestarts
[10:32:42.011]                         grepl <- base::grepl
[10:32:42.011]                         restarts <- computeRestarts(cond)
[10:32:42.011]                         for (restart in restarts) {
[10:32:42.011]                           name <- restart$name
[10:32:42.011]                           if (is.null(name)) 
[10:32:42.011]                             next
[10:32:42.011]                           if (!grepl(pattern, name)) 
[10:32:42.011]                             next
[10:32:42.011]                           invokeRestart(restart)
[10:32:42.011]                           muffled <- TRUE
[10:32:42.011]                           break
[10:32:42.011]                         }
[10:32:42.011]                       }
[10:32:42.011]                     }
[10:32:42.011]                     invisible(muffled)
[10:32:42.011]                   }
[10:32:42.011]                   muffleCondition(cond)
[10:32:42.011]                 })
[10:32:42.011]             }))
[10:32:42.011]             future::FutureResult(value = ...future.value$value, 
[10:32:42.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.011]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.011]                     ...future.globalenv.names))
[10:32:42.011]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.011]         }, condition = base::local({
[10:32:42.011]             c <- base::c
[10:32:42.011]             inherits <- base::inherits
[10:32:42.011]             invokeRestart <- base::invokeRestart
[10:32:42.011]             length <- base::length
[10:32:42.011]             list <- base::list
[10:32:42.011]             seq.int <- base::seq.int
[10:32:42.011]             signalCondition <- base::signalCondition
[10:32:42.011]             sys.calls <- base::sys.calls
[10:32:42.011]             `[[` <- base::`[[`
[10:32:42.011]             `+` <- base::`+`
[10:32:42.011]             `<<-` <- base::`<<-`
[10:32:42.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.011]                   3L)]
[10:32:42.011]             }
[10:32:42.011]             function(cond) {
[10:32:42.011]                 is_error <- inherits(cond, "error")
[10:32:42.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.011]                   NULL)
[10:32:42.011]                 if (is_error) {
[10:32:42.011]                   sessionInformation <- function() {
[10:32:42.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.011]                       search = base::search(), system = base::Sys.info())
[10:32:42.011]                   }
[10:32:42.011]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.011]                     cond$call), session = sessionInformation(), 
[10:32:42.011]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.011]                   signalCondition(cond)
[10:32:42.011]                 }
[10:32:42.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.011]                 "immediateCondition"))) {
[10:32:42.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.011]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.011]                   if (TRUE && !signal) {
[10:32:42.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.011]                     {
[10:32:42.011]                       inherits <- base::inherits
[10:32:42.011]                       invokeRestart <- base::invokeRestart
[10:32:42.011]                       is.null <- base::is.null
[10:32:42.011]                       muffled <- FALSE
[10:32:42.011]                       if (inherits(cond, "message")) {
[10:32:42.011]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.011]                         if (muffled) 
[10:32:42.011]                           invokeRestart("muffleMessage")
[10:32:42.011]                       }
[10:32:42.011]                       else if (inherits(cond, "warning")) {
[10:32:42.011]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.011]                         if (muffled) 
[10:32:42.011]                           invokeRestart("muffleWarning")
[10:32:42.011]                       }
[10:32:42.011]                       else if (inherits(cond, "condition")) {
[10:32:42.011]                         if (!is.null(pattern)) {
[10:32:42.011]                           computeRestarts <- base::computeRestarts
[10:32:42.011]                           grepl <- base::grepl
[10:32:42.011]                           restarts <- computeRestarts(cond)
[10:32:42.011]                           for (restart in restarts) {
[10:32:42.011]                             name <- restart$name
[10:32:42.011]                             if (is.null(name)) 
[10:32:42.011]                               next
[10:32:42.011]                             if (!grepl(pattern, name)) 
[10:32:42.011]                               next
[10:32:42.011]                             invokeRestart(restart)
[10:32:42.011]                             muffled <- TRUE
[10:32:42.011]                             break
[10:32:42.011]                           }
[10:32:42.011]                         }
[10:32:42.011]                       }
[10:32:42.011]                       invisible(muffled)
[10:32:42.011]                     }
[10:32:42.011]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.011]                   }
[10:32:42.011]                 }
[10:32:42.011]                 else {
[10:32:42.011]                   if (TRUE) {
[10:32:42.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.011]                     {
[10:32:42.011]                       inherits <- base::inherits
[10:32:42.011]                       invokeRestart <- base::invokeRestart
[10:32:42.011]                       is.null <- base::is.null
[10:32:42.011]                       muffled <- FALSE
[10:32:42.011]                       if (inherits(cond, "message")) {
[10:32:42.011]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.011]                         if (muffled) 
[10:32:42.011]                           invokeRestart("muffleMessage")
[10:32:42.011]                       }
[10:32:42.011]                       else if (inherits(cond, "warning")) {
[10:32:42.011]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.011]                         if (muffled) 
[10:32:42.011]                           invokeRestart("muffleWarning")
[10:32:42.011]                       }
[10:32:42.011]                       else if (inherits(cond, "condition")) {
[10:32:42.011]                         if (!is.null(pattern)) {
[10:32:42.011]                           computeRestarts <- base::computeRestarts
[10:32:42.011]                           grepl <- base::grepl
[10:32:42.011]                           restarts <- computeRestarts(cond)
[10:32:42.011]                           for (restart in restarts) {
[10:32:42.011]                             name <- restart$name
[10:32:42.011]                             if (is.null(name)) 
[10:32:42.011]                               next
[10:32:42.011]                             if (!grepl(pattern, name)) 
[10:32:42.011]                               next
[10:32:42.011]                             invokeRestart(restart)
[10:32:42.011]                             muffled <- TRUE
[10:32:42.011]                             break
[10:32:42.011]                           }
[10:32:42.011]                         }
[10:32:42.011]                       }
[10:32:42.011]                       invisible(muffled)
[10:32:42.011]                     }
[10:32:42.011]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.011]                   }
[10:32:42.011]                 }
[10:32:42.011]             }
[10:32:42.011]         }))
[10:32:42.011]     }, error = function(ex) {
[10:32:42.011]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.011]                 ...future.rng), started = ...future.startTime, 
[10:32:42.011]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.011]             version = "1.8"), class = "FutureResult")
[10:32:42.011]     }, finally = {
[10:32:42.011]         if (!identical(...future.workdir, getwd())) 
[10:32:42.011]             setwd(...future.workdir)
[10:32:42.011]         {
[10:32:42.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.011]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.011]             }
[10:32:42.011]             base::options(...future.oldOptions)
[10:32:42.011]             if (.Platform$OS.type == "windows") {
[10:32:42.011]                 old_names <- names(...future.oldEnvVars)
[10:32:42.011]                 envs <- base::Sys.getenv()
[10:32:42.011]                 names <- names(envs)
[10:32:42.011]                 common <- intersect(names, old_names)
[10:32:42.011]                 added <- setdiff(names, old_names)
[10:32:42.011]                 removed <- setdiff(old_names, names)
[10:32:42.011]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.011]                   envs[common]]
[10:32:42.011]                 NAMES <- toupper(changed)
[10:32:42.011]                 args <- list()
[10:32:42.011]                 for (kk in seq_along(NAMES)) {
[10:32:42.011]                   name <- changed[[kk]]
[10:32:42.011]                   NAME <- NAMES[[kk]]
[10:32:42.011]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.011]                     next
[10:32:42.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.011]                 }
[10:32:42.011]                 NAMES <- toupper(added)
[10:32:42.011]                 for (kk in seq_along(NAMES)) {
[10:32:42.011]                   name <- added[[kk]]
[10:32:42.011]                   NAME <- NAMES[[kk]]
[10:32:42.011]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.011]                     next
[10:32:42.011]                   args[[name]] <- ""
[10:32:42.011]                 }
[10:32:42.011]                 NAMES <- toupper(removed)
[10:32:42.011]                 for (kk in seq_along(NAMES)) {
[10:32:42.011]                   name <- removed[[kk]]
[10:32:42.011]                   NAME <- NAMES[[kk]]
[10:32:42.011]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.011]                     next
[10:32:42.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.011]                 }
[10:32:42.011]                 if (length(args) > 0) 
[10:32:42.011]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.011]             }
[10:32:42.011]             else {
[10:32:42.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.011]             }
[10:32:42.011]             {
[10:32:42.011]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.011]                   0L) {
[10:32:42.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.011]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.011]                   base::options(opts)
[10:32:42.011]                 }
[10:32:42.011]                 {
[10:32:42.011]                   {
[10:32:42.011]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.011]                     NULL
[10:32:42.011]                   }
[10:32:42.011]                   options(future.plan = NULL)
[10:32:42.011]                   if (is.na(NA_character_)) 
[10:32:42.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.011]                     .init = FALSE)
[10:32:42.011]                 }
[10:32:42.011]             }
[10:32:42.011]         }
[10:32:42.011]     })
[10:32:42.011]     if (TRUE) {
[10:32:42.011]         base::sink(type = "output", split = FALSE)
[10:32:42.011]         if (TRUE) {
[10:32:42.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.011]         }
[10:32:42.011]         else {
[10:32:42.011]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.011]         }
[10:32:42.011]         base::close(...future.stdout)
[10:32:42.011]         ...future.stdout <- NULL
[10:32:42.011]     }
[10:32:42.011]     ...future.result$conditions <- ...future.conditions
[10:32:42.011]     ...future.result$finished <- base::Sys.time()
[10:32:42.011]     ...future.result
[10:32:42.011] }
[10:32:42.013] requestCore(): workers = 2
[10:32:42.016] MulticoreFuture started
[10:32:42.017] - Launch lazy future ... done
[10:32:42.017] run() for ‘MulticoreFuture’ ... done
[10:32:42.017] plan(): Setting new future strategy stack:
[10:32:42.017] List of future strategies:
[10:32:42.017] 1. sequential:
[10:32:42.017]    - args: function (..., envir = parent.frame())
[10:32:42.017]    - tweaked: FALSE
[10:32:42.017]    - call: NULL
[10:32:42.018] plan(): nbrOfWorkers() = 1
[10:32:42.018] result() for MulticoreFuture ...
[10:32:42.020] plan(): Setting new future strategy stack:
[10:32:42.020] List of future strategies:
[10:32:42.020] 1. multicore:
[10:32:42.020]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.020]    - tweaked: FALSE
[10:32:42.020]    - call: plan(strategy)
[10:32:42.025] plan(): nbrOfWorkers() = 2
[10:32:42.030] result() for MulticoreFuture ...
[10:32:42.030] result() for MulticoreFuture ... done
[10:32:42.030] result() for MulticoreFuture ... done
[10:32:42.030] result() for MulticoreFuture ...
[10:32:42.030] result() for MulticoreFuture ... done
** Future evaluation with globals
[10:32:42.031] getGlobalsAndPackages() ...
[10:32:42.031] Searching for globals...
[10:32:42.032] - globals found: [3] ‘{’, ‘<-’, ‘a’
[10:32:42.032] Searching for globals ... DONE
[10:32:42.032] Resolving globals: FALSE
[10:32:42.033] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:42.033] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:32:42.033] - globals: [1] ‘a’
[10:32:42.033] 
[10:32:42.034] getGlobalsAndPackages() ... DONE
[10:32:42.034] run() for ‘Future’ ...
[10:32:42.034] - state: ‘created’
[10:32:42.034] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.038] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.038] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.039]   - Field: ‘label’
[10:32:42.039]   - Field: ‘local’
[10:32:42.039]   - Field: ‘owner’
[10:32:42.039]   - Field: ‘envir’
[10:32:42.039]   - Field: ‘workers’
[10:32:42.039]   - Field: ‘packages’
[10:32:42.039]   - Field: ‘gc’
[10:32:42.039]   - Field: ‘job’
[10:32:42.039]   - Field: ‘conditions’
[10:32:42.040]   - Field: ‘expr’
[10:32:42.040]   - Field: ‘uuid’
[10:32:42.040]   - Field: ‘seed’
[10:32:42.040]   - Field: ‘version’
[10:32:42.040]   - Field: ‘result’
[10:32:42.040]   - Field: ‘asynchronous’
[10:32:42.040]   - Field: ‘calls’
[10:32:42.040]   - Field: ‘globals’
[10:32:42.040]   - Field: ‘stdout’
[10:32:42.041]   - Field: ‘earlySignal’
[10:32:42.041]   - Field: ‘lazy’
[10:32:42.041]   - Field: ‘state’
[10:32:42.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.041] - Launch lazy future ...
[10:32:42.041] Packages needed by the future expression (n = 0): <none>
[10:32:42.042] Packages needed by future strategies (n = 0): <none>
[10:32:42.042] {
[10:32:42.042]     {
[10:32:42.042]         {
[10:32:42.042]             ...future.startTime <- base::Sys.time()
[10:32:42.042]             {
[10:32:42.042]                 {
[10:32:42.042]                   {
[10:32:42.042]                     {
[10:32:42.042]                       base::local({
[10:32:42.042]                         has_future <- base::requireNamespace("future", 
[10:32:42.042]                           quietly = TRUE)
[10:32:42.042]                         if (has_future) {
[10:32:42.042]                           ns <- base::getNamespace("future")
[10:32:42.042]                           version <- ns[[".package"]][["version"]]
[10:32:42.042]                           if (is.null(version)) 
[10:32:42.042]                             version <- utils::packageVersion("future")
[10:32:42.042]                         }
[10:32:42.042]                         else {
[10:32:42.042]                           version <- NULL
[10:32:42.042]                         }
[10:32:42.042]                         if (!has_future || version < "1.8.0") {
[10:32:42.042]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.042]                             "", base::R.version$version.string), 
[10:32:42.042]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.042]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.042]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.042]                               "release", "version")], collapse = " "), 
[10:32:42.042]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.042]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.042]                             info)
[10:32:42.042]                           info <- base::paste(info, collapse = "; ")
[10:32:42.042]                           if (!has_future) {
[10:32:42.042]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.042]                               info)
[10:32:42.042]                           }
[10:32:42.042]                           else {
[10:32:42.042]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.042]                               info, version)
[10:32:42.042]                           }
[10:32:42.042]                           base::stop(msg)
[10:32:42.042]                         }
[10:32:42.042]                       })
[10:32:42.042]                     }
[10:32:42.042]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.042]                     base::options(mc.cores = 1L)
[10:32:42.042]                   }
[10:32:42.042]                   ...future.strategy.old <- future::plan("list")
[10:32:42.042]                   options(future.plan = NULL)
[10:32:42.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.042]                 }
[10:32:42.042]                 ...future.workdir <- getwd()
[10:32:42.042]             }
[10:32:42.042]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.042]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.042]         }
[10:32:42.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.042]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.042]             base::names(...future.oldOptions))
[10:32:42.042]     }
[10:32:42.042]     if (FALSE) {
[10:32:42.042]     }
[10:32:42.042]     else {
[10:32:42.042]         if (TRUE) {
[10:32:42.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.042]                 open = "w")
[10:32:42.042]         }
[10:32:42.042]         else {
[10:32:42.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.042]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.042]         }
[10:32:42.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.042]             base::sink(type = "output", split = FALSE)
[10:32:42.042]             base::close(...future.stdout)
[10:32:42.042]         }, add = TRUE)
[10:32:42.042]     }
[10:32:42.042]     ...future.frame <- base::sys.nframe()
[10:32:42.042]     ...future.conditions <- base::list()
[10:32:42.042]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.042]     if (FALSE) {
[10:32:42.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.042]     }
[10:32:42.042]     ...future.result <- base::tryCatch({
[10:32:42.042]         base::withCallingHandlers({
[10:32:42.042]             ...future.value <- base::withVisible(base::local({
[10:32:42.042]                 withCallingHandlers({
[10:32:42.042]                   {
[10:32:42.042]                     x <- a
[10:32:42.042]                   }
[10:32:42.042]                 }, immediateCondition = function(cond) {
[10:32:42.042]                   save_rds <- function (object, pathname, ...) 
[10:32:42.042]                   {
[10:32:42.042]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.042]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.042]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.042]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.042]                         fi_tmp[["mtime"]])
[10:32:42.042]                     }
[10:32:42.042]                     tryCatch({
[10:32:42.042]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.042]                     }, error = function(ex) {
[10:32:42.042]                       msg <- conditionMessage(ex)
[10:32:42.042]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.042]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.042]                         fi_tmp[["mtime"]], msg)
[10:32:42.042]                       ex$message <- msg
[10:32:42.042]                       stop(ex)
[10:32:42.042]                     })
[10:32:42.042]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.042]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.042]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.042]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.042]                       fi <- file.info(pathname)
[10:32:42.042]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.042]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.042]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.042]                         fi[["size"]], fi[["mtime"]])
[10:32:42.042]                       stop(msg)
[10:32:42.042]                     }
[10:32:42.042]                     invisible(pathname)
[10:32:42.042]                   }
[10:32:42.042]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.042]                     rootPath = tempdir()) 
[10:32:42.042]                   {
[10:32:42.042]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.042]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.042]                       tmpdir = path, fileext = ".rds")
[10:32:42.042]                     save_rds(obj, file)
[10:32:42.042]                   }
[10:32:42.042]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.042]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.042]                   {
[10:32:42.042]                     inherits <- base::inherits
[10:32:42.042]                     invokeRestart <- base::invokeRestart
[10:32:42.042]                     is.null <- base::is.null
[10:32:42.042]                     muffled <- FALSE
[10:32:42.042]                     if (inherits(cond, "message")) {
[10:32:42.042]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.042]                       if (muffled) 
[10:32:42.042]                         invokeRestart("muffleMessage")
[10:32:42.042]                     }
[10:32:42.042]                     else if (inherits(cond, "warning")) {
[10:32:42.042]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.042]                       if (muffled) 
[10:32:42.042]                         invokeRestart("muffleWarning")
[10:32:42.042]                     }
[10:32:42.042]                     else if (inherits(cond, "condition")) {
[10:32:42.042]                       if (!is.null(pattern)) {
[10:32:42.042]                         computeRestarts <- base::computeRestarts
[10:32:42.042]                         grepl <- base::grepl
[10:32:42.042]                         restarts <- computeRestarts(cond)
[10:32:42.042]                         for (restart in restarts) {
[10:32:42.042]                           name <- restart$name
[10:32:42.042]                           if (is.null(name)) 
[10:32:42.042]                             next
[10:32:42.042]                           if (!grepl(pattern, name)) 
[10:32:42.042]                             next
[10:32:42.042]                           invokeRestart(restart)
[10:32:42.042]                           muffled <- TRUE
[10:32:42.042]                           break
[10:32:42.042]                         }
[10:32:42.042]                       }
[10:32:42.042]                     }
[10:32:42.042]                     invisible(muffled)
[10:32:42.042]                   }
[10:32:42.042]                   muffleCondition(cond)
[10:32:42.042]                 })
[10:32:42.042]             }))
[10:32:42.042]             future::FutureResult(value = ...future.value$value, 
[10:32:42.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.042]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.042]                     ...future.globalenv.names))
[10:32:42.042]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.042]         }, condition = base::local({
[10:32:42.042]             c <- base::c
[10:32:42.042]             inherits <- base::inherits
[10:32:42.042]             invokeRestart <- base::invokeRestart
[10:32:42.042]             length <- base::length
[10:32:42.042]             list <- base::list
[10:32:42.042]             seq.int <- base::seq.int
[10:32:42.042]             signalCondition <- base::signalCondition
[10:32:42.042]             sys.calls <- base::sys.calls
[10:32:42.042]             `[[` <- base::`[[`
[10:32:42.042]             `+` <- base::`+`
[10:32:42.042]             `<<-` <- base::`<<-`
[10:32:42.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.042]                   3L)]
[10:32:42.042]             }
[10:32:42.042]             function(cond) {
[10:32:42.042]                 is_error <- inherits(cond, "error")
[10:32:42.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.042]                   NULL)
[10:32:42.042]                 if (is_error) {
[10:32:42.042]                   sessionInformation <- function() {
[10:32:42.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.042]                       search = base::search(), system = base::Sys.info())
[10:32:42.042]                   }
[10:32:42.042]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.042]                     cond$call), session = sessionInformation(), 
[10:32:42.042]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.042]                   signalCondition(cond)
[10:32:42.042]                 }
[10:32:42.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.042]                 "immediateCondition"))) {
[10:32:42.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.042]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.042]                   if (TRUE && !signal) {
[10:32:42.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.042]                     {
[10:32:42.042]                       inherits <- base::inherits
[10:32:42.042]                       invokeRestart <- base::invokeRestart
[10:32:42.042]                       is.null <- base::is.null
[10:32:42.042]                       muffled <- FALSE
[10:32:42.042]                       if (inherits(cond, "message")) {
[10:32:42.042]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.042]                         if (muffled) 
[10:32:42.042]                           invokeRestart("muffleMessage")
[10:32:42.042]                       }
[10:32:42.042]                       else if (inherits(cond, "warning")) {
[10:32:42.042]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.042]                         if (muffled) 
[10:32:42.042]                           invokeRestart("muffleWarning")
[10:32:42.042]                       }
[10:32:42.042]                       else if (inherits(cond, "condition")) {
[10:32:42.042]                         if (!is.null(pattern)) {
[10:32:42.042]                           computeRestarts <- base::computeRestarts
[10:32:42.042]                           grepl <- base::grepl
[10:32:42.042]                           restarts <- computeRestarts(cond)
[10:32:42.042]                           for (restart in restarts) {
[10:32:42.042]                             name <- restart$name
[10:32:42.042]                             if (is.null(name)) 
[10:32:42.042]                               next
[10:32:42.042]                             if (!grepl(pattern, name)) 
[10:32:42.042]                               next
[10:32:42.042]                             invokeRestart(restart)
[10:32:42.042]                             muffled <- TRUE
[10:32:42.042]                             break
[10:32:42.042]                           }
[10:32:42.042]                         }
[10:32:42.042]                       }
[10:32:42.042]                       invisible(muffled)
[10:32:42.042]                     }
[10:32:42.042]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.042]                   }
[10:32:42.042]                 }
[10:32:42.042]                 else {
[10:32:42.042]                   if (TRUE) {
[10:32:42.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.042]                     {
[10:32:42.042]                       inherits <- base::inherits
[10:32:42.042]                       invokeRestart <- base::invokeRestart
[10:32:42.042]                       is.null <- base::is.null
[10:32:42.042]                       muffled <- FALSE
[10:32:42.042]                       if (inherits(cond, "message")) {
[10:32:42.042]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.042]                         if (muffled) 
[10:32:42.042]                           invokeRestart("muffleMessage")
[10:32:42.042]                       }
[10:32:42.042]                       else if (inherits(cond, "warning")) {
[10:32:42.042]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.042]                         if (muffled) 
[10:32:42.042]                           invokeRestart("muffleWarning")
[10:32:42.042]                       }
[10:32:42.042]                       else if (inherits(cond, "condition")) {
[10:32:42.042]                         if (!is.null(pattern)) {
[10:32:42.042]                           computeRestarts <- base::computeRestarts
[10:32:42.042]                           grepl <- base::grepl
[10:32:42.042]                           restarts <- computeRestarts(cond)
[10:32:42.042]                           for (restart in restarts) {
[10:32:42.042]                             name <- restart$name
[10:32:42.042]                             if (is.null(name)) 
[10:32:42.042]                               next
[10:32:42.042]                             if (!grepl(pattern, name)) 
[10:32:42.042]                               next
[10:32:42.042]                             invokeRestart(restart)
[10:32:42.042]                             muffled <- TRUE
[10:32:42.042]                             break
[10:32:42.042]                           }
[10:32:42.042]                         }
[10:32:42.042]                       }
[10:32:42.042]                       invisible(muffled)
[10:32:42.042]                     }
[10:32:42.042]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.042]                   }
[10:32:42.042]                 }
[10:32:42.042]             }
[10:32:42.042]         }))
[10:32:42.042]     }, error = function(ex) {
[10:32:42.042]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.042]                 ...future.rng), started = ...future.startTime, 
[10:32:42.042]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.042]             version = "1.8"), class = "FutureResult")
[10:32:42.042]     }, finally = {
[10:32:42.042]         if (!identical(...future.workdir, getwd())) 
[10:32:42.042]             setwd(...future.workdir)
[10:32:42.042]         {
[10:32:42.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.042]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.042]             }
[10:32:42.042]             base::options(...future.oldOptions)
[10:32:42.042]             if (.Platform$OS.type == "windows") {
[10:32:42.042]                 old_names <- names(...future.oldEnvVars)
[10:32:42.042]                 envs <- base::Sys.getenv()
[10:32:42.042]                 names <- names(envs)
[10:32:42.042]                 common <- intersect(names, old_names)
[10:32:42.042]                 added <- setdiff(names, old_names)
[10:32:42.042]                 removed <- setdiff(old_names, names)
[10:32:42.042]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.042]                   envs[common]]
[10:32:42.042]                 NAMES <- toupper(changed)
[10:32:42.042]                 args <- list()
[10:32:42.042]                 for (kk in seq_along(NAMES)) {
[10:32:42.042]                   name <- changed[[kk]]
[10:32:42.042]                   NAME <- NAMES[[kk]]
[10:32:42.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.042]                     next
[10:32:42.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.042]                 }
[10:32:42.042]                 NAMES <- toupper(added)
[10:32:42.042]                 for (kk in seq_along(NAMES)) {
[10:32:42.042]                   name <- added[[kk]]
[10:32:42.042]                   NAME <- NAMES[[kk]]
[10:32:42.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.042]                     next
[10:32:42.042]                   args[[name]] <- ""
[10:32:42.042]                 }
[10:32:42.042]                 NAMES <- toupper(removed)
[10:32:42.042]                 for (kk in seq_along(NAMES)) {
[10:32:42.042]                   name <- removed[[kk]]
[10:32:42.042]                   NAME <- NAMES[[kk]]
[10:32:42.042]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.042]                     next
[10:32:42.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.042]                 }
[10:32:42.042]                 if (length(args) > 0) 
[10:32:42.042]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.042]             }
[10:32:42.042]             else {
[10:32:42.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.042]             }
[10:32:42.042]             {
[10:32:42.042]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.042]                   0L) {
[10:32:42.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.042]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.042]                   base::options(opts)
[10:32:42.042]                 }
[10:32:42.042]                 {
[10:32:42.042]                   {
[10:32:42.042]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.042]                     NULL
[10:32:42.042]                   }
[10:32:42.042]                   options(future.plan = NULL)
[10:32:42.042]                   if (is.na(NA_character_)) 
[10:32:42.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.042]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.042]                     .init = FALSE)
[10:32:42.042]                 }
[10:32:42.042]             }
[10:32:42.042]         }
[10:32:42.042]     })
[10:32:42.042]     if (TRUE) {
[10:32:42.042]         base::sink(type = "output", split = FALSE)
[10:32:42.042]         if (TRUE) {
[10:32:42.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.042]         }
[10:32:42.042]         else {
[10:32:42.042]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.042]         }
[10:32:42.042]         base::close(...future.stdout)
[10:32:42.042]         ...future.stdout <- NULL
[10:32:42.042]     }
[10:32:42.042]     ...future.result$conditions <- ...future.conditions
[10:32:42.042]     ...future.result$finished <- base::Sys.time()
[10:32:42.042]     ...future.result
[10:32:42.042] }
[10:32:42.045] assign_globals() ...
[10:32:42.045] List of 1
[10:32:42.045]  $ a: num 2
[10:32:42.045]  - attr(*, "where")=List of 1
[10:32:42.045]   ..$ a:<environment: R_EmptyEnv> 
[10:32:42.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:42.045]  - attr(*, "resolved")= logi FALSE
[10:32:42.045]  - attr(*, "total_size")= num 56
[10:32:42.045]  - attr(*, "already-done")= logi TRUE
[10:32:42.048] - copied ‘a’ to environment
[10:32:42.048] assign_globals() ... done
[10:32:42.050] requestCore(): workers = 2
[10:32:42.053] MulticoreFuture started
[10:32:42.053] - Launch lazy future ... done
[10:32:42.053] run() for ‘MulticoreFuture’ ... done
[10:32:42.054] plan(): Setting new future strategy stack:
[10:32:42.054] result() for MulticoreFuture ...
[10:32:42.054] List of future strategies:
[10:32:42.054] 1. sequential:
[10:32:42.054]    - args: function (..., envir = parent.frame())
[10:32:42.054]    - tweaked: FALSE
[10:32:42.054]    - call: NULL
[10:32:42.055] plan(): nbrOfWorkers() = 1
[10:32:42.058] plan(): Setting new future strategy stack:
[10:32:42.058] List of future strategies:
[10:32:42.058] 1. multicore:
[10:32:42.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.058]    - tweaked: FALSE
[10:32:42.058]    - call: plan(strategy)
[10:32:42.064] plan(): nbrOfWorkers() = 2
[10:32:42.065] result() for MulticoreFuture ...
[10:32:42.065] result() for MulticoreFuture ... done
[10:32:42.065] result() for MulticoreFuture ... done
[10:32:42.066] result() for MulticoreFuture ...
[10:32:42.066] result() for MulticoreFuture ... done
** Future evaluation with errors
[10:32:42.067] getGlobalsAndPackages() ...
[10:32:42.067] Searching for globals...
[10:32:42.070] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[10:32:42.070] Searching for globals ... DONE
[10:32:42.070] Resolving globals: FALSE
[10:32:42.071] 
[10:32:42.071] 
[10:32:42.071] getGlobalsAndPackages() ... DONE
[10:32:42.072] run() for ‘Future’ ...
[10:32:42.072] - state: ‘created’
[10:32:42.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.077] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.078]   - Field: ‘label’
[10:32:42.078]   - Field: ‘local’
[10:32:42.078]   - Field: ‘owner’
[10:32:42.078]   - Field: ‘envir’
[10:32:42.078]   - Field: ‘workers’
[10:32:42.079]   - Field: ‘packages’
[10:32:42.079]   - Field: ‘gc’
[10:32:42.079]   - Field: ‘job’
[10:32:42.079]   - Field: ‘conditions’
[10:32:42.079]   - Field: ‘expr’
[10:32:42.079]   - Field: ‘uuid’
[10:32:42.079]   - Field: ‘seed’
[10:32:42.079]   - Field: ‘version’
[10:32:42.080]   - Field: ‘result’
[10:32:42.080]   - Field: ‘asynchronous’
[10:32:42.080]   - Field: ‘calls’
[10:32:42.080]   - Field: ‘globals’
[10:32:42.080]   - Field: ‘stdout’
[10:32:42.080]   - Field: ‘earlySignal’
[10:32:42.080]   - Field: ‘lazy’
[10:32:42.080]   - Field: ‘state’
[10:32:42.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.081] - Launch lazy future ...
[10:32:42.081] Packages needed by the future expression (n = 0): <none>
[10:32:42.081] Packages needed by future strategies (n = 0): <none>
[10:32:42.082] {
[10:32:42.082]     {
[10:32:42.082]         {
[10:32:42.082]             ...future.startTime <- base::Sys.time()
[10:32:42.082]             {
[10:32:42.082]                 {
[10:32:42.082]                   {
[10:32:42.082]                     {
[10:32:42.082]                       base::local({
[10:32:42.082]                         has_future <- base::requireNamespace("future", 
[10:32:42.082]                           quietly = TRUE)
[10:32:42.082]                         if (has_future) {
[10:32:42.082]                           ns <- base::getNamespace("future")
[10:32:42.082]                           version <- ns[[".package"]][["version"]]
[10:32:42.082]                           if (is.null(version)) 
[10:32:42.082]                             version <- utils::packageVersion("future")
[10:32:42.082]                         }
[10:32:42.082]                         else {
[10:32:42.082]                           version <- NULL
[10:32:42.082]                         }
[10:32:42.082]                         if (!has_future || version < "1.8.0") {
[10:32:42.082]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.082]                             "", base::R.version$version.string), 
[10:32:42.082]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.082]                               "release", "version")], collapse = " "), 
[10:32:42.082]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.082]                             info)
[10:32:42.082]                           info <- base::paste(info, collapse = "; ")
[10:32:42.082]                           if (!has_future) {
[10:32:42.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.082]                               info)
[10:32:42.082]                           }
[10:32:42.082]                           else {
[10:32:42.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.082]                               info, version)
[10:32:42.082]                           }
[10:32:42.082]                           base::stop(msg)
[10:32:42.082]                         }
[10:32:42.082]                       })
[10:32:42.082]                     }
[10:32:42.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.082]                     base::options(mc.cores = 1L)
[10:32:42.082]                   }
[10:32:42.082]                   ...future.strategy.old <- future::plan("list")
[10:32:42.082]                   options(future.plan = NULL)
[10:32:42.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.082]                 }
[10:32:42.082]                 ...future.workdir <- getwd()
[10:32:42.082]             }
[10:32:42.082]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.082]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.082]         }
[10:32:42.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.082]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.082]             base::names(...future.oldOptions))
[10:32:42.082]     }
[10:32:42.082]     if (FALSE) {
[10:32:42.082]     }
[10:32:42.082]     else {
[10:32:42.082]         if (TRUE) {
[10:32:42.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.082]                 open = "w")
[10:32:42.082]         }
[10:32:42.082]         else {
[10:32:42.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.082]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.082]         }
[10:32:42.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.082]             base::sink(type = "output", split = FALSE)
[10:32:42.082]             base::close(...future.stdout)
[10:32:42.082]         }, add = TRUE)
[10:32:42.082]     }
[10:32:42.082]     ...future.frame <- base::sys.nframe()
[10:32:42.082]     ...future.conditions <- base::list()
[10:32:42.082]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.082]     if (FALSE) {
[10:32:42.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.082]     }
[10:32:42.082]     ...future.result <- base::tryCatch({
[10:32:42.082]         base::withCallingHandlers({
[10:32:42.082]             ...future.value <- base::withVisible(base::local({
[10:32:42.082]                 withCallingHandlers({
[10:32:42.082]                   {
[10:32:42.082]                     x <- 3
[10:32:42.082]                     stop("Woops!")
[10:32:42.082]                     x
[10:32:42.082]                   }
[10:32:42.082]                 }, immediateCondition = function(cond) {
[10:32:42.082]                   save_rds <- function (object, pathname, ...) 
[10:32:42.082]                   {
[10:32:42.082]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.082]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.082]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.082]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.082]                         fi_tmp[["mtime"]])
[10:32:42.082]                     }
[10:32:42.082]                     tryCatch({
[10:32:42.082]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.082]                     }, error = function(ex) {
[10:32:42.082]                       msg <- conditionMessage(ex)
[10:32:42.082]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.082]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.082]                         fi_tmp[["mtime"]], msg)
[10:32:42.082]                       ex$message <- msg
[10:32:42.082]                       stop(ex)
[10:32:42.082]                     })
[10:32:42.082]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.082]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.082]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.082]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.082]                       fi <- file.info(pathname)
[10:32:42.082]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.082]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.082]                         fi[["size"]], fi[["mtime"]])
[10:32:42.082]                       stop(msg)
[10:32:42.082]                     }
[10:32:42.082]                     invisible(pathname)
[10:32:42.082]                   }
[10:32:42.082]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.082]                     rootPath = tempdir()) 
[10:32:42.082]                   {
[10:32:42.082]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.082]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.082]                       tmpdir = path, fileext = ".rds")
[10:32:42.082]                     save_rds(obj, file)
[10:32:42.082]                   }
[10:32:42.082]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.082]                   {
[10:32:42.082]                     inherits <- base::inherits
[10:32:42.082]                     invokeRestart <- base::invokeRestart
[10:32:42.082]                     is.null <- base::is.null
[10:32:42.082]                     muffled <- FALSE
[10:32:42.082]                     if (inherits(cond, "message")) {
[10:32:42.082]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.082]                       if (muffled) 
[10:32:42.082]                         invokeRestart("muffleMessage")
[10:32:42.082]                     }
[10:32:42.082]                     else if (inherits(cond, "warning")) {
[10:32:42.082]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.082]                       if (muffled) 
[10:32:42.082]                         invokeRestart("muffleWarning")
[10:32:42.082]                     }
[10:32:42.082]                     else if (inherits(cond, "condition")) {
[10:32:42.082]                       if (!is.null(pattern)) {
[10:32:42.082]                         computeRestarts <- base::computeRestarts
[10:32:42.082]                         grepl <- base::grepl
[10:32:42.082]                         restarts <- computeRestarts(cond)
[10:32:42.082]                         for (restart in restarts) {
[10:32:42.082]                           name <- restart$name
[10:32:42.082]                           if (is.null(name)) 
[10:32:42.082]                             next
[10:32:42.082]                           if (!grepl(pattern, name)) 
[10:32:42.082]                             next
[10:32:42.082]                           invokeRestart(restart)
[10:32:42.082]                           muffled <- TRUE
[10:32:42.082]                           break
[10:32:42.082]                         }
[10:32:42.082]                       }
[10:32:42.082]                     }
[10:32:42.082]                     invisible(muffled)
[10:32:42.082]                   }
[10:32:42.082]                   muffleCondition(cond)
[10:32:42.082]                 })
[10:32:42.082]             }))
[10:32:42.082]             future::FutureResult(value = ...future.value$value, 
[10:32:42.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.082]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.082]                     ...future.globalenv.names))
[10:32:42.082]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.082]         }, condition = base::local({
[10:32:42.082]             c <- base::c
[10:32:42.082]             inherits <- base::inherits
[10:32:42.082]             invokeRestart <- base::invokeRestart
[10:32:42.082]             length <- base::length
[10:32:42.082]             list <- base::list
[10:32:42.082]             seq.int <- base::seq.int
[10:32:42.082]             signalCondition <- base::signalCondition
[10:32:42.082]             sys.calls <- base::sys.calls
[10:32:42.082]             `[[` <- base::`[[`
[10:32:42.082]             `+` <- base::`+`
[10:32:42.082]             `<<-` <- base::`<<-`
[10:32:42.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.082]                   3L)]
[10:32:42.082]             }
[10:32:42.082]             function(cond) {
[10:32:42.082]                 is_error <- inherits(cond, "error")
[10:32:42.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.082]                   NULL)
[10:32:42.082]                 if (is_error) {
[10:32:42.082]                   sessionInformation <- function() {
[10:32:42.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.082]                       search = base::search(), system = base::Sys.info())
[10:32:42.082]                   }
[10:32:42.082]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.082]                     cond$call), session = sessionInformation(), 
[10:32:42.082]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.082]                   signalCondition(cond)
[10:32:42.082]                 }
[10:32:42.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.082]                 "immediateCondition"))) {
[10:32:42.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.082]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.082]                   if (TRUE && !signal) {
[10:32:42.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.082]                     {
[10:32:42.082]                       inherits <- base::inherits
[10:32:42.082]                       invokeRestart <- base::invokeRestart
[10:32:42.082]                       is.null <- base::is.null
[10:32:42.082]                       muffled <- FALSE
[10:32:42.082]                       if (inherits(cond, "message")) {
[10:32:42.082]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.082]                         if (muffled) 
[10:32:42.082]                           invokeRestart("muffleMessage")
[10:32:42.082]                       }
[10:32:42.082]                       else if (inherits(cond, "warning")) {
[10:32:42.082]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.082]                         if (muffled) 
[10:32:42.082]                           invokeRestart("muffleWarning")
[10:32:42.082]                       }
[10:32:42.082]                       else if (inherits(cond, "condition")) {
[10:32:42.082]                         if (!is.null(pattern)) {
[10:32:42.082]                           computeRestarts <- base::computeRestarts
[10:32:42.082]                           grepl <- base::grepl
[10:32:42.082]                           restarts <- computeRestarts(cond)
[10:32:42.082]                           for (restart in restarts) {
[10:32:42.082]                             name <- restart$name
[10:32:42.082]                             if (is.null(name)) 
[10:32:42.082]                               next
[10:32:42.082]                             if (!grepl(pattern, name)) 
[10:32:42.082]                               next
[10:32:42.082]                             invokeRestart(restart)
[10:32:42.082]                             muffled <- TRUE
[10:32:42.082]                             break
[10:32:42.082]                           }
[10:32:42.082]                         }
[10:32:42.082]                       }
[10:32:42.082]                       invisible(muffled)
[10:32:42.082]                     }
[10:32:42.082]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.082]                   }
[10:32:42.082]                 }
[10:32:42.082]                 else {
[10:32:42.082]                   if (TRUE) {
[10:32:42.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.082]                     {
[10:32:42.082]                       inherits <- base::inherits
[10:32:42.082]                       invokeRestart <- base::invokeRestart
[10:32:42.082]                       is.null <- base::is.null
[10:32:42.082]                       muffled <- FALSE
[10:32:42.082]                       if (inherits(cond, "message")) {
[10:32:42.082]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.082]                         if (muffled) 
[10:32:42.082]                           invokeRestart("muffleMessage")
[10:32:42.082]                       }
[10:32:42.082]                       else if (inherits(cond, "warning")) {
[10:32:42.082]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.082]                         if (muffled) 
[10:32:42.082]                           invokeRestart("muffleWarning")
[10:32:42.082]                       }
[10:32:42.082]                       else if (inherits(cond, "condition")) {
[10:32:42.082]                         if (!is.null(pattern)) {
[10:32:42.082]                           computeRestarts <- base::computeRestarts
[10:32:42.082]                           grepl <- base::grepl
[10:32:42.082]                           restarts <- computeRestarts(cond)
[10:32:42.082]                           for (restart in restarts) {
[10:32:42.082]                             name <- restart$name
[10:32:42.082]                             if (is.null(name)) 
[10:32:42.082]                               next
[10:32:42.082]                             if (!grepl(pattern, name)) 
[10:32:42.082]                               next
[10:32:42.082]                             invokeRestart(restart)
[10:32:42.082]                             muffled <- TRUE
[10:32:42.082]                             break
[10:32:42.082]                           }
[10:32:42.082]                         }
[10:32:42.082]                       }
[10:32:42.082]                       invisible(muffled)
[10:32:42.082]                     }
[10:32:42.082]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.082]                   }
[10:32:42.082]                 }
[10:32:42.082]             }
[10:32:42.082]         }))
[10:32:42.082]     }, error = function(ex) {
[10:32:42.082]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.082]                 ...future.rng), started = ...future.startTime, 
[10:32:42.082]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.082]             version = "1.8"), class = "FutureResult")
[10:32:42.082]     }, finally = {
[10:32:42.082]         if (!identical(...future.workdir, getwd())) 
[10:32:42.082]             setwd(...future.workdir)
[10:32:42.082]         {
[10:32:42.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.082]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.082]             }
[10:32:42.082]             base::options(...future.oldOptions)
[10:32:42.082]             if (.Platform$OS.type == "windows") {
[10:32:42.082]                 old_names <- names(...future.oldEnvVars)
[10:32:42.082]                 envs <- base::Sys.getenv()
[10:32:42.082]                 names <- names(envs)
[10:32:42.082]                 common <- intersect(names, old_names)
[10:32:42.082]                 added <- setdiff(names, old_names)
[10:32:42.082]                 removed <- setdiff(old_names, names)
[10:32:42.082]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.082]                   envs[common]]
[10:32:42.082]                 NAMES <- toupper(changed)
[10:32:42.082]                 args <- list()
[10:32:42.082]                 for (kk in seq_along(NAMES)) {
[10:32:42.082]                   name <- changed[[kk]]
[10:32:42.082]                   NAME <- NAMES[[kk]]
[10:32:42.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.082]                     next
[10:32:42.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.082]                 }
[10:32:42.082]                 NAMES <- toupper(added)
[10:32:42.082]                 for (kk in seq_along(NAMES)) {
[10:32:42.082]                   name <- added[[kk]]
[10:32:42.082]                   NAME <- NAMES[[kk]]
[10:32:42.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.082]                     next
[10:32:42.082]                   args[[name]] <- ""
[10:32:42.082]                 }
[10:32:42.082]                 NAMES <- toupper(removed)
[10:32:42.082]                 for (kk in seq_along(NAMES)) {
[10:32:42.082]                   name <- removed[[kk]]
[10:32:42.082]                   NAME <- NAMES[[kk]]
[10:32:42.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.082]                     next
[10:32:42.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.082]                 }
[10:32:42.082]                 if (length(args) > 0) 
[10:32:42.082]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.082]             }
[10:32:42.082]             else {
[10:32:42.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.082]             }
[10:32:42.082]             {
[10:32:42.082]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.082]                   0L) {
[10:32:42.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.082]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.082]                   base::options(opts)
[10:32:42.082]                 }
[10:32:42.082]                 {
[10:32:42.082]                   {
[10:32:42.082]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.082]                     NULL
[10:32:42.082]                   }
[10:32:42.082]                   options(future.plan = NULL)
[10:32:42.082]                   if (is.na(NA_character_)) 
[10:32:42.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.082]                     .init = FALSE)
[10:32:42.082]                 }
[10:32:42.082]             }
[10:32:42.082]         }
[10:32:42.082]     })
[10:32:42.082]     if (TRUE) {
[10:32:42.082]         base::sink(type = "output", split = FALSE)
[10:32:42.082]         if (TRUE) {
[10:32:42.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.082]         }
[10:32:42.082]         else {
[10:32:42.082]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.082]         }
[10:32:42.082]         base::close(...future.stdout)
[10:32:42.082]         ...future.stdout <- NULL
[10:32:42.082]     }
[10:32:42.082]     ...future.result$conditions <- ...future.conditions
[10:32:42.082]     ...future.result$finished <- base::Sys.time()
[10:32:42.082]     ...future.result
[10:32:42.082] }
[10:32:42.084] requestCore(): workers = 2
[10:32:42.086] MulticoreFuture started
[10:32:42.087] - Launch lazy future ... done
[10:32:42.087] run() for ‘MulticoreFuture’ ... done
[10:32:42.088] result() for MulticoreFuture ...
[10:32:42.088] plan(): Setting new future strategy stack:
[10:32:42.088] List of future strategies:
[10:32:42.088] 1. sequential:
[10:32:42.088]    - args: function (..., envir = parent.frame())
[10:32:42.088]    - tweaked: FALSE
[10:32:42.088]    - call: NULL
[10:32:42.089] plan(): nbrOfWorkers() = 1
[10:32:42.091] plan(): Setting new future strategy stack:
[10:32:42.091] List of future strategies:
[10:32:42.091] 1. multicore:
[10:32:42.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.091]    - tweaked: FALSE
[10:32:42.091]    - call: plan(strategy)
[10:32:42.096] plan(): nbrOfWorkers() = 2
[10:32:42.101] result() for MulticoreFuture ...
[10:32:42.101] result() for MulticoreFuture ... done
[10:32:42.101] signalConditions() ...
[10:32:42.101]  - include = ‘immediateCondition’
[10:32:42.102]  - exclude = 
[10:32:42.102]  - resignal = FALSE
[10:32:42.102]  - Number of conditions: 1
[10:32:42.102] signalConditions() ... done
[10:32:42.102] result() for MulticoreFuture ... done
[10:32:42.102] result() for MulticoreFuture ...
[10:32:42.102] result() for MulticoreFuture ... done
[10:32:42.102] signalConditions() ...
[10:32:42.103]  - include = ‘immediateCondition’
[10:32:42.103]  - exclude = 
[10:32:42.103]  - resignal = FALSE
[10:32:42.103]  - Number of conditions: 1
[10:32:42.103] signalConditions() ... done
[10:32:42.103] Future state: ‘finished’
[10:32:42.103] result() for MulticoreFuture ...
[10:32:42.103] result() for MulticoreFuture ... done
[10:32:42.104] signalConditions() ...
[10:32:42.104]  - include = ‘condition’
[10:32:42.104]  - exclude = ‘immediateCondition’
[10:32:42.104]  - resignal = TRUE
[10:32:42.104]  - Number of conditions: 1
[10:32:42.104]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:42.104] signalConditions() ... done
[10:32:42.105] getGlobalsAndPackages() ...
[10:32:42.105] Searching for globals...
[10:32:42.107] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:42.107] Searching for globals ... DONE
[10:32:42.107] Resolving globals: FALSE
[10:32:42.108] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:42.109] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:42.109] - globals: [1] ‘ii’
[10:32:42.109] 
[10:32:42.109] getGlobalsAndPackages() ... DONE
[10:32:42.109] run() for ‘Future’ ...
[10:32:42.109] - state: ‘created’
[10:32:42.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.114] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.114]   - Field: ‘label’
[10:32:42.114]   - Field: ‘local’
[10:32:42.114]   - Field: ‘owner’
[10:32:42.114]   - Field: ‘envir’
[10:32:42.114]   - Field: ‘workers’
[10:32:42.114]   - Field: ‘packages’
[10:32:42.115]   - Field: ‘gc’
[10:32:42.115]   - Field: ‘job’
[10:32:42.115]   - Field: ‘conditions’
[10:32:42.115]   - Field: ‘expr’
[10:32:42.115]   - Field: ‘uuid’
[10:32:42.115]   - Field: ‘seed’
[10:32:42.115]   - Field: ‘version’
[10:32:42.115]   - Field: ‘result’
[10:32:42.115]   - Field: ‘asynchronous’
[10:32:42.116]   - Field: ‘calls’
[10:32:42.116]   - Field: ‘globals’
[10:32:42.116]   - Field: ‘stdout’
[10:32:42.116]   - Field: ‘earlySignal’
[10:32:42.116]   - Field: ‘lazy’
[10:32:42.119]   - Field: ‘state’
[10:32:42.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.119] - Launch lazy future ...
[10:32:42.119] Packages needed by the future expression (n = 0): <none>
[10:32:42.120] Packages needed by future strategies (n = 0): <none>
[10:32:42.120] {
[10:32:42.120]     {
[10:32:42.120]         {
[10:32:42.120]             ...future.startTime <- base::Sys.time()
[10:32:42.120]             {
[10:32:42.120]                 {
[10:32:42.120]                   {
[10:32:42.120]                     {
[10:32:42.120]                       base::local({
[10:32:42.120]                         has_future <- base::requireNamespace("future", 
[10:32:42.120]                           quietly = TRUE)
[10:32:42.120]                         if (has_future) {
[10:32:42.120]                           ns <- base::getNamespace("future")
[10:32:42.120]                           version <- ns[[".package"]][["version"]]
[10:32:42.120]                           if (is.null(version)) 
[10:32:42.120]                             version <- utils::packageVersion("future")
[10:32:42.120]                         }
[10:32:42.120]                         else {
[10:32:42.120]                           version <- NULL
[10:32:42.120]                         }
[10:32:42.120]                         if (!has_future || version < "1.8.0") {
[10:32:42.120]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.120]                             "", base::R.version$version.string), 
[10:32:42.120]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.120]                               "release", "version")], collapse = " "), 
[10:32:42.120]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.120]                             info)
[10:32:42.120]                           info <- base::paste(info, collapse = "; ")
[10:32:42.120]                           if (!has_future) {
[10:32:42.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.120]                               info)
[10:32:42.120]                           }
[10:32:42.120]                           else {
[10:32:42.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.120]                               info, version)
[10:32:42.120]                           }
[10:32:42.120]                           base::stop(msg)
[10:32:42.120]                         }
[10:32:42.120]                       })
[10:32:42.120]                     }
[10:32:42.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.120]                     base::options(mc.cores = 1L)
[10:32:42.120]                   }
[10:32:42.120]                   ...future.strategy.old <- future::plan("list")
[10:32:42.120]                   options(future.plan = NULL)
[10:32:42.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.120]                 }
[10:32:42.120]                 ...future.workdir <- getwd()
[10:32:42.120]             }
[10:32:42.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.120]         }
[10:32:42.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.120]             base::names(...future.oldOptions))
[10:32:42.120]     }
[10:32:42.120]     if (FALSE) {
[10:32:42.120]     }
[10:32:42.120]     else {
[10:32:42.120]         if (TRUE) {
[10:32:42.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.120]                 open = "w")
[10:32:42.120]         }
[10:32:42.120]         else {
[10:32:42.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.120]         }
[10:32:42.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.120]             base::sink(type = "output", split = FALSE)
[10:32:42.120]             base::close(...future.stdout)
[10:32:42.120]         }, add = TRUE)
[10:32:42.120]     }
[10:32:42.120]     ...future.frame <- base::sys.nframe()
[10:32:42.120]     ...future.conditions <- base::list()
[10:32:42.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.120]     if (FALSE) {
[10:32:42.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.120]     }
[10:32:42.120]     ...future.result <- base::tryCatch({
[10:32:42.120]         base::withCallingHandlers({
[10:32:42.120]             ...future.value <- base::withVisible(base::local({
[10:32:42.120]                 withCallingHandlers({
[10:32:42.120]                   {
[10:32:42.120]                     if (ii%%2 == 0) 
[10:32:42.120]                       stop("Woops!")
[10:32:42.120]                     ii
[10:32:42.120]                   }
[10:32:42.120]                 }, immediateCondition = function(cond) {
[10:32:42.120]                   save_rds <- function (object, pathname, ...) 
[10:32:42.120]                   {
[10:32:42.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.120]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.120]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.120]                         fi_tmp[["mtime"]])
[10:32:42.120]                     }
[10:32:42.120]                     tryCatch({
[10:32:42.120]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.120]                     }, error = function(ex) {
[10:32:42.120]                       msg <- conditionMessage(ex)
[10:32:42.120]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.120]                         fi_tmp[["mtime"]], msg)
[10:32:42.120]                       ex$message <- msg
[10:32:42.120]                       stop(ex)
[10:32:42.120]                     })
[10:32:42.120]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.120]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.120]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.120]                       fi <- file.info(pathname)
[10:32:42.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.120]                         fi[["size"]], fi[["mtime"]])
[10:32:42.120]                       stop(msg)
[10:32:42.120]                     }
[10:32:42.120]                     invisible(pathname)
[10:32:42.120]                   }
[10:32:42.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.120]                     rootPath = tempdir()) 
[10:32:42.120]                   {
[10:32:42.120]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.120]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.120]                       tmpdir = path, fileext = ".rds")
[10:32:42.120]                     save_rds(obj, file)
[10:32:42.120]                   }
[10:32:42.120]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.120]                   {
[10:32:42.120]                     inherits <- base::inherits
[10:32:42.120]                     invokeRestart <- base::invokeRestart
[10:32:42.120]                     is.null <- base::is.null
[10:32:42.120]                     muffled <- FALSE
[10:32:42.120]                     if (inherits(cond, "message")) {
[10:32:42.120]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.120]                       if (muffled) 
[10:32:42.120]                         invokeRestart("muffleMessage")
[10:32:42.120]                     }
[10:32:42.120]                     else if (inherits(cond, "warning")) {
[10:32:42.120]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.120]                       if (muffled) 
[10:32:42.120]                         invokeRestart("muffleWarning")
[10:32:42.120]                     }
[10:32:42.120]                     else if (inherits(cond, "condition")) {
[10:32:42.120]                       if (!is.null(pattern)) {
[10:32:42.120]                         computeRestarts <- base::computeRestarts
[10:32:42.120]                         grepl <- base::grepl
[10:32:42.120]                         restarts <- computeRestarts(cond)
[10:32:42.120]                         for (restart in restarts) {
[10:32:42.120]                           name <- restart$name
[10:32:42.120]                           if (is.null(name)) 
[10:32:42.120]                             next
[10:32:42.120]                           if (!grepl(pattern, name)) 
[10:32:42.120]                             next
[10:32:42.120]                           invokeRestart(restart)
[10:32:42.120]                           muffled <- TRUE
[10:32:42.120]                           break
[10:32:42.120]                         }
[10:32:42.120]                       }
[10:32:42.120]                     }
[10:32:42.120]                     invisible(muffled)
[10:32:42.120]                   }
[10:32:42.120]                   muffleCondition(cond)
[10:32:42.120]                 })
[10:32:42.120]             }))
[10:32:42.120]             future::FutureResult(value = ...future.value$value, 
[10:32:42.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.120]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.120]                     ...future.globalenv.names))
[10:32:42.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.120]         }, condition = base::local({
[10:32:42.120]             c <- base::c
[10:32:42.120]             inherits <- base::inherits
[10:32:42.120]             invokeRestart <- base::invokeRestart
[10:32:42.120]             length <- base::length
[10:32:42.120]             list <- base::list
[10:32:42.120]             seq.int <- base::seq.int
[10:32:42.120]             signalCondition <- base::signalCondition
[10:32:42.120]             sys.calls <- base::sys.calls
[10:32:42.120]             `[[` <- base::`[[`
[10:32:42.120]             `+` <- base::`+`
[10:32:42.120]             `<<-` <- base::`<<-`
[10:32:42.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.120]                   3L)]
[10:32:42.120]             }
[10:32:42.120]             function(cond) {
[10:32:42.120]                 is_error <- inherits(cond, "error")
[10:32:42.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.120]                   NULL)
[10:32:42.120]                 if (is_error) {
[10:32:42.120]                   sessionInformation <- function() {
[10:32:42.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.120]                       search = base::search(), system = base::Sys.info())
[10:32:42.120]                   }
[10:32:42.120]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.120]                     cond$call), session = sessionInformation(), 
[10:32:42.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.120]                   signalCondition(cond)
[10:32:42.120]                 }
[10:32:42.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.120]                 "immediateCondition"))) {
[10:32:42.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.120]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.120]                   if (TRUE && !signal) {
[10:32:42.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.120]                     {
[10:32:42.120]                       inherits <- base::inherits
[10:32:42.120]                       invokeRestart <- base::invokeRestart
[10:32:42.120]                       is.null <- base::is.null
[10:32:42.120]                       muffled <- FALSE
[10:32:42.120]                       if (inherits(cond, "message")) {
[10:32:42.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.120]                         if (muffled) 
[10:32:42.120]                           invokeRestart("muffleMessage")
[10:32:42.120]                       }
[10:32:42.120]                       else if (inherits(cond, "warning")) {
[10:32:42.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.120]                         if (muffled) 
[10:32:42.120]                           invokeRestart("muffleWarning")
[10:32:42.120]                       }
[10:32:42.120]                       else if (inherits(cond, "condition")) {
[10:32:42.120]                         if (!is.null(pattern)) {
[10:32:42.120]                           computeRestarts <- base::computeRestarts
[10:32:42.120]                           grepl <- base::grepl
[10:32:42.120]                           restarts <- computeRestarts(cond)
[10:32:42.120]                           for (restart in restarts) {
[10:32:42.120]                             name <- restart$name
[10:32:42.120]                             if (is.null(name)) 
[10:32:42.120]                               next
[10:32:42.120]                             if (!grepl(pattern, name)) 
[10:32:42.120]                               next
[10:32:42.120]                             invokeRestart(restart)
[10:32:42.120]                             muffled <- TRUE
[10:32:42.120]                             break
[10:32:42.120]                           }
[10:32:42.120]                         }
[10:32:42.120]                       }
[10:32:42.120]                       invisible(muffled)
[10:32:42.120]                     }
[10:32:42.120]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.120]                   }
[10:32:42.120]                 }
[10:32:42.120]                 else {
[10:32:42.120]                   if (TRUE) {
[10:32:42.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.120]                     {
[10:32:42.120]                       inherits <- base::inherits
[10:32:42.120]                       invokeRestart <- base::invokeRestart
[10:32:42.120]                       is.null <- base::is.null
[10:32:42.120]                       muffled <- FALSE
[10:32:42.120]                       if (inherits(cond, "message")) {
[10:32:42.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.120]                         if (muffled) 
[10:32:42.120]                           invokeRestart("muffleMessage")
[10:32:42.120]                       }
[10:32:42.120]                       else if (inherits(cond, "warning")) {
[10:32:42.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.120]                         if (muffled) 
[10:32:42.120]                           invokeRestart("muffleWarning")
[10:32:42.120]                       }
[10:32:42.120]                       else if (inherits(cond, "condition")) {
[10:32:42.120]                         if (!is.null(pattern)) {
[10:32:42.120]                           computeRestarts <- base::computeRestarts
[10:32:42.120]                           grepl <- base::grepl
[10:32:42.120]                           restarts <- computeRestarts(cond)
[10:32:42.120]                           for (restart in restarts) {
[10:32:42.120]                             name <- restart$name
[10:32:42.120]                             if (is.null(name)) 
[10:32:42.120]                               next
[10:32:42.120]                             if (!grepl(pattern, name)) 
[10:32:42.120]                               next
[10:32:42.120]                             invokeRestart(restart)
[10:32:42.120]                             muffled <- TRUE
[10:32:42.120]                             break
[10:32:42.120]                           }
[10:32:42.120]                         }
[10:32:42.120]                       }
[10:32:42.120]                       invisible(muffled)
[10:32:42.120]                     }
[10:32:42.120]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.120]                   }
[10:32:42.120]                 }
[10:32:42.120]             }
[10:32:42.120]         }))
[10:32:42.120]     }, error = function(ex) {
[10:32:42.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.120]                 ...future.rng), started = ...future.startTime, 
[10:32:42.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.120]             version = "1.8"), class = "FutureResult")
[10:32:42.120]     }, finally = {
[10:32:42.120]         if (!identical(...future.workdir, getwd())) 
[10:32:42.120]             setwd(...future.workdir)
[10:32:42.120]         {
[10:32:42.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.120]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.120]             }
[10:32:42.120]             base::options(...future.oldOptions)
[10:32:42.120]             if (.Platform$OS.type == "windows") {
[10:32:42.120]                 old_names <- names(...future.oldEnvVars)
[10:32:42.120]                 envs <- base::Sys.getenv()
[10:32:42.120]                 names <- names(envs)
[10:32:42.120]                 common <- intersect(names, old_names)
[10:32:42.120]                 added <- setdiff(names, old_names)
[10:32:42.120]                 removed <- setdiff(old_names, names)
[10:32:42.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.120]                   envs[common]]
[10:32:42.120]                 NAMES <- toupper(changed)
[10:32:42.120]                 args <- list()
[10:32:42.120]                 for (kk in seq_along(NAMES)) {
[10:32:42.120]                   name <- changed[[kk]]
[10:32:42.120]                   NAME <- NAMES[[kk]]
[10:32:42.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.120]                     next
[10:32:42.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.120]                 }
[10:32:42.120]                 NAMES <- toupper(added)
[10:32:42.120]                 for (kk in seq_along(NAMES)) {
[10:32:42.120]                   name <- added[[kk]]
[10:32:42.120]                   NAME <- NAMES[[kk]]
[10:32:42.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.120]                     next
[10:32:42.120]                   args[[name]] <- ""
[10:32:42.120]                 }
[10:32:42.120]                 NAMES <- toupper(removed)
[10:32:42.120]                 for (kk in seq_along(NAMES)) {
[10:32:42.120]                   name <- removed[[kk]]
[10:32:42.120]                   NAME <- NAMES[[kk]]
[10:32:42.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.120]                     next
[10:32:42.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.120]                 }
[10:32:42.120]                 if (length(args) > 0) 
[10:32:42.120]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.120]             }
[10:32:42.120]             else {
[10:32:42.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.120]             }
[10:32:42.120]             {
[10:32:42.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.120]                   0L) {
[10:32:42.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.120]                   base::options(opts)
[10:32:42.120]                 }
[10:32:42.120]                 {
[10:32:42.120]                   {
[10:32:42.120]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.120]                     NULL
[10:32:42.120]                   }
[10:32:42.120]                   options(future.plan = NULL)
[10:32:42.120]                   if (is.na(NA_character_)) 
[10:32:42.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.120]                     .init = FALSE)
[10:32:42.120]                 }
[10:32:42.120]             }
[10:32:42.120]         }
[10:32:42.120]     })
[10:32:42.120]     if (TRUE) {
[10:32:42.120]         base::sink(type = "output", split = FALSE)
[10:32:42.120]         if (TRUE) {
[10:32:42.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.120]         }
[10:32:42.120]         else {
[10:32:42.120]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.120]         }
[10:32:42.120]         base::close(...future.stdout)
[10:32:42.120]         ...future.stdout <- NULL
[10:32:42.120]     }
[10:32:42.120]     ...future.result$conditions <- ...future.conditions
[10:32:42.120]     ...future.result$finished <- base::Sys.time()
[10:32:42.120]     ...future.result
[10:32:42.120] }
[10:32:42.123] assign_globals() ...
[10:32:42.123] List of 1
[10:32:42.123]  $ ii: int 1
[10:32:42.123]  - attr(*, "where")=List of 1
[10:32:42.123]   ..$ ii:<environment: R_EmptyEnv> 
[10:32:42.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:42.123]  - attr(*, "resolved")= logi FALSE
[10:32:42.123]  - attr(*, "total_size")= num 56
[10:32:42.123]  - attr(*, "already-done")= logi TRUE
[10:32:42.126] - copied ‘ii’ to environment
[10:32:42.126] assign_globals() ... done
[10:32:42.126] requestCore(): workers = 2
[10:32:42.128] MulticoreFuture started
[10:32:42.129] - Launch lazy future ... done
[10:32:42.129] run() for ‘MulticoreFuture’ ... done
[10:32:42.130] plan(): Setting new future strategy stack:
[10:32:42.130] getGlobalsAndPackages() ...
[10:32:42.130] Searching for globals...
[10:32:42.130] List of future strategies:
[10:32:42.130] 1. sequential:
[10:32:42.130]    - args: function (..., envir = parent.frame())
[10:32:42.130]    - tweaked: FALSE
[10:32:42.130]    - call: NULL
[10:32:42.131] plan(): nbrOfWorkers() = 1
[10:32:42.133] plan(): Setting new future strategy stack:
[10:32:42.133] List of future strategies:
[10:32:42.133] 1. multicore:
[10:32:42.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.133]    - tweaked: FALSE
[10:32:42.133]    - call: plan(strategy)
[10:32:42.133] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:42.134] Searching for globals ... DONE
[10:32:42.134] Resolving globals: FALSE
[10:32:42.135] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:42.136] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:42.136] - globals: [1] ‘ii’
[10:32:42.136] 
[10:32:42.136] getGlobalsAndPackages() ... DONE
[10:32:42.137] run() for ‘Future’ ...
[10:32:42.137] - state: ‘created’
[10:32:42.137] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.138] plan(): nbrOfWorkers() = 2
[10:32:42.141] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.142]   - Field: ‘label’
[10:32:42.142]   - Field: ‘local’
[10:32:42.142]   - Field: ‘owner’
[10:32:42.142]   - Field: ‘envir’
[10:32:42.142]   - Field: ‘workers’
[10:32:42.143]   - Field: ‘packages’
[10:32:42.143]   - Field: ‘gc’
[10:32:42.143]   - Field: ‘job’
[10:32:42.143]   - Field: ‘conditions’
[10:32:42.143]   - Field: ‘expr’
[10:32:42.143]   - Field: ‘uuid’
[10:32:42.143]   - Field: ‘seed’
[10:32:42.143]   - Field: ‘version’
[10:32:42.144]   - Field: ‘result’
[10:32:42.144]   - Field: ‘asynchronous’
[10:32:42.144]   - Field: ‘calls’
[10:32:42.144]   - Field: ‘globals’
[10:32:42.144]   - Field: ‘stdout’
[10:32:42.144]   - Field: ‘earlySignal’
[10:32:42.144]   - Field: ‘lazy’
[10:32:42.145]   - Field: ‘state’
[10:32:42.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.145] - Launch lazy future ...
[10:32:42.145] Packages needed by the future expression (n = 0): <none>
[10:32:42.146] Packages needed by future strategies (n = 0): <none>
[10:32:42.146] {
[10:32:42.146]     {
[10:32:42.146]         {
[10:32:42.146]             ...future.startTime <- base::Sys.time()
[10:32:42.146]             {
[10:32:42.146]                 {
[10:32:42.146]                   {
[10:32:42.146]                     {
[10:32:42.146]                       base::local({
[10:32:42.146]                         has_future <- base::requireNamespace("future", 
[10:32:42.146]                           quietly = TRUE)
[10:32:42.146]                         if (has_future) {
[10:32:42.146]                           ns <- base::getNamespace("future")
[10:32:42.146]                           version <- ns[[".package"]][["version"]]
[10:32:42.146]                           if (is.null(version)) 
[10:32:42.146]                             version <- utils::packageVersion("future")
[10:32:42.146]                         }
[10:32:42.146]                         else {
[10:32:42.146]                           version <- NULL
[10:32:42.146]                         }
[10:32:42.146]                         if (!has_future || version < "1.8.0") {
[10:32:42.146]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.146]                             "", base::R.version$version.string), 
[10:32:42.146]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.146]                               "release", "version")], collapse = " "), 
[10:32:42.146]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.146]                             info)
[10:32:42.146]                           info <- base::paste(info, collapse = "; ")
[10:32:42.146]                           if (!has_future) {
[10:32:42.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.146]                               info)
[10:32:42.146]                           }
[10:32:42.146]                           else {
[10:32:42.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.146]                               info, version)
[10:32:42.146]                           }
[10:32:42.146]                           base::stop(msg)
[10:32:42.146]                         }
[10:32:42.146]                       })
[10:32:42.146]                     }
[10:32:42.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.146]                     base::options(mc.cores = 1L)
[10:32:42.146]                   }
[10:32:42.146]                   ...future.strategy.old <- future::plan("list")
[10:32:42.146]                   options(future.plan = NULL)
[10:32:42.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.146]                 }
[10:32:42.146]                 ...future.workdir <- getwd()
[10:32:42.146]             }
[10:32:42.146]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.146]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.146]         }
[10:32:42.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.146]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.146]             base::names(...future.oldOptions))
[10:32:42.146]     }
[10:32:42.146]     if (FALSE) {
[10:32:42.146]     }
[10:32:42.146]     else {
[10:32:42.146]         if (TRUE) {
[10:32:42.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.146]                 open = "w")
[10:32:42.146]         }
[10:32:42.146]         else {
[10:32:42.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.146]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.146]         }
[10:32:42.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.146]             base::sink(type = "output", split = FALSE)
[10:32:42.146]             base::close(...future.stdout)
[10:32:42.146]         }, add = TRUE)
[10:32:42.146]     }
[10:32:42.146]     ...future.frame <- base::sys.nframe()
[10:32:42.146]     ...future.conditions <- base::list()
[10:32:42.146]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.146]     if (FALSE) {
[10:32:42.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.146]     }
[10:32:42.146]     ...future.result <- base::tryCatch({
[10:32:42.146]         base::withCallingHandlers({
[10:32:42.146]             ...future.value <- base::withVisible(base::local({
[10:32:42.146]                 withCallingHandlers({
[10:32:42.146]                   {
[10:32:42.146]                     if (ii%%2 == 0) 
[10:32:42.146]                       stop("Woops!")
[10:32:42.146]                     ii
[10:32:42.146]                   }
[10:32:42.146]                 }, immediateCondition = function(cond) {
[10:32:42.146]                   save_rds <- function (object, pathname, ...) 
[10:32:42.146]                   {
[10:32:42.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.146]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.146]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.146]                         fi_tmp[["mtime"]])
[10:32:42.146]                     }
[10:32:42.146]                     tryCatch({
[10:32:42.146]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.146]                     }, error = function(ex) {
[10:32:42.146]                       msg <- conditionMessage(ex)
[10:32:42.146]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.146]                         fi_tmp[["mtime"]], msg)
[10:32:42.146]                       ex$message <- msg
[10:32:42.146]                       stop(ex)
[10:32:42.146]                     })
[10:32:42.146]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.146]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.146]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.146]                       fi <- file.info(pathname)
[10:32:42.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.146]                         fi[["size"]], fi[["mtime"]])
[10:32:42.146]                       stop(msg)
[10:32:42.146]                     }
[10:32:42.146]                     invisible(pathname)
[10:32:42.146]                   }
[10:32:42.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.146]                     rootPath = tempdir()) 
[10:32:42.146]                   {
[10:32:42.146]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.146]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.146]                       tmpdir = path, fileext = ".rds")
[10:32:42.146]                     save_rds(obj, file)
[10:32:42.146]                   }
[10:32:42.146]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.146]                   {
[10:32:42.146]                     inherits <- base::inherits
[10:32:42.146]                     invokeRestart <- base::invokeRestart
[10:32:42.146]                     is.null <- base::is.null
[10:32:42.146]                     muffled <- FALSE
[10:32:42.146]                     if (inherits(cond, "message")) {
[10:32:42.146]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.146]                       if (muffled) 
[10:32:42.146]                         invokeRestart("muffleMessage")
[10:32:42.146]                     }
[10:32:42.146]                     else if (inherits(cond, "warning")) {
[10:32:42.146]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.146]                       if (muffled) 
[10:32:42.146]                         invokeRestart("muffleWarning")
[10:32:42.146]                     }
[10:32:42.146]                     else if (inherits(cond, "condition")) {
[10:32:42.146]                       if (!is.null(pattern)) {
[10:32:42.146]                         computeRestarts <- base::computeRestarts
[10:32:42.146]                         grepl <- base::grepl
[10:32:42.146]                         restarts <- computeRestarts(cond)
[10:32:42.146]                         for (restart in restarts) {
[10:32:42.146]                           name <- restart$name
[10:32:42.146]                           if (is.null(name)) 
[10:32:42.146]                             next
[10:32:42.146]                           if (!grepl(pattern, name)) 
[10:32:42.146]                             next
[10:32:42.146]                           invokeRestart(restart)
[10:32:42.146]                           muffled <- TRUE
[10:32:42.146]                           break
[10:32:42.146]                         }
[10:32:42.146]                       }
[10:32:42.146]                     }
[10:32:42.146]                     invisible(muffled)
[10:32:42.146]                   }
[10:32:42.146]                   muffleCondition(cond)
[10:32:42.146]                 })
[10:32:42.146]             }))
[10:32:42.146]             future::FutureResult(value = ...future.value$value, 
[10:32:42.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.146]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.146]                     ...future.globalenv.names))
[10:32:42.146]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.146]         }, condition = base::local({
[10:32:42.146]             c <- base::c
[10:32:42.146]             inherits <- base::inherits
[10:32:42.146]             invokeRestart <- base::invokeRestart
[10:32:42.146]             length <- base::length
[10:32:42.146]             list <- base::list
[10:32:42.146]             seq.int <- base::seq.int
[10:32:42.146]             signalCondition <- base::signalCondition
[10:32:42.146]             sys.calls <- base::sys.calls
[10:32:42.146]             `[[` <- base::`[[`
[10:32:42.146]             `+` <- base::`+`
[10:32:42.146]             `<<-` <- base::`<<-`
[10:32:42.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.146]                   3L)]
[10:32:42.146]             }
[10:32:42.146]             function(cond) {
[10:32:42.146]                 is_error <- inherits(cond, "error")
[10:32:42.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.146]                   NULL)
[10:32:42.146]                 if (is_error) {
[10:32:42.146]                   sessionInformation <- function() {
[10:32:42.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.146]                       search = base::search(), system = base::Sys.info())
[10:32:42.146]                   }
[10:32:42.146]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.146]                     cond$call), session = sessionInformation(), 
[10:32:42.146]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.146]                   signalCondition(cond)
[10:32:42.146]                 }
[10:32:42.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.146]                 "immediateCondition"))) {
[10:32:42.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.146]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.146]                   if (TRUE && !signal) {
[10:32:42.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.146]                     {
[10:32:42.146]                       inherits <- base::inherits
[10:32:42.146]                       invokeRestart <- base::invokeRestart
[10:32:42.146]                       is.null <- base::is.null
[10:32:42.146]                       muffled <- FALSE
[10:32:42.146]                       if (inherits(cond, "message")) {
[10:32:42.146]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.146]                         if (muffled) 
[10:32:42.146]                           invokeRestart("muffleMessage")
[10:32:42.146]                       }
[10:32:42.146]                       else if (inherits(cond, "warning")) {
[10:32:42.146]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.146]                         if (muffled) 
[10:32:42.146]                           invokeRestart("muffleWarning")
[10:32:42.146]                       }
[10:32:42.146]                       else if (inherits(cond, "condition")) {
[10:32:42.146]                         if (!is.null(pattern)) {
[10:32:42.146]                           computeRestarts <- base::computeRestarts
[10:32:42.146]                           grepl <- base::grepl
[10:32:42.146]                           restarts <- computeRestarts(cond)
[10:32:42.146]                           for (restart in restarts) {
[10:32:42.146]                             name <- restart$name
[10:32:42.146]                             if (is.null(name)) 
[10:32:42.146]                               next
[10:32:42.146]                             if (!grepl(pattern, name)) 
[10:32:42.146]                               next
[10:32:42.146]                             invokeRestart(restart)
[10:32:42.146]                             muffled <- TRUE
[10:32:42.146]                             break
[10:32:42.146]                           }
[10:32:42.146]                         }
[10:32:42.146]                       }
[10:32:42.146]                       invisible(muffled)
[10:32:42.146]                     }
[10:32:42.146]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.146]                   }
[10:32:42.146]                 }
[10:32:42.146]                 else {
[10:32:42.146]                   if (TRUE) {
[10:32:42.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.146]                     {
[10:32:42.146]                       inherits <- base::inherits
[10:32:42.146]                       invokeRestart <- base::invokeRestart
[10:32:42.146]                       is.null <- base::is.null
[10:32:42.146]                       muffled <- FALSE
[10:32:42.146]                       if (inherits(cond, "message")) {
[10:32:42.146]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.146]                         if (muffled) 
[10:32:42.146]                           invokeRestart("muffleMessage")
[10:32:42.146]                       }
[10:32:42.146]                       else if (inherits(cond, "warning")) {
[10:32:42.146]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.146]                         if (muffled) 
[10:32:42.146]                           invokeRestart("muffleWarning")
[10:32:42.146]                       }
[10:32:42.146]                       else if (inherits(cond, "condition")) {
[10:32:42.146]                         if (!is.null(pattern)) {
[10:32:42.146]                           computeRestarts <- base::computeRestarts
[10:32:42.146]                           grepl <- base::grepl
[10:32:42.146]                           restarts <- computeRestarts(cond)
[10:32:42.146]                           for (restart in restarts) {
[10:32:42.146]                             name <- restart$name
[10:32:42.146]                             if (is.null(name)) 
[10:32:42.146]                               next
[10:32:42.146]                             if (!grepl(pattern, name)) 
[10:32:42.146]                               next
[10:32:42.146]                             invokeRestart(restart)
[10:32:42.146]                             muffled <- TRUE
[10:32:42.146]                             break
[10:32:42.146]                           }
[10:32:42.146]                         }
[10:32:42.146]                       }
[10:32:42.146]                       invisible(muffled)
[10:32:42.146]                     }
[10:32:42.146]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.146]                   }
[10:32:42.146]                 }
[10:32:42.146]             }
[10:32:42.146]         }))
[10:32:42.146]     }, error = function(ex) {
[10:32:42.146]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.146]                 ...future.rng), started = ...future.startTime, 
[10:32:42.146]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.146]             version = "1.8"), class = "FutureResult")
[10:32:42.146]     }, finally = {
[10:32:42.146]         if (!identical(...future.workdir, getwd())) 
[10:32:42.146]             setwd(...future.workdir)
[10:32:42.146]         {
[10:32:42.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.146]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.146]             }
[10:32:42.146]             base::options(...future.oldOptions)
[10:32:42.146]             if (.Platform$OS.type == "windows") {
[10:32:42.146]                 old_names <- names(...future.oldEnvVars)
[10:32:42.146]                 envs <- base::Sys.getenv()
[10:32:42.146]                 names <- names(envs)
[10:32:42.146]                 common <- intersect(names, old_names)
[10:32:42.146]                 added <- setdiff(names, old_names)
[10:32:42.146]                 removed <- setdiff(old_names, names)
[10:32:42.146]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.146]                   envs[common]]
[10:32:42.146]                 NAMES <- toupper(changed)
[10:32:42.146]                 args <- list()
[10:32:42.146]                 for (kk in seq_along(NAMES)) {
[10:32:42.146]                   name <- changed[[kk]]
[10:32:42.146]                   NAME <- NAMES[[kk]]
[10:32:42.146]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.146]                     next
[10:32:42.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.146]                 }
[10:32:42.146]                 NAMES <- toupper(added)
[10:32:42.146]                 for (kk in seq_along(NAMES)) {
[10:32:42.146]                   name <- added[[kk]]
[10:32:42.146]                   NAME <- NAMES[[kk]]
[10:32:42.146]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.146]                     next
[10:32:42.146]                   args[[name]] <- ""
[10:32:42.146]                 }
[10:32:42.146]                 NAMES <- toupper(removed)
[10:32:42.146]                 for (kk in seq_along(NAMES)) {
[10:32:42.146]                   name <- removed[[kk]]
[10:32:42.146]                   NAME <- NAMES[[kk]]
[10:32:42.146]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.146]                     next
[10:32:42.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.146]                 }
[10:32:42.146]                 if (length(args) > 0) 
[10:32:42.146]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.146]             }
[10:32:42.146]             else {
[10:32:42.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.146]             }
[10:32:42.146]             {
[10:32:42.146]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.146]                   0L) {
[10:32:42.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.146]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.146]                   base::options(opts)
[10:32:42.146]                 }
[10:32:42.146]                 {
[10:32:42.146]                   {
[10:32:42.146]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.146]                     NULL
[10:32:42.146]                   }
[10:32:42.146]                   options(future.plan = NULL)
[10:32:42.146]                   if (is.na(NA_character_)) 
[10:32:42.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.146]                     .init = FALSE)
[10:32:42.146]                 }
[10:32:42.146]             }
[10:32:42.146]         }
[10:32:42.146]     })
[10:32:42.146]     if (TRUE) {
[10:32:42.146]         base::sink(type = "output", split = FALSE)
[10:32:42.146]         if (TRUE) {
[10:32:42.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.146]         }
[10:32:42.146]         else {
[10:32:42.146]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.146]         }
[10:32:42.146]         base::close(...future.stdout)
[10:32:42.146]         ...future.stdout <- NULL
[10:32:42.146]     }
[10:32:42.146]     ...future.result$conditions <- ...future.conditions
[10:32:42.146]     ...future.result$finished <- base::Sys.time()
[10:32:42.146]     ...future.result
[10:32:42.146] }
[10:32:42.149] assign_globals() ...
[10:32:42.149] List of 1
[10:32:42.149]  $ ii: int 2
[10:32:42.149]  - attr(*, "where")=List of 1
[10:32:42.149]   ..$ ii:<environment: R_EmptyEnv> 
[10:32:42.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:42.149]  - attr(*, "resolved")= logi FALSE
[10:32:42.149]  - attr(*, "total_size")= num 56
[10:32:42.149]  - attr(*, "already-done")= logi TRUE
[10:32:42.153] - copied ‘ii’ to environment
[10:32:42.153] assign_globals() ... done
[10:32:42.154] requestCore(): workers = 2
[10:32:42.156] MulticoreFuture started
[10:32:42.156] - Launch lazy future ... done
[10:32:42.156] run() for ‘MulticoreFuture’ ... done
[10:32:42.157] plan(): Setting new future strategy stack:
[10:32:42.157] getGlobalsAndPackages() ...
[10:32:42.157] Searching for globals...
[10:32:42.157] List of future strategies:
[10:32:42.157] 1. sequential:
[10:32:42.157]    - args: function (..., envir = parent.frame())
[10:32:42.157]    - tweaked: FALSE
[10:32:42.157]    - call: NULL
[10:32:42.158] plan(): nbrOfWorkers() = 1
[10:32:42.160] plan(): Setting new future strategy stack:
[10:32:42.160] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:42.160] List of future strategies:
[10:32:42.160] 1. multicore:
[10:32:42.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.160]    - tweaked: FALSE
[10:32:42.160]    - call: plan(strategy)
[10:32:42.161] Searching for globals ... DONE
[10:32:42.161] Resolving globals: FALSE
[10:32:42.162] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:42.162] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:42.165] plan(): nbrOfWorkers() = 2
[10:32:42.166] - globals: [1] ‘ii’
[10:32:42.167] 
[10:32:42.167] getGlobalsAndPackages() ... DONE
[10:32:42.167] run() for ‘Future’ ...
[10:32:42.168] - state: ‘created’
[10:32:42.168] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.173] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.173]   - Field: ‘label’
[10:32:42.174]   - Field: ‘local’
[10:32:42.174]   - Field: ‘owner’
[10:32:42.174]   - Field: ‘envir’
[10:32:42.174]   - Field: ‘workers’
[10:32:42.174]   - Field: ‘packages’
[10:32:42.175]   - Field: ‘gc’
[10:32:42.175]   - Field: ‘job’
[10:32:42.175]   - Field: ‘conditions’
[10:32:42.175]   - Field: ‘expr’
[10:32:42.175]   - Field: ‘uuid’
[10:32:42.175]   - Field: ‘seed’
[10:32:42.176]   - Field: ‘version’
[10:32:42.176]   - Field: ‘result’
[10:32:42.176]   - Field: ‘asynchronous’
[10:32:42.176]   - Field: ‘calls’
[10:32:42.176]   - Field: ‘globals’
[10:32:42.176]   - Field: ‘stdout’
[10:32:42.177]   - Field: ‘earlySignal’
[10:32:42.177]   - Field: ‘lazy’
[10:32:42.177]   - Field: ‘state’
[10:32:42.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.177] - Launch lazy future ...
[10:32:42.178] Packages needed by the future expression (n = 0): <none>
[10:32:42.178] Packages needed by future strategies (n = 0): <none>
[10:32:42.179] {
[10:32:42.179]     {
[10:32:42.179]         {
[10:32:42.179]             ...future.startTime <- base::Sys.time()
[10:32:42.179]             {
[10:32:42.179]                 {
[10:32:42.179]                   {
[10:32:42.179]                     {
[10:32:42.179]                       base::local({
[10:32:42.179]                         has_future <- base::requireNamespace("future", 
[10:32:42.179]                           quietly = TRUE)
[10:32:42.179]                         if (has_future) {
[10:32:42.179]                           ns <- base::getNamespace("future")
[10:32:42.179]                           version <- ns[[".package"]][["version"]]
[10:32:42.179]                           if (is.null(version)) 
[10:32:42.179]                             version <- utils::packageVersion("future")
[10:32:42.179]                         }
[10:32:42.179]                         else {
[10:32:42.179]                           version <- NULL
[10:32:42.179]                         }
[10:32:42.179]                         if (!has_future || version < "1.8.0") {
[10:32:42.179]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.179]                             "", base::R.version$version.string), 
[10:32:42.179]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.179]                               "release", "version")], collapse = " "), 
[10:32:42.179]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.179]                             info)
[10:32:42.179]                           info <- base::paste(info, collapse = "; ")
[10:32:42.179]                           if (!has_future) {
[10:32:42.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.179]                               info)
[10:32:42.179]                           }
[10:32:42.179]                           else {
[10:32:42.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.179]                               info, version)
[10:32:42.179]                           }
[10:32:42.179]                           base::stop(msg)
[10:32:42.179]                         }
[10:32:42.179]                       })
[10:32:42.179]                     }
[10:32:42.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.179]                     base::options(mc.cores = 1L)
[10:32:42.179]                   }
[10:32:42.179]                   ...future.strategy.old <- future::plan("list")
[10:32:42.179]                   options(future.plan = NULL)
[10:32:42.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.179]                 }
[10:32:42.179]                 ...future.workdir <- getwd()
[10:32:42.179]             }
[10:32:42.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.179]         }
[10:32:42.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.179]             base::names(...future.oldOptions))
[10:32:42.179]     }
[10:32:42.179]     if (FALSE) {
[10:32:42.179]     }
[10:32:42.179]     else {
[10:32:42.179]         if (TRUE) {
[10:32:42.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.179]                 open = "w")
[10:32:42.179]         }
[10:32:42.179]         else {
[10:32:42.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.179]         }
[10:32:42.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.179]             base::sink(type = "output", split = FALSE)
[10:32:42.179]             base::close(...future.stdout)
[10:32:42.179]         }, add = TRUE)
[10:32:42.179]     }
[10:32:42.179]     ...future.frame <- base::sys.nframe()
[10:32:42.179]     ...future.conditions <- base::list()
[10:32:42.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.179]     if (FALSE) {
[10:32:42.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.179]     }
[10:32:42.179]     ...future.result <- base::tryCatch({
[10:32:42.179]         base::withCallingHandlers({
[10:32:42.179]             ...future.value <- base::withVisible(base::local({
[10:32:42.179]                 withCallingHandlers({
[10:32:42.179]                   {
[10:32:42.179]                     if (ii%%2 == 0) 
[10:32:42.179]                       stop("Woops!")
[10:32:42.179]                     ii
[10:32:42.179]                   }
[10:32:42.179]                 }, immediateCondition = function(cond) {
[10:32:42.179]                   save_rds <- function (object, pathname, ...) 
[10:32:42.179]                   {
[10:32:42.179]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.179]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.179]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.179]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.179]                         fi_tmp[["mtime"]])
[10:32:42.179]                     }
[10:32:42.179]                     tryCatch({
[10:32:42.179]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.179]                     }, error = function(ex) {
[10:32:42.179]                       msg <- conditionMessage(ex)
[10:32:42.179]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.179]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.179]                         fi_tmp[["mtime"]], msg)
[10:32:42.179]                       ex$message <- msg
[10:32:42.179]                       stop(ex)
[10:32:42.179]                     })
[10:32:42.179]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.179]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.179]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.179]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.179]                       fi <- file.info(pathname)
[10:32:42.179]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.179]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.179]                         fi[["size"]], fi[["mtime"]])
[10:32:42.179]                       stop(msg)
[10:32:42.179]                     }
[10:32:42.179]                     invisible(pathname)
[10:32:42.179]                   }
[10:32:42.179]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.179]                     rootPath = tempdir()) 
[10:32:42.179]                   {
[10:32:42.179]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.179]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.179]                       tmpdir = path, fileext = ".rds")
[10:32:42.179]                     save_rds(obj, file)
[10:32:42.179]                   }
[10:32:42.179]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.179]                   {
[10:32:42.179]                     inherits <- base::inherits
[10:32:42.179]                     invokeRestart <- base::invokeRestart
[10:32:42.179]                     is.null <- base::is.null
[10:32:42.179]                     muffled <- FALSE
[10:32:42.179]                     if (inherits(cond, "message")) {
[10:32:42.179]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.179]                       if (muffled) 
[10:32:42.179]                         invokeRestart("muffleMessage")
[10:32:42.179]                     }
[10:32:42.179]                     else if (inherits(cond, "warning")) {
[10:32:42.179]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.179]                       if (muffled) 
[10:32:42.179]                         invokeRestart("muffleWarning")
[10:32:42.179]                     }
[10:32:42.179]                     else if (inherits(cond, "condition")) {
[10:32:42.179]                       if (!is.null(pattern)) {
[10:32:42.179]                         computeRestarts <- base::computeRestarts
[10:32:42.179]                         grepl <- base::grepl
[10:32:42.179]                         restarts <- computeRestarts(cond)
[10:32:42.179]                         for (restart in restarts) {
[10:32:42.179]                           name <- restart$name
[10:32:42.179]                           if (is.null(name)) 
[10:32:42.179]                             next
[10:32:42.179]                           if (!grepl(pattern, name)) 
[10:32:42.179]                             next
[10:32:42.179]                           invokeRestart(restart)
[10:32:42.179]                           muffled <- TRUE
[10:32:42.179]                           break
[10:32:42.179]                         }
[10:32:42.179]                       }
[10:32:42.179]                     }
[10:32:42.179]                     invisible(muffled)
[10:32:42.179]                   }
[10:32:42.179]                   muffleCondition(cond)
[10:32:42.179]                 })
[10:32:42.179]             }))
[10:32:42.179]             future::FutureResult(value = ...future.value$value, 
[10:32:42.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.179]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.179]                     ...future.globalenv.names))
[10:32:42.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.179]         }, condition = base::local({
[10:32:42.179]             c <- base::c
[10:32:42.179]             inherits <- base::inherits
[10:32:42.179]             invokeRestart <- base::invokeRestart
[10:32:42.179]             length <- base::length
[10:32:42.179]             list <- base::list
[10:32:42.179]             seq.int <- base::seq.int
[10:32:42.179]             signalCondition <- base::signalCondition
[10:32:42.179]             sys.calls <- base::sys.calls
[10:32:42.179]             `[[` <- base::`[[`
[10:32:42.179]             `+` <- base::`+`
[10:32:42.179]             `<<-` <- base::`<<-`
[10:32:42.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.179]                   3L)]
[10:32:42.179]             }
[10:32:42.179]             function(cond) {
[10:32:42.179]                 is_error <- inherits(cond, "error")
[10:32:42.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.179]                   NULL)
[10:32:42.179]                 if (is_error) {
[10:32:42.179]                   sessionInformation <- function() {
[10:32:42.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.179]                       search = base::search(), system = base::Sys.info())
[10:32:42.179]                   }
[10:32:42.179]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.179]                     cond$call), session = sessionInformation(), 
[10:32:42.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.179]                   signalCondition(cond)
[10:32:42.179]                 }
[10:32:42.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.179]                 "immediateCondition"))) {
[10:32:42.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.179]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.179]                   if (TRUE && !signal) {
[10:32:42.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.179]                     {
[10:32:42.179]                       inherits <- base::inherits
[10:32:42.179]                       invokeRestart <- base::invokeRestart
[10:32:42.179]                       is.null <- base::is.null
[10:32:42.179]                       muffled <- FALSE
[10:32:42.179]                       if (inherits(cond, "message")) {
[10:32:42.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.179]                         if (muffled) 
[10:32:42.179]                           invokeRestart("muffleMessage")
[10:32:42.179]                       }
[10:32:42.179]                       else if (inherits(cond, "warning")) {
[10:32:42.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.179]                         if (muffled) 
[10:32:42.179]                           invokeRestart("muffleWarning")
[10:32:42.179]                       }
[10:32:42.179]                       else if (inherits(cond, "condition")) {
[10:32:42.179]                         if (!is.null(pattern)) {
[10:32:42.179]                           computeRestarts <- base::computeRestarts
[10:32:42.179]                           grepl <- base::grepl
[10:32:42.179]                           restarts <- computeRestarts(cond)
[10:32:42.179]                           for (restart in restarts) {
[10:32:42.179]                             name <- restart$name
[10:32:42.179]                             if (is.null(name)) 
[10:32:42.179]                               next
[10:32:42.179]                             if (!grepl(pattern, name)) 
[10:32:42.179]                               next
[10:32:42.179]                             invokeRestart(restart)
[10:32:42.179]                             muffled <- TRUE
[10:32:42.179]                             break
[10:32:42.179]                           }
[10:32:42.179]                         }
[10:32:42.179]                       }
[10:32:42.179]                       invisible(muffled)
[10:32:42.179]                     }
[10:32:42.179]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.179]                   }
[10:32:42.179]                 }
[10:32:42.179]                 else {
[10:32:42.179]                   if (TRUE) {
[10:32:42.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.179]                     {
[10:32:42.179]                       inherits <- base::inherits
[10:32:42.179]                       invokeRestart <- base::invokeRestart
[10:32:42.179]                       is.null <- base::is.null
[10:32:42.179]                       muffled <- FALSE
[10:32:42.179]                       if (inherits(cond, "message")) {
[10:32:42.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.179]                         if (muffled) 
[10:32:42.179]                           invokeRestart("muffleMessage")
[10:32:42.179]                       }
[10:32:42.179]                       else if (inherits(cond, "warning")) {
[10:32:42.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.179]                         if (muffled) 
[10:32:42.179]                           invokeRestart("muffleWarning")
[10:32:42.179]                       }
[10:32:42.179]                       else if (inherits(cond, "condition")) {
[10:32:42.179]                         if (!is.null(pattern)) {
[10:32:42.179]                           computeRestarts <- base::computeRestarts
[10:32:42.179]                           grepl <- base::grepl
[10:32:42.179]                           restarts <- computeRestarts(cond)
[10:32:42.179]                           for (restart in restarts) {
[10:32:42.179]                             name <- restart$name
[10:32:42.179]                             if (is.null(name)) 
[10:32:42.179]                               next
[10:32:42.179]                             if (!grepl(pattern, name)) 
[10:32:42.179]                               next
[10:32:42.179]                             invokeRestart(restart)
[10:32:42.179]                             muffled <- TRUE
[10:32:42.179]                             break
[10:32:42.179]                           }
[10:32:42.179]                         }
[10:32:42.179]                       }
[10:32:42.179]                       invisible(muffled)
[10:32:42.179]                     }
[10:32:42.179]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.179]                   }
[10:32:42.179]                 }
[10:32:42.179]             }
[10:32:42.179]         }))
[10:32:42.179]     }, error = function(ex) {
[10:32:42.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.179]                 ...future.rng), started = ...future.startTime, 
[10:32:42.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.179]             version = "1.8"), class = "FutureResult")
[10:32:42.179]     }, finally = {
[10:32:42.179]         if (!identical(...future.workdir, getwd())) 
[10:32:42.179]             setwd(...future.workdir)
[10:32:42.179]         {
[10:32:42.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.179]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.179]             }
[10:32:42.179]             base::options(...future.oldOptions)
[10:32:42.179]             if (.Platform$OS.type == "windows") {
[10:32:42.179]                 old_names <- names(...future.oldEnvVars)
[10:32:42.179]                 envs <- base::Sys.getenv()
[10:32:42.179]                 names <- names(envs)
[10:32:42.179]                 common <- intersect(names, old_names)
[10:32:42.179]                 added <- setdiff(names, old_names)
[10:32:42.179]                 removed <- setdiff(old_names, names)
[10:32:42.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.179]                   envs[common]]
[10:32:42.179]                 NAMES <- toupper(changed)
[10:32:42.179]                 args <- list()
[10:32:42.179]                 for (kk in seq_along(NAMES)) {
[10:32:42.179]                   name <- changed[[kk]]
[10:32:42.179]                   NAME <- NAMES[[kk]]
[10:32:42.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.179]                     next
[10:32:42.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.179]                 }
[10:32:42.179]                 NAMES <- toupper(added)
[10:32:42.179]                 for (kk in seq_along(NAMES)) {
[10:32:42.179]                   name <- added[[kk]]
[10:32:42.179]                   NAME <- NAMES[[kk]]
[10:32:42.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.179]                     next
[10:32:42.179]                   args[[name]] <- ""
[10:32:42.179]                 }
[10:32:42.179]                 NAMES <- toupper(removed)
[10:32:42.179]                 for (kk in seq_along(NAMES)) {
[10:32:42.179]                   name <- removed[[kk]]
[10:32:42.179]                   NAME <- NAMES[[kk]]
[10:32:42.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.179]                     next
[10:32:42.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.179]                 }
[10:32:42.179]                 if (length(args) > 0) 
[10:32:42.179]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.179]             }
[10:32:42.179]             else {
[10:32:42.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.179]             }
[10:32:42.179]             {
[10:32:42.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.179]                   0L) {
[10:32:42.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.179]                   base::options(opts)
[10:32:42.179]                 }
[10:32:42.179]                 {
[10:32:42.179]                   {
[10:32:42.179]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.179]                     NULL
[10:32:42.179]                   }
[10:32:42.179]                   options(future.plan = NULL)
[10:32:42.179]                   if (is.na(NA_character_)) 
[10:32:42.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.179]                     .init = FALSE)
[10:32:42.179]                 }
[10:32:42.179]             }
[10:32:42.179]         }
[10:32:42.179]     })
[10:32:42.179]     if (TRUE) {
[10:32:42.179]         base::sink(type = "output", split = FALSE)
[10:32:42.179]         if (TRUE) {
[10:32:42.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.179]         }
[10:32:42.179]         else {
[10:32:42.179]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.179]         }
[10:32:42.179]         base::close(...future.stdout)
[10:32:42.179]         ...future.stdout <- NULL
[10:32:42.179]     }
[10:32:42.179]     ...future.result$conditions <- ...future.conditions
[10:32:42.179]     ...future.result$finished <- base::Sys.time()
[10:32:42.179]     ...future.result
[10:32:42.179] }
[10:32:42.181] assign_globals() ...
[10:32:42.181] List of 1
[10:32:42.181]  $ ii: int 3
[10:32:42.181]  - attr(*, "where")=List of 1
[10:32:42.181]   ..$ ii:<environment: R_EmptyEnv> 
[10:32:42.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:42.181]  - attr(*, "resolved")= logi FALSE
[10:32:42.181]  - attr(*, "total_size")= num 56
[10:32:42.181]  - attr(*, "already-done")= logi TRUE
[10:32:42.185] - copied ‘ii’ to environment
[10:32:42.185] assign_globals() ... done
[10:32:42.186] requestCore(): workers = 2
[10:32:42.186] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:42.197] result() for MulticoreFuture ...
[10:32:42.198] result() for MulticoreFuture ...
[10:32:42.198] result() for MulticoreFuture ... done
[10:32:42.198] result() for MulticoreFuture ... done
[10:32:42.199] result() for MulticoreFuture ...
[10:32:42.199] result() for MulticoreFuture ... done
[10:32:42.202] MulticoreFuture started
[10:32:42.202] - Launch lazy future ... done
[10:32:42.203] run() for ‘MulticoreFuture’ ... done
[10:32:42.203] plan(): Setting new future strategy stack:
[10:32:42.203] result() for MulticoreFuture ...
[10:32:42.203] result() for MulticoreFuture ... done
[10:32:42.204] result() for MulticoreFuture ...
[10:32:42.204] result() for MulticoreFuture ... done
[10:32:42.203] List of future strategies:
[10:32:42.203] 1. sequential:
[10:32:42.203]    - args: function (..., envir = parent.frame())
[10:32:42.203]    - tweaked: FALSE
[10:32:42.203]    - call: NULL
[10:32:42.204] result() for MulticoreFuture ...
[10:32:42.204] plan(): nbrOfWorkers() = 1
[10:32:42.206] plan(): Setting new future strategy stack:
[10:32:42.206] List of future strategies:
[10:32:42.206] 1. multicore:
[10:32:42.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.206]    - tweaked: FALSE
[10:32:42.206]    - call: plan(strategy)
[10:32:42.208] result() for MulticoreFuture ...
[10:32:42.208] result() for MulticoreFuture ... done
[10:32:42.208] signalConditions() ...
[10:32:42.208]  - include = ‘immediateCondition’
[10:32:42.209]  - exclude = 
[10:32:42.209]  - resignal = FALSE
[10:32:42.209]  - Number of conditions: 1
[10:32:42.209] signalConditions() ... done
[10:32:42.209] result() for MulticoreFuture ... done
[10:32:42.209] result() for MulticoreFuture ...
[10:32:42.210] result() for MulticoreFuture ... done
[10:32:42.210] signalConditions() ...
[10:32:42.210]  - include = ‘immediateCondition’
[10:32:42.210]  - exclude = 
[10:32:42.210]  - resignal = FALSE
[10:32:42.211]  - Number of conditions: 1
[10:32:42.211] signalConditions() ... done
[10:32:42.211] Future state: ‘finished’
[10:32:42.211] result() for MulticoreFuture ...
[10:32:42.211] result() for MulticoreFuture ... done
[10:32:42.211] signalConditions() ...
[10:32:42.211] plan(): nbrOfWorkers() = 2
[10:32:42.212]  - include = ‘condition’
[10:32:42.212]  - exclude = ‘immediateCondition’
[10:32:42.212]  - resignal = TRUE
[10:32:42.212]  - Number of conditions: 1
[10:32:42.212]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:42.212] signalConditions() ... done
[10:32:42.213] result() for MulticoreFuture ...
[10:32:42.214] result() for MulticoreFuture ...
[10:32:42.214] result() for MulticoreFuture ... done
[10:32:42.214] result() for MulticoreFuture ... done
[10:32:42.214] result() for MulticoreFuture ...
[10:32:42.214] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:32:42.215] result() for MulticoreFuture ...
[10:32:42.215] result() for MulticoreFuture ... done
[10:32:42.215] result() for MulticoreFuture ...
[10:32:42.215] result() for MulticoreFuture ... done
[10:32:42.215] signalConditions() ...
[10:32:42.215]  - include = ‘immediateCondition’
[10:32:42.215]  - exclude = 
[10:32:42.216]  - resignal = FALSE
[10:32:42.216]  - Number of conditions: 1
[10:32:42.216] signalConditions() ... done
[10:32:42.216] Future state: ‘finished’
[10:32:42.216] result() for MulticoreFuture ...
[10:32:42.216] result() for MulticoreFuture ... done
[10:32:42.216] signalConditions() ...
[10:32:42.216]  - include = ‘condition’
[10:32:42.216]  - exclude = ‘immediateCondition’
[10:32:42.217]  - resignal = TRUE
[10:32:42.217]  - Number of conditions: 1
[10:32:42.217]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:42.217] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:32:42.217] result() for MulticoreFuture ...
[10:32:42.218] result() for MulticoreFuture ... done
[10:32:42.218] result() for MulticoreFuture ...
[10:32:42.218] result() for MulticoreFuture ... done
[10:32:42.218] signalConditions() ...
[10:32:42.218]  - include = ‘immediateCondition’
[10:32:42.218]  - exclude = 
[10:32:42.218]  - resignal = FALSE
[10:32:42.218]  - Number of conditions: 1
[10:32:42.218] signalConditions() ... done
[10:32:42.219] Future state: ‘finished’
[10:32:42.219] result() for MulticoreFuture ...
[10:32:42.219] result() for MulticoreFuture ... done
[10:32:42.219] signalConditions() ...
[10:32:42.219]  - include = ‘condition’
[10:32:42.219]  - exclude = ‘immediateCondition’
[10:32:42.219]  - resignal = TRUE
[10:32:42.222]  - Number of conditions: 1
[10:32:42.222]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:42.222] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[10:32:42.223] getGlobalsAndPackages() ...
[10:32:42.223] Searching for globals...
[10:32:42.226] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[10:32:42.226] Searching for globals ... DONE
[10:32:42.226] Resolving globals: FALSE
[10:32:42.227] 
[10:32:42.227] 
[10:32:42.227] getGlobalsAndPackages() ... DONE
[10:32:42.227] run() for ‘Future’ ...
[10:32:42.227] - state: ‘created’
[10:32:42.228] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.232] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.232]   - Field: ‘label’
[10:32:42.232]   - Field: ‘local’
[10:32:42.232]   - Field: ‘owner’
[10:32:42.232]   - Field: ‘envir’
[10:32:42.232]   - Field: ‘workers’
[10:32:42.233]   - Field: ‘packages’
[10:32:42.233]   - Field: ‘gc’
[10:32:42.233]   - Field: ‘job’
[10:32:42.233]   - Field: ‘conditions’
[10:32:42.233]   - Field: ‘expr’
[10:32:42.233]   - Field: ‘uuid’
[10:32:42.233]   - Field: ‘seed’
[10:32:42.233]   - Field: ‘version’
[10:32:42.234]   - Field: ‘result’
[10:32:42.234]   - Field: ‘asynchronous’
[10:32:42.234]   - Field: ‘calls’
[10:32:42.234]   - Field: ‘globals’
[10:32:42.234]   - Field: ‘stdout’
[10:32:42.234]   - Field: ‘earlySignal’
[10:32:42.234]   - Field: ‘lazy’
[10:32:42.234]   - Field: ‘state’
[10:32:42.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.235] - Launch lazy future ...
[10:32:42.235] Packages needed by the future expression (n = 0): <none>
[10:32:42.235] Packages needed by future strategies (n = 0): <none>
[10:32:42.236] {
[10:32:42.236]     {
[10:32:42.236]         {
[10:32:42.236]             ...future.startTime <- base::Sys.time()
[10:32:42.236]             {
[10:32:42.236]                 {
[10:32:42.236]                   {
[10:32:42.236]                     {
[10:32:42.236]                       base::local({
[10:32:42.236]                         has_future <- base::requireNamespace("future", 
[10:32:42.236]                           quietly = TRUE)
[10:32:42.236]                         if (has_future) {
[10:32:42.236]                           ns <- base::getNamespace("future")
[10:32:42.236]                           version <- ns[[".package"]][["version"]]
[10:32:42.236]                           if (is.null(version)) 
[10:32:42.236]                             version <- utils::packageVersion("future")
[10:32:42.236]                         }
[10:32:42.236]                         else {
[10:32:42.236]                           version <- NULL
[10:32:42.236]                         }
[10:32:42.236]                         if (!has_future || version < "1.8.0") {
[10:32:42.236]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.236]                             "", base::R.version$version.string), 
[10:32:42.236]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.236]                               "release", "version")], collapse = " "), 
[10:32:42.236]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.236]                             info)
[10:32:42.236]                           info <- base::paste(info, collapse = "; ")
[10:32:42.236]                           if (!has_future) {
[10:32:42.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.236]                               info)
[10:32:42.236]                           }
[10:32:42.236]                           else {
[10:32:42.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.236]                               info, version)
[10:32:42.236]                           }
[10:32:42.236]                           base::stop(msg)
[10:32:42.236]                         }
[10:32:42.236]                       })
[10:32:42.236]                     }
[10:32:42.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.236]                     base::options(mc.cores = 1L)
[10:32:42.236]                   }
[10:32:42.236]                   ...future.strategy.old <- future::plan("list")
[10:32:42.236]                   options(future.plan = NULL)
[10:32:42.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.236]                 }
[10:32:42.236]                 ...future.workdir <- getwd()
[10:32:42.236]             }
[10:32:42.236]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.236]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.236]         }
[10:32:42.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.236]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.236]             base::names(...future.oldOptions))
[10:32:42.236]     }
[10:32:42.236]     if (FALSE) {
[10:32:42.236]     }
[10:32:42.236]     else {
[10:32:42.236]         if (TRUE) {
[10:32:42.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.236]                 open = "w")
[10:32:42.236]         }
[10:32:42.236]         else {
[10:32:42.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.236]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.236]         }
[10:32:42.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.236]             base::sink(type = "output", split = FALSE)
[10:32:42.236]             base::close(...future.stdout)
[10:32:42.236]         }, add = TRUE)
[10:32:42.236]     }
[10:32:42.236]     ...future.frame <- base::sys.nframe()
[10:32:42.236]     ...future.conditions <- base::list()
[10:32:42.236]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.236]     if (FALSE) {
[10:32:42.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.236]     }
[10:32:42.236]     ...future.result <- base::tryCatch({
[10:32:42.236]         base::withCallingHandlers({
[10:32:42.236]             ...future.value <- base::withVisible(base::local({
[10:32:42.236]                 withCallingHandlers({
[10:32:42.236]                   {
[10:32:42.236]                     cat("Processing: ")
[10:32:42.236]                     for (ii in 1:10) {
[10:32:42.236]                       cat(".")
[10:32:42.236]                     }
[10:32:42.236]                     cat(" [100%]\n")
[10:32:42.236]                     4
[10:32:42.236]                   }
[10:32:42.236]                 }, immediateCondition = function(cond) {
[10:32:42.236]                   save_rds <- function (object, pathname, ...) 
[10:32:42.236]                   {
[10:32:42.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.236]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.236]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.236]                         fi_tmp[["mtime"]])
[10:32:42.236]                     }
[10:32:42.236]                     tryCatch({
[10:32:42.236]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.236]                     }, error = function(ex) {
[10:32:42.236]                       msg <- conditionMessage(ex)
[10:32:42.236]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.236]                         fi_tmp[["mtime"]], msg)
[10:32:42.236]                       ex$message <- msg
[10:32:42.236]                       stop(ex)
[10:32:42.236]                     })
[10:32:42.236]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.236]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.236]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.236]                       fi <- file.info(pathname)
[10:32:42.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.236]                         fi[["size"]], fi[["mtime"]])
[10:32:42.236]                       stop(msg)
[10:32:42.236]                     }
[10:32:42.236]                     invisible(pathname)
[10:32:42.236]                   }
[10:32:42.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.236]                     rootPath = tempdir()) 
[10:32:42.236]                   {
[10:32:42.236]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.236]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.236]                       tmpdir = path, fileext = ".rds")
[10:32:42.236]                     save_rds(obj, file)
[10:32:42.236]                   }
[10:32:42.236]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.236]                   {
[10:32:42.236]                     inherits <- base::inherits
[10:32:42.236]                     invokeRestart <- base::invokeRestart
[10:32:42.236]                     is.null <- base::is.null
[10:32:42.236]                     muffled <- FALSE
[10:32:42.236]                     if (inherits(cond, "message")) {
[10:32:42.236]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.236]                       if (muffled) 
[10:32:42.236]                         invokeRestart("muffleMessage")
[10:32:42.236]                     }
[10:32:42.236]                     else if (inherits(cond, "warning")) {
[10:32:42.236]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.236]                       if (muffled) 
[10:32:42.236]                         invokeRestart("muffleWarning")
[10:32:42.236]                     }
[10:32:42.236]                     else if (inherits(cond, "condition")) {
[10:32:42.236]                       if (!is.null(pattern)) {
[10:32:42.236]                         computeRestarts <- base::computeRestarts
[10:32:42.236]                         grepl <- base::grepl
[10:32:42.236]                         restarts <- computeRestarts(cond)
[10:32:42.236]                         for (restart in restarts) {
[10:32:42.236]                           name <- restart$name
[10:32:42.236]                           if (is.null(name)) 
[10:32:42.236]                             next
[10:32:42.236]                           if (!grepl(pattern, name)) 
[10:32:42.236]                             next
[10:32:42.236]                           invokeRestart(restart)
[10:32:42.236]                           muffled <- TRUE
[10:32:42.236]                           break
[10:32:42.236]                         }
[10:32:42.236]                       }
[10:32:42.236]                     }
[10:32:42.236]                     invisible(muffled)
[10:32:42.236]                   }
[10:32:42.236]                   muffleCondition(cond)
[10:32:42.236]                 })
[10:32:42.236]             }))
[10:32:42.236]             future::FutureResult(value = ...future.value$value, 
[10:32:42.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.236]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.236]                     ...future.globalenv.names))
[10:32:42.236]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.236]         }, condition = base::local({
[10:32:42.236]             c <- base::c
[10:32:42.236]             inherits <- base::inherits
[10:32:42.236]             invokeRestart <- base::invokeRestart
[10:32:42.236]             length <- base::length
[10:32:42.236]             list <- base::list
[10:32:42.236]             seq.int <- base::seq.int
[10:32:42.236]             signalCondition <- base::signalCondition
[10:32:42.236]             sys.calls <- base::sys.calls
[10:32:42.236]             `[[` <- base::`[[`
[10:32:42.236]             `+` <- base::`+`
[10:32:42.236]             `<<-` <- base::`<<-`
[10:32:42.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.236]                   3L)]
[10:32:42.236]             }
[10:32:42.236]             function(cond) {
[10:32:42.236]                 is_error <- inherits(cond, "error")
[10:32:42.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.236]                   NULL)
[10:32:42.236]                 if (is_error) {
[10:32:42.236]                   sessionInformation <- function() {
[10:32:42.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.236]                       search = base::search(), system = base::Sys.info())
[10:32:42.236]                   }
[10:32:42.236]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.236]                     cond$call), session = sessionInformation(), 
[10:32:42.236]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.236]                   signalCondition(cond)
[10:32:42.236]                 }
[10:32:42.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.236]                 "immediateCondition"))) {
[10:32:42.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.236]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.236]                   if (TRUE && !signal) {
[10:32:42.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.236]                     {
[10:32:42.236]                       inherits <- base::inherits
[10:32:42.236]                       invokeRestart <- base::invokeRestart
[10:32:42.236]                       is.null <- base::is.null
[10:32:42.236]                       muffled <- FALSE
[10:32:42.236]                       if (inherits(cond, "message")) {
[10:32:42.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.236]                         if (muffled) 
[10:32:42.236]                           invokeRestart("muffleMessage")
[10:32:42.236]                       }
[10:32:42.236]                       else if (inherits(cond, "warning")) {
[10:32:42.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.236]                         if (muffled) 
[10:32:42.236]                           invokeRestart("muffleWarning")
[10:32:42.236]                       }
[10:32:42.236]                       else if (inherits(cond, "condition")) {
[10:32:42.236]                         if (!is.null(pattern)) {
[10:32:42.236]                           computeRestarts <- base::computeRestarts
[10:32:42.236]                           grepl <- base::grepl
[10:32:42.236]                           restarts <- computeRestarts(cond)
[10:32:42.236]                           for (restart in restarts) {
[10:32:42.236]                             name <- restart$name
[10:32:42.236]                             if (is.null(name)) 
[10:32:42.236]                               next
[10:32:42.236]                             if (!grepl(pattern, name)) 
[10:32:42.236]                               next
[10:32:42.236]                             invokeRestart(restart)
[10:32:42.236]                             muffled <- TRUE
[10:32:42.236]                             break
[10:32:42.236]                           }
[10:32:42.236]                         }
[10:32:42.236]                       }
[10:32:42.236]                       invisible(muffled)
[10:32:42.236]                     }
[10:32:42.236]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.236]                   }
[10:32:42.236]                 }
[10:32:42.236]                 else {
[10:32:42.236]                   if (TRUE) {
[10:32:42.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.236]                     {
[10:32:42.236]                       inherits <- base::inherits
[10:32:42.236]                       invokeRestart <- base::invokeRestart
[10:32:42.236]                       is.null <- base::is.null
[10:32:42.236]                       muffled <- FALSE
[10:32:42.236]                       if (inherits(cond, "message")) {
[10:32:42.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.236]                         if (muffled) 
[10:32:42.236]                           invokeRestart("muffleMessage")
[10:32:42.236]                       }
[10:32:42.236]                       else if (inherits(cond, "warning")) {
[10:32:42.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.236]                         if (muffled) 
[10:32:42.236]                           invokeRestart("muffleWarning")
[10:32:42.236]                       }
[10:32:42.236]                       else if (inherits(cond, "condition")) {
[10:32:42.236]                         if (!is.null(pattern)) {
[10:32:42.236]                           computeRestarts <- base::computeRestarts
[10:32:42.236]                           grepl <- base::grepl
[10:32:42.236]                           restarts <- computeRestarts(cond)
[10:32:42.236]                           for (restart in restarts) {
[10:32:42.236]                             name <- restart$name
[10:32:42.236]                             if (is.null(name)) 
[10:32:42.236]                               next
[10:32:42.236]                             if (!grepl(pattern, name)) 
[10:32:42.236]                               next
[10:32:42.236]                             invokeRestart(restart)
[10:32:42.236]                             muffled <- TRUE
[10:32:42.236]                             break
[10:32:42.236]                           }
[10:32:42.236]                         }
[10:32:42.236]                       }
[10:32:42.236]                       invisible(muffled)
[10:32:42.236]                     }
[10:32:42.236]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.236]                   }
[10:32:42.236]                 }
[10:32:42.236]             }
[10:32:42.236]         }))
[10:32:42.236]     }, error = function(ex) {
[10:32:42.236]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.236]                 ...future.rng), started = ...future.startTime, 
[10:32:42.236]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.236]             version = "1.8"), class = "FutureResult")
[10:32:42.236]     }, finally = {
[10:32:42.236]         if (!identical(...future.workdir, getwd())) 
[10:32:42.236]             setwd(...future.workdir)
[10:32:42.236]         {
[10:32:42.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.236]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.236]             }
[10:32:42.236]             base::options(...future.oldOptions)
[10:32:42.236]             if (.Platform$OS.type == "windows") {
[10:32:42.236]                 old_names <- names(...future.oldEnvVars)
[10:32:42.236]                 envs <- base::Sys.getenv()
[10:32:42.236]                 names <- names(envs)
[10:32:42.236]                 common <- intersect(names, old_names)
[10:32:42.236]                 added <- setdiff(names, old_names)
[10:32:42.236]                 removed <- setdiff(old_names, names)
[10:32:42.236]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.236]                   envs[common]]
[10:32:42.236]                 NAMES <- toupper(changed)
[10:32:42.236]                 args <- list()
[10:32:42.236]                 for (kk in seq_along(NAMES)) {
[10:32:42.236]                   name <- changed[[kk]]
[10:32:42.236]                   NAME <- NAMES[[kk]]
[10:32:42.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.236]                     next
[10:32:42.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.236]                 }
[10:32:42.236]                 NAMES <- toupper(added)
[10:32:42.236]                 for (kk in seq_along(NAMES)) {
[10:32:42.236]                   name <- added[[kk]]
[10:32:42.236]                   NAME <- NAMES[[kk]]
[10:32:42.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.236]                     next
[10:32:42.236]                   args[[name]] <- ""
[10:32:42.236]                 }
[10:32:42.236]                 NAMES <- toupper(removed)
[10:32:42.236]                 for (kk in seq_along(NAMES)) {
[10:32:42.236]                   name <- removed[[kk]]
[10:32:42.236]                   NAME <- NAMES[[kk]]
[10:32:42.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.236]                     next
[10:32:42.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.236]                 }
[10:32:42.236]                 if (length(args) > 0) 
[10:32:42.236]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.236]             }
[10:32:42.236]             else {
[10:32:42.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.236]             }
[10:32:42.236]             {
[10:32:42.236]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.236]                   0L) {
[10:32:42.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.236]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.236]                   base::options(opts)
[10:32:42.236]                 }
[10:32:42.236]                 {
[10:32:42.236]                   {
[10:32:42.236]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.236]                     NULL
[10:32:42.236]                   }
[10:32:42.236]                   options(future.plan = NULL)
[10:32:42.236]                   if (is.na(NA_character_)) 
[10:32:42.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.236]                     .init = FALSE)
[10:32:42.236]                 }
[10:32:42.236]             }
[10:32:42.236]         }
[10:32:42.236]     })
[10:32:42.236]     if (TRUE) {
[10:32:42.236]         base::sink(type = "output", split = FALSE)
[10:32:42.236]         if (TRUE) {
[10:32:42.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.236]         }
[10:32:42.236]         else {
[10:32:42.236]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.236]         }
[10:32:42.236]         base::close(...future.stdout)
[10:32:42.236]         ...future.stdout <- NULL
[10:32:42.236]     }
[10:32:42.236]     ...future.result$conditions <- ...future.conditions
[10:32:42.236]     ...future.result$finished <- base::Sys.time()
[10:32:42.236]     ...future.result
[10:32:42.236] }
[10:32:42.238] requestCore(): workers = 2
[10:32:42.240] MulticoreFuture started
[10:32:42.240] - Launch lazy future ... done
[10:32:42.240] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
[10:32:42.241] plan(): Setting new future strategy stack:
Warning in sprintf(...) : restarting interrupted promise evaluation
[10:32:42.241] result() for MulticoreFuture ...
[10:32:42.241] result() for MulticoreFuture ... done
[10:32:42.242] result() for MulticoreFuture ...
[10:32:42.241] List of future strategies:
[10:32:42.241] 1. sequential:
[10:32:42.241]    - args: function (..., envir = parent.frame())
[10:32:42.241]    - tweaked: FALSE
[10:32:42.241]    - call: NULL
[10:32:42.242] result() for MulticoreFuture ... done
[10:32:42.242] plan(): nbrOfWorkers() = 1
[10:32:42.242] signalConditions() ...
[10:32:42.242]  - include = ‘immediateCondition’
[10:32:42.242]  - exclude = 
[10:32:42.242]  - resignal = FALSE
[10:32:42.243]  - Number of conditions: 1
[10:32:42.243] signalConditions() ... done
[10:32:42.243] Future state: ‘finished’
[10:32:42.243] result() for MulticoreFuture ...
[10:32:42.243] result() for MulticoreFuture ... done
[10:32:42.243] signalConditions() ...
[10:32:42.244]  - include = ‘condition’
[10:32:42.244]  - exclude = ‘immediateCondition’
[10:32:42.244] plan(): Setting new future strategy stack:
[10:32:42.244]  - resignal = TRUE
[10:32:42.244]  - Number of conditions: 1
[10:32:42.244]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:42.244] List of future strategies:
[10:32:42.244] 1. multicore:
[10:32:42.244]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.244]    - tweaked: FALSE
[10:32:42.244]    - call: plan(strategy)
[10:32:42.245] signalConditions() ... done
v3: <simpleError> (as expect)
[10:32:42.245] result() for MulticoreFuture ...
[10:32:42.249] plan(): nbrOfWorkers() = 2
[10:32:42.250] result() for MulticoreFuture ...
[10:32:42.250] result() for MulticoreFuture ... done
[10:32:42.250] result() for MulticoreFuture ... done
[10:32:42.250] result() for MulticoreFuture ...
[10:32:42.250] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[10:32:42.251] getGlobalsAndPackages() ...
[10:32:42.251] Searching for globals...
[10:32:42.252] 
[10:32:42.252] Searching for globals ... DONE
[10:32:42.252] - globals: [0] <none>
[10:32:42.252] getGlobalsAndPackages() ... DONE
[10:32:42.252] run() for ‘Future’ ...
[10:32:42.253] - state: ‘created’
[10:32:42.253] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.257] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.257]   - Field: ‘label’
[10:32:42.257]   - Field: ‘local’
[10:32:42.258]   - Field: ‘owner’
[10:32:42.258]   - Field: ‘envir’
[10:32:42.258]   - Field: ‘workers’
[10:32:42.258]   - Field: ‘packages’
[10:32:42.258]   - Field: ‘gc’
[10:32:42.258]   - Field: ‘job’
[10:32:42.258]   - Field: ‘conditions’
[10:32:42.258]   - Field: ‘expr’
[10:32:42.259]   - Field: ‘uuid’
[10:32:42.259]   - Field: ‘seed’
[10:32:42.259]   - Field: ‘version’
[10:32:42.259]   - Field: ‘result’
[10:32:42.259]   - Field: ‘asynchronous’
[10:32:42.259]   - Field: ‘calls’
[10:32:42.259]   - Field: ‘globals’
[10:32:42.259]   - Field: ‘stdout’
[10:32:42.259]   - Field: ‘earlySignal’
[10:32:42.260]   - Field: ‘lazy’
[10:32:42.260]   - Field: ‘state’
[10:32:42.260] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.260] - Launch lazy future ...
[10:32:42.260] Packages needed by the future expression (n = 0): <none>
[10:32:42.260] Packages needed by future strategies (n = 0): <none>
[10:32:42.261] {
[10:32:42.261]     {
[10:32:42.261]         {
[10:32:42.261]             ...future.startTime <- base::Sys.time()
[10:32:42.261]             {
[10:32:42.261]                 {
[10:32:42.261]                   {
[10:32:42.261]                     {
[10:32:42.261]                       base::local({
[10:32:42.261]                         has_future <- base::requireNamespace("future", 
[10:32:42.261]                           quietly = TRUE)
[10:32:42.261]                         if (has_future) {
[10:32:42.261]                           ns <- base::getNamespace("future")
[10:32:42.261]                           version <- ns[[".package"]][["version"]]
[10:32:42.261]                           if (is.null(version)) 
[10:32:42.261]                             version <- utils::packageVersion("future")
[10:32:42.261]                         }
[10:32:42.261]                         else {
[10:32:42.261]                           version <- NULL
[10:32:42.261]                         }
[10:32:42.261]                         if (!has_future || version < "1.8.0") {
[10:32:42.261]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.261]                             "", base::R.version$version.string), 
[10:32:42.261]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.261]                               "release", "version")], collapse = " "), 
[10:32:42.261]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.261]                             info)
[10:32:42.261]                           info <- base::paste(info, collapse = "; ")
[10:32:42.261]                           if (!has_future) {
[10:32:42.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.261]                               info)
[10:32:42.261]                           }
[10:32:42.261]                           else {
[10:32:42.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.261]                               info, version)
[10:32:42.261]                           }
[10:32:42.261]                           base::stop(msg)
[10:32:42.261]                         }
[10:32:42.261]                       })
[10:32:42.261]                     }
[10:32:42.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.261]                     base::options(mc.cores = 1L)
[10:32:42.261]                   }
[10:32:42.261]                   ...future.strategy.old <- future::plan("list")
[10:32:42.261]                   options(future.plan = NULL)
[10:32:42.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.261]                 }
[10:32:42.261]                 ...future.workdir <- getwd()
[10:32:42.261]             }
[10:32:42.261]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.261]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.261]         }
[10:32:42.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.261]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.261]             base::names(...future.oldOptions))
[10:32:42.261]     }
[10:32:42.261]     if (FALSE) {
[10:32:42.261]     }
[10:32:42.261]     else {
[10:32:42.261]         if (TRUE) {
[10:32:42.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.261]                 open = "w")
[10:32:42.261]         }
[10:32:42.261]         else {
[10:32:42.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.261]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.261]         }
[10:32:42.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.261]             base::sink(type = "output", split = FALSE)
[10:32:42.261]             base::close(...future.stdout)
[10:32:42.261]         }, add = TRUE)
[10:32:42.261]     }
[10:32:42.261]     ...future.frame <- base::sys.nframe()
[10:32:42.261]     ...future.conditions <- base::list()
[10:32:42.261]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.261]     if (FALSE) {
[10:32:42.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.261]     }
[10:32:42.261]     ...future.result <- base::tryCatch({
[10:32:42.261]         base::withCallingHandlers({
[10:32:42.261]             ...future.value <- base::withVisible(base::local({
[10:32:42.261]                 withCallingHandlers({
[10:32:42.261]                   1
[10:32:42.261]                 }, immediateCondition = function(cond) {
[10:32:42.261]                   save_rds <- function (object, pathname, ...) 
[10:32:42.261]                   {
[10:32:42.261]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.261]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.261]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.261]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.261]                         fi_tmp[["mtime"]])
[10:32:42.261]                     }
[10:32:42.261]                     tryCatch({
[10:32:42.261]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.261]                     }, error = function(ex) {
[10:32:42.261]                       msg <- conditionMessage(ex)
[10:32:42.261]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.261]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.261]                         fi_tmp[["mtime"]], msg)
[10:32:42.261]                       ex$message <- msg
[10:32:42.261]                       stop(ex)
[10:32:42.261]                     })
[10:32:42.261]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.261]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.261]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.261]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.261]                       fi <- file.info(pathname)
[10:32:42.261]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.261]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.261]                         fi[["size"]], fi[["mtime"]])
[10:32:42.261]                       stop(msg)
[10:32:42.261]                     }
[10:32:42.261]                     invisible(pathname)
[10:32:42.261]                   }
[10:32:42.261]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.261]                     rootPath = tempdir()) 
[10:32:42.261]                   {
[10:32:42.261]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.261]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.261]                       tmpdir = path, fileext = ".rds")
[10:32:42.261]                     save_rds(obj, file)
[10:32:42.261]                   }
[10:32:42.261]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.261]                   {
[10:32:42.261]                     inherits <- base::inherits
[10:32:42.261]                     invokeRestart <- base::invokeRestart
[10:32:42.261]                     is.null <- base::is.null
[10:32:42.261]                     muffled <- FALSE
[10:32:42.261]                     if (inherits(cond, "message")) {
[10:32:42.261]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.261]                       if (muffled) 
[10:32:42.261]                         invokeRestart("muffleMessage")
[10:32:42.261]                     }
[10:32:42.261]                     else if (inherits(cond, "warning")) {
[10:32:42.261]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.261]                       if (muffled) 
[10:32:42.261]                         invokeRestart("muffleWarning")
[10:32:42.261]                     }
[10:32:42.261]                     else if (inherits(cond, "condition")) {
[10:32:42.261]                       if (!is.null(pattern)) {
[10:32:42.261]                         computeRestarts <- base::computeRestarts
[10:32:42.261]                         grepl <- base::grepl
[10:32:42.261]                         restarts <- computeRestarts(cond)
[10:32:42.261]                         for (restart in restarts) {
[10:32:42.261]                           name <- restart$name
[10:32:42.261]                           if (is.null(name)) 
[10:32:42.261]                             next
[10:32:42.261]                           if (!grepl(pattern, name)) 
[10:32:42.261]                             next
[10:32:42.261]                           invokeRestart(restart)
[10:32:42.261]                           muffled <- TRUE
[10:32:42.261]                           break
[10:32:42.261]                         }
[10:32:42.261]                       }
[10:32:42.261]                     }
[10:32:42.261]                     invisible(muffled)
[10:32:42.261]                   }
[10:32:42.261]                   muffleCondition(cond)
[10:32:42.261]                 })
[10:32:42.261]             }))
[10:32:42.261]             future::FutureResult(value = ...future.value$value, 
[10:32:42.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.261]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.261]                     ...future.globalenv.names))
[10:32:42.261]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.261]         }, condition = base::local({
[10:32:42.261]             c <- base::c
[10:32:42.261]             inherits <- base::inherits
[10:32:42.261]             invokeRestart <- base::invokeRestart
[10:32:42.261]             length <- base::length
[10:32:42.261]             list <- base::list
[10:32:42.261]             seq.int <- base::seq.int
[10:32:42.261]             signalCondition <- base::signalCondition
[10:32:42.261]             sys.calls <- base::sys.calls
[10:32:42.261]             `[[` <- base::`[[`
[10:32:42.261]             `+` <- base::`+`
[10:32:42.261]             `<<-` <- base::`<<-`
[10:32:42.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.261]                   3L)]
[10:32:42.261]             }
[10:32:42.261]             function(cond) {
[10:32:42.261]                 is_error <- inherits(cond, "error")
[10:32:42.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.261]                   NULL)
[10:32:42.261]                 if (is_error) {
[10:32:42.261]                   sessionInformation <- function() {
[10:32:42.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.261]                       search = base::search(), system = base::Sys.info())
[10:32:42.261]                   }
[10:32:42.261]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.261]                     cond$call), session = sessionInformation(), 
[10:32:42.261]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.261]                   signalCondition(cond)
[10:32:42.261]                 }
[10:32:42.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.261]                 "immediateCondition"))) {
[10:32:42.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.261]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.261]                   if (TRUE && !signal) {
[10:32:42.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.261]                     {
[10:32:42.261]                       inherits <- base::inherits
[10:32:42.261]                       invokeRestart <- base::invokeRestart
[10:32:42.261]                       is.null <- base::is.null
[10:32:42.261]                       muffled <- FALSE
[10:32:42.261]                       if (inherits(cond, "message")) {
[10:32:42.261]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.261]                         if (muffled) 
[10:32:42.261]                           invokeRestart("muffleMessage")
[10:32:42.261]                       }
[10:32:42.261]                       else if (inherits(cond, "warning")) {
[10:32:42.261]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.261]                         if (muffled) 
[10:32:42.261]                           invokeRestart("muffleWarning")
[10:32:42.261]                       }
[10:32:42.261]                       else if (inherits(cond, "condition")) {
[10:32:42.261]                         if (!is.null(pattern)) {
[10:32:42.261]                           computeRestarts <- base::computeRestarts
[10:32:42.261]                           grepl <- base::grepl
[10:32:42.261]                           restarts <- computeRestarts(cond)
[10:32:42.261]                           for (restart in restarts) {
[10:32:42.261]                             name <- restart$name
[10:32:42.261]                             if (is.null(name)) 
[10:32:42.261]                               next
[10:32:42.261]                             if (!grepl(pattern, name)) 
[10:32:42.261]                               next
[10:32:42.261]                             invokeRestart(restart)
[10:32:42.261]                             muffled <- TRUE
[10:32:42.261]                             break
[10:32:42.261]                           }
[10:32:42.261]                         }
[10:32:42.261]                       }
[10:32:42.261]                       invisible(muffled)
[10:32:42.261]                     }
[10:32:42.261]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.261]                   }
[10:32:42.261]                 }
[10:32:42.261]                 else {
[10:32:42.261]                   if (TRUE) {
[10:32:42.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.261]                     {
[10:32:42.261]                       inherits <- base::inherits
[10:32:42.261]                       invokeRestart <- base::invokeRestart
[10:32:42.261]                       is.null <- base::is.null
[10:32:42.261]                       muffled <- FALSE
[10:32:42.261]                       if (inherits(cond, "message")) {
[10:32:42.261]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.261]                         if (muffled) 
[10:32:42.261]                           invokeRestart("muffleMessage")
[10:32:42.261]                       }
[10:32:42.261]                       else if (inherits(cond, "warning")) {
[10:32:42.261]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.261]                         if (muffled) 
[10:32:42.261]                           invokeRestart("muffleWarning")
[10:32:42.261]                       }
[10:32:42.261]                       else if (inherits(cond, "condition")) {
[10:32:42.261]                         if (!is.null(pattern)) {
[10:32:42.261]                           computeRestarts <- base::computeRestarts
[10:32:42.261]                           grepl <- base::grepl
[10:32:42.261]                           restarts <- computeRestarts(cond)
[10:32:42.261]                           for (restart in restarts) {
[10:32:42.261]                             name <- restart$name
[10:32:42.261]                             if (is.null(name)) 
[10:32:42.261]                               next
[10:32:42.261]                             if (!grepl(pattern, name)) 
[10:32:42.261]                               next
[10:32:42.261]                             invokeRestart(restart)
[10:32:42.261]                             muffled <- TRUE
[10:32:42.261]                             break
[10:32:42.261]                           }
[10:32:42.261]                         }
[10:32:42.261]                       }
[10:32:42.261]                       invisible(muffled)
[10:32:42.261]                     }
[10:32:42.261]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.261]                   }
[10:32:42.261]                 }
[10:32:42.261]             }
[10:32:42.261]         }))
[10:32:42.261]     }, error = function(ex) {
[10:32:42.261]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.261]                 ...future.rng), started = ...future.startTime, 
[10:32:42.261]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.261]             version = "1.8"), class = "FutureResult")
[10:32:42.261]     }, finally = {
[10:32:42.261]         if (!identical(...future.workdir, getwd())) 
[10:32:42.261]             setwd(...future.workdir)
[10:32:42.261]         {
[10:32:42.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.261]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.261]             }
[10:32:42.261]             base::options(...future.oldOptions)
[10:32:42.261]             if (.Platform$OS.type == "windows") {
[10:32:42.261]                 old_names <- names(...future.oldEnvVars)
[10:32:42.261]                 envs <- base::Sys.getenv()
[10:32:42.261]                 names <- names(envs)
[10:32:42.261]                 common <- intersect(names, old_names)
[10:32:42.261]                 added <- setdiff(names, old_names)
[10:32:42.261]                 removed <- setdiff(old_names, names)
[10:32:42.261]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.261]                   envs[common]]
[10:32:42.261]                 NAMES <- toupper(changed)
[10:32:42.261]                 args <- list()
[10:32:42.261]                 for (kk in seq_along(NAMES)) {
[10:32:42.261]                   name <- changed[[kk]]
[10:32:42.261]                   NAME <- NAMES[[kk]]
[10:32:42.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.261]                     next
[10:32:42.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.261]                 }
[10:32:42.261]                 NAMES <- toupper(added)
[10:32:42.261]                 for (kk in seq_along(NAMES)) {
[10:32:42.261]                   name <- added[[kk]]
[10:32:42.261]                   NAME <- NAMES[[kk]]
[10:32:42.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.261]                     next
[10:32:42.261]                   args[[name]] <- ""
[10:32:42.261]                 }
[10:32:42.261]                 NAMES <- toupper(removed)
[10:32:42.261]                 for (kk in seq_along(NAMES)) {
[10:32:42.261]                   name <- removed[[kk]]
[10:32:42.261]                   NAME <- NAMES[[kk]]
[10:32:42.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.261]                     next
[10:32:42.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.261]                 }
[10:32:42.261]                 if (length(args) > 0) 
[10:32:42.261]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.261]             }
[10:32:42.261]             else {
[10:32:42.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.261]             }
[10:32:42.261]             {
[10:32:42.261]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.261]                   0L) {
[10:32:42.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.261]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.261]                   base::options(opts)
[10:32:42.261]                 }
[10:32:42.261]                 {
[10:32:42.261]                   {
[10:32:42.261]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.261]                     NULL
[10:32:42.261]                   }
[10:32:42.261]                   options(future.plan = NULL)
[10:32:42.261]                   if (is.na(NA_character_)) 
[10:32:42.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.261]                     .init = FALSE)
[10:32:42.261]                 }
[10:32:42.261]             }
[10:32:42.261]         }
[10:32:42.261]     })
[10:32:42.261]     if (TRUE) {
[10:32:42.261]         base::sink(type = "output", split = FALSE)
[10:32:42.261]         if (TRUE) {
[10:32:42.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.261]         }
[10:32:42.261]         else {
[10:32:42.261]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.261]         }
[10:32:42.261]         base::close(...future.stdout)
[10:32:42.261]         ...future.stdout <- NULL
[10:32:42.261]     }
[10:32:42.261]     ...future.result$conditions <- ...future.conditions
[10:32:42.261]     ...future.result$finished <- base::Sys.time()
[10:32:42.261]     ...future.result
[10:32:42.261] }
[10:32:42.267] requestCore(): workers = 2
[10:32:42.270] MulticoreFuture started
[10:32:42.271] - Launch lazy future ... done
[10:32:42.271] run() for ‘MulticoreFuture’ ... done
[10:32:42.271] plan(): Setting new future strategy stack:
[10:32:42.272] result() for MulticoreFuture ...
[10:32:42.271] List of future strategies:
[10:32:42.271] 1. sequential:
[10:32:42.271]    - args: function (..., envir = parent.frame())
[10:32:42.271]    - tweaked: FALSE
[10:32:42.271]    - call: NULL
[10:32:42.273] plan(): nbrOfWorkers() = 1
[10:32:42.276] plan(): Setting new future strategy stack:
[10:32:42.276] List of future strategies:
[10:32:42.276] 1. multicore:
[10:32:42.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.276]    - tweaked: FALSE
[10:32:42.276]    - call: plan(strategy)
[10:32:42.283] plan(): nbrOfWorkers() = 2
[10:32:42.284] result() for MulticoreFuture ...
[10:32:42.284] result() for MulticoreFuture ... done
[10:32:42.285] result() for MulticoreFuture ... done
[10:32:42.285] result() for MulticoreFuture ...
[10:32:42.285] result() for MulticoreFuture ... done
c = 1
[10:32:42.286] getGlobalsAndPackages() ...
[10:32:42.286] Searching for globals...
[10:32:42.287] 
[10:32:42.287] Searching for globals ... DONE
[10:32:42.287] - globals: [0] <none>
[10:32:42.287] getGlobalsAndPackages() ... DONE
[10:32:42.288] run() for ‘Future’ ...
[10:32:42.288] - state: ‘created’
[10:32:42.288] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.293]   - Field: ‘label’
[10:32:42.293]   - Field: ‘local’
[10:32:42.293]   - Field: ‘owner’
[10:32:42.293]   - Field: ‘envir’
[10:32:42.293]   - Field: ‘workers’
[10:32:42.294]   - Field: ‘packages’
[10:32:42.294]   - Field: ‘gc’
[10:32:42.294]   - Field: ‘job’
[10:32:42.294]   - Field: ‘conditions’
[10:32:42.294]   - Field: ‘expr’
[10:32:42.294]   - Field: ‘uuid’
[10:32:42.295]   - Field: ‘seed’
[10:32:42.295]   - Field: ‘version’
[10:32:42.295]   - Field: ‘result’
[10:32:42.295]   - Field: ‘asynchronous’
[10:32:42.295]   - Field: ‘calls’
[10:32:42.295]   - Field: ‘globals’
[10:32:42.295]   - Field: ‘stdout’
[10:32:42.296]   - Field: ‘earlySignal’
[10:32:42.296]   - Field: ‘lazy’
[10:32:42.296]   - Field: ‘state’
[10:32:42.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.296] - Launch lazy future ...
[10:32:42.297] Packages needed by the future expression (n = 0): <none>
[10:32:42.297] Packages needed by future strategies (n = 0): <none>
[10:32:42.298] {
[10:32:42.298]     {
[10:32:42.298]         {
[10:32:42.298]             ...future.startTime <- base::Sys.time()
[10:32:42.298]             {
[10:32:42.298]                 {
[10:32:42.298]                   {
[10:32:42.298]                     {
[10:32:42.298]                       base::local({
[10:32:42.298]                         has_future <- base::requireNamespace("future", 
[10:32:42.298]                           quietly = TRUE)
[10:32:42.298]                         if (has_future) {
[10:32:42.298]                           ns <- base::getNamespace("future")
[10:32:42.298]                           version <- ns[[".package"]][["version"]]
[10:32:42.298]                           if (is.null(version)) 
[10:32:42.298]                             version <- utils::packageVersion("future")
[10:32:42.298]                         }
[10:32:42.298]                         else {
[10:32:42.298]                           version <- NULL
[10:32:42.298]                         }
[10:32:42.298]                         if (!has_future || version < "1.8.0") {
[10:32:42.298]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.298]                             "", base::R.version$version.string), 
[10:32:42.298]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.298]                               "release", "version")], collapse = " "), 
[10:32:42.298]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.298]                             info)
[10:32:42.298]                           info <- base::paste(info, collapse = "; ")
[10:32:42.298]                           if (!has_future) {
[10:32:42.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.298]                               info)
[10:32:42.298]                           }
[10:32:42.298]                           else {
[10:32:42.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.298]                               info, version)
[10:32:42.298]                           }
[10:32:42.298]                           base::stop(msg)
[10:32:42.298]                         }
[10:32:42.298]                       })
[10:32:42.298]                     }
[10:32:42.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.298]                     base::options(mc.cores = 1L)
[10:32:42.298]                   }
[10:32:42.298]                   ...future.strategy.old <- future::plan("list")
[10:32:42.298]                   options(future.plan = NULL)
[10:32:42.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.298]                 }
[10:32:42.298]                 ...future.workdir <- getwd()
[10:32:42.298]             }
[10:32:42.298]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.298]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.298]         }
[10:32:42.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.298]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.298]             base::names(...future.oldOptions))
[10:32:42.298]     }
[10:32:42.298]     if (FALSE) {
[10:32:42.298]     }
[10:32:42.298]     else {
[10:32:42.298]         if (TRUE) {
[10:32:42.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.298]                 open = "w")
[10:32:42.298]         }
[10:32:42.298]         else {
[10:32:42.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.298]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.298]         }
[10:32:42.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.298]             base::sink(type = "output", split = FALSE)
[10:32:42.298]             base::close(...future.stdout)
[10:32:42.298]         }, add = TRUE)
[10:32:42.298]     }
[10:32:42.298]     ...future.frame <- base::sys.nframe()
[10:32:42.298]     ...future.conditions <- base::list()
[10:32:42.298]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.298]     if (FALSE) {
[10:32:42.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.298]     }
[10:32:42.298]     ...future.result <- base::tryCatch({
[10:32:42.298]         base::withCallingHandlers({
[10:32:42.298]             ...future.value <- base::withVisible(base::local({
[10:32:42.298]                 withCallingHandlers({
[10:32:42.298]                   1
[10:32:42.298]                 }, immediateCondition = function(cond) {
[10:32:42.298]                   save_rds <- function (object, pathname, ...) 
[10:32:42.298]                   {
[10:32:42.298]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.298]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.298]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.298]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.298]                         fi_tmp[["mtime"]])
[10:32:42.298]                     }
[10:32:42.298]                     tryCatch({
[10:32:42.298]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.298]                     }, error = function(ex) {
[10:32:42.298]                       msg <- conditionMessage(ex)
[10:32:42.298]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.298]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.298]                         fi_tmp[["mtime"]], msg)
[10:32:42.298]                       ex$message <- msg
[10:32:42.298]                       stop(ex)
[10:32:42.298]                     })
[10:32:42.298]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.298]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.298]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.298]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.298]                       fi <- file.info(pathname)
[10:32:42.298]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.298]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.298]                         fi[["size"]], fi[["mtime"]])
[10:32:42.298]                       stop(msg)
[10:32:42.298]                     }
[10:32:42.298]                     invisible(pathname)
[10:32:42.298]                   }
[10:32:42.298]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.298]                     rootPath = tempdir()) 
[10:32:42.298]                   {
[10:32:42.298]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.298]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.298]                       tmpdir = path, fileext = ".rds")
[10:32:42.298]                     save_rds(obj, file)
[10:32:42.298]                   }
[10:32:42.298]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.298]                   {
[10:32:42.298]                     inherits <- base::inherits
[10:32:42.298]                     invokeRestart <- base::invokeRestart
[10:32:42.298]                     is.null <- base::is.null
[10:32:42.298]                     muffled <- FALSE
[10:32:42.298]                     if (inherits(cond, "message")) {
[10:32:42.298]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.298]                       if (muffled) 
[10:32:42.298]                         invokeRestart("muffleMessage")
[10:32:42.298]                     }
[10:32:42.298]                     else if (inherits(cond, "warning")) {
[10:32:42.298]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.298]                       if (muffled) 
[10:32:42.298]                         invokeRestart("muffleWarning")
[10:32:42.298]                     }
[10:32:42.298]                     else if (inherits(cond, "condition")) {
[10:32:42.298]                       if (!is.null(pattern)) {
[10:32:42.298]                         computeRestarts <- base::computeRestarts
[10:32:42.298]                         grepl <- base::grepl
[10:32:42.298]                         restarts <- computeRestarts(cond)
[10:32:42.298]                         for (restart in restarts) {
[10:32:42.298]                           name <- restart$name
[10:32:42.298]                           if (is.null(name)) 
[10:32:42.298]                             next
[10:32:42.298]                           if (!grepl(pattern, name)) 
[10:32:42.298]                             next
[10:32:42.298]                           invokeRestart(restart)
[10:32:42.298]                           muffled <- TRUE
[10:32:42.298]                           break
[10:32:42.298]                         }
[10:32:42.298]                       }
[10:32:42.298]                     }
[10:32:42.298]                     invisible(muffled)
[10:32:42.298]                   }
[10:32:42.298]                   muffleCondition(cond)
[10:32:42.298]                 })
[10:32:42.298]             }))
[10:32:42.298]             future::FutureResult(value = ...future.value$value, 
[10:32:42.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.298]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.298]                     ...future.globalenv.names))
[10:32:42.298]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.298]         }, condition = base::local({
[10:32:42.298]             c <- base::c
[10:32:42.298]             inherits <- base::inherits
[10:32:42.298]             invokeRestart <- base::invokeRestart
[10:32:42.298]             length <- base::length
[10:32:42.298]             list <- base::list
[10:32:42.298]             seq.int <- base::seq.int
[10:32:42.298]             signalCondition <- base::signalCondition
[10:32:42.298]             sys.calls <- base::sys.calls
[10:32:42.298]             `[[` <- base::`[[`
[10:32:42.298]             `+` <- base::`+`
[10:32:42.298]             `<<-` <- base::`<<-`
[10:32:42.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.298]                   3L)]
[10:32:42.298]             }
[10:32:42.298]             function(cond) {
[10:32:42.298]                 is_error <- inherits(cond, "error")
[10:32:42.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.298]                   NULL)
[10:32:42.298]                 if (is_error) {
[10:32:42.298]                   sessionInformation <- function() {
[10:32:42.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.298]                       search = base::search(), system = base::Sys.info())
[10:32:42.298]                   }
[10:32:42.298]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.298]                     cond$call), session = sessionInformation(), 
[10:32:42.298]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.298]                   signalCondition(cond)
[10:32:42.298]                 }
[10:32:42.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.298]                 "immediateCondition"))) {
[10:32:42.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.298]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.298]                   if (TRUE && !signal) {
[10:32:42.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.298]                     {
[10:32:42.298]                       inherits <- base::inherits
[10:32:42.298]                       invokeRestart <- base::invokeRestart
[10:32:42.298]                       is.null <- base::is.null
[10:32:42.298]                       muffled <- FALSE
[10:32:42.298]                       if (inherits(cond, "message")) {
[10:32:42.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.298]                         if (muffled) 
[10:32:42.298]                           invokeRestart("muffleMessage")
[10:32:42.298]                       }
[10:32:42.298]                       else if (inherits(cond, "warning")) {
[10:32:42.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.298]                         if (muffled) 
[10:32:42.298]                           invokeRestart("muffleWarning")
[10:32:42.298]                       }
[10:32:42.298]                       else if (inherits(cond, "condition")) {
[10:32:42.298]                         if (!is.null(pattern)) {
[10:32:42.298]                           computeRestarts <- base::computeRestarts
[10:32:42.298]                           grepl <- base::grepl
[10:32:42.298]                           restarts <- computeRestarts(cond)
[10:32:42.298]                           for (restart in restarts) {
[10:32:42.298]                             name <- restart$name
[10:32:42.298]                             if (is.null(name)) 
[10:32:42.298]                               next
[10:32:42.298]                             if (!grepl(pattern, name)) 
[10:32:42.298]                               next
[10:32:42.298]                             invokeRestart(restart)
[10:32:42.298]                             muffled <- TRUE
[10:32:42.298]                             break
[10:32:42.298]                           }
[10:32:42.298]                         }
[10:32:42.298]                       }
[10:32:42.298]                       invisible(muffled)
[10:32:42.298]                     }
[10:32:42.298]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.298]                   }
[10:32:42.298]                 }
[10:32:42.298]                 else {
[10:32:42.298]                   if (TRUE) {
[10:32:42.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.298]                     {
[10:32:42.298]                       inherits <- base::inherits
[10:32:42.298]                       invokeRestart <- base::invokeRestart
[10:32:42.298]                       is.null <- base::is.null
[10:32:42.298]                       muffled <- FALSE
[10:32:42.298]                       if (inherits(cond, "message")) {
[10:32:42.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.298]                         if (muffled) 
[10:32:42.298]                           invokeRestart("muffleMessage")
[10:32:42.298]                       }
[10:32:42.298]                       else if (inherits(cond, "warning")) {
[10:32:42.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.298]                         if (muffled) 
[10:32:42.298]                           invokeRestart("muffleWarning")
[10:32:42.298]                       }
[10:32:42.298]                       else if (inherits(cond, "condition")) {
[10:32:42.298]                         if (!is.null(pattern)) {
[10:32:42.298]                           computeRestarts <- base::computeRestarts
[10:32:42.298]                           grepl <- base::grepl
[10:32:42.298]                           restarts <- computeRestarts(cond)
[10:32:42.298]                           for (restart in restarts) {
[10:32:42.298]                             name <- restart$name
[10:32:42.298]                             if (is.null(name)) 
[10:32:42.298]                               next
[10:32:42.298]                             if (!grepl(pattern, name)) 
[10:32:42.298]                               next
[10:32:42.298]                             invokeRestart(restart)
[10:32:42.298]                             muffled <- TRUE
[10:32:42.298]                             break
[10:32:42.298]                           }
[10:32:42.298]                         }
[10:32:42.298]                       }
[10:32:42.298]                       invisible(muffled)
[10:32:42.298]                     }
[10:32:42.298]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.298]                   }
[10:32:42.298]                 }
[10:32:42.298]             }
[10:32:42.298]         }))
[10:32:42.298]     }, error = function(ex) {
[10:32:42.298]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.298]                 ...future.rng), started = ...future.startTime, 
[10:32:42.298]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.298]             version = "1.8"), class = "FutureResult")
[10:32:42.298]     }, finally = {
[10:32:42.298]         if (!identical(...future.workdir, getwd())) 
[10:32:42.298]             setwd(...future.workdir)
[10:32:42.298]         {
[10:32:42.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.298]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.298]             }
[10:32:42.298]             base::options(...future.oldOptions)
[10:32:42.298]             if (.Platform$OS.type == "windows") {
[10:32:42.298]                 old_names <- names(...future.oldEnvVars)
[10:32:42.298]                 envs <- base::Sys.getenv()
[10:32:42.298]                 names <- names(envs)
[10:32:42.298]                 common <- intersect(names, old_names)
[10:32:42.298]                 added <- setdiff(names, old_names)
[10:32:42.298]                 removed <- setdiff(old_names, names)
[10:32:42.298]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.298]                   envs[common]]
[10:32:42.298]                 NAMES <- toupper(changed)
[10:32:42.298]                 args <- list()
[10:32:42.298]                 for (kk in seq_along(NAMES)) {
[10:32:42.298]                   name <- changed[[kk]]
[10:32:42.298]                   NAME <- NAMES[[kk]]
[10:32:42.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.298]                     next
[10:32:42.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.298]                 }
[10:32:42.298]                 NAMES <- toupper(added)
[10:32:42.298]                 for (kk in seq_along(NAMES)) {
[10:32:42.298]                   name <- added[[kk]]
[10:32:42.298]                   NAME <- NAMES[[kk]]
[10:32:42.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.298]                     next
[10:32:42.298]                   args[[name]] <- ""
[10:32:42.298]                 }
[10:32:42.298]                 NAMES <- toupper(removed)
[10:32:42.298]                 for (kk in seq_along(NAMES)) {
[10:32:42.298]                   name <- removed[[kk]]
[10:32:42.298]                   NAME <- NAMES[[kk]]
[10:32:42.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.298]                     next
[10:32:42.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.298]                 }
[10:32:42.298]                 if (length(args) > 0) 
[10:32:42.298]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.298]             }
[10:32:42.298]             else {
[10:32:42.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.298]             }
[10:32:42.298]             {
[10:32:42.298]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.298]                   0L) {
[10:32:42.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.298]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.298]                   base::options(opts)
[10:32:42.298]                 }
[10:32:42.298]                 {
[10:32:42.298]                   {
[10:32:42.298]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.298]                     NULL
[10:32:42.298]                   }
[10:32:42.298]                   options(future.plan = NULL)
[10:32:42.298]                   if (is.na(NA_character_)) 
[10:32:42.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.298]                     .init = FALSE)
[10:32:42.298]                 }
[10:32:42.298]             }
[10:32:42.298]         }
[10:32:42.298]     })
[10:32:42.298]     if (TRUE) {
[10:32:42.298]         base::sink(type = "output", split = FALSE)
[10:32:42.298]         if (TRUE) {
[10:32:42.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.298]         }
[10:32:42.298]         else {
[10:32:42.298]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.298]         }
[10:32:42.298]         base::close(...future.stdout)
[10:32:42.298]         ...future.stdout <- NULL
[10:32:42.298]     }
[10:32:42.298]     ...future.result$conditions <- ...future.conditions
[10:32:42.298]     ...future.result$finished <- base::Sys.time()
[10:32:42.298]     ...future.result
[10:32:42.298] }
[10:32:42.300] requestCore(): workers = 2
[10:32:42.302] MulticoreFuture started
[10:32:42.303] - Launch lazy future ... done
[10:32:42.303] run() for ‘MulticoreFuture’ ... done
[10:32:42.304] result() for MulticoreFuture ...
[10:32:42.304] plan(): Setting new future strategy stack:
[10:32:42.304] List of future strategies:
[10:32:42.304] 1. sequential:
[10:32:42.304]    - args: function (..., envir = parent.frame())
[10:32:42.304]    - tweaked: FALSE
[10:32:42.304]    - call: NULL
[10:32:42.305] plan(): nbrOfWorkers() = 1
[10:32:42.308] plan(): Setting new future strategy stack:
[10:32:42.308] List of future strategies:
[10:32:42.308] 1. multicore:
[10:32:42.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.308]    - tweaked: FALSE
[10:32:42.308]    - call: plan(strategy)
[10:32:42.314] plan(): nbrOfWorkers() = 2
[10:32:42.314] result() for MulticoreFuture ...
[10:32:42.315] result() for MulticoreFuture ... done
[10:32:42.315] result() for MulticoreFuture ... done
[10:32:42.315] result() for MulticoreFuture ...
[10:32:42.315] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[10:32:42.316] getGlobalsAndPackages() ...
[10:32:42.316] Searching for globals...
[10:32:42.322] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[10:32:42.322] Searching for globals ... DONE
[10:32:42.323] Resolving globals: FALSE
[10:32:42.323] 
[10:32:42.324] - packages: [1] ‘future’
[10:32:42.324] getGlobalsAndPackages() ... DONE
[10:32:42.324] run() for ‘Future’ ...
[10:32:42.324] - state: ‘created’
[10:32:42.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.330]   - Field: ‘label’
[10:32:42.330]   - Field: ‘local’
[10:32:42.330]   - Field: ‘owner’
[10:32:42.330]   - Field: ‘envir’
[10:32:42.331]   - Field: ‘workers’
[10:32:42.331]   - Field: ‘packages’
[10:32:42.331]   - Field: ‘gc’
[10:32:42.331]   - Field: ‘job’
[10:32:42.331]   - Field: ‘conditions’
[10:32:42.332]   - Field: ‘expr’
[10:32:42.332]   - Field: ‘uuid’
[10:32:42.332]   - Field: ‘seed’
[10:32:42.332]   - Field: ‘version’
[10:32:42.336]   - Field: ‘result’
[10:32:42.336]   - Field: ‘asynchronous’
[10:32:42.336]   - Field: ‘calls’
[10:32:42.337]   - Field: ‘globals’
[10:32:42.337]   - Field: ‘stdout’
[10:32:42.337]   - Field: ‘earlySignal’
[10:32:42.337]   - Field: ‘lazy’
[10:32:42.337]   - Field: ‘state’
[10:32:42.338] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.338] - Launch lazy future ...
[10:32:42.339] Packages needed by the future expression (n = 1): ‘future’
[10:32:42.339] Packages needed by future strategies (n = 0): <none>
[10:32:42.340] {
[10:32:42.340]     {
[10:32:42.340]         {
[10:32:42.340]             ...future.startTime <- base::Sys.time()
[10:32:42.340]             {
[10:32:42.340]                 {
[10:32:42.340]                   {
[10:32:42.340]                     {
[10:32:42.340]                       {
[10:32:42.340]                         base::local({
[10:32:42.340]                           has_future <- base::requireNamespace("future", 
[10:32:42.340]                             quietly = TRUE)
[10:32:42.340]                           if (has_future) {
[10:32:42.340]                             ns <- base::getNamespace("future")
[10:32:42.340]                             version <- ns[[".package"]][["version"]]
[10:32:42.340]                             if (is.null(version)) 
[10:32:42.340]                               version <- utils::packageVersion("future")
[10:32:42.340]                           }
[10:32:42.340]                           else {
[10:32:42.340]                             version <- NULL
[10:32:42.340]                           }
[10:32:42.340]                           if (!has_future || version < "1.8.0") {
[10:32:42.340]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.340]                               "", base::R.version$version.string), 
[10:32:42.340]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:42.340]                                 base::R.version$platform, 8 * 
[10:32:42.340]                                   base::.Machine$sizeof.pointer), 
[10:32:42.340]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.340]                                 "release", "version")], collapse = " "), 
[10:32:42.340]                               hostname = base::Sys.info()[["nodename"]])
[10:32:42.340]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.340]                               info)
[10:32:42.340]                             info <- base::paste(info, collapse = "; ")
[10:32:42.340]                             if (!has_future) {
[10:32:42.340]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.340]                                 info)
[10:32:42.340]                             }
[10:32:42.340]                             else {
[10:32:42.340]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.340]                                 info, version)
[10:32:42.340]                             }
[10:32:42.340]                             base::stop(msg)
[10:32:42.340]                           }
[10:32:42.340]                         })
[10:32:42.340]                       }
[10:32:42.340]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.340]                       base::options(mc.cores = 1L)
[10:32:42.340]                     }
[10:32:42.340]                     base::local({
[10:32:42.340]                       for (pkg in "future") {
[10:32:42.340]                         base::loadNamespace(pkg)
[10:32:42.340]                         base::library(pkg, character.only = TRUE)
[10:32:42.340]                       }
[10:32:42.340]                     })
[10:32:42.340]                   }
[10:32:42.340]                   ...future.strategy.old <- future::plan("list")
[10:32:42.340]                   options(future.plan = NULL)
[10:32:42.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.340]                 }
[10:32:42.340]                 ...future.workdir <- getwd()
[10:32:42.340]             }
[10:32:42.340]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.340]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.340]         }
[10:32:42.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.340]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.340]             base::names(...future.oldOptions))
[10:32:42.340]     }
[10:32:42.340]     if (FALSE) {
[10:32:42.340]     }
[10:32:42.340]     else {
[10:32:42.340]         if (TRUE) {
[10:32:42.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.340]                 open = "w")
[10:32:42.340]         }
[10:32:42.340]         else {
[10:32:42.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.340]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.340]         }
[10:32:42.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.340]             base::sink(type = "output", split = FALSE)
[10:32:42.340]             base::close(...future.stdout)
[10:32:42.340]         }, add = TRUE)
[10:32:42.340]     }
[10:32:42.340]     ...future.frame <- base::sys.nframe()
[10:32:42.340]     ...future.conditions <- base::list()
[10:32:42.340]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.340]     if (FALSE) {
[10:32:42.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.340]     }
[10:32:42.340]     ...future.result <- base::tryCatch({
[10:32:42.340]         base::withCallingHandlers({
[10:32:42.340]             ...future.value <- base::withVisible(base::local({
[10:32:42.340]                 withCallingHandlers({
[10:32:42.340]                   {
[10:32:42.340]                     b <- 1
[10:32:42.340]                     c %<-% 2
[10:32:42.340]                     d <- 3
[10:32:42.340]                     4 %->% e
[10:32:42.340]                     b + c + d + e
[10:32:42.340]                   }
[10:32:42.340]                 }, immediateCondition = function(cond) {
[10:32:42.340]                   save_rds <- function (object, pathname, ...) 
[10:32:42.340]                   {
[10:32:42.340]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.340]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.340]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.340]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.340]                         fi_tmp[["mtime"]])
[10:32:42.340]                     }
[10:32:42.340]                     tryCatch({
[10:32:42.340]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.340]                     }, error = function(ex) {
[10:32:42.340]                       msg <- conditionMessage(ex)
[10:32:42.340]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.340]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.340]                         fi_tmp[["mtime"]], msg)
[10:32:42.340]                       ex$message <- msg
[10:32:42.340]                       stop(ex)
[10:32:42.340]                     })
[10:32:42.340]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.340]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.340]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.340]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.340]                       fi <- file.info(pathname)
[10:32:42.340]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.340]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.340]                         fi[["size"]], fi[["mtime"]])
[10:32:42.340]                       stop(msg)
[10:32:42.340]                     }
[10:32:42.340]                     invisible(pathname)
[10:32:42.340]                   }
[10:32:42.340]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.340]                     rootPath = tempdir()) 
[10:32:42.340]                   {
[10:32:42.340]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.340]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.340]                       tmpdir = path, fileext = ".rds")
[10:32:42.340]                     save_rds(obj, file)
[10:32:42.340]                   }
[10:32:42.340]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.340]                   {
[10:32:42.340]                     inherits <- base::inherits
[10:32:42.340]                     invokeRestart <- base::invokeRestart
[10:32:42.340]                     is.null <- base::is.null
[10:32:42.340]                     muffled <- FALSE
[10:32:42.340]                     if (inherits(cond, "message")) {
[10:32:42.340]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.340]                       if (muffled) 
[10:32:42.340]                         invokeRestart("muffleMessage")
[10:32:42.340]                     }
[10:32:42.340]                     else if (inherits(cond, "warning")) {
[10:32:42.340]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.340]                       if (muffled) 
[10:32:42.340]                         invokeRestart("muffleWarning")
[10:32:42.340]                     }
[10:32:42.340]                     else if (inherits(cond, "condition")) {
[10:32:42.340]                       if (!is.null(pattern)) {
[10:32:42.340]                         computeRestarts <- base::computeRestarts
[10:32:42.340]                         grepl <- base::grepl
[10:32:42.340]                         restarts <- computeRestarts(cond)
[10:32:42.340]                         for (restart in restarts) {
[10:32:42.340]                           name <- restart$name
[10:32:42.340]                           if (is.null(name)) 
[10:32:42.340]                             next
[10:32:42.340]                           if (!grepl(pattern, name)) 
[10:32:42.340]                             next
[10:32:42.340]                           invokeRestart(restart)
[10:32:42.340]                           muffled <- TRUE
[10:32:42.340]                           break
[10:32:42.340]                         }
[10:32:42.340]                       }
[10:32:42.340]                     }
[10:32:42.340]                     invisible(muffled)
[10:32:42.340]                   }
[10:32:42.340]                   muffleCondition(cond)
[10:32:42.340]                 })
[10:32:42.340]             }))
[10:32:42.340]             future::FutureResult(value = ...future.value$value, 
[10:32:42.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.340]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.340]                     ...future.globalenv.names))
[10:32:42.340]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.340]         }, condition = base::local({
[10:32:42.340]             c <- base::c
[10:32:42.340]             inherits <- base::inherits
[10:32:42.340]             invokeRestart <- base::invokeRestart
[10:32:42.340]             length <- base::length
[10:32:42.340]             list <- base::list
[10:32:42.340]             seq.int <- base::seq.int
[10:32:42.340]             signalCondition <- base::signalCondition
[10:32:42.340]             sys.calls <- base::sys.calls
[10:32:42.340]             `[[` <- base::`[[`
[10:32:42.340]             `+` <- base::`+`
[10:32:42.340]             `<<-` <- base::`<<-`
[10:32:42.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.340]                   3L)]
[10:32:42.340]             }
[10:32:42.340]             function(cond) {
[10:32:42.340]                 is_error <- inherits(cond, "error")
[10:32:42.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.340]                   NULL)
[10:32:42.340]                 if (is_error) {
[10:32:42.340]                   sessionInformation <- function() {
[10:32:42.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.340]                       search = base::search(), system = base::Sys.info())
[10:32:42.340]                   }
[10:32:42.340]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.340]                     cond$call), session = sessionInformation(), 
[10:32:42.340]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.340]                   signalCondition(cond)
[10:32:42.340]                 }
[10:32:42.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.340]                 "immediateCondition"))) {
[10:32:42.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.340]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.340]                   if (TRUE && !signal) {
[10:32:42.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.340]                     {
[10:32:42.340]                       inherits <- base::inherits
[10:32:42.340]                       invokeRestart <- base::invokeRestart
[10:32:42.340]                       is.null <- base::is.null
[10:32:42.340]                       muffled <- FALSE
[10:32:42.340]                       if (inherits(cond, "message")) {
[10:32:42.340]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.340]                         if (muffled) 
[10:32:42.340]                           invokeRestart("muffleMessage")
[10:32:42.340]                       }
[10:32:42.340]                       else if (inherits(cond, "warning")) {
[10:32:42.340]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.340]                         if (muffled) 
[10:32:42.340]                           invokeRestart("muffleWarning")
[10:32:42.340]                       }
[10:32:42.340]                       else if (inherits(cond, "condition")) {
[10:32:42.340]                         if (!is.null(pattern)) {
[10:32:42.340]                           computeRestarts <- base::computeRestarts
[10:32:42.340]                           grepl <- base::grepl
[10:32:42.340]                           restarts <- computeRestarts(cond)
[10:32:42.340]                           for (restart in restarts) {
[10:32:42.340]                             name <- restart$name
[10:32:42.340]                             if (is.null(name)) 
[10:32:42.340]                               next
[10:32:42.340]                             if (!grepl(pattern, name)) 
[10:32:42.340]                               next
[10:32:42.340]                             invokeRestart(restart)
[10:32:42.340]                             muffled <- TRUE
[10:32:42.340]                             break
[10:32:42.340]                           }
[10:32:42.340]                         }
[10:32:42.340]                       }
[10:32:42.340]                       invisible(muffled)
[10:32:42.340]                     }
[10:32:42.340]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.340]                   }
[10:32:42.340]                 }
[10:32:42.340]                 else {
[10:32:42.340]                   if (TRUE) {
[10:32:42.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.340]                     {
[10:32:42.340]                       inherits <- base::inherits
[10:32:42.340]                       invokeRestart <- base::invokeRestart
[10:32:42.340]                       is.null <- base::is.null
[10:32:42.340]                       muffled <- FALSE
[10:32:42.340]                       if (inherits(cond, "message")) {
[10:32:42.340]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.340]                         if (muffled) 
[10:32:42.340]                           invokeRestart("muffleMessage")
[10:32:42.340]                       }
[10:32:42.340]                       else if (inherits(cond, "warning")) {
[10:32:42.340]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.340]                         if (muffled) 
[10:32:42.340]                           invokeRestart("muffleWarning")
[10:32:42.340]                       }
[10:32:42.340]                       else if (inherits(cond, "condition")) {
[10:32:42.340]                         if (!is.null(pattern)) {
[10:32:42.340]                           computeRestarts <- base::computeRestarts
[10:32:42.340]                           grepl <- base::grepl
[10:32:42.340]                           restarts <- computeRestarts(cond)
[10:32:42.340]                           for (restart in restarts) {
[10:32:42.340]                             name <- restart$name
[10:32:42.340]                             if (is.null(name)) 
[10:32:42.340]                               next
[10:32:42.340]                             if (!grepl(pattern, name)) 
[10:32:42.340]                               next
[10:32:42.340]                             invokeRestart(restart)
[10:32:42.340]                             muffled <- TRUE
[10:32:42.340]                             break
[10:32:42.340]                           }
[10:32:42.340]                         }
[10:32:42.340]                       }
[10:32:42.340]                       invisible(muffled)
[10:32:42.340]                     }
[10:32:42.340]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.340]                   }
[10:32:42.340]                 }
[10:32:42.340]             }
[10:32:42.340]         }))
[10:32:42.340]     }, error = function(ex) {
[10:32:42.340]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.340]                 ...future.rng), started = ...future.startTime, 
[10:32:42.340]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.340]             version = "1.8"), class = "FutureResult")
[10:32:42.340]     }, finally = {
[10:32:42.340]         if (!identical(...future.workdir, getwd())) 
[10:32:42.340]             setwd(...future.workdir)
[10:32:42.340]         {
[10:32:42.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.340]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.340]             }
[10:32:42.340]             base::options(...future.oldOptions)
[10:32:42.340]             if (.Platform$OS.type == "windows") {
[10:32:42.340]                 old_names <- names(...future.oldEnvVars)
[10:32:42.340]                 envs <- base::Sys.getenv()
[10:32:42.340]                 names <- names(envs)
[10:32:42.340]                 common <- intersect(names, old_names)
[10:32:42.340]                 added <- setdiff(names, old_names)
[10:32:42.340]                 removed <- setdiff(old_names, names)
[10:32:42.340]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.340]                   envs[common]]
[10:32:42.340]                 NAMES <- toupper(changed)
[10:32:42.340]                 args <- list()
[10:32:42.340]                 for (kk in seq_along(NAMES)) {
[10:32:42.340]                   name <- changed[[kk]]
[10:32:42.340]                   NAME <- NAMES[[kk]]
[10:32:42.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.340]                     next
[10:32:42.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.340]                 }
[10:32:42.340]                 NAMES <- toupper(added)
[10:32:42.340]                 for (kk in seq_along(NAMES)) {
[10:32:42.340]                   name <- added[[kk]]
[10:32:42.340]                   NAME <- NAMES[[kk]]
[10:32:42.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.340]                     next
[10:32:42.340]                   args[[name]] <- ""
[10:32:42.340]                 }
[10:32:42.340]                 NAMES <- toupper(removed)
[10:32:42.340]                 for (kk in seq_along(NAMES)) {
[10:32:42.340]                   name <- removed[[kk]]
[10:32:42.340]                   NAME <- NAMES[[kk]]
[10:32:42.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.340]                     next
[10:32:42.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.340]                 }
[10:32:42.340]                 if (length(args) > 0) 
[10:32:42.340]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.340]             }
[10:32:42.340]             else {
[10:32:42.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.340]             }
[10:32:42.340]             {
[10:32:42.340]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.340]                   0L) {
[10:32:42.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.340]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.340]                   base::options(opts)
[10:32:42.340]                 }
[10:32:42.340]                 {
[10:32:42.340]                   {
[10:32:42.340]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.340]                     NULL
[10:32:42.340]                   }
[10:32:42.340]                   options(future.plan = NULL)
[10:32:42.340]                   if (is.na(NA_character_)) 
[10:32:42.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.340]                     .init = FALSE)
[10:32:42.340]                 }
[10:32:42.340]             }
[10:32:42.340]         }
[10:32:42.340]     })
[10:32:42.340]     if (TRUE) {
[10:32:42.340]         base::sink(type = "output", split = FALSE)
[10:32:42.340]         if (TRUE) {
[10:32:42.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.340]         }
[10:32:42.340]         else {
[10:32:42.340]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.340]         }
[10:32:42.340]         base::close(...future.stdout)
[10:32:42.340]         ...future.stdout <- NULL
[10:32:42.340]     }
[10:32:42.340]     ...future.result$conditions <- ...future.conditions
[10:32:42.340]     ...future.result$finished <- base::Sys.time()
[10:32:42.340]     ...future.result
[10:32:42.340] }
[10:32:42.344] requestCore(): workers = 2
[10:32:42.347] MulticoreFuture started
[10:32:42.347] - Launch lazy future ... done
[10:32:42.348] run() for ‘MulticoreFuture’ ... done
[10:32:42.348] result() for MulticoreFuture ...
[10:32:42.349] plan(): Setting new future strategy stack:
[10:32:42.349] List of future strategies:
[10:32:42.349] 1. sequential:
[10:32:42.349]    - args: function (..., envir = parent.frame())
[10:32:42.349]    - tweaked: FALSE
[10:32:42.349]    - call: NULL
[10:32:42.350] plan(): nbrOfWorkers() = 1
[10:32:42.384] plan(): Setting new future strategy stack:
[10:32:42.384] List of future strategies:
[10:32:42.384] 1. multicore:
[10:32:42.384]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.384]    - tweaked: FALSE
[10:32:42.384]    - call: plan(strategy)
[10:32:42.389] plan(): nbrOfWorkers() = 2
[10:32:42.390] result() for MulticoreFuture ...
[10:32:42.390] result() for MulticoreFuture ... done
[10:32:42.390] signalConditions() ...
[10:32:42.391]  - include = ‘immediateCondition’
[10:32:42.391]  - exclude = 
[10:32:42.391]  - resignal = FALSE
[10:32:42.391]  - Number of conditions: 88
[10:32:42.391] signalConditions() ... done
[10:32:42.391] result() for MulticoreFuture ... done
[10:32:42.391] result() for MulticoreFuture ...
[10:32:42.392] result() for MulticoreFuture ... done
[10:32:42.392] signalConditions() ...
[10:32:42.392]  - include = ‘immediateCondition’
[10:32:42.392]  - exclude = 
[10:32:42.392]  - resignal = FALSE
[10:32:42.392]  - Number of conditions: 88
[10:32:42.392] signalConditions() ... done
[10:32:42.393] Future state: ‘finished’
[10:32:42.393] result() for MulticoreFuture ...
[10:32:42.393] result() for MulticoreFuture ... done
[10:32:42.393] signalConditions() ...
[10:32:42.393]  - include = ‘condition’
[10:32:42.393]  - exclude = ‘immediateCondition’
[10:32:42.393]  - resignal = TRUE
[10:32:42.393]  - Number of conditions: 88
[10:32:42.394]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.351] getGlobalsAndPackages() ...
[10:32:42.394]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.352] Searching for globals...
[10:32:42.394]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.352] 
[10:32:42.394]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.353] Searching for globals ... DONE
[10:32:42.394]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.353] - globals: [0] <none>
[10:32:42.395]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.353] getGlobalsAndPackages() ... DONE
[10:32:42.395]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.354] run() for ‘Future’ ...
[10:32:42.395]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.354] - state: ‘created’
[10:32:42.395]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:42.395]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:42.395]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:42.396]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.356]   - Field: ‘label’
[10:32:42.396]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.356]   - Field: ‘local’
[10:32:42.396]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.356]   - Field: ‘owner’
[10:32:42.396]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.356]   - Field: ‘envir’
[10:32:42.396]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.356]   - Field: ‘packages’
[10:32:42.396]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.357]   - Field: ‘gc’
[10:32:42.397]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.357]   - Field: ‘conditions’
[10:32:42.397]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.357]   - Field: ‘expr’
[10:32:42.397]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.357]   - Field: ‘uuid’
[10:32:42.397]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.357]   - Field: ‘seed’
[10:32:42.397]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.357]   - Field: ‘version’
[10:32:42.398]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.358]   - Field: ‘result’
[10:32:42.398]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.358]   - Field: ‘asynchronous’
[10:32:42.398]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.358]   - Field: ‘calls’
[10:32:42.398]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.358]   - Field: ‘globals’
[10:32:42.398]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.358]   - Field: ‘stdout’
[10:32:42.398]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.359]   - Field: ‘earlySignal’
[10:32:42.399]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.359]   - Field: ‘lazy’
[10:32:42.399]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.359]   - Field: ‘state’
[10:32:42.399]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:42.399]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.359] - Launch lazy future ...
[10:32:42.399]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.360] Packages needed by the future expression (n = 0): <none>
[10:32:42.399]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.360] Packages needed by future strategies (n = 0): <none>
[10:32:42.400]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.361] {
[10:32:42.361]     {
[10:32:42.361]         {
[10:32:42.361]             ...future.startTime <- base::Sys.time()
[10:32:42.361]             {
[10:32:42.361]                 {
[10:32:42.361]                   {
[10:32:42.361]                     base::local({
[10:32:42.361]                       has_future <- base::requireNamespace("future", 
[10:32:42.361]                         quietly = TRUE)
[10:32:42.361]                       if (has_future) {
[10:32:42.361]                         ns <- base::getNamespace("future")
[10:32:42.361]                         version <- ns[[".package"]][["version"]]
[10:32:42.361]                         if (is.null(version)) 
[10:32:42.361]                           version <- utils::packageVersion("future")
[10:32:42.361]                       }
[10:32:42.361]                       else {
[10:32:42.361]                         version <- NULL
[10:32:42.361]                       }
[10:32:42.361]                       if (!has_future || version < "1.8.0") {
[10:32:42.361]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.361]                           "", base::R.version$version.string), 
[10:32:42.361]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:42.361]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.361]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.361]                             "release", "version")], collapse = " "), 
[10:32:42.361]                           hostname = base::Sys.info()[["nodename"]])
[10:32:42.361]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.361]                           info)
[10:32:42.361]                         info <- base::paste(info, collapse = "; ")
[10:32:42.361]                         if (!has_future) {
[10:32:42.361]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.361]                             info)
[10:32:42.361]                         }
[10:32:42.361]                         else {
[10:32:42.361]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.361]                             info, version)
[10:32:42.361]                         }
[10:32:42.361]                         base::stop(msg)
[10:32:42.361]                       }
[10:32:42.361]                     })
[10:32:42.361]                   }
[10:32:42.361]                   ...future.strategy.old <- future::plan("list")
[10:32:42.361]                   options(future.plan = NULL)
[10:32:42.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.361]                 }
[10:32:42.361]                 ...future.workdir <- getwd()
[10:32:42.361]             }
[10:32:42.361]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.361]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.361]         }
[10:32:42.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.361]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.361]             base::names(...future.oldOptions))
[10:32:42.361]     }
[10:32:42.361]     if (FALSE) {
[10:32:42.361]     }
[10:32:42.361]     else {
[10:32:42.361]         if (TRUE) {
[10:32:42.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.361]                 open = "w")
[10:32:42.361]         }
[10:32:42.361]         else {
[10:32:42.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.361]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.361]         }
[10:32:42.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.361]             base::sink(type = "output", split = FALSE)
[10:32:42.361]             base::close(...future.stdout)
[10:32:42.361]         }, add = TRUE)
[10:32:42.361]     }
[10:32:42.361]     ...future.frame <- base::sys.nframe()
[10:32:42.361]     ...future.conditions <- base::list()
[10:32:42.361]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.361]     if (FALSE) {
[10:32:42.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.361]     }
[10:32:42.361]     ...future.result <- base::tryCatch({
[10:32:42.361]         base::withCallingHandlers({
[10:32:42.361]             ...future.value <- base::withVisible(base::local(2))
[10:32:42.361]             future::FutureResult(value = ...future.value$value, 
[10:32:42.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.361]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.361]                     ...future.globalenv.names))
[10:32:42.361]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.361]         }, condition = base::local({
[10:32:42.361]             c <- base::c
[10:32:42.361]             inherits <- base::inherits
[10:32:42.361]             invokeRestart <- base::invokeRestart
[10:32:42.361]             length <- base::length
[10:32:42.361]             list <- base::list
[10:32:42.361]             seq.int <- base::seq.int
[10:32:42.361]             signalCondition <- base::signalCondition
[10:32:42.361]             sys.calls <- base::sys.calls
[10:32:42.361]             `[[` <- base::`[[`
[10:32:42.361]             `+` <- base::`+`
[10:32:42.361]             `<<-` <- base::`<<-`
[10:32:42.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.361]                   3L)]
[10:32:42.361]             }
[10:32:42.361]             function(cond) {
[10:32:42.361]                 is_error <- inherits(cond, "error")
[10:32:42.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.361]                   NULL)
[10:32:42.361]                 if (is_error) {
[10:32:42.361]                   sessionInformation <- function() {
[10:32:42.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.361]                       search = base::search(), system = base::Sys.info())
[10:32:42.361]                   }
[10:32:42.361]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.361]                     cond$call), session = sessionInformation(), 
[10:32:42.361]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.361]                   signalCondition(cond)
[10:32:42.361]                 }
[10:32:42.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.361]                 "immediateCondition"))) {
[10:32:42.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.361]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.361]                   if (TRUE && !signal) {
[10:32:42.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.361]                     {
[10:32:42.361]                       inherits <- base::inherits
[10:32:42.361]                       invokeRestart <- base::invokeRestart
[10:32:42.361]                       is.null <- base::is.null
[10:32:42.361]                       muffled <- FALSE
[10:32:42.361]                       if (inherits(cond, "message")) {
[10:32:42.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.361]                         if (muffled) 
[10:32:42.361]                           invokeRestart("muffleMessage")
[10:32:42.361]                       }
[10:32:42.361]                       else if (inherits(cond, "warning")) {
[10:32:42.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.361]                         if (muffled) 
[10:32:42.361]                           invokeRestart("muffleWarning")
[10:32:42.361]                       }
[10:32:42.361]                       else if (inherits(cond, "condition")) {
[10:32:42.361]                         if (!is.null(pattern)) {
[10:32:42.361]                           computeRestarts <- base::computeRestarts
[10:32:42.361]                           grepl <- base::grepl
[10:32:42.361]                           restarts <- computeRestarts(cond)
[10:32:42.361]                           for (restart in restarts) {
[10:32:42.361]                             name <- restart$name
[10:32:42.361]                             if (is.null(name)) 
[10:32:42.361]                               next
[10:32:42.361]                             if (!grepl(pattern, name)) 
[10:32:42.361]                               next
[10:32:42.361]                             invokeRestart(restart)
[10:32:42.361]                             muffled <- TRUE
[10:32:42.361]                             break
[10:32:42.361]                           }
[10:32:42.361]                         }
[10:32:42.361]                       }
[10:32:42.361]                       invisible(muffled)
[10:32:42.361]                     }
[10:32:42.361]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.361]                   }
[10:32:42.361]                 }
[10:32:42.361]                 else {
[10:32:42.361]                   if (TRUE) {
[10:32:42.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.361]                     {
[10:32:42.361]                       inherits <- base::inherits
[10:32:42.361]                       invokeRestart <- base::invokeRestart
[10:32:42.361]                       is.null <- base::is.null
[10:32:42.361]                       muffled <- FALSE
[10:32:42.361]                       if (inherits(cond, "message")) {
[10:32:42.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.361]                         if (muffled) 
[10:32:42.361]                           invokeRestart("muffleMessage")
[10:32:42.361]                       }
[10:32:42.361]                       else if (inherits(cond, "warning")) {
[10:32:42.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.361]                         if (muffled) 
[10:32:42.361]                           invokeRestart("muffleWarning")
[10:32:42.361]                       }
[10:32:42.361]                       else if (inherits(cond, "condition")) {
[10:32:42.361]                         if (!is.null(pattern)) {
[10:32:42.361]                           computeRestarts <- base::computeRestarts
[10:32:42.361]                           grepl <- base::grepl
[10:32:42.361]                           restarts <- computeRestarts(cond)
[10:32:42.361]                           for (restart in restarts) {
[10:32:42.361]                             name <- restart$name
[10:32:42.361]                             if (is.null(name)) 
[10:32:42.361]                               next
[10:32:42.361]                             if (!grepl(pattern, name)) 
[10:32:42.361]                               next
[10:32:42.361]                             invokeRestart(restart)
[10:32:42.361]                             muffled <- TRUE
[10:32:42.361]                             break
[10:32:42.361]                           }
[10:32:42.361]                         }
[10:32:42.361]                       }
[10:32:42.361]                       invisible(muffled)
[10:32:42.361]                     }
[10:32:42.361]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.361]                   }
[10:32:42.361]                 }
[10:32:42.361]             }
[10:32:42.361]         }))
[10:32:42.361]     }, error = function(ex) {
[10:32:42.361]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.361]                 ...future.rng), started = ...future.startTime, 
[10:32:42.361]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.361]             version = "1.8"), class = "FutureResult")
[10:32:42.361]     }, finally = {
[10:32:42.361]         if (!identical(...future.workdir, getwd())) 
[10:32:42.361]             setwd(...future.workdir)
[10:32:42.361]         {
[10:32:42.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.361]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.361]             }
[10:32:42.361]             base::options(...future.oldOptions)
[10:32:42.361]             if (.Platform$OS.type == "windows") {
[10:32:42.361]                 old_names <- names(...future.oldEnvVars)
[10:32:42.361]                 envs <- base::Sys.getenv()
[10:32:42.361]                 names <- names(envs)
[10:32:42.361]                 common <- intersect(names, old_names)
[10:32:42.361]                 added <- setdiff(names, old_names)
[10:32:42.361]                 removed <- setdiff(old_names, names)
[10:32:42.361]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.361]                   envs[common]]
[10:32:42.361]                 NAMES <- toupper(changed)
[10:32:42.361]                 args <- list()
[10:32:42.361]                 for (kk in seq_along(NAMES)) {
[10:32:42.361]                   name <- changed[[kk]]
[10:32:42.361]                   NAME <- NAMES[[kk]]
[10:32:42.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.361]                     next
[10:32:42.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.361]                 }
[10:32:42.361]                 NAMES <- toupper(added)
[10:32:42.361]                 for (kk in seq_along(NAMES)) {
[10:32:42.361]                   name <- added[[kk]]
[10:32:42.361]                   NAME <- NAMES[[kk]]
[10:32:42.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.361]                     next
[10:32:42.361]                   args[[name]] <- ""
[10:32:42.361]                 }
[10:32:42.361]                 NAMES <- toupper(removed)
[10:32:42.361]                 for (kk in seq_along(NAMES)) {
[10:32:42.361]                   name <- removed[[kk]]
[10:32:42.361]                   NAME <- NAMES[[kk]]
[10:32:42.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.361]                     next
[10:32:42.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.361]                 }
[10:32:42.361]                 if (length(args) > 0) 
[10:32:42.361]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.361]             }
[10:32:42.361]             else {
[10:32:42.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.361]             }
[10:32:42.361]             {
[10:32:42.361]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.361]                   0L) {
[10:32:42.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.361]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.361]                   base::options(opts)
[10:32:42.361]                 }
[10:32:42.361]                 {
[10:32:42.361]                   {
[10:32:42.361]                     NULL
[10:32:42.361]                     RNGkind("Mersenne-Twister")
[10:32:42.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:42.361]                       inherits = FALSE)
[10:32:42.361]                   }
[10:32:42.361]                   options(future.plan = NULL)
[10:32:42.361]                   if (is.na(NA_character_)) 
[10:32:42.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.361]                     .init = FALSE)
[10:32:42.361]                 }
[10:32:42.361]             }
[10:32:42.361]         }
[10:32:42.361]     })
[10:32:42.361]     if (TRUE) {
[10:32:42.361]         base::sink(type = "output", split = FALSE)
[10:32:42.361]         if (TRUE) {
[10:32:42.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.361]         }
[10:32:42.361]         else {
[10:32:42.361]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.361]         }
[10:32:42.361]         base::close(...future.stdout)
[10:32:42.361]         ...future.stdout <- NULL
[10:32:42.361]     }
[10:32:42.361]     ...future.result$conditions <- ...future.conditions
[10:32:42.361]     ...future.result$finished <- base::Sys.time()
[10:32:42.361]     ...future.result
[10:32:42.361] }
[10:32:42.400]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.363] plan(): Setting new future strategy stack:
[10:32:42.400]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.364] List of future strategies:
[10:32:42.364] 1. sequential:
[10:32:42.364]    - args: function (..., envir = parent.frame())
[10:32:42.364]    - tweaked: FALSE
[10:32:42.364]    - call: NULL
[10:32:42.400]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.364] plan(): nbrOfWorkers() = 1
[10:32:42.400]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.365] plan(): Setting new future strategy stack:
[10:32:42.400]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.366] List of future strategies:
[10:32:42.366] 1. sequential:
[10:32:42.366]    - args: function (..., envir = parent.frame())
[10:32:42.366]    - tweaked: FALSE
[10:32:42.366]    - call: NULL
[10:32:42.401]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.366] plan(): nbrOfWorkers() = 1
[10:32:42.401]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.366] SequentialFuture started (and completed)
[10:32:42.401]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.367] - Launch lazy future ... done
[10:32:42.401]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.367] run() for ‘SequentialFuture’ ... done
[10:32:42.401]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.367] getGlobalsAndPackages() ...
[10:32:42.401]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.367] Searching for globals...
[10:32:42.402]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.368] 
[10:32:42.402]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.368] Searching for globals ... DONE
[10:32:42.402]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.368] - globals: [0] <none>
[10:32:42.402]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.368] getGlobalsAndPackages() ... DONE
[10:32:42.402]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.369] run() for ‘Future’ ...
[10:32:42.402]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.369] - state: ‘created’
[10:32:42.402]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.369] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:42.403]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.370] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:42.403]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.370] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:42.403]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.370]   - Field: ‘label’
[10:32:42.403]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.370]   - Field: ‘local’
[10:32:42.403]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.370]   - Field: ‘owner’
[10:32:42.403]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.370]   - Field: ‘envir’
[10:32:42.404]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.371]   - Field: ‘packages’
[10:32:42.404]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.371]   - Field: ‘gc’
[10:32:42.404]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.371]   - Field: ‘conditions’
[10:32:42.404]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.371]   - Field: ‘expr’
[10:32:42.404]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.371]   - Field: ‘uuid’
[10:32:42.404]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.371]   - Field: ‘seed’
[10:32:42.405]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘version’
[10:32:42.405]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘result’
[10:32:42.405]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘asynchronous’
[10:32:42.405]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘calls’
[10:32:42.405]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘globals’
[10:32:42.405]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘stdout’
[10:32:42.406]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.372]   - Field: ‘earlySignal’
[10:32:42.406]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.373]   - Field: ‘lazy’
[10:32:42.406]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.373]   - Field: ‘state’
[10:32:42.406]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:42.406]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.373] - Launch lazy future ...
[10:32:42.406]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.373] Packages needed by the future expression (n = 0): <none>
[10:32:42.406]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.374] Packages needed by future strategies (n = 0): <none>
[10:32:42.407]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.374] {
[10:32:42.374]     {
[10:32:42.374]         {
[10:32:42.374]             ...future.startTime <- base::Sys.time()
[10:32:42.374]             {
[10:32:42.374]                 {
[10:32:42.374]                   {
[10:32:42.374]                     base::local({
[10:32:42.374]                       has_future <- base::requireNamespace("future", 
[10:32:42.374]                         quietly = TRUE)
[10:32:42.374]                       if (has_future) {
[10:32:42.374]                         ns <- base::getNamespace("future")
[10:32:42.374]                         version <- ns[[".package"]][["version"]]
[10:32:42.374]                         if (is.null(version)) 
[10:32:42.374]                           version <- utils::packageVersion("future")
[10:32:42.374]                       }
[10:32:42.374]                       else {
[10:32:42.374]                         version <- NULL
[10:32:42.374]                       }
[10:32:42.374]                       if (!has_future || version < "1.8.0") {
[10:32:42.374]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.374]                           "", base::R.version$version.string), 
[10:32:42.374]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:42.374]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.374]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.374]                             "release", "version")], collapse = " "), 
[10:32:42.374]                           hostname = base::Sys.info()[["nodename"]])
[10:32:42.374]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.374]                           info)
[10:32:42.374]                         info <- base::paste(info, collapse = "; ")
[10:32:42.374]                         if (!has_future) {
[10:32:42.374]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.374]                             info)
[10:32:42.374]                         }
[10:32:42.374]                         else {
[10:32:42.374]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.374]                             info, version)
[10:32:42.374]                         }
[10:32:42.374]                         base::stop(msg)
[10:32:42.374]                       }
[10:32:42.374]                     })
[10:32:42.374]                   }
[10:32:42.374]                   ...future.strategy.old <- future::plan("list")
[10:32:42.374]                   options(future.plan = NULL)
[10:32:42.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.374]                 }
[10:32:42.374]                 ...future.workdir <- getwd()
[10:32:42.374]             }
[10:32:42.374]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.374]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.374]         }
[10:32:42.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.374]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.374]             base::names(...future.oldOptions))
[10:32:42.374]     }
[10:32:42.374]     if (FALSE) {
[10:32:42.374]     }
[10:32:42.374]     else {
[10:32:42.374]         if (TRUE) {
[10:32:42.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.374]                 open = "w")
[10:32:42.374]         }
[10:32:42.374]         else {
[10:32:42.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.374]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.374]         }
[10:32:42.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.374]             base::sink(type = "output", split = FALSE)
[10:32:42.374]             base::close(...future.stdout)
[10:32:42.374]         }, add = TRUE)
[10:32:42.374]     }
[10:32:42.374]     ...future.frame <- base::sys.nframe()
[10:32:42.374]     ...future.conditions <- base::list()
[10:32:42.374]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.374]     if (FALSE) {
[10:32:42.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.374]     }
[10:32:42.374]     ...future.result <- base::tryCatch({
[10:32:42.374]         base::withCallingHandlers({
[10:32:42.374]             ...future.value <- base::withVisible(base::local(4))
[10:32:42.374]             future::FutureResult(value = ...future.value$value, 
[10:32:42.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.374]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.374]                     ...future.globalenv.names))
[10:32:42.374]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.374]         }, condition = base::local({
[10:32:42.374]             c <- base::c
[10:32:42.374]             inherits <- base::inherits
[10:32:42.374]             invokeRestart <- base::invokeRestart
[10:32:42.374]             length <- base::length
[10:32:42.374]             list <- base::list
[10:32:42.374]             seq.int <- base::seq.int
[10:32:42.374]             signalCondition <- base::signalCondition
[10:32:42.374]             sys.calls <- base::sys.calls
[10:32:42.374]             `[[` <- base::`[[`
[10:32:42.374]             `+` <- base::`+`
[10:32:42.374]             `<<-` <- base::`<<-`
[10:32:42.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.374]                   3L)]
[10:32:42.374]             }
[10:32:42.374]             function(cond) {
[10:32:42.374]                 is_error <- inherits(cond, "error")
[10:32:42.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.374]                   NULL)
[10:32:42.374]                 if (is_error) {
[10:32:42.374]                   sessionInformation <- function() {
[10:32:42.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.374]                       search = base::search(), system = base::Sys.info())
[10:32:42.374]                   }
[10:32:42.374]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.374]                     cond$call), session = sessionInformation(), 
[10:32:42.374]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.374]                   signalCondition(cond)
[10:32:42.374]                 }
[10:32:42.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.374]                 "immediateCondition"))) {
[10:32:42.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.374]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.374]                   if (TRUE && !signal) {
[10:32:42.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.374]                     {
[10:32:42.374]                       inherits <- base::inherits
[10:32:42.374]                       invokeRestart <- base::invokeRestart
[10:32:42.374]                       is.null <- base::is.null
[10:32:42.374]                       muffled <- FALSE
[10:32:42.374]                       if (inherits(cond, "message")) {
[10:32:42.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.374]                         if (muffled) 
[10:32:42.374]                           invokeRestart("muffleMessage")
[10:32:42.374]                       }
[10:32:42.374]                       else if (inherits(cond, "warning")) {
[10:32:42.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.374]                         if (muffled) 
[10:32:42.374]                           invokeRestart("muffleWarning")
[10:32:42.374]                       }
[10:32:42.374]                       else if (inherits(cond, "condition")) {
[10:32:42.374]                         if (!is.null(pattern)) {
[10:32:42.374]                           computeRestarts <- base::computeRestarts
[10:32:42.374]                           grepl <- base::grepl
[10:32:42.374]                           restarts <- computeRestarts(cond)
[10:32:42.374]                           for (restart in restarts) {
[10:32:42.374]                             name <- restart$name
[10:32:42.374]                             if (is.null(name)) 
[10:32:42.374]                               next
[10:32:42.374]                             if (!grepl(pattern, name)) 
[10:32:42.374]                               next
[10:32:42.374]                             invokeRestart(restart)
[10:32:42.374]                             muffled <- TRUE
[10:32:42.374]                             break
[10:32:42.374]                           }
[10:32:42.374]                         }
[10:32:42.374]                       }
[10:32:42.374]                       invisible(muffled)
[10:32:42.374]                     }
[10:32:42.374]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.374]                   }
[10:32:42.374]                 }
[10:32:42.374]                 else {
[10:32:42.374]                   if (TRUE) {
[10:32:42.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.374]                     {
[10:32:42.374]                       inherits <- base::inherits
[10:32:42.374]                       invokeRestart <- base::invokeRestart
[10:32:42.374]                       is.null <- base::is.null
[10:32:42.374]                       muffled <- FALSE
[10:32:42.374]                       if (inherits(cond, "message")) {
[10:32:42.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.374]                         if (muffled) 
[10:32:42.374]                           invokeRestart("muffleMessage")
[10:32:42.374]                       }
[10:32:42.374]                       else if (inherits(cond, "warning")) {
[10:32:42.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.374]                         if (muffled) 
[10:32:42.374]                           invokeRestart("muffleWarning")
[10:32:42.374]                       }
[10:32:42.374]                       else if (inherits(cond, "condition")) {
[10:32:42.374]                         if (!is.null(pattern)) {
[10:32:42.374]                           computeRestarts <- base::computeRestarts
[10:32:42.374]                           grepl <- base::grepl
[10:32:42.374]                           restarts <- computeRestarts(cond)
[10:32:42.374]                           for (restart in restarts) {
[10:32:42.374]                             name <- restart$name
[10:32:42.374]                             if (is.null(name)) 
[10:32:42.374]                               next
[10:32:42.374]                             if (!grepl(pattern, name)) 
[10:32:42.374]                               next
[10:32:42.374]                             invokeRestart(restart)
[10:32:42.374]                             muffled <- TRUE
[10:32:42.374]                             break
[10:32:42.374]                           }
[10:32:42.374]                         }
[10:32:42.374]                       }
[10:32:42.374]                       invisible(muffled)
[10:32:42.374]                     }
[10:32:42.374]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.374]                   }
[10:32:42.374]                 }
[10:32:42.374]             }
[10:32:42.374]         }))
[10:32:42.374]     }, error = function(ex) {
[10:32:42.374]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.374]                 ...future.rng), started = ...future.startTime, 
[10:32:42.374]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.374]             version = "1.8"), class = "FutureResult")
[10:32:42.374]     }, finally = {
[10:32:42.374]         if (!identical(...future.workdir, getwd())) 
[10:32:42.374]             setwd(...future.workdir)
[10:32:42.374]         {
[10:32:42.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.374]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.374]             }
[10:32:42.374]             base::options(...future.oldOptions)
[10:32:42.374]             if (.Platform$OS.type == "windows") {
[10:32:42.374]                 old_names <- names(...future.oldEnvVars)
[10:32:42.374]                 envs <- base::Sys.getenv()
[10:32:42.374]                 names <- names(envs)
[10:32:42.374]                 common <- intersect(names, old_names)
[10:32:42.374]                 added <- setdiff(names, old_names)
[10:32:42.374]                 removed <- setdiff(old_names, names)
[10:32:42.374]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.374]                   envs[common]]
[10:32:42.374]                 NAMES <- toupper(changed)
[10:32:42.374]                 args <- list()
[10:32:42.374]                 for (kk in seq_along(NAMES)) {
[10:32:42.374]                   name <- changed[[kk]]
[10:32:42.374]                   NAME <- NAMES[[kk]]
[10:32:42.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.374]                     next
[10:32:42.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.374]                 }
[10:32:42.374]                 NAMES <- toupper(added)
[10:32:42.374]                 for (kk in seq_along(NAMES)) {
[10:32:42.374]                   name <- added[[kk]]
[10:32:42.374]                   NAME <- NAMES[[kk]]
[10:32:42.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.374]                     next
[10:32:42.374]                   args[[name]] <- ""
[10:32:42.374]                 }
[10:32:42.374]                 NAMES <- toupper(removed)
[10:32:42.374]                 for (kk in seq_along(NAMES)) {
[10:32:42.374]                   name <- removed[[kk]]
[10:32:42.374]                   NAME <- NAMES[[kk]]
[10:32:42.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.374]                     next
[10:32:42.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.374]                 }
[10:32:42.374]                 if (length(args) > 0) 
[10:32:42.374]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.374]             }
[10:32:42.374]             else {
[10:32:42.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.374]             }
[10:32:42.374]             {
[10:32:42.374]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.374]                   0L) {
[10:32:42.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.374]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.374]                   base::options(opts)
[10:32:42.374]                 }
[10:32:42.374]                 {
[10:32:42.374]                   {
[10:32:42.374]                     NULL
[10:32:42.374]                     RNGkind("Mersenne-Twister")
[10:32:42.374]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:42.374]                       inherits = FALSE)
[10:32:42.374]                   }
[10:32:42.374]                   options(future.plan = NULL)
[10:32:42.374]                   if (is.na(NA_character_)) 
[10:32:42.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.374]                     .init = FALSE)
[10:32:42.374]                 }
[10:32:42.374]             }
[10:32:42.374]         }
[10:32:42.374]     })
[10:32:42.374]     if (TRUE) {
[10:32:42.374]         base::sink(type = "output", split = FALSE)
[10:32:42.374]         if (TRUE) {
[10:32:42.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.374]         }
[10:32:42.374]         else {
[10:32:42.374]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.374]         }
[10:32:42.374]         base::close(...future.stdout)
[10:32:42.374]         ...future.stdout <- NULL
[10:32:42.374]     }
[10:32:42.374]     ...future.result$conditions <- ...future.conditions
[10:32:42.374]     ...future.result$finished <- base::Sys.time()
[10:32:42.374]     ...future.result
[10:32:42.374] }
[10:32:42.407]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.376] plan(): Setting new future strategy stack:
[10:32:42.407]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.376] List of future strategies:
[10:32:42.376] 1. sequential:
[10:32:42.376]    - args: function (..., envir = parent.frame())
[10:32:42.376]    - tweaked: FALSE
[10:32:42.376]    - call: NULL
[10:32:42.407]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.377] plan(): nbrOfWorkers() = 1
[10:32:42.407]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.378] plan(): Setting new future strategy stack:
[10:32:42.410]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.378] List of future strategies:
[10:32:42.378] 1. sequential:
[10:32:42.378]    - args: function (..., envir = parent.frame())
[10:32:42.378]    - tweaked: FALSE
[10:32:42.378]    - call: NULL
[10:32:42.410]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.382] plan(): nbrOfWorkers() = 1
[10:32:42.410]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.382] SequentialFuture started (and completed)
[10:32:42.410]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.382] - Launch lazy future ... done
[10:32:42.410]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:32:42.382] run() for ‘SequentialFuture’ ... done
[10:32:42.411] signalConditions() ... done
a = 10
[10:32:42.411] getGlobalsAndPackages() ...
[10:32:42.411] Searching for globals...
[10:32:42.413] - globals found: [3] ‘{’, ‘+’, ‘a’
[10:32:42.413] Searching for globals ... DONE
[10:32:42.413] Resolving globals: FALSE
[10:32:42.413] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:42.414] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:32:42.414] - globals: [1] ‘a’
[10:32:42.414] 
[10:32:42.414] getGlobalsAndPackages() ... DONE
[10:32:42.414] run() for ‘Future’ ...
[10:32:42.414] - state: ‘created’
[10:32:42.415] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:42.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:42.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:42.419]   - Field: ‘label’
[10:32:42.419]   - Field: ‘local’
[10:32:42.419]   - Field: ‘owner’
[10:32:42.419]   - Field: ‘envir’
[10:32:42.419]   - Field: ‘workers’
[10:32:42.419]   - Field: ‘packages’
[10:32:42.419]   - Field: ‘gc’
[10:32:42.419]   - Field: ‘job’
[10:32:42.419]   - Field: ‘conditions’
[10:32:42.420]   - Field: ‘expr’
[10:32:42.420]   - Field: ‘uuid’
[10:32:42.420]   - Field: ‘seed’
[10:32:42.420]   - Field: ‘version’
[10:32:42.420]   - Field: ‘result’
[10:32:42.420]   - Field: ‘asynchronous’
[10:32:42.420]   - Field: ‘calls’
[10:32:42.420]   - Field: ‘globals’
[10:32:42.420]   - Field: ‘stdout’
[10:32:42.420]   - Field: ‘earlySignal’
[10:32:42.420]   - Field: ‘lazy’
[10:32:42.421]   - Field: ‘state’
[10:32:42.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:42.421] - Launch lazy future ...
[10:32:42.421] Packages needed by the future expression (n = 0): <none>
[10:32:42.421] Packages needed by future strategies (n = 0): <none>
[10:32:42.422] {
[10:32:42.422]     {
[10:32:42.422]         {
[10:32:42.422]             ...future.startTime <- base::Sys.time()
[10:32:42.422]             {
[10:32:42.422]                 {
[10:32:42.422]                   {
[10:32:42.422]                     {
[10:32:42.422]                       base::local({
[10:32:42.422]                         has_future <- base::requireNamespace("future", 
[10:32:42.422]                           quietly = TRUE)
[10:32:42.422]                         if (has_future) {
[10:32:42.422]                           ns <- base::getNamespace("future")
[10:32:42.422]                           version <- ns[[".package"]][["version"]]
[10:32:42.422]                           if (is.null(version)) 
[10:32:42.422]                             version <- utils::packageVersion("future")
[10:32:42.422]                         }
[10:32:42.422]                         else {
[10:32:42.422]                           version <- NULL
[10:32:42.422]                         }
[10:32:42.422]                         if (!has_future || version < "1.8.0") {
[10:32:42.422]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.422]                             "", base::R.version$version.string), 
[10:32:42.422]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.422]                               "release", "version")], collapse = " "), 
[10:32:42.422]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.422]                             info)
[10:32:42.422]                           info <- base::paste(info, collapse = "; ")
[10:32:42.422]                           if (!has_future) {
[10:32:42.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.422]                               info)
[10:32:42.422]                           }
[10:32:42.422]                           else {
[10:32:42.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.422]                               info, version)
[10:32:42.422]                           }
[10:32:42.422]                           base::stop(msg)
[10:32:42.422]                         }
[10:32:42.422]                       })
[10:32:42.422]                     }
[10:32:42.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.422]                     base::options(mc.cores = 1L)
[10:32:42.422]                   }
[10:32:42.422]                   ...future.strategy.old <- future::plan("list")
[10:32:42.422]                   options(future.plan = NULL)
[10:32:42.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.422]                 }
[10:32:42.422]                 ...future.workdir <- getwd()
[10:32:42.422]             }
[10:32:42.422]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.422]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.422]         }
[10:32:42.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.422]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.422]             base::names(...future.oldOptions))
[10:32:42.422]     }
[10:32:42.422]     if (FALSE) {
[10:32:42.422]     }
[10:32:42.422]     else {
[10:32:42.422]         if (TRUE) {
[10:32:42.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.422]                 open = "w")
[10:32:42.422]         }
[10:32:42.422]         else {
[10:32:42.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.422]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.422]         }
[10:32:42.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.422]             base::sink(type = "output", split = FALSE)
[10:32:42.422]             base::close(...future.stdout)
[10:32:42.422]         }, add = TRUE)
[10:32:42.422]     }
[10:32:42.422]     ...future.frame <- base::sys.nframe()
[10:32:42.422]     ...future.conditions <- base::list()
[10:32:42.422]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.422]     if (FALSE) {
[10:32:42.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.422]     }
[10:32:42.422]     ...future.result <- base::tryCatch({
[10:32:42.422]         base::withCallingHandlers({
[10:32:42.422]             ...future.value <- base::withVisible(base::local({
[10:32:42.422]                 withCallingHandlers({
[10:32:42.422]                   {
[10:32:42.422]                     a + 1
[10:32:42.422]                   }
[10:32:42.422]                 }, immediateCondition = function(cond) {
[10:32:42.422]                   save_rds <- function (object, pathname, ...) 
[10:32:42.422]                   {
[10:32:42.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:42.422]                     if (file_test("-f", pathname_tmp)) {
[10:32:42.422]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:42.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.422]                         fi_tmp[["mtime"]])
[10:32:42.422]                     }
[10:32:42.422]                     tryCatch({
[10:32:42.422]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:42.422]                     }, error = function(ex) {
[10:32:42.422]                       msg <- conditionMessage(ex)
[10:32:42.422]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:42.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.422]                         fi_tmp[["mtime"]], msg)
[10:32:42.422]                       ex$message <- msg
[10:32:42.422]                       stop(ex)
[10:32:42.422]                     })
[10:32:42.422]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:42.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:42.422]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:42.422]                       fi_tmp <- file.info(pathname_tmp)
[10:32:42.422]                       fi <- file.info(pathname)
[10:32:42.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:42.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:42.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:42.422]                         fi[["size"]], fi[["mtime"]])
[10:32:42.422]                       stop(msg)
[10:32:42.422]                     }
[10:32:42.422]                     invisible(pathname)
[10:32:42.422]                   }
[10:32:42.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:42.422]                     rootPath = tempdir()) 
[10:32:42.422]                   {
[10:32:42.422]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:42.422]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:42.422]                       tmpdir = path, fileext = ".rds")
[10:32:42.422]                     save_rds(obj, file)
[10:32:42.422]                   }
[10:32:42.422]                   saveImmediateCondition(cond, path = "/tmp/RtmpAFrw2x/.future/immediateConditions")
[10:32:42.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.422]                   {
[10:32:42.422]                     inherits <- base::inherits
[10:32:42.422]                     invokeRestart <- base::invokeRestart
[10:32:42.422]                     is.null <- base::is.null
[10:32:42.422]                     muffled <- FALSE
[10:32:42.422]                     if (inherits(cond, "message")) {
[10:32:42.422]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.422]                       if (muffled) 
[10:32:42.422]                         invokeRestart("muffleMessage")
[10:32:42.422]                     }
[10:32:42.422]                     else if (inherits(cond, "warning")) {
[10:32:42.422]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.422]                       if (muffled) 
[10:32:42.422]                         invokeRestart("muffleWarning")
[10:32:42.422]                     }
[10:32:42.422]                     else if (inherits(cond, "condition")) {
[10:32:42.422]                       if (!is.null(pattern)) {
[10:32:42.422]                         computeRestarts <- base::computeRestarts
[10:32:42.422]                         grepl <- base::grepl
[10:32:42.422]                         restarts <- computeRestarts(cond)
[10:32:42.422]                         for (restart in restarts) {
[10:32:42.422]                           name <- restart$name
[10:32:42.422]                           if (is.null(name)) 
[10:32:42.422]                             next
[10:32:42.422]                           if (!grepl(pattern, name)) 
[10:32:42.422]                             next
[10:32:42.422]                           invokeRestart(restart)
[10:32:42.422]                           muffled <- TRUE
[10:32:42.422]                           break
[10:32:42.422]                         }
[10:32:42.422]                       }
[10:32:42.422]                     }
[10:32:42.422]                     invisible(muffled)
[10:32:42.422]                   }
[10:32:42.422]                   muffleCondition(cond)
[10:32:42.422]                 })
[10:32:42.422]             }))
[10:32:42.422]             future::FutureResult(value = ...future.value$value, 
[10:32:42.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.422]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.422]                     ...future.globalenv.names))
[10:32:42.422]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.422]         }, condition = base::local({
[10:32:42.422]             c <- base::c
[10:32:42.422]             inherits <- base::inherits
[10:32:42.422]             invokeRestart <- base::invokeRestart
[10:32:42.422]             length <- base::length
[10:32:42.422]             list <- base::list
[10:32:42.422]             seq.int <- base::seq.int
[10:32:42.422]             signalCondition <- base::signalCondition
[10:32:42.422]             sys.calls <- base::sys.calls
[10:32:42.422]             `[[` <- base::`[[`
[10:32:42.422]             `+` <- base::`+`
[10:32:42.422]             `<<-` <- base::`<<-`
[10:32:42.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.422]                   3L)]
[10:32:42.422]             }
[10:32:42.422]             function(cond) {
[10:32:42.422]                 is_error <- inherits(cond, "error")
[10:32:42.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.422]                   NULL)
[10:32:42.422]                 if (is_error) {
[10:32:42.422]                   sessionInformation <- function() {
[10:32:42.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.422]                       search = base::search(), system = base::Sys.info())
[10:32:42.422]                   }
[10:32:42.422]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.422]                     cond$call), session = sessionInformation(), 
[10:32:42.422]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.422]                   signalCondition(cond)
[10:32:42.422]                 }
[10:32:42.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.422]                 "immediateCondition"))) {
[10:32:42.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.422]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.422]                   if (TRUE && !signal) {
[10:32:42.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.422]                     {
[10:32:42.422]                       inherits <- base::inherits
[10:32:42.422]                       invokeRestart <- base::invokeRestart
[10:32:42.422]                       is.null <- base::is.null
[10:32:42.422]                       muffled <- FALSE
[10:32:42.422]                       if (inherits(cond, "message")) {
[10:32:42.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.422]                         if (muffled) 
[10:32:42.422]                           invokeRestart("muffleMessage")
[10:32:42.422]                       }
[10:32:42.422]                       else if (inherits(cond, "warning")) {
[10:32:42.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.422]                         if (muffled) 
[10:32:42.422]                           invokeRestart("muffleWarning")
[10:32:42.422]                       }
[10:32:42.422]                       else if (inherits(cond, "condition")) {
[10:32:42.422]                         if (!is.null(pattern)) {
[10:32:42.422]                           computeRestarts <- base::computeRestarts
[10:32:42.422]                           grepl <- base::grepl
[10:32:42.422]                           restarts <- computeRestarts(cond)
[10:32:42.422]                           for (restart in restarts) {
[10:32:42.422]                             name <- restart$name
[10:32:42.422]                             if (is.null(name)) 
[10:32:42.422]                               next
[10:32:42.422]                             if (!grepl(pattern, name)) 
[10:32:42.422]                               next
[10:32:42.422]                             invokeRestart(restart)
[10:32:42.422]                             muffled <- TRUE
[10:32:42.422]                             break
[10:32:42.422]                           }
[10:32:42.422]                         }
[10:32:42.422]                       }
[10:32:42.422]                       invisible(muffled)
[10:32:42.422]                     }
[10:32:42.422]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.422]                   }
[10:32:42.422]                 }
[10:32:42.422]                 else {
[10:32:42.422]                   if (TRUE) {
[10:32:42.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.422]                     {
[10:32:42.422]                       inherits <- base::inherits
[10:32:42.422]                       invokeRestart <- base::invokeRestart
[10:32:42.422]                       is.null <- base::is.null
[10:32:42.422]                       muffled <- FALSE
[10:32:42.422]                       if (inherits(cond, "message")) {
[10:32:42.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.422]                         if (muffled) 
[10:32:42.422]                           invokeRestart("muffleMessage")
[10:32:42.422]                       }
[10:32:42.422]                       else if (inherits(cond, "warning")) {
[10:32:42.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.422]                         if (muffled) 
[10:32:42.422]                           invokeRestart("muffleWarning")
[10:32:42.422]                       }
[10:32:42.422]                       else if (inherits(cond, "condition")) {
[10:32:42.422]                         if (!is.null(pattern)) {
[10:32:42.422]                           computeRestarts <- base::computeRestarts
[10:32:42.422]                           grepl <- base::grepl
[10:32:42.422]                           restarts <- computeRestarts(cond)
[10:32:42.422]                           for (restart in restarts) {
[10:32:42.422]                             name <- restart$name
[10:32:42.422]                             if (is.null(name)) 
[10:32:42.422]                               next
[10:32:42.422]                             if (!grepl(pattern, name)) 
[10:32:42.422]                               next
[10:32:42.422]                             invokeRestart(restart)
[10:32:42.422]                             muffled <- TRUE
[10:32:42.422]                             break
[10:32:42.422]                           }
[10:32:42.422]                         }
[10:32:42.422]                       }
[10:32:42.422]                       invisible(muffled)
[10:32:42.422]                     }
[10:32:42.422]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.422]                   }
[10:32:42.422]                 }
[10:32:42.422]             }
[10:32:42.422]         }))
[10:32:42.422]     }, error = function(ex) {
[10:32:42.422]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.422]                 ...future.rng), started = ...future.startTime, 
[10:32:42.422]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.422]             version = "1.8"), class = "FutureResult")
[10:32:42.422]     }, finally = {
[10:32:42.422]         if (!identical(...future.workdir, getwd())) 
[10:32:42.422]             setwd(...future.workdir)
[10:32:42.422]         {
[10:32:42.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.422]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.422]             }
[10:32:42.422]             base::options(...future.oldOptions)
[10:32:42.422]             if (.Platform$OS.type == "windows") {
[10:32:42.422]                 old_names <- names(...future.oldEnvVars)
[10:32:42.422]                 envs <- base::Sys.getenv()
[10:32:42.422]                 names <- names(envs)
[10:32:42.422]                 common <- intersect(names, old_names)
[10:32:42.422]                 added <- setdiff(names, old_names)
[10:32:42.422]                 removed <- setdiff(old_names, names)
[10:32:42.422]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.422]                   envs[common]]
[10:32:42.422]                 NAMES <- toupper(changed)
[10:32:42.422]                 args <- list()
[10:32:42.422]                 for (kk in seq_along(NAMES)) {
[10:32:42.422]                   name <- changed[[kk]]
[10:32:42.422]                   NAME <- NAMES[[kk]]
[10:32:42.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.422]                     next
[10:32:42.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.422]                 }
[10:32:42.422]                 NAMES <- toupper(added)
[10:32:42.422]                 for (kk in seq_along(NAMES)) {
[10:32:42.422]                   name <- added[[kk]]
[10:32:42.422]                   NAME <- NAMES[[kk]]
[10:32:42.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.422]                     next
[10:32:42.422]                   args[[name]] <- ""
[10:32:42.422]                 }
[10:32:42.422]                 NAMES <- toupper(removed)
[10:32:42.422]                 for (kk in seq_along(NAMES)) {
[10:32:42.422]                   name <- removed[[kk]]
[10:32:42.422]                   NAME <- NAMES[[kk]]
[10:32:42.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.422]                     next
[10:32:42.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.422]                 }
[10:32:42.422]                 if (length(args) > 0) 
[10:32:42.422]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.422]             }
[10:32:42.422]             else {
[10:32:42.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.422]             }
[10:32:42.422]             {
[10:32:42.422]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.422]                   0L) {
[10:32:42.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.422]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.422]                   base::options(opts)
[10:32:42.422]                 }
[10:32:42.422]                 {
[10:32:42.422]                   {
[10:32:42.422]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.422]                     NULL
[10:32:42.422]                   }
[10:32:42.422]                   options(future.plan = NULL)
[10:32:42.422]                   if (is.na(NA_character_)) 
[10:32:42.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.422]                     .init = FALSE)
[10:32:42.422]                 }
[10:32:42.422]             }
[10:32:42.422]         }
[10:32:42.422]     })
[10:32:42.422]     if (TRUE) {
[10:32:42.422]         base::sink(type = "output", split = FALSE)
[10:32:42.422]         if (TRUE) {
[10:32:42.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.422]         }
[10:32:42.422]         else {
[10:32:42.422]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.422]         }
[10:32:42.422]         base::close(...future.stdout)
[10:32:42.422]         ...future.stdout <- NULL
[10:32:42.422]     }
[10:32:42.422]     ...future.result$conditions <- ...future.conditions
[10:32:42.422]     ...future.result$finished <- base::Sys.time()
[10:32:42.422]     ...future.result
[10:32:42.422] }
[10:32:42.424] assign_globals() ...
[10:32:42.424] List of 1
[10:32:42.424]  $ a: num 10
[10:32:42.424]  - attr(*, "where")=List of 1
[10:32:42.424]   ..$ a:<environment: R_EmptyEnv> 
[10:32:42.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:42.424]  - attr(*, "resolved")= logi FALSE
[10:32:42.424]  - attr(*, "total_size")= num 56
[10:32:42.424]  - attr(*, "already-done")= logi TRUE
[10:32:42.427] - copied ‘a’ to environment
[10:32:42.427] assign_globals() ... done
[10:32:42.427] requestCore(): workers = 2
[10:32:42.429] MulticoreFuture started
[10:32:42.429] - Launch lazy future ... done
[10:32:42.429] run() for ‘MulticoreFuture’ ... done
[10:32:42.430] result() for MulticoreFuture ...
[10:32:42.430] plan(): Setting new future strategy stack:
[10:32:42.430] List of future strategies:
[10:32:42.430] 1. sequential:
[10:32:42.430]    - args: function (..., envir = parent.frame())
[10:32:42.430]    - tweaked: FALSE
[10:32:42.430]    - call: NULL
[10:32:42.431] plan(): nbrOfWorkers() = 1
[10:32:42.433] plan(): Setting new future strategy stack:
[10:32:42.433] List of future strategies:
[10:32:42.433] 1. multicore:
[10:32:42.433]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:42.433]    - tweaked: FALSE
[10:32:42.433]    - call: plan(strategy)
[10:32:42.438] plan(): nbrOfWorkers() = 2
[10:32:42.439] result() for MulticoreFuture ...
[10:32:42.439] result() for MulticoreFuture ... done
[10:32:42.439] result() for MulticoreFuture ... done
[10:32:42.439] result() for MulticoreFuture ...
[10:32:42.439] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[10:32:42.440] plan(): Setting new future strategy stack:
[10:32:42.440] List of future strategies:
[10:32:42.440] 1. multisession:
[10:32:42.440]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:42.440]    - tweaked: FALSE
[10:32:42.440]    - call: plan(strategy)
[10:32:42.441] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:32:42.441] multisession:
[10:32:42.441] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:42.441] - tweaked: FALSE
[10:32:42.441] - call: plan(strategy)
[10:32:42.447] getGlobalsAndPackages() ...
[10:32:42.448] Not searching for globals
[10:32:42.448] - globals: [0] <none>
[10:32:42.448] getGlobalsAndPackages() ... DONE
[10:32:42.449] [local output] makeClusterPSOCK() ...
[10:32:42.494] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:32:42.495] [local output] Base port: 11855
[10:32:42.495] [local output] Getting setup options for 2 cluster nodes ...
[10:32:42.495] [local output]  - Node 1 of 2 ...
[10:32:42.495] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:42.496] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpAFrw2x/worker.rank=1.parallelly.parent=80875.13beb6dc449d7.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpAFrw2x/worker.rank=1.parallelly.parent=80875.13beb6dc449d7.pid")'’
[10:32:42.684] - Possible to infer worker's PID: TRUE
[10:32:42.684] [local output] Rscript port: 11855

[10:32:42.684] [local output]  - Node 2 of 2 ...
[10:32:42.685] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:42.685] [local output] Rscript port: 11855

[10:32:42.686] [local output] Getting setup options for 2 cluster nodes ... done
[10:32:42.686] [local output]  - Parallel setup requested for some PSOCK nodes
[10:32:42.686] [local output] Setting up PSOCK nodes in parallel
[10:32:42.686] List of 36
[10:32:42.686]  $ worker          : chr "localhost"
[10:32:42.686]   ..- attr(*, "localhost")= logi TRUE
[10:32:42.686]  $ master          : chr "localhost"
[10:32:42.686]  $ port            : int 11855
[10:32:42.686]  $ connectTimeout  : num 120
[10:32:42.686]  $ timeout         : num 2592000
[10:32:42.686]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:32:42.686]  $ homogeneous     : logi TRUE
[10:32:42.686]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:32:42.686]  $ rscript_envs    : NULL
[10:32:42.686]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:42.686]  $ rscript_startup : NULL
[10:32:42.686]  $ rscript_sh      : chr "sh"
[10:32:42.686]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:42.686]  $ methods         : logi TRUE
[10:32:42.686]  $ socketOptions   : chr "no-delay"
[10:32:42.686]  $ useXDR          : logi FALSE
[10:32:42.686]  $ outfile         : chr "/dev/null"
[10:32:42.686]  $ renice          : int NA
[10:32:42.686]  $ rshcmd          : NULL
[10:32:42.686]  $ user            : chr(0) 
[10:32:42.686]  $ revtunnel       : logi FALSE
[10:32:42.686]  $ rshlogfile      : NULL
[10:32:42.686]  $ rshopts         : chr(0) 
[10:32:42.686]  $ rank            : int 1
[10:32:42.686]  $ manual          : logi FALSE
[10:32:42.686]  $ dryrun          : logi FALSE
[10:32:42.686]  $ quiet           : logi FALSE
[10:32:42.686]  $ setup_strategy  : chr "parallel"
[10:32:42.686]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:42.686]  $ pidfile         : chr "/tmp/RtmpAFrw2x/worker.rank=1.parallelly.parent=80875.13beb6dc449d7.pid"
[10:32:42.686]  $ rshcmd_label    : NULL
[10:32:42.686]  $ rsh_call        : NULL
[10:32:42.686]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:42.686]  $ localMachine    : logi TRUE
[10:32:42.686]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:32:42.686]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:32:42.686]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:32:42.686]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:32:42.686]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:32:42.686]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:32:42.686]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:32:42.686]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:32:42.686]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:32:42.686]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:32:42.686]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:32:42.686]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:32:42.686]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:32:42.686]  $ arguments       :List of 28
[10:32:42.686]   ..$ worker          : chr "localhost"
[10:32:42.686]   ..$ master          : NULL
[10:32:42.686]   ..$ port            : int 11855
[10:32:42.686]   ..$ connectTimeout  : num 120
[10:32:42.686]   ..$ timeout         : num 2592000
[10:32:42.686]   ..$ rscript         : NULL
[10:32:42.686]   ..$ homogeneous     : NULL
[10:32:42.686]   ..$ rscript_args    : NULL
[10:32:42.686]   ..$ rscript_envs    : NULL
[10:32:42.686]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:42.686]   ..$ rscript_startup : NULL
[10:32:42.686]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:32:42.686]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:42.686]   ..$ methods         : logi TRUE
[10:32:42.686]   ..$ socketOptions   : chr "no-delay"
[10:32:42.686]   ..$ useXDR          : logi FALSE
[10:32:42.686]   ..$ outfile         : chr "/dev/null"
[10:32:42.686]   ..$ renice          : int NA
[10:32:42.686]   ..$ rshcmd          : NULL
[10:32:42.686]   ..$ user            : NULL
[10:32:42.686]   ..$ revtunnel       : logi NA
[10:32:42.686]   ..$ rshlogfile      : NULL
[10:32:42.686]   ..$ rshopts         : NULL
[10:32:42.686]   ..$ rank            : int 1
[10:32:42.686]   ..$ manual          : logi FALSE
[10:32:42.686]   ..$ dryrun          : logi FALSE
[10:32:42.686]   ..$ quiet           : logi FALSE
[10:32:42.686]   ..$ setup_strategy  : chr "parallel"
[10:32:42.686]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:32:42.703] [local output] System call to launch all workers:
[10:32:42.703] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpAFrw2x/worker.rank=1.parallelly.parent=80875.13beb6dc449d7.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11855 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:32:42.704] [local output] Starting PSOCK main server
[10:32:42.709] [local output] Workers launched
[10:32:42.709] [local output] Waiting for workers to connect back
[10:32:42.710]  - [local output] 0 workers out of 2 ready
[10:32:42.949]  - [local output] 0 workers out of 2 ready
[10:32:42.950]  - [local output] 1 workers out of 2 ready
[10:32:42.953]  - [local output] 1 workers out of 2 ready
[10:32:42.953]  - [local output] 2 workers out of 2 ready
[10:32:42.953] [local output] Launching of workers completed
[10:32:42.954] [local output] Collecting session information from workers
[10:32:42.955] [local output]  - Worker #1 of 2
[10:32:42.955] [local output]  - Worker #2 of 2
[10:32:42.955] [local output] makeClusterPSOCK() ... done
[10:32:42.967] Packages needed by the future expression (n = 0): <none>
[10:32:42.967] Packages needed by future strategies (n = 0): <none>
[10:32:42.967] {
[10:32:42.967]     {
[10:32:42.967]         {
[10:32:42.967]             ...future.startTime <- base::Sys.time()
[10:32:42.967]             {
[10:32:42.967]                 {
[10:32:42.967]                   {
[10:32:42.967]                     {
[10:32:42.967]                       base::local({
[10:32:42.967]                         has_future <- base::requireNamespace("future", 
[10:32:42.967]                           quietly = TRUE)
[10:32:42.967]                         if (has_future) {
[10:32:42.967]                           ns <- base::getNamespace("future")
[10:32:42.967]                           version <- ns[[".package"]][["version"]]
[10:32:42.967]                           if (is.null(version)) 
[10:32:42.967]                             version <- utils::packageVersion("future")
[10:32:42.967]                         }
[10:32:42.967]                         else {
[10:32:42.967]                           version <- NULL
[10:32:42.967]                         }
[10:32:42.967]                         if (!has_future || version < "1.8.0") {
[10:32:42.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:42.967]                             "", base::R.version$version.string), 
[10:32:42.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:42.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:42.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:42.967]                               "release", "version")], collapse = " "), 
[10:32:42.967]                             hostname = base::Sys.info()[["nodename"]])
[10:32:42.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:42.967]                             info)
[10:32:42.967]                           info <- base::paste(info, collapse = "; ")
[10:32:42.967]                           if (!has_future) {
[10:32:42.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:42.967]                               info)
[10:32:42.967]                           }
[10:32:42.967]                           else {
[10:32:42.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:42.967]                               info, version)
[10:32:42.967]                           }
[10:32:42.967]                           base::stop(msg)
[10:32:42.967]                         }
[10:32:42.967]                       })
[10:32:42.967]                     }
[10:32:42.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:42.967]                     base::options(mc.cores = 1L)
[10:32:42.967]                   }
[10:32:42.967]                   ...future.strategy.old <- future::plan("list")
[10:32:42.967]                   options(future.plan = NULL)
[10:32:42.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:42.967]                 }
[10:32:42.967]                 ...future.workdir <- getwd()
[10:32:42.967]             }
[10:32:42.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:42.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:42.967]         }
[10:32:42.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:42.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:42.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:42.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:42.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:42.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:42.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:42.967]             base::names(...future.oldOptions))
[10:32:42.967]     }
[10:32:42.967]     if (FALSE) {
[10:32:42.967]     }
[10:32:42.967]     else {
[10:32:42.967]         if (TRUE) {
[10:32:42.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:42.967]                 open = "w")
[10:32:42.967]         }
[10:32:42.967]         else {
[10:32:42.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:42.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:42.967]         }
[10:32:42.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:42.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:42.967]             base::sink(type = "output", split = FALSE)
[10:32:42.967]             base::close(...future.stdout)
[10:32:42.967]         }, add = TRUE)
[10:32:42.967]     }
[10:32:42.967]     ...future.frame <- base::sys.nframe()
[10:32:42.967]     ...future.conditions <- base::list()
[10:32:42.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:42.967]     if (FALSE) {
[10:32:42.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:42.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:42.967]     }
[10:32:42.967]     ...future.result <- base::tryCatch({
[10:32:42.967]         base::withCallingHandlers({
[10:32:42.967]             ...future.value <- base::withVisible(base::local({
[10:32:42.967]                 ...future.makeSendCondition <- base::local({
[10:32:42.967]                   sendCondition <- NULL
[10:32:42.967]                   function(frame = 1L) {
[10:32:42.967]                     if (is.function(sendCondition)) 
[10:32:42.967]                       return(sendCondition)
[10:32:42.967]                     ns <- getNamespace("parallel")
[10:32:42.967]                     if (exists("sendData", mode = "function", 
[10:32:42.967]                       envir = ns)) {
[10:32:42.967]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:42.967]                         envir = ns)
[10:32:42.967]                       envir <- sys.frame(frame)
[10:32:42.967]                       master <- NULL
[10:32:42.967]                       while (!identical(envir, .GlobalEnv) && 
[10:32:42.967]                         !identical(envir, emptyenv())) {
[10:32:42.967]                         if (exists("master", mode = "list", envir = envir, 
[10:32:42.967]                           inherits = FALSE)) {
[10:32:42.967]                           master <- get("master", mode = "list", 
[10:32:42.967]                             envir = envir, inherits = FALSE)
[10:32:42.967]                           if (inherits(master, c("SOCKnode", 
[10:32:42.967]                             "SOCK0node"))) {
[10:32:42.967]                             sendCondition <<- function(cond) {
[10:32:42.967]                               data <- list(type = "VALUE", value = cond, 
[10:32:42.967]                                 success = TRUE)
[10:32:42.967]                               parallel_sendData(master, data)
[10:32:42.967]                             }
[10:32:42.967]                             return(sendCondition)
[10:32:42.967]                           }
[10:32:42.967]                         }
[10:32:42.967]                         frame <- frame + 1L
[10:32:42.967]                         envir <- sys.frame(frame)
[10:32:42.967]                       }
[10:32:42.967]                     }
[10:32:42.967]                     sendCondition <<- function(cond) NULL
[10:32:42.967]                   }
[10:32:42.967]                 })
[10:32:42.967]                 withCallingHandlers({
[10:32:42.967]                   NA
[10:32:42.967]                 }, immediateCondition = function(cond) {
[10:32:42.967]                   sendCondition <- ...future.makeSendCondition()
[10:32:42.967]                   sendCondition(cond)
[10:32:42.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.967]                   {
[10:32:42.967]                     inherits <- base::inherits
[10:32:42.967]                     invokeRestart <- base::invokeRestart
[10:32:42.967]                     is.null <- base::is.null
[10:32:42.967]                     muffled <- FALSE
[10:32:42.967]                     if (inherits(cond, "message")) {
[10:32:42.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:42.967]                       if (muffled) 
[10:32:42.967]                         invokeRestart("muffleMessage")
[10:32:42.967]                     }
[10:32:42.967]                     else if (inherits(cond, "warning")) {
[10:32:42.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:42.967]                       if (muffled) 
[10:32:42.967]                         invokeRestart("muffleWarning")
[10:32:42.967]                     }
[10:32:42.967]                     else if (inherits(cond, "condition")) {
[10:32:42.967]                       if (!is.null(pattern)) {
[10:32:42.967]                         computeRestarts <- base::computeRestarts
[10:32:42.967]                         grepl <- base::grepl
[10:32:42.967]                         restarts <- computeRestarts(cond)
[10:32:42.967]                         for (restart in restarts) {
[10:32:42.967]                           name <- restart$name
[10:32:42.967]                           if (is.null(name)) 
[10:32:42.967]                             next
[10:32:42.967]                           if (!grepl(pattern, name)) 
[10:32:42.967]                             next
[10:32:42.967]                           invokeRestart(restart)
[10:32:42.967]                           muffled <- TRUE
[10:32:42.967]                           break
[10:32:42.967]                         }
[10:32:42.967]                       }
[10:32:42.967]                     }
[10:32:42.967]                     invisible(muffled)
[10:32:42.967]                   }
[10:32:42.967]                   muffleCondition(cond)
[10:32:42.967]                 })
[10:32:42.967]             }))
[10:32:42.967]             future::FutureResult(value = ...future.value$value, 
[10:32:42.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.967]                   ...future.rng), globalenv = if (FALSE) 
[10:32:42.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:42.967]                     ...future.globalenv.names))
[10:32:42.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:42.967]         }, condition = base::local({
[10:32:42.967]             c <- base::c
[10:32:42.967]             inherits <- base::inherits
[10:32:42.967]             invokeRestart <- base::invokeRestart
[10:32:42.967]             length <- base::length
[10:32:42.967]             list <- base::list
[10:32:42.967]             seq.int <- base::seq.int
[10:32:42.967]             signalCondition <- base::signalCondition
[10:32:42.967]             sys.calls <- base::sys.calls
[10:32:42.967]             `[[` <- base::`[[`
[10:32:42.967]             `+` <- base::`+`
[10:32:42.967]             `<<-` <- base::`<<-`
[10:32:42.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:42.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:42.967]                   3L)]
[10:32:42.967]             }
[10:32:42.967]             function(cond) {
[10:32:42.967]                 is_error <- inherits(cond, "error")
[10:32:42.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:42.967]                   NULL)
[10:32:42.967]                 if (is_error) {
[10:32:42.967]                   sessionInformation <- function() {
[10:32:42.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:42.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:42.967]                       search = base::search(), system = base::Sys.info())
[10:32:42.967]                   }
[10:32:42.967]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:42.967]                     cond$call), session = sessionInformation(), 
[10:32:42.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:42.967]                   signalCondition(cond)
[10:32:42.967]                 }
[10:32:42.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:42.967]                 "immediateCondition"))) {
[10:32:42.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:42.967]                   ...future.conditions[[length(...future.conditions) + 
[10:32:42.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:42.967]                   if (TRUE && !signal) {
[10:32:42.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.967]                     {
[10:32:42.967]                       inherits <- base::inherits
[10:32:42.967]                       invokeRestart <- base::invokeRestart
[10:32:42.967]                       is.null <- base::is.null
[10:32:42.967]                       muffled <- FALSE
[10:32:42.967]                       if (inherits(cond, "message")) {
[10:32:42.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.967]                         if (muffled) 
[10:32:42.967]                           invokeRestart("muffleMessage")
[10:32:42.967]                       }
[10:32:42.967]                       else if (inherits(cond, "warning")) {
[10:32:42.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.967]                         if (muffled) 
[10:32:42.967]                           invokeRestart("muffleWarning")
[10:32:42.967]                       }
[10:32:42.967]                       else if (inherits(cond, "condition")) {
[10:32:42.967]                         if (!is.null(pattern)) {
[10:32:42.967]                           computeRestarts <- base::computeRestarts
[10:32:42.967]                           grepl <- base::grepl
[10:32:42.967]                           restarts <- computeRestarts(cond)
[10:32:42.967]                           for (restart in restarts) {
[10:32:42.967]                             name <- restart$name
[10:32:42.967]                             if (is.null(name)) 
[10:32:42.967]                               next
[10:32:42.967]                             if (!grepl(pattern, name)) 
[10:32:42.967]                               next
[10:32:42.967]                             invokeRestart(restart)
[10:32:42.967]                             muffled <- TRUE
[10:32:42.967]                             break
[10:32:42.967]                           }
[10:32:42.967]                         }
[10:32:42.967]                       }
[10:32:42.967]                       invisible(muffled)
[10:32:42.967]                     }
[10:32:42.967]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.967]                   }
[10:32:42.967]                 }
[10:32:42.967]                 else {
[10:32:42.967]                   if (TRUE) {
[10:32:42.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:42.967]                     {
[10:32:42.967]                       inherits <- base::inherits
[10:32:42.967]                       invokeRestart <- base::invokeRestart
[10:32:42.967]                       is.null <- base::is.null
[10:32:42.967]                       muffled <- FALSE
[10:32:42.967]                       if (inherits(cond, "message")) {
[10:32:42.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:42.967]                         if (muffled) 
[10:32:42.967]                           invokeRestart("muffleMessage")
[10:32:42.967]                       }
[10:32:42.967]                       else if (inherits(cond, "warning")) {
[10:32:42.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:42.967]                         if (muffled) 
[10:32:42.967]                           invokeRestart("muffleWarning")
[10:32:42.967]                       }
[10:32:42.967]                       else if (inherits(cond, "condition")) {
[10:32:42.967]                         if (!is.null(pattern)) {
[10:32:42.967]                           computeRestarts <- base::computeRestarts
[10:32:42.967]                           grepl <- base::grepl
[10:32:42.967]                           restarts <- computeRestarts(cond)
[10:32:42.967]                           for (restart in restarts) {
[10:32:42.967]                             name <- restart$name
[10:32:42.967]                             if (is.null(name)) 
[10:32:42.967]                               next
[10:32:42.967]                             if (!grepl(pattern, name)) 
[10:32:42.967]                               next
[10:32:42.967]                             invokeRestart(restart)
[10:32:42.967]                             muffled <- TRUE
[10:32:42.967]                             break
[10:32:42.967]                           }
[10:32:42.967]                         }
[10:32:42.967]                       }
[10:32:42.967]                       invisible(muffled)
[10:32:42.967]                     }
[10:32:42.967]                     muffleCondition(cond, pattern = "^muffle")
[10:32:42.967]                   }
[10:32:42.967]                 }
[10:32:42.967]             }
[10:32:42.967]         }))
[10:32:42.967]     }, error = function(ex) {
[10:32:42.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:42.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:42.967]                 ...future.rng), started = ...future.startTime, 
[10:32:42.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:42.967]             version = "1.8"), class = "FutureResult")
[10:32:42.967]     }, finally = {
[10:32:42.967]         if (!identical(...future.workdir, getwd())) 
[10:32:42.967]             setwd(...future.workdir)
[10:32:42.967]         {
[10:32:42.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:42.967]                 ...future.oldOptions$nwarnings <- NULL
[10:32:42.967]             }
[10:32:42.967]             base::options(...future.oldOptions)
[10:32:42.967]             if (.Platform$OS.type == "windows") {
[10:32:42.967]                 old_names <- names(...future.oldEnvVars)
[10:32:42.967]                 envs <- base::Sys.getenv()
[10:32:42.967]                 names <- names(envs)
[10:32:42.967]                 common <- intersect(names, old_names)
[10:32:42.967]                 added <- setdiff(names, old_names)
[10:32:42.967]                 removed <- setdiff(old_names, names)
[10:32:42.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:42.967]                   envs[common]]
[10:32:42.967]                 NAMES <- toupper(changed)
[10:32:42.967]                 args <- list()
[10:32:42.967]                 for (kk in seq_along(NAMES)) {
[10:32:42.967]                   name <- changed[[kk]]
[10:32:42.967]                   NAME <- NAMES[[kk]]
[10:32:42.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.967]                     next
[10:32:42.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.967]                 }
[10:32:42.967]                 NAMES <- toupper(added)
[10:32:42.967]                 for (kk in seq_along(NAMES)) {
[10:32:42.967]                   name <- added[[kk]]
[10:32:42.967]                   NAME <- NAMES[[kk]]
[10:32:42.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.967]                     next
[10:32:42.967]                   args[[name]] <- ""
[10:32:42.967]                 }
[10:32:42.967]                 NAMES <- toupper(removed)
[10:32:42.967]                 for (kk in seq_along(NAMES)) {
[10:32:42.967]                   name <- removed[[kk]]
[10:32:42.967]                   NAME <- NAMES[[kk]]
[10:32:42.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:42.967]                     next
[10:32:42.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:42.967]                 }
[10:32:42.967]                 if (length(args) > 0) 
[10:32:42.967]                   base::do.call(base::Sys.setenv, args = args)
[10:32:42.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:42.967]             }
[10:32:42.967]             else {
[10:32:42.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:42.967]             }
[10:32:42.967]             {
[10:32:42.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:42.967]                   0L) {
[10:32:42.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:42.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:42.967]                   base::options(opts)
[10:32:42.967]                 }
[10:32:42.967]                 {
[10:32:42.967]                   {
[10:32:42.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:42.967]                     NULL
[10:32:42.967]                   }
[10:32:42.967]                   options(future.plan = NULL)
[10:32:42.967]                   if (is.na(NA_character_)) 
[10:32:42.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:42.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:42.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:42.967]                     .init = FALSE)
[10:32:42.967]                 }
[10:32:42.967]             }
[10:32:42.967]         }
[10:32:42.967]     })
[10:32:42.967]     if (TRUE) {
[10:32:42.967]         base::sink(type = "output", split = FALSE)
[10:32:42.967]         if (TRUE) {
[10:32:42.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:42.967]         }
[10:32:42.967]         else {
[10:32:42.967]             ...future.result["stdout"] <- base::list(NULL)
[10:32:42.967]         }
[10:32:42.967]         base::close(...future.stdout)
[10:32:42.967]         ...future.stdout <- NULL
[10:32:42.967]     }
[10:32:42.967]     ...future.result$conditions <- ...future.conditions
[10:32:42.967]     ...future.result$finished <- base::Sys.time()
[10:32:42.967]     ...future.result
[10:32:42.967] }
[10:32:43.020] MultisessionFuture started
[10:32:43.021] result() for ClusterFuture ...
[10:32:43.022] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.022] - Validating connection of MultisessionFuture
[10:32:43.054] - received message: FutureResult
[10:32:43.054] - Received FutureResult
[10:32:43.055] - Erased future from FutureRegistry
[10:32:43.055] result() for ClusterFuture ...
[10:32:43.055] - result already collected: FutureResult
[10:32:43.055] result() for ClusterFuture ... done
[10:32:43.055] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.055] result() for ClusterFuture ... done
[10:32:43.055] result() for ClusterFuture ...
[10:32:43.055] - result already collected: FutureResult
[10:32:43.056] result() for ClusterFuture ... done
[10:32:43.056] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:32:43.060] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[10:32:43.061] getGlobalsAndPackages() ...
[10:32:43.061] Searching for globals...
[10:32:43.062] - globals found: [2] ‘{’, ‘<-’
[10:32:43.062] Searching for globals ... DONE
[10:32:43.062] Resolving globals: FALSE
[10:32:43.063] 
[10:32:43.063] 
[10:32:43.063] getGlobalsAndPackages() ... DONE
[10:32:43.063] run() for ‘Future’ ...
[10:32:43.063] - state: ‘created’
[10:32:43.064] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.078]   - Field: ‘node’
[10:32:43.078]   - Field: ‘label’
[10:32:43.078]   - Field: ‘local’
[10:32:43.078]   - Field: ‘owner’
[10:32:43.079]   - Field: ‘envir’
[10:32:43.079]   - Field: ‘workers’
[10:32:43.079]   - Field: ‘packages’
[10:32:43.079]   - Field: ‘gc’
[10:32:43.079]   - Field: ‘conditions’
[10:32:43.079]   - Field: ‘persistent’
[10:32:43.079]   - Field: ‘expr’
[10:32:43.079]   - Field: ‘uuid’
[10:32:43.079]   - Field: ‘seed’
[10:32:43.080]   - Field: ‘version’
[10:32:43.080]   - Field: ‘result’
[10:32:43.080]   - Field: ‘asynchronous’
[10:32:43.080]   - Field: ‘calls’
[10:32:43.080]   - Field: ‘globals’
[10:32:43.080]   - Field: ‘stdout’
[10:32:43.080]   - Field: ‘earlySignal’
[10:32:43.080]   - Field: ‘lazy’
[10:32:43.081]   - Field: ‘state’
[10:32:43.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.081] - Launch lazy future ...
[10:32:43.081] Packages needed by the future expression (n = 0): <none>
[10:32:43.081] Packages needed by future strategies (n = 0): <none>
[10:32:43.082] {
[10:32:43.082]     {
[10:32:43.082]         {
[10:32:43.082]             ...future.startTime <- base::Sys.time()
[10:32:43.082]             {
[10:32:43.082]                 {
[10:32:43.082]                   {
[10:32:43.082]                     {
[10:32:43.082]                       base::local({
[10:32:43.082]                         has_future <- base::requireNamespace("future", 
[10:32:43.082]                           quietly = TRUE)
[10:32:43.082]                         if (has_future) {
[10:32:43.082]                           ns <- base::getNamespace("future")
[10:32:43.082]                           version <- ns[[".package"]][["version"]]
[10:32:43.082]                           if (is.null(version)) 
[10:32:43.082]                             version <- utils::packageVersion("future")
[10:32:43.082]                         }
[10:32:43.082]                         else {
[10:32:43.082]                           version <- NULL
[10:32:43.082]                         }
[10:32:43.082]                         if (!has_future || version < "1.8.0") {
[10:32:43.082]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.082]                             "", base::R.version$version.string), 
[10:32:43.082]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.082]                               "release", "version")], collapse = " "), 
[10:32:43.082]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.082]                             info)
[10:32:43.082]                           info <- base::paste(info, collapse = "; ")
[10:32:43.082]                           if (!has_future) {
[10:32:43.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.082]                               info)
[10:32:43.082]                           }
[10:32:43.082]                           else {
[10:32:43.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.082]                               info, version)
[10:32:43.082]                           }
[10:32:43.082]                           base::stop(msg)
[10:32:43.082]                         }
[10:32:43.082]                       })
[10:32:43.082]                     }
[10:32:43.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.082]                     base::options(mc.cores = 1L)
[10:32:43.082]                   }
[10:32:43.082]                   ...future.strategy.old <- future::plan("list")
[10:32:43.082]                   options(future.plan = NULL)
[10:32:43.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.082]                 }
[10:32:43.082]                 ...future.workdir <- getwd()
[10:32:43.082]             }
[10:32:43.082]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.082]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.082]         }
[10:32:43.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.082]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.082]             base::names(...future.oldOptions))
[10:32:43.082]     }
[10:32:43.082]     if (FALSE) {
[10:32:43.082]     }
[10:32:43.082]     else {
[10:32:43.082]         if (TRUE) {
[10:32:43.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.082]                 open = "w")
[10:32:43.082]         }
[10:32:43.082]         else {
[10:32:43.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.082]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.082]         }
[10:32:43.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.082]             base::sink(type = "output", split = FALSE)
[10:32:43.082]             base::close(...future.stdout)
[10:32:43.082]         }, add = TRUE)
[10:32:43.082]     }
[10:32:43.082]     ...future.frame <- base::sys.nframe()
[10:32:43.082]     ...future.conditions <- base::list()
[10:32:43.082]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.082]     if (FALSE) {
[10:32:43.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.082]     }
[10:32:43.082]     ...future.result <- base::tryCatch({
[10:32:43.082]         base::withCallingHandlers({
[10:32:43.082]             ...future.value <- base::withVisible(base::local({
[10:32:43.082]                 ...future.makeSendCondition <- base::local({
[10:32:43.082]                   sendCondition <- NULL
[10:32:43.082]                   function(frame = 1L) {
[10:32:43.082]                     if (is.function(sendCondition)) 
[10:32:43.082]                       return(sendCondition)
[10:32:43.082]                     ns <- getNamespace("parallel")
[10:32:43.082]                     if (exists("sendData", mode = "function", 
[10:32:43.082]                       envir = ns)) {
[10:32:43.082]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.082]                         envir = ns)
[10:32:43.082]                       envir <- sys.frame(frame)
[10:32:43.082]                       master <- NULL
[10:32:43.082]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.082]                         !identical(envir, emptyenv())) {
[10:32:43.082]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.082]                           inherits = FALSE)) {
[10:32:43.082]                           master <- get("master", mode = "list", 
[10:32:43.082]                             envir = envir, inherits = FALSE)
[10:32:43.082]                           if (inherits(master, c("SOCKnode", 
[10:32:43.082]                             "SOCK0node"))) {
[10:32:43.082]                             sendCondition <<- function(cond) {
[10:32:43.082]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.082]                                 success = TRUE)
[10:32:43.082]                               parallel_sendData(master, data)
[10:32:43.082]                             }
[10:32:43.082]                             return(sendCondition)
[10:32:43.082]                           }
[10:32:43.082]                         }
[10:32:43.082]                         frame <- frame + 1L
[10:32:43.082]                         envir <- sys.frame(frame)
[10:32:43.082]                       }
[10:32:43.082]                     }
[10:32:43.082]                     sendCondition <<- function(cond) NULL
[10:32:43.082]                   }
[10:32:43.082]                 })
[10:32:43.082]                 withCallingHandlers({
[10:32:43.082]                   {
[10:32:43.082]                     x <- 1
[10:32:43.082]                   }
[10:32:43.082]                 }, immediateCondition = function(cond) {
[10:32:43.082]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.082]                   sendCondition(cond)
[10:32:43.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.082]                   {
[10:32:43.082]                     inherits <- base::inherits
[10:32:43.082]                     invokeRestart <- base::invokeRestart
[10:32:43.082]                     is.null <- base::is.null
[10:32:43.082]                     muffled <- FALSE
[10:32:43.082]                     if (inherits(cond, "message")) {
[10:32:43.082]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.082]                       if (muffled) 
[10:32:43.082]                         invokeRestart("muffleMessage")
[10:32:43.082]                     }
[10:32:43.082]                     else if (inherits(cond, "warning")) {
[10:32:43.082]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.082]                       if (muffled) 
[10:32:43.082]                         invokeRestart("muffleWarning")
[10:32:43.082]                     }
[10:32:43.082]                     else if (inherits(cond, "condition")) {
[10:32:43.082]                       if (!is.null(pattern)) {
[10:32:43.082]                         computeRestarts <- base::computeRestarts
[10:32:43.082]                         grepl <- base::grepl
[10:32:43.082]                         restarts <- computeRestarts(cond)
[10:32:43.082]                         for (restart in restarts) {
[10:32:43.082]                           name <- restart$name
[10:32:43.082]                           if (is.null(name)) 
[10:32:43.082]                             next
[10:32:43.082]                           if (!grepl(pattern, name)) 
[10:32:43.082]                             next
[10:32:43.082]                           invokeRestart(restart)
[10:32:43.082]                           muffled <- TRUE
[10:32:43.082]                           break
[10:32:43.082]                         }
[10:32:43.082]                       }
[10:32:43.082]                     }
[10:32:43.082]                     invisible(muffled)
[10:32:43.082]                   }
[10:32:43.082]                   muffleCondition(cond)
[10:32:43.082]                 })
[10:32:43.082]             }))
[10:32:43.082]             future::FutureResult(value = ...future.value$value, 
[10:32:43.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.082]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.082]                     ...future.globalenv.names))
[10:32:43.082]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.082]         }, condition = base::local({
[10:32:43.082]             c <- base::c
[10:32:43.082]             inherits <- base::inherits
[10:32:43.082]             invokeRestart <- base::invokeRestart
[10:32:43.082]             length <- base::length
[10:32:43.082]             list <- base::list
[10:32:43.082]             seq.int <- base::seq.int
[10:32:43.082]             signalCondition <- base::signalCondition
[10:32:43.082]             sys.calls <- base::sys.calls
[10:32:43.082]             `[[` <- base::`[[`
[10:32:43.082]             `+` <- base::`+`
[10:32:43.082]             `<<-` <- base::`<<-`
[10:32:43.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.082]                   3L)]
[10:32:43.082]             }
[10:32:43.082]             function(cond) {
[10:32:43.082]                 is_error <- inherits(cond, "error")
[10:32:43.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.082]                   NULL)
[10:32:43.082]                 if (is_error) {
[10:32:43.082]                   sessionInformation <- function() {
[10:32:43.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.082]                       search = base::search(), system = base::Sys.info())
[10:32:43.082]                   }
[10:32:43.082]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.082]                     cond$call), session = sessionInformation(), 
[10:32:43.082]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.082]                   signalCondition(cond)
[10:32:43.082]                 }
[10:32:43.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.082]                 "immediateCondition"))) {
[10:32:43.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.082]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.082]                   if (TRUE && !signal) {
[10:32:43.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.082]                     {
[10:32:43.082]                       inherits <- base::inherits
[10:32:43.082]                       invokeRestart <- base::invokeRestart
[10:32:43.082]                       is.null <- base::is.null
[10:32:43.082]                       muffled <- FALSE
[10:32:43.082]                       if (inherits(cond, "message")) {
[10:32:43.082]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.082]                         if (muffled) 
[10:32:43.082]                           invokeRestart("muffleMessage")
[10:32:43.082]                       }
[10:32:43.082]                       else if (inherits(cond, "warning")) {
[10:32:43.082]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.082]                         if (muffled) 
[10:32:43.082]                           invokeRestart("muffleWarning")
[10:32:43.082]                       }
[10:32:43.082]                       else if (inherits(cond, "condition")) {
[10:32:43.082]                         if (!is.null(pattern)) {
[10:32:43.082]                           computeRestarts <- base::computeRestarts
[10:32:43.082]                           grepl <- base::grepl
[10:32:43.082]                           restarts <- computeRestarts(cond)
[10:32:43.082]                           for (restart in restarts) {
[10:32:43.082]                             name <- restart$name
[10:32:43.082]                             if (is.null(name)) 
[10:32:43.082]                               next
[10:32:43.082]                             if (!grepl(pattern, name)) 
[10:32:43.082]                               next
[10:32:43.082]                             invokeRestart(restart)
[10:32:43.082]                             muffled <- TRUE
[10:32:43.082]                             break
[10:32:43.082]                           }
[10:32:43.082]                         }
[10:32:43.082]                       }
[10:32:43.082]                       invisible(muffled)
[10:32:43.082]                     }
[10:32:43.082]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.082]                   }
[10:32:43.082]                 }
[10:32:43.082]                 else {
[10:32:43.082]                   if (TRUE) {
[10:32:43.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.082]                     {
[10:32:43.082]                       inherits <- base::inherits
[10:32:43.082]                       invokeRestart <- base::invokeRestart
[10:32:43.082]                       is.null <- base::is.null
[10:32:43.082]                       muffled <- FALSE
[10:32:43.082]                       if (inherits(cond, "message")) {
[10:32:43.082]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.082]                         if (muffled) 
[10:32:43.082]                           invokeRestart("muffleMessage")
[10:32:43.082]                       }
[10:32:43.082]                       else if (inherits(cond, "warning")) {
[10:32:43.082]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.082]                         if (muffled) 
[10:32:43.082]                           invokeRestart("muffleWarning")
[10:32:43.082]                       }
[10:32:43.082]                       else if (inherits(cond, "condition")) {
[10:32:43.082]                         if (!is.null(pattern)) {
[10:32:43.082]                           computeRestarts <- base::computeRestarts
[10:32:43.082]                           grepl <- base::grepl
[10:32:43.082]                           restarts <- computeRestarts(cond)
[10:32:43.082]                           for (restart in restarts) {
[10:32:43.082]                             name <- restart$name
[10:32:43.082]                             if (is.null(name)) 
[10:32:43.082]                               next
[10:32:43.082]                             if (!grepl(pattern, name)) 
[10:32:43.082]                               next
[10:32:43.082]                             invokeRestart(restart)
[10:32:43.082]                             muffled <- TRUE
[10:32:43.082]                             break
[10:32:43.082]                           }
[10:32:43.082]                         }
[10:32:43.082]                       }
[10:32:43.082]                       invisible(muffled)
[10:32:43.082]                     }
[10:32:43.082]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.082]                   }
[10:32:43.082]                 }
[10:32:43.082]             }
[10:32:43.082]         }))
[10:32:43.082]     }, error = function(ex) {
[10:32:43.082]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.082]                 ...future.rng), started = ...future.startTime, 
[10:32:43.082]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.082]             version = "1.8"), class = "FutureResult")
[10:32:43.082]     }, finally = {
[10:32:43.082]         if (!identical(...future.workdir, getwd())) 
[10:32:43.082]             setwd(...future.workdir)
[10:32:43.082]         {
[10:32:43.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.082]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.082]             }
[10:32:43.082]             base::options(...future.oldOptions)
[10:32:43.082]             if (.Platform$OS.type == "windows") {
[10:32:43.082]                 old_names <- names(...future.oldEnvVars)
[10:32:43.082]                 envs <- base::Sys.getenv()
[10:32:43.082]                 names <- names(envs)
[10:32:43.082]                 common <- intersect(names, old_names)
[10:32:43.082]                 added <- setdiff(names, old_names)
[10:32:43.082]                 removed <- setdiff(old_names, names)
[10:32:43.082]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.082]                   envs[common]]
[10:32:43.082]                 NAMES <- toupper(changed)
[10:32:43.082]                 args <- list()
[10:32:43.082]                 for (kk in seq_along(NAMES)) {
[10:32:43.082]                   name <- changed[[kk]]
[10:32:43.082]                   NAME <- NAMES[[kk]]
[10:32:43.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.082]                     next
[10:32:43.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.082]                 }
[10:32:43.082]                 NAMES <- toupper(added)
[10:32:43.082]                 for (kk in seq_along(NAMES)) {
[10:32:43.082]                   name <- added[[kk]]
[10:32:43.082]                   NAME <- NAMES[[kk]]
[10:32:43.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.082]                     next
[10:32:43.082]                   args[[name]] <- ""
[10:32:43.082]                 }
[10:32:43.082]                 NAMES <- toupper(removed)
[10:32:43.082]                 for (kk in seq_along(NAMES)) {
[10:32:43.082]                   name <- removed[[kk]]
[10:32:43.082]                   NAME <- NAMES[[kk]]
[10:32:43.082]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.082]                     next
[10:32:43.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.082]                 }
[10:32:43.082]                 if (length(args) > 0) 
[10:32:43.082]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.082]             }
[10:32:43.082]             else {
[10:32:43.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.082]             }
[10:32:43.082]             {
[10:32:43.082]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.082]                   0L) {
[10:32:43.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.082]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.082]                   base::options(opts)
[10:32:43.082]                 }
[10:32:43.082]                 {
[10:32:43.082]                   {
[10:32:43.082]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.082]                     NULL
[10:32:43.082]                   }
[10:32:43.082]                   options(future.plan = NULL)
[10:32:43.082]                   if (is.na(NA_character_)) 
[10:32:43.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.082]                     .init = FALSE)
[10:32:43.082]                 }
[10:32:43.082]             }
[10:32:43.082]         }
[10:32:43.082]     })
[10:32:43.082]     if (TRUE) {
[10:32:43.082]         base::sink(type = "output", split = FALSE)
[10:32:43.082]         if (TRUE) {
[10:32:43.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.082]         }
[10:32:43.082]         else {
[10:32:43.082]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.082]         }
[10:32:43.082]         base::close(...future.stdout)
[10:32:43.082]         ...future.stdout <- NULL
[10:32:43.082]     }
[10:32:43.082]     ...future.result$conditions <- ...future.conditions
[10:32:43.082]     ...future.result$finished <- base::Sys.time()
[10:32:43.082]     ...future.result
[10:32:43.082] }
[10:32:43.085] MultisessionFuture started
[10:32:43.085] - Launch lazy future ... done
[10:32:43.086] run() for ‘MultisessionFuture’ ... done
[10:32:43.086] result() for ClusterFuture ...
[10:32:43.086] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.086] - Validating connection of MultisessionFuture
[10:32:43.090] - received message: FutureResult
[10:32:43.091] - Received FutureResult
[10:32:43.091] - Erased future from FutureRegistry
[10:32:43.091] result() for ClusterFuture ...
[10:32:43.091] - result already collected: FutureResult
[10:32:43.091] result() for ClusterFuture ... done
[10:32:43.091] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.091] result() for ClusterFuture ... done
[10:32:43.091] result() for ClusterFuture ...
[10:32:43.092] - result already collected: FutureResult
[10:32:43.092] result() for ClusterFuture ... done
** Future evaluation with globals
[10:32:43.092] getGlobalsAndPackages() ...
[10:32:43.092] Searching for globals...
[10:32:43.093] - globals found: [3] ‘{’, ‘<-’, ‘a’
[10:32:43.094] Searching for globals ... DONE
[10:32:43.094] Resolving globals: FALSE
[10:32:43.094] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:43.095] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:32:43.095] - globals: [1] ‘a’
[10:32:43.095] 
[10:32:43.095] getGlobalsAndPackages() ... DONE
[10:32:43.095] run() for ‘Future’ ...
[10:32:43.095] - state: ‘created’
[10:32:43.096] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.110]   - Field: ‘node’
[10:32:43.111]   - Field: ‘label’
[10:32:43.111]   - Field: ‘local’
[10:32:43.111]   - Field: ‘owner’
[10:32:43.111]   - Field: ‘envir’
[10:32:43.111]   - Field: ‘workers’
[10:32:43.111]   - Field: ‘packages’
[10:32:43.111]   - Field: ‘gc’
[10:32:43.111]   - Field: ‘conditions’
[10:32:43.111]   - Field: ‘persistent’
[10:32:43.112]   - Field: ‘expr’
[10:32:43.112]   - Field: ‘uuid’
[10:32:43.112]   - Field: ‘seed’
[10:32:43.112]   - Field: ‘version’
[10:32:43.112]   - Field: ‘result’
[10:32:43.112]   - Field: ‘asynchronous’
[10:32:43.112]   - Field: ‘calls’
[10:32:43.112]   - Field: ‘globals’
[10:32:43.112]   - Field: ‘stdout’
[10:32:43.113]   - Field: ‘earlySignal’
[10:32:43.113]   - Field: ‘lazy’
[10:32:43.113]   - Field: ‘state’
[10:32:43.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.113] - Launch lazy future ...
[10:32:43.113] Packages needed by the future expression (n = 0): <none>
[10:32:43.114] Packages needed by future strategies (n = 0): <none>
[10:32:43.114] {
[10:32:43.114]     {
[10:32:43.114]         {
[10:32:43.114]             ...future.startTime <- base::Sys.time()
[10:32:43.114]             {
[10:32:43.114]                 {
[10:32:43.114]                   {
[10:32:43.114]                     {
[10:32:43.114]                       base::local({
[10:32:43.114]                         has_future <- base::requireNamespace("future", 
[10:32:43.114]                           quietly = TRUE)
[10:32:43.114]                         if (has_future) {
[10:32:43.114]                           ns <- base::getNamespace("future")
[10:32:43.114]                           version <- ns[[".package"]][["version"]]
[10:32:43.114]                           if (is.null(version)) 
[10:32:43.114]                             version <- utils::packageVersion("future")
[10:32:43.114]                         }
[10:32:43.114]                         else {
[10:32:43.114]                           version <- NULL
[10:32:43.114]                         }
[10:32:43.114]                         if (!has_future || version < "1.8.0") {
[10:32:43.114]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.114]                             "", base::R.version$version.string), 
[10:32:43.114]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.114]                               "release", "version")], collapse = " "), 
[10:32:43.114]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.114]                             info)
[10:32:43.114]                           info <- base::paste(info, collapse = "; ")
[10:32:43.114]                           if (!has_future) {
[10:32:43.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.114]                               info)
[10:32:43.114]                           }
[10:32:43.114]                           else {
[10:32:43.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.114]                               info, version)
[10:32:43.114]                           }
[10:32:43.114]                           base::stop(msg)
[10:32:43.114]                         }
[10:32:43.114]                       })
[10:32:43.114]                     }
[10:32:43.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.114]                     base::options(mc.cores = 1L)
[10:32:43.114]                   }
[10:32:43.114]                   ...future.strategy.old <- future::plan("list")
[10:32:43.114]                   options(future.plan = NULL)
[10:32:43.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.114]                 }
[10:32:43.114]                 ...future.workdir <- getwd()
[10:32:43.114]             }
[10:32:43.114]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.114]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.114]         }
[10:32:43.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.114]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.114]             base::names(...future.oldOptions))
[10:32:43.114]     }
[10:32:43.114]     if (FALSE) {
[10:32:43.114]     }
[10:32:43.114]     else {
[10:32:43.114]         if (TRUE) {
[10:32:43.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.114]                 open = "w")
[10:32:43.114]         }
[10:32:43.114]         else {
[10:32:43.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.114]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.114]         }
[10:32:43.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.114]             base::sink(type = "output", split = FALSE)
[10:32:43.114]             base::close(...future.stdout)
[10:32:43.114]         }, add = TRUE)
[10:32:43.114]     }
[10:32:43.114]     ...future.frame <- base::sys.nframe()
[10:32:43.114]     ...future.conditions <- base::list()
[10:32:43.114]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.114]     if (FALSE) {
[10:32:43.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.114]     }
[10:32:43.114]     ...future.result <- base::tryCatch({
[10:32:43.114]         base::withCallingHandlers({
[10:32:43.114]             ...future.value <- base::withVisible(base::local({
[10:32:43.114]                 ...future.makeSendCondition <- base::local({
[10:32:43.114]                   sendCondition <- NULL
[10:32:43.114]                   function(frame = 1L) {
[10:32:43.114]                     if (is.function(sendCondition)) 
[10:32:43.114]                       return(sendCondition)
[10:32:43.114]                     ns <- getNamespace("parallel")
[10:32:43.114]                     if (exists("sendData", mode = "function", 
[10:32:43.114]                       envir = ns)) {
[10:32:43.114]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.114]                         envir = ns)
[10:32:43.114]                       envir <- sys.frame(frame)
[10:32:43.114]                       master <- NULL
[10:32:43.114]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.114]                         !identical(envir, emptyenv())) {
[10:32:43.114]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.114]                           inherits = FALSE)) {
[10:32:43.114]                           master <- get("master", mode = "list", 
[10:32:43.114]                             envir = envir, inherits = FALSE)
[10:32:43.114]                           if (inherits(master, c("SOCKnode", 
[10:32:43.114]                             "SOCK0node"))) {
[10:32:43.114]                             sendCondition <<- function(cond) {
[10:32:43.114]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.114]                                 success = TRUE)
[10:32:43.114]                               parallel_sendData(master, data)
[10:32:43.114]                             }
[10:32:43.114]                             return(sendCondition)
[10:32:43.114]                           }
[10:32:43.114]                         }
[10:32:43.114]                         frame <- frame + 1L
[10:32:43.114]                         envir <- sys.frame(frame)
[10:32:43.114]                       }
[10:32:43.114]                     }
[10:32:43.114]                     sendCondition <<- function(cond) NULL
[10:32:43.114]                   }
[10:32:43.114]                 })
[10:32:43.114]                 withCallingHandlers({
[10:32:43.114]                   {
[10:32:43.114]                     x <- a
[10:32:43.114]                   }
[10:32:43.114]                 }, immediateCondition = function(cond) {
[10:32:43.114]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.114]                   sendCondition(cond)
[10:32:43.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.114]                   {
[10:32:43.114]                     inherits <- base::inherits
[10:32:43.114]                     invokeRestart <- base::invokeRestart
[10:32:43.114]                     is.null <- base::is.null
[10:32:43.114]                     muffled <- FALSE
[10:32:43.114]                     if (inherits(cond, "message")) {
[10:32:43.114]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.114]                       if (muffled) 
[10:32:43.114]                         invokeRestart("muffleMessage")
[10:32:43.114]                     }
[10:32:43.114]                     else if (inherits(cond, "warning")) {
[10:32:43.114]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.114]                       if (muffled) 
[10:32:43.114]                         invokeRestart("muffleWarning")
[10:32:43.114]                     }
[10:32:43.114]                     else if (inherits(cond, "condition")) {
[10:32:43.114]                       if (!is.null(pattern)) {
[10:32:43.114]                         computeRestarts <- base::computeRestarts
[10:32:43.114]                         grepl <- base::grepl
[10:32:43.114]                         restarts <- computeRestarts(cond)
[10:32:43.114]                         for (restart in restarts) {
[10:32:43.114]                           name <- restart$name
[10:32:43.114]                           if (is.null(name)) 
[10:32:43.114]                             next
[10:32:43.114]                           if (!grepl(pattern, name)) 
[10:32:43.114]                             next
[10:32:43.114]                           invokeRestart(restart)
[10:32:43.114]                           muffled <- TRUE
[10:32:43.114]                           break
[10:32:43.114]                         }
[10:32:43.114]                       }
[10:32:43.114]                     }
[10:32:43.114]                     invisible(muffled)
[10:32:43.114]                   }
[10:32:43.114]                   muffleCondition(cond)
[10:32:43.114]                 })
[10:32:43.114]             }))
[10:32:43.114]             future::FutureResult(value = ...future.value$value, 
[10:32:43.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.114]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.114]                     ...future.globalenv.names))
[10:32:43.114]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.114]         }, condition = base::local({
[10:32:43.114]             c <- base::c
[10:32:43.114]             inherits <- base::inherits
[10:32:43.114]             invokeRestart <- base::invokeRestart
[10:32:43.114]             length <- base::length
[10:32:43.114]             list <- base::list
[10:32:43.114]             seq.int <- base::seq.int
[10:32:43.114]             signalCondition <- base::signalCondition
[10:32:43.114]             sys.calls <- base::sys.calls
[10:32:43.114]             `[[` <- base::`[[`
[10:32:43.114]             `+` <- base::`+`
[10:32:43.114]             `<<-` <- base::`<<-`
[10:32:43.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.114]                   3L)]
[10:32:43.114]             }
[10:32:43.114]             function(cond) {
[10:32:43.114]                 is_error <- inherits(cond, "error")
[10:32:43.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.114]                   NULL)
[10:32:43.114]                 if (is_error) {
[10:32:43.114]                   sessionInformation <- function() {
[10:32:43.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.114]                       search = base::search(), system = base::Sys.info())
[10:32:43.114]                   }
[10:32:43.114]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.114]                     cond$call), session = sessionInformation(), 
[10:32:43.114]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.114]                   signalCondition(cond)
[10:32:43.114]                 }
[10:32:43.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.114]                 "immediateCondition"))) {
[10:32:43.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.114]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.114]                   if (TRUE && !signal) {
[10:32:43.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.114]                     {
[10:32:43.114]                       inherits <- base::inherits
[10:32:43.114]                       invokeRestart <- base::invokeRestart
[10:32:43.114]                       is.null <- base::is.null
[10:32:43.114]                       muffled <- FALSE
[10:32:43.114]                       if (inherits(cond, "message")) {
[10:32:43.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.114]                         if (muffled) 
[10:32:43.114]                           invokeRestart("muffleMessage")
[10:32:43.114]                       }
[10:32:43.114]                       else if (inherits(cond, "warning")) {
[10:32:43.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.114]                         if (muffled) 
[10:32:43.114]                           invokeRestart("muffleWarning")
[10:32:43.114]                       }
[10:32:43.114]                       else if (inherits(cond, "condition")) {
[10:32:43.114]                         if (!is.null(pattern)) {
[10:32:43.114]                           computeRestarts <- base::computeRestarts
[10:32:43.114]                           grepl <- base::grepl
[10:32:43.114]                           restarts <- computeRestarts(cond)
[10:32:43.114]                           for (restart in restarts) {
[10:32:43.114]                             name <- restart$name
[10:32:43.114]                             if (is.null(name)) 
[10:32:43.114]                               next
[10:32:43.114]                             if (!grepl(pattern, name)) 
[10:32:43.114]                               next
[10:32:43.114]                             invokeRestart(restart)
[10:32:43.114]                             muffled <- TRUE
[10:32:43.114]                             break
[10:32:43.114]                           }
[10:32:43.114]                         }
[10:32:43.114]                       }
[10:32:43.114]                       invisible(muffled)
[10:32:43.114]                     }
[10:32:43.114]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.114]                   }
[10:32:43.114]                 }
[10:32:43.114]                 else {
[10:32:43.114]                   if (TRUE) {
[10:32:43.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.114]                     {
[10:32:43.114]                       inherits <- base::inherits
[10:32:43.114]                       invokeRestart <- base::invokeRestart
[10:32:43.114]                       is.null <- base::is.null
[10:32:43.114]                       muffled <- FALSE
[10:32:43.114]                       if (inherits(cond, "message")) {
[10:32:43.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.114]                         if (muffled) 
[10:32:43.114]                           invokeRestart("muffleMessage")
[10:32:43.114]                       }
[10:32:43.114]                       else if (inherits(cond, "warning")) {
[10:32:43.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.114]                         if (muffled) 
[10:32:43.114]                           invokeRestart("muffleWarning")
[10:32:43.114]                       }
[10:32:43.114]                       else if (inherits(cond, "condition")) {
[10:32:43.114]                         if (!is.null(pattern)) {
[10:32:43.114]                           computeRestarts <- base::computeRestarts
[10:32:43.114]                           grepl <- base::grepl
[10:32:43.114]                           restarts <- computeRestarts(cond)
[10:32:43.114]                           for (restart in restarts) {
[10:32:43.114]                             name <- restart$name
[10:32:43.114]                             if (is.null(name)) 
[10:32:43.114]                               next
[10:32:43.114]                             if (!grepl(pattern, name)) 
[10:32:43.114]                               next
[10:32:43.114]                             invokeRestart(restart)
[10:32:43.114]                             muffled <- TRUE
[10:32:43.114]                             break
[10:32:43.114]                           }
[10:32:43.114]                         }
[10:32:43.114]                       }
[10:32:43.114]                       invisible(muffled)
[10:32:43.114]                     }
[10:32:43.114]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.114]                   }
[10:32:43.114]                 }
[10:32:43.114]             }
[10:32:43.114]         }))
[10:32:43.114]     }, error = function(ex) {
[10:32:43.114]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.114]                 ...future.rng), started = ...future.startTime, 
[10:32:43.114]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.114]             version = "1.8"), class = "FutureResult")
[10:32:43.114]     }, finally = {
[10:32:43.114]         if (!identical(...future.workdir, getwd())) 
[10:32:43.114]             setwd(...future.workdir)
[10:32:43.114]         {
[10:32:43.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.114]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.114]             }
[10:32:43.114]             base::options(...future.oldOptions)
[10:32:43.114]             if (.Platform$OS.type == "windows") {
[10:32:43.114]                 old_names <- names(...future.oldEnvVars)
[10:32:43.114]                 envs <- base::Sys.getenv()
[10:32:43.114]                 names <- names(envs)
[10:32:43.114]                 common <- intersect(names, old_names)
[10:32:43.114]                 added <- setdiff(names, old_names)
[10:32:43.114]                 removed <- setdiff(old_names, names)
[10:32:43.114]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.114]                   envs[common]]
[10:32:43.114]                 NAMES <- toupper(changed)
[10:32:43.114]                 args <- list()
[10:32:43.114]                 for (kk in seq_along(NAMES)) {
[10:32:43.114]                   name <- changed[[kk]]
[10:32:43.114]                   NAME <- NAMES[[kk]]
[10:32:43.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.114]                     next
[10:32:43.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.114]                 }
[10:32:43.114]                 NAMES <- toupper(added)
[10:32:43.114]                 for (kk in seq_along(NAMES)) {
[10:32:43.114]                   name <- added[[kk]]
[10:32:43.114]                   NAME <- NAMES[[kk]]
[10:32:43.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.114]                     next
[10:32:43.114]                   args[[name]] <- ""
[10:32:43.114]                 }
[10:32:43.114]                 NAMES <- toupper(removed)
[10:32:43.114]                 for (kk in seq_along(NAMES)) {
[10:32:43.114]                   name <- removed[[kk]]
[10:32:43.114]                   NAME <- NAMES[[kk]]
[10:32:43.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.114]                     next
[10:32:43.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.114]                 }
[10:32:43.114]                 if (length(args) > 0) 
[10:32:43.114]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.114]             }
[10:32:43.114]             else {
[10:32:43.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.114]             }
[10:32:43.114]             {
[10:32:43.114]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.114]                   0L) {
[10:32:43.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.114]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.114]                   base::options(opts)
[10:32:43.114]                 }
[10:32:43.114]                 {
[10:32:43.114]                   {
[10:32:43.114]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.114]                     NULL
[10:32:43.114]                   }
[10:32:43.114]                   options(future.plan = NULL)
[10:32:43.114]                   if (is.na(NA_character_)) 
[10:32:43.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.114]                     .init = FALSE)
[10:32:43.114]                 }
[10:32:43.114]             }
[10:32:43.114]         }
[10:32:43.114]     })
[10:32:43.114]     if (TRUE) {
[10:32:43.114]         base::sink(type = "output", split = FALSE)
[10:32:43.114]         if (TRUE) {
[10:32:43.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.114]         }
[10:32:43.114]         else {
[10:32:43.114]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.114]         }
[10:32:43.114]         base::close(...future.stdout)
[10:32:43.114]         ...future.stdout <- NULL
[10:32:43.114]     }
[10:32:43.114]     ...future.result$conditions <- ...future.conditions
[10:32:43.114]     ...future.result$finished <- base::Sys.time()
[10:32:43.114]     ...future.result
[10:32:43.114] }
[10:32:43.117] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:32:43.117] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:32:43.118] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:32:43.118] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:32:43.118] MultisessionFuture started
[10:32:43.119] - Launch lazy future ... done
[10:32:43.119] run() for ‘MultisessionFuture’ ... done
[10:32:43.119] result() for ClusterFuture ...
[10:32:43.119] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.120] - Validating connection of MultisessionFuture
[10:32:43.120] - received message: FutureResult
[10:32:43.121] - Received FutureResult
[10:32:43.121] - Erased future from FutureRegistry
[10:32:43.121] result() for ClusterFuture ...
[10:32:43.121] - result already collected: FutureResult
[10:32:43.121] result() for ClusterFuture ... done
[10:32:43.121] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.121] result() for ClusterFuture ... done
[10:32:43.122] result() for ClusterFuture ...
[10:32:43.122] - result already collected: FutureResult
[10:32:43.122] result() for ClusterFuture ... done
** Future evaluation with errors
[10:32:43.122] getGlobalsAndPackages() ...
[10:32:43.122] Searching for globals...
[10:32:43.124] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[10:32:43.124] Searching for globals ... DONE
[10:32:43.124] Resolving globals: FALSE
[10:32:43.125] 
[10:32:43.125] 
[10:32:43.125] getGlobalsAndPackages() ... DONE
[10:32:43.125] run() for ‘Future’ ...
[10:32:43.126] - state: ‘created’
[10:32:43.126] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.140]   - Field: ‘node’
[10:32:43.141]   - Field: ‘label’
[10:32:43.141]   - Field: ‘local’
[10:32:43.141]   - Field: ‘owner’
[10:32:43.141]   - Field: ‘envir’
[10:32:43.141]   - Field: ‘workers’
[10:32:43.141]   - Field: ‘packages’
[10:32:43.141]   - Field: ‘gc’
[10:32:43.141]   - Field: ‘conditions’
[10:32:43.141]   - Field: ‘persistent’
[10:32:43.142]   - Field: ‘expr’
[10:32:43.142]   - Field: ‘uuid’
[10:32:43.142]   - Field: ‘seed’
[10:32:43.142]   - Field: ‘version’
[10:32:43.142]   - Field: ‘result’
[10:32:43.142]   - Field: ‘asynchronous’
[10:32:43.142]   - Field: ‘calls’
[10:32:43.142]   - Field: ‘globals’
[10:32:43.142]   - Field: ‘stdout’
[10:32:43.143]   - Field: ‘earlySignal’
[10:32:43.143]   - Field: ‘lazy’
[10:32:43.143]   - Field: ‘state’
[10:32:43.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.143] - Launch lazy future ...
[10:32:43.143] Packages needed by the future expression (n = 0): <none>
[10:32:43.143] Packages needed by future strategies (n = 0): <none>
[10:32:43.144] {
[10:32:43.144]     {
[10:32:43.144]         {
[10:32:43.144]             ...future.startTime <- base::Sys.time()
[10:32:43.144]             {
[10:32:43.144]                 {
[10:32:43.144]                   {
[10:32:43.144]                     {
[10:32:43.144]                       base::local({
[10:32:43.144]                         has_future <- base::requireNamespace("future", 
[10:32:43.144]                           quietly = TRUE)
[10:32:43.144]                         if (has_future) {
[10:32:43.144]                           ns <- base::getNamespace("future")
[10:32:43.144]                           version <- ns[[".package"]][["version"]]
[10:32:43.144]                           if (is.null(version)) 
[10:32:43.144]                             version <- utils::packageVersion("future")
[10:32:43.144]                         }
[10:32:43.144]                         else {
[10:32:43.144]                           version <- NULL
[10:32:43.144]                         }
[10:32:43.144]                         if (!has_future || version < "1.8.0") {
[10:32:43.144]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.144]                             "", base::R.version$version.string), 
[10:32:43.144]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.144]                               "release", "version")], collapse = " "), 
[10:32:43.144]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.144]                             info)
[10:32:43.144]                           info <- base::paste(info, collapse = "; ")
[10:32:43.144]                           if (!has_future) {
[10:32:43.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.144]                               info)
[10:32:43.144]                           }
[10:32:43.144]                           else {
[10:32:43.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.144]                               info, version)
[10:32:43.144]                           }
[10:32:43.144]                           base::stop(msg)
[10:32:43.144]                         }
[10:32:43.144]                       })
[10:32:43.144]                     }
[10:32:43.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.144]                     base::options(mc.cores = 1L)
[10:32:43.144]                   }
[10:32:43.144]                   ...future.strategy.old <- future::plan("list")
[10:32:43.144]                   options(future.plan = NULL)
[10:32:43.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.144]                 }
[10:32:43.144]                 ...future.workdir <- getwd()
[10:32:43.144]             }
[10:32:43.144]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.144]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.144]         }
[10:32:43.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.144]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.144]             base::names(...future.oldOptions))
[10:32:43.144]     }
[10:32:43.144]     if (FALSE) {
[10:32:43.144]     }
[10:32:43.144]     else {
[10:32:43.144]         if (TRUE) {
[10:32:43.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.144]                 open = "w")
[10:32:43.144]         }
[10:32:43.144]         else {
[10:32:43.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.144]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.144]         }
[10:32:43.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.144]             base::sink(type = "output", split = FALSE)
[10:32:43.144]             base::close(...future.stdout)
[10:32:43.144]         }, add = TRUE)
[10:32:43.144]     }
[10:32:43.144]     ...future.frame <- base::sys.nframe()
[10:32:43.144]     ...future.conditions <- base::list()
[10:32:43.144]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.144]     if (FALSE) {
[10:32:43.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.144]     }
[10:32:43.144]     ...future.result <- base::tryCatch({
[10:32:43.144]         base::withCallingHandlers({
[10:32:43.144]             ...future.value <- base::withVisible(base::local({
[10:32:43.144]                 ...future.makeSendCondition <- base::local({
[10:32:43.144]                   sendCondition <- NULL
[10:32:43.144]                   function(frame = 1L) {
[10:32:43.144]                     if (is.function(sendCondition)) 
[10:32:43.144]                       return(sendCondition)
[10:32:43.144]                     ns <- getNamespace("parallel")
[10:32:43.144]                     if (exists("sendData", mode = "function", 
[10:32:43.144]                       envir = ns)) {
[10:32:43.144]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.144]                         envir = ns)
[10:32:43.144]                       envir <- sys.frame(frame)
[10:32:43.144]                       master <- NULL
[10:32:43.144]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.144]                         !identical(envir, emptyenv())) {
[10:32:43.144]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.144]                           inherits = FALSE)) {
[10:32:43.144]                           master <- get("master", mode = "list", 
[10:32:43.144]                             envir = envir, inherits = FALSE)
[10:32:43.144]                           if (inherits(master, c("SOCKnode", 
[10:32:43.144]                             "SOCK0node"))) {
[10:32:43.144]                             sendCondition <<- function(cond) {
[10:32:43.144]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.144]                                 success = TRUE)
[10:32:43.144]                               parallel_sendData(master, data)
[10:32:43.144]                             }
[10:32:43.144]                             return(sendCondition)
[10:32:43.144]                           }
[10:32:43.144]                         }
[10:32:43.144]                         frame <- frame + 1L
[10:32:43.144]                         envir <- sys.frame(frame)
[10:32:43.144]                       }
[10:32:43.144]                     }
[10:32:43.144]                     sendCondition <<- function(cond) NULL
[10:32:43.144]                   }
[10:32:43.144]                 })
[10:32:43.144]                 withCallingHandlers({
[10:32:43.144]                   {
[10:32:43.144]                     x <- 3
[10:32:43.144]                     stop("Woops!")
[10:32:43.144]                     x
[10:32:43.144]                   }
[10:32:43.144]                 }, immediateCondition = function(cond) {
[10:32:43.144]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.144]                   sendCondition(cond)
[10:32:43.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.144]                   {
[10:32:43.144]                     inherits <- base::inherits
[10:32:43.144]                     invokeRestart <- base::invokeRestart
[10:32:43.144]                     is.null <- base::is.null
[10:32:43.144]                     muffled <- FALSE
[10:32:43.144]                     if (inherits(cond, "message")) {
[10:32:43.144]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.144]                       if (muffled) 
[10:32:43.144]                         invokeRestart("muffleMessage")
[10:32:43.144]                     }
[10:32:43.144]                     else if (inherits(cond, "warning")) {
[10:32:43.144]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.144]                       if (muffled) 
[10:32:43.144]                         invokeRestart("muffleWarning")
[10:32:43.144]                     }
[10:32:43.144]                     else if (inherits(cond, "condition")) {
[10:32:43.144]                       if (!is.null(pattern)) {
[10:32:43.144]                         computeRestarts <- base::computeRestarts
[10:32:43.144]                         grepl <- base::grepl
[10:32:43.144]                         restarts <- computeRestarts(cond)
[10:32:43.144]                         for (restart in restarts) {
[10:32:43.144]                           name <- restart$name
[10:32:43.144]                           if (is.null(name)) 
[10:32:43.144]                             next
[10:32:43.144]                           if (!grepl(pattern, name)) 
[10:32:43.144]                             next
[10:32:43.144]                           invokeRestart(restart)
[10:32:43.144]                           muffled <- TRUE
[10:32:43.144]                           break
[10:32:43.144]                         }
[10:32:43.144]                       }
[10:32:43.144]                     }
[10:32:43.144]                     invisible(muffled)
[10:32:43.144]                   }
[10:32:43.144]                   muffleCondition(cond)
[10:32:43.144]                 })
[10:32:43.144]             }))
[10:32:43.144]             future::FutureResult(value = ...future.value$value, 
[10:32:43.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.144]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.144]                     ...future.globalenv.names))
[10:32:43.144]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.144]         }, condition = base::local({
[10:32:43.144]             c <- base::c
[10:32:43.144]             inherits <- base::inherits
[10:32:43.144]             invokeRestart <- base::invokeRestart
[10:32:43.144]             length <- base::length
[10:32:43.144]             list <- base::list
[10:32:43.144]             seq.int <- base::seq.int
[10:32:43.144]             signalCondition <- base::signalCondition
[10:32:43.144]             sys.calls <- base::sys.calls
[10:32:43.144]             `[[` <- base::`[[`
[10:32:43.144]             `+` <- base::`+`
[10:32:43.144]             `<<-` <- base::`<<-`
[10:32:43.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.144]                   3L)]
[10:32:43.144]             }
[10:32:43.144]             function(cond) {
[10:32:43.144]                 is_error <- inherits(cond, "error")
[10:32:43.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.144]                   NULL)
[10:32:43.144]                 if (is_error) {
[10:32:43.144]                   sessionInformation <- function() {
[10:32:43.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.144]                       search = base::search(), system = base::Sys.info())
[10:32:43.144]                   }
[10:32:43.144]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.144]                     cond$call), session = sessionInformation(), 
[10:32:43.144]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.144]                   signalCondition(cond)
[10:32:43.144]                 }
[10:32:43.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.144]                 "immediateCondition"))) {
[10:32:43.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.144]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.144]                   if (TRUE && !signal) {
[10:32:43.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.144]                     {
[10:32:43.144]                       inherits <- base::inherits
[10:32:43.144]                       invokeRestart <- base::invokeRestart
[10:32:43.144]                       is.null <- base::is.null
[10:32:43.144]                       muffled <- FALSE
[10:32:43.144]                       if (inherits(cond, "message")) {
[10:32:43.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.144]                         if (muffled) 
[10:32:43.144]                           invokeRestart("muffleMessage")
[10:32:43.144]                       }
[10:32:43.144]                       else if (inherits(cond, "warning")) {
[10:32:43.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.144]                         if (muffled) 
[10:32:43.144]                           invokeRestart("muffleWarning")
[10:32:43.144]                       }
[10:32:43.144]                       else if (inherits(cond, "condition")) {
[10:32:43.144]                         if (!is.null(pattern)) {
[10:32:43.144]                           computeRestarts <- base::computeRestarts
[10:32:43.144]                           grepl <- base::grepl
[10:32:43.144]                           restarts <- computeRestarts(cond)
[10:32:43.144]                           for (restart in restarts) {
[10:32:43.144]                             name <- restart$name
[10:32:43.144]                             if (is.null(name)) 
[10:32:43.144]                               next
[10:32:43.144]                             if (!grepl(pattern, name)) 
[10:32:43.144]                               next
[10:32:43.144]                             invokeRestart(restart)
[10:32:43.144]                             muffled <- TRUE
[10:32:43.144]                             break
[10:32:43.144]                           }
[10:32:43.144]                         }
[10:32:43.144]                       }
[10:32:43.144]                       invisible(muffled)
[10:32:43.144]                     }
[10:32:43.144]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.144]                   }
[10:32:43.144]                 }
[10:32:43.144]                 else {
[10:32:43.144]                   if (TRUE) {
[10:32:43.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.144]                     {
[10:32:43.144]                       inherits <- base::inherits
[10:32:43.144]                       invokeRestart <- base::invokeRestart
[10:32:43.144]                       is.null <- base::is.null
[10:32:43.144]                       muffled <- FALSE
[10:32:43.144]                       if (inherits(cond, "message")) {
[10:32:43.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.144]                         if (muffled) 
[10:32:43.144]                           invokeRestart("muffleMessage")
[10:32:43.144]                       }
[10:32:43.144]                       else if (inherits(cond, "warning")) {
[10:32:43.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.144]                         if (muffled) 
[10:32:43.144]                           invokeRestart("muffleWarning")
[10:32:43.144]                       }
[10:32:43.144]                       else if (inherits(cond, "condition")) {
[10:32:43.144]                         if (!is.null(pattern)) {
[10:32:43.144]                           computeRestarts <- base::computeRestarts
[10:32:43.144]                           grepl <- base::grepl
[10:32:43.144]                           restarts <- computeRestarts(cond)
[10:32:43.144]                           for (restart in restarts) {
[10:32:43.144]                             name <- restart$name
[10:32:43.144]                             if (is.null(name)) 
[10:32:43.144]                               next
[10:32:43.144]                             if (!grepl(pattern, name)) 
[10:32:43.144]                               next
[10:32:43.144]                             invokeRestart(restart)
[10:32:43.144]                             muffled <- TRUE
[10:32:43.144]                             break
[10:32:43.144]                           }
[10:32:43.144]                         }
[10:32:43.144]                       }
[10:32:43.144]                       invisible(muffled)
[10:32:43.144]                     }
[10:32:43.144]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.144]                   }
[10:32:43.144]                 }
[10:32:43.144]             }
[10:32:43.144]         }))
[10:32:43.144]     }, error = function(ex) {
[10:32:43.144]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.144]                 ...future.rng), started = ...future.startTime, 
[10:32:43.144]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.144]             version = "1.8"), class = "FutureResult")
[10:32:43.144]     }, finally = {
[10:32:43.144]         if (!identical(...future.workdir, getwd())) 
[10:32:43.144]             setwd(...future.workdir)
[10:32:43.144]         {
[10:32:43.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.144]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.144]             }
[10:32:43.144]             base::options(...future.oldOptions)
[10:32:43.144]             if (.Platform$OS.type == "windows") {
[10:32:43.144]                 old_names <- names(...future.oldEnvVars)
[10:32:43.144]                 envs <- base::Sys.getenv()
[10:32:43.144]                 names <- names(envs)
[10:32:43.144]                 common <- intersect(names, old_names)
[10:32:43.144]                 added <- setdiff(names, old_names)
[10:32:43.144]                 removed <- setdiff(old_names, names)
[10:32:43.144]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.144]                   envs[common]]
[10:32:43.144]                 NAMES <- toupper(changed)
[10:32:43.144]                 args <- list()
[10:32:43.144]                 for (kk in seq_along(NAMES)) {
[10:32:43.144]                   name <- changed[[kk]]
[10:32:43.144]                   NAME <- NAMES[[kk]]
[10:32:43.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.144]                     next
[10:32:43.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.144]                 }
[10:32:43.144]                 NAMES <- toupper(added)
[10:32:43.144]                 for (kk in seq_along(NAMES)) {
[10:32:43.144]                   name <- added[[kk]]
[10:32:43.144]                   NAME <- NAMES[[kk]]
[10:32:43.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.144]                     next
[10:32:43.144]                   args[[name]] <- ""
[10:32:43.144]                 }
[10:32:43.144]                 NAMES <- toupper(removed)
[10:32:43.144]                 for (kk in seq_along(NAMES)) {
[10:32:43.144]                   name <- removed[[kk]]
[10:32:43.144]                   NAME <- NAMES[[kk]]
[10:32:43.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.144]                     next
[10:32:43.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.144]                 }
[10:32:43.144]                 if (length(args) > 0) 
[10:32:43.144]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.144]             }
[10:32:43.144]             else {
[10:32:43.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.144]             }
[10:32:43.144]             {
[10:32:43.144]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.144]                   0L) {
[10:32:43.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.144]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.144]                   base::options(opts)
[10:32:43.144]                 }
[10:32:43.144]                 {
[10:32:43.144]                   {
[10:32:43.144]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.144]                     NULL
[10:32:43.144]                   }
[10:32:43.144]                   options(future.plan = NULL)
[10:32:43.144]                   if (is.na(NA_character_)) 
[10:32:43.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.144]                     .init = FALSE)
[10:32:43.144]                 }
[10:32:43.144]             }
[10:32:43.144]         }
[10:32:43.144]     })
[10:32:43.144]     if (TRUE) {
[10:32:43.144]         base::sink(type = "output", split = FALSE)
[10:32:43.144]         if (TRUE) {
[10:32:43.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.144]         }
[10:32:43.144]         else {
[10:32:43.144]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.144]         }
[10:32:43.144]         base::close(...future.stdout)
[10:32:43.144]         ...future.stdout <- NULL
[10:32:43.144]     }
[10:32:43.144]     ...future.result$conditions <- ...future.conditions
[10:32:43.144]     ...future.result$finished <- base::Sys.time()
[10:32:43.144]     ...future.result
[10:32:43.144] }
[10:32:43.147] MultisessionFuture started
[10:32:43.147] - Launch lazy future ... done
[10:32:43.148] run() for ‘MultisessionFuture’ ... done
[10:32:43.148] result() for ClusterFuture ...
[10:32:43.148] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.148] - Validating connection of MultisessionFuture
[10:32:43.150] - received message: FutureResult
[10:32:43.150] - Received FutureResult
[10:32:43.150] - Erased future from FutureRegistry
[10:32:43.150] result() for ClusterFuture ...
[10:32:43.150] - result already collected: FutureResult
[10:32:43.150] result() for ClusterFuture ... done
[10:32:43.150] signalConditions() ...
[10:32:43.150]  - include = ‘immediateCondition’
[10:32:43.151]  - exclude = 
[10:32:43.151]  - resignal = FALSE
[10:32:43.151]  - Number of conditions: 1
[10:32:43.151] signalConditions() ... done
[10:32:43.151] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.151] result() for ClusterFuture ... done
[10:32:43.151] result() for ClusterFuture ...
[10:32:43.151] - result already collected: FutureResult
[10:32:43.151] result() for ClusterFuture ... done
[10:32:43.152] signalConditions() ...
[10:32:43.152]  - include = ‘immediateCondition’
[10:32:43.152]  - exclude = 
[10:32:43.152]  - resignal = FALSE
[10:32:43.152]  - Number of conditions: 1
[10:32:43.152] signalConditions() ... done
[10:32:43.152] Future state: ‘finished’
[10:32:43.152] result() for ClusterFuture ...
[10:32:43.152] - result already collected: FutureResult
[10:32:43.153] result() for ClusterFuture ... done
[10:32:43.153] signalConditions() ...
[10:32:43.153]  - include = ‘condition’
[10:32:43.153]  - exclude = ‘immediateCondition’
[10:32:43.153]  - resignal = TRUE
[10:32:43.153]  - Number of conditions: 1
[10:32:43.153]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:43.153] signalConditions() ... done
[10:32:43.154] getGlobalsAndPackages() ...
[10:32:43.154] Searching for globals...
[10:32:43.156] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:43.156] Searching for globals ... DONE
[10:32:43.156] Resolving globals: FALSE
[10:32:43.157] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:43.157] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:43.158] - globals: [1] ‘ii’
[10:32:43.158] 
[10:32:43.158] getGlobalsAndPackages() ... DONE
[10:32:43.158] run() for ‘Future’ ...
[10:32:43.158] - state: ‘created’
[10:32:43.158] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.176]   - Field: ‘node’
[10:32:43.176]   - Field: ‘label’
[10:32:43.176]   - Field: ‘local’
[10:32:43.176]   - Field: ‘owner’
[10:32:43.176]   - Field: ‘envir’
[10:32:43.176]   - Field: ‘workers’
[10:32:43.177]   - Field: ‘packages’
[10:32:43.177]   - Field: ‘gc’
[10:32:43.177]   - Field: ‘conditions’
[10:32:43.177]   - Field: ‘persistent’
[10:32:43.177]   - Field: ‘expr’
[10:32:43.177]   - Field: ‘uuid’
[10:32:43.177]   - Field: ‘seed’
[10:32:43.177]   - Field: ‘version’
[10:32:43.177]   - Field: ‘result’
[10:32:43.177]   - Field: ‘asynchronous’
[10:32:43.177]   - Field: ‘calls’
[10:32:43.178]   - Field: ‘globals’
[10:32:43.178]   - Field: ‘stdout’
[10:32:43.178]   - Field: ‘earlySignal’
[10:32:43.178]   - Field: ‘lazy’
[10:32:43.178]   - Field: ‘state’
[10:32:43.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.178] - Launch lazy future ...
[10:32:43.178] Packages needed by the future expression (n = 0): <none>
[10:32:43.178] Packages needed by future strategies (n = 0): <none>
[10:32:43.179] {
[10:32:43.179]     {
[10:32:43.179]         {
[10:32:43.179]             ...future.startTime <- base::Sys.time()
[10:32:43.179]             {
[10:32:43.179]                 {
[10:32:43.179]                   {
[10:32:43.179]                     {
[10:32:43.179]                       base::local({
[10:32:43.179]                         has_future <- base::requireNamespace("future", 
[10:32:43.179]                           quietly = TRUE)
[10:32:43.179]                         if (has_future) {
[10:32:43.179]                           ns <- base::getNamespace("future")
[10:32:43.179]                           version <- ns[[".package"]][["version"]]
[10:32:43.179]                           if (is.null(version)) 
[10:32:43.179]                             version <- utils::packageVersion("future")
[10:32:43.179]                         }
[10:32:43.179]                         else {
[10:32:43.179]                           version <- NULL
[10:32:43.179]                         }
[10:32:43.179]                         if (!has_future || version < "1.8.0") {
[10:32:43.179]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.179]                             "", base::R.version$version.string), 
[10:32:43.179]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.179]                               "release", "version")], collapse = " "), 
[10:32:43.179]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.179]                             info)
[10:32:43.179]                           info <- base::paste(info, collapse = "; ")
[10:32:43.179]                           if (!has_future) {
[10:32:43.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.179]                               info)
[10:32:43.179]                           }
[10:32:43.179]                           else {
[10:32:43.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.179]                               info, version)
[10:32:43.179]                           }
[10:32:43.179]                           base::stop(msg)
[10:32:43.179]                         }
[10:32:43.179]                       })
[10:32:43.179]                     }
[10:32:43.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.179]                     base::options(mc.cores = 1L)
[10:32:43.179]                   }
[10:32:43.179]                   ...future.strategy.old <- future::plan("list")
[10:32:43.179]                   options(future.plan = NULL)
[10:32:43.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.179]                 }
[10:32:43.179]                 ...future.workdir <- getwd()
[10:32:43.179]             }
[10:32:43.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.179]         }
[10:32:43.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.179]             base::names(...future.oldOptions))
[10:32:43.179]     }
[10:32:43.179]     if (FALSE) {
[10:32:43.179]     }
[10:32:43.179]     else {
[10:32:43.179]         if (TRUE) {
[10:32:43.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.179]                 open = "w")
[10:32:43.179]         }
[10:32:43.179]         else {
[10:32:43.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.179]         }
[10:32:43.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.179]             base::sink(type = "output", split = FALSE)
[10:32:43.179]             base::close(...future.stdout)
[10:32:43.179]         }, add = TRUE)
[10:32:43.179]     }
[10:32:43.179]     ...future.frame <- base::sys.nframe()
[10:32:43.179]     ...future.conditions <- base::list()
[10:32:43.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.179]     if (FALSE) {
[10:32:43.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.179]     }
[10:32:43.179]     ...future.result <- base::tryCatch({
[10:32:43.179]         base::withCallingHandlers({
[10:32:43.179]             ...future.value <- base::withVisible(base::local({
[10:32:43.179]                 ...future.makeSendCondition <- base::local({
[10:32:43.179]                   sendCondition <- NULL
[10:32:43.179]                   function(frame = 1L) {
[10:32:43.179]                     if (is.function(sendCondition)) 
[10:32:43.179]                       return(sendCondition)
[10:32:43.179]                     ns <- getNamespace("parallel")
[10:32:43.179]                     if (exists("sendData", mode = "function", 
[10:32:43.179]                       envir = ns)) {
[10:32:43.179]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.179]                         envir = ns)
[10:32:43.179]                       envir <- sys.frame(frame)
[10:32:43.179]                       master <- NULL
[10:32:43.179]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.179]                         !identical(envir, emptyenv())) {
[10:32:43.179]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.179]                           inherits = FALSE)) {
[10:32:43.179]                           master <- get("master", mode = "list", 
[10:32:43.179]                             envir = envir, inherits = FALSE)
[10:32:43.179]                           if (inherits(master, c("SOCKnode", 
[10:32:43.179]                             "SOCK0node"))) {
[10:32:43.179]                             sendCondition <<- function(cond) {
[10:32:43.179]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.179]                                 success = TRUE)
[10:32:43.179]                               parallel_sendData(master, data)
[10:32:43.179]                             }
[10:32:43.179]                             return(sendCondition)
[10:32:43.179]                           }
[10:32:43.179]                         }
[10:32:43.179]                         frame <- frame + 1L
[10:32:43.179]                         envir <- sys.frame(frame)
[10:32:43.179]                       }
[10:32:43.179]                     }
[10:32:43.179]                     sendCondition <<- function(cond) NULL
[10:32:43.179]                   }
[10:32:43.179]                 })
[10:32:43.179]                 withCallingHandlers({
[10:32:43.179]                   {
[10:32:43.179]                     if (ii%%2 == 0) 
[10:32:43.179]                       stop("Woops!")
[10:32:43.179]                     ii
[10:32:43.179]                   }
[10:32:43.179]                 }, immediateCondition = function(cond) {
[10:32:43.179]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.179]                   sendCondition(cond)
[10:32:43.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.179]                   {
[10:32:43.179]                     inherits <- base::inherits
[10:32:43.179]                     invokeRestart <- base::invokeRestart
[10:32:43.179]                     is.null <- base::is.null
[10:32:43.179]                     muffled <- FALSE
[10:32:43.179]                     if (inherits(cond, "message")) {
[10:32:43.179]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.179]                       if (muffled) 
[10:32:43.179]                         invokeRestart("muffleMessage")
[10:32:43.179]                     }
[10:32:43.179]                     else if (inherits(cond, "warning")) {
[10:32:43.179]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.179]                       if (muffled) 
[10:32:43.179]                         invokeRestart("muffleWarning")
[10:32:43.179]                     }
[10:32:43.179]                     else if (inherits(cond, "condition")) {
[10:32:43.179]                       if (!is.null(pattern)) {
[10:32:43.179]                         computeRestarts <- base::computeRestarts
[10:32:43.179]                         grepl <- base::grepl
[10:32:43.179]                         restarts <- computeRestarts(cond)
[10:32:43.179]                         for (restart in restarts) {
[10:32:43.179]                           name <- restart$name
[10:32:43.179]                           if (is.null(name)) 
[10:32:43.179]                             next
[10:32:43.179]                           if (!grepl(pattern, name)) 
[10:32:43.179]                             next
[10:32:43.179]                           invokeRestart(restart)
[10:32:43.179]                           muffled <- TRUE
[10:32:43.179]                           break
[10:32:43.179]                         }
[10:32:43.179]                       }
[10:32:43.179]                     }
[10:32:43.179]                     invisible(muffled)
[10:32:43.179]                   }
[10:32:43.179]                   muffleCondition(cond)
[10:32:43.179]                 })
[10:32:43.179]             }))
[10:32:43.179]             future::FutureResult(value = ...future.value$value, 
[10:32:43.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.179]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.179]                     ...future.globalenv.names))
[10:32:43.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.179]         }, condition = base::local({
[10:32:43.179]             c <- base::c
[10:32:43.179]             inherits <- base::inherits
[10:32:43.179]             invokeRestart <- base::invokeRestart
[10:32:43.179]             length <- base::length
[10:32:43.179]             list <- base::list
[10:32:43.179]             seq.int <- base::seq.int
[10:32:43.179]             signalCondition <- base::signalCondition
[10:32:43.179]             sys.calls <- base::sys.calls
[10:32:43.179]             `[[` <- base::`[[`
[10:32:43.179]             `+` <- base::`+`
[10:32:43.179]             `<<-` <- base::`<<-`
[10:32:43.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.179]                   3L)]
[10:32:43.179]             }
[10:32:43.179]             function(cond) {
[10:32:43.179]                 is_error <- inherits(cond, "error")
[10:32:43.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.179]                   NULL)
[10:32:43.179]                 if (is_error) {
[10:32:43.179]                   sessionInformation <- function() {
[10:32:43.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.179]                       search = base::search(), system = base::Sys.info())
[10:32:43.179]                   }
[10:32:43.179]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.179]                     cond$call), session = sessionInformation(), 
[10:32:43.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.179]                   signalCondition(cond)
[10:32:43.179]                 }
[10:32:43.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.179]                 "immediateCondition"))) {
[10:32:43.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.179]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.179]                   if (TRUE && !signal) {
[10:32:43.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.179]                     {
[10:32:43.179]                       inherits <- base::inherits
[10:32:43.179]                       invokeRestart <- base::invokeRestart
[10:32:43.179]                       is.null <- base::is.null
[10:32:43.179]                       muffled <- FALSE
[10:32:43.179]                       if (inherits(cond, "message")) {
[10:32:43.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.179]                         if (muffled) 
[10:32:43.179]                           invokeRestart("muffleMessage")
[10:32:43.179]                       }
[10:32:43.179]                       else if (inherits(cond, "warning")) {
[10:32:43.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.179]                         if (muffled) 
[10:32:43.179]                           invokeRestart("muffleWarning")
[10:32:43.179]                       }
[10:32:43.179]                       else if (inherits(cond, "condition")) {
[10:32:43.179]                         if (!is.null(pattern)) {
[10:32:43.179]                           computeRestarts <- base::computeRestarts
[10:32:43.179]                           grepl <- base::grepl
[10:32:43.179]                           restarts <- computeRestarts(cond)
[10:32:43.179]                           for (restart in restarts) {
[10:32:43.179]                             name <- restart$name
[10:32:43.179]                             if (is.null(name)) 
[10:32:43.179]                               next
[10:32:43.179]                             if (!grepl(pattern, name)) 
[10:32:43.179]                               next
[10:32:43.179]                             invokeRestart(restart)
[10:32:43.179]                             muffled <- TRUE
[10:32:43.179]                             break
[10:32:43.179]                           }
[10:32:43.179]                         }
[10:32:43.179]                       }
[10:32:43.179]                       invisible(muffled)
[10:32:43.179]                     }
[10:32:43.179]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.179]                   }
[10:32:43.179]                 }
[10:32:43.179]                 else {
[10:32:43.179]                   if (TRUE) {
[10:32:43.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.179]                     {
[10:32:43.179]                       inherits <- base::inherits
[10:32:43.179]                       invokeRestart <- base::invokeRestart
[10:32:43.179]                       is.null <- base::is.null
[10:32:43.179]                       muffled <- FALSE
[10:32:43.179]                       if (inherits(cond, "message")) {
[10:32:43.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.179]                         if (muffled) 
[10:32:43.179]                           invokeRestart("muffleMessage")
[10:32:43.179]                       }
[10:32:43.179]                       else if (inherits(cond, "warning")) {
[10:32:43.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.179]                         if (muffled) 
[10:32:43.179]                           invokeRestart("muffleWarning")
[10:32:43.179]                       }
[10:32:43.179]                       else if (inherits(cond, "condition")) {
[10:32:43.179]                         if (!is.null(pattern)) {
[10:32:43.179]                           computeRestarts <- base::computeRestarts
[10:32:43.179]                           grepl <- base::grepl
[10:32:43.179]                           restarts <- computeRestarts(cond)
[10:32:43.179]                           for (restart in restarts) {
[10:32:43.179]                             name <- restart$name
[10:32:43.179]                             if (is.null(name)) 
[10:32:43.179]                               next
[10:32:43.179]                             if (!grepl(pattern, name)) 
[10:32:43.179]                               next
[10:32:43.179]                             invokeRestart(restart)
[10:32:43.179]                             muffled <- TRUE
[10:32:43.179]                             break
[10:32:43.179]                           }
[10:32:43.179]                         }
[10:32:43.179]                       }
[10:32:43.179]                       invisible(muffled)
[10:32:43.179]                     }
[10:32:43.179]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.179]                   }
[10:32:43.179]                 }
[10:32:43.179]             }
[10:32:43.179]         }))
[10:32:43.179]     }, error = function(ex) {
[10:32:43.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.179]                 ...future.rng), started = ...future.startTime, 
[10:32:43.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.179]             version = "1.8"), class = "FutureResult")
[10:32:43.179]     }, finally = {
[10:32:43.179]         if (!identical(...future.workdir, getwd())) 
[10:32:43.179]             setwd(...future.workdir)
[10:32:43.179]         {
[10:32:43.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.179]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.179]             }
[10:32:43.179]             base::options(...future.oldOptions)
[10:32:43.179]             if (.Platform$OS.type == "windows") {
[10:32:43.179]                 old_names <- names(...future.oldEnvVars)
[10:32:43.179]                 envs <- base::Sys.getenv()
[10:32:43.179]                 names <- names(envs)
[10:32:43.179]                 common <- intersect(names, old_names)
[10:32:43.179]                 added <- setdiff(names, old_names)
[10:32:43.179]                 removed <- setdiff(old_names, names)
[10:32:43.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.179]                   envs[common]]
[10:32:43.179]                 NAMES <- toupper(changed)
[10:32:43.179]                 args <- list()
[10:32:43.179]                 for (kk in seq_along(NAMES)) {
[10:32:43.179]                   name <- changed[[kk]]
[10:32:43.179]                   NAME <- NAMES[[kk]]
[10:32:43.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.179]                     next
[10:32:43.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.179]                 }
[10:32:43.179]                 NAMES <- toupper(added)
[10:32:43.179]                 for (kk in seq_along(NAMES)) {
[10:32:43.179]                   name <- added[[kk]]
[10:32:43.179]                   NAME <- NAMES[[kk]]
[10:32:43.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.179]                     next
[10:32:43.179]                   args[[name]] <- ""
[10:32:43.179]                 }
[10:32:43.179]                 NAMES <- toupper(removed)
[10:32:43.179]                 for (kk in seq_along(NAMES)) {
[10:32:43.179]                   name <- removed[[kk]]
[10:32:43.179]                   NAME <- NAMES[[kk]]
[10:32:43.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.179]                     next
[10:32:43.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.179]                 }
[10:32:43.179]                 if (length(args) > 0) 
[10:32:43.179]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.179]             }
[10:32:43.179]             else {
[10:32:43.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.179]             }
[10:32:43.179]             {
[10:32:43.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.179]                   0L) {
[10:32:43.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.179]                   base::options(opts)
[10:32:43.179]                 }
[10:32:43.179]                 {
[10:32:43.179]                   {
[10:32:43.179]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.179]                     NULL
[10:32:43.179]                   }
[10:32:43.179]                   options(future.plan = NULL)
[10:32:43.179]                   if (is.na(NA_character_)) 
[10:32:43.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.179]                     .init = FALSE)
[10:32:43.179]                 }
[10:32:43.179]             }
[10:32:43.179]         }
[10:32:43.179]     })
[10:32:43.179]     if (TRUE) {
[10:32:43.179]         base::sink(type = "output", split = FALSE)
[10:32:43.179]         if (TRUE) {
[10:32:43.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.179]         }
[10:32:43.179]         else {
[10:32:43.179]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.179]         }
[10:32:43.179]         base::close(...future.stdout)
[10:32:43.179]         ...future.stdout <- NULL
[10:32:43.179]     }
[10:32:43.179]     ...future.result$conditions <- ...future.conditions
[10:32:43.179]     ...future.result$finished <- base::Sys.time()
[10:32:43.179]     ...future.result
[10:32:43.179] }
[10:32:43.181] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:32:43.182] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:32:43.182] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:32:43.182] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:32:43.182] MultisessionFuture started
[10:32:43.183] - Launch lazy future ... done
[10:32:43.183] run() for ‘MultisessionFuture’ ... done
[10:32:43.183] getGlobalsAndPackages() ...
[10:32:43.183] Searching for globals...
[10:32:43.185] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:43.185] Searching for globals ... DONE
[10:32:43.185] Resolving globals: FALSE
[10:32:43.185] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:43.186] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:43.186] - globals: [1] ‘ii’
[10:32:43.186] 
[10:32:43.186] getGlobalsAndPackages() ... DONE
[10:32:43.186] run() for ‘Future’ ...
[10:32:43.186] - state: ‘created’
[10:32:43.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.200]   - Field: ‘node’
[10:32:43.200]   - Field: ‘label’
[10:32:43.200]   - Field: ‘local’
[10:32:43.201]   - Field: ‘owner’
[10:32:43.201]   - Field: ‘envir’
[10:32:43.201]   - Field: ‘workers’
[10:32:43.201]   - Field: ‘packages’
[10:32:43.201]   - Field: ‘gc’
[10:32:43.201]   - Field: ‘conditions’
[10:32:43.201]   - Field: ‘persistent’
[10:32:43.201]   - Field: ‘expr’
[10:32:43.201]   - Field: ‘uuid’
[10:32:43.201]   - Field: ‘seed’
[10:32:43.202]   - Field: ‘version’
[10:32:43.202]   - Field: ‘result’
[10:32:43.202]   - Field: ‘asynchronous’
[10:32:43.202]   - Field: ‘calls’
[10:32:43.202]   - Field: ‘globals’
[10:32:43.202]   - Field: ‘stdout’
[10:32:43.202]   - Field: ‘earlySignal’
[10:32:43.202]   - Field: ‘lazy’
[10:32:43.202]   - Field: ‘state’
[10:32:43.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.202] - Launch lazy future ...
[10:32:43.203] Packages needed by the future expression (n = 0): <none>
[10:32:43.203] Packages needed by future strategies (n = 0): <none>
[10:32:43.203] {
[10:32:43.203]     {
[10:32:43.203]         {
[10:32:43.203]             ...future.startTime <- base::Sys.time()
[10:32:43.203]             {
[10:32:43.203]                 {
[10:32:43.203]                   {
[10:32:43.203]                     {
[10:32:43.203]                       base::local({
[10:32:43.203]                         has_future <- base::requireNamespace("future", 
[10:32:43.203]                           quietly = TRUE)
[10:32:43.203]                         if (has_future) {
[10:32:43.203]                           ns <- base::getNamespace("future")
[10:32:43.203]                           version <- ns[[".package"]][["version"]]
[10:32:43.203]                           if (is.null(version)) 
[10:32:43.203]                             version <- utils::packageVersion("future")
[10:32:43.203]                         }
[10:32:43.203]                         else {
[10:32:43.203]                           version <- NULL
[10:32:43.203]                         }
[10:32:43.203]                         if (!has_future || version < "1.8.0") {
[10:32:43.203]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.203]                             "", base::R.version$version.string), 
[10:32:43.203]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.203]                               "release", "version")], collapse = " "), 
[10:32:43.203]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.203]                             info)
[10:32:43.203]                           info <- base::paste(info, collapse = "; ")
[10:32:43.203]                           if (!has_future) {
[10:32:43.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.203]                               info)
[10:32:43.203]                           }
[10:32:43.203]                           else {
[10:32:43.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.203]                               info, version)
[10:32:43.203]                           }
[10:32:43.203]                           base::stop(msg)
[10:32:43.203]                         }
[10:32:43.203]                       })
[10:32:43.203]                     }
[10:32:43.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.203]                     base::options(mc.cores = 1L)
[10:32:43.203]                   }
[10:32:43.203]                   ...future.strategy.old <- future::plan("list")
[10:32:43.203]                   options(future.plan = NULL)
[10:32:43.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.203]                 }
[10:32:43.203]                 ...future.workdir <- getwd()
[10:32:43.203]             }
[10:32:43.203]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.203]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.203]         }
[10:32:43.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.203]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.203]             base::names(...future.oldOptions))
[10:32:43.203]     }
[10:32:43.203]     if (FALSE) {
[10:32:43.203]     }
[10:32:43.203]     else {
[10:32:43.203]         if (TRUE) {
[10:32:43.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.203]                 open = "w")
[10:32:43.203]         }
[10:32:43.203]         else {
[10:32:43.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.203]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.203]         }
[10:32:43.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.203]             base::sink(type = "output", split = FALSE)
[10:32:43.203]             base::close(...future.stdout)
[10:32:43.203]         }, add = TRUE)
[10:32:43.203]     }
[10:32:43.203]     ...future.frame <- base::sys.nframe()
[10:32:43.203]     ...future.conditions <- base::list()
[10:32:43.203]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.203]     if (FALSE) {
[10:32:43.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.203]     }
[10:32:43.203]     ...future.result <- base::tryCatch({
[10:32:43.203]         base::withCallingHandlers({
[10:32:43.203]             ...future.value <- base::withVisible(base::local({
[10:32:43.203]                 ...future.makeSendCondition <- base::local({
[10:32:43.203]                   sendCondition <- NULL
[10:32:43.203]                   function(frame = 1L) {
[10:32:43.203]                     if (is.function(sendCondition)) 
[10:32:43.203]                       return(sendCondition)
[10:32:43.203]                     ns <- getNamespace("parallel")
[10:32:43.203]                     if (exists("sendData", mode = "function", 
[10:32:43.203]                       envir = ns)) {
[10:32:43.203]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.203]                         envir = ns)
[10:32:43.203]                       envir <- sys.frame(frame)
[10:32:43.203]                       master <- NULL
[10:32:43.203]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.203]                         !identical(envir, emptyenv())) {
[10:32:43.203]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.203]                           inherits = FALSE)) {
[10:32:43.203]                           master <- get("master", mode = "list", 
[10:32:43.203]                             envir = envir, inherits = FALSE)
[10:32:43.203]                           if (inherits(master, c("SOCKnode", 
[10:32:43.203]                             "SOCK0node"))) {
[10:32:43.203]                             sendCondition <<- function(cond) {
[10:32:43.203]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.203]                                 success = TRUE)
[10:32:43.203]                               parallel_sendData(master, data)
[10:32:43.203]                             }
[10:32:43.203]                             return(sendCondition)
[10:32:43.203]                           }
[10:32:43.203]                         }
[10:32:43.203]                         frame <- frame + 1L
[10:32:43.203]                         envir <- sys.frame(frame)
[10:32:43.203]                       }
[10:32:43.203]                     }
[10:32:43.203]                     sendCondition <<- function(cond) NULL
[10:32:43.203]                   }
[10:32:43.203]                 })
[10:32:43.203]                 withCallingHandlers({
[10:32:43.203]                   {
[10:32:43.203]                     if (ii%%2 == 0) 
[10:32:43.203]                       stop("Woops!")
[10:32:43.203]                     ii
[10:32:43.203]                   }
[10:32:43.203]                 }, immediateCondition = function(cond) {
[10:32:43.203]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.203]                   sendCondition(cond)
[10:32:43.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.203]                   {
[10:32:43.203]                     inherits <- base::inherits
[10:32:43.203]                     invokeRestart <- base::invokeRestart
[10:32:43.203]                     is.null <- base::is.null
[10:32:43.203]                     muffled <- FALSE
[10:32:43.203]                     if (inherits(cond, "message")) {
[10:32:43.203]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.203]                       if (muffled) 
[10:32:43.203]                         invokeRestart("muffleMessage")
[10:32:43.203]                     }
[10:32:43.203]                     else if (inherits(cond, "warning")) {
[10:32:43.203]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.203]                       if (muffled) 
[10:32:43.203]                         invokeRestart("muffleWarning")
[10:32:43.203]                     }
[10:32:43.203]                     else if (inherits(cond, "condition")) {
[10:32:43.203]                       if (!is.null(pattern)) {
[10:32:43.203]                         computeRestarts <- base::computeRestarts
[10:32:43.203]                         grepl <- base::grepl
[10:32:43.203]                         restarts <- computeRestarts(cond)
[10:32:43.203]                         for (restart in restarts) {
[10:32:43.203]                           name <- restart$name
[10:32:43.203]                           if (is.null(name)) 
[10:32:43.203]                             next
[10:32:43.203]                           if (!grepl(pattern, name)) 
[10:32:43.203]                             next
[10:32:43.203]                           invokeRestart(restart)
[10:32:43.203]                           muffled <- TRUE
[10:32:43.203]                           break
[10:32:43.203]                         }
[10:32:43.203]                       }
[10:32:43.203]                     }
[10:32:43.203]                     invisible(muffled)
[10:32:43.203]                   }
[10:32:43.203]                   muffleCondition(cond)
[10:32:43.203]                 })
[10:32:43.203]             }))
[10:32:43.203]             future::FutureResult(value = ...future.value$value, 
[10:32:43.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.203]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.203]                     ...future.globalenv.names))
[10:32:43.203]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.203]         }, condition = base::local({
[10:32:43.203]             c <- base::c
[10:32:43.203]             inherits <- base::inherits
[10:32:43.203]             invokeRestart <- base::invokeRestart
[10:32:43.203]             length <- base::length
[10:32:43.203]             list <- base::list
[10:32:43.203]             seq.int <- base::seq.int
[10:32:43.203]             signalCondition <- base::signalCondition
[10:32:43.203]             sys.calls <- base::sys.calls
[10:32:43.203]             `[[` <- base::`[[`
[10:32:43.203]             `+` <- base::`+`
[10:32:43.203]             `<<-` <- base::`<<-`
[10:32:43.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.203]                   3L)]
[10:32:43.203]             }
[10:32:43.203]             function(cond) {
[10:32:43.203]                 is_error <- inherits(cond, "error")
[10:32:43.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.203]                   NULL)
[10:32:43.203]                 if (is_error) {
[10:32:43.203]                   sessionInformation <- function() {
[10:32:43.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.203]                       search = base::search(), system = base::Sys.info())
[10:32:43.203]                   }
[10:32:43.203]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.203]                     cond$call), session = sessionInformation(), 
[10:32:43.203]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.203]                   signalCondition(cond)
[10:32:43.203]                 }
[10:32:43.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.203]                 "immediateCondition"))) {
[10:32:43.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.203]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.203]                   if (TRUE && !signal) {
[10:32:43.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.203]                     {
[10:32:43.203]                       inherits <- base::inherits
[10:32:43.203]                       invokeRestart <- base::invokeRestart
[10:32:43.203]                       is.null <- base::is.null
[10:32:43.203]                       muffled <- FALSE
[10:32:43.203]                       if (inherits(cond, "message")) {
[10:32:43.203]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.203]                         if (muffled) 
[10:32:43.203]                           invokeRestart("muffleMessage")
[10:32:43.203]                       }
[10:32:43.203]                       else if (inherits(cond, "warning")) {
[10:32:43.203]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.203]                         if (muffled) 
[10:32:43.203]                           invokeRestart("muffleWarning")
[10:32:43.203]                       }
[10:32:43.203]                       else if (inherits(cond, "condition")) {
[10:32:43.203]                         if (!is.null(pattern)) {
[10:32:43.203]                           computeRestarts <- base::computeRestarts
[10:32:43.203]                           grepl <- base::grepl
[10:32:43.203]                           restarts <- computeRestarts(cond)
[10:32:43.203]                           for (restart in restarts) {
[10:32:43.203]                             name <- restart$name
[10:32:43.203]                             if (is.null(name)) 
[10:32:43.203]                               next
[10:32:43.203]                             if (!grepl(pattern, name)) 
[10:32:43.203]                               next
[10:32:43.203]                             invokeRestart(restart)
[10:32:43.203]                             muffled <- TRUE
[10:32:43.203]                             break
[10:32:43.203]                           }
[10:32:43.203]                         }
[10:32:43.203]                       }
[10:32:43.203]                       invisible(muffled)
[10:32:43.203]                     }
[10:32:43.203]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.203]                   }
[10:32:43.203]                 }
[10:32:43.203]                 else {
[10:32:43.203]                   if (TRUE) {
[10:32:43.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.203]                     {
[10:32:43.203]                       inherits <- base::inherits
[10:32:43.203]                       invokeRestart <- base::invokeRestart
[10:32:43.203]                       is.null <- base::is.null
[10:32:43.203]                       muffled <- FALSE
[10:32:43.203]                       if (inherits(cond, "message")) {
[10:32:43.203]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.203]                         if (muffled) 
[10:32:43.203]                           invokeRestart("muffleMessage")
[10:32:43.203]                       }
[10:32:43.203]                       else if (inherits(cond, "warning")) {
[10:32:43.203]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.203]                         if (muffled) 
[10:32:43.203]                           invokeRestart("muffleWarning")
[10:32:43.203]                       }
[10:32:43.203]                       else if (inherits(cond, "condition")) {
[10:32:43.203]                         if (!is.null(pattern)) {
[10:32:43.203]                           computeRestarts <- base::computeRestarts
[10:32:43.203]                           grepl <- base::grepl
[10:32:43.203]                           restarts <- computeRestarts(cond)
[10:32:43.203]                           for (restart in restarts) {
[10:32:43.203]                             name <- restart$name
[10:32:43.203]                             if (is.null(name)) 
[10:32:43.203]                               next
[10:32:43.203]                             if (!grepl(pattern, name)) 
[10:32:43.203]                               next
[10:32:43.203]                             invokeRestart(restart)
[10:32:43.203]                             muffled <- TRUE
[10:32:43.203]                             break
[10:32:43.203]                           }
[10:32:43.203]                         }
[10:32:43.203]                       }
[10:32:43.203]                       invisible(muffled)
[10:32:43.203]                     }
[10:32:43.203]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.203]                   }
[10:32:43.203]                 }
[10:32:43.203]             }
[10:32:43.203]         }))
[10:32:43.203]     }, error = function(ex) {
[10:32:43.203]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.203]                 ...future.rng), started = ...future.startTime, 
[10:32:43.203]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.203]             version = "1.8"), class = "FutureResult")
[10:32:43.203]     }, finally = {
[10:32:43.203]         if (!identical(...future.workdir, getwd())) 
[10:32:43.203]             setwd(...future.workdir)
[10:32:43.203]         {
[10:32:43.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.203]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.203]             }
[10:32:43.203]             base::options(...future.oldOptions)
[10:32:43.203]             if (.Platform$OS.type == "windows") {
[10:32:43.203]                 old_names <- names(...future.oldEnvVars)
[10:32:43.203]                 envs <- base::Sys.getenv()
[10:32:43.203]                 names <- names(envs)
[10:32:43.203]                 common <- intersect(names, old_names)
[10:32:43.203]                 added <- setdiff(names, old_names)
[10:32:43.203]                 removed <- setdiff(old_names, names)
[10:32:43.203]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.203]                   envs[common]]
[10:32:43.203]                 NAMES <- toupper(changed)
[10:32:43.203]                 args <- list()
[10:32:43.203]                 for (kk in seq_along(NAMES)) {
[10:32:43.203]                   name <- changed[[kk]]
[10:32:43.203]                   NAME <- NAMES[[kk]]
[10:32:43.203]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.203]                     next
[10:32:43.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.203]                 }
[10:32:43.203]                 NAMES <- toupper(added)
[10:32:43.203]                 for (kk in seq_along(NAMES)) {
[10:32:43.203]                   name <- added[[kk]]
[10:32:43.203]                   NAME <- NAMES[[kk]]
[10:32:43.203]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.203]                     next
[10:32:43.203]                   args[[name]] <- ""
[10:32:43.203]                 }
[10:32:43.203]                 NAMES <- toupper(removed)
[10:32:43.203]                 for (kk in seq_along(NAMES)) {
[10:32:43.203]                   name <- removed[[kk]]
[10:32:43.203]                   NAME <- NAMES[[kk]]
[10:32:43.203]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.203]                     next
[10:32:43.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.203]                 }
[10:32:43.203]                 if (length(args) > 0) 
[10:32:43.203]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.203]             }
[10:32:43.203]             else {
[10:32:43.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.203]             }
[10:32:43.203]             {
[10:32:43.203]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.203]                   0L) {
[10:32:43.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.203]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.203]                   base::options(opts)
[10:32:43.203]                 }
[10:32:43.203]                 {
[10:32:43.203]                   {
[10:32:43.203]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.203]                     NULL
[10:32:43.203]                   }
[10:32:43.203]                   options(future.plan = NULL)
[10:32:43.203]                   if (is.na(NA_character_)) 
[10:32:43.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.203]                     .init = FALSE)
[10:32:43.203]                 }
[10:32:43.203]             }
[10:32:43.203]         }
[10:32:43.203]     })
[10:32:43.203]     if (TRUE) {
[10:32:43.203]         base::sink(type = "output", split = FALSE)
[10:32:43.203]         if (TRUE) {
[10:32:43.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.203]         }
[10:32:43.203]         else {
[10:32:43.203]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.203]         }
[10:32:43.203]         base::close(...future.stdout)
[10:32:43.203]         ...future.stdout <- NULL
[10:32:43.203]     }
[10:32:43.203]     ...future.result$conditions <- ...future.conditions
[10:32:43.203]     ...future.result$finished <- base::Sys.time()
[10:32:43.203]     ...future.result
[10:32:43.203] }
[10:32:43.255] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:32:43.255] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:32:43.255] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:32:43.256] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:32:43.256] MultisessionFuture started
[10:32:43.256] - Launch lazy future ... done
[10:32:43.257] run() for ‘MultisessionFuture’ ... done
[10:32:43.257] getGlobalsAndPackages() ...
[10:32:43.257] Searching for globals...
[10:32:43.260] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:32:43.260] Searching for globals ... DONE
[10:32:43.260] Resolving globals: FALSE
[10:32:43.261] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:43.262] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:32:43.262] - globals: [1] ‘ii’
[10:32:43.262] 
[10:32:43.262] getGlobalsAndPackages() ... DONE
[10:32:43.262] run() for ‘Future’ ...
[10:32:43.263] - state: ‘created’
[10:32:43.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.279] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.279]   - Field: ‘node’
[10:32:43.279]   - Field: ‘label’
[10:32:43.279]   - Field: ‘local’
[10:32:43.280]   - Field: ‘owner’
[10:32:43.280]   - Field: ‘envir’
[10:32:43.280]   - Field: ‘workers’
[10:32:43.280]   - Field: ‘packages’
[10:32:43.280]   - Field: ‘gc’
[10:32:43.280]   - Field: ‘conditions’
[10:32:43.280]   - Field: ‘persistent’
[10:32:43.280]   - Field: ‘expr’
[10:32:43.280]   - Field: ‘uuid’
[10:32:43.280]   - Field: ‘seed’
[10:32:43.280]   - Field: ‘version’
[10:32:43.281]   - Field: ‘result’
[10:32:43.281]   - Field: ‘asynchronous’
[10:32:43.281]   - Field: ‘calls’
[10:32:43.281]   - Field: ‘globals’
[10:32:43.281]   - Field: ‘stdout’
[10:32:43.281]   - Field: ‘earlySignal’
[10:32:43.281]   - Field: ‘lazy’
[10:32:43.281]   - Field: ‘state’
[10:32:43.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.281] - Launch lazy future ...
[10:32:43.282] Packages needed by the future expression (n = 0): <none>
[10:32:43.282] Packages needed by future strategies (n = 0): <none>
[10:32:43.282] {
[10:32:43.282]     {
[10:32:43.282]         {
[10:32:43.282]             ...future.startTime <- base::Sys.time()
[10:32:43.282]             {
[10:32:43.282]                 {
[10:32:43.282]                   {
[10:32:43.282]                     {
[10:32:43.282]                       base::local({
[10:32:43.282]                         has_future <- base::requireNamespace("future", 
[10:32:43.282]                           quietly = TRUE)
[10:32:43.282]                         if (has_future) {
[10:32:43.282]                           ns <- base::getNamespace("future")
[10:32:43.282]                           version <- ns[[".package"]][["version"]]
[10:32:43.282]                           if (is.null(version)) 
[10:32:43.282]                             version <- utils::packageVersion("future")
[10:32:43.282]                         }
[10:32:43.282]                         else {
[10:32:43.282]                           version <- NULL
[10:32:43.282]                         }
[10:32:43.282]                         if (!has_future || version < "1.8.0") {
[10:32:43.282]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.282]                             "", base::R.version$version.string), 
[10:32:43.282]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.282]                               "release", "version")], collapse = " "), 
[10:32:43.282]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.282]                             info)
[10:32:43.282]                           info <- base::paste(info, collapse = "; ")
[10:32:43.282]                           if (!has_future) {
[10:32:43.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.282]                               info)
[10:32:43.282]                           }
[10:32:43.282]                           else {
[10:32:43.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.282]                               info, version)
[10:32:43.282]                           }
[10:32:43.282]                           base::stop(msg)
[10:32:43.282]                         }
[10:32:43.282]                       })
[10:32:43.282]                     }
[10:32:43.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.282]                     base::options(mc.cores = 1L)
[10:32:43.282]                   }
[10:32:43.282]                   ...future.strategy.old <- future::plan("list")
[10:32:43.282]                   options(future.plan = NULL)
[10:32:43.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.282]                 }
[10:32:43.282]                 ...future.workdir <- getwd()
[10:32:43.282]             }
[10:32:43.282]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.282]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.282]         }
[10:32:43.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.282]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.282]             base::names(...future.oldOptions))
[10:32:43.282]     }
[10:32:43.282]     if (FALSE) {
[10:32:43.282]     }
[10:32:43.282]     else {
[10:32:43.282]         if (TRUE) {
[10:32:43.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.282]                 open = "w")
[10:32:43.282]         }
[10:32:43.282]         else {
[10:32:43.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.282]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.282]         }
[10:32:43.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.282]             base::sink(type = "output", split = FALSE)
[10:32:43.282]             base::close(...future.stdout)
[10:32:43.282]         }, add = TRUE)
[10:32:43.282]     }
[10:32:43.282]     ...future.frame <- base::sys.nframe()
[10:32:43.282]     ...future.conditions <- base::list()
[10:32:43.282]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.282]     if (FALSE) {
[10:32:43.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.282]     }
[10:32:43.282]     ...future.result <- base::tryCatch({
[10:32:43.282]         base::withCallingHandlers({
[10:32:43.282]             ...future.value <- base::withVisible(base::local({
[10:32:43.282]                 ...future.makeSendCondition <- base::local({
[10:32:43.282]                   sendCondition <- NULL
[10:32:43.282]                   function(frame = 1L) {
[10:32:43.282]                     if (is.function(sendCondition)) 
[10:32:43.282]                       return(sendCondition)
[10:32:43.282]                     ns <- getNamespace("parallel")
[10:32:43.282]                     if (exists("sendData", mode = "function", 
[10:32:43.282]                       envir = ns)) {
[10:32:43.282]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.282]                         envir = ns)
[10:32:43.282]                       envir <- sys.frame(frame)
[10:32:43.282]                       master <- NULL
[10:32:43.282]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.282]                         !identical(envir, emptyenv())) {
[10:32:43.282]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.282]                           inherits = FALSE)) {
[10:32:43.282]                           master <- get("master", mode = "list", 
[10:32:43.282]                             envir = envir, inherits = FALSE)
[10:32:43.282]                           if (inherits(master, c("SOCKnode", 
[10:32:43.282]                             "SOCK0node"))) {
[10:32:43.282]                             sendCondition <<- function(cond) {
[10:32:43.282]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.282]                                 success = TRUE)
[10:32:43.282]                               parallel_sendData(master, data)
[10:32:43.282]                             }
[10:32:43.282]                             return(sendCondition)
[10:32:43.282]                           }
[10:32:43.282]                         }
[10:32:43.282]                         frame <- frame + 1L
[10:32:43.282]                         envir <- sys.frame(frame)
[10:32:43.282]                       }
[10:32:43.282]                     }
[10:32:43.282]                     sendCondition <<- function(cond) NULL
[10:32:43.282]                   }
[10:32:43.282]                 })
[10:32:43.282]                 withCallingHandlers({
[10:32:43.282]                   {
[10:32:43.282]                     if (ii%%2 == 0) 
[10:32:43.282]                       stop("Woops!")
[10:32:43.282]                     ii
[10:32:43.282]                   }
[10:32:43.282]                 }, immediateCondition = function(cond) {
[10:32:43.282]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.282]                   sendCondition(cond)
[10:32:43.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.282]                   {
[10:32:43.282]                     inherits <- base::inherits
[10:32:43.282]                     invokeRestart <- base::invokeRestart
[10:32:43.282]                     is.null <- base::is.null
[10:32:43.282]                     muffled <- FALSE
[10:32:43.282]                     if (inherits(cond, "message")) {
[10:32:43.282]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.282]                       if (muffled) 
[10:32:43.282]                         invokeRestart("muffleMessage")
[10:32:43.282]                     }
[10:32:43.282]                     else if (inherits(cond, "warning")) {
[10:32:43.282]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.282]                       if (muffled) 
[10:32:43.282]                         invokeRestart("muffleWarning")
[10:32:43.282]                     }
[10:32:43.282]                     else if (inherits(cond, "condition")) {
[10:32:43.282]                       if (!is.null(pattern)) {
[10:32:43.282]                         computeRestarts <- base::computeRestarts
[10:32:43.282]                         grepl <- base::grepl
[10:32:43.282]                         restarts <- computeRestarts(cond)
[10:32:43.282]                         for (restart in restarts) {
[10:32:43.282]                           name <- restart$name
[10:32:43.282]                           if (is.null(name)) 
[10:32:43.282]                             next
[10:32:43.282]                           if (!grepl(pattern, name)) 
[10:32:43.282]                             next
[10:32:43.282]                           invokeRestart(restart)
[10:32:43.282]                           muffled <- TRUE
[10:32:43.282]                           break
[10:32:43.282]                         }
[10:32:43.282]                       }
[10:32:43.282]                     }
[10:32:43.282]                     invisible(muffled)
[10:32:43.282]                   }
[10:32:43.282]                   muffleCondition(cond)
[10:32:43.282]                 })
[10:32:43.282]             }))
[10:32:43.282]             future::FutureResult(value = ...future.value$value, 
[10:32:43.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.282]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.282]                     ...future.globalenv.names))
[10:32:43.282]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.282]         }, condition = base::local({
[10:32:43.282]             c <- base::c
[10:32:43.282]             inherits <- base::inherits
[10:32:43.282]             invokeRestart <- base::invokeRestart
[10:32:43.282]             length <- base::length
[10:32:43.282]             list <- base::list
[10:32:43.282]             seq.int <- base::seq.int
[10:32:43.282]             signalCondition <- base::signalCondition
[10:32:43.282]             sys.calls <- base::sys.calls
[10:32:43.282]             `[[` <- base::`[[`
[10:32:43.282]             `+` <- base::`+`
[10:32:43.282]             `<<-` <- base::`<<-`
[10:32:43.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.282]                   3L)]
[10:32:43.282]             }
[10:32:43.282]             function(cond) {
[10:32:43.282]                 is_error <- inherits(cond, "error")
[10:32:43.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.282]                   NULL)
[10:32:43.282]                 if (is_error) {
[10:32:43.282]                   sessionInformation <- function() {
[10:32:43.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.282]                       search = base::search(), system = base::Sys.info())
[10:32:43.282]                   }
[10:32:43.282]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.282]                     cond$call), session = sessionInformation(), 
[10:32:43.282]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.282]                   signalCondition(cond)
[10:32:43.282]                 }
[10:32:43.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.282]                 "immediateCondition"))) {
[10:32:43.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.282]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.282]                   if (TRUE && !signal) {
[10:32:43.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.282]                     {
[10:32:43.282]                       inherits <- base::inherits
[10:32:43.282]                       invokeRestart <- base::invokeRestart
[10:32:43.282]                       is.null <- base::is.null
[10:32:43.282]                       muffled <- FALSE
[10:32:43.282]                       if (inherits(cond, "message")) {
[10:32:43.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.282]                         if (muffled) 
[10:32:43.282]                           invokeRestart("muffleMessage")
[10:32:43.282]                       }
[10:32:43.282]                       else if (inherits(cond, "warning")) {
[10:32:43.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.282]                         if (muffled) 
[10:32:43.282]                           invokeRestart("muffleWarning")
[10:32:43.282]                       }
[10:32:43.282]                       else if (inherits(cond, "condition")) {
[10:32:43.282]                         if (!is.null(pattern)) {
[10:32:43.282]                           computeRestarts <- base::computeRestarts
[10:32:43.282]                           grepl <- base::grepl
[10:32:43.282]                           restarts <- computeRestarts(cond)
[10:32:43.282]                           for (restart in restarts) {
[10:32:43.282]                             name <- restart$name
[10:32:43.282]                             if (is.null(name)) 
[10:32:43.282]                               next
[10:32:43.282]                             if (!grepl(pattern, name)) 
[10:32:43.282]                               next
[10:32:43.282]                             invokeRestart(restart)
[10:32:43.282]                             muffled <- TRUE
[10:32:43.282]                             break
[10:32:43.282]                           }
[10:32:43.282]                         }
[10:32:43.282]                       }
[10:32:43.282]                       invisible(muffled)
[10:32:43.282]                     }
[10:32:43.282]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.282]                   }
[10:32:43.282]                 }
[10:32:43.282]                 else {
[10:32:43.282]                   if (TRUE) {
[10:32:43.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.282]                     {
[10:32:43.282]                       inherits <- base::inherits
[10:32:43.282]                       invokeRestart <- base::invokeRestart
[10:32:43.282]                       is.null <- base::is.null
[10:32:43.282]                       muffled <- FALSE
[10:32:43.282]                       if (inherits(cond, "message")) {
[10:32:43.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.282]                         if (muffled) 
[10:32:43.282]                           invokeRestart("muffleMessage")
[10:32:43.282]                       }
[10:32:43.282]                       else if (inherits(cond, "warning")) {
[10:32:43.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.282]                         if (muffled) 
[10:32:43.282]                           invokeRestart("muffleWarning")
[10:32:43.282]                       }
[10:32:43.282]                       else if (inherits(cond, "condition")) {
[10:32:43.282]                         if (!is.null(pattern)) {
[10:32:43.282]                           computeRestarts <- base::computeRestarts
[10:32:43.282]                           grepl <- base::grepl
[10:32:43.282]                           restarts <- computeRestarts(cond)
[10:32:43.282]                           for (restart in restarts) {
[10:32:43.282]                             name <- restart$name
[10:32:43.282]                             if (is.null(name)) 
[10:32:43.282]                               next
[10:32:43.282]                             if (!grepl(pattern, name)) 
[10:32:43.282]                               next
[10:32:43.282]                             invokeRestart(restart)
[10:32:43.282]                             muffled <- TRUE
[10:32:43.282]                             break
[10:32:43.282]                           }
[10:32:43.282]                         }
[10:32:43.282]                       }
[10:32:43.282]                       invisible(muffled)
[10:32:43.282]                     }
[10:32:43.282]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.282]                   }
[10:32:43.282]                 }
[10:32:43.282]             }
[10:32:43.282]         }))
[10:32:43.282]     }, error = function(ex) {
[10:32:43.282]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.282]                 ...future.rng), started = ...future.startTime, 
[10:32:43.282]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.282]             version = "1.8"), class = "FutureResult")
[10:32:43.282]     }, finally = {
[10:32:43.282]         if (!identical(...future.workdir, getwd())) 
[10:32:43.282]             setwd(...future.workdir)
[10:32:43.282]         {
[10:32:43.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.282]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.282]             }
[10:32:43.282]             base::options(...future.oldOptions)
[10:32:43.282]             if (.Platform$OS.type == "windows") {
[10:32:43.282]                 old_names <- names(...future.oldEnvVars)
[10:32:43.282]                 envs <- base::Sys.getenv()
[10:32:43.282]                 names <- names(envs)
[10:32:43.282]                 common <- intersect(names, old_names)
[10:32:43.282]                 added <- setdiff(names, old_names)
[10:32:43.282]                 removed <- setdiff(old_names, names)
[10:32:43.282]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.282]                   envs[common]]
[10:32:43.282]                 NAMES <- toupper(changed)
[10:32:43.282]                 args <- list()
[10:32:43.282]                 for (kk in seq_along(NAMES)) {
[10:32:43.282]                   name <- changed[[kk]]
[10:32:43.282]                   NAME <- NAMES[[kk]]
[10:32:43.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.282]                     next
[10:32:43.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.282]                 }
[10:32:43.282]                 NAMES <- toupper(added)
[10:32:43.282]                 for (kk in seq_along(NAMES)) {
[10:32:43.282]                   name <- added[[kk]]
[10:32:43.282]                   NAME <- NAMES[[kk]]
[10:32:43.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.282]                     next
[10:32:43.282]                   args[[name]] <- ""
[10:32:43.282]                 }
[10:32:43.282]                 NAMES <- toupper(removed)
[10:32:43.282]                 for (kk in seq_along(NAMES)) {
[10:32:43.282]                   name <- removed[[kk]]
[10:32:43.282]                   NAME <- NAMES[[kk]]
[10:32:43.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.282]                     next
[10:32:43.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.282]                 }
[10:32:43.282]                 if (length(args) > 0) 
[10:32:43.282]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.282]             }
[10:32:43.282]             else {
[10:32:43.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.282]             }
[10:32:43.282]             {
[10:32:43.282]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.282]                   0L) {
[10:32:43.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.282]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.282]                   base::options(opts)
[10:32:43.282]                 }
[10:32:43.282]                 {
[10:32:43.282]                   {
[10:32:43.282]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.282]                     NULL
[10:32:43.282]                   }
[10:32:43.282]                   options(future.plan = NULL)
[10:32:43.282]                   if (is.na(NA_character_)) 
[10:32:43.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.282]                     .init = FALSE)
[10:32:43.282]                 }
[10:32:43.282]             }
[10:32:43.282]         }
[10:32:43.282]     })
[10:32:43.282]     if (TRUE) {
[10:32:43.282]         base::sink(type = "output", split = FALSE)
[10:32:43.282]         if (TRUE) {
[10:32:43.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.282]         }
[10:32:43.282]         else {
[10:32:43.282]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.282]         }
[10:32:43.282]         base::close(...future.stdout)
[10:32:43.282]         ...future.stdout <- NULL
[10:32:43.282]     }
[10:32:43.282]     ...future.result$conditions <- ...future.conditions
[10:32:43.282]     ...future.result$finished <- base::Sys.time()
[10:32:43.282]     ...future.result
[10:32:43.282] }
[10:32:43.284] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:43.304] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.304] - Validating connection of MultisessionFuture
[10:32:43.304] - received message: FutureResult
[10:32:43.304] - Received FutureResult
[10:32:43.304] - Erased future from FutureRegistry
[10:32:43.304] result() for ClusterFuture ...
[10:32:43.304] - result already collected: FutureResult
[10:32:43.305] result() for ClusterFuture ... done
[10:32:43.305] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.305] result() for ClusterFuture ...
[10:32:43.305] - result already collected: FutureResult
[10:32:43.305] result() for ClusterFuture ... done
[10:32:43.305] result() for ClusterFuture ...
[10:32:43.305] - result already collected: FutureResult
[10:32:43.305] result() for ClusterFuture ... done
[10:32:43.306] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:32:43.306] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:32:43.307] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:32:43.307] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:32:43.307] MultisessionFuture started
[10:32:43.307] - Launch lazy future ... done
[10:32:43.308] run() for ‘MultisessionFuture’ ... done
[10:32:43.308] result() for ClusterFuture ...
[10:32:43.308] - result already collected: FutureResult
[10:32:43.308] result() for ClusterFuture ... done
[10:32:43.308] result() for ClusterFuture ...
[10:32:43.308] - result already collected: FutureResult
[10:32:43.309] result() for ClusterFuture ... done
[10:32:43.309] result() for ClusterFuture ...
[10:32:43.309] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.309] - Validating connection of MultisessionFuture
[10:32:43.310] - received message: FutureResult
[10:32:43.310] - Received FutureResult
[10:32:43.310] - Erased future from FutureRegistry
[10:32:43.310] result() for ClusterFuture ...
[10:32:43.310] - result already collected: FutureResult
[10:32:43.310] result() for ClusterFuture ... done
[10:32:43.310] signalConditions() ...
[10:32:43.310]  - include = ‘immediateCondition’
[10:32:43.311]  - exclude = 
[10:32:43.311]  - resignal = FALSE
[10:32:43.311]  - Number of conditions: 1
[10:32:43.311] signalConditions() ... done
[10:32:43.311] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.311] result() for ClusterFuture ... done
[10:32:43.311] result() for ClusterFuture ...
[10:32:43.311] - result already collected: FutureResult
[10:32:43.311] result() for ClusterFuture ... done
[10:32:43.311] signalConditions() ...
[10:32:43.312]  - include = ‘immediateCondition’
[10:32:43.312]  - exclude = 
[10:32:43.312]  - resignal = FALSE
[10:32:43.312]  - Number of conditions: 1
[10:32:43.312] signalConditions() ... done
[10:32:43.312] Future state: ‘finished’
[10:32:43.312] result() for ClusterFuture ...
[10:32:43.312] - result already collected: FutureResult
[10:32:43.312] result() for ClusterFuture ... done
[10:32:43.312] signalConditions() ...
[10:32:43.312]  - include = ‘condition’
[10:32:43.313]  - exclude = ‘immediateCondition’
[10:32:43.313]  - resignal = TRUE
[10:32:43.313]  - Number of conditions: 1
[10:32:43.313]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:43.313] signalConditions() ... done
[10:32:43.313] result() for ClusterFuture ...
[10:32:43.313] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.314] - Validating connection of MultisessionFuture
[10:32:43.314] - received message: FutureResult
[10:32:43.314] - Received FutureResult
[10:32:43.314] - Erased future from FutureRegistry
[10:32:43.314] result() for ClusterFuture ...
[10:32:43.314] - result already collected: FutureResult
[10:32:43.314] result() for ClusterFuture ... done
[10:32:43.314] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.314] result() for ClusterFuture ... done
[10:32:43.314] result() for ClusterFuture ...
[10:32:43.314] - result already collected: FutureResult
[10:32:43.315] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:32:43.315] result() for ClusterFuture ...
[10:32:43.315] - result already collected: FutureResult
[10:32:43.315] result() for ClusterFuture ... done
[10:32:43.315] result() for ClusterFuture ...
[10:32:43.315] - result already collected: FutureResult
[10:32:43.315] result() for ClusterFuture ... done
[10:32:43.316] signalConditions() ...
[10:32:43.316]  - include = ‘immediateCondition’
[10:32:43.316]  - exclude = 
[10:32:43.316]  - resignal = FALSE
[10:32:43.316]  - Number of conditions: 1
[10:32:43.316] signalConditions() ... done
[10:32:43.316] Future state: ‘finished’
[10:32:43.316] result() for ClusterFuture ...
[10:32:43.316] - result already collected: FutureResult
[10:32:43.316] result() for ClusterFuture ... done
[10:32:43.316] signalConditions() ...
[10:32:43.317]  - include = ‘condition’
[10:32:43.317]  - exclude = ‘immediateCondition’
[10:32:43.317]  - resignal = TRUE
[10:32:43.317]  - Number of conditions: 1
[10:32:43.317]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:43.317] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:32:43.317] result() for ClusterFuture ...
[10:32:43.317] - result already collected: FutureResult
[10:32:43.318] result() for ClusterFuture ... done
[10:32:43.318] result() for ClusterFuture ...
[10:32:43.318] - result already collected: FutureResult
[10:32:43.318] result() for ClusterFuture ... done
[10:32:43.318] signalConditions() ...
[10:32:43.318]  - include = ‘immediateCondition’
[10:32:43.318]  - exclude = 
[10:32:43.318]  - resignal = FALSE
[10:32:43.318]  - Number of conditions: 1
[10:32:43.318] signalConditions() ... done
[10:32:43.318] Future state: ‘finished’
[10:32:43.319] result() for ClusterFuture ...
[10:32:43.319] - result already collected: FutureResult
[10:32:43.319] result() for ClusterFuture ... done
[10:32:43.319] signalConditions() ...
[10:32:43.319]  - include = ‘condition’
[10:32:43.319]  - exclude = ‘immediateCondition’
[10:32:43.319]  - resignal = TRUE
[10:32:43.319]  - Number of conditions: 1
[10:32:43.319]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:43.319] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[10:32:43.320] getGlobalsAndPackages() ...
[10:32:43.320] Searching for globals...
[10:32:43.322] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[10:32:43.322] Searching for globals ... DONE
[10:32:43.322] Resolving globals: FALSE
[10:32:43.322] 
[10:32:43.322] 
[10:32:43.322] getGlobalsAndPackages() ... DONE
[10:32:43.323] run() for ‘Future’ ...
[10:32:43.323] - state: ‘created’
[10:32:43.323] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.337] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.337]   - Field: ‘node’
[10:32:43.337]   - Field: ‘label’
[10:32:43.337]   - Field: ‘local’
[10:32:43.337]   - Field: ‘owner’
[10:32:43.337]   - Field: ‘envir’
[10:32:43.338]   - Field: ‘workers’
[10:32:43.338]   - Field: ‘packages’
[10:32:43.338]   - Field: ‘gc’
[10:32:43.338]   - Field: ‘conditions’
[10:32:43.338]   - Field: ‘persistent’
[10:32:43.338]   - Field: ‘expr’
[10:32:43.338]   - Field: ‘uuid’
[10:32:43.338]   - Field: ‘seed’
[10:32:43.338]   - Field: ‘version’
[10:32:43.338]   - Field: ‘result’
[10:32:43.338]   - Field: ‘asynchronous’
[10:32:43.339]   - Field: ‘calls’
[10:32:43.339]   - Field: ‘globals’
[10:32:43.339]   - Field: ‘stdout’
[10:32:43.339]   - Field: ‘earlySignal’
[10:32:43.339]   - Field: ‘lazy’
[10:32:43.339]   - Field: ‘state’
[10:32:43.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.339] - Launch lazy future ...
[10:32:43.339] Packages needed by the future expression (n = 0): <none>
[10:32:43.340] Packages needed by future strategies (n = 0): <none>
[10:32:43.340] {
[10:32:43.340]     {
[10:32:43.340]         {
[10:32:43.340]             ...future.startTime <- base::Sys.time()
[10:32:43.340]             {
[10:32:43.340]                 {
[10:32:43.340]                   {
[10:32:43.340]                     {
[10:32:43.340]                       base::local({
[10:32:43.340]                         has_future <- base::requireNamespace("future", 
[10:32:43.340]                           quietly = TRUE)
[10:32:43.340]                         if (has_future) {
[10:32:43.340]                           ns <- base::getNamespace("future")
[10:32:43.340]                           version <- ns[[".package"]][["version"]]
[10:32:43.340]                           if (is.null(version)) 
[10:32:43.340]                             version <- utils::packageVersion("future")
[10:32:43.340]                         }
[10:32:43.340]                         else {
[10:32:43.340]                           version <- NULL
[10:32:43.340]                         }
[10:32:43.340]                         if (!has_future || version < "1.8.0") {
[10:32:43.340]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.340]                             "", base::R.version$version.string), 
[10:32:43.340]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.340]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.340]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.340]                               "release", "version")], collapse = " "), 
[10:32:43.340]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.340]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.340]                             info)
[10:32:43.340]                           info <- base::paste(info, collapse = "; ")
[10:32:43.340]                           if (!has_future) {
[10:32:43.340]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.340]                               info)
[10:32:43.340]                           }
[10:32:43.340]                           else {
[10:32:43.340]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.340]                               info, version)
[10:32:43.340]                           }
[10:32:43.340]                           base::stop(msg)
[10:32:43.340]                         }
[10:32:43.340]                       })
[10:32:43.340]                     }
[10:32:43.340]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.340]                     base::options(mc.cores = 1L)
[10:32:43.340]                   }
[10:32:43.340]                   ...future.strategy.old <- future::plan("list")
[10:32:43.340]                   options(future.plan = NULL)
[10:32:43.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.340]                 }
[10:32:43.340]                 ...future.workdir <- getwd()
[10:32:43.340]             }
[10:32:43.340]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.340]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.340]         }
[10:32:43.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.340]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.340]             base::names(...future.oldOptions))
[10:32:43.340]     }
[10:32:43.340]     if (FALSE) {
[10:32:43.340]     }
[10:32:43.340]     else {
[10:32:43.340]         if (TRUE) {
[10:32:43.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.340]                 open = "w")
[10:32:43.340]         }
[10:32:43.340]         else {
[10:32:43.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.340]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.340]         }
[10:32:43.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.340]             base::sink(type = "output", split = FALSE)
[10:32:43.340]             base::close(...future.stdout)
[10:32:43.340]         }, add = TRUE)
[10:32:43.340]     }
[10:32:43.340]     ...future.frame <- base::sys.nframe()
[10:32:43.340]     ...future.conditions <- base::list()
[10:32:43.340]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.340]     if (FALSE) {
[10:32:43.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.340]     }
[10:32:43.340]     ...future.result <- base::tryCatch({
[10:32:43.340]         base::withCallingHandlers({
[10:32:43.340]             ...future.value <- base::withVisible(base::local({
[10:32:43.340]                 ...future.makeSendCondition <- base::local({
[10:32:43.340]                   sendCondition <- NULL
[10:32:43.340]                   function(frame = 1L) {
[10:32:43.340]                     if (is.function(sendCondition)) 
[10:32:43.340]                       return(sendCondition)
[10:32:43.340]                     ns <- getNamespace("parallel")
[10:32:43.340]                     if (exists("sendData", mode = "function", 
[10:32:43.340]                       envir = ns)) {
[10:32:43.340]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.340]                         envir = ns)
[10:32:43.340]                       envir <- sys.frame(frame)
[10:32:43.340]                       master <- NULL
[10:32:43.340]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.340]                         !identical(envir, emptyenv())) {
[10:32:43.340]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.340]                           inherits = FALSE)) {
[10:32:43.340]                           master <- get("master", mode = "list", 
[10:32:43.340]                             envir = envir, inherits = FALSE)
[10:32:43.340]                           if (inherits(master, c("SOCKnode", 
[10:32:43.340]                             "SOCK0node"))) {
[10:32:43.340]                             sendCondition <<- function(cond) {
[10:32:43.340]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.340]                                 success = TRUE)
[10:32:43.340]                               parallel_sendData(master, data)
[10:32:43.340]                             }
[10:32:43.340]                             return(sendCondition)
[10:32:43.340]                           }
[10:32:43.340]                         }
[10:32:43.340]                         frame <- frame + 1L
[10:32:43.340]                         envir <- sys.frame(frame)
[10:32:43.340]                       }
[10:32:43.340]                     }
[10:32:43.340]                     sendCondition <<- function(cond) NULL
[10:32:43.340]                   }
[10:32:43.340]                 })
[10:32:43.340]                 withCallingHandlers({
[10:32:43.340]                   {
[10:32:43.340]                     cat("Processing: ")
[10:32:43.340]                     for (ii in 1:10) {
[10:32:43.340]                       cat(".")
[10:32:43.340]                     }
[10:32:43.340]                     cat(" [100%]\n")
[10:32:43.340]                     4
[10:32:43.340]                   }
[10:32:43.340]                 }, immediateCondition = function(cond) {
[10:32:43.340]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.340]                   sendCondition(cond)
[10:32:43.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.340]                   {
[10:32:43.340]                     inherits <- base::inherits
[10:32:43.340]                     invokeRestart <- base::invokeRestart
[10:32:43.340]                     is.null <- base::is.null
[10:32:43.340]                     muffled <- FALSE
[10:32:43.340]                     if (inherits(cond, "message")) {
[10:32:43.340]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.340]                       if (muffled) 
[10:32:43.340]                         invokeRestart("muffleMessage")
[10:32:43.340]                     }
[10:32:43.340]                     else if (inherits(cond, "warning")) {
[10:32:43.340]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.340]                       if (muffled) 
[10:32:43.340]                         invokeRestart("muffleWarning")
[10:32:43.340]                     }
[10:32:43.340]                     else if (inherits(cond, "condition")) {
[10:32:43.340]                       if (!is.null(pattern)) {
[10:32:43.340]                         computeRestarts <- base::computeRestarts
[10:32:43.340]                         grepl <- base::grepl
[10:32:43.340]                         restarts <- computeRestarts(cond)
[10:32:43.340]                         for (restart in restarts) {
[10:32:43.340]                           name <- restart$name
[10:32:43.340]                           if (is.null(name)) 
[10:32:43.340]                             next
[10:32:43.340]                           if (!grepl(pattern, name)) 
[10:32:43.340]                             next
[10:32:43.340]                           invokeRestart(restart)
[10:32:43.340]                           muffled <- TRUE
[10:32:43.340]                           break
[10:32:43.340]                         }
[10:32:43.340]                       }
[10:32:43.340]                     }
[10:32:43.340]                     invisible(muffled)
[10:32:43.340]                   }
[10:32:43.340]                   muffleCondition(cond)
[10:32:43.340]                 })
[10:32:43.340]             }))
[10:32:43.340]             future::FutureResult(value = ...future.value$value, 
[10:32:43.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.340]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.340]                     ...future.globalenv.names))
[10:32:43.340]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.340]         }, condition = base::local({
[10:32:43.340]             c <- base::c
[10:32:43.340]             inherits <- base::inherits
[10:32:43.340]             invokeRestart <- base::invokeRestart
[10:32:43.340]             length <- base::length
[10:32:43.340]             list <- base::list
[10:32:43.340]             seq.int <- base::seq.int
[10:32:43.340]             signalCondition <- base::signalCondition
[10:32:43.340]             sys.calls <- base::sys.calls
[10:32:43.340]             `[[` <- base::`[[`
[10:32:43.340]             `+` <- base::`+`
[10:32:43.340]             `<<-` <- base::`<<-`
[10:32:43.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.340]                   3L)]
[10:32:43.340]             }
[10:32:43.340]             function(cond) {
[10:32:43.340]                 is_error <- inherits(cond, "error")
[10:32:43.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.340]                   NULL)
[10:32:43.340]                 if (is_error) {
[10:32:43.340]                   sessionInformation <- function() {
[10:32:43.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.340]                       search = base::search(), system = base::Sys.info())
[10:32:43.340]                   }
[10:32:43.340]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.340]                     cond$call), session = sessionInformation(), 
[10:32:43.340]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.340]                   signalCondition(cond)
[10:32:43.340]                 }
[10:32:43.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.340]                 "immediateCondition"))) {
[10:32:43.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.340]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.340]                   if (TRUE && !signal) {
[10:32:43.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.340]                     {
[10:32:43.340]                       inherits <- base::inherits
[10:32:43.340]                       invokeRestart <- base::invokeRestart
[10:32:43.340]                       is.null <- base::is.null
[10:32:43.340]                       muffled <- FALSE
[10:32:43.340]                       if (inherits(cond, "message")) {
[10:32:43.340]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.340]                         if (muffled) 
[10:32:43.340]                           invokeRestart("muffleMessage")
[10:32:43.340]                       }
[10:32:43.340]                       else if (inherits(cond, "warning")) {
[10:32:43.340]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.340]                         if (muffled) 
[10:32:43.340]                           invokeRestart("muffleWarning")
[10:32:43.340]                       }
[10:32:43.340]                       else if (inherits(cond, "condition")) {
[10:32:43.340]                         if (!is.null(pattern)) {
[10:32:43.340]                           computeRestarts <- base::computeRestarts
[10:32:43.340]                           grepl <- base::grepl
[10:32:43.340]                           restarts <- computeRestarts(cond)
[10:32:43.340]                           for (restart in restarts) {
[10:32:43.340]                             name <- restart$name
[10:32:43.340]                             if (is.null(name)) 
[10:32:43.340]                               next
[10:32:43.340]                             if (!grepl(pattern, name)) 
[10:32:43.340]                               next
[10:32:43.340]                             invokeRestart(restart)
[10:32:43.340]                             muffled <- TRUE
[10:32:43.340]                             break
[10:32:43.340]                           }
[10:32:43.340]                         }
[10:32:43.340]                       }
[10:32:43.340]                       invisible(muffled)
[10:32:43.340]                     }
[10:32:43.340]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.340]                   }
[10:32:43.340]                 }
[10:32:43.340]                 else {
[10:32:43.340]                   if (TRUE) {
[10:32:43.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.340]                     {
[10:32:43.340]                       inherits <- base::inherits
[10:32:43.340]                       invokeRestart <- base::invokeRestart
[10:32:43.340]                       is.null <- base::is.null
[10:32:43.340]                       muffled <- FALSE
[10:32:43.340]                       if (inherits(cond, "message")) {
[10:32:43.340]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.340]                         if (muffled) 
[10:32:43.340]                           invokeRestart("muffleMessage")
[10:32:43.340]                       }
[10:32:43.340]                       else if (inherits(cond, "warning")) {
[10:32:43.340]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.340]                         if (muffled) 
[10:32:43.340]                           invokeRestart("muffleWarning")
[10:32:43.340]                       }
[10:32:43.340]                       else if (inherits(cond, "condition")) {
[10:32:43.340]                         if (!is.null(pattern)) {
[10:32:43.340]                           computeRestarts <- base::computeRestarts
[10:32:43.340]                           grepl <- base::grepl
[10:32:43.340]                           restarts <- computeRestarts(cond)
[10:32:43.340]                           for (restart in restarts) {
[10:32:43.340]                             name <- restart$name
[10:32:43.340]                             if (is.null(name)) 
[10:32:43.340]                               next
[10:32:43.340]                             if (!grepl(pattern, name)) 
[10:32:43.340]                               next
[10:32:43.340]                             invokeRestart(restart)
[10:32:43.340]                             muffled <- TRUE
[10:32:43.340]                             break
[10:32:43.340]                           }
[10:32:43.340]                         }
[10:32:43.340]                       }
[10:32:43.340]                       invisible(muffled)
[10:32:43.340]                     }
[10:32:43.340]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.340]                   }
[10:32:43.340]                 }
[10:32:43.340]             }
[10:32:43.340]         }))
[10:32:43.340]     }, error = function(ex) {
[10:32:43.340]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.340]                 ...future.rng), started = ...future.startTime, 
[10:32:43.340]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.340]             version = "1.8"), class = "FutureResult")
[10:32:43.340]     }, finally = {
[10:32:43.340]         if (!identical(...future.workdir, getwd())) 
[10:32:43.340]             setwd(...future.workdir)
[10:32:43.340]         {
[10:32:43.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.340]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.340]             }
[10:32:43.340]             base::options(...future.oldOptions)
[10:32:43.340]             if (.Platform$OS.type == "windows") {
[10:32:43.340]                 old_names <- names(...future.oldEnvVars)
[10:32:43.340]                 envs <- base::Sys.getenv()
[10:32:43.340]                 names <- names(envs)
[10:32:43.340]                 common <- intersect(names, old_names)
[10:32:43.340]                 added <- setdiff(names, old_names)
[10:32:43.340]                 removed <- setdiff(old_names, names)
[10:32:43.340]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.340]                   envs[common]]
[10:32:43.340]                 NAMES <- toupper(changed)
[10:32:43.340]                 args <- list()
[10:32:43.340]                 for (kk in seq_along(NAMES)) {
[10:32:43.340]                   name <- changed[[kk]]
[10:32:43.340]                   NAME <- NAMES[[kk]]
[10:32:43.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.340]                     next
[10:32:43.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.340]                 }
[10:32:43.340]                 NAMES <- toupper(added)
[10:32:43.340]                 for (kk in seq_along(NAMES)) {
[10:32:43.340]                   name <- added[[kk]]
[10:32:43.340]                   NAME <- NAMES[[kk]]
[10:32:43.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.340]                     next
[10:32:43.340]                   args[[name]] <- ""
[10:32:43.340]                 }
[10:32:43.340]                 NAMES <- toupper(removed)
[10:32:43.340]                 for (kk in seq_along(NAMES)) {
[10:32:43.340]                   name <- removed[[kk]]
[10:32:43.340]                   NAME <- NAMES[[kk]]
[10:32:43.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.340]                     next
[10:32:43.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.340]                 }
[10:32:43.340]                 if (length(args) > 0) 
[10:32:43.340]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.340]             }
[10:32:43.340]             else {
[10:32:43.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.340]             }
[10:32:43.340]             {
[10:32:43.340]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.340]                   0L) {
[10:32:43.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.340]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.340]                   base::options(opts)
[10:32:43.340]                 }
[10:32:43.340]                 {
[10:32:43.340]                   {
[10:32:43.340]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.340]                     NULL
[10:32:43.340]                   }
[10:32:43.340]                   options(future.plan = NULL)
[10:32:43.340]                   if (is.na(NA_character_)) 
[10:32:43.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.340]                     .init = FALSE)
[10:32:43.340]                 }
[10:32:43.340]             }
[10:32:43.340]         }
[10:32:43.340]     })
[10:32:43.340]     if (TRUE) {
[10:32:43.340]         base::sink(type = "output", split = FALSE)
[10:32:43.340]         if (TRUE) {
[10:32:43.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.340]         }
[10:32:43.340]         else {
[10:32:43.340]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.340]         }
[10:32:43.340]         base::close(...future.stdout)
[10:32:43.340]         ...future.stdout <- NULL
[10:32:43.340]     }
[10:32:43.340]     ...future.result$conditions <- ...future.conditions
[10:32:43.340]     ...future.result$finished <- base::Sys.time()
[10:32:43.340]     ...future.result
[10:32:43.340] }
[10:32:43.343] MultisessionFuture started
[10:32:43.343] - Launch lazy future ... done
[10:32:43.343] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[10:32:43.343] result() for ClusterFuture ...
[10:32:43.344] - result already collected: FutureResult
[10:32:43.344] result() for ClusterFuture ... done
[10:32:43.344] result() for ClusterFuture ...
[10:32:43.344] - result already collected: FutureResult
[10:32:43.344] result() for ClusterFuture ... done
[10:32:43.344] signalConditions() ...
[10:32:43.344]  - include = ‘immediateCondition’
[10:32:43.344]  - exclude = 
[10:32:43.344]  - resignal = FALSE
[10:32:43.344]  - Number of conditions: 1
[10:32:43.344] signalConditions() ... done
[10:32:43.345] Future state: ‘finished’
[10:32:43.345] result() for ClusterFuture ...
[10:32:43.345] - result already collected: FutureResult
[10:32:43.345] result() for ClusterFuture ... done
[10:32:43.345] signalConditions() ...
[10:32:43.345]  - include = ‘condition’
[10:32:43.345]  - exclude = ‘immediateCondition’
[10:32:43.345]  - resignal = TRUE
[10:32:43.345]  - Number of conditions: 1
[10:32:43.345]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:32:43.346] signalConditions() ... done
v3: <simpleError> (as expect)
[10:32:43.346] result() for ClusterFuture ...
[10:32:43.346] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.346] - Validating connection of MultisessionFuture
[10:32:43.346] - received message: FutureResult
[10:32:43.346] - Received FutureResult
[10:32:43.346] - Erased future from FutureRegistry
[10:32:43.346] result() for ClusterFuture ...
[10:32:43.346] - result already collected: FutureResult
[10:32:43.347] result() for ClusterFuture ... done
[10:32:43.347] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.347] result() for ClusterFuture ... done
[10:32:43.347] result() for ClusterFuture ...
[10:32:43.347] - result already collected: FutureResult
[10:32:43.347] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[10:32:43.347] getGlobalsAndPackages() ...
[10:32:43.347] Searching for globals...
[10:32:43.348] 
[10:32:43.348] Searching for globals ... DONE
[10:32:43.348] - globals: [0] <none>
[10:32:43.348] getGlobalsAndPackages() ... DONE
[10:32:43.348] run() for ‘Future’ ...
[10:32:43.348] - state: ‘created’
[10:32:43.349] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.362]   - Field: ‘node’
[10:32:43.363]   - Field: ‘label’
[10:32:43.363]   - Field: ‘local’
[10:32:43.363]   - Field: ‘owner’
[10:32:43.363]   - Field: ‘envir’
[10:32:43.363]   - Field: ‘workers’
[10:32:43.363]   - Field: ‘packages’
[10:32:43.363]   - Field: ‘gc’
[10:32:43.363]   - Field: ‘conditions’
[10:32:43.363]   - Field: ‘persistent’
[10:32:43.363]   - Field: ‘expr’
[10:32:43.364]   - Field: ‘uuid’
[10:32:43.364]   - Field: ‘seed’
[10:32:43.364]   - Field: ‘version’
[10:32:43.364]   - Field: ‘result’
[10:32:43.364]   - Field: ‘asynchronous’
[10:32:43.364]   - Field: ‘calls’
[10:32:43.364]   - Field: ‘globals’
[10:32:43.364]   - Field: ‘stdout’
[10:32:43.364]   - Field: ‘earlySignal’
[10:32:43.364]   - Field: ‘lazy’
[10:32:43.364]   - Field: ‘state’
[10:32:43.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.365] - Launch lazy future ...
[10:32:43.365] Packages needed by the future expression (n = 0): <none>
[10:32:43.365] Packages needed by future strategies (n = 0): <none>
[10:32:43.368] {
[10:32:43.368]     {
[10:32:43.368]         {
[10:32:43.368]             ...future.startTime <- base::Sys.time()
[10:32:43.368]             {
[10:32:43.368]                 {
[10:32:43.368]                   {
[10:32:43.368]                     {
[10:32:43.368]                       base::local({
[10:32:43.368]                         has_future <- base::requireNamespace("future", 
[10:32:43.368]                           quietly = TRUE)
[10:32:43.368]                         if (has_future) {
[10:32:43.368]                           ns <- base::getNamespace("future")
[10:32:43.368]                           version <- ns[[".package"]][["version"]]
[10:32:43.368]                           if (is.null(version)) 
[10:32:43.368]                             version <- utils::packageVersion("future")
[10:32:43.368]                         }
[10:32:43.368]                         else {
[10:32:43.368]                           version <- NULL
[10:32:43.368]                         }
[10:32:43.368]                         if (!has_future || version < "1.8.0") {
[10:32:43.368]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.368]                             "", base::R.version$version.string), 
[10:32:43.368]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.368]                               "release", "version")], collapse = " "), 
[10:32:43.368]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.368]                             info)
[10:32:43.368]                           info <- base::paste(info, collapse = "; ")
[10:32:43.368]                           if (!has_future) {
[10:32:43.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.368]                               info)
[10:32:43.368]                           }
[10:32:43.368]                           else {
[10:32:43.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.368]                               info, version)
[10:32:43.368]                           }
[10:32:43.368]                           base::stop(msg)
[10:32:43.368]                         }
[10:32:43.368]                       })
[10:32:43.368]                     }
[10:32:43.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.368]                     base::options(mc.cores = 1L)
[10:32:43.368]                   }
[10:32:43.368]                   ...future.strategy.old <- future::plan("list")
[10:32:43.368]                   options(future.plan = NULL)
[10:32:43.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.368]                 }
[10:32:43.368]                 ...future.workdir <- getwd()
[10:32:43.368]             }
[10:32:43.368]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.368]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.368]         }
[10:32:43.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.368]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.368]             base::names(...future.oldOptions))
[10:32:43.368]     }
[10:32:43.368]     if (FALSE) {
[10:32:43.368]     }
[10:32:43.368]     else {
[10:32:43.368]         if (TRUE) {
[10:32:43.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.368]                 open = "w")
[10:32:43.368]         }
[10:32:43.368]         else {
[10:32:43.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.368]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.368]         }
[10:32:43.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.368]             base::sink(type = "output", split = FALSE)
[10:32:43.368]             base::close(...future.stdout)
[10:32:43.368]         }, add = TRUE)
[10:32:43.368]     }
[10:32:43.368]     ...future.frame <- base::sys.nframe()
[10:32:43.368]     ...future.conditions <- base::list()
[10:32:43.368]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.368]     if (FALSE) {
[10:32:43.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.368]     }
[10:32:43.368]     ...future.result <- base::tryCatch({
[10:32:43.368]         base::withCallingHandlers({
[10:32:43.368]             ...future.value <- base::withVisible(base::local({
[10:32:43.368]                 ...future.makeSendCondition <- base::local({
[10:32:43.368]                   sendCondition <- NULL
[10:32:43.368]                   function(frame = 1L) {
[10:32:43.368]                     if (is.function(sendCondition)) 
[10:32:43.368]                       return(sendCondition)
[10:32:43.368]                     ns <- getNamespace("parallel")
[10:32:43.368]                     if (exists("sendData", mode = "function", 
[10:32:43.368]                       envir = ns)) {
[10:32:43.368]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.368]                         envir = ns)
[10:32:43.368]                       envir <- sys.frame(frame)
[10:32:43.368]                       master <- NULL
[10:32:43.368]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.368]                         !identical(envir, emptyenv())) {
[10:32:43.368]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.368]                           inherits = FALSE)) {
[10:32:43.368]                           master <- get("master", mode = "list", 
[10:32:43.368]                             envir = envir, inherits = FALSE)
[10:32:43.368]                           if (inherits(master, c("SOCKnode", 
[10:32:43.368]                             "SOCK0node"))) {
[10:32:43.368]                             sendCondition <<- function(cond) {
[10:32:43.368]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.368]                                 success = TRUE)
[10:32:43.368]                               parallel_sendData(master, data)
[10:32:43.368]                             }
[10:32:43.368]                             return(sendCondition)
[10:32:43.368]                           }
[10:32:43.368]                         }
[10:32:43.368]                         frame <- frame + 1L
[10:32:43.368]                         envir <- sys.frame(frame)
[10:32:43.368]                       }
[10:32:43.368]                     }
[10:32:43.368]                     sendCondition <<- function(cond) NULL
[10:32:43.368]                   }
[10:32:43.368]                 })
[10:32:43.368]                 withCallingHandlers({
[10:32:43.368]                   1
[10:32:43.368]                 }, immediateCondition = function(cond) {
[10:32:43.368]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.368]                   sendCondition(cond)
[10:32:43.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.368]                   {
[10:32:43.368]                     inherits <- base::inherits
[10:32:43.368]                     invokeRestart <- base::invokeRestart
[10:32:43.368]                     is.null <- base::is.null
[10:32:43.368]                     muffled <- FALSE
[10:32:43.368]                     if (inherits(cond, "message")) {
[10:32:43.368]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.368]                       if (muffled) 
[10:32:43.368]                         invokeRestart("muffleMessage")
[10:32:43.368]                     }
[10:32:43.368]                     else if (inherits(cond, "warning")) {
[10:32:43.368]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.368]                       if (muffled) 
[10:32:43.368]                         invokeRestart("muffleWarning")
[10:32:43.368]                     }
[10:32:43.368]                     else if (inherits(cond, "condition")) {
[10:32:43.368]                       if (!is.null(pattern)) {
[10:32:43.368]                         computeRestarts <- base::computeRestarts
[10:32:43.368]                         grepl <- base::grepl
[10:32:43.368]                         restarts <- computeRestarts(cond)
[10:32:43.368]                         for (restart in restarts) {
[10:32:43.368]                           name <- restart$name
[10:32:43.368]                           if (is.null(name)) 
[10:32:43.368]                             next
[10:32:43.368]                           if (!grepl(pattern, name)) 
[10:32:43.368]                             next
[10:32:43.368]                           invokeRestart(restart)
[10:32:43.368]                           muffled <- TRUE
[10:32:43.368]                           break
[10:32:43.368]                         }
[10:32:43.368]                       }
[10:32:43.368]                     }
[10:32:43.368]                     invisible(muffled)
[10:32:43.368]                   }
[10:32:43.368]                   muffleCondition(cond)
[10:32:43.368]                 })
[10:32:43.368]             }))
[10:32:43.368]             future::FutureResult(value = ...future.value$value, 
[10:32:43.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.368]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.368]                     ...future.globalenv.names))
[10:32:43.368]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.368]         }, condition = base::local({
[10:32:43.368]             c <- base::c
[10:32:43.368]             inherits <- base::inherits
[10:32:43.368]             invokeRestart <- base::invokeRestart
[10:32:43.368]             length <- base::length
[10:32:43.368]             list <- base::list
[10:32:43.368]             seq.int <- base::seq.int
[10:32:43.368]             signalCondition <- base::signalCondition
[10:32:43.368]             sys.calls <- base::sys.calls
[10:32:43.368]             `[[` <- base::`[[`
[10:32:43.368]             `+` <- base::`+`
[10:32:43.368]             `<<-` <- base::`<<-`
[10:32:43.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.368]                   3L)]
[10:32:43.368]             }
[10:32:43.368]             function(cond) {
[10:32:43.368]                 is_error <- inherits(cond, "error")
[10:32:43.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.368]                   NULL)
[10:32:43.368]                 if (is_error) {
[10:32:43.368]                   sessionInformation <- function() {
[10:32:43.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.368]                       search = base::search(), system = base::Sys.info())
[10:32:43.368]                   }
[10:32:43.368]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.368]                     cond$call), session = sessionInformation(), 
[10:32:43.368]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.368]                   signalCondition(cond)
[10:32:43.368]                 }
[10:32:43.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.368]                 "immediateCondition"))) {
[10:32:43.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.368]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.368]                   if (TRUE && !signal) {
[10:32:43.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.368]                     {
[10:32:43.368]                       inherits <- base::inherits
[10:32:43.368]                       invokeRestart <- base::invokeRestart
[10:32:43.368]                       is.null <- base::is.null
[10:32:43.368]                       muffled <- FALSE
[10:32:43.368]                       if (inherits(cond, "message")) {
[10:32:43.368]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.368]                         if (muffled) 
[10:32:43.368]                           invokeRestart("muffleMessage")
[10:32:43.368]                       }
[10:32:43.368]                       else if (inherits(cond, "warning")) {
[10:32:43.368]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.368]                         if (muffled) 
[10:32:43.368]                           invokeRestart("muffleWarning")
[10:32:43.368]                       }
[10:32:43.368]                       else if (inherits(cond, "condition")) {
[10:32:43.368]                         if (!is.null(pattern)) {
[10:32:43.368]                           computeRestarts <- base::computeRestarts
[10:32:43.368]                           grepl <- base::grepl
[10:32:43.368]                           restarts <- computeRestarts(cond)
[10:32:43.368]                           for (restart in restarts) {
[10:32:43.368]                             name <- restart$name
[10:32:43.368]                             if (is.null(name)) 
[10:32:43.368]                               next
[10:32:43.368]                             if (!grepl(pattern, name)) 
[10:32:43.368]                               next
[10:32:43.368]                             invokeRestart(restart)
[10:32:43.368]                             muffled <- TRUE
[10:32:43.368]                             break
[10:32:43.368]                           }
[10:32:43.368]                         }
[10:32:43.368]                       }
[10:32:43.368]                       invisible(muffled)
[10:32:43.368]                     }
[10:32:43.368]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.368]                   }
[10:32:43.368]                 }
[10:32:43.368]                 else {
[10:32:43.368]                   if (TRUE) {
[10:32:43.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.368]                     {
[10:32:43.368]                       inherits <- base::inherits
[10:32:43.368]                       invokeRestart <- base::invokeRestart
[10:32:43.368]                       is.null <- base::is.null
[10:32:43.368]                       muffled <- FALSE
[10:32:43.368]                       if (inherits(cond, "message")) {
[10:32:43.368]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.368]                         if (muffled) 
[10:32:43.368]                           invokeRestart("muffleMessage")
[10:32:43.368]                       }
[10:32:43.368]                       else if (inherits(cond, "warning")) {
[10:32:43.368]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.368]                         if (muffled) 
[10:32:43.368]                           invokeRestart("muffleWarning")
[10:32:43.368]                       }
[10:32:43.368]                       else if (inherits(cond, "condition")) {
[10:32:43.368]                         if (!is.null(pattern)) {
[10:32:43.368]                           computeRestarts <- base::computeRestarts
[10:32:43.368]                           grepl <- base::grepl
[10:32:43.368]                           restarts <- computeRestarts(cond)
[10:32:43.368]                           for (restart in restarts) {
[10:32:43.368]                             name <- restart$name
[10:32:43.368]                             if (is.null(name)) 
[10:32:43.368]                               next
[10:32:43.368]                             if (!grepl(pattern, name)) 
[10:32:43.368]                               next
[10:32:43.368]                             invokeRestart(restart)
[10:32:43.368]                             muffled <- TRUE
[10:32:43.368]                             break
[10:32:43.368]                           }
[10:32:43.368]                         }
[10:32:43.368]                       }
[10:32:43.368]                       invisible(muffled)
[10:32:43.368]                     }
[10:32:43.368]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.368]                   }
[10:32:43.368]                 }
[10:32:43.368]             }
[10:32:43.368]         }))
[10:32:43.368]     }, error = function(ex) {
[10:32:43.368]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.368]                 ...future.rng), started = ...future.startTime, 
[10:32:43.368]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.368]             version = "1.8"), class = "FutureResult")
[10:32:43.368]     }, finally = {
[10:32:43.368]         if (!identical(...future.workdir, getwd())) 
[10:32:43.368]             setwd(...future.workdir)
[10:32:43.368]         {
[10:32:43.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.368]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.368]             }
[10:32:43.368]             base::options(...future.oldOptions)
[10:32:43.368]             if (.Platform$OS.type == "windows") {
[10:32:43.368]                 old_names <- names(...future.oldEnvVars)
[10:32:43.368]                 envs <- base::Sys.getenv()
[10:32:43.368]                 names <- names(envs)
[10:32:43.368]                 common <- intersect(names, old_names)
[10:32:43.368]                 added <- setdiff(names, old_names)
[10:32:43.368]                 removed <- setdiff(old_names, names)
[10:32:43.368]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.368]                   envs[common]]
[10:32:43.368]                 NAMES <- toupper(changed)
[10:32:43.368]                 args <- list()
[10:32:43.368]                 for (kk in seq_along(NAMES)) {
[10:32:43.368]                   name <- changed[[kk]]
[10:32:43.368]                   NAME <- NAMES[[kk]]
[10:32:43.368]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.368]                     next
[10:32:43.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.368]                 }
[10:32:43.368]                 NAMES <- toupper(added)
[10:32:43.368]                 for (kk in seq_along(NAMES)) {
[10:32:43.368]                   name <- added[[kk]]
[10:32:43.368]                   NAME <- NAMES[[kk]]
[10:32:43.368]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.368]                     next
[10:32:43.368]                   args[[name]] <- ""
[10:32:43.368]                 }
[10:32:43.368]                 NAMES <- toupper(removed)
[10:32:43.368]                 for (kk in seq_along(NAMES)) {
[10:32:43.368]                   name <- removed[[kk]]
[10:32:43.368]                   NAME <- NAMES[[kk]]
[10:32:43.368]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.368]                     next
[10:32:43.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.368]                 }
[10:32:43.368]                 if (length(args) > 0) 
[10:32:43.368]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.368]             }
[10:32:43.368]             else {
[10:32:43.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.368]             }
[10:32:43.368]             {
[10:32:43.368]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.368]                   0L) {
[10:32:43.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.368]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.368]                   base::options(opts)
[10:32:43.368]                 }
[10:32:43.368]                 {
[10:32:43.368]                   {
[10:32:43.368]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.368]                     NULL
[10:32:43.368]                   }
[10:32:43.368]                   options(future.plan = NULL)
[10:32:43.368]                   if (is.na(NA_character_)) 
[10:32:43.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.368]                     .init = FALSE)
[10:32:43.368]                 }
[10:32:43.368]             }
[10:32:43.368]         }
[10:32:43.368]     })
[10:32:43.368]     if (TRUE) {
[10:32:43.368]         base::sink(type = "output", split = FALSE)
[10:32:43.368]         if (TRUE) {
[10:32:43.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.368]         }
[10:32:43.368]         else {
[10:32:43.368]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.368]         }
[10:32:43.368]         base::close(...future.stdout)
[10:32:43.368]         ...future.stdout <- NULL
[10:32:43.368]     }
[10:32:43.368]     ...future.result$conditions <- ...future.conditions
[10:32:43.368]     ...future.result$finished <- base::Sys.time()
[10:32:43.368]     ...future.result
[10:32:43.368] }
[10:32:43.371] MultisessionFuture started
[10:32:43.371] - Launch lazy future ... done
[10:32:43.371] run() for ‘MultisessionFuture’ ... done
[10:32:43.371] result() for ClusterFuture ...
[10:32:43.371] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.372] - Validating connection of MultisessionFuture
[10:32:43.373] - received message: FutureResult
[10:32:43.373] - Received FutureResult
[10:32:43.373] - Erased future from FutureRegistry
[10:32:43.373] result() for ClusterFuture ...
[10:32:43.373] - result already collected: FutureResult
[10:32:43.373] result() for ClusterFuture ... done
[10:32:43.373] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.373] result() for ClusterFuture ... done
[10:32:43.374] result() for ClusterFuture ...
[10:32:43.374] - result already collected: FutureResult
[10:32:43.374] result() for ClusterFuture ... done
c = 1
[10:32:43.374] getGlobalsAndPackages() ...
[10:32:43.374] Searching for globals...
[10:32:43.374] 
[10:32:43.375] Searching for globals ... DONE
[10:32:43.375] - globals: [0] <none>
[10:32:43.375] getGlobalsAndPackages() ... DONE
[10:32:43.375] run() for ‘Future’ ...
[10:32:43.375] - state: ‘created’
[10:32:43.375] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.389]   - Field: ‘node’
[10:32:43.389]   - Field: ‘label’
[10:32:43.389]   - Field: ‘local’
[10:32:43.390]   - Field: ‘owner’
[10:32:43.390]   - Field: ‘envir’
[10:32:43.390]   - Field: ‘workers’
[10:32:43.390]   - Field: ‘packages’
[10:32:43.390]   - Field: ‘gc’
[10:32:43.390]   - Field: ‘conditions’
[10:32:43.390]   - Field: ‘persistent’
[10:32:43.390]   - Field: ‘expr’
[10:32:43.390]   - Field: ‘uuid’
[10:32:43.390]   - Field: ‘seed’
[10:32:43.390]   - Field: ‘version’
[10:32:43.391]   - Field: ‘result’
[10:32:43.391]   - Field: ‘asynchronous’
[10:32:43.391]   - Field: ‘calls’
[10:32:43.391]   - Field: ‘globals’
[10:32:43.391]   - Field: ‘stdout’
[10:32:43.391]   - Field: ‘earlySignal’
[10:32:43.391]   - Field: ‘lazy’
[10:32:43.391]   - Field: ‘state’
[10:32:43.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.391] - Launch lazy future ...
[10:32:43.392] Packages needed by the future expression (n = 0): <none>
[10:32:43.392] Packages needed by future strategies (n = 0): <none>
[10:32:43.392] {
[10:32:43.392]     {
[10:32:43.392]         {
[10:32:43.392]             ...future.startTime <- base::Sys.time()
[10:32:43.392]             {
[10:32:43.392]                 {
[10:32:43.392]                   {
[10:32:43.392]                     {
[10:32:43.392]                       base::local({
[10:32:43.392]                         has_future <- base::requireNamespace("future", 
[10:32:43.392]                           quietly = TRUE)
[10:32:43.392]                         if (has_future) {
[10:32:43.392]                           ns <- base::getNamespace("future")
[10:32:43.392]                           version <- ns[[".package"]][["version"]]
[10:32:43.392]                           if (is.null(version)) 
[10:32:43.392]                             version <- utils::packageVersion("future")
[10:32:43.392]                         }
[10:32:43.392]                         else {
[10:32:43.392]                           version <- NULL
[10:32:43.392]                         }
[10:32:43.392]                         if (!has_future || version < "1.8.0") {
[10:32:43.392]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.392]                             "", base::R.version$version.string), 
[10:32:43.392]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.392]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.392]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.392]                               "release", "version")], collapse = " "), 
[10:32:43.392]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.392]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.392]                             info)
[10:32:43.392]                           info <- base::paste(info, collapse = "; ")
[10:32:43.392]                           if (!has_future) {
[10:32:43.392]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.392]                               info)
[10:32:43.392]                           }
[10:32:43.392]                           else {
[10:32:43.392]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.392]                               info, version)
[10:32:43.392]                           }
[10:32:43.392]                           base::stop(msg)
[10:32:43.392]                         }
[10:32:43.392]                       })
[10:32:43.392]                     }
[10:32:43.392]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.392]                     base::options(mc.cores = 1L)
[10:32:43.392]                   }
[10:32:43.392]                   ...future.strategy.old <- future::plan("list")
[10:32:43.392]                   options(future.plan = NULL)
[10:32:43.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.392]                 }
[10:32:43.392]                 ...future.workdir <- getwd()
[10:32:43.392]             }
[10:32:43.392]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.392]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.392]         }
[10:32:43.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.392]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.392]             base::names(...future.oldOptions))
[10:32:43.392]     }
[10:32:43.392]     if (FALSE) {
[10:32:43.392]     }
[10:32:43.392]     else {
[10:32:43.392]         if (TRUE) {
[10:32:43.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.392]                 open = "w")
[10:32:43.392]         }
[10:32:43.392]         else {
[10:32:43.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.392]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.392]         }
[10:32:43.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.392]             base::sink(type = "output", split = FALSE)
[10:32:43.392]             base::close(...future.stdout)
[10:32:43.392]         }, add = TRUE)
[10:32:43.392]     }
[10:32:43.392]     ...future.frame <- base::sys.nframe()
[10:32:43.392]     ...future.conditions <- base::list()
[10:32:43.392]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.392]     if (FALSE) {
[10:32:43.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.392]     }
[10:32:43.392]     ...future.result <- base::tryCatch({
[10:32:43.392]         base::withCallingHandlers({
[10:32:43.392]             ...future.value <- base::withVisible(base::local({
[10:32:43.392]                 ...future.makeSendCondition <- base::local({
[10:32:43.392]                   sendCondition <- NULL
[10:32:43.392]                   function(frame = 1L) {
[10:32:43.392]                     if (is.function(sendCondition)) 
[10:32:43.392]                       return(sendCondition)
[10:32:43.392]                     ns <- getNamespace("parallel")
[10:32:43.392]                     if (exists("sendData", mode = "function", 
[10:32:43.392]                       envir = ns)) {
[10:32:43.392]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.392]                         envir = ns)
[10:32:43.392]                       envir <- sys.frame(frame)
[10:32:43.392]                       master <- NULL
[10:32:43.392]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.392]                         !identical(envir, emptyenv())) {
[10:32:43.392]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.392]                           inherits = FALSE)) {
[10:32:43.392]                           master <- get("master", mode = "list", 
[10:32:43.392]                             envir = envir, inherits = FALSE)
[10:32:43.392]                           if (inherits(master, c("SOCKnode", 
[10:32:43.392]                             "SOCK0node"))) {
[10:32:43.392]                             sendCondition <<- function(cond) {
[10:32:43.392]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.392]                                 success = TRUE)
[10:32:43.392]                               parallel_sendData(master, data)
[10:32:43.392]                             }
[10:32:43.392]                             return(sendCondition)
[10:32:43.392]                           }
[10:32:43.392]                         }
[10:32:43.392]                         frame <- frame + 1L
[10:32:43.392]                         envir <- sys.frame(frame)
[10:32:43.392]                       }
[10:32:43.392]                     }
[10:32:43.392]                     sendCondition <<- function(cond) NULL
[10:32:43.392]                   }
[10:32:43.392]                 })
[10:32:43.392]                 withCallingHandlers({
[10:32:43.392]                   1
[10:32:43.392]                 }, immediateCondition = function(cond) {
[10:32:43.392]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.392]                   sendCondition(cond)
[10:32:43.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.392]                   {
[10:32:43.392]                     inherits <- base::inherits
[10:32:43.392]                     invokeRestart <- base::invokeRestart
[10:32:43.392]                     is.null <- base::is.null
[10:32:43.392]                     muffled <- FALSE
[10:32:43.392]                     if (inherits(cond, "message")) {
[10:32:43.392]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.392]                       if (muffled) 
[10:32:43.392]                         invokeRestart("muffleMessage")
[10:32:43.392]                     }
[10:32:43.392]                     else if (inherits(cond, "warning")) {
[10:32:43.392]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.392]                       if (muffled) 
[10:32:43.392]                         invokeRestart("muffleWarning")
[10:32:43.392]                     }
[10:32:43.392]                     else if (inherits(cond, "condition")) {
[10:32:43.392]                       if (!is.null(pattern)) {
[10:32:43.392]                         computeRestarts <- base::computeRestarts
[10:32:43.392]                         grepl <- base::grepl
[10:32:43.392]                         restarts <- computeRestarts(cond)
[10:32:43.392]                         for (restart in restarts) {
[10:32:43.392]                           name <- restart$name
[10:32:43.392]                           if (is.null(name)) 
[10:32:43.392]                             next
[10:32:43.392]                           if (!grepl(pattern, name)) 
[10:32:43.392]                             next
[10:32:43.392]                           invokeRestart(restart)
[10:32:43.392]                           muffled <- TRUE
[10:32:43.392]                           break
[10:32:43.392]                         }
[10:32:43.392]                       }
[10:32:43.392]                     }
[10:32:43.392]                     invisible(muffled)
[10:32:43.392]                   }
[10:32:43.392]                   muffleCondition(cond)
[10:32:43.392]                 })
[10:32:43.392]             }))
[10:32:43.392]             future::FutureResult(value = ...future.value$value, 
[10:32:43.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.392]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.392]                     ...future.globalenv.names))
[10:32:43.392]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.392]         }, condition = base::local({
[10:32:43.392]             c <- base::c
[10:32:43.392]             inherits <- base::inherits
[10:32:43.392]             invokeRestart <- base::invokeRestart
[10:32:43.392]             length <- base::length
[10:32:43.392]             list <- base::list
[10:32:43.392]             seq.int <- base::seq.int
[10:32:43.392]             signalCondition <- base::signalCondition
[10:32:43.392]             sys.calls <- base::sys.calls
[10:32:43.392]             `[[` <- base::`[[`
[10:32:43.392]             `+` <- base::`+`
[10:32:43.392]             `<<-` <- base::`<<-`
[10:32:43.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.392]                   3L)]
[10:32:43.392]             }
[10:32:43.392]             function(cond) {
[10:32:43.392]                 is_error <- inherits(cond, "error")
[10:32:43.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.392]                   NULL)
[10:32:43.392]                 if (is_error) {
[10:32:43.392]                   sessionInformation <- function() {
[10:32:43.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.392]                       search = base::search(), system = base::Sys.info())
[10:32:43.392]                   }
[10:32:43.392]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.392]                     cond$call), session = sessionInformation(), 
[10:32:43.392]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.392]                   signalCondition(cond)
[10:32:43.392]                 }
[10:32:43.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.392]                 "immediateCondition"))) {
[10:32:43.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.392]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.392]                   if (TRUE && !signal) {
[10:32:43.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.392]                     {
[10:32:43.392]                       inherits <- base::inherits
[10:32:43.392]                       invokeRestart <- base::invokeRestart
[10:32:43.392]                       is.null <- base::is.null
[10:32:43.392]                       muffled <- FALSE
[10:32:43.392]                       if (inherits(cond, "message")) {
[10:32:43.392]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.392]                         if (muffled) 
[10:32:43.392]                           invokeRestart("muffleMessage")
[10:32:43.392]                       }
[10:32:43.392]                       else if (inherits(cond, "warning")) {
[10:32:43.392]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.392]                         if (muffled) 
[10:32:43.392]                           invokeRestart("muffleWarning")
[10:32:43.392]                       }
[10:32:43.392]                       else if (inherits(cond, "condition")) {
[10:32:43.392]                         if (!is.null(pattern)) {
[10:32:43.392]                           computeRestarts <- base::computeRestarts
[10:32:43.392]                           grepl <- base::grepl
[10:32:43.392]                           restarts <- computeRestarts(cond)
[10:32:43.392]                           for (restart in restarts) {
[10:32:43.392]                             name <- restart$name
[10:32:43.392]                             if (is.null(name)) 
[10:32:43.392]                               next
[10:32:43.392]                             if (!grepl(pattern, name)) 
[10:32:43.392]                               next
[10:32:43.392]                             invokeRestart(restart)
[10:32:43.392]                             muffled <- TRUE
[10:32:43.392]                             break
[10:32:43.392]                           }
[10:32:43.392]                         }
[10:32:43.392]                       }
[10:32:43.392]                       invisible(muffled)
[10:32:43.392]                     }
[10:32:43.392]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.392]                   }
[10:32:43.392]                 }
[10:32:43.392]                 else {
[10:32:43.392]                   if (TRUE) {
[10:32:43.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.392]                     {
[10:32:43.392]                       inherits <- base::inherits
[10:32:43.392]                       invokeRestart <- base::invokeRestart
[10:32:43.392]                       is.null <- base::is.null
[10:32:43.392]                       muffled <- FALSE
[10:32:43.392]                       if (inherits(cond, "message")) {
[10:32:43.392]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.392]                         if (muffled) 
[10:32:43.392]                           invokeRestart("muffleMessage")
[10:32:43.392]                       }
[10:32:43.392]                       else if (inherits(cond, "warning")) {
[10:32:43.392]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.392]                         if (muffled) 
[10:32:43.392]                           invokeRestart("muffleWarning")
[10:32:43.392]                       }
[10:32:43.392]                       else if (inherits(cond, "condition")) {
[10:32:43.392]                         if (!is.null(pattern)) {
[10:32:43.392]                           computeRestarts <- base::computeRestarts
[10:32:43.392]                           grepl <- base::grepl
[10:32:43.392]                           restarts <- computeRestarts(cond)
[10:32:43.392]                           for (restart in restarts) {
[10:32:43.392]                             name <- restart$name
[10:32:43.392]                             if (is.null(name)) 
[10:32:43.392]                               next
[10:32:43.392]                             if (!grepl(pattern, name)) 
[10:32:43.392]                               next
[10:32:43.392]                             invokeRestart(restart)
[10:32:43.392]                             muffled <- TRUE
[10:32:43.392]                             break
[10:32:43.392]                           }
[10:32:43.392]                         }
[10:32:43.392]                       }
[10:32:43.392]                       invisible(muffled)
[10:32:43.392]                     }
[10:32:43.392]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.392]                   }
[10:32:43.392]                 }
[10:32:43.392]             }
[10:32:43.392]         }))
[10:32:43.392]     }, error = function(ex) {
[10:32:43.392]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.392]                 ...future.rng), started = ...future.startTime, 
[10:32:43.392]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.392]             version = "1.8"), class = "FutureResult")
[10:32:43.392]     }, finally = {
[10:32:43.392]         if (!identical(...future.workdir, getwd())) 
[10:32:43.392]             setwd(...future.workdir)
[10:32:43.392]         {
[10:32:43.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.392]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.392]             }
[10:32:43.392]             base::options(...future.oldOptions)
[10:32:43.392]             if (.Platform$OS.type == "windows") {
[10:32:43.392]                 old_names <- names(...future.oldEnvVars)
[10:32:43.392]                 envs <- base::Sys.getenv()
[10:32:43.392]                 names <- names(envs)
[10:32:43.392]                 common <- intersect(names, old_names)
[10:32:43.392]                 added <- setdiff(names, old_names)
[10:32:43.392]                 removed <- setdiff(old_names, names)
[10:32:43.392]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.392]                   envs[common]]
[10:32:43.392]                 NAMES <- toupper(changed)
[10:32:43.392]                 args <- list()
[10:32:43.392]                 for (kk in seq_along(NAMES)) {
[10:32:43.392]                   name <- changed[[kk]]
[10:32:43.392]                   NAME <- NAMES[[kk]]
[10:32:43.392]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.392]                     next
[10:32:43.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.392]                 }
[10:32:43.392]                 NAMES <- toupper(added)
[10:32:43.392]                 for (kk in seq_along(NAMES)) {
[10:32:43.392]                   name <- added[[kk]]
[10:32:43.392]                   NAME <- NAMES[[kk]]
[10:32:43.392]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.392]                     next
[10:32:43.392]                   args[[name]] <- ""
[10:32:43.392]                 }
[10:32:43.392]                 NAMES <- toupper(removed)
[10:32:43.392]                 for (kk in seq_along(NAMES)) {
[10:32:43.392]                   name <- removed[[kk]]
[10:32:43.392]                   NAME <- NAMES[[kk]]
[10:32:43.392]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.392]                     next
[10:32:43.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.392]                 }
[10:32:43.392]                 if (length(args) > 0) 
[10:32:43.392]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.392]             }
[10:32:43.392]             else {
[10:32:43.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.392]             }
[10:32:43.392]             {
[10:32:43.392]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.392]                   0L) {
[10:32:43.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.392]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.392]                   base::options(opts)
[10:32:43.392]                 }
[10:32:43.392]                 {
[10:32:43.392]                   {
[10:32:43.392]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.392]                     NULL
[10:32:43.392]                   }
[10:32:43.392]                   options(future.plan = NULL)
[10:32:43.392]                   if (is.na(NA_character_)) 
[10:32:43.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.392]                     .init = FALSE)
[10:32:43.392]                 }
[10:32:43.392]             }
[10:32:43.392]         }
[10:32:43.392]     })
[10:32:43.392]     if (TRUE) {
[10:32:43.392]         base::sink(type = "output", split = FALSE)
[10:32:43.392]         if (TRUE) {
[10:32:43.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.392]         }
[10:32:43.392]         else {
[10:32:43.392]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.392]         }
[10:32:43.392]         base::close(...future.stdout)
[10:32:43.392]         ...future.stdout <- NULL
[10:32:43.392]     }
[10:32:43.392]     ...future.result$conditions <- ...future.conditions
[10:32:43.392]     ...future.result$finished <- base::Sys.time()
[10:32:43.392]     ...future.result
[10:32:43.392] }
[10:32:43.395] MultisessionFuture started
[10:32:43.395] - Launch lazy future ... done
[10:32:43.395] run() for ‘MultisessionFuture’ ... done
[10:32:43.395] result() for ClusterFuture ...
[10:32:43.395] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.395] - Validating connection of MultisessionFuture
[10:32:43.396] - received message: FutureResult
[10:32:43.397] - Received FutureResult
[10:32:43.397] - Erased future from FutureRegistry
[10:32:43.397] result() for ClusterFuture ...
[10:32:43.397] - result already collected: FutureResult
[10:32:43.397] result() for ClusterFuture ... done
[10:32:43.397] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.397] result() for ClusterFuture ... done
[10:32:43.397] result() for ClusterFuture ...
[10:32:43.397] - result already collected: FutureResult
[10:32:43.397] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[10:32:43.398] getGlobalsAndPackages() ...
[10:32:43.398] Searching for globals...
[10:32:43.401] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[10:32:43.401] Searching for globals ... DONE
[10:32:43.402] Resolving globals: FALSE
[10:32:43.402] 
[10:32:43.402] - packages: [1] ‘future’
[10:32:43.402] getGlobalsAndPackages() ... DONE
[10:32:43.402] run() for ‘Future’ ...
[10:32:43.403] - state: ‘created’
[10:32:43.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.417] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.417] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.417]   - Field: ‘node’
[10:32:43.418]   - Field: ‘label’
[10:32:43.418]   - Field: ‘local’
[10:32:43.418]   - Field: ‘owner’
[10:32:43.418]   - Field: ‘envir’
[10:32:43.418]   - Field: ‘workers’
[10:32:43.418]   - Field: ‘packages’
[10:32:43.418]   - Field: ‘gc’
[10:32:43.418]   - Field: ‘conditions’
[10:32:43.418]   - Field: ‘persistent’
[10:32:43.418]   - Field: ‘expr’
[10:32:43.418]   - Field: ‘uuid’
[10:32:43.419]   - Field: ‘seed’
[10:32:43.419]   - Field: ‘version’
[10:32:43.419]   - Field: ‘result’
[10:32:43.419]   - Field: ‘asynchronous’
[10:32:43.419]   - Field: ‘calls’
[10:32:43.419]   - Field: ‘globals’
[10:32:43.419]   - Field: ‘stdout’
[10:32:43.419]   - Field: ‘earlySignal’
[10:32:43.419]   - Field: ‘lazy’
[10:32:43.419]   - Field: ‘state’
[10:32:43.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.420] - Launch lazy future ...
[10:32:43.420] Packages needed by the future expression (n = 1): ‘future’
[10:32:43.420] Packages needed by future strategies (n = 0): <none>
[10:32:43.420] {
[10:32:43.420]     {
[10:32:43.420]         {
[10:32:43.420]             ...future.startTime <- base::Sys.time()
[10:32:43.420]             {
[10:32:43.420]                 {
[10:32:43.420]                   {
[10:32:43.420]                     {
[10:32:43.420]                       {
[10:32:43.420]                         base::local({
[10:32:43.420]                           has_future <- base::requireNamespace("future", 
[10:32:43.420]                             quietly = TRUE)
[10:32:43.420]                           if (has_future) {
[10:32:43.420]                             ns <- base::getNamespace("future")
[10:32:43.420]                             version <- ns[[".package"]][["version"]]
[10:32:43.420]                             if (is.null(version)) 
[10:32:43.420]                               version <- utils::packageVersion("future")
[10:32:43.420]                           }
[10:32:43.420]                           else {
[10:32:43.420]                             version <- NULL
[10:32:43.420]                           }
[10:32:43.420]                           if (!has_future || version < "1.8.0") {
[10:32:43.420]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.420]                               "", base::R.version$version.string), 
[10:32:43.420]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:43.420]                                 base::R.version$platform, 8 * 
[10:32:43.420]                                   base::.Machine$sizeof.pointer), 
[10:32:43.420]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.420]                                 "release", "version")], collapse = " "), 
[10:32:43.420]                               hostname = base::Sys.info()[["nodename"]])
[10:32:43.420]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.420]                               info)
[10:32:43.420]                             info <- base::paste(info, collapse = "; ")
[10:32:43.420]                             if (!has_future) {
[10:32:43.420]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.420]                                 info)
[10:32:43.420]                             }
[10:32:43.420]                             else {
[10:32:43.420]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.420]                                 info, version)
[10:32:43.420]                             }
[10:32:43.420]                             base::stop(msg)
[10:32:43.420]                           }
[10:32:43.420]                         })
[10:32:43.420]                       }
[10:32:43.420]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.420]                       base::options(mc.cores = 1L)
[10:32:43.420]                     }
[10:32:43.420]                     base::local({
[10:32:43.420]                       for (pkg in "future") {
[10:32:43.420]                         base::loadNamespace(pkg)
[10:32:43.420]                         base::library(pkg, character.only = TRUE)
[10:32:43.420]                       }
[10:32:43.420]                     })
[10:32:43.420]                   }
[10:32:43.420]                   ...future.strategy.old <- future::plan("list")
[10:32:43.420]                   options(future.plan = NULL)
[10:32:43.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.420]                 }
[10:32:43.420]                 ...future.workdir <- getwd()
[10:32:43.420]             }
[10:32:43.420]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.420]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.420]         }
[10:32:43.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.420]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.420]             base::names(...future.oldOptions))
[10:32:43.420]     }
[10:32:43.420]     if (FALSE) {
[10:32:43.420]     }
[10:32:43.420]     else {
[10:32:43.420]         if (TRUE) {
[10:32:43.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.420]                 open = "w")
[10:32:43.420]         }
[10:32:43.420]         else {
[10:32:43.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.420]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.420]         }
[10:32:43.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.420]             base::sink(type = "output", split = FALSE)
[10:32:43.420]             base::close(...future.stdout)
[10:32:43.420]         }, add = TRUE)
[10:32:43.420]     }
[10:32:43.420]     ...future.frame <- base::sys.nframe()
[10:32:43.420]     ...future.conditions <- base::list()
[10:32:43.420]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.420]     if (FALSE) {
[10:32:43.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.420]     }
[10:32:43.420]     ...future.result <- base::tryCatch({
[10:32:43.420]         base::withCallingHandlers({
[10:32:43.420]             ...future.value <- base::withVisible(base::local({
[10:32:43.420]                 ...future.makeSendCondition <- base::local({
[10:32:43.420]                   sendCondition <- NULL
[10:32:43.420]                   function(frame = 1L) {
[10:32:43.420]                     if (is.function(sendCondition)) 
[10:32:43.420]                       return(sendCondition)
[10:32:43.420]                     ns <- getNamespace("parallel")
[10:32:43.420]                     if (exists("sendData", mode = "function", 
[10:32:43.420]                       envir = ns)) {
[10:32:43.420]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.420]                         envir = ns)
[10:32:43.420]                       envir <- sys.frame(frame)
[10:32:43.420]                       master <- NULL
[10:32:43.420]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.420]                         !identical(envir, emptyenv())) {
[10:32:43.420]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.420]                           inherits = FALSE)) {
[10:32:43.420]                           master <- get("master", mode = "list", 
[10:32:43.420]                             envir = envir, inherits = FALSE)
[10:32:43.420]                           if (inherits(master, c("SOCKnode", 
[10:32:43.420]                             "SOCK0node"))) {
[10:32:43.420]                             sendCondition <<- function(cond) {
[10:32:43.420]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.420]                                 success = TRUE)
[10:32:43.420]                               parallel_sendData(master, data)
[10:32:43.420]                             }
[10:32:43.420]                             return(sendCondition)
[10:32:43.420]                           }
[10:32:43.420]                         }
[10:32:43.420]                         frame <- frame + 1L
[10:32:43.420]                         envir <- sys.frame(frame)
[10:32:43.420]                       }
[10:32:43.420]                     }
[10:32:43.420]                     sendCondition <<- function(cond) NULL
[10:32:43.420]                   }
[10:32:43.420]                 })
[10:32:43.420]                 withCallingHandlers({
[10:32:43.420]                   {
[10:32:43.420]                     b <- 1
[10:32:43.420]                     c %<-% 2
[10:32:43.420]                     d <- 3
[10:32:43.420]                     4 %->% e
[10:32:43.420]                     b + c + d + e
[10:32:43.420]                   }
[10:32:43.420]                 }, immediateCondition = function(cond) {
[10:32:43.420]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.420]                   sendCondition(cond)
[10:32:43.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.420]                   {
[10:32:43.420]                     inherits <- base::inherits
[10:32:43.420]                     invokeRestart <- base::invokeRestart
[10:32:43.420]                     is.null <- base::is.null
[10:32:43.420]                     muffled <- FALSE
[10:32:43.420]                     if (inherits(cond, "message")) {
[10:32:43.420]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.420]                       if (muffled) 
[10:32:43.420]                         invokeRestart("muffleMessage")
[10:32:43.420]                     }
[10:32:43.420]                     else if (inherits(cond, "warning")) {
[10:32:43.420]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.420]                       if (muffled) 
[10:32:43.420]                         invokeRestart("muffleWarning")
[10:32:43.420]                     }
[10:32:43.420]                     else if (inherits(cond, "condition")) {
[10:32:43.420]                       if (!is.null(pattern)) {
[10:32:43.420]                         computeRestarts <- base::computeRestarts
[10:32:43.420]                         grepl <- base::grepl
[10:32:43.420]                         restarts <- computeRestarts(cond)
[10:32:43.420]                         for (restart in restarts) {
[10:32:43.420]                           name <- restart$name
[10:32:43.420]                           if (is.null(name)) 
[10:32:43.420]                             next
[10:32:43.420]                           if (!grepl(pattern, name)) 
[10:32:43.420]                             next
[10:32:43.420]                           invokeRestart(restart)
[10:32:43.420]                           muffled <- TRUE
[10:32:43.420]                           break
[10:32:43.420]                         }
[10:32:43.420]                       }
[10:32:43.420]                     }
[10:32:43.420]                     invisible(muffled)
[10:32:43.420]                   }
[10:32:43.420]                   muffleCondition(cond)
[10:32:43.420]                 })
[10:32:43.420]             }))
[10:32:43.420]             future::FutureResult(value = ...future.value$value, 
[10:32:43.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.420]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.420]                     ...future.globalenv.names))
[10:32:43.420]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.420]         }, condition = base::local({
[10:32:43.420]             c <- base::c
[10:32:43.420]             inherits <- base::inherits
[10:32:43.420]             invokeRestart <- base::invokeRestart
[10:32:43.420]             length <- base::length
[10:32:43.420]             list <- base::list
[10:32:43.420]             seq.int <- base::seq.int
[10:32:43.420]             signalCondition <- base::signalCondition
[10:32:43.420]             sys.calls <- base::sys.calls
[10:32:43.420]             `[[` <- base::`[[`
[10:32:43.420]             `+` <- base::`+`
[10:32:43.420]             `<<-` <- base::`<<-`
[10:32:43.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.420]                   3L)]
[10:32:43.420]             }
[10:32:43.420]             function(cond) {
[10:32:43.420]                 is_error <- inherits(cond, "error")
[10:32:43.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.420]                   NULL)
[10:32:43.420]                 if (is_error) {
[10:32:43.420]                   sessionInformation <- function() {
[10:32:43.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.420]                       search = base::search(), system = base::Sys.info())
[10:32:43.420]                   }
[10:32:43.420]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.420]                     cond$call), session = sessionInformation(), 
[10:32:43.420]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.420]                   signalCondition(cond)
[10:32:43.420]                 }
[10:32:43.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.420]                 "immediateCondition"))) {
[10:32:43.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.420]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.420]                   if (TRUE && !signal) {
[10:32:43.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.420]                     {
[10:32:43.420]                       inherits <- base::inherits
[10:32:43.420]                       invokeRestart <- base::invokeRestart
[10:32:43.420]                       is.null <- base::is.null
[10:32:43.420]                       muffled <- FALSE
[10:32:43.420]                       if (inherits(cond, "message")) {
[10:32:43.420]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.420]                         if (muffled) 
[10:32:43.420]                           invokeRestart("muffleMessage")
[10:32:43.420]                       }
[10:32:43.420]                       else if (inherits(cond, "warning")) {
[10:32:43.420]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.420]                         if (muffled) 
[10:32:43.420]                           invokeRestart("muffleWarning")
[10:32:43.420]                       }
[10:32:43.420]                       else if (inherits(cond, "condition")) {
[10:32:43.420]                         if (!is.null(pattern)) {
[10:32:43.420]                           computeRestarts <- base::computeRestarts
[10:32:43.420]                           grepl <- base::grepl
[10:32:43.420]                           restarts <- computeRestarts(cond)
[10:32:43.420]                           for (restart in restarts) {
[10:32:43.420]                             name <- restart$name
[10:32:43.420]                             if (is.null(name)) 
[10:32:43.420]                               next
[10:32:43.420]                             if (!grepl(pattern, name)) 
[10:32:43.420]                               next
[10:32:43.420]                             invokeRestart(restart)
[10:32:43.420]                             muffled <- TRUE
[10:32:43.420]                             break
[10:32:43.420]                           }
[10:32:43.420]                         }
[10:32:43.420]                       }
[10:32:43.420]                       invisible(muffled)
[10:32:43.420]                     }
[10:32:43.420]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.420]                   }
[10:32:43.420]                 }
[10:32:43.420]                 else {
[10:32:43.420]                   if (TRUE) {
[10:32:43.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.420]                     {
[10:32:43.420]                       inherits <- base::inherits
[10:32:43.420]                       invokeRestart <- base::invokeRestart
[10:32:43.420]                       is.null <- base::is.null
[10:32:43.420]                       muffled <- FALSE
[10:32:43.420]                       if (inherits(cond, "message")) {
[10:32:43.420]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.420]                         if (muffled) 
[10:32:43.420]                           invokeRestart("muffleMessage")
[10:32:43.420]                       }
[10:32:43.420]                       else if (inherits(cond, "warning")) {
[10:32:43.420]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.420]                         if (muffled) 
[10:32:43.420]                           invokeRestart("muffleWarning")
[10:32:43.420]                       }
[10:32:43.420]                       else if (inherits(cond, "condition")) {
[10:32:43.420]                         if (!is.null(pattern)) {
[10:32:43.420]                           computeRestarts <- base::computeRestarts
[10:32:43.420]                           grepl <- base::grepl
[10:32:43.420]                           restarts <- computeRestarts(cond)
[10:32:43.420]                           for (restart in restarts) {
[10:32:43.420]                             name <- restart$name
[10:32:43.420]                             if (is.null(name)) 
[10:32:43.420]                               next
[10:32:43.420]                             if (!grepl(pattern, name)) 
[10:32:43.420]                               next
[10:32:43.420]                             invokeRestart(restart)
[10:32:43.420]                             muffled <- TRUE
[10:32:43.420]                             break
[10:32:43.420]                           }
[10:32:43.420]                         }
[10:32:43.420]                       }
[10:32:43.420]                       invisible(muffled)
[10:32:43.420]                     }
[10:32:43.420]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.420]                   }
[10:32:43.420]                 }
[10:32:43.420]             }
[10:32:43.420]         }))
[10:32:43.420]     }, error = function(ex) {
[10:32:43.420]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.420]                 ...future.rng), started = ...future.startTime, 
[10:32:43.420]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.420]             version = "1.8"), class = "FutureResult")
[10:32:43.420]     }, finally = {
[10:32:43.420]         if (!identical(...future.workdir, getwd())) 
[10:32:43.420]             setwd(...future.workdir)
[10:32:43.420]         {
[10:32:43.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.420]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.420]             }
[10:32:43.420]             base::options(...future.oldOptions)
[10:32:43.420]             if (.Platform$OS.type == "windows") {
[10:32:43.420]                 old_names <- names(...future.oldEnvVars)
[10:32:43.420]                 envs <- base::Sys.getenv()
[10:32:43.420]                 names <- names(envs)
[10:32:43.420]                 common <- intersect(names, old_names)
[10:32:43.420]                 added <- setdiff(names, old_names)
[10:32:43.420]                 removed <- setdiff(old_names, names)
[10:32:43.420]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.420]                   envs[common]]
[10:32:43.420]                 NAMES <- toupper(changed)
[10:32:43.420]                 args <- list()
[10:32:43.420]                 for (kk in seq_along(NAMES)) {
[10:32:43.420]                   name <- changed[[kk]]
[10:32:43.420]                   NAME <- NAMES[[kk]]
[10:32:43.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.420]                     next
[10:32:43.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.420]                 }
[10:32:43.420]                 NAMES <- toupper(added)
[10:32:43.420]                 for (kk in seq_along(NAMES)) {
[10:32:43.420]                   name <- added[[kk]]
[10:32:43.420]                   NAME <- NAMES[[kk]]
[10:32:43.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.420]                     next
[10:32:43.420]                   args[[name]] <- ""
[10:32:43.420]                 }
[10:32:43.420]                 NAMES <- toupper(removed)
[10:32:43.420]                 for (kk in seq_along(NAMES)) {
[10:32:43.420]                   name <- removed[[kk]]
[10:32:43.420]                   NAME <- NAMES[[kk]]
[10:32:43.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.420]                     next
[10:32:43.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.420]                 }
[10:32:43.420]                 if (length(args) > 0) 
[10:32:43.420]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.420]             }
[10:32:43.420]             else {
[10:32:43.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.420]             }
[10:32:43.420]             {
[10:32:43.420]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.420]                   0L) {
[10:32:43.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.420]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.420]                   base::options(opts)
[10:32:43.420]                 }
[10:32:43.420]                 {
[10:32:43.420]                   {
[10:32:43.420]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.420]                     NULL
[10:32:43.420]                   }
[10:32:43.420]                   options(future.plan = NULL)
[10:32:43.420]                   if (is.na(NA_character_)) 
[10:32:43.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.420]                     .init = FALSE)
[10:32:43.420]                 }
[10:32:43.420]             }
[10:32:43.420]         }
[10:32:43.420]     })
[10:32:43.420]     if (TRUE) {
[10:32:43.420]         base::sink(type = "output", split = FALSE)
[10:32:43.420]         if (TRUE) {
[10:32:43.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.420]         }
[10:32:43.420]         else {
[10:32:43.420]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.420]         }
[10:32:43.420]         base::close(...future.stdout)
[10:32:43.420]         ...future.stdout <- NULL
[10:32:43.420]     }
[10:32:43.420]     ...future.result$conditions <- ...future.conditions
[10:32:43.420]     ...future.result$finished <- base::Sys.time()
[10:32:43.420]     ...future.result
[10:32:43.420] }
[10:32:43.423] MultisessionFuture started
[10:32:43.423] - Launch lazy future ... done
[10:32:43.423] run() for ‘MultisessionFuture’ ... done
[10:32:43.424] result() for ClusterFuture ...
[10:32:43.424] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.424] - Validating connection of MultisessionFuture
[10:32:43.439] - received message: FutureResult
[10:32:43.439] - Received FutureResult
[10:32:43.439] - Erased future from FutureRegistry
[10:32:43.439] result() for ClusterFuture ...
[10:32:43.439] - result already collected: FutureResult
[10:32:43.439] result() for ClusterFuture ... done
[10:32:43.440] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.440] result() for ClusterFuture ... done
[10:32:43.440] result() for ClusterFuture ...
[10:32:43.440] - result already collected: FutureResult
[10:32:43.440] result() for ClusterFuture ... done
a = 10
[10:32:43.440] getGlobalsAndPackages() ...
[10:32:43.440] Searching for globals...
[10:32:43.441] - globals found: [3] ‘{’, ‘+’, ‘a’
[10:32:43.441] Searching for globals ... DONE
[10:32:43.441] Resolving globals: FALSE
[10:32:43.442] The total size of the 1 globals is 56 bytes (56 bytes)
[10:32:43.442] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:32:43.442] - globals: [1] ‘a’
[10:32:43.442] 
[10:32:43.442] getGlobalsAndPackages() ... DONE
[10:32:43.443] run() for ‘Future’ ...
[10:32:43.443] - state: ‘created’
[10:32:43.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:43.456] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:43.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:43.457]   - Field: ‘node’
[10:32:43.457]   - Field: ‘label’
[10:32:43.457]   - Field: ‘local’
[10:32:43.457]   - Field: ‘owner’
[10:32:43.457]   - Field: ‘envir’
[10:32:43.457]   - Field: ‘workers’
[10:32:43.457]   - Field: ‘packages’
[10:32:43.457]   - Field: ‘gc’
[10:32:43.458]   - Field: ‘conditions’
[10:32:43.458]   - Field: ‘persistent’
[10:32:43.458]   - Field: ‘expr’
[10:32:43.458]   - Field: ‘uuid’
[10:32:43.458]   - Field: ‘seed’
[10:32:43.458]   - Field: ‘version’
[10:32:43.458]   - Field: ‘result’
[10:32:43.458]   - Field: ‘asynchronous’
[10:32:43.458]   - Field: ‘calls’
[10:32:43.458]   - Field: ‘globals’
[10:32:43.458]   - Field: ‘stdout’
[10:32:43.459]   - Field: ‘earlySignal’
[10:32:43.459]   - Field: ‘lazy’
[10:32:43.459]   - Field: ‘state’
[10:32:43.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:43.459] - Launch lazy future ...
[10:32:43.459] Packages needed by the future expression (n = 0): <none>
[10:32:43.459] Packages needed by future strategies (n = 0): <none>
[10:32:43.460] {
[10:32:43.460]     {
[10:32:43.460]         {
[10:32:43.460]             ...future.startTime <- base::Sys.time()
[10:32:43.460]             {
[10:32:43.460]                 {
[10:32:43.460]                   {
[10:32:43.460]                     {
[10:32:43.460]                       base::local({
[10:32:43.460]                         has_future <- base::requireNamespace("future", 
[10:32:43.460]                           quietly = TRUE)
[10:32:43.460]                         if (has_future) {
[10:32:43.460]                           ns <- base::getNamespace("future")
[10:32:43.460]                           version <- ns[[".package"]][["version"]]
[10:32:43.460]                           if (is.null(version)) 
[10:32:43.460]                             version <- utils::packageVersion("future")
[10:32:43.460]                         }
[10:32:43.460]                         else {
[10:32:43.460]                           version <- NULL
[10:32:43.460]                         }
[10:32:43.460]                         if (!has_future || version < "1.8.0") {
[10:32:43.460]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:43.460]                             "", base::R.version$version.string), 
[10:32:43.460]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:43.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:43.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:43.460]                               "release", "version")], collapse = " "), 
[10:32:43.460]                             hostname = base::Sys.info()[["nodename"]])
[10:32:43.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:43.460]                             info)
[10:32:43.460]                           info <- base::paste(info, collapse = "; ")
[10:32:43.460]                           if (!has_future) {
[10:32:43.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:43.460]                               info)
[10:32:43.460]                           }
[10:32:43.460]                           else {
[10:32:43.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:43.460]                               info, version)
[10:32:43.460]                           }
[10:32:43.460]                           base::stop(msg)
[10:32:43.460]                         }
[10:32:43.460]                       })
[10:32:43.460]                     }
[10:32:43.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:43.460]                     base::options(mc.cores = 1L)
[10:32:43.460]                   }
[10:32:43.460]                   ...future.strategy.old <- future::plan("list")
[10:32:43.460]                   options(future.plan = NULL)
[10:32:43.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:43.460]                 }
[10:32:43.460]                 ...future.workdir <- getwd()
[10:32:43.460]             }
[10:32:43.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:43.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:43.460]         }
[10:32:43.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:43.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:43.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:43.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:43.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:43.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:43.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:43.460]             base::names(...future.oldOptions))
[10:32:43.460]     }
[10:32:43.460]     if (FALSE) {
[10:32:43.460]     }
[10:32:43.460]     else {
[10:32:43.460]         if (TRUE) {
[10:32:43.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:43.460]                 open = "w")
[10:32:43.460]         }
[10:32:43.460]         else {
[10:32:43.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:43.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:43.460]         }
[10:32:43.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:43.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:43.460]             base::sink(type = "output", split = FALSE)
[10:32:43.460]             base::close(...future.stdout)
[10:32:43.460]         }, add = TRUE)
[10:32:43.460]     }
[10:32:43.460]     ...future.frame <- base::sys.nframe()
[10:32:43.460]     ...future.conditions <- base::list()
[10:32:43.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:43.460]     if (FALSE) {
[10:32:43.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:43.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:43.460]     }
[10:32:43.460]     ...future.result <- base::tryCatch({
[10:32:43.460]         base::withCallingHandlers({
[10:32:43.460]             ...future.value <- base::withVisible(base::local({
[10:32:43.460]                 ...future.makeSendCondition <- base::local({
[10:32:43.460]                   sendCondition <- NULL
[10:32:43.460]                   function(frame = 1L) {
[10:32:43.460]                     if (is.function(sendCondition)) 
[10:32:43.460]                       return(sendCondition)
[10:32:43.460]                     ns <- getNamespace("parallel")
[10:32:43.460]                     if (exists("sendData", mode = "function", 
[10:32:43.460]                       envir = ns)) {
[10:32:43.460]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:43.460]                         envir = ns)
[10:32:43.460]                       envir <- sys.frame(frame)
[10:32:43.460]                       master <- NULL
[10:32:43.460]                       while (!identical(envir, .GlobalEnv) && 
[10:32:43.460]                         !identical(envir, emptyenv())) {
[10:32:43.460]                         if (exists("master", mode = "list", envir = envir, 
[10:32:43.460]                           inherits = FALSE)) {
[10:32:43.460]                           master <- get("master", mode = "list", 
[10:32:43.460]                             envir = envir, inherits = FALSE)
[10:32:43.460]                           if (inherits(master, c("SOCKnode", 
[10:32:43.460]                             "SOCK0node"))) {
[10:32:43.460]                             sendCondition <<- function(cond) {
[10:32:43.460]                               data <- list(type = "VALUE", value = cond, 
[10:32:43.460]                                 success = TRUE)
[10:32:43.460]                               parallel_sendData(master, data)
[10:32:43.460]                             }
[10:32:43.460]                             return(sendCondition)
[10:32:43.460]                           }
[10:32:43.460]                         }
[10:32:43.460]                         frame <- frame + 1L
[10:32:43.460]                         envir <- sys.frame(frame)
[10:32:43.460]                       }
[10:32:43.460]                     }
[10:32:43.460]                     sendCondition <<- function(cond) NULL
[10:32:43.460]                   }
[10:32:43.460]                 })
[10:32:43.460]                 withCallingHandlers({
[10:32:43.460]                   {
[10:32:43.460]                     a + 1
[10:32:43.460]                   }
[10:32:43.460]                 }, immediateCondition = function(cond) {
[10:32:43.460]                   sendCondition <- ...future.makeSendCondition()
[10:32:43.460]                   sendCondition(cond)
[10:32:43.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.460]                   {
[10:32:43.460]                     inherits <- base::inherits
[10:32:43.460]                     invokeRestart <- base::invokeRestart
[10:32:43.460]                     is.null <- base::is.null
[10:32:43.460]                     muffled <- FALSE
[10:32:43.460]                     if (inherits(cond, "message")) {
[10:32:43.460]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:43.460]                       if (muffled) 
[10:32:43.460]                         invokeRestart("muffleMessage")
[10:32:43.460]                     }
[10:32:43.460]                     else if (inherits(cond, "warning")) {
[10:32:43.460]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:43.460]                       if (muffled) 
[10:32:43.460]                         invokeRestart("muffleWarning")
[10:32:43.460]                     }
[10:32:43.460]                     else if (inherits(cond, "condition")) {
[10:32:43.460]                       if (!is.null(pattern)) {
[10:32:43.460]                         computeRestarts <- base::computeRestarts
[10:32:43.460]                         grepl <- base::grepl
[10:32:43.460]                         restarts <- computeRestarts(cond)
[10:32:43.460]                         for (restart in restarts) {
[10:32:43.460]                           name <- restart$name
[10:32:43.460]                           if (is.null(name)) 
[10:32:43.460]                             next
[10:32:43.460]                           if (!grepl(pattern, name)) 
[10:32:43.460]                             next
[10:32:43.460]                           invokeRestart(restart)
[10:32:43.460]                           muffled <- TRUE
[10:32:43.460]                           break
[10:32:43.460]                         }
[10:32:43.460]                       }
[10:32:43.460]                     }
[10:32:43.460]                     invisible(muffled)
[10:32:43.460]                   }
[10:32:43.460]                   muffleCondition(cond)
[10:32:43.460]                 })
[10:32:43.460]             }))
[10:32:43.460]             future::FutureResult(value = ...future.value$value, 
[10:32:43.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.460]                   ...future.rng), globalenv = if (FALSE) 
[10:32:43.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:43.460]                     ...future.globalenv.names))
[10:32:43.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:43.460]         }, condition = base::local({
[10:32:43.460]             c <- base::c
[10:32:43.460]             inherits <- base::inherits
[10:32:43.460]             invokeRestart <- base::invokeRestart
[10:32:43.460]             length <- base::length
[10:32:43.460]             list <- base::list
[10:32:43.460]             seq.int <- base::seq.int
[10:32:43.460]             signalCondition <- base::signalCondition
[10:32:43.460]             sys.calls <- base::sys.calls
[10:32:43.460]             `[[` <- base::`[[`
[10:32:43.460]             `+` <- base::`+`
[10:32:43.460]             `<<-` <- base::`<<-`
[10:32:43.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:43.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:43.460]                   3L)]
[10:32:43.460]             }
[10:32:43.460]             function(cond) {
[10:32:43.460]                 is_error <- inherits(cond, "error")
[10:32:43.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:43.460]                   NULL)
[10:32:43.460]                 if (is_error) {
[10:32:43.460]                   sessionInformation <- function() {
[10:32:43.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:43.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:43.460]                       search = base::search(), system = base::Sys.info())
[10:32:43.460]                   }
[10:32:43.460]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:43.460]                     cond$call), session = sessionInformation(), 
[10:32:43.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:43.460]                   signalCondition(cond)
[10:32:43.460]                 }
[10:32:43.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:43.460]                 "immediateCondition"))) {
[10:32:43.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:43.460]                   ...future.conditions[[length(...future.conditions) + 
[10:32:43.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:43.460]                   if (TRUE && !signal) {
[10:32:43.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.460]                     {
[10:32:43.460]                       inherits <- base::inherits
[10:32:43.460]                       invokeRestart <- base::invokeRestart
[10:32:43.460]                       is.null <- base::is.null
[10:32:43.460]                       muffled <- FALSE
[10:32:43.460]                       if (inherits(cond, "message")) {
[10:32:43.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.460]                         if (muffled) 
[10:32:43.460]                           invokeRestart("muffleMessage")
[10:32:43.460]                       }
[10:32:43.460]                       else if (inherits(cond, "warning")) {
[10:32:43.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.460]                         if (muffled) 
[10:32:43.460]                           invokeRestart("muffleWarning")
[10:32:43.460]                       }
[10:32:43.460]                       else if (inherits(cond, "condition")) {
[10:32:43.460]                         if (!is.null(pattern)) {
[10:32:43.460]                           computeRestarts <- base::computeRestarts
[10:32:43.460]                           grepl <- base::grepl
[10:32:43.460]                           restarts <- computeRestarts(cond)
[10:32:43.460]                           for (restart in restarts) {
[10:32:43.460]                             name <- restart$name
[10:32:43.460]                             if (is.null(name)) 
[10:32:43.460]                               next
[10:32:43.460]                             if (!grepl(pattern, name)) 
[10:32:43.460]                               next
[10:32:43.460]                             invokeRestart(restart)
[10:32:43.460]                             muffled <- TRUE
[10:32:43.460]                             break
[10:32:43.460]                           }
[10:32:43.460]                         }
[10:32:43.460]                       }
[10:32:43.460]                       invisible(muffled)
[10:32:43.460]                     }
[10:32:43.460]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.460]                   }
[10:32:43.460]                 }
[10:32:43.460]                 else {
[10:32:43.460]                   if (TRUE) {
[10:32:43.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:43.460]                     {
[10:32:43.460]                       inherits <- base::inherits
[10:32:43.460]                       invokeRestart <- base::invokeRestart
[10:32:43.460]                       is.null <- base::is.null
[10:32:43.460]                       muffled <- FALSE
[10:32:43.460]                       if (inherits(cond, "message")) {
[10:32:43.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:43.460]                         if (muffled) 
[10:32:43.460]                           invokeRestart("muffleMessage")
[10:32:43.460]                       }
[10:32:43.460]                       else if (inherits(cond, "warning")) {
[10:32:43.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:43.460]                         if (muffled) 
[10:32:43.460]                           invokeRestart("muffleWarning")
[10:32:43.460]                       }
[10:32:43.460]                       else if (inherits(cond, "condition")) {
[10:32:43.460]                         if (!is.null(pattern)) {
[10:32:43.460]                           computeRestarts <- base::computeRestarts
[10:32:43.460]                           grepl <- base::grepl
[10:32:43.460]                           restarts <- computeRestarts(cond)
[10:32:43.460]                           for (restart in restarts) {
[10:32:43.460]                             name <- restart$name
[10:32:43.460]                             if (is.null(name)) 
[10:32:43.460]                               next
[10:32:43.460]                             if (!grepl(pattern, name)) 
[10:32:43.460]                               next
[10:32:43.460]                             invokeRestart(restart)
[10:32:43.460]                             muffled <- TRUE
[10:32:43.460]                             break
[10:32:43.460]                           }
[10:32:43.460]                         }
[10:32:43.460]                       }
[10:32:43.460]                       invisible(muffled)
[10:32:43.460]                     }
[10:32:43.460]                     muffleCondition(cond, pattern = "^muffle")
[10:32:43.460]                   }
[10:32:43.460]                 }
[10:32:43.460]             }
[10:32:43.460]         }))
[10:32:43.460]     }, error = function(ex) {
[10:32:43.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:43.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:43.460]                 ...future.rng), started = ...future.startTime, 
[10:32:43.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:43.460]             version = "1.8"), class = "FutureResult")
[10:32:43.460]     }, finally = {
[10:32:43.460]         if (!identical(...future.workdir, getwd())) 
[10:32:43.460]             setwd(...future.workdir)
[10:32:43.460]         {
[10:32:43.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:43.460]                 ...future.oldOptions$nwarnings <- NULL
[10:32:43.460]             }
[10:32:43.460]             base::options(...future.oldOptions)
[10:32:43.460]             if (.Platform$OS.type == "windows") {
[10:32:43.460]                 old_names <- names(...future.oldEnvVars)
[10:32:43.460]                 envs <- base::Sys.getenv()
[10:32:43.460]                 names <- names(envs)
[10:32:43.460]                 common <- intersect(names, old_names)
[10:32:43.460]                 added <- setdiff(names, old_names)
[10:32:43.460]                 removed <- setdiff(old_names, names)
[10:32:43.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:43.460]                   envs[common]]
[10:32:43.460]                 NAMES <- toupper(changed)
[10:32:43.460]                 args <- list()
[10:32:43.460]                 for (kk in seq_along(NAMES)) {
[10:32:43.460]                   name <- changed[[kk]]
[10:32:43.460]                   NAME <- NAMES[[kk]]
[10:32:43.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.460]                     next
[10:32:43.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.460]                 }
[10:32:43.460]                 NAMES <- toupper(added)
[10:32:43.460]                 for (kk in seq_along(NAMES)) {
[10:32:43.460]                   name <- added[[kk]]
[10:32:43.460]                   NAME <- NAMES[[kk]]
[10:32:43.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.460]                     next
[10:32:43.460]                   args[[name]] <- ""
[10:32:43.460]                 }
[10:32:43.460]                 NAMES <- toupper(removed)
[10:32:43.460]                 for (kk in seq_along(NAMES)) {
[10:32:43.460]                   name <- removed[[kk]]
[10:32:43.460]                   NAME <- NAMES[[kk]]
[10:32:43.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:43.460]                     next
[10:32:43.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:43.460]                 }
[10:32:43.460]                 if (length(args) > 0) 
[10:32:43.460]                   base::do.call(base::Sys.setenv, args = args)
[10:32:43.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:43.460]             }
[10:32:43.460]             else {
[10:32:43.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:43.460]             }
[10:32:43.460]             {
[10:32:43.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:43.460]                   0L) {
[10:32:43.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:43.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:43.460]                   base::options(opts)
[10:32:43.460]                 }
[10:32:43.460]                 {
[10:32:43.460]                   {
[10:32:43.460]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:43.460]                     NULL
[10:32:43.460]                   }
[10:32:43.460]                   options(future.plan = NULL)
[10:32:43.460]                   if (is.na(NA_character_)) 
[10:32:43.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:43.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:43.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:43.460]                     .init = FALSE)
[10:32:43.460]                 }
[10:32:43.460]             }
[10:32:43.460]         }
[10:32:43.460]     })
[10:32:43.460]     if (TRUE) {
[10:32:43.460]         base::sink(type = "output", split = FALSE)
[10:32:43.460]         if (TRUE) {
[10:32:43.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:43.460]         }
[10:32:43.460]         else {
[10:32:43.460]             ...future.result["stdout"] <- base::list(NULL)
[10:32:43.460]         }
[10:32:43.460]         base::close(...future.stdout)
[10:32:43.460]         ...future.stdout <- NULL
[10:32:43.460]     }
[10:32:43.460]     ...future.result$conditions <- ...future.conditions
[10:32:43.460]     ...future.result$finished <- base::Sys.time()
[10:32:43.460]     ...future.result
[10:32:43.460] }
[10:32:43.462] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:32:43.462] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:32:43.463] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:32:43.463] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:32:43.464] MultisessionFuture started
[10:32:43.464] - Launch lazy future ... done
[10:32:43.464] run() for ‘MultisessionFuture’ ... done
[10:32:43.464] result() for ClusterFuture ...
[10:32:43.464] receiveMessageFromWorker() for ClusterFuture ...
[10:32:43.464] - Validating connection of MultisessionFuture
[10:32:43.465] - received message: FutureResult
[10:32:43.466] - Received FutureResult
[10:32:43.466] - Erased future from FutureRegistry
[10:32:43.466] result() for ClusterFuture ...
[10:32:43.466] - result already collected: FutureResult
[10:32:43.466] result() for ClusterFuture ... done
[10:32:43.466] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:43.466] result() for ClusterFuture ... done
[10:32:43.466] result() for ClusterFuture ...
[10:32:43.466] - result already collected: FutureResult
[10:32:43.466] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[10:32:43.467] plan(): Setting new future strategy stack:
[10:32:43.467] List of future strategies:
[10:32:43.467] 1. FutureStrategy:
[10:32:43.467]    - args: function (..., envir = parent.frame())
[10:32:43.467]    - tweaked: FALSE
[10:32:43.467]    - call: future::plan(oplan)
[10:32:43.468] plan(): nbrOfWorkers() = 1
> 
