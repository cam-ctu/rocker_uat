
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:36:25.469] plan(): Setting new future strategy stack:
[13:36:25.469] List of future strategies:
[13:36:25.469] 1. sequential:
[13:36:25.469]    - args: function (..., envir = parent.frame())
[13:36:25.469]    - tweaked: FALSE
[13:36:25.469]    - call: future::plan("sequential")
[13:36:25.483] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[13:36:25.535] plan(): Setting new future strategy stack:
[13:36:25.535] List of future strategies:
[13:36:25.535] 1. sequential:
[13:36:25.535]    - args: function (..., envir = parent.frame())
[13:36:25.535]    - tweaked: FALSE
[13:36:25.535]    - call: plan(strategy)
[13:36:25.546] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[13:36:25.548] getGlobalsAndPackages() ...
[13:36:25.548] Searching for globals...
[13:36:25.553] - globals found: [2] ‘{’, ‘<-’
[13:36:25.553] Searching for globals ... DONE
[13:36:25.553] Resolving globals: FALSE
[13:36:25.554] 
[13:36:25.554] 
[13:36:25.554] getGlobalsAndPackages() ... DONE
[13:36:25.555] run() for ‘Future’ ...
[13:36:25.555] - state: ‘created’
[13:36:25.555] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.555]   - Field: ‘label’
[13:36:25.556]   - Field: ‘local’
[13:36:25.556]   - Field: ‘owner’
[13:36:25.556]   - Field: ‘envir’
[13:36:25.556]   - Field: ‘packages’
[13:36:25.556]   - Field: ‘gc’
[13:36:25.556]   - Field: ‘conditions’
[13:36:25.556]   - Field: ‘expr’
[13:36:25.556]   - Field: ‘uuid’
[13:36:25.556]   - Field: ‘seed’
[13:36:25.556]   - Field: ‘version’
[13:36:25.556]   - Field: ‘result’
[13:36:25.557]   - Field: ‘asynchronous’
[13:36:25.557]   - Field: ‘calls’
[13:36:25.557]   - Field: ‘globals’
[13:36:25.557]   - Field: ‘stdout’
[13:36:25.557]   - Field: ‘earlySignal’
[13:36:25.557]   - Field: ‘lazy’
[13:36:25.557]   - Field: ‘state’
[13:36:25.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.557] - Launch lazy future ...
[13:36:25.558] Packages needed by the future expression (n = 0): <none>
[13:36:25.558] Packages needed by future strategies (n = 0): <none>
[13:36:25.559] {
[13:36:25.559]     {
[13:36:25.559]         {
[13:36:25.559]             ...future.startTime <- base::Sys.time()
[13:36:25.559]             {
[13:36:25.559]                 {
[13:36:25.559]                   {
[13:36:25.559]                     base::local({
[13:36:25.559]                       has_future <- base::requireNamespace("future", 
[13:36:25.559]                         quietly = TRUE)
[13:36:25.559]                       if (has_future) {
[13:36:25.559]                         ns <- base::getNamespace("future")
[13:36:25.559]                         version <- ns[[".package"]][["version"]]
[13:36:25.559]                         if (is.null(version)) 
[13:36:25.559]                           version <- utils::packageVersion("future")
[13:36:25.559]                       }
[13:36:25.559]                       else {
[13:36:25.559]                         version <- NULL
[13:36:25.559]                       }
[13:36:25.559]                       if (!has_future || version < "1.8.0") {
[13:36:25.559]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.559]                           "", base::R.version$version.string), 
[13:36:25.559]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.559]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.559]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.559]                             "release", "version")], collapse = " "), 
[13:36:25.559]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.559]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.559]                           info)
[13:36:25.559]                         info <- base::paste(info, collapse = "; ")
[13:36:25.559]                         if (!has_future) {
[13:36:25.559]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.559]                             info)
[13:36:25.559]                         }
[13:36:25.559]                         else {
[13:36:25.559]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.559]                             info, version)
[13:36:25.559]                         }
[13:36:25.559]                         base::stop(msg)
[13:36:25.559]                       }
[13:36:25.559]                     })
[13:36:25.559]                   }
[13:36:25.559]                   ...future.strategy.old <- future::plan("list")
[13:36:25.559]                   options(future.plan = NULL)
[13:36:25.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.559]                 }
[13:36:25.559]                 ...future.workdir <- getwd()
[13:36:25.559]             }
[13:36:25.559]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.559]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.559]         }
[13:36:25.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.559]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.559]             base::names(...future.oldOptions))
[13:36:25.559]     }
[13:36:25.559]     if (FALSE) {
[13:36:25.559]     }
[13:36:25.559]     else {
[13:36:25.559]         if (TRUE) {
[13:36:25.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.559]                 open = "w")
[13:36:25.559]         }
[13:36:25.559]         else {
[13:36:25.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.559]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.559]         }
[13:36:25.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.559]             base::sink(type = "output", split = FALSE)
[13:36:25.559]             base::close(...future.stdout)
[13:36:25.559]         }, add = TRUE)
[13:36:25.559]     }
[13:36:25.559]     ...future.frame <- base::sys.nframe()
[13:36:25.559]     ...future.conditions <- base::list()
[13:36:25.559]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.559]     if (FALSE) {
[13:36:25.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.559]     }
[13:36:25.559]     ...future.result <- base::tryCatch({
[13:36:25.559]         base::withCallingHandlers({
[13:36:25.559]             ...future.value <- base::withVisible(base::local({
[13:36:25.559]                 x <- 1
[13:36:25.559]             }))
[13:36:25.559]             future::FutureResult(value = ...future.value$value, 
[13:36:25.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.559]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.559]                     ...future.globalenv.names))
[13:36:25.559]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.559]         }, condition = base::local({
[13:36:25.559]             c <- base::c
[13:36:25.559]             inherits <- base::inherits
[13:36:25.559]             invokeRestart <- base::invokeRestart
[13:36:25.559]             length <- base::length
[13:36:25.559]             list <- base::list
[13:36:25.559]             seq.int <- base::seq.int
[13:36:25.559]             signalCondition <- base::signalCondition
[13:36:25.559]             sys.calls <- base::sys.calls
[13:36:25.559]             `[[` <- base::`[[`
[13:36:25.559]             `+` <- base::`+`
[13:36:25.559]             `<<-` <- base::`<<-`
[13:36:25.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.559]                   3L)]
[13:36:25.559]             }
[13:36:25.559]             function(cond) {
[13:36:25.559]                 is_error <- inherits(cond, "error")
[13:36:25.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.559]                   NULL)
[13:36:25.559]                 if (is_error) {
[13:36:25.559]                   sessionInformation <- function() {
[13:36:25.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.559]                       search = base::search(), system = base::Sys.info())
[13:36:25.559]                   }
[13:36:25.559]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.559]                     cond$call), session = sessionInformation(), 
[13:36:25.559]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.559]                   signalCondition(cond)
[13:36:25.559]                 }
[13:36:25.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.559]                 "immediateCondition"))) {
[13:36:25.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.559]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.559]                   if (TRUE && !signal) {
[13:36:25.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.559]                     {
[13:36:25.559]                       inherits <- base::inherits
[13:36:25.559]                       invokeRestart <- base::invokeRestart
[13:36:25.559]                       is.null <- base::is.null
[13:36:25.559]                       muffled <- FALSE
[13:36:25.559]                       if (inherits(cond, "message")) {
[13:36:25.559]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.559]                         if (muffled) 
[13:36:25.559]                           invokeRestart("muffleMessage")
[13:36:25.559]                       }
[13:36:25.559]                       else if (inherits(cond, "warning")) {
[13:36:25.559]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.559]                         if (muffled) 
[13:36:25.559]                           invokeRestart("muffleWarning")
[13:36:25.559]                       }
[13:36:25.559]                       else if (inherits(cond, "condition")) {
[13:36:25.559]                         if (!is.null(pattern)) {
[13:36:25.559]                           computeRestarts <- base::computeRestarts
[13:36:25.559]                           grepl <- base::grepl
[13:36:25.559]                           restarts <- computeRestarts(cond)
[13:36:25.559]                           for (restart in restarts) {
[13:36:25.559]                             name <- restart$name
[13:36:25.559]                             if (is.null(name)) 
[13:36:25.559]                               next
[13:36:25.559]                             if (!grepl(pattern, name)) 
[13:36:25.559]                               next
[13:36:25.559]                             invokeRestart(restart)
[13:36:25.559]                             muffled <- TRUE
[13:36:25.559]                             break
[13:36:25.559]                           }
[13:36:25.559]                         }
[13:36:25.559]                       }
[13:36:25.559]                       invisible(muffled)
[13:36:25.559]                     }
[13:36:25.559]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.559]                   }
[13:36:25.559]                 }
[13:36:25.559]                 else {
[13:36:25.559]                   if (TRUE) {
[13:36:25.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.559]                     {
[13:36:25.559]                       inherits <- base::inherits
[13:36:25.559]                       invokeRestart <- base::invokeRestart
[13:36:25.559]                       is.null <- base::is.null
[13:36:25.559]                       muffled <- FALSE
[13:36:25.559]                       if (inherits(cond, "message")) {
[13:36:25.559]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.559]                         if (muffled) 
[13:36:25.559]                           invokeRestart("muffleMessage")
[13:36:25.559]                       }
[13:36:25.559]                       else if (inherits(cond, "warning")) {
[13:36:25.559]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.559]                         if (muffled) 
[13:36:25.559]                           invokeRestart("muffleWarning")
[13:36:25.559]                       }
[13:36:25.559]                       else if (inherits(cond, "condition")) {
[13:36:25.559]                         if (!is.null(pattern)) {
[13:36:25.559]                           computeRestarts <- base::computeRestarts
[13:36:25.559]                           grepl <- base::grepl
[13:36:25.559]                           restarts <- computeRestarts(cond)
[13:36:25.559]                           for (restart in restarts) {
[13:36:25.559]                             name <- restart$name
[13:36:25.559]                             if (is.null(name)) 
[13:36:25.559]                               next
[13:36:25.559]                             if (!grepl(pattern, name)) 
[13:36:25.559]                               next
[13:36:25.559]                             invokeRestart(restart)
[13:36:25.559]                             muffled <- TRUE
[13:36:25.559]                             break
[13:36:25.559]                           }
[13:36:25.559]                         }
[13:36:25.559]                       }
[13:36:25.559]                       invisible(muffled)
[13:36:25.559]                     }
[13:36:25.559]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.559]                   }
[13:36:25.559]                 }
[13:36:25.559]             }
[13:36:25.559]         }))
[13:36:25.559]     }, error = function(ex) {
[13:36:25.559]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.559]                 ...future.rng), started = ...future.startTime, 
[13:36:25.559]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.559]             version = "1.8"), class = "FutureResult")
[13:36:25.559]     }, finally = {
[13:36:25.559]         if (!identical(...future.workdir, getwd())) 
[13:36:25.559]             setwd(...future.workdir)
[13:36:25.559]         {
[13:36:25.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.559]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.559]             }
[13:36:25.559]             base::options(...future.oldOptions)
[13:36:25.559]             if (.Platform$OS.type == "windows") {
[13:36:25.559]                 old_names <- names(...future.oldEnvVars)
[13:36:25.559]                 envs <- base::Sys.getenv()
[13:36:25.559]                 names <- names(envs)
[13:36:25.559]                 common <- intersect(names, old_names)
[13:36:25.559]                 added <- setdiff(names, old_names)
[13:36:25.559]                 removed <- setdiff(old_names, names)
[13:36:25.559]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.559]                   envs[common]]
[13:36:25.559]                 NAMES <- toupper(changed)
[13:36:25.559]                 args <- list()
[13:36:25.559]                 for (kk in seq_along(NAMES)) {
[13:36:25.559]                   name <- changed[[kk]]
[13:36:25.559]                   NAME <- NAMES[[kk]]
[13:36:25.559]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.559]                     next
[13:36:25.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.559]                 }
[13:36:25.559]                 NAMES <- toupper(added)
[13:36:25.559]                 for (kk in seq_along(NAMES)) {
[13:36:25.559]                   name <- added[[kk]]
[13:36:25.559]                   NAME <- NAMES[[kk]]
[13:36:25.559]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.559]                     next
[13:36:25.559]                   args[[name]] <- ""
[13:36:25.559]                 }
[13:36:25.559]                 NAMES <- toupper(removed)
[13:36:25.559]                 for (kk in seq_along(NAMES)) {
[13:36:25.559]                   name <- removed[[kk]]
[13:36:25.559]                   NAME <- NAMES[[kk]]
[13:36:25.559]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.559]                     next
[13:36:25.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.559]                 }
[13:36:25.559]                 if (length(args) > 0) 
[13:36:25.559]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.559]             }
[13:36:25.559]             else {
[13:36:25.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.559]             }
[13:36:25.559]             {
[13:36:25.559]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.559]                   0L) {
[13:36:25.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.559]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.559]                   base::options(opts)
[13:36:25.559]                 }
[13:36:25.559]                 {
[13:36:25.559]                   {
[13:36:25.559]                     NULL
[13:36:25.559]                     RNGkind("Mersenne-Twister")
[13:36:25.559]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.559]                       inherits = FALSE)
[13:36:25.559]                   }
[13:36:25.559]                   options(future.plan = NULL)
[13:36:25.559]                   if (is.na(NA_character_)) 
[13:36:25.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.559]                     .init = FALSE)
[13:36:25.559]                 }
[13:36:25.559]             }
[13:36:25.559]         }
[13:36:25.559]     })
[13:36:25.559]     if (TRUE) {
[13:36:25.559]         base::sink(type = "output", split = FALSE)
[13:36:25.559]         if (TRUE) {
[13:36:25.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.559]         }
[13:36:25.559]         else {
[13:36:25.559]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.559]         }
[13:36:25.559]         base::close(...future.stdout)
[13:36:25.559]         ...future.stdout <- NULL
[13:36:25.559]     }
[13:36:25.559]     ...future.result$conditions <- ...future.conditions
[13:36:25.559]     ...future.result$finished <- base::Sys.time()
[13:36:25.559]     ...future.result
[13:36:25.559] }
[13:36:25.561] plan(): Setting new future strategy stack:
[13:36:25.561] List of future strategies:
[13:36:25.561] 1. sequential:
[13:36:25.561]    - args: function (..., envir = parent.frame())
[13:36:25.561]    - tweaked: FALSE
[13:36:25.561]    - call: NULL
[13:36:25.561] plan(): nbrOfWorkers() = 1
[13:36:25.562] plan(): Setting new future strategy stack:
[13:36:25.563] List of future strategies:
[13:36:25.563] 1. sequential:
[13:36:25.563]    - args: function (..., envir = parent.frame())
[13:36:25.563]    - tweaked: FALSE
[13:36:25.563]    - call: plan(strategy)
[13:36:25.563] plan(): nbrOfWorkers() = 1
[13:36:25.563] SequentialFuture started (and completed)
[13:36:25.564] - Launch lazy future ... done
[13:36:25.564] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[13:36:25.564] getGlobalsAndPackages() ...
[13:36:25.564] Searching for globals...
[13:36:25.565] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:36:25.565] Searching for globals ... DONE
[13:36:25.565] Resolving globals: FALSE
[13:36:25.566] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.567] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:25.567] - globals: [1] ‘a’
[13:36:25.567] 
[13:36:25.567] getGlobalsAndPackages() ... DONE
[13:36:25.567] run() for ‘Future’ ...
[13:36:25.567] - state: ‘created’
[13:36:25.567] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.568] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.568]   - Field: ‘label’
[13:36:25.568]   - Field: ‘local’
[13:36:25.568]   - Field: ‘owner’
[13:36:25.568]   - Field: ‘envir’
[13:36:25.568]   - Field: ‘packages’
[13:36:25.568]   - Field: ‘gc’
[13:36:25.568]   - Field: ‘conditions’
[13:36:25.568]   - Field: ‘expr’
[13:36:25.569]   - Field: ‘uuid’
[13:36:25.569]   - Field: ‘seed’
[13:36:25.569]   - Field: ‘version’
[13:36:25.569]   - Field: ‘result’
[13:36:25.569]   - Field: ‘asynchronous’
[13:36:25.569]   - Field: ‘calls’
[13:36:25.569]   - Field: ‘globals’
[13:36:25.569]   - Field: ‘stdout’
[13:36:25.569]   - Field: ‘earlySignal’
[13:36:25.569]   - Field: ‘lazy’
[13:36:25.569]   - Field: ‘state’
[13:36:25.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.570] - Launch lazy future ...
[13:36:25.570] Packages needed by the future expression (n = 0): <none>
[13:36:25.570] Packages needed by future strategies (n = 0): <none>
[13:36:25.570] {
[13:36:25.570]     {
[13:36:25.570]         {
[13:36:25.570]             ...future.startTime <- base::Sys.time()
[13:36:25.570]             {
[13:36:25.570]                 {
[13:36:25.570]                   {
[13:36:25.570]                     base::local({
[13:36:25.570]                       has_future <- base::requireNamespace("future", 
[13:36:25.570]                         quietly = TRUE)
[13:36:25.570]                       if (has_future) {
[13:36:25.570]                         ns <- base::getNamespace("future")
[13:36:25.570]                         version <- ns[[".package"]][["version"]]
[13:36:25.570]                         if (is.null(version)) 
[13:36:25.570]                           version <- utils::packageVersion("future")
[13:36:25.570]                       }
[13:36:25.570]                       else {
[13:36:25.570]                         version <- NULL
[13:36:25.570]                       }
[13:36:25.570]                       if (!has_future || version < "1.8.0") {
[13:36:25.570]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.570]                           "", base::R.version$version.string), 
[13:36:25.570]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.570]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.570]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.570]                             "release", "version")], collapse = " "), 
[13:36:25.570]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.570]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.570]                           info)
[13:36:25.570]                         info <- base::paste(info, collapse = "; ")
[13:36:25.570]                         if (!has_future) {
[13:36:25.570]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.570]                             info)
[13:36:25.570]                         }
[13:36:25.570]                         else {
[13:36:25.570]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.570]                             info, version)
[13:36:25.570]                         }
[13:36:25.570]                         base::stop(msg)
[13:36:25.570]                       }
[13:36:25.570]                     })
[13:36:25.570]                   }
[13:36:25.570]                   ...future.strategy.old <- future::plan("list")
[13:36:25.570]                   options(future.plan = NULL)
[13:36:25.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.570]                 }
[13:36:25.570]                 ...future.workdir <- getwd()
[13:36:25.570]             }
[13:36:25.570]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.570]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.570]         }
[13:36:25.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.570]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.570]             base::names(...future.oldOptions))
[13:36:25.570]     }
[13:36:25.570]     if (FALSE) {
[13:36:25.570]     }
[13:36:25.570]     else {
[13:36:25.570]         if (TRUE) {
[13:36:25.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.570]                 open = "w")
[13:36:25.570]         }
[13:36:25.570]         else {
[13:36:25.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.570]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.570]         }
[13:36:25.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.570]             base::sink(type = "output", split = FALSE)
[13:36:25.570]             base::close(...future.stdout)
[13:36:25.570]         }, add = TRUE)
[13:36:25.570]     }
[13:36:25.570]     ...future.frame <- base::sys.nframe()
[13:36:25.570]     ...future.conditions <- base::list()
[13:36:25.570]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.570]     if (FALSE) {
[13:36:25.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.570]     }
[13:36:25.570]     ...future.result <- base::tryCatch({
[13:36:25.570]         base::withCallingHandlers({
[13:36:25.570]             ...future.value <- base::withVisible(base::local({
[13:36:25.570]                 x <- a
[13:36:25.570]             }))
[13:36:25.570]             future::FutureResult(value = ...future.value$value, 
[13:36:25.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.570]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.570]                     ...future.globalenv.names))
[13:36:25.570]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.570]         }, condition = base::local({
[13:36:25.570]             c <- base::c
[13:36:25.570]             inherits <- base::inherits
[13:36:25.570]             invokeRestart <- base::invokeRestart
[13:36:25.570]             length <- base::length
[13:36:25.570]             list <- base::list
[13:36:25.570]             seq.int <- base::seq.int
[13:36:25.570]             signalCondition <- base::signalCondition
[13:36:25.570]             sys.calls <- base::sys.calls
[13:36:25.570]             `[[` <- base::`[[`
[13:36:25.570]             `+` <- base::`+`
[13:36:25.570]             `<<-` <- base::`<<-`
[13:36:25.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.570]                   3L)]
[13:36:25.570]             }
[13:36:25.570]             function(cond) {
[13:36:25.570]                 is_error <- inherits(cond, "error")
[13:36:25.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.570]                   NULL)
[13:36:25.570]                 if (is_error) {
[13:36:25.570]                   sessionInformation <- function() {
[13:36:25.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.570]                       search = base::search(), system = base::Sys.info())
[13:36:25.570]                   }
[13:36:25.570]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.570]                     cond$call), session = sessionInformation(), 
[13:36:25.570]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.570]                   signalCondition(cond)
[13:36:25.570]                 }
[13:36:25.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.570]                 "immediateCondition"))) {
[13:36:25.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.570]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.570]                   if (TRUE && !signal) {
[13:36:25.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.570]                     {
[13:36:25.570]                       inherits <- base::inherits
[13:36:25.570]                       invokeRestart <- base::invokeRestart
[13:36:25.570]                       is.null <- base::is.null
[13:36:25.570]                       muffled <- FALSE
[13:36:25.570]                       if (inherits(cond, "message")) {
[13:36:25.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.570]                         if (muffled) 
[13:36:25.570]                           invokeRestart("muffleMessage")
[13:36:25.570]                       }
[13:36:25.570]                       else if (inherits(cond, "warning")) {
[13:36:25.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.570]                         if (muffled) 
[13:36:25.570]                           invokeRestart("muffleWarning")
[13:36:25.570]                       }
[13:36:25.570]                       else if (inherits(cond, "condition")) {
[13:36:25.570]                         if (!is.null(pattern)) {
[13:36:25.570]                           computeRestarts <- base::computeRestarts
[13:36:25.570]                           grepl <- base::grepl
[13:36:25.570]                           restarts <- computeRestarts(cond)
[13:36:25.570]                           for (restart in restarts) {
[13:36:25.570]                             name <- restart$name
[13:36:25.570]                             if (is.null(name)) 
[13:36:25.570]                               next
[13:36:25.570]                             if (!grepl(pattern, name)) 
[13:36:25.570]                               next
[13:36:25.570]                             invokeRestart(restart)
[13:36:25.570]                             muffled <- TRUE
[13:36:25.570]                             break
[13:36:25.570]                           }
[13:36:25.570]                         }
[13:36:25.570]                       }
[13:36:25.570]                       invisible(muffled)
[13:36:25.570]                     }
[13:36:25.570]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.570]                   }
[13:36:25.570]                 }
[13:36:25.570]                 else {
[13:36:25.570]                   if (TRUE) {
[13:36:25.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.570]                     {
[13:36:25.570]                       inherits <- base::inherits
[13:36:25.570]                       invokeRestart <- base::invokeRestart
[13:36:25.570]                       is.null <- base::is.null
[13:36:25.570]                       muffled <- FALSE
[13:36:25.570]                       if (inherits(cond, "message")) {
[13:36:25.570]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.570]                         if (muffled) 
[13:36:25.570]                           invokeRestart("muffleMessage")
[13:36:25.570]                       }
[13:36:25.570]                       else if (inherits(cond, "warning")) {
[13:36:25.570]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.570]                         if (muffled) 
[13:36:25.570]                           invokeRestart("muffleWarning")
[13:36:25.570]                       }
[13:36:25.570]                       else if (inherits(cond, "condition")) {
[13:36:25.570]                         if (!is.null(pattern)) {
[13:36:25.570]                           computeRestarts <- base::computeRestarts
[13:36:25.570]                           grepl <- base::grepl
[13:36:25.570]                           restarts <- computeRestarts(cond)
[13:36:25.570]                           for (restart in restarts) {
[13:36:25.570]                             name <- restart$name
[13:36:25.570]                             if (is.null(name)) 
[13:36:25.570]                               next
[13:36:25.570]                             if (!grepl(pattern, name)) 
[13:36:25.570]                               next
[13:36:25.570]                             invokeRestart(restart)
[13:36:25.570]                             muffled <- TRUE
[13:36:25.570]                             break
[13:36:25.570]                           }
[13:36:25.570]                         }
[13:36:25.570]                       }
[13:36:25.570]                       invisible(muffled)
[13:36:25.570]                     }
[13:36:25.570]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.570]                   }
[13:36:25.570]                 }
[13:36:25.570]             }
[13:36:25.570]         }))
[13:36:25.570]     }, error = function(ex) {
[13:36:25.570]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.570]                 ...future.rng), started = ...future.startTime, 
[13:36:25.570]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.570]             version = "1.8"), class = "FutureResult")
[13:36:25.570]     }, finally = {
[13:36:25.570]         if (!identical(...future.workdir, getwd())) 
[13:36:25.570]             setwd(...future.workdir)
[13:36:25.570]         {
[13:36:25.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.570]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.570]             }
[13:36:25.570]             base::options(...future.oldOptions)
[13:36:25.570]             if (.Platform$OS.type == "windows") {
[13:36:25.570]                 old_names <- names(...future.oldEnvVars)
[13:36:25.570]                 envs <- base::Sys.getenv()
[13:36:25.570]                 names <- names(envs)
[13:36:25.570]                 common <- intersect(names, old_names)
[13:36:25.570]                 added <- setdiff(names, old_names)
[13:36:25.570]                 removed <- setdiff(old_names, names)
[13:36:25.570]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.570]                   envs[common]]
[13:36:25.570]                 NAMES <- toupper(changed)
[13:36:25.570]                 args <- list()
[13:36:25.570]                 for (kk in seq_along(NAMES)) {
[13:36:25.570]                   name <- changed[[kk]]
[13:36:25.570]                   NAME <- NAMES[[kk]]
[13:36:25.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.570]                     next
[13:36:25.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.570]                 }
[13:36:25.570]                 NAMES <- toupper(added)
[13:36:25.570]                 for (kk in seq_along(NAMES)) {
[13:36:25.570]                   name <- added[[kk]]
[13:36:25.570]                   NAME <- NAMES[[kk]]
[13:36:25.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.570]                     next
[13:36:25.570]                   args[[name]] <- ""
[13:36:25.570]                 }
[13:36:25.570]                 NAMES <- toupper(removed)
[13:36:25.570]                 for (kk in seq_along(NAMES)) {
[13:36:25.570]                   name <- removed[[kk]]
[13:36:25.570]                   NAME <- NAMES[[kk]]
[13:36:25.570]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.570]                     next
[13:36:25.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.570]                 }
[13:36:25.570]                 if (length(args) > 0) 
[13:36:25.570]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.570]             }
[13:36:25.570]             else {
[13:36:25.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.570]             }
[13:36:25.570]             {
[13:36:25.570]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.570]                   0L) {
[13:36:25.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.570]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.570]                   base::options(opts)
[13:36:25.570]                 }
[13:36:25.570]                 {
[13:36:25.570]                   {
[13:36:25.570]                     NULL
[13:36:25.570]                     RNGkind("Mersenne-Twister")
[13:36:25.570]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.570]                       inherits = FALSE)
[13:36:25.570]                   }
[13:36:25.570]                   options(future.plan = NULL)
[13:36:25.570]                   if (is.na(NA_character_)) 
[13:36:25.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.570]                     .init = FALSE)
[13:36:25.570]                 }
[13:36:25.570]             }
[13:36:25.570]         }
[13:36:25.570]     })
[13:36:25.570]     if (TRUE) {
[13:36:25.570]         base::sink(type = "output", split = FALSE)
[13:36:25.570]         if (TRUE) {
[13:36:25.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.570]         }
[13:36:25.570]         else {
[13:36:25.570]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.570]         }
[13:36:25.570]         base::close(...future.stdout)
[13:36:25.570]         ...future.stdout <- NULL
[13:36:25.570]     }
[13:36:25.570]     ...future.result$conditions <- ...future.conditions
[13:36:25.570]     ...future.result$finished <- base::Sys.time()
[13:36:25.570]     ...future.result
[13:36:25.570] }
[13:36:25.572] assign_globals() ...
[13:36:25.572] List of 1
[13:36:25.572]  $ a: num 2
[13:36:25.572]  - attr(*, "where")=List of 1
[13:36:25.572]   ..$ a:<environment: R_EmptyEnv> 
[13:36:25.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.572]  - attr(*, "resolved")= logi FALSE
[13:36:25.572]  - attr(*, "total_size")= num 56
[13:36:25.572]  - attr(*, "already-done")= logi TRUE
[13:36:25.579] - copied ‘a’ to environment
[13:36:25.579] assign_globals() ... done
[13:36:25.579] plan(): Setting new future strategy stack:
[13:36:25.580] List of future strategies:
[13:36:25.580] 1. sequential:
[13:36:25.580]    - args: function (..., envir = parent.frame())
[13:36:25.580]    - tweaked: FALSE
[13:36:25.580]    - call: NULL
[13:36:25.580] plan(): nbrOfWorkers() = 1
[13:36:25.581] plan(): Setting new future strategy stack:
[13:36:25.581] List of future strategies:
[13:36:25.581] 1. sequential:
[13:36:25.581]    - args: function (..., envir = parent.frame())
[13:36:25.581]    - tweaked: FALSE
[13:36:25.581]    - call: plan(strategy)
[13:36:25.581] plan(): nbrOfWorkers() = 1
[13:36:25.581] SequentialFuture started (and completed)
[13:36:25.581] - Launch lazy future ... done
[13:36:25.581] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[13:36:25.582] getGlobalsAndPackages() ...
[13:36:25.582] Searching for globals...
[13:36:25.585] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:36:25.585] Searching for globals ... DONE
[13:36:25.585] Resolving globals: FALSE
[13:36:25.586] 
[13:36:25.586] 
[13:36:25.586] getGlobalsAndPackages() ... DONE
[13:36:25.586] run() for ‘Future’ ...
[13:36:25.586] - state: ‘created’
[13:36:25.586] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.586] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.587]   - Field: ‘label’
[13:36:25.587]   - Field: ‘local’
[13:36:25.587]   - Field: ‘owner’
[13:36:25.587]   - Field: ‘envir’
[13:36:25.587]   - Field: ‘packages’
[13:36:25.587]   - Field: ‘gc’
[13:36:25.587]   - Field: ‘conditions’
[13:36:25.587]   - Field: ‘expr’
[13:36:25.587]   - Field: ‘uuid’
[13:36:25.587]   - Field: ‘seed’
[13:36:25.588]   - Field: ‘version’
[13:36:25.588]   - Field: ‘result’
[13:36:25.588]   - Field: ‘asynchronous’
[13:36:25.588]   - Field: ‘calls’
[13:36:25.588]   - Field: ‘globals’
[13:36:25.588]   - Field: ‘stdout’
[13:36:25.588]   - Field: ‘earlySignal’
[13:36:25.588]   - Field: ‘lazy’
[13:36:25.588]   - Field: ‘state’
[13:36:25.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.588] - Launch lazy future ...
[13:36:25.589] Packages needed by the future expression (n = 0): <none>
[13:36:25.589] Packages needed by future strategies (n = 0): <none>
[13:36:25.589] {
[13:36:25.589]     {
[13:36:25.589]         {
[13:36:25.589]             ...future.startTime <- base::Sys.time()
[13:36:25.589]             {
[13:36:25.589]                 {
[13:36:25.589]                   {
[13:36:25.589]                     base::local({
[13:36:25.589]                       has_future <- base::requireNamespace("future", 
[13:36:25.589]                         quietly = TRUE)
[13:36:25.589]                       if (has_future) {
[13:36:25.589]                         ns <- base::getNamespace("future")
[13:36:25.589]                         version <- ns[[".package"]][["version"]]
[13:36:25.589]                         if (is.null(version)) 
[13:36:25.589]                           version <- utils::packageVersion("future")
[13:36:25.589]                       }
[13:36:25.589]                       else {
[13:36:25.589]                         version <- NULL
[13:36:25.589]                       }
[13:36:25.589]                       if (!has_future || version < "1.8.0") {
[13:36:25.589]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.589]                           "", base::R.version$version.string), 
[13:36:25.589]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.589]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.589]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.589]                             "release", "version")], collapse = " "), 
[13:36:25.589]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.589]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.589]                           info)
[13:36:25.589]                         info <- base::paste(info, collapse = "; ")
[13:36:25.589]                         if (!has_future) {
[13:36:25.589]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.589]                             info)
[13:36:25.589]                         }
[13:36:25.589]                         else {
[13:36:25.589]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.589]                             info, version)
[13:36:25.589]                         }
[13:36:25.589]                         base::stop(msg)
[13:36:25.589]                       }
[13:36:25.589]                     })
[13:36:25.589]                   }
[13:36:25.589]                   ...future.strategy.old <- future::plan("list")
[13:36:25.589]                   options(future.plan = NULL)
[13:36:25.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.589]                 }
[13:36:25.589]                 ...future.workdir <- getwd()
[13:36:25.589]             }
[13:36:25.589]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.589]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.589]         }
[13:36:25.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.589]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.589]             base::names(...future.oldOptions))
[13:36:25.589]     }
[13:36:25.589]     if (FALSE) {
[13:36:25.589]     }
[13:36:25.589]     else {
[13:36:25.589]         if (TRUE) {
[13:36:25.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.589]                 open = "w")
[13:36:25.589]         }
[13:36:25.589]         else {
[13:36:25.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.589]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.589]         }
[13:36:25.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.589]             base::sink(type = "output", split = FALSE)
[13:36:25.589]             base::close(...future.stdout)
[13:36:25.589]         }, add = TRUE)
[13:36:25.589]     }
[13:36:25.589]     ...future.frame <- base::sys.nframe()
[13:36:25.589]     ...future.conditions <- base::list()
[13:36:25.589]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.589]     if (FALSE) {
[13:36:25.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.589]     }
[13:36:25.589]     ...future.result <- base::tryCatch({
[13:36:25.589]         base::withCallingHandlers({
[13:36:25.589]             ...future.value <- base::withVisible(base::local({
[13:36:25.589]                 x <- 3
[13:36:25.589]                 stop("Woops!")
[13:36:25.589]                 x
[13:36:25.589]             }))
[13:36:25.589]             future::FutureResult(value = ...future.value$value, 
[13:36:25.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.589]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.589]                     ...future.globalenv.names))
[13:36:25.589]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.589]         }, condition = base::local({
[13:36:25.589]             c <- base::c
[13:36:25.589]             inherits <- base::inherits
[13:36:25.589]             invokeRestart <- base::invokeRestart
[13:36:25.589]             length <- base::length
[13:36:25.589]             list <- base::list
[13:36:25.589]             seq.int <- base::seq.int
[13:36:25.589]             signalCondition <- base::signalCondition
[13:36:25.589]             sys.calls <- base::sys.calls
[13:36:25.589]             `[[` <- base::`[[`
[13:36:25.589]             `+` <- base::`+`
[13:36:25.589]             `<<-` <- base::`<<-`
[13:36:25.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.589]                   3L)]
[13:36:25.589]             }
[13:36:25.589]             function(cond) {
[13:36:25.589]                 is_error <- inherits(cond, "error")
[13:36:25.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.589]                   NULL)
[13:36:25.589]                 if (is_error) {
[13:36:25.589]                   sessionInformation <- function() {
[13:36:25.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.589]                       search = base::search(), system = base::Sys.info())
[13:36:25.589]                   }
[13:36:25.589]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.589]                     cond$call), session = sessionInformation(), 
[13:36:25.589]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.589]                   signalCondition(cond)
[13:36:25.589]                 }
[13:36:25.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.589]                 "immediateCondition"))) {
[13:36:25.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.589]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.589]                   if (TRUE && !signal) {
[13:36:25.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.589]                     {
[13:36:25.589]                       inherits <- base::inherits
[13:36:25.589]                       invokeRestart <- base::invokeRestart
[13:36:25.589]                       is.null <- base::is.null
[13:36:25.589]                       muffled <- FALSE
[13:36:25.589]                       if (inherits(cond, "message")) {
[13:36:25.589]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.589]                         if (muffled) 
[13:36:25.589]                           invokeRestart("muffleMessage")
[13:36:25.589]                       }
[13:36:25.589]                       else if (inherits(cond, "warning")) {
[13:36:25.589]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.589]                         if (muffled) 
[13:36:25.589]                           invokeRestart("muffleWarning")
[13:36:25.589]                       }
[13:36:25.589]                       else if (inherits(cond, "condition")) {
[13:36:25.589]                         if (!is.null(pattern)) {
[13:36:25.589]                           computeRestarts <- base::computeRestarts
[13:36:25.589]                           grepl <- base::grepl
[13:36:25.589]                           restarts <- computeRestarts(cond)
[13:36:25.589]                           for (restart in restarts) {
[13:36:25.589]                             name <- restart$name
[13:36:25.589]                             if (is.null(name)) 
[13:36:25.589]                               next
[13:36:25.589]                             if (!grepl(pattern, name)) 
[13:36:25.589]                               next
[13:36:25.589]                             invokeRestart(restart)
[13:36:25.589]                             muffled <- TRUE
[13:36:25.589]                             break
[13:36:25.589]                           }
[13:36:25.589]                         }
[13:36:25.589]                       }
[13:36:25.589]                       invisible(muffled)
[13:36:25.589]                     }
[13:36:25.589]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.589]                   }
[13:36:25.589]                 }
[13:36:25.589]                 else {
[13:36:25.589]                   if (TRUE) {
[13:36:25.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.589]                     {
[13:36:25.589]                       inherits <- base::inherits
[13:36:25.589]                       invokeRestart <- base::invokeRestart
[13:36:25.589]                       is.null <- base::is.null
[13:36:25.589]                       muffled <- FALSE
[13:36:25.589]                       if (inherits(cond, "message")) {
[13:36:25.589]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.589]                         if (muffled) 
[13:36:25.589]                           invokeRestart("muffleMessage")
[13:36:25.589]                       }
[13:36:25.589]                       else if (inherits(cond, "warning")) {
[13:36:25.589]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.589]                         if (muffled) 
[13:36:25.589]                           invokeRestart("muffleWarning")
[13:36:25.589]                       }
[13:36:25.589]                       else if (inherits(cond, "condition")) {
[13:36:25.589]                         if (!is.null(pattern)) {
[13:36:25.589]                           computeRestarts <- base::computeRestarts
[13:36:25.589]                           grepl <- base::grepl
[13:36:25.589]                           restarts <- computeRestarts(cond)
[13:36:25.589]                           for (restart in restarts) {
[13:36:25.589]                             name <- restart$name
[13:36:25.589]                             if (is.null(name)) 
[13:36:25.589]                               next
[13:36:25.589]                             if (!grepl(pattern, name)) 
[13:36:25.589]                               next
[13:36:25.589]                             invokeRestart(restart)
[13:36:25.589]                             muffled <- TRUE
[13:36:25.589]                             break
[13:36:25.589]                           }
[13:36:25.589]                         }
[13:36:25.589]                       }
[13:36:25.589]                       invisible(muffled)
[13:36:25.589]                     }
[13:36:25.589]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.589]                   }
[13:36:25.589]                 }
[13:36:25.589]             }
[13:36:25.589]         }))
[13:36:25.589]     }, error = function(ex) {
[13:36:25.589]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.589]                 ...future.rng), started = ...future.startTime, 
[13:36:25.589]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.589]             version = "1.8"), class = "FutureResult")
[13:36:25.589]     }, finally = {
[13:36:25.589]         if (!identical(...future.workdir, getwd())) 
[13:36:25.589]             setwd(...future.workdir)
[13:36:25.589]         {
[13:36:25.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.589]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.589]             }
[13:36:25.589]             base::options(...future.oldOptions)
[13:36:25.589]             if (.Platform$OS.type == "windows") {
[13:36:25.589]                 old_names <- names(...future.oldEnvVars)
[13:36:25.589]                 envs <- base::Sys.getenv()
[13:36:25.589]                 names <- names(envs)
[13:36:25.589]                 common <- intersect(names, old_names)
[13:36:25.589]                 added <- setdiff(names, old_names)
[13:36:25.589]                 removed <- setdiff(old_names, names)
[13:36:25.589]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.589]                   envs[common]]
[13:36:25.589]                 NAMES <- toupper(changed)
[13:36:25.589]                 args <- list()
[13:36:25.589]                 for (kk in seq_along(NAMES)) {
[13:36:25.589]                   name <- changed[[kk]]
[13:36:25.589]                   NAME <- NAMES[[kk]]
[13:36:25.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.589]                     next
[13:36:25.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.589]                 }
[13:36:25.589]                 NAMES <- toupper(added)
[13:36:25.589]                 for (kk in seq_along(NAMES)) {
[13:36:25.589]                   name <- added[[kk]]
[13:36:25.589]                   NAME <- NAMES[[kk]]
[13:36:25.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.589]                     next
[13:36:25.589]                   args[[name]] <- ""
[13:36:25.589]                 }
[13:36:25.589]                 NAMES <- toupper(removed)
[13:36:25.589]                 for (kk in seq_along(NAMES)) {
[13:36:25.589]                   name <- removed[[kk]]
[13:36:25.589]                   NAME <- NAMES[[kk]]
[13:36:25.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.589]                     next
[13:36:25.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.589]                 }
[13:36:25.589]                 if (length(args) > 0) 
[13:36:25.589]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.589]             }
[13:36:25.589]             else {
[13:36:25.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.589]             }
[13:36:25.589]             {
[13:36:25.589]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.589]                   0L) {
[13:36:25.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.589]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.589]                   base::options(opts)
[13:36:25.589]                 }
[13:36:25.589]                 {
[13:36:25.589]                   {
[13:36:25.589]                     NULL
[13:36:25.589]                     RNGkind("Mersenne-Twister")
[13:36:25.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.589]                       inherits = FALSE)
[13:36:25.589]                   }
[13:36:25.589]                   options(future.plan = NULL)
[13:36:25.589]                   if (is.na(NA_character_)) 
[13:36:25.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.589]                     .init = FALSE)
[13:36:25.589]                 }
[13:36:25.589]             }
[13:36:25.589]         }
[13:36:25.589]     })
[13:36:25.589]     if (TRUE) {
[13:36:25.589]         base::sink(type = "output", split = FALSE)
[13:36:25.589]         if (TRUE) {
[13:36:25.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.589]         }
[13:36:25.589]         else {
[13:36:25.589]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.589]         }
[13:36:25.589]         base::close(...future.stdout)
[13:36:25.589]         ...future.stdout <- NULL
[13:36:25.589]     }
[13:36:25.589]     ...future.result$conditions <- ...future.conditions
[13:36:25.589]     ...future.result$finished <- base::Sys.time()
[13:36:25.589]     ...future.result
[13:36:25.589] }
[13:36:25.591] plan(): Setting new future strategy stack:
[13:36:25.591] List of future strategies:
[13:36:25.591] 1. sequential:
[13:36:25.591]    - args: function (..., envir = parent.frame())
[13:36:25.591]    - tweaked: FALSE
[13:36:25.591]    - call: NULL
[13:36:25.591] plan(): nbrOfWorkers() = 1
[13:36:25.592] plan(): Setting new future strategy stack:
[13:36:25.592] List of future strategies:
[13:36:25.592] 1. sequential:
[13:36:25.592]    - args: function (..., envir = parent.frame())
[13:36:25.592]    - tweaked: FALSE
[13:36:25.592]    - call: plan(strategy)
[13:36:25.593] plan(): nbrOfWorkers() = 1
[13:36:25.593] SequentialFuture started (and completed)
[13:36:25.593] signalConditions() ...
[13:36:25.593]  - include = ‘immediateCondition’
[13:36:25.593]  - exclude = 
[13:36:25.593]  - resignal = FALSE
[13:36:25.593]  - Number of conditions: 1
[13:36:25.593] signalConditions() ... done
[13:36:25.593] - Launch lazy future ... done
[13:36:25.593] run() for ‘SequentialFuture’ ... done
[13:36:25.594] signalConditions() ...
[13:36:25.594]  - include = ‘immediateCondition’
[13:36:25.594]  - exclude = 
[13:36:25.594]  - resignal = FALSE
[13:36:25.594]  - Number of conditions: 1
[13:36:25.594] signalConditions() ... done
[13:36:25.594] Future state: ‘finished’
[13:36:25.594] signalConditions() ...
[13:36:25.594]  - include = ‘condition’
[13:36:25.594]  - exclude = ‘immediateCondition’
[13:36:25.595]  - resignal = TRUE
[13:36:25.595]  - Number of conditions: 1
[13:36:25.595]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.595] signalConditions() ... done
[13:36:25.596] getGlobalsAndPackages() ...
[13:36:25.596] Searching for globals...
[13:36:25.597] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:25.598] Searching for globals ... DONE
[13:36:25.598] Resolving globals: FALSE
[13:36:25.598] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.598] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:25.599] - globals: [1] ‘ii’
[13:36:25.599] 
[13:36:25.599] getGlobalsAndPackages() ... DONE
[13:36:25.599] run() for ‘Future’ ...
[13:36:25.599] - state: ‘created’
[13:36:25.599] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.599] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.600]   - Field: ‘label’
[13:36:25.600]   - Field: ‘local’
[13:36:25.600]   - Field: ‘owner’
[13:36:25.600]   - Field: ‘envir’
[13:36:25.600]   - Field: ‘packages’
[13:36:25.600]   - Field: ‘gc’
[13:36:25.600]   - Field: ‘conditions’
[13:36:25.600]   - Field: ‘expr’
[13:36:25.600]   - Field: ‘uuid’
[13:36:25.600]   - Field: ‘seed’
[13:36:25.600]   - Field: ‘version’
[13:36:25.601]   - Field: ‘result’
[13:36:25.601]   - Field: ‘asynchronous’
[13:36:25.601]   - Field: ‘calls’
[13:36:25.601]   - Field: ‘globals’
[13:36:25.601]   - Field: ‘stdout’
[13:36:25.601]   - Field: ‘earlySignal’
[13:36:25.601]   - Field: ‘lazy’
[13:36:25.601]   - Field: ‘state’
[13:36:25.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.601] - Launch lazy future ...
[13:36:25.602] Packages needed by the future expression (n = 0): <none>
[13:36:25.602] Packages needed by future strategies (n = 0): <none>
[13:36:25.602] {
[13:36:25.602]     {
[13:36:25.602]         {
[13:36:25.602]             ...future.startTime <- base::Sys.time()
[13:36:25.602]             {
[13:36:25.602]                 {
[13:36:25.602]                   {
[13:36:25.602]                     base::local({
[13:36:25.602]                       has_future <- base::requireNamespace("future", 
[13:36:25.602]                         quietly = TRUE)
[13:36:25.602]                       if (has_future) {
[13:36:25.602]                         ns <- base::getNamespace("future")
[13:36:25.602]                         version <- ns[[".package"]][["version"]]
[13:36:25.602]                         if (is.null(version)) 
[13:36:25.602]                           version <- utils::packageVersion("future")
[13:36:25.602]                       }
[13:36:25.602]                       else {
[13:36:25.602]                         version <- NULL
[13:36:25.602]                       }
[13:36:25.602]                       if (!has_future || version < "1.8.0") {
[13:36:25.602]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.602]                           "", base::R.version$version.string), 
[13:36:25.602]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.602]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.602]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.602]                             "release", "version")], collapse = " "), 
[13:36:25.602]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.602]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.602]                           info)
[13:36:25.602]                         info <- base::paste(info, collapse = "; ")
[13:36:25.602]                         if (!has_future) {
[13:36:25.602]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.602]                             info)
[13:36:25.602]                         }
[13:36:25.602]                         else {
[13:36:25.602]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.602]                             info, version)
[13:36:25.602]                         }
[13:36:25.602]                         base::stop(msg)
[13:36:25.602]                       }
[13:36:25.602]                     })
[13:36:25.602]                   }
[13:36:25.602]                   ...future.strategy.old <- future::plan("list")
[13:36:25.602]                   options(future.plan = NULL)
[13:36:25.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.602]                 }
[13:36:25.602]                 ...future.workdir <- getwd()
[13:36:25.602]             }
[13:36:25.602]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.602]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.602]         }
[13:36:25.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.602]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.602]             base::names(...future.oldOptions))
[13:36:25.602]     }
[13:36:25.602]     if (FALSE) {
[13:36:25.602]     }
[13:36:25.602]     else {
[13:36:25.602]         if (TRUE) {
[13:36:25.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.602]                 open = "w")
[13:36:25.602]         }
[13:36:25.602]         else {
[13:36:25.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.602]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.602]         }
[13:36:25.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.602]             base::sink(type = "output", split = FALSE)
[13:36:25.602]             base::close(...future.stdout)
[13:36:25.602]         }, add = TRUE)
[13:36:25.602]     }
[13:36:25.602]     ...future.frame <- base::sys.nframe()
[13:36:25.602]     ...future.conditions <- base::list()
[13:36:25.602]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.602]     if (FALSE) {
[13:36:25.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.602]     }
[13:36:25.602]     ...future.result <- base::tryCatch({
[13:36:25.602]         base::withCallingHandlers({
[13:36:25.602]             ...future.value <- base::withVisible(base::local({
[13:36:25.602]                 if (ii%%2 == 0) 
[13:36:25.602]                   stop("Woops!")
[13:36:25.602]                 ii
[13:36:25.602]             }))
[13:36:25.602]             future::FutureResult(value = ...future.value$value, 
[13:36:25.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.602]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.602]                     ...future.globalenv.names))
[13:36:25.602]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.602]         }, condition = base::local({
[13:36:25.602]             c <- base::c
[13:36:25.602]             inherits <- base::inherits
[13:36:25.602]             invokeRestart <- base::invokeRestart
[13:36:25.602]             length <- base::length
[13:36:25.602]             list <- base::list
[13:36:25.602]             seq.int <- base::seq.int
[13:36:25.602]             signalCondition <- base::signalCondition
[13:36:25.602]             sys.calls <- base::sys.calls
[13:36:25.602]             `[[` <- base::`[[`
[13:36:25.602]             `+` <- base::`+`
[13:36:25.602]             `<<-` <- base::`<<-`
[13:36:25.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.602]                   3L)]
[13:36:25.602]             }
[13:36:25.602]             function(cond) {
[13:36:25.602]                 is_error <- inherits(cond, "error")
[13:36:25.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.602]                   NULL)
[13:36:25.602]                 if (is_error) {
[13:36:25.602]                   sessionInformation <- function() {
[13:36:25.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.602]                       search = base::search(), system = base::Sys.info())
[13:36:25.602]                   }
[13:36:25.602]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.602]                     cond$call), session = sessionInformation(), 
[13:36:25.602]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.602]                   signalCondition(cond)
[13:36:25.602]                 }
[13:36:25.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.602]                 "immediateCondition"))) {
[13:36:25.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.602]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.602]                   if (TRUE && !signal) {
[13:36:25.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.602]                     {
[13:36:25.602]                       inherits <- base::inherits
[13:36:25.602]                       invokeRestart <- base::invokeRestart
[13:36:25.602]                       is.null <- base::is.null
[13:36:25.602]                       muffled <- FALSE
[13:36:25.602]                       if (inherits(cond, "message")) {
[13:36:25.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.602]                         if (muffled) 
[13:36:25.602]                           invokeRestart("muffleMessage")
[13:36:25.602]                       }
[13:36:25.602]                       else if (inherits(cond, "warning")) {
[13:36:25.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.602]                         if (muffled) 
[13:36:25.602]                           invokeRestart("muffleWarning")
[13:36:25.602]                       }
[13:36:25.602]                       else if (inherits(cond, "condition")) {
[13:36:25.602]                         if (!is.null(pattern)) {
[13:36:25.602]                           computeRestarts <- base::computeRestarts
[13:36:25.602]                           grepl <- base::grepl
[13:36:25.602]                           restarts <- computeRestarts(cond)
[13:36:25.602]                           for (restart in restarts) {
[13:36:25.602]                             name <- restart$name
[13:36:25.602]                             if (is.null(name)) 
[13:36:25.602]                               next
[13:36:25.602]                             if (!grepl(pattern, name)) 
[13:36:25.602]                               next
[13:36:25.602]                             invokeRestart(restart)
[13:36:25.602]                             muffled <- TRUE
[13:36:25.602]                             break
[13:36:25.602]                           }
[13:36:25.602]                         }
[13:36:25.602]                       }
[13:36:25.602]                       invisible(muffled)
[13:36:25.602]                     }
[13:36:25.602]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.602]                   }
[13:36:25.602]                 }
[13:36:25.602]                 else {
[13:36:25.602]                   if (TRUE) {
[13:36:25.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.602]                     {
[13:36:25.602]                       inherits <- base::inherits
[13:36:25.602]                       invokeRestart <- base::invokeRestart
[13:36:25.602]                       is.null <- base::is.null
[13:36:25.602]                       muffled <- FALSE
[13:36:25.602]                       if (inherits(cond, "message")) {
[13:36:25.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.602]                         if (muffled) 
[13:36:25.602]                           invokeRestart("muffleMessage")
[13:36:25.602]                       }
[13:36:25.602]                       else if (inherits(cond, "warning")) {
[13:36:25.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.602]                         if (muffled) 
[13:36:25.602]                           invokeRestart("muffleWarning")
[13:36:25.602]                       }
[13:36:25.602]                       else if (inherits(cond, "condition")) {
[13:36:25.602]                         if (!is.null(pattern)) {
[13:36:25.602]                           computeRestarts <- base::computeRestarts
[13:36:25.602]                           grepl <- base::grepl
[13:36:25.602]                           restarts <- computeRestarts(cond)
[13:36:25.602]                           for (restart in restarts) {
[13:36:25.602]                             name <- restart$name
[13:36:25.602]                             if (is.null(name)) 
[13:36:25.602]                               next
[13:36:25.602]                             if (!grepl(pattern, name)) 
[13:36:25.602]                               next
[13:36:25.602]                             invokeRestart(restart)
[13:36:25.602]                             muffled <- TRUE
[13:36:25.602]                             break
[13:36:25.602]                           }
[13:36:25.602]                         }
[13:36:25.602]                       }
[13:36:25.602]                       invisible(muffled)
[13:36:25.602]                     }
[13:36:25.602]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.602]                   }
[13:36:25.602]                 }
[13:36:25.602]             }
[13:36:25.602]         }))
[13:36:25.602]     }, error = function(ex) {
[13:36:25.602]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.602]                 ...future.rng), started = ...future.startTime, 
[13:36:25.602]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.602]             version = "1.8"), class = "FutureResult")
[13:36:25.602]     }, finally = {
[13:36:25.602]         if (!identical(...future.workdir, getwd())) 
[13:36:25.602]             setwd(...future.workdir)
[13:36:25.602]         {
[13:36:25.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.602]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.602]             }
[13:36:25.602]             base::options(...future.oldOptions)
[13:36:25.602]             if (.Platform$OS.type == "windows") {
[13:36:25.602]                 old_names <- names(...future.oldEnvVars)
[13:36:25.602]                 envs <- base::Sys.getenv()
[13:36:25.602]                 names <- names(envs)
[13:36:25.602]                 common <- intersect(names, old_names)
[13:36:25.602]                 added <- setdiff(names, old_names)
[13:36:25.602]                 removed <- setdiff(old_names, names)
[13:36:25.602]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.602]                   envs[common]]
[13:36:25.602]                 NAMES <- toupper(changed)
[13:36:25.602]                 args <- list()
[13:36:25.602]                 for (kk in seq_along(NAMES)) {
[13:36:25.602]                   name <- changed[[kk]]
[13:36:25.602]                   NAME <- NAMES[[kk]]
[13:36:25.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.602]                     next
[13:36:25.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.602]                 }
[13:36:25.602]                 NAMES <- toupper(added)
[13:36:25.602]                 for (kk in seq_along(NAMES)) {
[13:36:25.602]                   name <- added[[kk]]
[13:36:25.602]                   NAME <- NAMES[[kk]]
[13:36:25.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.602]                     next
[13:36:25.602]                   args[[name]] <- ""
[13:36:25.602]                 }
[13:36:25.602]                 NAMES <- toupper(removed)
[13:36:25.602]                 for (kk in seq_along(NAMES)) {
[13:36:25.602]                   name <- removed[[kk]]
[13:36:25.602]                   NAME <- NAMES[[kk]]
[13:36:25.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.602]                     next
[13:36:25.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.602]                 }
[13:36:25.602]                 if (length(args) > 0) 
[13:36:25.602]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.602]             }
[13:36:25.602]             else {
[13:36:25.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.602]             }
[13:36:25.602]             {
[13:36:25.602]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.602]                   0L) {
[13:36:25.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.602]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.602]                   base::options(opts)
[13:36:25.602]                 }
[13:36:25.602]                 {
[13:36:25.602]                   {
[13:36:25.602]                     NULL
[13:36:25.602]                     RNGkind("Mersenne-Twister")
[13:36:25.602]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.602]                       inherits = FALSE)
[13:36:25.602]                   }
[13:36:25.602]                   options(future.plan = NULL)
[13:36:25.602]                   if (is.na(NA_character_)) 
[13:36:25.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.602]                     .init = FALSE)
[13:36:25.602]                 }
[13:36:25.602]             }
[13:36:25.602]         }
[13:36:25.602]     })
[13:36:25.602]     if (TRUE) {
[13:36:25.602]         base::sink(type = "output", split = FALSE)
[13:36:25.602]         if (TRUE) {
[13:36:25.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.602]         }
[13:36:25.602]         else {
[13:36:25.602]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.602]         }
[13:36:25.602]         base::close(...future.stdout)
[13:36:25.602]         ...future.stdout <- NULL
[13:36:25.602]     }
[13:36:25.602]     ...future.result$conditions <- ...future.conditions
[13:36:25.602]     ...future.result$finished <- base::Sys.time()
[13:36:25.602]     ...future.result
[13:36:25.602] }
[13:36:25.604] assign_globals() ...
[13:36:25.604] List of 1
[13:36:25.604]  $ ii: int 1
[13:36:25.604]  - attr(*, "where")=List of 1
[13:36:25.604]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:25.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.604]  - attr(*, "resolved")= logi FALSE
[13:36:25.604]  - attr(*, "total_size")= num 56
[13:36:25.604]  - attr(*, "already-done")= logi TRUE
[13:36:25.607] - copied ‘ii’ to environment
[13:36:25.608] assign_globals() ... done
[13:36:25.608] plan(): Setting new future strategy stack:
[13:36:25.608] List of future strategies:
[13:36:25.608] 1. sequential:
[13:36:25.608]    - args: function (..., envir = parent.frame())
[13:36:25.608]    - tweaked: FALSE
[13:36:25.608]    - call: NULL
[13:36:25.608] plan(): nbrOfWorkers() = 1
[13:36:25.609] plan(): Setting new future strategy stack:
[13:36:25.609] List of future strategies:
[13:36:25.609] 1. sequential:
[13:36:25.609]    - args: function (..., envir = parent.frame())
[13:36:25.609]    - tweaked: FALSE
[13:36:25.609]    - call: plan(strategy)
[13:36:25.609] plan(): nbrOfWorkers() = 1
[13:36:25.610] SequentialFuture started (and completed)
[13:36:25.610] - Launch lazy future ... done
[13:36:25.610] run() for ‘SequentialFuture’ ... done
[13:36:25.610] getGlobalsAndPackages() ...
[13:36:25.610] Searching for globals...
[13:36:25.612] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:25.612] Searching for globals ... DONE
[13:36:25.612] Resolving globals: FALSE
[13:36:25.612] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.613] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:25.613] - globals: [1] ‘ii’
[13:36:25.613] 
[13:36:25.613] getGlobalsAndPackages() ... DONE
[13:36:25.613] run() for ‘Future’ ...
[13:36:25.613] - state: ‘created’
[13:36:25.613] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.614] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.614] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.614]   - Field: ‘label’
[13:36:25.614]   - Field: ‘local’
[13:36:25.614]   - Field: ‘owner’
[13:36:25.614]   - Field: ‘envir’
[13:36:25.614]   - Field: ‘packages’
[13:36:25.614]   - Field: ‘gc’
[13:36:25.614]   - Field: ‘conditions’
[13:36:25.614]   - Field: ‘expr’
[13:36:25.615]   - Field: ‘uuid’
[13:36:25.615]   - Field: ‘seed’
[13:36:25.615]   - Field: ‘version’
[13:36:25.615]   - Field: ‘result’
[13:36:25.615]   - Field: ‘asynchronous’
[13:36:25.615]   - Field: ‘calls’
[13:36:25.615]   - Field: ‘globals’
[13:36:25.615]   - Field: ‘stdout’
[13:36:25.615]   - Field: ‘earlySignal’
[13:36:25.615]   - Field: ‘lazy’
[13:36:25.615]   - Field: ‘state’
[13:36:25.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.616] - Launch lazy future ...
[13:36:25.616] Packages needed by the future expression (n = 0): <none>
[13:36:25.616] Packages needed by future strategies (n = 0): <none>
[13:36:25.616] {
[13:36:25.616]     {
[13:36:25.616]         {
[13:36:25.616]             ...future.startTime <- base::Sys.time()
[13:36:25.616]             {
[13:36:25.616]                 {
[13:36:25.616]                   {
[13:36:25.616]                     base::local({
[13:36:25.616]                       has_future <- base::requireNamespace("future", 
[13:36:25.616]                         quietly = TRUE)
[13:36:25.616]                       if (has_future) {
[13:36:25.616]                         ns <- base::getNamespace("future")
[13:36:25.616]                         version <- ns[[".package"]][["version"]]
[13:36:25.616]                         if (is.null(version)) 
[13:36:25.616]                           version <- utils::packageVersion("future")
[13:36:25.616]                       }
[13:36:25.616]                       else {
[13:36:25.616]                         version <- NULL
[13:36:25.616]                       }
[13:36:25.616]                       if (!has_future || version < "1.8.0") {
[13:36:25.616]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.616]                           "", base::R.version$version.string), 
[13:36:25.616]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.616]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.616]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.616]                             "release", "version")], collapse = " "), 
[13:36:25.616]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.616]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.616]                           info)
[13:36:25.616]                         info <- base::paste(info, collapse = "; ")
[13:36:25.616]                         if (!has_future) {
[13:36:25.616]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.616]                             info)
[13:36:25.616]                         }
[13:36:25.616]                         else {
[13:36:25.616]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.616]                             info, version)
[13:36:25.616]                         }
[13:36:25.616]                         base::stop(msg)
[13:36:25.616]                       }
[13:36:25.616]                     })
[13:36:25.616]                   }
[13:36:25.616]                   ...future.strategy.old <- future::plan("list")
[13:36:25.616]                   options(future.plan = NULL)
[13:36:25.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.616]                 }
[13:36:25.616]                 ...future.workdir <- getwd()
[13:36:25.616]             }
[13:36:25.616]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.616]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.616]         }
[13:36:25.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.616]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.616]             base::names(...future.oldOptions))
[13:36:25.616]     }
[13:36:25.616]     if (FALSE) {
[13:36:25.616]     }
[13:36:25.616]     else {
[13:36:25.616]         if (TRUE) {
[13:36:25.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.616]                 open = "w")
[13:36:25.616]         }
[13:36:25.616]         else {
[13:36:25.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.616]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.616]         }
[13:36:25.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.616]             base::sink(type = "output", split = FALSE)
[13:36:25.616]             base::close(...future.stdout)
[13:36:25.616]         }, add = TRUE)
[13:36:25.616]     }
[13:36:25.616]     ...future.frame <- base::sys.nframe()
[13:36:25.616]     ...future.conditions <- base::list()
[13:36:25.616]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.616]     if (FALSE) {
[13:36:25.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.616]     }
[13:36:25.616]     ...future.result <- base::tryCatch({
[13:36:25.616]         base::withCallingHandlers({
[13:36:25.616]             ...future.value <- base::withVisible(base::local({
[13:36:25.616]                 if (ii%%2 == 0) 
[13:36:25.616]                   stop("Woops!")
[13:36:25.616]                 ii
[13:36:25.616]             }))
[13:36:25.616]             future::FutureResult(value = ...future.value$value, 
[13:36:25.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.616]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.616]                     ...future.globalenv.names))
[13:36:25.616]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.616]         }, condition = base::local({
[13:36:25.616]             c <- base::c
[13:36:25.616]             inherits <- base::inherits
[13:36:25.616]             invokeRestart <- base::invokeRestart
[13:36:25.616]             length <- base::length
[13:36:25.616]             list <- base::list
[13:36:25.616]             seq.int <- base::seq.int
[13:36:25.616]             signalCondition <- base::signalCondition
[13:36:25.616]             sys.calls <- base::sys.calls
[13:36:25.616]             `[[` <- base::`[[`
[13:36:25.616]             `+` <- base::`+`
[13:36:25.616]             `<<-` <- base::`<<-`
[13:36:25.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.616]                   3L)]
[13:36:25.616]             }
[13:36:25.616]             function(cond) {
[13:36:25.616]                 is_error <- inherits(cond, "error")
[13:36:25.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.616]                   NULL)
[13:36:25.616]                 if (is_error) {
[13:36:25.616]                   sessionInformation <- function() {
[13:36:25.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.616]                       search = base::search(), system = base::Sys.info())
[13:36:25.616]                   }
[13:36:25.616]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.616]                     cond$call), session = sessionInformation(), 
[13:36:25.616]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.616]                   signalCondition(cond)
[13:36:25.616]                 }
[13:36:25.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.616]                 "immediateCondition"))) {
[13:36:25.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.616]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.616]                   if (TRUE && !signal) {
[13:36:25.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.616]                     {
[13:36:25.616]                       inherits <- base::inherits
[13:36:25.616]                       invokeRestart <- base::invokeRestart
[13:36:25.616]                       is.null <- base::is.null
[13:36:25.616]                       muffled <- FALSE
[13:36:25.616]                       if (inherits(cond, "message")) {
[13:36:25.616]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.616]                         if (muffled) 
[13:36:25.616]                           invokeRestart("muffleMessage")
[13:36:25.616]                       }
[13:36:25.616]                       else if (inherits(cond, "warning")) {
[13:36:25.616]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.616]                         if (muffled) 
[13:36:25.616]                           invokeRestart("muffleWarning")
[13:36:25.616]                       }
[13:36:25.616]                       else if (inherits(cond, "condition")) {
[13:36:25.616]                         if (!is.null(pattern)) {
[13:36:25.616]                           computeRestarts <- base::computeRestarts
[13:36:25.616]                           grepl <- base::grepl
[13:36:25.616]                           restarts <- computeRestarts(cond)
[13:36:25.616]                           for (restart in restarts) {
[13:36:25.616]                             name <- restart$name
[13:36:25.616]                             if (is.null(name)) 
[13:36:25.616]                               next
[13:36:25.616]                             if (!grepl(pattern, name)) 
[13:36:25.616]                               next
[13:36:25.616]                             invokeRestart(restart)
[13:36:25.616]                             muffled <- TRUE
[13:36:25.616]                             break
[13:36:25.616]                           }
[13:36:25.616]                         }
[13:36:25.616]                       }
[13:36:25.616]                       invisible(muffled)
[13:36:25.616]                     }
[13:36:25.616]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.616]                   }
[13:36:25.616]                 }
[13:36:25.616]                 else {
[13:36:25.616]                   if (TRUE) {
[13:36:25.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.616]                     {
[13:36:25.616]                       inherits <- base::inherits
[13:36:25.616]                       invokeRestart <- base::invokeRestart
[13:36:25.616]                       is.null <- base::is.null
[13:36:25.616]                       muffled <- FALSE
[13:36:25.616]                       if (inherits(cond, "message")) {
[13:36:25.616]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.616]                         if (muffled) 
[13:36:25.616]                           invokeRestart("muffleMessage")
[13:36:25.616]                       }
[13:36:25.616]                       else if (inherits(cond, "warning")) {
[13:36:25.616]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.616]                         if (muffled) 
[13:36:25.616]                           invokeRestart("muffleWarning")
[13:36:25.616]                       }
[13:36:25.616]                       else if (inherits(cond, "condition")) {
[13:36:25.616]                         if (!is.null(pattern)) {
[13:36:25.616]                           computeRestarts <- base::computeRestarts
[13:36:25.616]                           grepl <- base::grepl
[13:36:25.616]                           restarts <- computeRestarts(cond)
[13:36:25.616]                           for (restart in restarts) {
[13:36:25.616]                             name <- restart$name
[13:36:25.616]                             if (is.null(name)) 
[13:36:25.616]                               next
[13:36:25.616]                             if (!grepl(pattern, name)) 
[13:36:25.616]                               next
[13:36:25.616]                             invokeRestart(restart)
[13:36:25.616]                             muffled <- TRUE
[13:36:25.616]                             break
[13:36:25.616]                           }
[13:36:25.616]                         }
[13:36:25.616]                       }
[13:36:25.616]                       invisible(muffled)
[13:36:25.616]                     }
[13:36:25.616]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.616]                   }
[13:36:25.616]                 }
[13:36:25.616]             }
[13:36:25.616]         }))
[13:36:25.616]     }, error = function(ex) {
[13:36:25.616]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.616]                 ...future.rng), started = ...future.startTime, 
[13:36:25.616]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.616]             version = "1.8"), class = "FutureResult")
[13:36:25.616]     }, finally = {
[13:36:25.616]         if (!identical(...future.workdir, getwd())) 
[13:36:25.616]             setwd(...future.workdir)
[13:36:25.616]         {
[13:36:25.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.616]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.616]             }
[13:36:25.616]             base::options(...future.oldOptions)
[13:36:25.616]             if (.Platform$OS.type == "windows") {
[13:36:25.616]                 old_names <- names(...future.oldEnvVars)
[13:36:25.616]                 envs <- base::Sys.getenv()
[13:36:25.616]                 names <- names(envs)
[13:36:25.616]                 common <- intersect(names, old_names)
[13:36:25.616]                 added <- setdiff(names, old_names)
[13:36:25.616]                 removed <- setdiff(old_names, names)
[13:36:25.616]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.616]                   envs[common]]
[13:36:25.616]                 NAMES <- toupper(changed)
[13:36:25.616]                 args <- list()
[13:36:25.616]                 for (kk in seq_along(NAMES)) {
[13:36:25.616]                   name <- changed[[kk]]
[13:36:25.616]                   NAME <- NAMES[[kk]]
[13:36:25.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.616]                     next
[13:36:25.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.616]                 }
[13:36:25.616]                 NAMES <- toupper(added)
[13:36:25.616]                 for (kk in seq_along(NAMES)) {
[13:36:25.616]                   name <- added[[kk]]
[13:36:25.616]                   NAME <- NAMES[[kk]]
[13:36:25.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.616]                     next
[13:36:25.616]                   args[[name]] <- ""
[13:36:25.616]                 }
[13:36:25.616]                 NAMES <- toupper(removed)
[13:36:25.616]                 for (kk in seq_along(NAMES)) {
[13:36:25.616]                   name <- removed[[kk]]
[13:36:25.616]                   NAME <- NAMES[[kk]]
[13:36:25.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.616]                     next
[13:36:25.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.616]                 }
[13:36:25.616]                 if (length(args) > 0) 
[13:36:25.616]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.616]             }
[13:36:25.616]             else {
[13:36:25.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.616]             }
[13:36:25.616]             {
[13:36:25.616]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.616]                   0L) {
[13:36:25.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.616]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.616]                   base::options(opts)
[13:36:25.616]                 }
[13:36:25.616]                 {
[13:36:25.616]                   {
[13:36:25.616]                     NULL
[13:36:25.616]                     RNGkind("Mersenne-Twister")
[13:36:25.616]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.616]                       inherits = FALSE)
[13:36:25.616]                   }
[13:36:25.616]                   options(future.plan = NULL)
[13:36:25.616]                   if (is.na(NA_character_)) 
[13:36:25.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.616]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.616]                     .init = FALSE)
[13:36:25.616]                 }
[13:36:25.616]             }
[13:36:25.616]         }
[13:36:25.616]     })
[13:36:25.616]     if (TRUE) {
[13:36:25.616]         base::sink(type = "output", split = FALSE)
[13:36:25.616]         if (TRUE) {
[13:36:25.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.616]         }
[13:36:25.616]         else {
[13:36:25.616]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.616]         }
[13:36:25.616]         base::close(...future.stdout)
[13:36:25.616]         ...future.stdout <- NULL
[13:36:25.616]     }
[13:36:25.616]     ...future.result$conditions <- ...future.conditions
[13:36:25.616]     ...future.result$finished <- base::Sys.time()
[13:36:25.616]     ...future.result
[13:36:25.616] }
[13:36:25.618] assign_globals() ...
[13:36:25.618] List of 1
[13:36:25.618]  $ ii: int 2
[13:36:25.618]  - attr(*, "where")=List of 1
[13:36:25.618]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:25.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.618]  - attr(*, "resolved")= logi FALSE
[13:36:25.618]  - attr(*, "total_size")= num 56
[13:36:25.618]  - attr(*, "already-done")= logi TRUE
[13:36:25.620] - copied ‘ii’ to environment
[13:36:25.620] assign_globals() ... done
[13:36:25.621] plan(): Setting new future strategy stack:
[13:36:25.621] List of future strategies:
[13:36:25.621] 1. sequential:
[13:36:25.621]    - args: function (..., envir = parent.frame())
[13:36:25.621]    - tweaked: FALSE
[13:36:25.621]    - call: NULL
[13:36:25.621] plan(): nbrOfWorkers() = 1
[13:36:25.622] plan(): Setting new future strategy stack:
[13:36:25.622] List of future strategies:
[13:36:25.622] 1. sequential:
[13:36:25.622]    - args: function (..., envir = parent.frame())
[13:36:25.622]    - tweaked: FALSE
[13:36:25.622]    - call: plan(strategy)
[13:36:25.622] plan(): nbrOfWorkers() = 1
[13:36:25.623] SequentialFuture started (and completed)
[13:36:25.623] signalConditions() ...
[13:36:25.623]  - include = ‘immediateCondition’
[13:36:25.623]  - exclude = 
[13:36:25.623]  - resignal = FALSE
[13:36:25.623]  - Number of conditions: 1
[13:36:25.623] signalConditions() ... done
[13:36:25.623] - Launch lazy future ... done
[13:36:25.623] run() for ‘SequentialFuture’ ... done
[13:36:25.624] getGlobalsAndPackages() ...
[13:36:25.624] Searching for globals...
[13:36:25.625] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:25.625] Searching for globals ... DONE
[13:36:25.625] Resolving globals: FALSE
[13:36:25.626] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.626] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:25.626] - globals: [1] ‘ii’
[13:36:25.626] 
[13:36:25.626] getGlobalsAndPackages() ... DONE
[13:36:25.627] run() for ‘Future’ ...
[13:36:25.627] - state: ‘created’
[13:36:25.627] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.627]   - Field: ‘label’
[13:36:25.627]   - Field: ‘local’
[13:36:25.627]   - Field: ‘owner’
[13:36:25.628]   - Field: ‘envir’
[13:36:25.628]   - Field: ‘packages’
[13:36:25.628]   - Field: ‘gc’
[13:36:25.628]   - Field: ‘conditions’
[13:36:25.628]   - Field: ‘expr’
[13:36:25.628]   - Field: ‘uuid’
[13:36:25.628]   - Field: ‘seed’
[13:36:25.628]   - Field: ‘version’
[13:36:25.628]   - Field: ‘result’
[13:36:25.628]   - Field: ‘asynchronous’
[13:36:25.628]   - Field: ‘calls’
[13:36:25.629]   - Field: ‘globals’
[13:36:25.629]   - Field: ‘stdout’
[13:36:25.629]   - Field: ‘earlySignal’
[13:36:25.629]   - Field: ‘lazy’
[13:36:25.629]   - Field: ‘state’
[13:36:25.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.629] - Launch lazy future ...
[13:36:25.629] Packages needed by the future expression (n = 0): <none>
[13:36:25.629] Packages needed by future strategies (n = 0): <none>
[13:36:25.630] {
[13:36:25.630]     {
[13:36:25.630]         {
[13:36:25.630]             ...future.startTime <- base::Sys.time()
[13:36:25.630]             {
[13:36:25.630]                 {
[13:36:25.630]                   {
[13:36:25.630]                     base::local({
[13:36:25.630]                       has_future <- base::requireNamespace("future", 
[13:36:25.630]                         quietly = TRUE)
[13:36:25.630]                       if (has_future) {
[13:36:25.630]                         ns <- base::getNamespace("future")
[13:36:25.630]                         version <- ns[[".package"]][["version"]]
[13:36:25.630]                         if (is.null(version)) 
[13:36:25.630]                           version <- utils::packageVersion("future")
[13:36:25.630]                       }
[13:36:25.630]                       else {
[13:36:25.630]                         version <- NULL
[13:36:25.630]                       }
[13:36:25.630]                       if (!has_future || version < "1.8.0") {
[13:36:25.630]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.630]                           "", base::R.version$version.string), 
[13:36:25.630]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.630]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.630]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.630]                             "release", "version")], collapse = " "), 
[13:36:25.630]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.630]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.630]                           info)
[13:36:25.630]                         info <- base::paste(info, collapse = "; ")
[13:36:25.630]                         if (!has_future) {
[13:36:25.630]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.630]                             info)
[13:36:25.630]                         }
[13:36:25.630]                         else {
[13:36:25.630]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.630]                             info, version)
[13:36:25.630]                         }
[13:36:25.630]                         base::stop(msg)
[13:36:25.630]                       }
[13:36:25.630]                     })
[13:36:25.630]                   }
[13:36:25.630]                   ...future.strategy.old <- future::plan("list")
[13:36:25.630]                   options(future.plan = NULL)
[13:36:25.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.630]                 }
[13:36:25.630]                 ...future.workdir <- getwd()
[13:36:25.630]             }
[13:36:25.630]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.630]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.630]         }
[13:36:25.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.630]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.630]             base::names(...future.oldOptions))
[13:36:25.630]     }
[13:36:25.630]     if (FALSE) {
[13:36:25.630]     }
[13:36:25.630]     else {
[13:36:25.630]         if (TRUE) {
[13:36:25.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.630]                 open = "w")
[13:36:25.630]         }
[13:36:25.630]         else {
[13:36:25.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.630]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.630]         }
[13:36:25.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.630]             base::sink(type = "output", split = FALSE)
[13:36:25.630]             base::close(...future.stdout)
[13:36:25.630]         }, add = TRUE)
[13:36:25.630]     }
[13:36:25.630]     ...future.frame <- base::sys.nframe()
[13:36:25.630]     ...future.conditions <- base::list()
[13:36:25.630]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.630]     if (FALSE) {
[13:36:25.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.630]     }
[13:36:25.630]     ...future.result <- base::tryCatch({
[13:36:25.630]         base::withCallingHandlers({
[13:36:25.630]             ...future.value <- base::withVisible(base::local({
[13:36:25.630]                 if (ii%%2 == 0) 
[13:36:25.630]                   stop("Woops!")
[13:36:25.630]                 ii
[13:36:25.630]             }))
[13:36:25.630]             future::FutureResult(value = ...future.value$value, 
[13:36:25.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.630]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.630]                     ...future.globalenv.names))
[13:36:25.630]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.630]         }, condition = base::local({
[13:36:25.630]             c <- base::c
[13:36:25.630]             inherits <- base::inherits
[13:36:25.630]             invokeRestart <- base::invokeRestart
[13:36:25.630]             length <- base::length
[13:36:25.630]             list <- base::list
[13:36:25.630]             seq.int <- base::seq.int
[13:36:25.630]             signalCondition <- base::signalCondition
[13:36:25.630]             sys.calls <- base::sys.calls
[13:36:25.630]             `[[` <- base::`[[`
[13:36:25.630]             `+` <- base::`+`
[13:36:25.630]             `<<-` <- base::`<<-`
[13:36:25.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.630]                   3L)]
[13:36:25.630]             }
[13:36:25.630]             function(cond) {
[13:36:25.630]                 is_error <- inherits(cond, "error")
[13:36:25.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.630]                   NULL)
[13:36:25.630]                 if (is_error) {
[13:36:25.630]                   sessionInformation <- function() {
[13:36:25.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.630]                       search = base::search(), system = base::Sys.info())
[13:36:25.630]                   }
[13:36:25.630]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.630]                     cond$call), session = sessionInformation(), 
[13:36:25.630]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.630]                   signalCondition(cond)
[13:36:25.630]                 }
[13:36:25.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.630]                 "immediateCondition"))) {
[13:36:25.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.630]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.630]                   if (TRUE && !signal) {
[13:36:25.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.630]                     {
[13:36:25.630]                       inherits <- base::inherits
[13:36:25.630]                       invokeRestart <- base::invokeRestart
[13:36:25.630]                       is.null <- base::is.null
[13:36:25.630]                       muffled <- FALSE
[13:36:25.630]                       if (inherits(cond, "message")) {
[13:36:25.630]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.630]                         if (muffled) 
[13:36:25.630]                           invokeRestart("muffleMessage")
[13:36:25.630]                       }
[13:36:25.630]                       else if (inherits(cond, "warning")) {
[13:36:25.630]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.630]                         if (muffled) 
[13:36:25.630]                           invokeRestart("muffleWarning")
[13:36:25.630]                       }
[13:36:25.630]                       else if (inherits(cond, "condition")) {
[13:36:25.630]                         if (!is.null(pattern)) {
[13:36:25.630]                           computeRestarts <- base::computeRestarts
[13:36:25.630]                           grepl <- base::grepl
[13:36:25.630]                           restarts <- computeRestarts(cond)
[13:36:25.630]                           for (restart in restarts) {
[13:36:25.630]                             name <- restart$name
[13:36:25.630]                             if (is.null(name)) 
[13:36:25.630]                               next
[13:36:25.630]                             if (!grepl(pattern, name)) 
[13:36:25.630]                               next
[13:36:25.630]                             invokeRestart(restart)
[13:36:25.630]                             muffled <- TRUE
[13:36:25.630]                             break
[13:36:25.630]                           }
[13:36:25.630]                         }
[13:36:25.630]                       }
[13:36:25.630]                       invisible(muffled)
[13:36:25.630]                     }
[13:36:25.630]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.630]                   }
[13:36:25.630]                 }
[13:36:25.630]                 else {
[13:36:25.630]                   if (TRUE) {
[13:36:25.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.630]                     {
[13:36:25.630]                       inherits <- base::inherits
[13:36:25.630]                       invokeRestart <- base::invokeRestart
[13:36:25.630]                       is.null <- base::is.null
[13:36:25.630]                       muffled <- FALSE
[13:36:25.630]                       if (inherits(cond, "message")) {
[13:36:25.630]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.630]                         if (muffled) 
[13:36:25.630]                           invokeRestart("muffleMessage")
[13:36:25.630]                       }
[13:36:25.630]                       else if (inherits(cond, "warning")) {
[13:36:25.630]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.630]                         if (muffled) 
[13:36:25.630]                           invokeRestart("muffleWarning")
[13:36:25.630]                       }
[13:36:25.630]                       else if (inherits(cond, "condition")) {
[13:36:25.630]                         if (!is.null(pattern)) {
[13:36:25.630]                           computeRestarts <- base::computeRestarts
[13:36:25.630]                           grepl <- base::grepl
[13:36:25.630]                           restarts <- computeRestarts(cond)
[13:36:25.630]                           for (restart in restarts) {
[13:36:25.630]                             name <- restart$name
[13:36:25.630]                             if (is.null(name)) 
[13:36:25.630]                               next
[13:36:25.630]                             if (!grepl(pattern, name)) 
[13:36:25.630]                               next
[13:36:25.630]                             invokeRestart(restart)
[13:36:25.630]                             muffled <- TRUE
[13:36:25.630]                             break
[13:36:25.630]                           }
[13:36:25.630]                         }
[13:36:25.630]                       }
[13:36:25.630]                       invisible(muffled)
[13:36:25.630]                     }
[13:36:25.630]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.630]                   }
[13:36:25.630]                 }
[13:36:25.630]             }
[13:36:25.630]         }))
[13:36:25.630]     }, error = function(ex) {
[13:36:25.630]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.630]                 ...future.rng), started = ...future.startTime, 
[13:36:25.630]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.630]             version = "1.8"), class = "FutureResult")
[13:36:25.630]     }, finally = {
[13:36:25.630]         if (!identical(...future.workdir, getwd())) 
[13:36:25.630]             setwd(...future.workdir)
[13:36:25.630]         {
[13:36:25.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.630]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.630]             }
[13:36:25.630]             base::options(...future.oldOptions)
[13:36:25.630]             if (.Platform$OS.type == "windows") {
[13:36:25.630]                 old_names <- names(...future.oldEnvVars)
[13:36:25.630]                 envs <- base::Sys.getenv()
[13:36:25.630]                 names <- names(envs)
[13:36:25.630]                 common <- intersect(names, old_names)
[13:36:25.630]                 added <- setdiff(names, old_names)
[13:36:25.630]                 removed <- setdiff(old_names, names)
[13:36:25.630]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.630]                   envs[common]]
[13:36:25.630]                 NAMES <- toupper(changed)
[13:36:25.630]                 args <- list()
[13:36:25.630]                 for (kk in seq_along(NAMES)) {
[13:36:25.630]                   name <- changed[[kk]]
[13:36:25.630]                   NAME <- NAMES[[kk]]
[13:36:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.630]                     next
[13:36:25.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.630]                 }
[13:36:25.630]                 NAMES <- toupper(added)
[13:36:25.630]                 for (kk in seq_along(NAMES)) {
[13:36:25.630]                   name <- added[[kk]]
[13:36:25.630]                   NAME <- NAMES[[kk]]
[13:36:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.630]                     next
[13:36:25.630]                   args[[name]] <- ""
[13:36:25.630]                 }
[13:36:25.630]                 NAMES <- toupper(removed)
[13:36:25.630]                 for (kk in seq_along(NAMES)) {
[13:36:25.630]                   name <- removed[[kk]]
[13:36:25.630]                   NAME <- NAMES[[kk]]
[13:36:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.630]                     next
[13:36:25.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.630]                 }
[13:36:25.630]                 if (length(args) > 0) 
[13:36:25.630]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.630]             }
[13:36:25.630]             else {
[13:36:25.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.630]             }
[13:36:25.630]             {
[13:36:25.630]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.630]                   0L) {
[13:36:25.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.630]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.630]                   base::options(opts)
[13:36:25.630]                 }
[13:36:25.630]                 {
[13:36:25.630]                   {
[13:36:25.630]                     NULL
[13:36:25.630]                     RNGkind("Mersenne-Twister")
[13:36:25.630]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.630]                       inherits = FALSE)
[13:36:25.630]                   }
[13:36:25.630]                   options(future.plan = NULL)
[13:36:25.630]                   if (is.na(NA_character_)) 
[13:36:25.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.630]                     .init = FALSE)
[13:36:25.630]                 }
[13:36:25.630]             }
[13:36:25.630]         }
[13:36:25.630]     })
[13:36:25.630]     if (TRUE) {
[13:36:25.630]         base::sink(type = "output", split = FALSE)
[13:36:25.630]         if (TRUE) {
[13:36:25.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.630]         }
[13:36:25.630]         else {
[13:36:25.630]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.630]         }
[13:36:25.630]         base::close(...future.stdout)
[13:36:25.630]         ...future.stdout <- NULL
[13:36:25.630]     }
[13:36:25.630]     ...future.result$conditions <- ...future.conditions
[13:36:25.630]     ...future.result$finished <- base::Sys.time()
[13:36:25.630]     ...future.result
[13:36:25.630] }
[13:36:25.631] assign_globals() ...
[13:36:25.631] List of 1
[13:36:25.631]  $ ii: int 3
[13:36:25.631]  - attr(*, "where")=List of 1
[13:36:25.631]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:25.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.631]  - attr(*, "resolved")= logi FALSE
[13:36:25.631]  - attr(*, "total_size")= num 56
[13:36:25.631]  - attr(*, "already-done")= logi TRUE
[13:36:25.635] - copied ‘ii’ to environment
[13:36:25.635] assign_globals() ... done
[13:36:25.635] plan(): Setting new future strategy stack:
[13:36:25.635] List of future strategies:
[13:36:25.635] 1. sequential:
[13:36:25.635]    - args: function (..., envir = parent.frame())
[13:36:25.635]    - tweaked: FALSE
[13:36:25.635]    - call: NULL
[13:36:25.636] plan(): nbrOfWorkers() = 1
[13:36:25.636] plan(): Setting new future strategy stack:
[13:36:25.636] List of future strategies:
[13:36:25.636] 1. sequential:
[13:36:25.636]    - args: function (..., envir = parent.frame())
[13:36:25.636]    - tweaked: FALSE
[13:36:25.636]    - call: plan(strategy)
[13:36:25.637] plan(): nbrOfWorkers() = 1
[13:36:25.637] SequentialFuture started (and completed)
[13:36:25.637] - Launch lazy future ... done
[13:36:25.637] run() for ‘SequentialFuture’ ... done
[13:36:25.637] signalConditions() ...
[13:36:25.638]  - include = ‘immediateCondition’
[13:36:25.638]  - exclude = 
[13:36:25.638]  - resignal = FALSE
[13:36:25.638]  - Number of conditions: 1
[13:36:25.638] signalConditions() ... done
[13:36:25.638] Future state: ‘finished’
[13:36:25.638] signalConditions() ...
[13:36:25.638]  - include = ‘condition’
[13:36:25.638]  - exclude = ‘immediateCondition’
[13:36:25.638]  - resignal = TRUE
[13:36:25.639]  - Number of conditions: 1
[13:36:25.639]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.639] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:36:25.640] signalConditions() ...
[13:36:25.640]  - include = ‘immediateCondition’
[13:36:25.640]  - exclude = 
[13:36:25.640]  - resignal = FALSE
[13:36:25.640]  - Number of conditions: 1
[13:36:25.640] signalConditions() ... done
[13:36:25.640] Future state: ‘finished’
[13:36:25.640] signalConditions() ...
[13:36:25.641]  - include = ‘condition’
[13:36:25.641]  - exclude = ‘immediateCondition’
[13:36:25.641]  - resignal = TRUE
[13:36:25.641]  - Number of conditions: 1
[13:36:25.641]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.641] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:36:25.641] signalConditions() ...
[13:36:25.641]  - include = ‘immediateCondition’
[13:36:25.642]  - exclude = 
[13:36:25.642]  - resignal = FALSE
[13:36:25.642]  - Number of conditions: 1
[13:36:25.642] signalConditions() ... done
[13:36:25.642] Future state: ‘finished’
[13:36:25.642] signalConditions() ...
[13:36:25.642]  - include = ‘condition’
[13:36:25.642]  - exclude = ‘immediateCondition’
[13:36:25.642]  - resignal = TRUE
[13:36:25.642]  - Number of conditions: 1
[13:36:25.642]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.643] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:36:25.643] getGlobalsAndPackages() ...
[13:36:25.643] Searching for globals...
[13:36:25.645] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:36:25.645] Searching for globals ... DONE
[13:36:25.645] Resolving globals: FALSE
[13:36:25.645] 
[13:36:25.645] 
[13:36:25.645] getGlobalsAndPackages() ... DONE
[13:36:25.646] run() for ‘Future’ ...
[13:36:25.646] - state: ‘created’
[13:36:25.646] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.646] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.646]   - Field: ‘label’
[13:36:25.646]   - Field: ‘local’
[13:36:25.646]   - Field: ‘owner’
[13:36:25.647]   - Field: ‘envir’
[13:36:25.647]   - Field: ‘packages’
[13:36:25.647]   - Field: ‘gc’
[13:36:25.647]   - Field: ‘conditions’
[13:36:25.647]   - Field: ‘expr’
[13:36:25.647]   - Field: ‘uuid’
[13:36:25.647]   - Field: ‘seed’
[13:36:25.647]   - Field: ‘version’
[13:36:25.647]   - Field: ‘result’
[13:36:25.647]   - Field: ‘asynchronous’
[13:36:25.647]   - Field: ‘calls’
[13:36:25.647]   - Field: ‘globals’
[13:36:25.648]   - Field: ‘stdout’
[13:36:25.648]   - Field: ‘earlySignal’
[13:36:25.648]   - Field: ‘lazy’
[13:36:25.648]   - Field: ‘state’
[13:36:25.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.648] - Launch lazy future ...
[13:36:25.648] Packages needed by the future expression (n = 0): <none>
[13:36:25.648] Packages needed by future strategies (n = 0): <none>
[13:36:25.649] {
[13:36:25.649]     {
[13:36:25.649]         {
[13:36:25.649]             ...future.startTime <- base::Sys.time()
[13:36:25.649]             {
[13:36:25.649]                 {
[13:36:25.649]                   {
[13:36:25.649]                     base::local({
[13:36:25.649]                       has_future <- base::requireNamespace("future", 
[13:36:25.649]                         quietly = TRUE)
[13:36:25.649]                       if (has_future) {
[13:36:25.649]                         ns <- base::getNamespace("future")
[13:36:25.649]                         version <- ns[[".package"]][["version"]]
[13:36:25.649]                         if (is.null(version)) 
[13:36:25.649]                           version <- utils::packageVersion("future")
[13:36:25.649]                       }
[13:36:25.649]                       else {
[13:36:25.649]                         version <- NULL
[13:36:25.649]                       }
[13:36:25.649]                       if (!has_future || version < "1.8.0") {
[13:36:25.649]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.649]                           "", base::R.version$version.string), 
[13:36:25.649]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.649]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.649]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.649]                             "release", "version")], collapse = " "), 
[13:36:25.649]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.649]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.649]                           info)
[13:36:25.649]                         info <- base::paste(info, collapse = "; ")
[13:36:25.649]                         if (!has_future) {
[13:36:25.649]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.649]                             info)
[13:36:25.649]                         }
[13:36:25.649]                         else {
[13:36:25.649]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.649]                             info, version)
[13:36:25.649]                         }
[13:36:25.649]                         base::stop(msg)
[13:36:25.649]                       }
[13:36:25.649]                     })
[13:36:25.649]                   }
[13:36:25.649]                   ...future.strategy.old <- future::plan("list")
[13:36:25.649]                   options(future.plan = NULL)
[13:36:25.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.649]                 }
[13:36:25.649]                 ...future.workdir <- getwd()
[13:36:25.649]             }
[13:36:25.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.649]         }
[13:36:25.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.649]             base::names(...future.oldOptions))
[13:36:25.649]     }
[13:36:25.649]     if (FALSE) {
[13:36:25.649]     }
[13:36:25.649]     else {
[13:36:25.649]         if (TRUE) {
[13:36:25.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.649]                 open = "w")
[13:36:25.649]         }
[13:36:25.649]         else {
[13:36:25.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.649]         }
[13:36:25.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.649]             base::sink(type = "output", split = FALSE)
[13:36:25.649]             base::close(...future.stdout)
[13:36:25.649]         }, add = TRUE)
[13:36:25.649]     }
[13:36:25.649]     ...future.frame <- base::sys.nframe()
[13:36:25.649]     ...future.conditions <- base::list()
[13:36:25.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.649]     if (FALSE) {
[13:36:25.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.649]     }
[13:36:25.649]     ...future.result <- base::tryCatch({
[13:36:25.649]         base::withCallingHandlers({
[13:36:25.649]             ...future.value <- base::withVisible(base::local({
[13:36:25.649]                 cat("Processing: ")
[13:36:25.649]                 for (ii in 1:10) {
[13:36:25.649]                   cat(".")
[13:36:25.649]                 }
[13:36:25.649]                 cat(" [100%]\n")
[13:36:25.649]                 4
[13:36:25.649]             }))
[13:36:25.649]             future::FutureResult(value = ...future.value$value, 
[13:36:25.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.649]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.649]                     ...future.globalenv.names))
[13:36:25.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.649]         }, condition = base::local({
[13:36:25.649]             c <- base::c
[13:36:25.649]             inherits <- base::inherits
[13:36:25.649]             invokeRestart <- base::invokeRestart
[13:36:25.649]             length <- base::length
[13:36:25.649]             list <- base::list
[13:36:25.649]             seq.int <- base::seq.int
[13:36:25.649]             signalCondition <- base::signalCondition
[13:36:25.649]             sys.calls <- base::sys.calls
[13:36:25.649]             `[[` <- base::`[[`
[13:36:25.649]             `+` <- base::`+`
[13:36:25.649]             `<<-` <- base::`<<-`
[13:36:25.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.649]                   3L)]
[13:36:25.649]             }
[13:36:25.649]             function(cond) {
[13:36:25.649]                 is_error <- inherits(cond, "error")
[13:36:25.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.649]                   NULL)
[13:36:25.649]                 if (is_error) {
[13:36:25.649]                   sessionInformation <- function() {
[13:36:25.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.649]                       search = base::search(), system = base::Sys.info())
[13:36:25.649]                   }
[13:36:25.649]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.649]                     cond$call), session = sessionInformation(), 
[13:36:25.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.649]                   signalCondition(cond)
[13:36:25.649]                 }
[13:36:25.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.649]                 "immediateCondition"))) {
[13:36:25.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.649]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.649]                   if (TRUE && !signal) {
[13:36:25.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.649]                     {
[13:36:25.649]                       inherits <- base::inherits
[13:36:25.649]                       invokeRestart <- base::invokeRestart
[13:36:25.649]                       is.null <- base::is.null
[13:36:25.649]                       muffled <- FALSE
[13:36:25.649]                       if (inherits(cond, "message")) {
[13:36:25.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.649]                         if (muffled) 
[13:36:25.649]                           invokeRestart("muffleMessage")
[13:36:25.649]                       }
[13:36:25.649]                       else if (inherits(cond, "warning")) {
[13:36:25.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.649]                         if (muffled) 
[13:36:25.649]                           invokeRestart("muffleWarning")
[13:36:25.649]                       }
[13:36:25.649]                       else if (inherits(cond, "condition")) {
[13:36:25.649]                         if (!is.null(pattern)) {
[13:36:25.649]                           computeRestarts <- base::computeRestarts
[13:36:25.649]                           grepl <- base::grepl
[13:36:25.649]                           restarts <- computeRestarts(cond)
[13:36:25.649]                           for (restart in restarts) {
[13:36:25.649]                             name <- restart$name
[13:36:25.649]                             if (is.null(name)) 
[13:36:25.649]                               next
[13:36:25.649]                             if (!grepl(pattern, name)) 
[13:36:25.649]                               next
[13:36:25.649]                             invokeRestart(restart)
[13:36:25.649]                             muffled <- TRUE
[13:36:25.649]                             break
[13:36:25.649]                           }
[13:36:25.649]                         }
[13:36:25.649]                       }
[13:36:25.649]                       invisible(muffled)
[13:36:25.649]                     }
[13:36:25.649]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.649]                   }
[13:36:25.649]                 }
[13:36:25.649]                 else {
[13:36:25.649]                   if (TRUE) {
[13:36:25.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.649]                     {
[13:36:25.649]                       inherits <- base::inherits
[13:36:25.649]                       invokeRestart <- base::invokeRestart
[13:36:25.649]                       is.null <- base::is.null
[13:36:25.649]                       muffled <- FALSE
[13:36:25.649]                       if (inherits(cond, "message")) {
[13:36:25.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.649]                         if (muffled) 
[13:36:25.649]                           invokeRestart("muffleMessage")
[13:36:25.649]                       }
[13:36:25.649]                       else if (inherits(cond, "warning")) {
[13:36:25.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.649]                         if (muffled) 
[13:36:25.649]                           invokeRestart("muffleWarning")
[13:36:25.649]                       }
[13:36:25.649]                       else if (inherits(cond, "condition")) {
[13:36:25.649]                         if (!is.null(pattern)) {
[13:36:25.649]                           computeRestarts <- base::computeRestarts
[13:36:25.649]                           grepl <- base::grepl
[13:36:25.649]                           restarts <- computeRestarts(cond)
[13:36:25.649]                           for (restart in restarts) {
[13:36:25.649]                             name <- restart$name
[13:36:25.649]                             if (is.null(name)) 
[13:36:25.649]                               next
[13:36:25.649]                             if (!grepl(pattern, name)) 
[13:36:25.649]                               next
[13:36:25.649]                             invokeRestart(restart)
[13:36:25.649]                             muffled <- TRUE
[13:36:25.649]                             break
[13:36:25.649]                           }
[13:36:25.649]                         }
[13:36:25.649]                       }
[13:36:25.649]                       invisible(muffled)
[13:36:25.649]                     }
[13:36:25.649]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.649]                   }
[13:36:25.649]                 }
[13:36:25.649]             }
[13:36:25.649]         }))
[13:36:25.649]     }, error = function(ex) {
[13:36:25.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.649]                 ...future.rng), started = ...future.startTime, 
[13:36:25.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.649]             version = "1.8"), class = "FutureResult")
[13:36:25.649]     }, finally = {
[13:36:25.649]         if (!identical(...future.workdir, getwd())) 
[13:36:25.649]             setwd(...future.workdir)
[13:36:25.649]         {
[13:36:25.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.649]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.649]             }
[13:36:25.649]             base::options(...future.oldOptions)
[13:36:25.649]             if (.Platform$OS.type == "windows") {
[13:36:25.649]                 old_names <- names(...future.oldEnvVars)
[13:36:25.649]                 envs <- base::Sys.getenv()
[13:36:25.649]                 names <- names(envs)
[13:36:25.649]                 common <- intersect(names, old_names)
[13:36:25.649]                 added <- setdiff(names, old_names)
[13:36:25.649]                 removed <- setdiff(old_names, names)
[13:36:25.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.649]                   envs[common]]
[13:36:25.649]                 NAMES <- toupper(changed)
[13:36:25.649]                 args <- list()
[13:36:25.649]                 for (kk in seq_along(NAMES)) {
[13:36:25.649]                   name <- changed[[kk]]
[13:36:25.649]                   NAME <- NAMES[[kk]]
[13:36:25.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.649]                     next
[13:36:25.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.649]                 }
[13:36:25.649]                 NAMES <- toupper(added)
[13:36:25.649]                 for (kk in seq_along(NAMES)) {
[13:36:25.649]                   name <- added[[kk]]
[13:36:25.649]                   NAME <- NAMES[[kk]]
[13:36:25.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.649]                     next
[13:36:25.649]                   args[[name]] <- ""
[13:36:25.649]                 }
[13:36:25.649]                 NAMES <- toupper(removed)
[13:36:25.649]                 for (kk in seq_along(NAMES)) {
[13:36:25.649]                   name <- removed[[kk]]
[13:36:25.649]                   NAME <- NAMES[[kk]]
[13:36:25.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.649]                     next
[13:36:25.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.649]                 }
[13:36:25.649]                 if (length(args) > 0) 
[13:36:25.649]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.649]             }
[13:36:25.649]             else {
[13:36:25.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.649]             }
[13:36:25.649]             {
[13:36:25.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.649]                   0L) {
[13:36:25.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.649]                   base::options(opts)
[13:36:25.649]                 }
[13:36:25.649]                 {
[13:36:25.649]                   {
[13:36:25.649]                     NULL
[13:36:25.649]                     RNGkind("Mersenne-Twister")
[13:36:25.649]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.649]                       inherits = FALSE)
[13:36:25.649]                   }
[13:36:25.649]                   options(future.plan = NULL)
[13:36:25.649]                   if (is.na(NA_character_)) 
[13:36:25.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.649]                     .init = FALSE)
[13:36:25.649]                 }
[13:36:25.649]             }
[13:36:25.649]         }
[13:36:25.649]     })
[13:36:25.649]     if (TRUE) {
[13:36:25.649]         base::sink(type = "output", split = FALSE)
[13:36:25.649]         if (TRUE) {
[13:36:25.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.649]         }
[13:36:25.649]         else {
[13:36:25.649]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.649]         }
[13:36:25.649]         base::close(...future.stdout)
[13:36:25.649]         ...future.stdout <- NULL
[13:36:25.649]     }
[13:36:25.649]     ...future.result$conditions <- ...future.conditions
[13:36:25.649]     ...future.result$finished <- base::Sys.time()
[13:36:25.649]     ...future.result
[13:36:25.649] }
[13:36:25.650] plan(): Setting new future strategy stack:
[13:36:25.651] List of future strategies:
[13:36:25.651] 1. sequential:
[13:36:25.651]    - args: function (..., envir = parent.frame())
[13:36:25.651]    - tweaked: FALSE
[13:36:25.651]    - call: NULL
[13:36:25.651] plan(): nbrOfWorkers() = 1
[13:36:25.652] plan(): Setting new future strategy stack:
[13:36:25.652] List of future strategies:
[13:36:25.652] 1. sequential:
[13:36:25.652]    - args: function (..., envir = parent.frame())
[13:36:25.652]    - tweaked: FALSE
[13:36:25.652]    - call: plan(strategy)
[13:36:25.652] plan(): nbrOfWorkers() = 1
[13:36:25.652] SequentialFuture started (and completed)
[13:36:25.652] - Launch lazy future ... done
[13:36:25.652] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:36:25.654] signalConditions() ...
[13:36:25.654]  - include = ‘immediateCondition’
[13:36:25.654]  - exclude = 
[13:36:25.654]  - resignal = FALSE
[13:36:25.654]  - Number of conditions: 1
[13:36:25.654] signalConditions() ... done
[13:36:25.654] Future state: ‘finished’
[13:36:25.654] signalConditions() ...
[13:36:25.654]  - include = ‘condition’
[13:36:25.654]  - exclude = ‘immediateCondition’
[13:36:25.655]  - resignal = TRUE
[13:36:25.655]  - Number of conditions: 1
[13:36:25.655]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.655] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:36:25.655] getGlobalsAndPackages() ...
[13:36:25.655] Searching for globals...
[13:36:25.656] 
[13:36:25.656] Searching for globals ... DONE
[13:36:25.656] - globals: [0] <none>
[13:36:25.656] getGlobalsAndPackages() ... DONE
[13:36:25.656] run() for ‘Future’ ...
[13:36:25.656] - state: ‘created’
[13:36:25.656] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.656] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.658] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.658]   - Field: ‘label’
[13:36:25.658]   - Field: ‘local’
[13:36:25.658]   - Field: ‘owner’
[13:36:25.658]   - Field: ‘envir’
[13:36:25.658]   - Field: ‘packages’
[13:36:25.658]   - Field: ‘gc’
[13:36:25.658]   - Field: ‘conditions’
[13:36:25.658]   - Field: ‘expr’
[13:36:25.658]   - Field: ‘uuid’
[13:36:25.659]   - Field: ‘seed’
[13:36:25.659]   - Field: ‘version’
[13:36:25.659]   - Field: ‘result’
[13:36:25.659]   - Field: ‘asynchronous’
[13:36:25.659]   - Field: ‘calls’
[13:36:25.659]   - Field: ‘globals’
[13:36:25.659]   - Field: ‘stdout’
[13:36:25.659]   - Field: ‘earlySignal’
[13:36:25.659]   - Field: ‘lazy’
[13:36:25.659]   - Field: ‘state’
[13:36:25.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.660] - Launch lazy future ...
[13:36:25.660] Packages needed by the future expression (n = 0): <none>
[13:36:25.660] Packages needed by future strategies (n = 0): <none>
[13:36:25.660] {
[13:36:25.660]     {
[13:36:25.660]         {
[13:36:25.660]             ...future.startTime <- base::Sys.time()
[13:36:25.660]             {
[13:36:25.660]                 {
[13:36:25.660]                   {
[13:36:25.660]                     base::local({
[13:36:25.660]                       has_future <- base::requireNamespace("future", 
[13:36:25.660]                         quietly = TRUE)
[13:36:25.660]                       if (has_future) {
[13:36:25.660]                         ns <- base::getNamespace("future")
[13:36:25.660]                         version <- ns[[".package"]][["version"]]
[13:36:25.660]                         if (is.null(version)) 
[13:36:25.660]                           version <- utils::packageVersion("future")
[13:36:25.660]                       }
[13:36:25.660]                       else {
[13:36:25.660]                         version <- NULL
[13:36:25.660]                       }
[13:36:25.660]                       if (!has_future || version < "1.8.0") {
[13:36:25.660]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.660]                           "", base::R.version$version.string), 
[13:36:25.660]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.660]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.660]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.660]                             "release", "version")], collapse = " "), 
[13:36:25.660]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.660]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.660]                           info)
[13:36:25.660]                         info <- base::paste(info, collapse = "; ")
[13:36:25.660]                         if (!has_future) {
[13:36:25.660]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.660]                             info)
[13:36:25.660]                         }
[13:36:25.660]                         else {
[13:36:25.660]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.660]                             info, version)
[13:36:25.660]                         }
[13:36:25.660]                         base::stop(msg)
[13:36:25.660]                       }
[13:36:25.660]                     })
[13:36:25.660]                   }
[13:36:25.660]                   ...future.strategy.old <- future::plan("list")
[13:36:25.660]                   options(future.plan = NULL)
[13:36:25.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.660]                 }
[13:36:25.660]                 ...future.workdir <- getwd()
[13:36:25.660]             }
[13:36:25.660]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.660]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.660]         }
[13:36:25.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.660]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.660]             base::names(...future.oldOptions))
[13:36:25.660]     }
[13:36:25.660]     if (FALSE) {
[13:36:25.660]     }
[13:36:25.660]     else {
[13:36:25.660]         if (TRUE) {
[13:36:25.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.660]                 open = "w")
[13:36:25.660]         }
[13:36:25.660]         else {
[13:36:25.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.660]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.660]         }
[13:36:25.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.660]             base::sink(type = "output", split = FALSE)
[13:36:25.660]             base::close(...future.stdout)
[13:36:25.660]         }, add = TRUE)
[13:36:25.660]     }
[13:36:25.660]     ...future.frame <- base::sys.nframe()
[13:36:25.660]     ...future.conditions <- base::list()
[13:36:25.660]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.660]     if (FALSE) {
[13:36:25.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.660]     }
[13:36:25.660]     ...future.result <- base::tryCatch({
[13:36:25.660]         base::withCallingHandlers({
[13:36:25.660]             ...future.value <- base::withVisible(base::local(1))
[13:36:25.660]             future::FutureResult(value = ...future.value$value, 
[13:36:25.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.660]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.660]                     ...future.globalenv.names))
[13:36:25.660]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.660]         }, condition = base::local({
[13:36:25.660]             c <- base::c
[13:36:25.660]             inherits <- base::inherits
[13:36:25.660]             invokeRestart <- base::invokeRestart
[13:36:25.660]             length <- base::length
[13:36:25.660]             list <- base::list
[13:36:25.660]             seq.int <- base::seq.int
[13:36:25.660]             signalCondition <- base::signalCondition
[13:36:25.660]             sys.calls <- base::sys.calls
[13:36:25.660]             `[[` <- base::`[[`
[13:36:25.660]             `+` <- base::`+`
[13:36:25.660]             `<<-` <- base::`<<-`
[13:36:25.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.660]                   3L)]
[13:36:25.660]             }
[13:36:25.660]             function(cond) {
[13:36:25.660]                 is_error <- inherits(cond, "error")
[13:36:25.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.660]                   NULL)
[13:36:25.660]                 if (is_error) {
[13:36:25.660]                   sessionInformation <- function() {
[13:36:25.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.660]                       search = base::search(), system = base::Sys.info())
[13:36:25.660]                   }
[13:36:25.660]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.660]                     cond$call), session = sessionInformation(), 
[13:36:25.660]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.660]                   signalCondition(cond)
[13:36:25.660]                 }
[13:36:25.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.660]                 "immediateCondition"))) {
[13:36:25.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.660]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.660]                   if (TRUE && !signal) {
[13:36:25.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.660]                     {
[13:36:25.660]                       inherits <- base::inherits
[13:36:25.660]                       invokeRestart <- base::invokeRestart
[13:36:25.660]                       is.null <- base::is.null
[13:36:25.660]                       muffled <- FALSE
[13:36:25.660]                       if (inherits(cond, "message")) {
[13:36:25.660]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.660]                         if (muffled) 
[13:36:25.660]                           invokeRestart("muffleMessage")
[13:36:25.660]                       }
[13:36:25.660]                       else if (inherits(cond, "warning")) {
[13:36:25.660]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.660]                         if (muffled) 
[13:36:25.660]                           invokeRestart("muffleWarning")
[13:36:25.660]                       }
[13:36:25.660]                       else if (inherits(cond, "condition")) {
[13:36:25.660]                         if (!is.null(pattern)) {
[13:36:25.660]                           computeRestarts <- base::computeRestarts
[13:36:25.660]                           grepl <- base::grepl
[13:36:25.660]                           restarts <- computeRestarts(cond)
[13:36:25.660]                           for (restart in restarts) {
[13:36:25.660]                             name <- restart$name
[13:36:25.660]                             if (is.null(name)) 
[13:36:25.660]                               next
[13:36:25.660]                             if (!grepl(pattern, name)) 
[13:36:25.660]                               next
[13:36:25.660]                             invokeRestart(restart)
[13:36:25.660]                             muffled <- TRUE
[13:36:25.660]                             break
[13:36:25.660]                           }
[13:36:25.660]                         }
[13:36:25.660]                       }
[13:36:25.660]                       invisible(muffled)
[13:36:25.660]                     }
[13:36:25.660]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.660]                   }
[13:36:25.660]                 }
[13:36:25.660]                 else {
[13:36:25.660]                   if (TRUE) {
[13:36:25.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.660]                     {
[13:36:25.660]                       inherits <- base::inherits
[13:36:25.660]                       invokeRestart <- base::invokeRestart
[13:36:25.660]                       is.null <- base::is.null
[13:36:25.660]                       muffled <- FALSE
[13:36:25.660]                       if (inherits(cond, "message")) {
[13:36:25.660]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.660]                         if (muffled) 
[13:36:25.660]                           invokeRestart("muffleMessage")
[13:36:25.660]                       }
[13:36:25.660]                       else if (inherits(cond, "warning")) {
[13:36:25.660]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.660]                         if (muffled) 
[13:36:25.660]                           invokeRestart("muffleWarning")
[13:36:25.660]                       }
[13:36:25.660]                       else if (inherits(cond, "condition")) {
[13:36:25.660]                         if (!is.null(pattern)) {
[13:36:25.660]                           computeRestarts <- base::computeRestarts
[13:36:25.660]                           grepl <- base::grepl
[13:36:25.660]                           restarts <- computeRestarts(cond)
[13:36:25.660]                           for (restart in restarts) {
[13:36:25.660]                             name <- restart$name
[13:36:25.660]                             if (is.null(name)) 
[13:36:25.660]                               next
[13:36:25.660]                             if (!grepl(pattern, name)) 
[13:36:25.660]                               next
[13:36:25.660]                             invokeRestart(restart)
[13:36:25.660]                             muffled <- TRUE
[13:36:25.660]                             break
[13:36:25.660]                           }
[13:36:25.660]                         }
[13:36:25.660]                       }
[13:36:25.660]                       invisible(muffled)
[13:36:25.660]                     }
[13:36:25.660]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.660]                   }
[13:36:25.660]                 }
[13:36:25.660]             }
[13:36:25.660]         }))
[13:36:25.660]     }, error = function(ex) {
[13:36:25.660]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.660]                 ...future.rng), started = ...future.startTime, 
[13:36:25.660]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.660]             version = "1.8"), class = "FutureResult")
[13:36:25.660]     }, finally = {
[13:36:25.660]         if (!identical(...future.workdir, getwd())) 
[13:36:25.660]             setwd(...future.workdir)
[13:36:25.660]         {
[13:36:25.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.660]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.660]             }
[13:36:25.660]             base::options(...future.oldOptions)
[13:36:25.660]             if (.Platform$OS.type == "windows") {
[13:36:25.660]                 old_names <- names(...future.oldEnvVars)
[13:36:25.660]                 envs <- base::Sys.getenv()
[13:36:25.660]                 names <- names(envs)
[13:36:25.660]                 common <- intersect(names, old_names)
[13:36:25.660]                 added <- setdiff(names, old_names)
[13:36:25.660]                 removed <- setdiff(old_names, names)
[13:36:25.660]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.660]                   envs[common]]
[13:36:25.660]                 NAMES <- toupper(changed)
[13:36:25.660]                 args <- list()
[13:36:25.660]                 for (kk in seq_along(NAMES)) {
[13:36:25.660]                   name <- changed[[kk]]
[13:36:25.660]                   NAME <- NAMES[[kk]]
[13:36:25.660]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.660]                     next
[13:36:25.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.660]                 }
[13:36:25.660]                 NAMES <- toupper(added)
[13:36:25.660]                 for (kk in seq_along(NAMES)) {
[13:36:25.660]                   name <- added[[kk]]
[13:36:25.660]                   NAME <- NAMES[[kk]]
[13:36:25.660]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.660]                     next
[13:36:25.660]                   args[[name]] <- ""
[13:36:25.660]                 }
[13:36:25.660]                 NAMES <- toupper(removed)
[13:36:25.660]                 for (kk in seq_along(NAMES)) {
[13:36:25.660]                   name <- removed[[kk]]
[13:36:25.660]                   NAME <- NAMES[[kk]]
[13:36:25.660]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.660]                     next
[13:36:25.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.660]                 }
[13:36:25.660]                 if (length(args) > 0) 
[13:36:25.660]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.660]             }
[13:36:25.660]             else {
[13:36:25.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.660]             }
[13:36:25.660]             {
[13:36:25.660]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.660]                   0L) {
[13:36:25.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.660]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.660]                   base::options(opts)
[13:36:25.660]                 }
[13:36:25.660]                 {
[13:36:25.660]                   {
[13:36:25.660]                     NULL
[13:36:25.660]                     RNGkind("Mersenne-Twister")
[13:36:25.660]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.660]                       inherits = FALSE)
[13:36:25.660]                   }
[13:36:25.660]                   options(future.plan = NULL)
[13:36:25.660]                   if (is.na(NA_character_)) 
[13:36:25.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.660]                     .init = FALSE)
[13:36:25.660]                 }
[13:36:25.660]             }
[13:36:25.660]         }
[13:36:25.660]     })
[13:36:25.660]     if (TRUE) {
[13:36:25.660]         base::sink(type = "output", split = FALSE)
[13:36:25.660]         if (TRUE) {
[13:36:25.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.660]         }
[13:36:25.660]         else {
[13:36:25.660]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.660]         }
[13:36:25.660]         base::close(...future.stdout)
[13:36:25.660]         ...future.stdout <- NULL
[13:36:25.660]     }
[13:36:25.660]     ...future.result$conditions <- ...future.conditions
[13:36:25.660]     ...future.result$finished <- base::Sys.time()
[13:36:25.660]     ...future.result
[13:36:25.660] }
[13:36:25.662] plan(): Setting new future strategy stack:
[13:36:25.662] List of future strategies:
[13:36:25.662] 1. sequential:
[13:36:25.662]    - args: function (..., envir = parent.frame())
[13:36:25.662]    - tweaked: FALSE
[13:36:25.662]    - call: NULL
[13:36:25.662] plan(): nbrOfWorkers() = 1
[13:36:25.663] plan(): Setting new future strategy stack:
[13:36:25.663] List of future strategies:
[13:36:25.663] 1. sequential:
[13:36:25.663]    - args: function (..., envir = parent.frame())
[13:36:25.663]    - tweaked: FALSE
[13:36:25.663]    - call: plan(strategy)
[13:36:25.663] plan(): nbrOfWorkers() = 1
[13:36:25.664] SequentialFuture started (and completed)
[13:36:25.664] - Launch lazy future ... done
[13:36:25.664] run() for ‘SequentialFuture’ ... done
c = 1
[13:36:25.664] getGlobalsAndPackages() ...
[13:36:25.664] Searching for globals...
[13:36:25.665] 
[13:36:25.665] Searching for globals ... DONE
[13:36:25.665] - globals: [0] <none>
[13:36:25.665] getGlobalsAndPackages() ... DONE
[13:36:25.665] run() for ‘Future’ ...
[13:36:25.665] - state: ‘created’
[13:36:25.665] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.665] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.666]   - Field: ‘label’
[13:36:25.666]   - Field: ‘local’
[13:36:25.666]   - Field: ‘owner’
[13:36:25.666]   - Field: ‘envir’
[13:36:25.666]   - Field: ‘packages’
[13:36:25.666]   - Field: ‘gc’
[13:36:25.666]   - Field: ‘conditions’
[13:36:25.666]   - Field: ‘expr’
[13:36:25.666]   - Field: ‘uuid’
[13:36:25.667]   - Field: ‘seed’
[13:36:25.667]   - Field: ‘version’
[13:36:25.667]   - Field: ‘result’
[13:36:25.667]   - Field: ‘asynchronous’
[13:36:25.667]   - Field: ‘calls’
[13:36:25.667]   - Field: ‘globals’
[13:36:25.667]   - Field: ‘stdout’
[13:36:25.667]   - Field: ‘earlySignal’
[13:36:25.667]   - Field: ‘lazy’
[13:36:25.667]   - Field: ‘state’
[13:36:25.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.667] - Launch lazy future ...
[13:36:25.668] Packages needed by the future expression (n = 0): <none>
[13:36:25.668] Packages needed by future strategies (n = 0): <none>
[13:36:25.668] {
[13:36:25.668]     {
[13:36:25.668]         {
[13:36:25.668]             ...future.startTime <- base::Sys.time()
[13:36:25.668]             {
[13:36:25.668]                 {
[13:36:25.668]                   {
[13:36:25.668]                     base::local({
[13:36:25.668]                       has_future <- base::requireNamespace("future", 
[13:36:25.668]                         quietly = TRUE)
[13:36:25.668]                       if (has_future) {
[13:36:25.668]                         ns <- base::getNamespace("future")
[13:36:25.668]                         version <- ns[[".package"]][["version"]]
[13:36:25.668]                         if (is.null(version)) 
[13:36:25.668]                           version <- utils::packageVersion("future")
[13:36:25.668]                       }
[13:36:25.668]                       else {
[13:36:25.668]                         version <- NULL
[13:36:25.668]                       }
[13:36:25.668]                       if (!has_future || version < "1.8.0") {
[13:36:25.668]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.668]                           "", base::R.version$version.string), 
[13:36:25.668]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.668]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.668]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.668]                             "release", "version")], collapse = " "), 
[13:36:25.668]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.668]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.668]                           info)
[13:36:25.668]                         info <- base::paste(info, collapse = "; ")
[13:36:25.668]                         if (!has_future) {
[13:36:25.668]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.668]                             info)
[13:36:25.668]                         }
[13:36:25.668]                         else {
[13:36:25.668]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.668]                             info, version)
[13:36:25.668]                         }
[13:36:25.668]                         base::stop(msg)
[13:36:25.668]                       }
[13:36:25.668]                     })
[13:36:25.668]                   }
[13:36:25.668]                   ...future.strategy.old <- future::plan("list")
[13:36:25.668]                   options(future.plan = NULL)
[13:36:25.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.668]                 }
[13:36:25.668]                 ...future.workdir <- getwd()
[13:36:25.668]             }
[13:36:25.668]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.668]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.668]         }
[13:36:25.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.668]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.668]             base::names(...future.oldOptions))
[13:36:25.668]     }
[13:36:25.668]     if (FALSE) {
[13:36:25.668]     }
[13:36:25.668]     else {
[13:36:25.668]         if (TRUE) {
[13:36:25.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.668]                 open = "w")
[13:36:25.668]         }
[13:36:25.668]         else {
[13:36:25.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.668]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.668]         }
[13:36:25.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.668]             base::sink(type = "output", split = FALSE)
[13:36:25.668]             base::close(...future.stdout)
[13:36:25.668]         }, add = TRUE)
[13:36:25.668]     }
[13:36:25.668]     ...future.frame <- base::sys.nframe()
[13:36:25.668]     ...future.conditions <- base::list()
[13:36:25.668]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.668]     if (FALSE) {
[13:36:25.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.668]     }
[13:36:25.668]     ...future.result <- base::tryCatch({
[13:36:25.668]         base::withCallingHandlers({
[13:36:25.668]             ...future.value <- base::withVisible(base::local(1))
[13:36:25.668]             future::FutureResult(value = ...future.value$value, 
[13:36:25.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.668]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.668]                     ...future.globalenv.names))
[13:36:25.668]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.668]         }, condition = base::local({
[13:36:25.668]             c <- base::c
[13:36:25.668]             inherits <- base::inherits
[13:36:25.668]             invokeRestart <- base::invokeRestart
[13:36:25.668]             length <- base::length
[13:36:25.668]             list <- base::list
[13:36:25.668]             seq.int <- base::seq.int
[13:36:25.668]             signalCondition <- base::signalCondition
[13:36:25.668]             sys.calls <- base::sys.calls
[13:36:25.668]             `[[` <- base::`[[`
[13:36:25.668]             `+` <- base::`+`
[13:36:25.668]             `<<-` <- base::`<<-`
[13:36:25.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.668]                   3L)]
[13:36:25.668]             }
[13:36:25.668]             function(cond) {
[13:36:25.668]                 is_error <- inherits(cond, "error")
[13:36:25.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.668]                   NULL)
[13:36:25.668]                 if (is_error) {
[13:36:25.668]                   sessionInformation <- function() {
[13:36:25.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.668]                       search = base::search(), system = base::Sys.info())
[13:36:25.668]                   }
[13:36:25.668]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.668]                     cond$call), session = sessionInformation(), 
[13:36:25.668]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.668]                   signalCondition(cond)
[13:36:25.668]                 }
[13:36:25.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.668]                 "immediateCondition"))) {
[13:36:25.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.668]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.668]                   if (TRUE && !signal) {
[13:36:25.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.668]                     {
[13:36:25.668]                       inherits <- base::inherits
[13:36:25.668]                       invokeRestart <- base::invokeRestart
[13:36:25.668]                       is.null <- base::is.null
[13:36:25.668]                       muffled <- FALSE
[13:36:25.668]                       if (inherits(cond, "message")) {
[13:36:25.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.668]                         if (muffled) 
[13:36:25.668]                           invokeRestart("muffleMessage")
[13:36:25.668]                       }
[13:36:25.668]                       else if (inherits(cond, "warning")) {
[13:36:25.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.668]                         if (muffled) 
[13:36:25.668]                           invokeRestart("muffleWarning")
[13:36:25.668]                       }
[13:36:25.668]                       else if (inherits(cond, "condition")) {
[13:36:25.668]                         if (!is.null(pattern)) {
[13:36:25.668]                           computeRestarts <- base::computeRestarts
[13:36:25.668]                           grepl <- base::grepl
[13:36:25.668]                           restarts <- computeRestarts(cond)
[13:36:25.668]                           for (restart in restarts) {
[13:36:25.668]                             name <- restart$name
[13:36:25.668]                             if (is.null(name)) 
[13:36:25.668]                               next
[13:36:25.668]                             if (!grepl(pattern, name)) 
[13:36:25.668]                               next
[13:36:25.668]                             invokeRestart(restart)
[13:36:25.668]                             muffled <- TRUE
[13:36:25.668]                             break
[13:36:25.668]                           }
[13:36:25.668]                         }
[13:36:25.668]                       }
[13:36:25.668]                       invisible(muffled)
[13:36:25.668]                     }
[13:36:25.668]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.668]                   }
[13:36:25.668]                 }
[13:36:25.668]                 else {
[13:36:25.668]                   if (TRUE) {
[13:36:25.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.668]                     {
[13:36:25.668]                       inherits <- base::inherits
[13:36:25.668]                       invokeRestart <- base::invokeRestart
[13:36:25.668]                       is.null <- base::is.null
[13:36:25.668]                       muffled <- FALSE
[13:36:25.668]                       if (inherits(cond, "message")) {
[13:36:25.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.668]                         if (muffled) 
[13:36:25.668]                           invokeRestart("muffleMessage")
[13:36:25.668]                       }
[13:36:25.668]                       else if (inherits(cond, "warning")) {
[13:36:25.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.668]                         if (muffled) 
[13:36:25.668]                           invokeRestart("muffleWarning")
[13:36:25.668]                       }
[13:36:25.668]                       else if (inherits(cond, "condition")) {
[13:36:25.668]                         if (!is.null(pattern)) {
[13:36:25.668]                           computeRestarts <- base::computeRestarts
[13:36:25.668]                           grepl <- base::grepl
[13:36:25.668]                           restarts <- computeRestarts(cond)
[13:36:25.668]                           for (restart in restarts) {
[13:36:25.668]                             name <- restart$name
[13:36:25.668]                             if (is.null(name)) 
[13:36:25.668]                               next
[13:36:25.668]                             if (!grepl(pattern, name)) 
[13:36:25.668]                               next
[13:36:25.668]                             invokeRestart(restart)
[13:36:25.668]                             muffled <- TRUE
[13:36:25.668]                             break
[13:36:25.668]                           }
[13:36:25.668]                         }
[13:36:25.668]                       }
[13:36:25.668]                       invisible(muffled)
[13:36:25.668]                     }
[13:36:25.668]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.668]                   }
[13:36:25.668]                 }
[13:36:25.668]             }
[13:36:25.668]         }))
[13:36:25.668]     }, error = function(ex) {
[13:36:25.668]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.668]                 ...future.rng), started = ...future.startTime, 
[13:36:25.668]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.668]             version = "1.8"), class = "FutureResult")
[13:36:25.668]     }, finally = {
[13:36:25.668]         if (!identical(...future.workdir, getwd())) 
[13:36:25.668]             setwd(...future.workdir)
[13:36:25.668]         {
[13:36:25.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.668]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.668]             }
[13:36:25.668]             base::options(...future.oldOptions)
[13:36:25.668]             if (.Platform$OS.type == "windows") {
[13:36:25.668]                 old_names <- names(...future.oldEnvVars)
[13:36:25.668]                 envs <- base::Sys.getenv()
[13:36:25.668]                 names <- names(envs)
[13:36:25.668]                 common <- intersect(names, old_names)
[13:36:25.668]                 added <- setdiff(names, old_names)
[13:36:25.668]                 removed <- setdiff(old_names, names)
[13:36:25.668]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.668]                   envs[common]]
[13:36:25.668]                 NAMES <- toupper(changed)
[13:36:25.668]                 args <- list()
[13:36:25.668]                 for (kk in seq_along(NAMES)) {
[13:36:25.668]                   name <- changed[[kk]]
[13:36:25.668]                   NAME <- NAMES[[kk]]
[13:36:25.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.668]                     next
[13:36:25.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.668]                 }
[13:36:25.668]                 NAMES <- toupper(added)
[13:36:25.668]                 for (kk in seq_along(NAMES)) {
[13:36:25.668]                   name <- added[[kk]]
[13:36:25.668]                   NAME <- NAMES[[kk]]
[13:36:25.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.668]                     next
[13:36:25.668]                   args[[name]] <- ""
[13:36:25.668]                 }
[13:36:25.668]                 NAMES <- toupper(removed)
[13:36:25.668]                 for (kk in seq_along(NAMES)) {
[13:36:25.668]                   name <- removed[[kk]]
[13:36:25.668]                   NAME <- NAMES[[kk]]
[13:36:25.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.668]                     next
[13:36:25.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.668]                 }
[13:36:25.668]                 if (length(args) > 0) 
[13:36:25.668]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.668]             }
[13:36:25.668]             else {
[13:36:25.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.668]             }
[13:36:25.668]             {
[13:36:25.668]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.668]                   0L) {
[13:36:25.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.668]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.668]                   base::options(opts)
[13:36:25.668]                 }
[13:36:25.668]                 {
[13:36:25.668]                   {
[13:36:25.668]                     NULL
[13:36:25.668]                     RNGkind("Mersenne-Twister")
[13:36:25.668]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.668]                       inherits = FALSE)
[13:36:25.668]                   }
[13:36:25.668]                   options(future.plan = NULL)
[13:36:25.668]                   if (is.na(NA_character_)) 
[13:36:25.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.668]                     .init = FALSE)
[13:36:25.668]                 }
[13:36:25.668]             }
[13:36:25.668]         }
[13:36:25.668]     })
[13:36:25.668]     if (TRUE) {
[13:36:25.668]         base::sink(type = "output", split = FALSE)
[13:36:25.668]         if (TRUE) {
[13:36:25.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.668]         }
[13:36:25.668]         else {
[13:36:25.668]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.668]         }
[13:36:25.668]         base::close(...future.stdout)
[13:36:25.668]         ...future.stdout <- NULL
[13:36:25.668]     }
[13:36:25.668]     ...future.result$conditions <- ...future.conditions
[13:36:25.668]     ...future.result$finished <- base::Sys.time()
[13:36:25.668]     ...future.result
[13:36:25.668] }
[13:36:25.670] plan(): Setting new future strategy stack:
[13:36:25.670] List of future strategies:
[13:36:25.670] 1. sequential:
[13:36:25.670]    - args: function (..., envir = parent.frame())
[13:36:25.670]    - tweaked: FALSE
[13:36:25.670]    - call: NULL
[13:36:25.670] plan(): nbrOfWorkers() = 1
[13:36:25.671] plan(): Setting new future strategy stack:
[13:36:25.671] List of future strategies:
[13:36:25.671] 1. sequential:
[13:36:25.671]    - args: function (..., envir = parent.frame())
[13:36:25.671]    - tweaked: FALSE
[13:36:25.671]    - call: plan(strategy)
[13:36:25.671] plan(): nbrOfWorkers() = 1
[13:36:25.671] SequentialFuture started (and completed)
[13:36:25.672] - Launch lazy future ... done
[13:36:25.672] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[13:36:25.672] getGlobalsAndPackages() ...
[13:36:25.672] Searching for globals...
[13:36:25.675] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:36:25.675] Searching for globals ... DONE
[13:36:25.676] Resolving globals: FALSE
[13:36:25.676] 
[13:36:25.676] - packages: [1] ‘future’
[13:36:25.676] getGlobalsAndPackages() ... DONE
[13:36:25.676] run() for ‘Future’ ...
[13:36:25.676] - state: ‘created’
[13:36:25.677] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.677] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.677]   - Field: ‘label’
[13:36:25.677]   - Field: ‘local’
[13:36:25.677]   - Field: ‘owner’
[13:36:25.677]   - Field: ‘envir’
[13:36:25.677]   - Field: ‘packages’
[13:36:25.677]   - Field: ‘gc’
[13:36:25.678]   - Field: ‘conditions’
[13:36:25.678]   - Field: ‘expr’
[13:36:25.678]   - Field: ‘uuid’
[13:36:25.678]   - Field: ‘seed’
[13:36:25.678]   - Field: ‘version’
[13:36:25.678]   - Field: ‘result’
[13:36:25.678]   - Field: ‘asynchronous’
[13:36:25.678]   - Field: ‘calls’
[13:36:25.679]   - Field: ‘globals’
[13:36:25.679]   - Field: ‘stdout’
[13:36:25.679]   - Field: ‘earlySignal’
[13:36:25.679]   - Field: ‘lazy’
[13:36:25.679]   - Field: ‘state’
[13:36:25.679] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.679] - Launch lazy future ...
[13:36:25.680] Packages needed by the future expression (n = 1): ‘future’
[13:36:25.680] Packages needed by future strategies (n = 0): <none>
[13:36:25.680] {
[13:36:25.680]     {
[13:36:25.680]         {
[13:36:25.680]             ...future.startTime <- base::Sys.time()
[13:36:25.680]             {
[13:36:25.680]                 {
[13:36:25.680]                   {
[13:36:25.680]                     {
[13:36:25.680]                       base::local({
[13:36:25.680]                         has_future <- base::requireNamespace("future", 
[13:36:25.680]                           quietly = TRUE)
[13:36:25.680]                         if (has_future) {
[13:36:25.680]                           ns <- base::getNamespace("future")
[13:36:25.680]                           version <- ns[[".package"]][["version"]]
[13:36:25.680]                           if (is.null(version)) 
[13:36:25.680]                             version <- utils::packageVersion("future")
[13:36:25.680]                         }
[13:36:25.680]                         else {
[13:36:25.680]                           version <- NULL
[13:36:25.680]                         }
[13:36:25.680]                         if (!has_future || version < "1.8.0") {
[13:36:25.680]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.680]                             "", base::R.version$version.string), 
[13:36:25.680]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.680]                               "release", "version")], collapse = " "), 
[13:36:25.680]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.680]                             info)
[13:36:25.680]                           info <- base::paste(info, collapse = "; ")
[13:36:25.680]                           if (!has_future) {
[13:36:25.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.680]                               info)
[13:36:25.680]                           }
[13:36:25.680]                           else {
[13:36:25.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.680]                               info, version)
[13:36:25.680]                           }
[13:36:25.680]                           base::stop(msg)
[13:36:25.680]                         }
[13:36:25.680]                       })
[13:36:25.680]                     }
[13:36:25.680]                     base::local({
[13:36:25.680]                       for (pkg in "future") {
[13:36:25.680]                         base::loadNamespace(pkg)
[13:36:25.680]                         base::library(pkg, character.only = TRUE)
[13:36:25.680]                       }
[13:36:25.680]                     })
[13:36:25.680]                   }
[13:36:25.680]                   ...future.strategy.old <- future::plan("list")
[13:36:25.680]                   options(future.plan = NULL)
[13:36:25.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.680]                 }
[13:36:25.680]                 ...future.workdir <- getwd()
[13:36:25.680]             }
[13:36:25.680]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.680]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.680]         }
[13:36:25.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.680]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.680]             base::names(...future.oldOptions))
[13:36:25.680]     }
[13:36:25.680]     if (FALSE) {
[13:36:25.680]     }
[13:36:25.680]     else {
[13:36:25.680]         if (TRUE) {
[13:36:25.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.680]                 open = "w")
[13:36:25.680]         }
[13:36:25.680]         else {
[13:36:25.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.680]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.680]         }
[13:36:25.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.680]             base::sink(type = "output", split = FALSE)
[13:36:25.680]             base::close(...future.stdout)
[13:36:25.680]         }, add = TRUE)
[13:36:25.680]     }
[13:36:25.680]     ...future.frame <- base::sys.nframe()
[13:36:25.680]     ...future.conditions <- base::list()
[13:36:25.680]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.680]     if (FALSE) {
[13:36:25.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.680]     }
[13:36:25.680]     ...future.result <- base::tryCatch({
[13:36:25.680]         base::withCallingHandlers({
[13:36:25.680]             ...future.value <- base::withVisible(base::local({
[13:36:25.680]                 b <- 1
[13:36:25.680]                 c %<-% 2
[13:36:25.680]                 d <- 3
[13:36:25.680]                 4 %->% e
[13:36:25.680]                 b + c + d + e
[13:36:25.680]             }))
[13:36:25.680]             future::FutureResult(value = ...future.value$value, 
[13:36:25.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.680]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.680]                     ...future.globalenv.names))
[13:36:25.680]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.680]         }, condition = base::local({
[13:36:25.680]             c <- base::c
[13:36:25.680]             inherits <- base::inherits
[13:36:25.680]             invokeRestart <- base::invokeRestart
[13:36:25.680]             length <- base::length
[13:36:25.680]             list <- base::list
[13:36:25.680]             seq.int <- base::seq.int
[13:36:25.680]             signalCondition <- base::signalCondition
[13:36:25.680]             sys.calls <- base::sys.calls
[13:36:25.680]             `[[` <- base::`[[`
[13:36:25.680]             `+` <- base::`+`
[13:36:25.680]             `<<-` <- base::`<<-`
[13:36:25.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.680]                   3L)]
[13:36:25.680]             }
[13:36:25.680]             function(cond) {
[13:36:25.680]                 is_error <- inherits(cond, "error")
[13:36:25.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.680]                   NULL)
[13:36:25.680]                 if (is_error) {
[13:36:25.680]                   sessionInformation <- function() {
[13:36:25.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.680]                       search = base::search(), system = base::Sys.info())
[13:36:25.680]                   }
[13:36:25.680]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.680]                     cond$call), session = sessionInformation(), 
[13:36:25.680]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.680]                   signalCondition(cond)
[13:36:25.680]                 }
[13:36:25.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.680]                 "immediateCondition"))) {
[13:36:25.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.680]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.680]                   if (TRUE && !signal) {
[13:36:25.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.680]                     {
[13:36:25.680]                       inherits <- base::inherits
[13:36:25.680]                       invokeRestart <- base::invokeRestart
[13:36:25.680]                       is.null <- base::is.null
[13:36:25.680]                       muffled <- FALSE
[13:36:25.680]                       if (inherits(cond, "message")) {
[13:36:25.680]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.680]                         if (muffled) 
[13:36:25.680]                           invokeRestart("muffleMessage")
[13:36:25.680]                       }
[13:36:25.680]                       else if (inherits(cond, "warning")) {
[13:36:25.680]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.680]                         if (muffled) 
[13:36:25.680]                           invokeRestart("muffleWarning")
[13:36:25.680]                       }
[13:36:25.680]                       else if (inherits(cond, "condition")) {
[13:36:25.680]                         if (!is.null(pattern)) {
[13:36:25.680]                           computeRestarts <- base::computeRestarts
[13:36:25.680]                           grepl <- base::grepl
[13:36:25.680]                           restarts <- computeRestarts(cond)
[13:36:25.680]                           for (restart in restarts) {
[13:36:25.680]                             name <- restart$name
[13:36:25.680]                             if (is.null(name)) 
[13:36:25.680]                               next
[13:36:25.680]                             if (!grepl(pattern, name)) 
[13:36:25.680]                               next
[13:36:25.680]                             invokeRestart(restart)
[13:36:25.680]                             muffled <- TRUE
[13:36:25.680]                             break
[13:36:25.680]                           }
[13:36:25.680]                         }
[13:36:25.680]                       }
[13:36:25.680]                       invisible(muffled)
[13:36:25.680]                     }
[13:36:25.680]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.680]                   }
[13:36:25.680]                 }
[13:36:25.680]                 else {
[13:36:25.680]                   if (TRUE) {
[13:36:25.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.680]                     {
[13:36:25.680]                       inherits <- base::inherits
[13:36:25.680]                       invokeRestart <- base::invokeRestart
[13:36:25.680]                       is.null <- base::is.null
[13:36:25.680]                       muffled <- FALSE
[13:36:25.680]                       if (inherits(cond, "message")) {
[13:36:25.680]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.680]                         if (muffled) 
[13:36:25.680]                           invokeRestart("muffleMessage")
[13:36:25.680]                       }
[13:36:25.680]                       else if (inherits(cond, "warning")) {
[13:36:25.680]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.680]                         if (muffled) 
[13:36:25.680]                           invokeRestart("muffleWarning")
[13:36:25.680]                       }
[13:36:25.680]                       else if (inherits(cond, "condition")) {
[13:36:25.680]                         if (!is.null(pattern)) {
[13:36:25.680]                           computeRestarts <- base::computeRestarts
[13:36:25.680]                           grepl <- base::grepl
[13:36:25.680]                           restarts <- computeRestarts(cond)
[13:36:25.680]                           for (restart in restarts) {
[13:36:25.680]                             name <- restart$name
[13:36:25.680]                             if (is.null(name)) 
[13:36:25.680]                               next
[13:36:25.680]                             if (!grepl(pattern, name)) 
[13:36:25.680]                               next
[13:36:25.680]                             invokeRestart(restart)
[13:36:25.680]                             muffled <- TRUE
[13:36:25.680]                             break
[13:36:25.680]                           }
[13:36:25.680]                         }
[13:36:25.680]                       }
[13:36:25.680]                       invisible(muffled)
[13:36:25.680]                     }
[13:36:25.680]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.680]                   }
[13:36:25.680]                 }
[13:36:25.680]             }
[13:36:25.680]         }))
[13:36:25.680]     }, error = function(ex) {
[13:36:25.680]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.680]                 ...future.rng), started = ...future.startTime, 
[13:36:25.680]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.680]             version = "1.8"), class = "FutureResult")
[13:36:25.680]     }, finally = {
[13:36:25.680]         if (!identical(...future.workdir, getwd())) 
[13:36:25.680]             setwd(...future.workdir)
[13:36:25.680]         {
[13:36:25.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.680]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.680]             }
[13:36:25.680]             base::options(...future.oldOptions)
[13:36:25.680]             if (.Platform$OS.type == "windows") {
[13:36:25.680]                 old_names <- names(...future.oldEnvVars)
[13:36:25.680]                 envs <- base::Sys.getenv()
[13:36:25.680]                 names <- names(envs)
[13:36:25.680]                 common <- intersect(names, old_names)
[13:36:25.680]                 added <- setdiff(names, old_names)
[13:36:25.680]                 removed <- setdiff(old_names, names)
[13:36:25.680]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.680]                   envs[common]]
[13:36:25.680]                 NAMES <- toupper(changed)
[13:36:25.680]                 args <- list()
[13:36:25.680]                 for (kk in seq_along(NAMES)) {
[13:36:25.680]                   name <- changed[[kk]]
[13:36:25.680]                   NAME <- NAMES[[kk]]
[13:36:25.680]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.680]                     next
[13:36:25.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.680]                 }
[13:36:25.680]                 NAMES <- toupper(added)
[13:36:25.680]                 for (kk in seq_along(NAMES)) {
[13:36:25.680]                   name <- added[[kk]]
[13:36:25.680]                   NAME <- NAMES[[kk]]
[13:36:25.680]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.680]                     next
[13:36:25.680]                   args[[name]] <- ""
[13:36:25.680]                 }
[13:36:25.680]                 NAMES <- toupper(removed)
[13:36:25.680]                 for (kk in seq_along(NAMES)) {
[13:36:25.680]                   name <- removed[[kk]]
[13:36:25.680]                   NAME <- NAMES[[kk]]
[13:36:25.680]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.680]                     next
[13:36:25.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.680]                 }
[13:36:25.680]                 if (length(args) > 0) 
[13:36:25.680]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.680]             }
[13:36:25.680]             else {
[13:36:25.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.680]             }
[13:36:25.680]             {
[13:36:25.680]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.680]                   0L) {
[13:36:25.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.680]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.680]                   base::options(opts)
[13:36:25.680]                 }
[13:36:25.680]                 {
[13:36:25.680]                   {
[13:36:25.680]                     NULL
[13:36:25.680]                     RNGkind("Mersenne-Twister")
[13:36:25.680]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.680]                       inherits = FALSE)
[13:36:25.680]                   }
[13:36:25.680]                   options(future.plan = NULL)
[13:36:25.680]                   if (is.na(NA_character_)) 
[13:36:25.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.680]                     .init = FALSE)
[13:36:25.680]                 }
[13:36:25.680]             }
[13:36:25.680]         }
[13:36:25.680]     })
[13:36:25.680]     if (TRUE) {
[13:36:25.680]         base::sink(type = "output", split = FALSE)
[13:36:25.680]         if (TRUE) {
[13:36:25.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.680]         }
[13:36:25.680]         else {
[13:36:25.680]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.680]         }
[13:36:25.680]         base::close(...future.stdout)
[13:36:25.680]         ...future.stdout <- NULL
[13:36:25.680]     }
[13:36:25.680]     ...future.result$conditions <- ...future.conditions
[13:36:25.680]     ...future.result$finished <- base::Sys.time()
[13:36:25.680]     ...future.result
[13:36:25.680] }
[13:36:25.682] plan(): Setting new future strategy stack:
[13:36:25.683] List of future strategies:
[13:36:25.683] 1. sequential:
[13:36:25.683]    - args: function (..., envir = parent.frame())
[13:36:25.683]    - tweaked: FALSE
[13:36:25.683]    - call: NULL
[13:36:25.683] plan(): nbrOfWorkers() = 1
[13:36:25.715] plan(): Setting new future strategy stack:
[13:36:25.715] List of future strategies:
[13:36:25.715] 1. sequential:
[13:36:25.715]    - args: function (..., envir = parent.frame())
[13:36:25.715]    - tweaked: FALSE
[13:36:25.715]    - call: plan(strategy)
[13:36:25.715] plan(): nbrOfWorkers() = 1
[13:36:25.715] SequentialFuture started (and completed)
[13:36:25.715] signalConditions() ...
[13:36:25.715]  - include = ‘immediateCondition’
[13:36:25.716]  - exclude = 
[13:36:25.716]  - resignal = FALSE
[13:36:25.716]  - Number of conditions: 88
[13:36:25.716] signalConditions() ... done
[13:36:25.716] - Launch lazy future ... done
[13:36:25.716] run() for ‘SequentialFuture’ ... done
[13:36:25.716] signalConditions() ...
[13:36:25.716]  - include = ‘immediateCondition’
[13:36:25.716]  - exclude = 
[13:36:25.716]  - resignal = FALSE
[13:36:25.717]  - Number of conditions: 88
[13:36:25.717] signalConditions() ... done
[13:36:25.717] Future state: ‘finished’
[13:36:25.717] signalConditions() ...
[13:36:25.717]  - include = ‘condition’
[13:36:25.717]  - exclude = ‘immediateCondition’
[13:36:25.717]  - resignal = TRUE
[13:36:25.717]  - Number of conditions: 88
[13:36:25.717]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.683] getGlobalsAndPackages() ...
[13:36:25.717]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.684] Searching for globals...
[13:36:25.718]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.697] 
[13:36:25.718]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.697] Searching for globals ... DONE
[13:36:25.718]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.697] - globals: [0] <none>
[13:36:25.718]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.698] getGlobalsAndPackages() ... DONE
[13:36:25.718]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.698] run() for ‘Future’ ...
[13:36:25.718]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.698] - state: ‘created’
[13:36:25.718]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.718]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.719]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.719]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘label’
[13:36:25.719]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘local’
[13:36:25.719]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘owner’
[13:36:25.719]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘envir’
[13:36:25.719]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘packages’
[13:36:25.719]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘gc’
[13:36:25.719]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘conditions’
[13:36:25.720]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘expr’
[13:36:25.720]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.699]   - Field: ‘uuid’
[13:36:25.720]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘seed’
[13:36:25.720]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘version’
[13:36:25.720]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘result’
[13:36:25.720]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘asynchronous’
[13:36:25.720]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘calls’
[13:36:25.720]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘globals’
[13:36:25.721]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘stdout’
[13:36:25.721]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘earlySignal’
[13:36:25.721]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘lazy’
[13:36:25.721]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700]   - Field: ‘state’
[13:36:25.721]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.721]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.701] - Launch lazy future ...
[13:36:25.721]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.701] Packages needed by the future expression (n = 0): <none>
[13:36:25.721]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.701] Packages needed by future strategies (n = 0): <none>
[13:36:25.722]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.701] {
[13:36:25.701]     {
[13:36:25.701]         {
[13:36:25.701]             ...future.startTime <- base::Sys.time()
[13:36:25.701]             {
[13:36:25.701]                 {
[13:36:25.701]                   {
[13:36:25.701]                     base::local({
[13:36:25.701]                       has_future <- base::requireNamespace("future", 
[13:36:25.701]                         quietly = TRUE)
[13:36:25.701]                       if (has_future) {
[13:36:25.701]                         ns <- base::getNamespace("future")
[13:36:25.701]                         version <- ns[[".package"]][["version"]]
[13:36:25.701]                         if (is.null(version)) 
[13:36:25.701]                           version <- utils::packageVersion("future")
[13:36:25.701]                       }
[13:36:25.701]                       else {
[13:36:25.701]                         version <- NULL
[13:36:25.701]                       }
[13:36:25.701]                       if (!has_future || version < "1.8.0") {
[13:36:25.701]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.701]                           "", base::R.version$version.string), 
[13:36:25.701]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.701]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.701]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.701]                             "release", "version")], collapse = " "), 
[13:36:25.701]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.701]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.701]                           info)
[13:36:25.701]                         info <- base::paste(info, collapse = "; ")
[13:36:25.701]                         if (!has_future) {
[13:36:25.701]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.701]                             info)
[13:36:25.701]                         }
[13:36:25.701]                         else {
[13:36:25.701]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.701]                             info, version)
[13:36:25.701]                         }
[13:36:25.701]                         base::stop(msg)
[13:36:25.701]                       }
[13:36:25.701]                     })
[13:36:25.701]                   }
[13:36:25.701]                   ...future.strategy.old <- future::plan("list")
[13:36:25.701]                   options(future.plan = NULL)
[13:36:25.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.701]                 }
[13:36:25.701]                 ...future.workdir <- getwd()
[13:36:25.701]             }
[13:36:25.701]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.701]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.701]         }
[13:36:25.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.701]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.701]             base::names(...future.oldOptions))
[13:36:25.701]     }
[13:36:25.701]     if (FALSE) {
[13:36:25.701]     }
[13:36:25.701]     else {
[13:36:25.701]         if (TRUE) {
[13:36:25.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.701]                 open = "w")
[13:36:25.701]         }
[13:36:25.701]         else {
[13:36:25.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.701]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.701]         }
[13:36:25.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.701]             base::sink(type = "output", split = FALSE)
[13:36:25.701]             base::close(...future.stdout)
[13:36:25.701]         }, add = TRUE)
[13:36:25.701]     }
[13:36:25.701]     ...future.frame <- base::sys.nframe()
[13:36:25.701]     ...future.conditions <- base::list()
[13:36:25.701]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.701]     if (FALSE) {
[13:36:25.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.701]     }
[13:36:25.701]     ...future.result <- base::tryCatch({
[13:36:25.701]         base::withCallingHandlers({
[13:36:25.701]             ...future.value <- base::withVisible(base::local(2))
[13:36:25.701]             future::FutureResult(value = ...future.value$value, 
[13:36:25.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.701]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.701]                     ...future.globalenv.names))
[13:36:25.701]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.701]         }, condition = base::local({
[13:36:25.701]             c <- base::c
[13:36:25.701]             inherits <- base::inherits
[13:36:25.701]             invokeRestart <- base::invokeRestart
[13:36:25.701]             length <- base::length
[13:36:25.701]             list <- base::list
[13:36:25.701]             seq.int <- base::seq.int
[13:36:25.701]             signalCondition <- base::signalCondition
[13:36:25.701]             sys.calls <- base::sys.calls
[13:36:25.701]             `[[` <- base::`[[`
[13:36:25.701]             `+` <- base::`+`
[13:36:25.701]             `<<-` <- base::`<<-`
[13:36:25.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.701]                   3L)]
[13:36:25.701]             }
[13:36:25.701]             function(cond) {
[13:36:25.701]                 is_error <- inherits(cond, "error")
[13:36:25.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.701]                   NULL)
[13:36:25.701]                 if (is_error) {
[13:36:25.701]                   sessionInformation <- function() {
[13:36:25.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.701]                       search = base::search(), system = base::Sys.info())
[13:36:25.701]                   }
[13:36:25.701]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.701]                     cond$call), session = sessionInformation(), 
[13:36:25.701]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.701]                   signalCondition(cond)
[13:36:25.701]                 }
[13:36:25.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.701]                 "immediateCondition"))) {
[13:36:25.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.701]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.701]                   if (TRUE && !signal) {
[13:36:25.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.701]                     {
[13:36:25.701]                       inherits <- base::inherits
[13:36:25.701]                       invokeRestart <- base::invokeRestart
[13:36:25.701]                       is.null <- base::is.null
[13:36:25.701]                       muffled <- FALSE
[13:36:25.701]                       if (inherits(cond, "message")) {
[13:36:25.701]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.701]                         if (muffled) 
[13:36:25.701]                           invokeRestart("muffleMessage")
[13:36:25.701]                       }
[13:36:25.701]                       else if (inherits(cond, "warning")) {
[13:36:25.701]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.701]                         if (muffled) 
[13:36:25.701]                           invokeRestart("muffleWarning")
[13:36:25.701]                       }
[13:36:25.701]                       else if (inherits(cond, "condition")) {
[13:36:25.701]                         if (!is.null(pattern)) {
[13:36:25.701]                           computeRestarts <- base::computeRestarts
[13:36:25.701]                           grepl <- base::grepl
[13:36:25.701]                           restarts <- computeRestarts(cond)
[13:36:25.701]                           for (restart in restarts) {
[13:36:25.701]                             name <- restart$name
[13:36:25.701]                             if (is.null(name)) 
[13:36:25.701]                               next
[13:36:25.701]                             if (!grepl(pattern, name)) 
[13:36:25.701]                               next
[13:36:25.701]                             invokeRestart(restart)
[13:36:25.701]                             muffled <- TRUE
[13:36:25.701]                             break
[13:36:25.701]                           }
[13:36:25.701]                         }
[13:36:25.701]                       }
[13:36:25.701]                       invisible(muffled)
[13:36:25.701]                     }
[13:36:25.701]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.701]                   }
[13:36:25.701]                 }
[13:36:25.701]                 else {
[13:36:25.701]                   if (TRUE) {
[13:36:25.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.701]                     {
[13:36:25.701]                       inherits <- base::inherits
[13:36:25.701]                       invokeRestart <- base::invokeRestart
[13:36:25.701]                       is.null <- base::is.null
[13:36:25.701]                       muffled <- FALSE
[13:36:25.701]                       if (inherits(cond, "message")) {
[13:36:25.701]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.701]                         if (muffled) 
[13:36:25.701]                           invokeRestart("muffleMessage")
[13:36:25.701]                       }
[13:36:25.701]                       else if (inherits(cond, "warning")) {
[13:36:25.701]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.701]                         if (muffled) 
[13:36:25.701]                           invokeRestart("muffleWarning")
[13:36:25.701]                       }
[13:36:25.701]                       else if (inherits(cond, "condition")) {
[13:36:25.701]                         if (!is.null(pattern)) {
[13:36:25.701]                           computeRestarts <- base::computeRestarts
[13:36:25.701]                           grepl <- base::grepl
[13:36:25.701]                           restarts <- computeRestarts(cond)
[13:36:25.701]                           for (restart in restarts) {
[13:36:25.701]                             name <- restart$name
[13:36:25.701]                             if (is.null(name)) 
[13:36:25.701]                               next
[13:36:25.701]                             if (!grepl(pattern, name)) 
[13:36:25.701]                               next
[13:36:25.701]                             invokeRestart(restart)
[13:36:25.701]                             muffled <- TRUE
[13:36:25.701]                             break
[13:36:25.701]                           }
[13:36:25.701]                         }
[13:36:25.701]                       }
[13:36:25.701]                       invisible(muffled)
[13:36:25.701]                     }
[13:36:25.701]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.701]                   }
[13:36:25.701]                 }
[13:36:25.701]             }
[13:36:25.701]         }))
[13:36:25.701]     }, error = function(ex) {
[13:36:25.701]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.701]                 ...future.rng), started = ...future.startTime, 
[13:36:25.701]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.701]             version = "1.8"), class = "FutureResult")
[13:36:25.701]     }, finally = {
[13:36:25.701]         if (!identical(...future.workdir, getwd())) 
[13:36:25.701]             setwd(...future.workdir)
[13:36:25.701]         {
[13:36:25.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.701]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.701]             }
[13:36:25.701]             base::options(...future.oldOptions)
[13:36:25.701]             if (.Platform$OS.type == "windows") {
[13:36:25.701]                 old_names <- names(...future.oldEnvVars)
[13:36:25.701]                 envs <- base::Sys.getenv()
[13:36:25.701]                 names <- names(envs)
[13:36:25.701]                 common <- intersect(names, old_names)
[13:36:25.701]                 added <- setdiff(names, old_names)
[13:36:25.701]                 removed <- setdiff(old_names, names)
[13:36:25.701]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.701]                   envs[common]]
[13:36:25.701]                 NAMES <- toupper(changed)
[13:36:25.701]                 args <- list()
[13:36:25.701]                 for (kk in seq_along(NAMES)) {
[13:36:25.701]                   name <- changed[[kk]]
[13:36:25.701]                   NAME <- NAMES[[kk]]
[13:36:25.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.701]                     next
[13:36:25.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.701]                 }
[13:36:25.701]                 NAMES <- toupper(added)
[13:36:25.701]                 for (kk in seq_along(NAMES)) {
[13:36:25.701]                   name <- added[[kk]]
[13:36:25.701]                   NAME <- NAMES[[kk]]
[13:36:25.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.701]                     next
[13:36:25.701]                   args[[name]] <- ""
[13:36:25.701]                 }
[13:36:25.701]                 NAMES <- toupper(removed)
[13:36:25.701]                 for (kk in seq_along(NAMES)) {
[13:36:25.701]                   name <- removed[[kk]]
[13:36:25.701]                   NAME <- NAMES[[kk]]
[13:36:25.701]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.701]                     next
[13:36:25.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.701]                 }
[13:36:25.701]                 if (length(args) > 0) 
[13:36:25.701]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.701]             }
[13:36:25.701]             else {
[13:36:25.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.701]             }
[13:36:25.701]             {
[13:36:25.701]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.701]                   0L) {
[13:36:25.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.701]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.701]                   base::options(opts)
[13:36:25.701]                 }
[13:36:25.701]                 {
[13:36:25.701]                   {
[13:36:25.701]                     NULL
[13:36:25.701]                     RNGkind("Mersenne-Twister")
[13:36:25.701]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.701]                       inherits = FALSE)
[13:36:25.701]                   }
[13:36:25.701]                   options(future.plan = NULL)
[13:36:25.701]                   if (is.na(NA_character_)) 
[13:36:25.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.701]                     .init = FALSE)
[13:36:25.701]                 }
[13:36:25.701]             }
[13:36:25.701]         }
[13:36:25.701]     })
[13:36:25.701]     if (TRUE) {
[13:36:25.701]         base::sink(type = "output", split = FALSE)
[13:36:25.701]         if (TRUE) {
[13:36:25.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.701]         }
[13:36:25.701]         else {
[13:36:25.701]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.701]         }
[13:36:25.701]         base::close(...future.stdout)
[13:36:25.701]         ...future.stdout <- NULL
[13:36:25.701]     }
[13:36:25.701]     ...future.result$conditions <- ...future.conditions
[13:36:25.701]     ...future.result$finished <- base::Sys.time()
[13:36:25.701]     ...future.result
[13:36:25.701] }
[13:36:25.722]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.704] plan(): Setting new future strategy stack:
[13:36:25.722]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.704] List of future strategies:
[13:36:25.704] 1. sequential:
[13:36:25.704]    - args: function (..., envir = parent.frame())
[13:36:25.704]    - tweaked: FALSE
[13:36:25.704]    - call: NULL
[13:36:25.722]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.704] plan(): nbrOfWorkers() = 1
[13:36:25.722]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.705] plan(): Setting new future strategy stack:
[13:36:25.722]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.705] List of future strategies:
[13:36:25.705] 1. sequential:
[13:36:25.705]    - args: function (..., envir = parent.frame())
[13:36:25.705]    - tweaked: FALSE
[13:36:25.705]    - call: NULL
[13:36:25.722]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.706] plan(): nbrOfWorkers() = 1
[13:36:25.722]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.706] SequentialFuture started (and completed)
[13:36:25.723]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.706] - Launch lazy future ... done
[13:36:25.723]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.706] run() for ‘SequentialFuture’ ... done
[13:36:25.723]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.706] getGlobalsAndPackages() ...
[13:36:25.723]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.706] Searching for globals...
[13:36:25.723]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] 
[13:36:25.723]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] Searching for globals ... DONE
[13:36:25.723]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] - globals: [0] <none>
[13:36:25.723]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] getGlobalsAndPackages() ... DONE
[13:36:25.724]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] run() for ‘Future’ ...
[13:36:25.724]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] - state: ‘created’
[13:36:25.724]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.707] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.724]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.724]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.724]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘label’
[13:36:25.724]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘local’
[13:36:25.724]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘owner’
[13:36:25.725]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘envir’
[13:36:25.725]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘packages’
[13:36:25.725]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘gc’
[13:36:25.725]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.708]   - Field: ‘conditions’
[13:36:25.725]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘expr’
[13:36:25.725]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘uuid’
[13:36:25.725]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘seed’
[13:36:25.725]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘version’
[13:36:25.726]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘result’
[13:36:25.727]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘asynchronous’
[13:36:25.727]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘calls’
[13:36:25.727]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘globals’
[13:36:25.727]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘stdout’
[13:36:25.727]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.709]   - Field: ‘earlySignal’
[13:36:25.727]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.710]   - Field: ‘lazy’
[13:36:25.727]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.710]   - Field: ‘state’
[13:36:25.728]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.728]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.710] - Launch lazy future ...
[13:36:25.728]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.710] Packages needed by the future expression (n = 0): <none>
[13:36:25.728]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.710] Packages needed by future strategies (n = 0): <none>
[13:36:25.728]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.711] {
[13:36:25.711]     {
[13:36:25.711]         {
[13:36:25.711]             ...future.startTime <- base::Sys.time()
[13:36:25.711]             {
[13:36:25.711]                 {
[13:36:25.711]                   {
[13:36:25.711]                     base::local({
[13:36:25.711]                       has_future <- base::requireNamespace("future", 
[13:36:25.711]                         quietly = TRUE)
[13:36:25.711]                       if (has_future) {
[13:36:25.711]                         ns <- base::getNamespace("future")
[13:36:25.711]                         version <- ns[[".package"]][["version"]]
[13:36:25.711]                         if (is.null(version)) 
[13:36:25.711]                           version <- utils::packageVersion("future")
[13:36:25.711]                       }
[13:36:25.711]                       else {
[13:36:25.711]                         version <- NULL
[13:36:25.711]                       }
[13:36:25.711]                       if (!has_future || version < "1.8.0") {
[13:36:25.711]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.711]                           "", base::R.version$version.string), 
[13:36:25.711]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.711]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.711]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.711]                             "release", "version")], collapse = " "), 
[13:36:25.711]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.711]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.711]                           info)
[13:36:25.711]                         info <- base::paste(info, collapse = "; ")
[13:36:25.711]                         if (!has_future) {
[13:36:25.711]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.711]                             info)
[13:36:25.711]                         }
[13:36:25.711]                         else {
[13:36:25.711]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.711]                             info, version)
[13:36:25.711]                         }
[13:36:25.711]                         base::stop(msg)
[13:36:25.711]                       }
[13:36:25.711]                     })
[13:36:25.711]                   }
[13:36:25.711]                   ...future.strategy.old <- future::plan("list")
[13:36:25.711]                   options(future.plan = NULL)
[13:36:25.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.711]                 }
[13:36:25.711]                 ...future.workdir <- getwd()
[13:36:25.711]             }
[13:36:25.711]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.711]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.711]         }
[13:36:25.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.711]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.711]             base::names(...future.oldOptions))
[13:36:25.711]     }
[13:36:25.711]     if (FALSE) {
[13:36:25.711]     }
[13:36:25.711]     else {
[13:36:25.711]         if (TRUE) {
[13:36:25.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.711]                 open = "w")
[13:36:25.711]         }
[13:36:25.711]         else {
[13:36:25.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.711]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.711]         }
[13:36:25.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.711]             base::sink(type = "output", split = FALSE)
[13:36:25.711]             base::close(...future.stdout)
[13:36:25.711]         }, add = TRUE)
[13:36:25.711]     }
[13:36:25.711]     ...future.frame <- base::sys.nframe()
[13:36:25.711]     ...future.conditions <- base::list()
[13:36:25.711]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.711]     if (FALSE) {
[13:36:25.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.711]     }
[13:36:25.711]     ...future.result <- base::tryCatch({
[13:36:25.711]         base::withCallingHandlers({
[13:36:25.711]             ...future.value <- base::withVisible(base::local(4))
[13:36:25.711]             future::FutureResult(value = ...future.value$value, 
[13:36:25.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.711]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.711]                     ...future.globalenv.names))
[13:36:25.711]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.711]         }, condition = base::local({
[13:36:25.711]             c <- base::c
[13:36:25.711]             inherits <- base::inherits
[13:36:25.711]             invokeRestart <- base::invokeRestart
[13:36:25.711]             length <- base::length
[13:36:25.711]             list <- base::list
[13:36:25.711]             seq.int <- base::seq.int
[13:36:25.711]             signalCondition <- base::signalCondition
[13:36:25.711]             sys.calls <- base::sys.calls
[13:36:25.711]             `[[` <- base::`[[`
[13:36:25.711]             `+` <- base::`+`
[13:36:25.711]             `<<-` <- base::`<<-`
[13:36:25.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.711]                   3L)]
[13:36:25.711]             }
[13:36:25.711]             function(cond) {
[13:36:25.711]                 is_error <- inherits(cond, "error")
[13:36:25.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.711]                   NULL)
[13:36:25.711]                 if (is_error) {
[13:36:25.711]                   sessionInformation <- function() {
[13:36:25.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.711]                       search = base::search(), system = base::Sys.info())
[13:36:25.711]                   }
[13:36:25.711]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.711]                     cond$call), session = sessionInformation(), 
[13:36:25.711]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.711]                   signalCondition(cond)
[13:36:25.711]                 }
[13:36:25.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.711]                 "immediateCondition"))) {
[13:36:25.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.711]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.711]                   if (TRUE && !signal) {
[13:36:25.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.711]                     {
[13:36:25.711]                       inherits <- base::inherits
[13:36:25.711]                       invokeRestart <- base::invokeRestart
[13:36:25.711]                       is.null <- base::is.null
[13:36:25.711]                       muffled <- FALSE
[13:36:25.711]                       if (inherits(cond, "message")) {
[13:36:25.711]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.711]                         if (muffled) 
[13:36:25.711]                           invokeRestart("muffleMessage")
[13:36:25.711]                       }
[13:36:25.711]                       else if (inherits(cond, "warning")) {
[13:36:25.711]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.711]                         if (muffled) 
[13:36:25.711]                           invokeRestart("muffleWarning")
[13:36:25.711]                       }
[13:36:25.711]                       else if (inherits(cond, "condition")) {
[13:36:25.711]                         if (!is.null(pattern)) {
[13:36:25.711]                           computeRestarts <- base::computeRestarts
[13:36:25.711]                           grepl <- base::grepl
[13:36:25.711]                           restarts <- computeRestarts(cond)
[13:36:25.711]                           for (restart in restarts) {
[13:36:25.711]                             name <- restart$name
[13:36:25.711]                             if (is.null(name)) 
[13:36:25.711]                               next
[13:36:25.711]                             if (!grepl(pattern, name)) 
[13:36:25.711]                               next
[13:36:25.711]                             invokeRestart(restart)
[13:36:25.711]                             muffled <- TRUE
[13:36:25.711]                             break
[13:36:25.711]                           }
[13:36:25.711]                         }
[13:36:25.711]                       }
[13:36:25.711]                       invisible(muffled)
[13:36:25.711]                     }
[13:36:25.711]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.711]                   }
[13:36:25.711]                 }
[13:36:25.711]                 else {
[13:36:25.711]                   if (TRUE) {
[13:36:25.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.711]                     {
[13:36:25.711]                       inherits <- base::inherits
[13:36:25.711]                       invokeRestart <- base::invokeRestart
[13:36:25.711]                       is.null <- base::is.null
[13:36:25.711]                       muffled <- FALSE
[13:36:25.711]                       if (inherits(cond, "message")) {
[13:36:25.711]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.711]                         if (muffled) 
[13:36:25.711]                           invokeRestart("muffleMessage")
[13:36:25.711]                       }
[13:36:25.711]                       else if (inherits(cond, "warning")) {
[13:36:25.711]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.711]                         if (muffled) 
[13:36:25.711]                           invokeRestart("muffleWarning")
[13:36:25.711]                       }
[13:36:25.711]                       else if (inherits(cond, "condition")) {
[13:36:25.711]                         if (!is.null(pattern)) {
[13:36:25.711]                           computeRestarts <- base::computeRestarts
[13:36:25.711]                           grepl <- base::grepl
[13:36:25.711]                           restarts <- computeRestarts(cond)
[13:36:25.711]                           for (restart in restarts) {
[13:36:25.711]                             name <- restart$name
[13:36:25.711]                             if (is.null(name)) 
[13:36:25.711]                               next
[13:36:25.711]                             if (!grepl(pattern, name)) 
[13:36:25.711]                               next
[13:36:25.711]                             invokeRestart(restart)
[13:36:25.711]                             muffled <- TRUE
[13:36:25.711]                             break
[13:36:25.711]                           }
[13:36:25.711]                         }
[13:36:25.711]                       }
[13:36:25.711]                       invisible(muffled)
[13:36:25.711]                     }
[13:36:25.711]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.711]                   }
[13:36:25.711]                 }
[13:36:25.711]             }
[13:36:25.711]         }))
[13:36:25.711]     }, error = function(ex) {
[13:36:25.711]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.711]                 ...future.rng), started = ...future.startTime, 
[13:36:25.711]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.711]             version = "1.8"), class = "FutureResult")
[13:36:25.711]     }, finally = {
[13:36:25.711]         if (!identical(...future.workdir, getwd())) 
[13:36:25.711]             setwd(...future.workdir)
[13:36:25.711]         {
[13:36:25.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.711]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.711]             }
[13:36:25.711]             base::options(...future.oldOptions)
[13:36:25.711]             if (.Platform$OS.type == "windows") {
[13:36:25.711]                 old_names <- names(...future.oldEnvVars)
[13:36:25.711]                 envs <- base::Sys.getenv()
[13:36:25.711]                 names <- names(envs)
[13:36:25.711]                 common <- intersect(names, old_names)
[13:36:25.711]                 added <- setdiff(names, old_names)
[13:36:25.711]                 removed <- setdiff(old_names, names)
[13:36:25.711]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.711]                   envs[common]]
[13:36:25.711]                 NAMES <- toupper(changed)
[13:36:25.711]                 args <- list()
[13:36:25.711]                 for (kk in seq_along(NAMES)) {
[13:36:25.711]                   name <- changed[[kk]]
[13:36:25.711]                   NAME <- NAMES[[kk]]
[13:36:25.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.711]                     next
[13:36:25.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.711]                 }
[13:36:25.711]                 NAMES <- toupper(added)
[13:36:25.711]                 for (kk in seq_along(NAMES)) {
[13:36:25.711]                   name <- added[[kk]]
[13:36:25.711]                   NAME <- NAMES[[kk]]
[13:36:25.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.711]                     next
[13:36:25.711]                   args[[name]] <- ""
[13:36:25.711]                 }
[13:36:25.711]                 NAMES <- toupper(removed)
[13:36:25.711]                 for (kk in seq_along(NAMES)) {
[13:36:25.711]                   name <- removed[[kk]]
[13:36:25.711]                   NAME <- NAMES[[kk]]
[13:36:25.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.711]                     next
[13:36:25.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.711]                 }
[13:36:25.711]                 if (length(args) > 0) 
[13:36:25.711]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.711]             }
[13:36:25.711]             else {
[13:36:25.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.711]             }
[13:36:25.711]             {
[13:36:25.711]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.711]                   0L) {
[13:36:25.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.711]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.711]                   base::options(opts)
[13:36:25.711]                 }
[13:36:25.711]                 {
[13:36:25.711]                   {
[13:36:25.711]                     NULL
[13:36:25.711]                     RNGkind("Mersenne-Twister")
[13:36:25.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.711]                       inherits = FALSE)
[13:36:25.711]                   }
[13:36:25.711]                   options(future.plan = NULL)
[13:36:25.711]                   if (is.na(NA_character_)) 
[13:36:25.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.711]                     .init = FALSE)
[13:36:25.711]                 }
[13:36:25.711]             }
[13:36:25.711]         }
[13:36:25.711]     })
[13:36:25.711]     if (TRUE) {
[13:36:25.711]         base::sink(type = "output", split = FALSE)
[13:36:25.711]         if (TRUE) {
[13:36:25.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.711]         }
[13:36:25.711]         else {
[13:36:25.711]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.711]         }
[13:36:25.711]         base::close(...future.stdout)
[13:36:25.711]         ...future.stdout <- NULL
[13:36:25.711]     }
[13:36:25.711]     ...future.result$conditions <- ...future.conditions
[13:36:25.711]     ...future.result$finished <- base::Sys.time()
[13:36:25.711]     ...future.result
[13:36:25.711] }
[13:36:25.728]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.712] plan(): Setting new future strategy stack:
[13:36:25.728]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.712] List of future strategies:
[13:36:25.712] 1. sequential:
[13:36:25.712]    - args: function (..., envir = parent.frame())
[13:36:25.712]    - tweaked: FALSE
[13:36:25.712]    - call: NULL
[13:36:25.728]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.713] plan(): nbrOfWorkers() = 1
[13:36:25.729]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.713] plan(): Setting new future strategy stack:
[13:36:25.729]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.713] List of future strategies:
[13:36:25.713] 1. sequential:
[13:36:25.713]    - args: function (..., envir = parent.frame())
[13:36:25.713]    - tweaked: FALSE
[13:36:25.713]    - call: NULL
[13:36:25.729]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.714] plan(): nbrOfWorkers() = 1
[13:36:25.729]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.714] SequentialFuture started (and completed)
[13:36:25.729]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.714] - Launch lazy future ... done
[13:36:25.729]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:25.714] run() for ‘SequentialFuture’ ... done
[13:36:25.729] signalConditions() ... done
a = 10
[13:36:25.730] getGlobalsAndPackages() ...
[13:36:25.730] Searching for globals...
[13:36:25.730] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:36:25.731] Searching for globals ... DONE
[13:36:25.731] Resolving globals: FALSE
[13:36:25.731] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.731] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:25.731] - globals: [1] ‘a’
[13:36:25.732] 
[13:36:25.732] getGlobalsAndPackages() ... DONE
[13:36:25.732] run() for ‘Future’ ...
[13:36:25.732] - state: ‘created’
[13:36:25.732] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:25.732] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:25.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:25.733]   - Field: ‘label’
[13:36:25.733]   - Field: ‘local’
[13:36:25.733]   - Field: ‘owner’
[13:36:25.733]   - Field: ‘envir’
[13:36:25.733]   - Field: ‘packages’
[13:36:25.733]   - Field: ‘gc’
[13:36:25.733]   - Field: ‘conditions’
[13:36:25.733]   - Field: ‘expr’
[13:36:25.733]   - Field: ‘uuid’
[13:36:25.733]   - Field: ‘seed’
[13:36:25.733]   - Field: ‘version’
[13:36:25.733]   - Field: ‘result’
[13:36:25.734]   - Field: ‘asynchronous’
[13:36:25.734]   - Field: ‘calls’
[13:36:25.734]   - Field: ‘globals’
[13:36:25.734]   - Field: ‘stdout’
[13:36:25.734]   - Field: ‘earlySignal’
[13:36:25.734]   - Field: ‘lazy’
[13:36:25.734]   - Field: ‘state’
[13:36:25.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:25.734] - Launch lazy future ...
[13:36:25.734] Packages needed by the future expression (n = 0): <none>
[13:36:25.735] Packages needed by future strategies (n = 0): <none>
[13:36:25.735] {
[13:36:25.735]     {
[13:36:25.735]         {
[13:36:25.735]             ...future.startTime <- base::Sys.time()
[13:36:25.735]             {
[13:36:25.735]                 {
[13:36:25.735]                   {
[13:36:25.735]                     base::local({
[13:36:25.735]                       has_future <- base::requireNamespace("future", 
[13:36:25.735]                         quietly = TRUE)
[13:36:25.735]                       if (has_future) {
[13:36:25.735]                         ns <- base::getNamespace("future")
[13:36:25.735]                         version <- ns[[".package"]][["version"]]
[13:36:25.735]                         if (is.null(version)) 
[13:36:25.735]                           version <- utils::packageVersion("future")
[13:36:25.735]                       }
[13:36:25.735]                       else {
[13:36:25.735]                         version <- NULL
[13:36:25.735]                       }
[13:36:25.735]                       if (!has_future || version < "1.8.0") {
[13:36:25.735]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.735]                           "", base::R.version$version.string), 
[13:36:25.735]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:25.735]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.735]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.735]                             "release", "version")], collapse = " "), 
[13:36:25.735]                           hostname = base::Sys.info()[["nodename"]])
[13:36:25.735]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.735]                           info)
[13:36:25.735]                         info <- base::paste(info, collapse = "; ")
[13:36:25.735]                         if (!has_future) {
[13:36:25.735]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.735]                             info)
[13:36:25.735]                         }
[13:36:25.735]                         else {
[13:36:25.735]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.735]                             info, version)
[13:36:25.735]                         }
[13:36:25.735]                         base::stop(msg)
[13:36:25.735]                       }
[13:36:25.735]                     })
[13:36:25.735]                   }
[13:36:25.735]                   ...future.strategy.old <- future::plan("list")
[13:36:25.735]                   options(future.plan = NULL)
[13:36:25.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.735]                 }
[13:36:25.735]                 ...future.workdir <- getwd()
[13:36:25.735]             }
[13:36:25.735]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.735]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.735]         }
[13:36:25.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.735]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.735]             base::names(...future.oldOptions))
[13:36:25.735]     }
[13:36:25.735]     if (FALSE) {
[13:36:25.735]     }
[13:36:25.735]     else {
[13:36:25.735]         if (TRUE) {
[13:36:25.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.735]                 open = "w")
[13:36:25.735]         }
[13:36:25.735]         else {
[13:36:25.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.735]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.735]         }
[13:36:25.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.735]             base::sink(type = "output", split = FALSE)
[13:36:25.735]             base::close(...future.stdout)
[13:36:25.735]         }, add = TRUE)
[13:36:25.735]     }
[13:36:25.735]     ...future.frame <- base::sys.nframe()
[13:36:25.735]     ...future.conditions <- base::list()
[13:36:25.735]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.735]     if (FALSE) {
[13:36:25.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.735]     }
[13:36:25.735]     ...future.result <- base::tryCatch({
[13:36:25.735]         base::withCallingHandlers({
[13:36:25.735]             ...future.value <- base::withVisible(base::local({
[13:36:25.735]                 a + 1
[13:36:25.735]             }))
[13:36:25.735]             future::FutureResult(value = ...future.value$value, 
[13:36:25.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.735]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.735]                     ...future.globalenv.names))
[13:36:25.735]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.735]         }, condition = base::local({
[13:36:25.735]             c <- base::c
[13:36:25.735]             inherits <- base::inherits
[13:36:25.735]             invokeRestart <- base::invokeRestart
[13:36:25.735]             length <- base::length
[13:36:25.735]             list <- base::list
[13:36:25.735]             seq.int <- base::seq.int
[13:36:25.735]             signalCondition <- base::signalCondition
[13:36:25.735]             sys.calls <- base::sys.calls
[13:36:25.735]             `[[` <- base::`[[`
[13:36:25.735]             `+` <- base::`+`
[13:36:25.735]             `<<-` <- base::`<<-`
[13:36:25.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.735]                   3L)]
[13:36:25.735]             }
[13:36:25.735]             function(cond) {
[13:36:25.735]                 is_error <- inherits(cond, "error")
[13:36:25.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.735]                   NULL)
[13:36:25.735]                 if (is_error) {
[13:36:25.735]                   sessionInformation <- function() {
[13:36:25.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.735]                       search = base::search(), system = base::Sys.info())
[13:36:25.735]                   }
[13:36:25.735]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.735]                     cond$call), session = sessionInformation(), 
[13:36:25.735]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.735]                   signalCondition(cond)
[13:36:25.735]                 }
[13:36:25.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.735]                 "immediateCondition"))) {
[13:36:25.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.735]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.735]                   if (TRUE && !signal) {
[13:36:25.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.735]                     {
[13:36:25.735]                       inherits <- base::inherits
[13:36:25.735]                       invokeRestart <- base::invokeRestart
[13:36:25.735]                       is.null <- base::is.null
[13:36:25.735]                       muffled <- FALSE
[13:36:25.735]                       if (inherits(cond, "message")) {
[13:36:25.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.735]                         if (muffled) 
[13:36:25.735]                           invokeRestart("muffleMessage")
[13:36:25.735]                       }
[13:36:25.735]                       else if (inherits(cond, "warning")) {
[13:36:25.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.735]                         if (muffled) 
[13:36:25.735]                           invokeRestart("muffleWarning")
[13:36:25.735]                       }
[13:36:25.735]                       else if (inherits(cond, "condition")) {
[13:36:25.735]                         if (!is.null(pattern)) {
[13:36:25.735]                           computeRestarts <- base::computeRestarts
[13:36:25.735]                           grepl <- base::grepl
[13:36:25.735]                           restarts <- computeRestarts(cond)
[13:36:25.735]                           for (restart in restarts) {
[13:36:25.735]                             name <- restart$name
[13:36:25.735]                             if (is.null(name)) 
[13:36:25.735]                               next
[13:36:25.735]                             if (!grepl(pattern, name)) 
[13:36:25.735]                               next
[13:36:25.735]                             invokeRestart(restart)
[13:36:25.735]                             muffled <- TRUE
[13:36:25.735]                             break
[13:36:25.735]                           }
[13:36:25.735]                         }
[13:36:25.735]                       }
[13:36:25.735]                       invisible(muffled)
[13:36:25.735]                     }
[13:36:25.735]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.735]                   }
[13:36:25.735]                 }
[13:36:25.735]                 else {
[13:36:25.735]                   if (TRUE) {
[13:36:25.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.735]                     {
[13:36:25.735]                       inherits <- base::inherits
[13:36:25.735]                       invokeRestart <- base::invokeRestart
[13:36:25.735]                       is.null <- base::is.null
[13:36:25.735]                       muffled <- FALSE
[13:36:25.735]                       if (inherits(cond, "message")) {
[13:36:25.735]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.735]                         if (muffled) 
[13:36:25.735]                           invokeRestart("muffleMessage")
[13:36:25.735]                       }
[13:36:25.735]                       else if (inherits(cond, "warning")) {
[13:36:25.735]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.735]                         if (muffled) 
[13:36:25.735]                           invokeRestart("muffleWarning")
[13:36:25.735]                       }
[13:36:25.735]                       else if (inherits(cond, "condition")) {
[13:36:25.735]                         if (!is.null(pattern)) {
[13:36:25.735]                           computeRestarts <- base::computeRestarts
[13:36:25.735]                           grepl <- base::grepl
[13:36:25.735]                           restarts <- computeRestarts(cond)
[13:36:25.735]                           for (restart in restarts) {
[13:36:25.735]                             name <- restart$name
[13:36:25.735]                             if (is.null(name)) 
[13:36:25.735]                               next
[13:36:25.735]                             if (!grepl(pattern, name)) 
[13:36:25.735]                               next
[13:36:25.735]                             invokeRestart(restart)
[13:36:25.735]                             muffled <- TRUE
[13:36:25.735]                             break
[13:36:25.735]                           }
[13:36:25.735]                         }
[13:36:25.735]                       }
[13:36:25.735]                       invisible(muffled)
[13:36:25.735]                     }
[13:36:25.735]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.735]                   }
[13:36:25.735]                 }
[13:36:25.735]             }
[13:36:25.735]         }))
[13:36:25.735]     }, error = function(ex) {
[13:36:25.735]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.735]                 ...future.rng), started = ...future.startTime, 
[13:36:25.735]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.735]             version = "1.8"), class = "FutureResult")
[13:36:25.735]     }, finally = {
[13:36:25.735]         if (!identical(...future.workdir, getwd())) 
[13:36:25.735]             setwd(...future.workdir)
[13:36:25.735]         {
[13:36:25.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.735]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.735]             }
[13:36:25.735]             base::options(...future.oldOptions)
[13:36:25.735]             if (.Platform$OS.type == "windows") {
[13:36:25.735]                 old_names <- names(...future.oldEnvVars)
[13:36:25.735]                 envs <- base::Sys.getenv()
[13:36:25.735]                 names <- names(envs)
[13:36:25.735]                 common <- intersect(names, old_names)
[13:36:25.735]                 added <- setdiff(names, old_names)
[13:36:25.735]                 removed <- setdiff(old_names, names)
[13:36:25.735]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.735]                   envs[common]]
[13:36:25.735]                 NAMES <- toupper(changed)
[13:36:25.735]                 args <- list()
[13:36:25.735]                 for (kk in seq_along(NAMES)) {
[13:36:25.735]                   name <- changed[[kk]]
[13:36:25.735]                   NAME <- NAMES[[kk]]
[13:36:25.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.735]                     next
[13:36:25.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.735]                 }
[13:36:25.735]                 NAMES <- toupper(added)
[13:36:25.735]                 for (kk in seq_along(NAMES)) {
[13:36:25.735]                   name <- added[[kk]]
[13:36:25.735]                   NAME <- NAMES[[kk]]
[13:36:25.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.735]                     next
[13:36:25.735]                   args[[name]] <- ""
[13:36:25.735]                 }
[13:36:25.735]                 NAMES <- toupper(removed)
[13:36:25.735]                 for (kk in seq_along(NAMES)) {
[13:36:25.735]                   name <- removed[[kk]]
[13:36:25.735]                   NAME <- NAMES[[kk]]
[13:36:25.735]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.735]                     next
[13:36:25.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.735]                 }
[13:36:25.735]                 if (length(args) > 0) 
[13:36:25.735]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.735]             }
[13:36:25.735]             else {
[13:36:25.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.735]             }
[13:36:25.735]             {
[13:36:25.735]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.735]                   0L) {
[13:36:25.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.735]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.735]                   base::options(opts)
[13:36:25.735]                 }
[13:36:25.735]                 {
[13:36:25.735]                   {
[13:36:25.735]                     NULL
[13:36:25.735]                     RNGkind("Mersenne-Twister")
[13:36:25.735]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:25.735]                       inherits = FALSE)
[13:36:25.735]                   }
[13:36:25.735]                   options(future.plan = NULL)
[13:36:25.735]                   if (is.na(NA_character_)) 
[13:36:25.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.735]                     .init = FALSE)
[13:36:25.735]                 }
[13:36:25.735]             }
[13:36:25.735]         }
[13:36:25.735]     })
[13:36:25.735]     if (TRUE) {
[13:36:25.735]         base::sink(type = "output", split = FALSE)
[13:36:25.735]         if (TRUE) {
[13:36:25.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.735]         }
[13:36:25.735]         else {
[13:36:25.735]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.735]         }
[13:36:25.735]         base::close(...future.stdout)
[13:36:25.735]         ...future.stdout <- NULL
[13:36:25.735]     }
[13:36:25.735]     ...future.result$conditions <- ...future.conditions
[13:36:25.735]     ...future.result$finished <- base::Sys.time()
[13:36:25.735]     ...future.result
[13:36:25.735] }
[13:36:25.736] assign_globals() ...
[13:36:25.736] List of 1
[13:36:25.736]  $ a: num 10
[13:36:25.736]  - attr(*, "where")=List of 1
[13:36:25.736]   ..$ a:<environment: R_EmptyEnv> 
[13:36:25.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.736]  - attr(*, "resolved")= logi FALSE
[13:36:25.736]  - attr(*, "total_size")= num 56
[13:36:25.736]  - attr(*, "already-done")= logi TRUE
[13:36:25.739] - copied ‘a’ to environment
[13:36:25.739] assign_globals() ... done
[13:36:25.739] plan(): Setting new future strategy stack:
[13:36:25.739] List of future strategies:
[13:36:25.739] 1. sequential:
[13:36:25.739]    - args: function (..., envir = parent.frame())
[13:36:25.739]    - tweaked: FALSE
[13:36:25.739]    - call: NULL
[13:36:25.740] plan(): nbrOfWorkers() = 1
[13:36:25.740] plan(): Setting new future strategy stack:
[13:36:25.740] List of future strategies:
[13:36:25.740] 1. sequential:
[13:36:25.740]    - args: function (..., envir = parent.frame())
[13:36:25.740]    - tweaked: FALSE
[13:36:25.740]    - call: plan(strategy)
[13:36:25.741] plan(): nbrOfWorkers() = 1
[13:36:25.741] SequentialFuture started (and completed)
[13:36:25.741] - Launch lazy future ... done
[13:36:25.741] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[13:36:25.746] plan(): Setting new future strategy stack:
[13:36:25.746] List of future strategies:
[13:36:25.746] 1. multicore:
[13:36:25.746]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.746]    - tweaked: FALSE
[13:36:25.746]    - call: plan(strategy)
[13:36:25.750] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[13:36:25.750] getGlobalsAndPackages() ...
[13:36:25.751] Searching for globals...
[13:36:25.752] - globals found: [2] ‘{’, ‘<-’
[13:36:25.752] Searching for globals ... DONE
[13:36:25.752] Resolving globals: FALSE
[13:36:25.753] 
[13:36:25.753] 
[13:36:25.753] getGlobalsAndPackages() ... DONE
[13:36:25.753] run() for ‘Future’ ...
[13:36:25.753] - state: ‘created’
[13:36:25.753] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.757] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.757]   - Field: ‘label’
[13:36:25.757]   - Field: ‘local’
[13:36:25.757]   - Field: ‘owner’
[13:36:25.757]   - Field: ‘envir’
[13:36:25.757]   - Field: ‘workers’
[13:36:25.757]   - Field: ‘packages’
[13:36:25.757]   - Field: ‘gc’
[13:36:25.758]   - Field: ‘job’
[13:36:25.758]   - Field: ‘conditions’
[13:36:25.758]   - Field: ‘expr’
[13:36:25.758]   - Field: ‘uuid’
[13:36:25.758]   - Field: ‘seed’
[13:36:25.758]   - Field: ‘version’
[13:36:25.758]   - Field: ‘result’
[13:36:25.758]   - Field: ‘asynchronous’
[13:36:25.758]   - Field: ‘calls’
[13:36:25.758]   - Field: ‘globals’
[13:36:25.758]   - Field: ‘stdout’
[13:36:25.759]   - Field: ‘earlySignal’
[13:36:25.759]   - Field: ‘lazy’
[13:36:25.759]   - Field: ‘state’
[13:36:25.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.759] - Launch lazy future ...
[13:36:25.760] Packages needed by the future expression (n = 0): <none>
[13:36:25.760] Packages needed by future strategies (n = 0): <none>
[13:36:25.760] {
[13:36:25.760]     {
[13:36:25.760]         {
[13:36:25.760]             ...future.startTime <- base::Sys.time()
[13:36:25.760]             {
[13:36:25.760]                 {
[13:36:25.760]                   {
[13:36:25.760]                     {
[13:36:25.760]                       base::local({
[13:36:25.760]                         has_future <- base::requireNamespace("future", 
[13:36:25.760]                           quietly = TRUE)
[13:36:25.760]                         if (has_future) {
[13:36:25.760]                           ns <- base::getNamespace("future")
[13:36:25.760]                           version <- ns[[".package"]][["version"]]
[13:36:25.760]                           if (is.null(version)) 
[13:36:25.760]                             version <- utils::packageVersion("future")
[13:36:25.760]                         }
[13:36:25.760]                         else {
[13:36:25.760]                           version <- NULL
[13:36:25.760]                         }
[13:36:25.760]                         if (!has_future || version < "1.8.0") {
[13:36:25.760]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.760]                             "", base::R.version$version.string), 
[13:36:25.760]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.760]                               "release", "version")], collapse = " "), 
[13:36:25.760]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.760]                             info)
[13:36:25.760]                           info <- base::paste(info, collapse = "; ")
[13:36:25.760]                           if (!has_future) {
[13:36:25.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.760]                               info)
[13:36:25.760]                           }
[13:36:25.760]                           else {
[13:36:25.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.760]                               info, version)
[13:36:25.760]                           }
[13:36:25.760]                           base::stop(msg)
[13:36:25.760]                         }
[13:36:25.760]                       })
[13:36:25.760]                     }
[13:36:25.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.760]                     base::options(mc.cores = 1L)
[13:36:25.760]                   }
[13:36:25.760]                   ...future.strategy.old <- future::plan("list")
[13:36:25.760]                   options(future.plan = NULL)
[13:36:25.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.760]                 }
[13:36:25.760]                 ...future.workdir <- getwd()
[13:36:25.760]             }
[13:36:25.760]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.760]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.760]         }
[13:36:25.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.760]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.760]             base::names(...future.oldOptions))
[13:36:25.760]     }
[13:36:25.760]     if (FALSE) {
[13:36:25.760]     }
[13:36:25.760]     else {
[13:36:25.760]         if (TRUE) {
[13:36:25.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.760]                 open = "w")
[13:36:25.760]         }
[13:36:25.760]         else {
[13:36:25.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.760]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.760]         }
[13:36:25.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.760]             base::sink(type = "output", split = FALSE)
[13:36:25.760]             base::close(...future.stdout)
[13:36:25.760]         }, add = TRUE)
[13:36:25.760]     }
[13:36:25.760]     ...future.frame <- base::sys.nframe()
[13:36:25.760]     ...future.conditions <- base::list()
[13:36:25.760]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.760]     if (FALSE) {
[13:36:25.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.760]     }
[13:36:25.760]     ...future.result <- base::tryCatch({
[13:36:25.760]         base::withCallingHandlers({
[13:36:25.760]             ...future.value <- base::withVisible(base::local({
[13:36:25.760]                 withCallingHandlers({
[13:36:25.760]                   {
[13:36:25.760]                     x <- 1
[13:36:25.760]                   }
[13:36:25.760]                 }, immediateCondition = function(cond) {
[13:36:25.760]                   save_rds <- function (object, pathname, ...) 
[13:36:25.760]                   {
[13:36:25.760]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.760]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.760]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.760]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.760]                         fi_tmp[["mtime"]])
[13:36:25.760]                     }
[13:36:25.760]                     tryCatch({
[13:36:25.760]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.760]                     }, error = function(ex) {
[13:36:25.760]                       msg <- conditionMessage(ex)
[13:36:25.760]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.760]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.760]                         fi_tmp[["mtime"]], msg)
[13:36:25.760]                       ex$message <- msg
[13:36:25.760]                       stop(ex)
[13:36:25.760]                     })
[13:36:25.760]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.760]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.760]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.760]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.760]                       fi <- file.info(pathname)
[13:36:25.760]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.760]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.760]                         fi[["size"]], fi[["mtime"]])
[13:36:25.760]                       stop(msg)
[13:36:25.760]                     }
[13:36:25.760]                     invisible(pathname)
[13:36:25.760]                   }
[13:36:25.760]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.760]                     rootPath = tempdir()) 
[13:36:25.760]                   {
[13:36:25.760]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.760]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.760]                       tmpdir = path, fileext = ".rds")
[13:36:25.760]                     save_rds(obj, file)
[13:36:25.760]                   }
[13:36:25.760]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.760]                   {
[13:36:25.760]                     inherits <- base::inherits
[13:36:25.760]                     invokeRestart <- base::invokeRestart
[13:36:25.760]                     is.null <- base::is.null
[13:36:25.760]                     muffled <- FALSE
[13:36:25.760]                     if (inherits(cond, "message")) {
[13:36:25.760]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.760]                       if (muffled) 
[13:36:25.760]                         invokeRestart("muffleMessage")
[13:36:25.760]                     }
[13:36:25.760]                     else if (inherits(cond, "warning")) {
[13:36:25.760]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.760]                       if (muffled) 
[13:36:25.760]                         invokeRestart("muffleWarning")
[13:36:25.760]                     }
[13:36:25.760]                     else if (inherits(cond, "condition")) {
[13:36:25.760]                       if (!is.null(pattern)) {
[13:36:25.760]                         computeRestarts <- base::computeRestarts
[13:36:25.760]                         grepl <- base::grepl
[13:36:25.760]                         restarts <- computeRestarts(cond)
[13:36:25.760]                         for (restart in restarts) {
[13:36:25.760]                           name <- restart$name
[13:36:25.760]                           if (is.null(name)) 
[13:36:25.760]                             next
[13:36:25.760]                           if (!grepl(pattern, name)) 
[13:36:25.760]                             next
[13:36:25.760]                           invokeRestart(restart)
[13:36:25.760]                           muffled <- TRUE
[13:36:25.760]                           break
[13:36:25.760]                         }
[13:36:25.760]                       }
[13:36:25.760]                     }
[13:36:25.760]                     invisible(muffled)
[13:36:25.760]                   }
[13:36:25.760]                   muffleCondition(cond)
[13:36:25.760]                 })
[13:36:25.760]             }))
[13:36:25.760]             future::FutureResult(value = ...future.value$value, 
[13:36:25.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.760]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.760]                     ...future.globalenv.names))
[13:36:25.760]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.760]         }, condition = base::local({
[13:36:25.760]             c <- base::c
[13:36:25.760]             inherits <- base::inherits
[13:36:25.760]             invokeRestart <- base::invokeRestart
[13:36:25.760]             length <- base::length
[13:36:25.760]             list <- base::list
[13:36:25.760]             seq.int <- base::seq.int
[13:36:25.760]             signalCondition <- base::signalCondition
[13:36:25.760]             sys.calls <- base::sys.calls
[13:36:25.760]             `[[` <- base::`[[`
[13:36:25.760]             `+` <- base::`+`
[13:36:25.760]             `<<-` <- base::`<<-`
[13:36:25.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.760]                   3L)]
[13:36:25.760]             }
[13:36:25.760]             function(cond) {
[13:36:25.760]                 is_error <- inherits(cond, "error")
[13:36:25.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.760]                   NULL)
[13:36:25.760]                 if (is_error) {
[13:36:25.760]                   sessionInformation <- function() {
[13:36:25.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.760]                       search = base::search(), system = base::Sys.info())
[13:36:25.760]                   }
[13:36:25.760]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.760]                     cond$call), session = sessionInformation(), 
[13:36:25.760]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.760]                   signalCondition(cond)
[13:36:25.760]                 }
[13:36:25.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.760]                 "immediateCondition"))) {
[13:36:25.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.760]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.760]                   if (TRUE && !signal) {
[13:36:25.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.760]                     {
[13:36:25.760]                       inherits <- base::inherits
[13:36:25.760]                       invokeRestart <- base::invokeRestart
[13:36:25.760]                       is.null <- base::is.null
[13:36:25.760]                       muffled <- FALSE
[13:36:25.760]                       if (inherits(cond, "message")) {
[13:36:25.760]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.760]                         if (muffled) 
[13:36:25.760]                           invokeRestart("muffleMessage")
[13:36:25.760]                       }
[13:36:25.760]                       else if (inherits(cond, "warning")) {
[13:36:25.760]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.760]                         if (muffled) 
[13:36:25.760]                           invokeRestart("muffleWarning")
[13:36:25.760]                       }
[13:36:25.760]                       else if (inherits(cond, "condition")) {
[13:36:25.760]                         if (!is.null(pattern)) {
[13:36:25.760]                           computeRestarts <- base::computeRestarts
[13:36:25.760]                           grepl <- base::grepl
[13:36:25.760]                           restarts <- computeRestarts(cond)
[13:36:25.760]                           for (restart in restarts) {
[13:36:25.760]                             name <- restart$name
[13:36:25.760]                             if (is.null(name)) 
[13:36:25.760]                               next
[13:36:25.760]                             if (!grepl(pattern, name)) 
[13:36:25.760]                               next
[13:36:25.760]                             invokeRestart(restart)
[13:36:25.760]                             muffled <- TRUE
[13:36:25.760]                             break
[13:36:25.760]                           }
[13:36:25.760]                         }
[13:36:25.760]                       }
[13:36:25.760]                       invisible(muffled)
[13:36:25.760]                     }
[13:36:25.760]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.760]                   }
[13:36:25.760]                 }
[13:36:25.760]                 else {
[13:36:25.760]                   if (TRUE) {
[13:36:25.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.760]                     {
[13:36:25.760]                       inherits <- base::inherits
[13:36:25.760]                       invokeRestart <- base::invokeRestart
[13:36:25.760]                       is.null <- base::is.null
[13:36:25.760]                       muffled <- FALSE
[13:36:25.760]                       if (inherits(cond, "message")) {
[13:36:25.760]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.760]                         if (muffled) 
[13:36:25.760]                           invokeRestart("muffleMessage")
[13:36:25.760]                       }
[13:36:25.760]                       else if (inherits(cond, "warning")) {
[13:36:25.760]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.760]                         if (muffled) 
[13:36:25.760]                           invokeRestart("muffleWarning")
[13:36:25.760]                       }
[13:36:25.760]                       else if (inherits(cond, "condition")) {
[13:36:25.760]                         if (!is.null(pattern)) {
[13:36:25.760]                           computeRestarts <- base::computeRestarts
[13:36:25.760]                           grepl <- base::grepl
[13:36:25.760]                           restarts <- computeRestarts(cond)
[13:36:25.760]                           for (restart in restarts) {
[13:36:25.760]                             name <- restart$name
[13:36:25.760]                             if (is.null(name)) 
[13:36:25.760]                               next
[13:36:25.760]                             if (!grepl(pattern, name)) 
[13:36:25.760]                               next
[13:36:25.760]                             invokeRestart(restart)
[13:36:25.760]                             muffled <- TRUE
[13:36:25.760]                             break
[13:36:25.760]                           }
[13:36:25.760]                         }
[13:36:25.760]                       }
[13:36:25.760]                       invisible(muffled)
[13:36:25.760]                     }
[13:36:25.760]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.760]                   }
[13:36:25.760]                 }
[13:36:25.760]             }
[13:36:25.760]         }))
[13:36:25.760]     }, error = function(ex) {
[13:36:25.760]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.760]                 ...future.rng), started = ...future.startTime, 
[13:36:25.760]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.760]             version = "1.8"), class = "FutureResult")
[13:36:25.760]     }, finally = {
[13:36:25.760]         if (!identical(...future.workdir, getwd())) 
[13:36:25.760]             setwd(...future.workdir)
[13:36:25.760]         {
[13:36:25.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.760]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.760]             }
[13:36:25.760]             base::options(...future.oldOptions)
[13:36:25.760]             if (.Platform$OS.type == "windows") {
[13:36:25.760]                 old_names <- names(...future.oldEnvVars)
[13:36:25.760]                 envs <- base::Sys.getenv()
[13:36:25.760]                 names <- names(envs)
[13:36:25.760]                 common <- intersect(names, old_names)
[13:36:25.760]                 added <- setdiff(names, old_names)
[13:36:25.760]                 removed <- setdiff(old_names, names)
[13:36:25.760]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.760]                   envs[common]]
[13:36:25.760]                 NAMES <- toupper(changed)
[13:36:25.760]                 args <- list()
[13:36:25.760]                 for (kk in seq_along(NAMES)) {
[13:36:25.760]                   name <- changed[[kk]]
[13:36:25.760]                   NAME <- NAMES[[kk]]
[13:36:25.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.760]                     next
[13:36:25.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.760]                 }
[13:36:25.760]                 NAMES <- toupper(added)
[13:36:25.760]                 for (kk in seq_along(NAMES)) {
[13:36:25.760]                   name <- added[[kk]]
[13:36:25.760]                   NAME <- NAMES[[kk]]
[13:36:25.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.760]                     next
[13:36:25.760]                   args[[name]] <- ""
[13:36:25.760]                 }
[13:36:25.760]                 NAMES <- toupper(removed)
[13:36:25.760]                 for (kk in seq_along(NAMES)) {
[13:36:25.760]                   name <- removed[[kk]]
[13:36:25.760]                   NAME <- NAMES[[kk]]
[13:36:25.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.760]                     next
[13:36:25.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.760]                 }
[13:36:25.760]                 if (length(args) > 0) 
[13:36:25.760]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.760]             }
[13:36:25.760]             else {
[13:36:25.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.760]             }
[13:36:25.760]             {
[13:36:25.760]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.760]                   0L) {
[13:36:25.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.760]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.760]                   base::options(opts)
[13:36:25.760]                 }
[13:36:25.760]                 {
[13:36:25.760]                   {
[13:36:25.760]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.760]                     NULL
[13:36:25.760]                   }
[13:36:25.760]                   options(future.plan = NULL)
[13:36:25.760]                   if (is.na(NA_character_)) 
[13:36:25.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.760]                     .init = FALSE)
[13:36:25.760]                 }
[13:36:25.760]             }
[13:36:25.760]         }
[13:36:25.760]     })
[13:36:25.760]     if (TRUE) {
[13:36:25.760]         base::sink(type = "output", split = FALSE)
[13:36:25.760]         if (TRUE) {
[13:36:25.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.760]         }
[13:36:25.760]         else {
[13:36:25.760]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.760]         }
[13:36:25.760]         base::close(...future.stdout)
[13:36:25.760]         ...future.stdout <- NULL
[13:36:25.760]     }
[13:36:25.760]     ...future.result$conditions <- ...future.conditions
[13:36:25.760]     ...future.result$finished <- base::Sys.time()
[13:36:25.760]     ...future.result
[13:36:25.760] }
[13:36:25.763] requestCore(): workers = 2
[13:36:25.765] MulticoreFuture started
[13:36:25.766] - Launch lazy future ... done
[13:36:25.766] run() for ‘MulticoreFuture’ ... done
[13:36:25.766] plan(): Setting new future strategy stack:
[13:36:25.766] List of future strategies:
[13:36:25.766] 1. sequential:
[13:36:25.766]    - args: function (..., envir = parent.frame())
[13:36:25.766]    - tweaked: FALSE
[13:36:25.766]    - call: NULL
[13:36:25.767] plan(): nbrOfWorkers() = 1
[13:36:25.768] result() for MulticoreFuture ...
[13:36:25.769] plan(): Setting new future strategy stack:
[13:36:25.770] List of future strategies:
[13:36:25.770] 1. multicore:
[13:36:25.770]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.770]    - tweaked: FALSE
[13:36:25.770]    - call: plan(strategy)
[13:36:25.774] plan(): nbrOfWorkers() = 2
[13:36:25.779] result() for MulticoreFuture ...
[13:36:25.779] result() for MulticoreFuture ... done
[13:36:25.779] result() for MulticoreFuture ... done
[13:36:25.779] result() for MulticoreFuture ...
[13:36:25.779] result() for MulticoreFuture ... done
** Future evaluation with globals
[13:36:25.780] getGlobalsAndPackages() ...
[13:36:25.780] Searching for globals...
[13:36:25.781] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:36:25.781] Searching for globals ... DONE
[13:36:25.782] Resolving globals: FALSE
[13:36:25.782] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.783] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:25.783] - globals: [1] ‘a’
[13:36:25.783] 
[13:36:25.783] getGlobalsAndPackages() ... DONE
[13:36:25.783] run() for ‘Future’ ...
[13:36:25.783] - state: ‘created’
[13:36:25.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.787] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.788]   - Field: ‘label’
[13:36:25.788]   - Field: ‘local’
[13:36:25.788]   - Field: ‘owner’
[13:36:25.788]   - Field: ‘envir’
[13:36:25.788]   - Field: ‘workers’
[13:36:25.788]   - Field: ‘packages’
[13:36:25.788]   - Field: ‘gc’
[13:36:25.789]   - Field: ‘job’
[13:36:25.789]   - Field: ‘conditions’
[13:36:25.789]   - Field: ‘expr’
[13:36:25.789]   - Field: ‘uuid’
[13:36:25.789]   - Field: ‘seed’
[13:36:25.789]   - Field: ‘version’
[13:36:25.789]   - Field: ‘result’
[13:36:25.789]   - Field: ‘asynchronous’
[13:36:25.789]   - Field: ‘calls’
[13:36:25.789]   - Field: ‘globals’
[13:36:25.790]   - Field: ‘stdout’
[13:36:25.790]   - Field: ‘earlySignal’
[13:36:25.790]   - Field: ‘lazy’
[13:36:25.790]   - Field: ‘state’
[13:36:25.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.790] - Launch lazy future ...
[13:36:25.790] Packages needed by the future expression (n = 0): <none>
[13:36:25.791] Packages needed by future strategies (n = 0): <none>
[13:36:25.791] {
[13:36:25.791]     {
[13:36:25.791]         {
[13:36:25.791]             ...future.startTime <- base::Sys.time()
[13:36:25.791]             {
[13:36:25.791]                 {
[13:36:25.791]                   {
[13:36:25.791]                     {
[13:36:25.791]                       base::local({
[13:36:25.791]                         has_future <- base::requireNamespace("future", 
[13:36:25.791]                           quietly = TRUE)
[13:36:25.791]                         if (has_future) {
[13:36:25.791]                           ns <- base::getNamespace("future")
[13:36:25.791]                           version <- ns[[".package"]][["version"]]
[13:36:25.791]                           if (is.null(version)) 
[13:36:25.791]                             version <- utils::packageVersion("future")
[13:36:25.791]                         }
[13:36:25.791]                         else {
[13:36:25.791]                           version <- NULL
[13:36:25.791]                         }
[13:36:25.791]                         if (!has_future || version < "1.8.0") {
[13:36:25.791]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.791]                             "", base::R.version$version.string), 
[13:36:25.791]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.791]                               "release", "version")], collapse = " "), 
[13:36:25.791]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.791]                             info)
[13:36:25.791]                           info <- base::paste(info, collapse = "; ")
[13:36:25.791]                           if (!has_future) {
[13:36:25.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.791]                               info)
[13:36:25.791]                           }
[13:36:25.791]                           else {
[13:36:25.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.791]                               info, version)
[13:36:25.791]                           }
[13:36:25.791]                           base::stop(msg)
[13:36:25.791]                         }
[13:36:25.791]                       })
[13:36:25.791]                     }
[13:36:25.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.791]                     base::options(mc.cores = 1L)
[13:36:25.791]                   }
[13:36:25.791]                   ...future.strategy.old <- future::plan("list")
[13:36:25.791]                   options(future.plan = NULL)
[13:36:25.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.791]                 }
[13:36:25.791]                 ...future.workdir <- getwd()
[13:36:25.791]             }
[13:36:25.791]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.791]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.791]         }
[13:36:25.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.791]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.791]             base::names(...future.oldOptions))
[13:36:25.791]     }
[13:36:25.791]     if (FALSE) {
[13:36:25.791]     }
[13:36:25.791]     else {
[13:36:25.791]         if (TRUE) {
[13:36:25.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.791]                 open = "w")
[13:36:25.791]         }
[13:36:25.791]         else {
[13:36:25.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.791]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.791]         }
[13:36:25.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.791]             base::sink(type = "output", split = FALSE)
[13:36:25.791]             base::close(...future.stdout)
[13:36:25.791]         }, add = TRUE)
[13:36:25.791]     }
[13:36:25.791]     ...future.frame <- base::sys.nframe()
[13:36:25.791]     ...future.conditions <- base::list()
[13:36:25.791]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.791]     if (FALSE) {
[13:36:25.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.791]     }
[13:36:25.791]     ...future.result <- base::tryCatch({
[13:36:25.791]         base::withCallingHandlers({
[13:36:25.791]             ...future.value <- base::withVisible(base::local({
[13:36:25.791]                 withCallingHandlers({
[13:36:25.791]                   {
[13:36:25.791]                     x <- a
[13:36:25.791]                   }
[13:36:25.791]                 }, immediateCondition = function(cond) {
[13:36:25.791]                   save_rds <- function (object, pathname, ...) 
[13:36:25.791]                   {
[13:36:25.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.791]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.791]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.791]                         fi_tmp[["mtime"]])
[13:36:25.791]                     }
[13:36:25.791]                     tryCatch({
[13:36:25.791]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.791]                     }, error = function(ex) {
[13:36:25.791]                       msg <- conditionMessage(ex)
[13:36:25.791]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.791]                         fi_tmp[["mtime"]], msg)
[13:36:25.791]                       ex$message <- msg
[13:36:25.791]                       stop(ex)
[13:36:25.791]                     })
[13:36:25.791]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.791]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.791]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.791]                       fi <- file.info(pathname)
[13:36:25.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.791]                         fi[["size"]], fi[["mtime"]])
[13:36:25.791]                       stop(msg)
[13:36:25.791]                     }
[13:36:25.791]                     invisible(pathname)
[13:36:25.791]                   }
[13:36:25.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.791]                     rootPath = tempdir()) 
[13:36:25.791]                   {
[13:36:25.791]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.791]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.791]                       tmpdir = path, fileext = ".rds")
[13:36:25.791]                     save_rds(obj, file)
[13:36:25.791]                   }
[13:36:25.791]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.791]                   {
[13:36:25.791]                     inherits <- base::inherits
[13:36:25.791]                     invokeRestart <- base::invokeRestart
[13:36:25.791]                     is.null <- base::is.null
[13:36:25.791]                     muffled <- FALSE
[13:36:25.791]                     if (inherits(cond, "message")) {
[13:36:25.791]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.791]                       if (muffled) 
[13:36:25.791]                         invokeRestart("muffleMessage")
[13:36:25.791]                     }
[13:36:25.791]                     else if (inherits(cond, "warning")) {
[13:36:25.791]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.791]                       if (muffled) 
[13:36:25.791]                         invokeRestart("muffleWarning")
[13:36:25.791]                     }
[13:36:25.791]                     else if (inherits(cond, "condition")) {
[13:36:25.791]                       if (!is.null(pattern)) {
[13:36:25.791]                         computeRestarts <- base::computeRestarts
[13:36:25.791]                         grepl <- base::grepl
[13:36:25.791]                         restarts <- computeRestarts(cond)
[13:36:25.791]                         for (restart in restarts) {
[13:36:25.791]                           name <- restart$name
[13:36:25.791]                           if (is.null(name)) 
[13:36:25.791]                             next
[13:36:25.791]                           if (!grepl(pattern, name)) 
[13:36:25.791]                             next
[13:36:25.791]                           invokeRestart(restart)
[13:36:25.791]                           muffled <- TRUE
[13:36:25.791]                           break
[13:36:25.791]                         }
[13:36:25.791]                       }
[13:36:25.791]                     }
[13:36:25.791]                     invisible(muffled)
[13:36:25.791]                   }
[13:36:25.791]                   muffleCondition(cond)
[13:36:25.791]                 })
[13:36:25.791]             }))
[13:36:25.791]             future::FutureResult(value = ...future.value$value, 
[13:36:25.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.791]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.791]                     ...future.globalenv.names))
[13:36:25.791]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.791]         }, condition = base::local({
[13:36:25.791]             c <- base::c
[13:36:25.791]             inherits <- base::inherits
[13:36:25.791]             invokeRestart <- base::invokeRestart
[13:36:25.791]             length <- base::length
[13:36:25.791]             list <- base::list
[13:36:25.791]             seq.int <- base::seq.int
[13:36:25.791]             signalCondition <- base::signalCondition
[13:36:25.791]             sys.calls <- base::sys.calls
[13:36:25.791]             `[[` <- base::`[[`
[13:36:25.791]             `+` <- base::`+`
[13:36:25.791]             `<<-` <- base::`<<-`
[13:36:25.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.791]                   3L)]
[13:36:25.791]             }
[13:36:25.791]             function(cond) {
[13:36:25.791]                 is_error <- inherits(cond, "error")
[13:36:25.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.791]                   NULL)
[13:36:25.791]                 if (is_error) {
[13:36:25.791]                   sessionInformation <- function() {
[13:36:25.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.791]                       search = base::search(), system = base::Sys.info())
[13:36:25.791]                   }
[13:36:25.791]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.791]                     cond$call), session = sessionInformation(), 
[13:36:25.791]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.791]                   signalCondition(cond)
[13:36:25.791]                 }
[13:36:25.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.791]                 "immediateCondition"))) {
[13:36:25.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.791]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.791]                   if (TRUE && !signal) {
[13:36:25.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.791]                     {
[13:36:25.791]                       inherits <- base::inherits
[13:36:25.791]                       invokeRestart <- base::invokeRestart
[13:36:25.791]                       is.null <- base::is.null
[13:36:25.791]                       muffled <- FALSE
[13:36:25.791]                       if (inherits(cond, "message")) {
[13:36:25.791]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.791]                         if (muffled) 
[13:36:25.791]                           invokeRestart("muffleMessage")
[13:36:25.791]                       }
[13:36:25.791]                       else if (inherits(cond, "warning")) {
[13:36:25.791]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.791]                         if (muffled) 
[13:36:25.791]                           invokeRestart("muffleWarning")
[13:36:25.791]                       }
[13:36:25.791]                       else if (inherits(cond, "condition")) {
[13:36:25.791]                         if (!is.null(pattern)) {
[13:36:25.791]                           computeRestarts <- base::computeRestarts
[13:36:25.791]                           grepl <- base::grepl
[13:36:25.791]                           restarts <- computeRestarts(cond)
[13:36:25.791]                           for (restart in restarts) {
[13:36:25.791]                             name <- restart$name
[13:36:25.791]                             if (is.null(name)) 
[13:36:25.791]                               next
[13:36:25.791]                             if (!grepl(pattern, name)) 
[13:36:25.791]                               next
[13:36:25.791]                             invokeRestart(restart)
[13:36:25.791]                             muffled <- TRUE
[13:36:25.791]                             break
[13:36:25.791]                           }
[13:36:25.791]                         }
[13:36:25.791]                       }
[13:36:25.791]                       invisible(muffled)
[13:36:25.791]                     }
[13:36:25.791]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.791]                   }
[13:36:25.791]                 }
[13:36:25.791]                 else {
[13:36:25.791]                   if (TRUE) {
[13:36:25.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.791]                     {
[13:36:25.791]                       inherits <- base::inherits
[13:36:25.791]                       invokeRestart <- base::invokeRestart
[13:36:25.791]                       is.null <- base::is.null
[13:36:25.791]                       muffled <- FALSE
[13:36:25.791]                       if (inherits(cond, "message")) {
[13:36:25.791]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.791]                         if (muffled) 
[13:36:25.791]                           invokeRestart("muffleMessage")
[13:36:25.791]                       }
[13:36:25.791]                       else if (inherits(cond, "warning")) {
[13:36:25.791]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.791]                         if (muffled) 
[13:36:25.791]                           invokeRestart("muffleWarning")
[13:36:25.791]                       }
[13:36:25.791]                       else if (inherits(cond, "condition")) {
[13:36:25.791]                         if (!is.null(pattern)) {
[13:36:25.791]                           computeRestarts <- base::computeRestarts
[13:36:25.791]                           grepl <- base::grepl
[13:36:25.791]                           restarts <- computeRestarts(cond)
[13:36:25.791]                           for (restart in restarts) {
[13:36:25.791]                             name <- restart$name
[13:36:25.791]                             if (is.null(name)) 
[13:36:25.791]                               next
[13:36:25.791]                             if (!grepl(pattern, name)) 
[13:36:25.791]                               next
[13:36:25.791]                             invokeRestart(restart)
[13:36:25.791]                             muffled <- TRUE
[13:36:25.791]                             break
[13:36:25.791]                           }
[13:36:25.791]                         }
[13:36:25.791]                       }
[13:36:25.791]                       invisible(muffled)
[13:36:25.791]                     }
[13:36:25.791]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.791]                   }
[13:36:25.791]                 }
[13:36:25.791]             }
[13:36:25.791]         }))
[13:36:25.791]     }, error = function(ex) {
[13:36:25.791]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.791]                 ...future.rng), started = ...future.startTime, 
[13:36:25.791]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.791]             version = "1.8"), class = "FutureResult")
[13:36:25.791]     }, finally = {
[13:36:25.791]         if (!identical(...future.workdir, getwd())) 
[13:36:25.791]             setwd(...future.workdir)
[13:36:25.791]         {
[13:36:25.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.791]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.791]             }
[13:36:25.791]             base::options(...future.oldOptions)
[13:36:25.791]             if (.Platform$OS.type == "windows") {
[13:36:25.791]                 old_names <- names(...future.oldEnvVars)
[13:36:25.791]                 envs <- base::Sys.getenv()
[13:36:25.791]                 names <- names(envs)
[13:36:25.791]                 common <- intersect(names, old_names)
[13:36:25.791]                 added <- setdiff(names, old_names)
[13:36:25.791]                 removed <- setdiff(old_names, names)
[13:36:25.791]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.791]                   envs[common]]
[13:36:25.791]                 NAMES <- toupper(changed)
[13:36:25.791]                 args <- list()
[13:36:25.791]                 for (kk in seq_along(NAMES)) {
[13:36:25.791]                   name <- changed[[kk]]
[13:36:25.791]                   NAME <- NAMES[[kk]]
[13:36:25.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.791]                     next
[13:36:25.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.791]                 }
[13:36:25.791]                 NAMES <- toupper(added)
[13:36:25.791]                 for (kk in seq_along(NAMES)) {
[13:36:25.791]                   name <- added[[kk]]
[13:36:25.791]                   NAME <- NAMES[[kk]]
[13:36:25.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.791]                     next
[13:36:25.791]                   args[[name]] <- ""
[13:36:25.791]                 }
[13:36:25.791]                 NAMES <- toupper(removed)
[13:36:25.791]                 for (kk in seq_along(NAMES)) {
[13:36:25.791]                   name <- removed[[kk]]
[13:36:25.791]                   NAME <- NAMES[[kk]]
[13:36:25.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.791]                     next
[13:36:25.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.791]                 }
[13:36:25.791]                 if (length(args) > 0) 
[13:36:25.791]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.791]             }
[13:36:25.791]             else {
[13:36:25.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.791]             }
[13:36:25.791]             {
[13:36:25.791]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.791]                   0L) {
[13:36:25.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.791]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.791]                   base::options(opts)
[13:36:25.791]                 }
[13:36:25.791]                 {
[13:36:25.791]                   {
[13:36:25.791]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.791]                     NULL
[13:36:25.791]                   }
[13:36:25.791]                   options(future.plan = NULL)
[13:36:25.791]                   if (is.na(NA_character_)) 
[13:36:25.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.791]                     .init = FALSE)
[13:36:25.791]                 }
[13:36:25.791]             }
[13:36:25.791]         }
[13:36:25.791]     })
[13:36:25.791]     if (TRUE) {
[13:36:25.791]         base::sink(type = "output", split = FALSE)
[13:36:25.791]         if (TRUE) {
[13:36:25.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.791]         }
[13:36:25.791]         else {
[13:36:25.791]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.791]         }
[13:36:25.791]         base::close(...future.stdout)
[13:36:25.791]         ...future.stdout <- NULL
[13:36:25.791]     }
[13:36:25.791]     ...future.result$conditions <- ...future.conditions
[13:36:25.791]     ...future.result$finished <- base::Sys.time()
[13:36:25.791]     ...future.result
[13:36:25.791] }
[13:36:25.794] assign_globals() ...
[13:36:25.794] List of 1
[13:36:25.794]  $ a: num 2
[13:36:25.794]  - attr(*, "where")=List of 1
[13:36:25.794]   ..$ a:<environment: R_EmptyEnv> 
[13:36:25.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.794]  - attr(*, "resolved")= logi FALSE
[13:36:25.794]  - attr(*, "total_size")= num 56
[13:36:25.794]  - attr(*, "already-done")= logi TRUE
[13:36:25.797] - copied ‘a’ to environment
[13:36:25.797] assign_globals() ... done
[13:36:25.799] requestCore(): workers = 2
[13:36:25.801] MulticoreFuture started
[13:36:25.802] - Launch lazy future ... done
[13:36:25.802] run() for ‘MulticoreFuture’ ... done
[13:36:25.802] result() for MulticoreFuture ...
[13:36:25.802] plan(): Setting new future strategy stack:
[13:36:25.803] List of future strategies:
[13:36:25.803] 1. sequential:
[13:36:25.803]    - args: function (..., envir = parent.frame())
[13:36:25.803]    - tweaked: FALSE
[13:36:25.803]    - call: NULL
[13:36:25.804] plan(): nbrOfWorkers() = 1
[13:36:25.806] plan(): Setting new future strategy stack:
[13:36:25.807] List of future strategies:
[13:36:25.807] 1. multicore:
[13:36:25.807]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.807]    - tweaked: FALSE
[13:36:25.807]    - call: plan(strategy)
[13:36:25.812] plan(): nbrOfWorkers() = 2
[13:36:25.813] result() for MulticoreFuture ...
[13:36:25.813] result() for MulticoreFuture ... done
[13:36:25.813] result() for MulticoreFuture ... done
[13:36:25.814] result() for MulticoreFuture ...
[13:36:25.814] result() for MulticoreFuture ... done
** Future evaluation with errors
[13:36:25.815] getGlobalsAndPackages() ...
[13:36:25.815] Searching for globals...
[13:36:25.817] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:36:25.817] Searching for globals ... DONE
[13:36:25.817] Resolving globals: FALSE
[13:36:25.818] 
[13:36:25.818] 
[13:36:25.818] getGlobalsAndPackages() ... DONE
[13:36:25.818] run() for ‘Future’ ...
[13:36:25.818] - state: ‘created’
[13:36:25.819] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.823] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.823]   - Field: ‘label’
[13:36:25.823]   - Field: ‘local’
[13:36:25.823]   - Field: ‘owner’
[13:36:25.823]   - Field: ‘envir’
[13:36:25.823]   - Field: ‘workers’
[13:36:25.824]   - Field: ‘packages’
[13:36:25.824]   - Field: ‘gc’
[13:36:25.824]   - Field: ‘job’
[13:36:25.824]   - Field: ‘conditions’
[13:36:25.824]   - Field: ‘expr’
[13:36:25.824]   - Field: ‘uuid’
[13:36:25.824]   - Field: ‘seed’
[13:36:25.824]   - Field: ‘version’
[13:36:25.824]   - Field: ‘result’
[13:36:25.825]   - Field: ‘asynchronous’
[13:36:25.825]   - Field: ‘calls’
[13:36:25.825]   - Field: ‘globals’
[13:36:25.825]   - Field: ‘stdout’
[13:36:25.825]   - Field: ‘earlySignal’
[13:36:25.825]   - Field: ‘lazy’
[13:36:25.825]   - Field: ‘state’
[13:36:25.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.825] - Launch lazy future ...
[13:36:25.826] Packages needed by the future expression (n = 0): <none>
[13:36:25.826] Packages needed by future strategies (n = 0): <none>
[13:36:25.827] {
[13:36:25.827]     {
[13:36:25.827]         {
[13:36:25.827]             ...future.startTime <- base::Sys.time()
[13:36:25.827]             {
[13:36:25.827]                 {
[13:36:25.827]                   {
[13:36:25.827]                     {
[13:36:25.827]                       base::local({
[13:36:25.827]                         has_future <- base::requireNamespace("future", 
[13:36:25.827]                           quietly = TRUE)
[13:36:25.827]                         if (has_future) {
[13:36:25.827]                           ns <- base::getNamespace("future")
[13:36:25.827]                           version <- ns[[".package"]][["version"]]
[13:36:25.827]                           if (is.null(version)) 
[13:36:25.827]                             version <- utils::packageVersion("future")
[13:36:25.827]                         }
[13:36:25.827]                         else {
[13:36:25.827]                           version <- NULL
[13:36:25.827]                         }
[13:36:25.827]                         if (!has_future || version < "1.8.0") {
[13:36:25.827]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.827]                             "", base::R.version$version.string), 
[13:36:25.827]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.827]                               "release", "version")], collapse = " "), 
[13:36:25.827]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.827]                             info)
[13:36:25.827]                           info <- base::paste(info, collapse = "; ")
[13:36:25.827]                           if (!has_future) {
[13:36:25.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.827]                               info)
[13:36:25.827]                           }
[13:36:25.827]                           else {
[13:36:25.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.827]                               info, version)
[13:36:25.827]                           }
[13:36:25.827]                           base::stop(msg)
[13:36:25.827]                         }
[13:36:25.827]                       })
[13:36:25.827]                     }
[13:36:25.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.827]                     base::options(mc.cores = 1L)
[13:36:25.827]                   }
[13:36:25.827]                   ...future.strategy.old <- future::plan("list")
[13:36:25.827]                   options(future.plan = NULL)
[13:36:25.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.827]                 }
[13:36:25.827]                 ...future.workdir <- getwd()
[13:36:25.827]             }
[13:36:25.827]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.827]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.827]         }
[13:36:25.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.827]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.827]             base::names(...future.oldOptions))
[13:36:25.827]     }
[13:36:25.827]     if (FALSE) {
[13:36:25.827]     }
[13:36:25.827]     else {
[13:36:25.827]         if (TRUE) {
[13:36:25.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.827]                 open = "w")
[13:36:25.827]         }
[13:36:25.827]         else {
[13:36:25.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.827]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.827]         }
[13:36:25.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.827]             base::sink(type = "output", split = FALSE)
[13:36:25.827]             base::close(...future.stdout)
[13:36:25.827]         }, add = TRUE)
[13:36:25.827]     }
[13:36:25.827]     ...future.frame <- base::sys.nframe()
[13:36:25.827]     ...future.conditions <- base::list()
[13:36:25.827]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.827]     if (FALSE) {
[13:36:25.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.827]     }
[13:36:25.827]     ...future.result <- base::tryCatch({
[13:36:25.827]         base::withCallingHandlers({
[13:36:25.827]             ...future.value <- base::withVisible(base::local({
[13:36:25.827]                 withCallingHandlers({
[13:36:25.827]                   {
[13:36:25.827]                     x <- 3
[13:36:25.827]                     stop("Woops!")
[13:36:25.827]                     x
[13:36:25.827]                   }
[13:36:25.827]                 }, immediateCondition = function(cond) {
[13:36:25.827]                   save_rds <- function (object, pathname, ...) 
[13:36:25.827]                   {
[13:36:25.827]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.827]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.827]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.827]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.827]                         fi_tmp[["mtime"]])
[13:36:25.827]                     }
[13:36:25.827]                     tryCatch({
[13:36:25.827]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.827]                     }, error = function(ex) {
[13:36:25.827]                       msg <- conditionMessage(ex)
[13:36:25.827]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.827]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.827]                         fi_tmp[["mtime"]], msg)
[13:36:25.827]                       ex$message <- msg
[13:36:25.827]                       stop(ex)
[13:36:25.827]                     })
[13:36:25.827]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.827]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.827]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.827]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.827]                       fi <- file.info(pathname)
[13:36:25.827]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.827]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.827]                         fi[["size"]], fi[["mtime"]])
[13:36:25.827]                       stop(msg)
[13:36:25.827]                     }
[13:36:25.827]                     invisible(pathname)
[13:36:25.827]                   }
[13:36:25.827]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.827]                     rootPath = tempdir()) 
[13:36:25.827]                   {
[13:36:25.827]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.827]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.827]                       tmpdir = path, fileext = ".rds")
[13:36:25.827]                     save_rds(obj, file)
[13:36:25.827]                   }
[13:36:25.827]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.827]                   {
[13:36:25.827]                     inherits <- base::inherits
[13:36:25.827]                     invokeRestart <- base::invokeRestart
[13:36:25.827]                     is.null <- base::is.null
[13:36:25.827]                     muffled <- FALSE
[13:36:25.827]                     if (inherits(cond, "message")) {
[13:36:25.827]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.827]                       if (muffled) 
[13:36:25.827]                         invokeRestart("muffleMessage")
[13:36:25.827]                     }
[13:36:25.827]                     else if (inherits(cond, "warning")) {
[13:36:25.827]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.827]                       if (muffled) 
[13:36:25.827]                         invokeRestart("muffleWarning")
[13:36:25.827]                     }
[13:36:25.827]                     else if (inherits(cond, "condition")) {
[13:36:25.827]                       if (!is.null(pattern)) {
[13:36:25.827]                         computeRestarts <- base::computeRestarts
[13:36:25.827]                         grepl <- base::grepl
[13:36:25.827]                         restarts <- computeRestarts(cond)
[13:36:25.827]                         for (restart in restarts) {
[13:36:25.827]                           name <- restart$name
[13:36:25.827]                           if (is.null(name)) 
[13:36:25.827]                             next
[13:36:25.827]                           if (!grepl(pattern, name)) 
[13:36:25.827]                             next
[13:36:25.827]                           invokeRestart(restart)
[13:36:25.827]                           muffled <- TRUE
[13:36:25.827]                           break
[13:36:25.827]                         }
[13:36:25.827]                       }
[13:36:25.827]                     }
[13:36:25.827]                     invisible(muffled)
[13:36:25.827]                   }
[13:36:25.827]                   muffleCondition(cond)
[13:36:25.827]                 })
[13:36:25.827]             }))
[13:36:25.827]             future::FutureResult(value = ...future.value$value, 
[13:36:25.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.827]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.827]                     ...future.globalenv.names))
[13:36:25.827]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.827]         }, condition = base::local({
[13:36:25.827]             c <- base::c
[13:36:25.827]             inherits <- base::inherits
[13:36:25.827]             invokeRestart <- base::invokeRestart
[13:36:25.827]             length <- base::length
[13:36:25.827]             list <- base::list
[13:36:25.827]             seq.int <- base::seq.int
[13:36:25.827]             signalCondition <- base::signalCondition
[13:36:25.827]             sys.calls <- base::sys.calls
[13:36:25.827]             `[[` <- base::`[[`
[13:36:25.827]             `+` <- base::`+`
[13:36:25.827]             `<<-` <- base::`<<-`
[13:36:25.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.827]                   3L)]
[13:36:25.827]             }
[13:36:25.827]             function(cond) {
[13:36:25.827]                 is_error <- inherits(cond, "error")
[13:36:25.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.827]                   NULL)
[13:36:25.827]                 if (is_error) {
[13:36:25.827]                   sessionInformation <- function() {
[13:36:25.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.827]                       search = base::search(), system = base::Sys.info())
[13:36:25.827]                   }
[13:36:25.827]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.827]                     cond$call), session = sessionInformation(), 
[13:36:25.827]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.827]                   signalCondition(cond)
[13:36:25.827]                 }
[13:36:25.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.827]                 "immediateCondition"))) {
[13:36:25.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.827]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.827]                   if (TRUE && !signal) {
[13:36:25.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.827]                     {
[13:36:25.827]                       inherits <- base::inherits
[13:36:25.827]                       invokeRestart <- base::invokeRestart
[13:36:25.827]                       is.null <- base::is.null
[13:36:25.827]                       muffled <- FALSE
[13:36:25.827]                       if (inherits(cond, "message")) {
[13:36:25.827]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.827]                         if (muffled) 
[13:36:25.827]                           invokeRestart("muffleMessage")
[13:36:25.827]                       }
[13:36:25.827]                       else if (inherits(cond, "warning")) {
[13:36:25.827]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.827]                         if (muffled) 
[13:36:25.827]                           invokeRestart("muffleWarning")
[13:36:25.827]                       }
[13:36:25.827]                       else if (inherits(cond, "condition")) {
[13:36:25.827]                         if (!is.null(pattern)) {
[13:36:25.827]                           computeRestarts <- base::computeRestarts
[13:36:25.827]                           grepl <- base::grepl
[13:36:25.827]                           restarts <- computeRestarts(cond)
[13:36:25.827]                           for (restart in restarts) {
[13:36:25.827]                             name <- restart$name
[13:36:25.827]                             if (is.null(name)) 
[13:36:25.827]                               next
[13:36:25.827]                             if (!grepl(pattern, name)) 
[13:36:25.827]                               next
[13:36:25.827]                             invokeRestart(restart)
[13:36:25.827]                             muffled <- TRUE
[13:36:25.827]                             break
[13:36:25.827]                           }
[13:36:25.827]                         }
[13:36:25.827]                       }
[13:36:25.827]                       invisible(muffled)
[13:36:25.827]                     }
[13:36:25.827]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.827]                   }
[13:36:25.827]                 }
[13:36:25.827]                 else {
[13:36:25.827]                   if (TRUE) {
[13:36:25.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.827]                     {
[13:36:25.827]                       inherits <- base::inherits
[13:36:25.827]                       invokeRestart <- base::invokeRestart
[13:36:25.827]                       is.null <- base::is.null
[13:36:25.827]                       muffled <- FALSE
[13:36:25.827]                       if (inherits(cond, "message")) {
[13:36:25.827]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.827]                         if (muffled) 
[13:36:25.827]                           invokeRestart("muffleMessage")
[13:36:25.827]                       }
[13:36:25.827]                       else if (inherits(cond, "warning")) {
[13:36:25.827]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.827]                         if (muffled) 
[13:36:25.827]                           invokeRestart("muffleWarning")
[13:36:25.827]                       }
[13:36:25.827]                       else if (inherits(cond, "condition")) {
[13:36:25.827]                         if (!is.null(pattern)) {
[13:36:25.827]                           computeRestarts <- base::computeRestarts
[13:36:25.827]                           grepl <- base::grepl
[13:36:25.827]                           restarts <- computeRestarts(cond)
[13:36:25.827]                           for (restart in restarts) {
[13:36:25.827]                             name <- restart$name
[13:36:25.827]                             if (is.null(name)) 
[13:36:25.827]                               next
[13:36:25.827]                             if (!grepl(pattern, name)) 
[13:36:25.827]                               next
[13:36:25.827]                             invokeRestart(restart)
[13:36:25.827]                             muffled <- TRUE
[13:36:25.827]                             break
[13:36:25.827]                           }
[13:36:25.827]                         }
[13:36:25.827]                       }
[13:36:25.827]                       invisible(muffled)
[13:36:25.827]                     }
[13:36:25.827]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.827]                   }
[13:36:25.827]                 }
[13:36:25.827]             }
[13:36:25.827]         }))
[13:36:25.827]     }, error = function(ex) {
[13:36:25.827]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.827]                 ...future.rng), started = ...future.startTime, 
[13:36:25.827]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.827]             version = "1.8"), class = "FutureResult")
[13:36:25.827]     }, finally = {
[13:36:25.827]         if (!identical(...future.workdir, getwd())) 
[13:36:25.827]             setwd(...future.workdir)
[13:36:25.827]         {
[13:36:25.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.827]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.827]             }
[13:36:25.827]             base::options(...future.oldOptions)
[13:36:25.827]             if (.Platform$OS.type == "windows") {
[13:36:25.827]                 old_names <- names(...future.oldEnvVars)
[13:36:25.827]                 envs <- base::Sys.getenv()
[13:36:25.827]                 names <- names(envs)
[13:36:25.827]                 common <- intersect(names, old_names)
[13:36:25.827]                 added <- setdiff(names, old_names)
[13:36:25.827]                 removed <- setdiff(old_names, names)
[13:36:25.827]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.827]                   envs[common]]
[13:36:25.827]                 NAMES <- toupper(changed)
[13:36:25.827]                 args <- list()
[13:36:25.827]                 for (kk in seq_along(NAMES)) {
[13:36:25.827]                   name <- changed[[kk]]
[13:36:25.827]                   NAME <- NAMES[[kk]]
[13:36:25.827]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.827]                     next
[13:36:25.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.827]                 }
[13:36:25.827]                 NAMES <- toupper(added)
[13:36:25.827]                 for (kk in seq_along(NAMES)) {
[13:36:25.827]                   name <- added[[kk]]
[13:36:25.827]                   NAME <- NAMES[[kk]]
[13:36:25.827]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.827]                     next
[13:36:25.827]                   args[[name]] <- ""
[13:36:25.827]                 }
[13:36:25.827]                 NAMES <- toupper(removed)
[13:36:25.827]                 for (kk in seq_along(NAMES)) {
[13:36:25.827]                   name <- removed[[kk]]
[13:36:25.827]                   NAME <- NAMES[[kk]]
[13:36:25.827]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.827]                     next
[13:36:25.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.827]                 }
[13:36:25.827]                 if (length(args) > 0) 
[13:36:25.827]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.827]             }
[13:36:25.827]             else {
[13:36:25.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.827]             }
[13:36:25.827]             {
[13:36:25.827]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.827]                   0L) {
[13:36:25.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.827]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.827]                   base::options(opts)
[13:36:25.827]                 }
[13:36:25.827]                 {
[13:36:25.827]                   {
[13:36:25.827]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.827]                     NULL
[13:36:25.827]                   }
[13:36:25.827]                   options(future.plan = NULL)
[13:36:25.827]                   if (is.na(NA_character_)) 
[13:36:25.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.827]                     .init = FALSE)
[13:36:25.827]                 }
[13:36:25.827]             }
[13:36:25.827]         }
[13:36:25.827]     })
[13:36:25.827]     if (TRUE) {
[13:36:25.827]         base::sink(type = "output", split = FALSE)
[13:36:25.827]         if (TRUE) {
[13:36:25.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.827]         }
[13:36:25.827]         else {
[13:36:25.827]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.827]         }
[13:36:25.827]         base::close(...future.stdout)
[13:36:25.827]         ...future.stdout <- NULL
[13:36:25.827]     }
[13:36:25.827]     ...future.result$conditions <- ...future.conditions
[13:36:25.827]     ...future.result$finished <- base::Sys.time()
[13:36:25.827]     ...future.result
[13:36:25.827] }
[13:36:25.829] requestCore(): workers = 2
[13:36:25.831] MulticoreFuture started
[13:36:25.831] - Launch lazy future ... done
[13:36:25.831] run() for ‘MulticoreFuture’ ... done
[13:36:25.832] result() for MulticoreFuture ...
[13:36:25.832] plan(): Setting new future strategy stack:
[13:36:25.832] List of future strategies:
[13:36:25.832] 1. sequential:
[13:36:25.832]    - args: function (..., envir = parent.frame())
[13:36:25.832]    - tweaked: FALSE
[13:36:25.832]    - call: NULL
[13:36:25.833] plan(): nbrOfWorkers() = 1
[13:36:25.835] plan(): Setting new future strategy stack:
[13:36:25.835] List of future strategies:
[13:36:25.835] 1. multicore:
[13:36:25.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.835]    - tweaked: FALSE
[13:36:25.835]    - call: plan(strategy)
[13:36:25.840] plan(): nbrOfWorkers() = 2
[13:36:25.845] result() for MulticoreFuture ...
[13:36:25.845] result() for MulticoreFuture ... done
[13:36:25.845] signalConditions() ...
[13:36:25.845]  - include = ‘immediateCondition’
[13:36:25.846]  - exclude = 
[13:36:25.846]  - resignal = FALSE
[13:36:25.846]  - Number of conditions: 1
[13:36:25.846] signalConditions() ... done
[13:36:25.846] result() for MulticoreFuture ... done
[13:36:25.846] result() for MulticoreFuture ...
[13:36:25.846] result() for MulticoreFuture ... done
[13:36:25.846] signalConditions() ...
[13:36:25.846]  - include = ‘immediateCondition’
[13:36:25.847]  - exclude = 
[13:36:25.847]  - resignal = FALSE
[13:36:25.847]  - Number of conditions: 1
[13:36:25.847] signalConditions() ... done
[13:36:25.847] Future state: ‘finished’
[13:36:25.847] result() for MulticoreFuture ...
[13:36:25.847] result() for MulticoreFuture ... done
[13:36:25.847] signalConditions() ...
[13:36:25.848]  - include = ‘condition’
[13:36:25.848]  - exclude = ‘immediateCondition’
[13:36:25.848]  - resignal = TRUE
[13:36:25.848]  - Number of conditions: 1
[13:36:25.848]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.848] signalConditions() ... done
[13:36:25.849] getGlobalsAndPackages() ...
[13:36:25.849] Searching for globals...
[13:36:25.851] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:25.851] Searching for globals ... DONE
[13:36:25.851] Resolving globals: FALSE
[13:36:25.852] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.852] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:25.852] - globals: [1] ‘ii’
[13:36:25.853] 
[13:36:25.853] getGlobalsAndPackages() ... DONE
[13:36:25.853] run() for ‘Future’ ...
[13:36:25.853] - state: ‘created’
[13:36:25.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.858]   - Field: ‘label’
[13:36:25.858]   - Field: ‘local’
[13:36:25.858]   - Field: ‘owner’
[13:36:25.858]   - Field: ‘envir’
[13:36:25.858]   - Field: ‘workers’
[13:36:25.858]   - Field: ‘packages’
[13:36:25.858]   - Field: ‘gc’
[13:36:25.858]   - Field: ‘job’
[13:36:25.859]   - Field: ‘conditions’
[13:36:25.859]   - Field: ‘expr’
[13:36:25.859]   - Field: ‘uuid’
[13:36:25.859]   - Field: ‘seed’
[13:36:25.859]   - Field: ‘version’
[13:36:25.859]   - Field: ‘result’
[13:36:25.859]   - Field: ‘asynchronous’
[13:36:25.859]   - Field: ‘calls’
[13:36:25.859]   - Field: ‘globals’
[13:36:25.860]   - Field: ‘stdout’
[13:36:25.860]   - Field: ‘earlySignal’
[13:36:25.860]   - Field: ‘lazy’
[13:36:25.862]   - Field: ‘state’
[13:36:25.863] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.863] - Launch lazy future ...
[13:36:25.863] Packages needed by the future expression (n = 0): <none>
[13:36:25.863] Packages needed by future strategies (n = 0): <none>
[13:36:25.864] {
[13:36:25.864]     {
[13:36:25.864]         {
[13:36:25.864]             ...future.startTime <- base::Sys.time()
[13:36:25.864]             {
[13:36:25.864]                 {
[13:36:25.864]                   {
[13:36:25.864]                     {
[13:36:25.864]                       base::local({
[13:36:25.864]                         has_future <- base::requireNamespace("future", 
[13:36:25.864]                           quietly = TRUE)
[13:36:25.864]                         if (has_future) {
[13:36:25.864]                           ns <- base::getNamespace("future")
[13:36:25.864]                           version <- ns[[".package"]][["version"]]
[13:36:25.864]                           if (is.null(version)) 
[13:36:25.864]                             version <- utils::packageVersion("future")
[13:36:25.864]                         }
[13:36:25.864]                         else {
[13:36:25.864]                           version <- NULL
[13:36:25.864]                         }
[13:36:25.864]                         if (!has_future || version < "1.8.0") {
[13:36:25.864]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.864]                             "", base::R.version$version.string), 
[13:36:25.864]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.864]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.864]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.864]                               "release", "version")], collapse = " "), 
[13:36:25.864]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.864]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.864]                             info)
[13:36:25.864]                           info <- base::paste(info, collapse = "; ")
[13:36:25.864]                           if (!has_future) {
[13:36:25.864]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.864]                               info)
[13:36:25.864]                           }
[13:36:25.864]                           else {
[13:36:25.864]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.864]                               info, version)
[13:36:25.864]                           }
[13:36:25.864]                           base::stop(msg)
[13:36:25.864]                         }
[13:36:25.864]                       })
[13:36:25.864]                     }
[13:36:25.864]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.864]                     base::options(mc.cores = 1L)
[13:36:25.864]                   }
[13:36:25.864]                   ...future.strategy.old <- future::plan("list")
[13:36:25.864]                   options(future.plan = NULL)
[13:36:25.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.864]                 }
[13:36:25.864]                 ...future.workdir <- getwd()
[13:36:25.864]             }
[13:36:25.864]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.864]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.864]         }
[13:36:25.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.864]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.864]             base::names(...future.oldOptions))
[13:36:25.864]     }
[13:36:25.864]     if (FALSE) {
[13:36:25.864]     }
[13:36:25.864]     else {
[13:36:25.864]         if (TRUE) {
[13:36:25.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.864]                 open = "w")
[13:36:25.864]         }
[13:36:25.864]         else {
[13:36:25.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.864]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.864]         }
[13:36:25.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.864]             base::sink(type = "output", split = FALSE)
[13:36:25.864]             base::close(...future.stdout)
[13:36:25.864]         }, add = TRUE)
[13:36:25.864]     }
[13:36:25.864]     ...future.frame <- base::sys.nframe()
[13:36:25.864]     ...future.conditions <- base::list()
[13:36:25.864]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.864]     if (FALSE) {
[13:36:25.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.864]     }
[13:36:25.864]     ...future.result <- base::tryCatch({
[13:36:25.864]         base::withCallingHandlers({
[13:36:25.864]             ...future.value <- base::withVisible(base::local({
[13:36:25.864]                 withCallingHandlers({
[13:36:25.864]                   {
[13:36:25.864]                     if (ii%%2 == 0) 
[13:36:25.864]                       stop("Woops!")
[13:36:25.864]                     ii
[13:36:25.864]                   }
[13:36:25.864]                 }, immediateCondition = function(cond) {
[13:36:25.864]                   save_rds <- function (object, pathname, ...) 
[13:36:25.864]                   {
[13:36:25.864]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.864]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.864]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.864]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.864]                         fi_tmp[["mtime"]])
[13:36:25.864]                     }
[13:36:25.864]                     tryCatch({
[13:36:25.864]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.864]                     }, error = function(ex) {
[13:36:25.864]                       msg <- conditionMessage(ex)
[13:36:25.864]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.864]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.864]                         fi_tmp[["mtime"]], msg)
[13:36:25.864]                       ex$message <- msg
[13:36:25.864]                       stop(ex)
[13:36:25.864]                     })
[13:36:25.864]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.864]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.864]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.864]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.864]                       fi <- file.info(pathname)
[13:36:25.864]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.864]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.864]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.864]                         fi[["size"]], fi[["mtime"]])
[13:36:25.864]                       stop(msg)
[13:36:25.864]                     }
[13:36:25.864]                     invisible(pathname)
[13:36:25.864]                   }
[13:36:25.864]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.864]                     rootPath = tempdir()) 
[13:36:25.864]                   {
[13:36:25.864]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.864]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.864]                       tmpdir = path, fileext = ".rds")
[13:36:25.864]                     save_rds(obj, file)
[13:36:25.864]                   }
[13:36:25.864]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.864]                   {
[13:36:25.864]                     inherits <- base::inherits
[13:36:25.864]                     invokeRestart <- base::invokeRestart
[13:36:25.864]                     is.null <- base::is.null
[13:36:25.864]                     muffled <- FALSE
[13:36:25.864]                     if (inherits(cond, "message")) {
[13:36:25.864]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.864]                       if (muffled) 
[13:36:25.864]                         invokeRestart("muffleMessage")
[13:36:25.864]                     }
[13:36:25.864]                     else if (inherits(cond, "warning")) {
[13:36:25.864]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.864]                       if (muffled) 
[13:36:25.864]                         invokeRestart("muffleWarning")
[13:36:25.864]                     }
[13:36:25.864]                     else if (inherits(cond, "condition")) {
[13:36:25.864]                       if (!is.null(pattern)) {
[13:36:25.864]                         computeRestarts <- base::computeRestarts
[13:36:25.864]                         grepl <- base::grepl
[13:36:25.864]                         restarts <- computeRestarts(cond)
[13:36:25.864]                         for (restart in restarts) {
[13:36:25.864]                           name <- restart$name
[13:36:25.864]                           if (is.null(name)) 
[13:36:25.864]                             next
[13:36:25.864]                           if (!grepl(pattern, name)) 
[13:36:25.864]                             next
[13:36:25.864]                           invokeRestart(restart)
[13:36:25.864]                           muffled <- TRUE
[13:36:25.864]                           break
[13:36:25.864]                         }
[13:36:25.864]                       }
[13:36:25.864]                     }
[13:36:25.864]                     invisible(muffled)
[13:36:25.864]                   }
[13:36:25.864]                   muffleCondition(cond)
[13:36:25.864]                 })
[13:36:25.864]             }))
[13:36:25.864]             future::FutureResult(value = ...future.value$value, 
[13:36:25.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.864]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.864]                     ...future.globalenv.names))
[13:36:25.864]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.864]         }, condition = base::local({
[13:36:25.864]             c <- base::c
[13:36:25.864]             inherits <- base::inherits
[13:36:25.864]             invokeRestart <- base::invokeRestart
[13:36:25.864]             length <- base::length
[13:36:25.864]             list <- base::list
[13:36:25.864]             seq.int <- base::seq.int
[13:36:25.864]             signalCondition <- base::signalCondition
[13:36:25.864]             sys.calls <- base::sys.calls
[13:36:25.864]             `[[` <- base::`[[`
[13:36:25.864]             `+` <- base::`+`
[13:36:25.864]             `<<-` <- base::`<<-`
[13:36:25.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.864]                   3L)]
[13:36:25.864]             }
[13:36:25.864]             function(cond) {
[13:36:25.864]                 is_error <- inherits(cond, "error")
[13:36:25.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.864]                   NULL)
[13:36:25.864]                 if (is_error) {
[13:36:25.864]                   sessionInformation <- function() {
[13:36:25.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.864]                       search = base::search(), system = base::Sys.info())
[13:36:25.864]                   }
[13:36:25.864]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.864]                     cond$call), session = sessionInformation(), 
[13:36:25.864]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.864]                   signalCondition(cond)
[13:36:25.864]                 }
[13:36:25.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.864]                 "immediateCondition"))) {
[13:36:25.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.864]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.864]                   if (TRUE && !signal) {
[13:36:25.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.864]                     {
[13:36:25.864]                       inherits <- base::inherits
[13:36:25.864]                       invokeRestart <- base::invokeRestart
[13:36:25.864]                       is.null <- base::is.null
[13:36:25.864]                       muffled <- FALSE
[13:36:25.864]                       if (inherits(cond, "message")) {
[13:36:25.864]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.864]                         if (muffled) 
[13:36:25.864]                           invokeRestart("muffleMessage")
[13:36:25.864]                       }
[13:36:25.864]                       else if (inherits(cond, "warning")) {
[13:36:25.864]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.864]                         if (muffled) 
[13:36:25.864]                           invokeRestart("muffleWarning")
[13:36:25.864]                       }
[13:36:25.864]                       else if (inherits(cond, "condition")) {
[13:36:25.864]                         if (!is.null(pattern)) {
[13:36:25.864]                           computeRestarts <- base::computeRestarts
[13:36:25.864]                           grepl <- base::grepl
[13:36:25.864]                           restarts <- computeRestarts(cond)
[13:36:25.864]                           for (restart in restarts) {
[13:36:25.864]                             name <- restart$name
[13:36:25.864]                             if (is.null(name)) 
[13:36:25.864]                               next
[13:36:25.864]                             if (!grepl(pattern, name)) 
[13:36:25.864]                               next
[13:36:25.864]                             invokeRestart(restart)
[13:36:25.864]                             muffled <- TRUE
[13:36:25.864]                             break
[13:36:25.864]                           }
[13:36:25.864]                         }
[13:36:25.864]                       }
[13:36:25.864]                       invisible(muffled)
[13:36:25.864]                     }
[13:36:25.864]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.864]                   }
[13:36:25.864]                 }
[13:36:25.864]                 else {
[13:36:25.864]                   if (TRUE) {
[13:36:25.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.864]                     {
[13:36:25.864]                       inherits <- base::inherits
[13:36:25.864]                       invokeRestart <- base::invokeRestart
[13:36:25.864]                       is.null <- base::is.null
[13:36:25.864]                       muffled <- FALSE
[13:36:25.864]                       if (inherits(cond, "message")) {
[13:36:25.864]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.864]                         if (muffled) 
[13:36:25.864]                           invokeRestart("muffleMessage")
[13:36:25.864]                       }
[13:36:25.864]                       else if (inherits(cond, "warning")) {
[13:36:25.864]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.864]                         if (muffled) 
[13:36:25.864]                           invokeRestart("muffleWarning")
[13:36:25.864]                       }
[13:36:25.864]                       else if (inherits(cond, "condition")) {
[13:36:25.864]                         if (!is.null(pattern)) {
[13:36:25.864]                           computeRestarts <- base::computeRestarts
[13:36:25.864]                           grepl <- base::grepl
[13:36:25.864]                           restarts <- computeRestarts(cond)
[13:36:25.864]                           for (restart in restarts) {
[13:36:25.864]                             name <- restart$name
[13:36:25.864]                             if (is.null(name)) 
[13:36:25.864]                               next
[13:36:25.864]                             if (!grepl(pattern, name)) 
[13:36:25.864]                               next
[13:36:25.864]                             invokeRestart(restart)
[13:36:25.864]                             muffled <- TRUE
[13:36:25.864]                             break
[13:36:25.864]                           }
[13:36:25.864]                         }
[13:36:25.864]                       }
[13:36:25.864]                       invisible(muffled)
[13:36:25.864]                     }
[13:36:25.864]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.864]                   }
[13:36:25.864]                 }
[13:36:25.864]             }
[13:36:25.864]         }))
[13:36:25.864]     }, error = function(ex) {
[13:36:25.864]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.864]                 ...future.rng), started = ...future.startTime, 
[13:36:25.864]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.864]             version = "1.8"), class = "FutureResult")
[13:36:25.864]     }, finally = {
[13:36:25.864]         if (!identical(...future.workdir, getwd())) 
[13:36:25.864]             setwd(...future.workdir)
[13:36:25.864]         {
[13:36:25.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.864]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.864]             }
[13:36:25.864]             base::options(...future.oldOptions)
[13:36:25.864]             if (.Platform$OS.type == "windows") {
[13:36:25.864]                 old_names <- names(...future.oldEnvVars)
[13:36:25.864]                 envs <- base::Sys.getenv()
[13:36:25.864]                 names <- names(envs)
[13:36:25.864]                 common <- intersect(names, old_names)
[13:36:25.864]                 added <- setdiff(names, old_names)
[13:36:25.864]                 removed <- setdiff(old_names, names)
[13:36:25.864]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.864]                   envs[common]]
[13:36:25.864]                 NAMES <- toupper(changed)
[13:36:25.864]                 args <- list()
[13:36:25.864]                 for (kk in seq_along(NAMES)) {
[13:36:25.864]                   name <- changed[[kk]]
[13:36:25.864]                   NAME <- NAMES[[kk]]
[13:36:25.864]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.864]                     next
[13:36:25.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.864]                 }
[13:36:25.864]                 NAMES <- toupper(added)
[13:36:25.864]                 for (kk in seq_along(NAMES)) {
[13:36:25.864]                   name <- added[[kk]]
[13:36:25.864]                   NAME <- NAMES[[kk]]
[13:36:25.864]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.864]                     next
[13:36:25.864]                   args[[name]] <- ""
[13:36:25.864]                 }
[13:36:25.864]                 NAMES <- toupper(removed)
[13:36:25.864]                 for (kk in seq_along(NAMES)) {
[13:36:25.864]                   name <- removed[[kk]]
[13:36:25.864]                   NAME <- NAMES[[kk]]
[13:36:25.864]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.864]                     next
[13:36:25.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.864]                 }
[13:36:25.864]                 if (length(args) > 0) 
[13:36:25.864]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.864]             }
[13:36:25.864]             else {
[13:36:25.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.864]             }
[13:36:25.864]             {
[13:36:25.864]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.864]                   0L) {
[13:36:25.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.864]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.864]                   base::options(opts)
[13:36:25.864]                 }
[13:36:25.864]                 {
[13:36:25.864]                   {
[13:36:25.864]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.864]                     NULL
[13:36:25.864]                   }
[13:36:25.864]                   options(future.plan = NULL)
[13:36:25.864]                   if (is.na(NA_character_)) 
[13:36:25.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.864]                     .init = FALSE)
[13:36:25.864]                 }
[13:36:25.864]             }
[13:36:25.864]         }
[13:36:25.864]     })
[13:36:25.864]     if (TRUE) {
[13:36:25.864]         base::sink(type = "output", split = FALSE)
[13:36:25.864]         if (TRUE) {
[13:36:25.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.864]         }
[13:36:25.864]         else {
[13:36:25.864]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.864]         }
[13:36:25.864]         base::close(...future.stdout)
[13:36:25.864]         ...future.stdout <- NULL
[13:36:25.864]     }
[13:36:25.864]     ...future.result$conditions <- ...future.conditions
[13:36:25.864]     ...future.result$finished <- base::Sys.time()
[13:36:25.864]     ...future.result
[13:36:25.864] }
[13:36:25.866] assign_globals() ...
[13:36:25.866] List of 1
[13:36:25.866]  $ ii: int 1
[13:36:25.866]  - attr(*, "where")=List of 1
[13:36:25.866]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:25.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.866]  - attr(*, "resolved")= logi FALSE
[13:36:25.866]  - attr(*, "total_size")= num 56
[13:36:25.866]  - attr(*, "already-done")= logi TRUE
[13:36:25.870] - copied ‘ii’ to environment
[13:36:25.870] assign_globals() ... done
[13:36:25.870] requestCore(): workers = 2
[13:36:25.872] MulticoreFuture started
[13:36:25.872] - Launch lazy future ... done
[13:36:25.872] run() for ‘MulticoreFuture’ ... done
[13:36:25.873] plan(): Setting new future strategy stack:
[13:36:25.873] getGlobalsAndPackages() ...
[13:36:25.873] Searching for globals...
[13:36:25.873] List of future strategies:
[13:36:25.873] 1. sequential:
[13:36:25.873]    - args: function (..., envir = parent.frame())
[13:36:25.873]    - tweaked: FALSE
[13:36:25.873]    - call: NULL
[13:36:25.874] plan(): nbrOfWorkers() = 1
[13:36:25.876] plan(): Setting new future strategy stack:
[13:36:25.876] List of future strategies:
[13:36:25.876] 1. multicore:
[13:36:25.876]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.876]    - tweaked: FALSE
[13:36:25.876]    - call: plan(strategy)
[13:36:25.877] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:25.877] Searching for globals ... DONE
[13:36:25.877] Resolving globals: FALSE
[13:36:25.878] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.879] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:25.879] - globals: [1] ‘ii’
[13:36:25.879] 
[13:36:25.880] getGlobalsAndPackages() ... DONE
[13:36:25.880] run() for ‘Future’ ...
[13:36:25.880] - state: ‘created’
[13:36:25.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.881] plan(): nbrOfWorkers() = 2
[13:36:25.885] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.886]   - Field: ‘label’
[13:36:25.886]   - Field: ‘local’
[13:36:25.886]   - Field: ‘owner’
[13:36:25.886]   - Field: ‘envir’
[13:36:25.886]   - Field: ‘workers’
[13:36:25.887]   - Field: ‘packages’
[13:36:25.887]   - Field: ‘gc’
[13:36:25.887]   - Field: ‘job’
[13:36:25.887]   - Field: ‘conditions’
[13:36:25.887]   - Field: ‘expr’
[13:36:25.887]   - Field: ‘uuid’
[13:36:25.887]   - Field: ‘seed’
[13:36:25.887]   - Field: ‘version’
[13:36:25.888]   - Field: ‘result’
[13:36:25.888]   - Field: ‘asynchronous’
[13:36:25.888]   - Field: ‘calls’
[13:36:25.888]   - Field: ‘globals’
[13:36:25.888]   - Field: ‘stdout’
[13:36:25.888]   - Field: ‘earlySignal’
[13:36:25.888]   - Field: ‘lazy’
[13:36:25.889]   - Field: ‘state’
[13:36:25.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.889] - Launch lazy future ...
[13:36:25.889] Packages needed by the future expression (n = 0): <none>
[13:36:25.889] Packages needed by future strategies (n = 0): <none>
[13:36:25.890] {
[13:36:25.890]     {
[13:36:25.890]         {
[13:36:25.890]             ...future.startTime <- base::Sys.time()
[13:36:25.890]             {
[13:36:25.890]                 {
[13:36:25.890]                   {
[13:36:25.890]                     {
[13:36:25.890]                       base::local({
[13:36:25.890]                         has_future <- base::requireNamespace("future", 
[13:36:25.890]                           quietly = TRUE)
[13:36:25.890]                         if (has_future) {
[13:36:25.890]                           ns <- base::getNamespace("future")
[13:36:25.890]                           version <- ns[[".package"]][["version"]]
[13:36:25.890]                           if (is.null(version)) 
[13:36:25.890]                             version <- utils::packageVersion("future")
[13:36:25.890]                         }
[13:36:25.890]                         else {
[13:36:25.890]                           version <- NULL
[13:36:25.890]                         }
[13:36:25.890]                         if (!has_future || version < "1.8.0") {
[13:36:25.890]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.890]                             "", base::R.version$version.string), 
[13:36:25.890]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.890]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.890]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.890]                               "release", "version")], collapse = " "), 
[13:36:25.890]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.890]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.890]                             info)
[13:36:25.890]                           info <- base::paste(info, collapse = "; ")
[13:36:25.890]                           if (!has_future) {
[13:36:25.890]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.890]                               info)
[13:36:25.890]                           }
[13:36:25.890]                           else {
[13:36:25.890]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.890]                               info, version)
[13:36:25.890]                           }
[13:36:25.890]                           base::stop(msg)
[13:36:25.890]                         }
[13:36:25.890]                       })
[13:36:25.890]                     }
[13:36:25.890]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.890]                     base::options(mc.cores = 1L)
[13:36:25.890]                   }
[13:36:25.890]                   ...future.strategy.old <- future::plan("list")
[13:36:25.890]                   options(future.plan = NULL)
[13:36:25.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.890]                 }
[13:36:25.890]                 ...future.workdir <- getwd()
[13:36:25.890]             }
[13:36:25.890]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.890]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.890]         }
[13:36:25.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.890]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.890]             base::names(...future.oldOptions))
[13:36:25.890]     }
[13:36:25.890]     if (FALSE) {
[13:36:25.890]     }
[13:36:25.890]     else {
[13:36:25.890]         if (TRUE) {
[13:36:25.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.890]                 open = "w")
[13:36:25.890]         }
[13:36:25.890]         else {
[13:36:25.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.890]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.890]         }
[13:36:25.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.890]             base::sink(type = "output", split = FALSE)
[13:36:25.890]             base::close(...future.stdout)
[13:36:25.890]         }, add = TRUE)
[13:36:25.890]     }
[13:36:25.890]     ...future.frame <- base::sys.nframe()
[13:36:25.890]     ...future.conditions <- base::list()
[13:36:25.890]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.890]     if (FALSE) {
[13:36:25.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.890]     }
[13:36:25.890]     ...future.result <- base::tryCatch({
[13:36:25.890]         base::withCallingHandlers({
[13:36:25.890]             ...future.value <- base::withVisible(base::local({
[13:36:25.890]                 withCallingHandlers({
[13:36:25.890]                   {
[13:36:25.890]                     if (ii%%2 == 0) 
[13:36:25.890]                       stop("Woops!")
[13:36:25.890]                     ii
[13:36:25.890]                   }
[13:36:25.890]                 }, immediateCondition = function(cond) {
[13:36:25.890]                   save_rds <- function (object, pathname, ...) 
[13:36:25.890]                   {
[13:36:25.890]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.890]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.890]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.890]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.890]                         fi_tmp[["mtime"]])
[13:36:25.890]                     }
[13:36:25.890]                     tryCatch({
[13:36:25.890]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.890]                     }, error = function(ex) {
[13:36:25.890]                       msg <- conditionMessage(ex)
[13:36:25.890]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.890]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.890]                         fi_tmp[["mtime"]], msg)
[13:36:25.890]                       ex$message <- msg
[13:36:25.890]                       stop(ex)
[13:36:25.890]                     })
[13:36:25.890]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.890]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.890]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.890]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.890]                       fi <- file.info(pathname)
[13:36:25.890]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.890]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.890]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.890]                         fi[["size"]], fi[["mtime"]])
[13:36:25.890]                       stop(msg)
[13:36:25.890]                     }
[13:36:25.890]                     invisible(pathname)
[13:36:25.890]                   }
[13:36:25.890]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.890]                     rootPath = tempdir()) 
[13:36:25.890]                   {
[13:36:25.890]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.890]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.890]                       tmpdir = path, fileext = ".rds")
[13:36:25.890]                     save_rds(obj, file)
[13:36:25.890]                   }
[13:36:25.890]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.890]                   {
[13:36:25.890]                     inherits <- base::inherits
[13:36:25.890]                     invokeRestart <- base::invokeRestart
[13:36:25.890]                     is.null <- base::is.null
[13:36:25.890]                     muffled <- FALSE
[13:36:25.890]                     if (inherits(cond, "message")) {
[13:36:25.890]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.890]                       if (muffled) 
[13:36:25.890]                         invokeRestart("muffleMessage")
[13:36:25.890]                     }
[13:36:25.890]                     else if (inherits(cond, "warning")) {
[13:36:25.890]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.890]                       if (muffled) 
[13:36:25.890]                         invokeRestart("muffleWarning")
[13:36:25.890]                     }
[13:36:25.890]                     else if (inherits(cond, "condition")) {
[13:36:25.890]                       if (!is.null(pattern)) {
[13:36:25.890]                         computeRestarts <- base::computeRestarts
[13:36:25.890]                         grepl <- base::grepl
[13:36:25.890]                         restarts <- computeRestarts(cond)
[13:36:25.890]                         for (restart in restarts) {
[13:36:25.890]                           name <- restart$name
[13:36:25.890]                           if (is.null(name)) 
[13:36:25.890]                             next
[13:36:25.890]                           if (!grepl(pattern, name)) 
[13:36:25.890]                             next
[13:36:25.890]                           invokeRestart(restart)
[13:36:25.890]                           muffled <- TRUE
[13:36:25.890]                           break
[13:36:25.890]                         }
[13:36:25.890]                       }
[13:36:25.890]                     }
[13:36:25.890]                     invisible(muffled)
[13:36:25.890]                   }
[13:36:25.890]                   muffleCondition(cond)
[13:36:25.890]                 })
[13:36:25.890]             }))
[13:36:25.890]             future::FutureResult(value = ...future.value$value, 
[13:36:25.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.890]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.890]                     ...future.globalenv.names))
[13:36:25.890]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.890]         }, condition = base::local({
[13:36:25.890]             c <- base::c
[13:36:25.890]             inherits <- base::inherits
[13:36:25.890]             invokeRestart <- base::invokeRestart
[13:36:25.890]             length <- base::length
[13:36:25.890]             list <- base::list
[13:36:25.890]             seq.int <- base::seq.int
[13:36:25.890]             signalCondition <- base::signalCondition
[13:36:25.890]             sys.calls <- base::sys.calls
[13:36:25.890]             `[[` <- base::`[[`
[13:36:25.890]             `+` <- base::`+`
[13:36:25.890]             `<<-` <- base::`<<-`
[13:36:25.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.890]                   3L)]
[13:36:25.890]             }
[13:36:25.890]             function(cond) {
[13:36:25.890]                 is_error <- inherits(cond, "error")
[13:36:25.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.890]                   NULL)
[13:36:25.890]                 if (is_error) {
[13:36:25.890]                   sessionInformation <- function() {
[13:36:25.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.890]                       search = base::search(), system = base::Sys.info())
[13:36:25.890]                   }
[13:36:25.890]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.890]                     cond$call), session = sessionInformation(), 
[13:36:25.890]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.890]                   signalCondition(cond)
[13:36:25.890]                 }
[13:36:25.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.890]                 "immediateCondition"))) {
[13:36:25.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.890]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.890]                   if (TRUE && !signal) {
[13:36:25.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.890]                     {
[13:36:25.890]                       inherits <- base::inherits
[13:36:25.890]                       invokeRestart <- base::invokeRestart
[13:36:25.890]                       is.null <- base::is.null
[13:36:25.890]                       muffled <- FALSE
[13:36:25.890]                       if (inherits(cond, "message")) {
[13:36:25.890]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.890]                         if (muffled) 
[13:36:25.890]                           invokeRestart("muffleMessage")
[13:36:25.890]                       }
[13:36:25.890]                       else if (inherits(cond, "warning")) {
[13:36:25.890]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.890]                         if (muffled) 
[13:36:25.890]                           invokeRestart("muffleWarning")
[13:36:25.890]                       }
[13:36:25.890]                       else if (inherits(cond, "condition")) {
[13:36:25.890]                         if (!is.null(pattern)) {
[13:36:25.890]                           computeRestarts <- base::computeRestarts
[13:36:25.890]                           grepl <- base::grepl
[13:36:25.890]                           restarts <- computeRestarts(cond)
[13:36:25.890]                           for (restart in restarts) {
[13:36:25.890]                             name <- restart$name
[13:36:25.890]                             if (is.null(name)) 
[13:36:25.890]                               next
[13:36:25.890]                             if (!grepl(pattern, name)) 
[13:36:25.890]                               next
[13:36:25.890]                             invokeRestart(restart)
[13:36:25.890]                             muffled <- TRUE
[13:36:25.890]                             break
[13:36:25.890]                           }
[13:36:25.890]                         }
[13:36:25.890]                       }
[13:36:25.890]                       invisible(muffled)
[13:36:25.890]                     }
[13:36:25.890]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.890]                   }
[13:36:25.890]                 }
[13:36:25.890]                 else {
[13:36:25.890]                   if (TRUE) {
[13:36:25.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.890]                     {
[13:36:25.890]                       inherits <- base::inherits
[13:36:25.890]                       invokeRestart <- base::invokeRestart
[13:36:25.890]                       is.null <- base::is.null
[13:36:25.890]                       muffled <- FALSE
[13:36:25.890]                       if (inherits(cond, "message")) {
[13:36:25.890]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.890]                         if (muffled) 
[13:36:25.890]                           invokeRestart("muffleMessage")
[13:36:25.890]                       }
[13:36:25.890]                       else if (inherits(cond, "warning")) {
[13:36:25.890]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.890]                         if (muffled) 
[13:36:25.890]                           invokeRestart("muffleWarning")
[13:36:25.890]                       }
[13:36:25.890]                       else if (inherits(cond, "condition")) {
[13:36:25.890]                         if (!is.null(pattern)) {
[13:36:25.890]                           computeRestarts <- base::computeRestarts
[13:36:25.890]                           grepl <- base::grepl
[13:36:25.890]                           restarts <- computeRestarts(cond)
[13:36:25.890]                           for (restart in restarts) {
[13:36:25.890]                             name <- restart$name
[13:36:25.890]                             if (is.null(name)) 
[13:36:25.890]                               next
[13:36:25.890]                             if (!grepl(pattern, name)) 
[13:36:25.890]                               next
[13:36:25.890]                             invokeRestart(restart)
[13:36:25.890]                             muffled <- TRUE
[13:36:25.890]                             break
[13:36:25.890]                           }
[13:36:25.890]                         }
[13:36:25.890]                       }
[13:36:25.890]                       invisible(muffled)
[13:36:25.890]                     }
[13:36:25.890]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.890]                   }
[13:36:25.890]                 }
[13:36:25.890]             }
[13:36:25.890]         }))
[13:36:25.890]     }, error = function(ex) {
[13:36:25.890]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.890]                 ...future.rng), started = ...future.startTime, 
[13:36:25.890]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.890]             version = "1.8"), class = "FutureResult")
[13:36:25.890]     }, finally = {
[13:36:25.890]         if (!identical(...future.workdir, getwd())) 
[13:36:25.890]             setwd(...future.workdir)
[13:36:25.890]         {
[13:36:25.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.890]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.890]             }
[13:36:25.890]             base::options(...future.oldOptions)
[13:36:25.890]             if (.Platform$OS.type == "windows") {
[13:36:25.890]                 old_names <- names(...future.oldEnvVars)
[13:36:25.890]                 envs <- base::Sys.getenv()
[13:36:25.890]                 names <- names(envs)
[13:36:25.890]                 common <- intersect(names, old_names)
[13:36:25.890]                 added <- setdiff(names, old_names)
[13:36:25.890]                 removed <- setdiff(old_names, names)
[13:36:25.890]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.890]                   envs[common]]
[13:36:25.890]                 NAMES <- toupper(changed)
[13:36:25.890]                 args <- list()
[13:36:25.890]                 for (kk in seq_along(NAMES)) {
[13:36:25.890]                   name <- changed[[kk]]
[13:36:25.890]                   NAME <- NAMES[[kk]]
[13:36:25.890]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.890]                     next
[13:36:25.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.890]                 }
[13:36:25.890]                 NAMES <- toupper(added)
[13:36:25.890]                 for (kk in seq_along(NAMES)) {
[13:36:25.890]                   name <- added[[kk]]
[13:36:25.890]                   NAME <- NAMES[[kk]]
[13:36:25.890]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.890]                     next
[13:36:25.890]                   args[[name]] <- ""
[13:36:25.890]                 }
[13:36:25.890]                 NAMES <- toupper(removed)
[13:36:25.890]                 for (kk in seq_along(NAMES)) {
[13:36:25.890]                   name <- removed[[kk]]
[13:36:25.890]                   NAME <- NAMES[[kk]]
[13:36:25.890]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.890]                     next
[13:36:25.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.890]                 }
[13:36:25.890]                 if (length(args) > 0) 
[13:36:25.890]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.890]             }
[13:36:25.890]             else {
[13:36:25.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.890]             }
[13:36:25.890]             {
[13:36:25.890]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.890]                   0L) {
[13:36:25.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.890]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.890]                   base::options(opts)
[13:36:25.890]                 }
[13:36:25.890]                 {
[13:36:25.890]                   {
[13:36:25.890]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.890]                     NULL
[13:36:25.890]                   }
[13:36:25.890]                   options(future.plan = NULL)
[13:36:25.890]                   if (is.na(NA_character_)) 
[13:36:25.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.890]                     .init = FALSE)
[13:36:25.890]                 }
[13:36:25.890]             }
[13:36:25.890]         }
[13:36:25.890]     })
[13:36:25.890]     if (TRUE) {
[13:36:25.890]         base::sink(type = "output", split = FALSE)
[13:36:25.890]         if (TRUE) {
[13:36:25.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.890]         }
[13:36:25.890]         else {
[13:36:25.890]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.890]         }
[13:36:25.890]         base::close(...future.stdout)
[13:36:25.890]         ...future.stdout <- NULL
[13:36:25.890]     }
[13:36:25.890]     ...future.result$conditions <- ...future.conditions
[13:36:25.890]     ...future.result$finished <- base::Sys.time()
[13:36:25.890]     ...future.result
[13:36:25.890] }
[13:36:25.893] assign_globals() ...
[13:36:25.893] List of 1
[13:36:25.893]  $ ii: int 2
[13:36:25.893]  - attr(*, "where")=List of 1
[13:36:25.893]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:25.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.893]  - attr(*, "resolved")= logi FALSE
[13:36:25.893]  - attr(*, "total_size")= num 56
[13:36:25.893]  - attr(*, "already-done")= logi TRUE
[13:36:25.897] - copied ‘ii’ to environment
[13:36:25.897] assign_globals() ... done
[13:36:25.897] requestCore(): workers = 2
[13:36:25.899] MulticoreFuture started
[13:36:25.900] - Launch lazy future ... done
[13:36:25.900] run() for ‘MulticoreFuture’ ... done
[13:36:25.900] plan(): Setting new future strategy stack:
[13:36:25.901] getGlobalsAndPackages() ...
[13:36:25.901] Searching for globals...
[13:36:25.901] List of future strategies:
[13:36:25.901] 1. sequential:
[13:36:25.901]    - args: function (..., envir = parent.frame())
[13:36:25.901]    - tweaked: FALSE
[13:36:25.901]    - call: NULL
[13:36:25.902] plan(): nbrOfWorkers() = 1
[13:36:25.904] plan(): Setting new future strategy stack:
[13:36:25.904] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:25.904] List of future strategies:
[13:36:25.904] 1. multicore:
[13:36:25.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.904]    - tweaked: FALSE
[13:36:25.904]    - call: plan(strategy)
[13:36:25.904] Searching for globals ... DONE
[13:36:25.905] Resolving globals: FALSE
[13:36:25.905] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:25.906] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:25.909] plan(): nbrOfWorkers() = 2
[13:36:25.910] - globals: [1] ‘ii’
[13:36:25.911] 
[13:36:25.911] getGlobalsAndPackages() ... DONE
[13:36:25.911] run() for ‘Future’ ...
[13:36:25.912] - state: ‘created’
[13:36:25.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.918]   - Field: ‘label’
[13:36:25.918]   - Field: ‘local’
[13:36:25.918]   - Field: ‘owner’
[13:36:25.918]   - Field: ‘envir’
[13:36:25.918]   - Field: ‘workers’
[13:36:25.919]   - Field: ‘packages’
[13:36:25.919]   - Field: ‘gc’
[13:36:25.919]   - Field: ‘job’
[13:36:25.919]   - Field: ‘conditions’
[13:36:25.919]   - Field: ‘expr’
[13:36:25.919]   - Field: ‘uuid’
[13:36:25.920]   - Field: ‘seed’
[13:36:25.920]   - Field: ‘version’
[13:36:25.920]   - Field: ‘result’
[13:36:25.920]   - Field: ‘asynchronous’
[13:36:25.920]   - Field: ‘calls’
[13:36:25.920]   - Field: ‘globals’
[13:36:25.921]   - Field: ‘stdout’
[13:36:25.921]   - Field: ‘earlySignal’
[13:36:25.921]   - Field: ‘lazy’
[13:36:25.921]   - Field: ‘state’
[13:36:25.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.921] - Launch lazy future ...
[13:36:25.922] Packages needed by the future expression (n = 0): <none>
[13:36:25.922] Packages needed by future strategies (n = 0): <none>
[13:36:25.923] {
[13:36:25.923]     {
[13:36:25.923]         {
[13:36:25.923]             ...future.startTime <- base::Sys.time()
[13:36:25.923]             {
[13:36:25.923]                 {
[13:36:25.923]                   {
[13:36:25.923]                     {
[13:36:25.923]                       base::local({
[13:36:25.923]                         has_future <- base::requireNamespace("future", 
[13:36:25.923]                           quietly = TRUE)
[13:36:25.923]                         if (has_future) {
[13:36:25.923]                           ns <- base::getNamespace("future")
[13:36:25.923]                           version <- ns[[".package"]][["version"]]
[13:36:25.923]                           if (is.null(version)) 
[13:36:25.923]                             version <- utils::packageVersion("future")
[13:36:25.923]                         }
[13:36:25.923]                         else {
[13:36:25.923]                           version <- NULL
[13:36:25.923]                         }
[13:36:25.923]                         if (!has_future || version < "1.8.0") {
[13:36:25.923]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.923]                             "", base::R.version$version.string), 
[13:36:25.923]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.923]                               "release", "version")], collapse = " "), 
[13:36:25.923]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.923]                             info)
[13:36:25.923]                           info <- base::paste(info, collapse = "; ")
[13:36:25.923]                           if (!has_future) {
[13:36:25.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.923]                               info)
[13:36:25.923]                           }
[13:36:25.923]                           else {
[13:36:25.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.923]                               info, version)
[13:36:25.923]                           }
[13:36:25.923]                           base::stop(msg)
[13:36:25.923]                         }
[13:36:25.923]                       })
[13:36:25.923]                     }
[13:36:25.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.923]                     base::options(mc.cores = 1L)
[13:36:25.923]                   }
[13:36:25.923]                   ...future.strategy.old <- future::plan("list")
[13:36:25.923]                   options(future.plan = NULL)
[13:36:25.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.923]                 }
[13:36:25.923]                 ...future.workdir <- getwd()
[13:36:25.923]             }
[13:36:25.923]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.923]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.923]         }
[13:36:25.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.923]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.923]             base::names(...future.oldOptions))
[13:36:25.923]     }
[13:36:25.923]     if (FALSE) {
[13:36:25.923]     }
[13:36:25.923]     else {
[13:36:25.923]         if (TRUE) {
[13:36:25.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.923]                 open = "w")
[13:36:25.923]         }
[13:36:25.923]         else {
[13:36:25.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.923]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.923]         }
[13:36:25.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.923]             base::sink(type = "output", split = FALSE)
[13:36:25.923]             base::close(...future.stdout)
[13:36:25.923]         }, add = TRUE)
[13:36:25.923]     }
[13:36:25.923]     ...future.frame <- base::sys.nframe()
[13:36:25.923]     ...future.conditions <- base::list()
[13:36:25.923]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.923]     if (FALSE) {
[13:36:25.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.923]     }
[13:36:25.923]     ...future.result <- base::tryCatch({
[13:36:25.923]         base::withCallingHandlers({
[13:36:25.923]             ...future.value <- base::withVisible(base::local({
[13:36:25.923]                 withCallingHandlers({
[13:36:25.923]                   {
[13:36:25.923]                     if (ii%%2 == 0) 
[13:36:25.923]                       stop("Woops!")
[13:36:25.923]                     ii
[13:36:25.923]                   }
[13:36:25.923]                 }, immediateCondition = function(cond) {
[13:36:25.923]                   save_rds <- function (object, pathname, ...) 
[13:36:25.923]                   {
[13:36:25.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.923]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.923]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.923]                         fi_tmp[["mtime"]])
[13:36:25.923]                     }
[13:36:25.923]                     tryCatch({
[13:36:25.923]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.923]                     }, error = function(ex) {
[13:36:25.923]                       msg <- conditionMessage(ex)
[13:36:25.923]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.923]                         fi_tmp[["mtime"]], msg)
[13:36:25.923]                       ex$message <- msg
[13:36:25.923]                       stop(ex)
[13:36:25.923]                     })
[13:36:25.923]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.923]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.923]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.923]                       fi <- file.info(pathname)
[13:36:25.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.923]                         fi[["size"]], fi[["mtime"]])
[13:36:25.923]                       stop(msg)
[13:36:25.923]                     }
[13:36:25.923]                     invisible(pathname)
[13:36:25.923]                   }
[13:36:25.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.923]                     rootPath = tempdir()) 
[13:36:25.923]                   {
[13:36:25.923]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.923]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.923]                       tmpdir = path, fileext = ".rds")
[13:36:25.923]                     save_rds(obj, file)
[13:36:25.923]                   }
[13:36:25.923]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.923]                   {
[13:36:25.923]                     inherits <- base::inherits
[13:36:25.923]                     invokeRestart <- base::invokeRestart
[13:36:25.923]                     is.null <- base::is.null
[13:36:25.923]                     muffled <- FALSE
[13:36:25.923]                     if (inherits(cond, "message")) {
[13:36:25.923]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.923]                       if (muffled) 
[13:36:25.923]                         invokeRestart("muffleMessage")
[13:36:25.923]                     }
[13:36:25.923]                     else if (inherits(cond, "warning")) {
[13:36:25.923]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.923]                       if (muffled) 
[13:36:25.923]                         invokeRestart("muffleWarning")
[13:36:25.923]                     }
[13:36:25.923]                     else if (inherits(cond, "condition")) {
[13:36:25.923]                       if (!is.null(pattern)) {
[13:36:25.923]                         computeRestarts <- base::computeRestarts
[13:36:25.923]                         grepl <- base::grepl
[13:36:25.923]                         restarts <- computeRestarts(cond)
[13:36:25.923]                         for (restart in restarts) {
[13:36:25.923]                           name <- restart$name
[13:36:25.923]                           if (is.null(name)) 
[13:36:25.923]                             next
[13:36:25.923]                           if (!grepl(pattern, name)) 
[13:36:25.923]                             next
[13:36:25.923]                           invokeRestart(restart)
[13:36:25.923]                           muffled <- TRUE
[13:36:25.923]                           break
[13:36:25.923]                         }
[13:36:25.923]                       }
[13:36:25.923]                     }
[13:36:25.923]                     invisible(muffled)
[13:36:25.923]                   }
[13:36:25.923]                   muffleCondition(cond)
[13:36:25.923]                 })
[13:36:25.923]             }))
[13:36:25.923]             future::FutureResult(value = ...future.value$value, 
[13:36:25.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.923]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.923]                     ...future.globalenv.names))
[13:36:25.923]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.923]         }, condition = base::local({
[13:36:25.923]             c <- base::c
[13:36:25.923]             inherits <- base::inherits
[13:36:25.923]             invokeRestart <- base::invokeRestart
[13:36:25.923]             length <- base::length
[13:36:25.923]             list <- base::list
[13:36:25.923]             seq.int <- base::seq.int
[13:36:25.923]             signalCondition <- base::signalCondition
[13:36:25.923]             sys.calls <- base::sys.calls
[13:36:25.923]             `[[` <- base::`[[`
[13:36:25.923]             `+` <- base::`+`
[13:36:25.923]             `<<-` <- base::`<<-`
[13:36:25.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.923]                   3L)]
[13:36:25.923]             }
[13:36:25.923]             function(cond) {
[13:36:25.923]                 is_error <- inherits(cond, "error")
[13:36:25.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.923]                   NULL)
[13:36:25.923]                 if (is_error) {
[13:36:25.923]                   sessionInformation <- function() {
[13:36:25.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.923]                       search = base::search(), system = base::Sys.info())
[13:36:25.923]                   }
[13:36:25.923]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.923]                     cond$call), session = sessionInformation(), 
[13:36:25.923]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.923]                   signalCondition(cond)
[13:36:25.923]                 }
[13:36:25.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.923]                 "immediateCondition"))) {
[13:36:25.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.923]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.923]                   if (TRUE && !signal) {
[13:36:25.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.923]                     {
[13:36:25.923]                       inherits <- base::inherits
[13:36:25.923]                       invokeRestart <- base::invokeRestart
[13:36:25.923]                       is.null <- base::is.null
[13:36:25.923]                       muffled <- FALSE
[13:36:25.923]                       if (inherits(cond, "message")) {
[13:36:25.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.923]                         if (muffled) 
[13:36:25.923]                           invokeRestart("muffleMessage")
[13:36:25.923]                       }
[13:36:25.923]                       else if (inherits(cond, "warning")) {
[13:36:25.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.923]                         if (muffled) 
[13:36:25.923]                           invokeRestart("muffleWarning")
[13:36:25.923]                       }
[13:36:25.923]                       else if (inherits(cond, "condition")) {
[13:36:25.923]                         if (!is.null(pattern)) {
[13:36:25.923]                           computeRestarts <- base::computeRestarts
[13:36:25.923]                           grepl <- base::grepl
[13:36:25.923]                           restarts <- computeRestarts(cond)
[13:36:25.923]                           for (restart in restarts) {
[13:36:25.923]                             name <- restart$name
[13:36:25.923]                             if (is.null(name)) 
[13:36:25.923]                               next
[13:36:25.923]                             if (!grepl(pattern, name)) 
[13:36:25.923]                               next
[13:36:25.923]                             invokeRestart(restart)
[13:36:25.923]                             muffled <- TRUE
[13:36:25.923]                             break
[13:36:25.923]                           }
[13:36:25.923]                         }
[13:36:25.923]                       }
[13:36:25.923]                       invisible(muffled)
[13:36:25.923]                     }
[13:36:25.923]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.923]                   }
[13:36:25.923]                 }
[13:36:25.923]                 else {
[13:36:25.923]                   if (TRUE) {
[13:36:25.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.923]                     {
[13:36:25.923]                       inherits <- base::inherits
[13:36:25.923]                       invokeRestart <- base::invokeRestart
[13:36:25.923]                       is.null <- base::is.null
[13:36:25.923]                       muffled <- FALSE
[13:36:25.923]                       if (inherits(cond, "message")) {
[13:36:25.923]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.923]                         if (muffled) 
[13:36:25.923]                           invokeRestart("muffleMessage")
[13:36:25.923]                       }
[13:36:25.923]                       else if (inherits(cond, "warning")) {
[13:36:25.923]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.923]                         if (muffled) 
[13:36:25.923]                           invokeRestart("muffleWarning")
[13:36:25.923]                       }
[13:36:25.923]                       else if (inherits(cond, "condition")) {
[13:36:25.923]                         if (!is.null(pattern)) {
[13:36:25.923]                           computeRestarts <- base::computeRestarts
[13:36:25.923]                           grepl <- base::grepl
[13:36:25.923]                           restarts <- computeRestarts(cond)
[13:36:25.923]                           for (restart in restarts) {
[13:36:25.923]                             name <- restart$name
[13:36:25.923]                             if (is.null(name)) 
[13:36:25.923]                               next
[13:36:25.923]                             if (!grepl(pattern, name)) 
[13:36:25.923]                               next
[13:36:25.923]                             invokeRestart(restart)
[13:36:25.923]                             muffled <- TRUE
[13:36:25.923]                             break
[13:36:25.923]                           }
[13:36:25.923]                         }
[13:36:25.923]                       }
[13:36:25.923]                       invisible(muffled)
[13:36:25.923]                     }
[13:36:25.923]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.923]                   }
[13:36:25.923]                 }
[13:36:25.923]             }
[13:36:25.923]         }))
[13:36:25.923]     }, error = function(ex) {
[13:36:25.923]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.923]                 ...future.rng), started = ...future.startTime, 
[13:36:25.923]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.923]             version = "1.8"), class = "FutureResult")
[13:36:25.923]     }, finally = {
[13:36:25.923]         if (!identical(...future.workdir, getwd())) 
[13:36:25.923]             setwd(...future.workdir)
[13:36:25.923]         {
[13:36:25.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.923]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.923]             }
[13:36:25.923]             base::options(...future.oldOptions)
[13:36:25.923]             if (.Platform$OS.type == "windows") {
[13:36:25.923]                 old_names <- names(...future.oldEnvVars)
[13:36:25.923]                 envs <- base::Sys.getenv()
[13:36:25.923]                 names <- names(envs)
[13:36:25.923]                 common <- intersect(names, old_names)
[13:36:25.923]                 added <- setdiff(names, old_names)
[13:36:25.923]                 removed <- setdiff(old_names, names)
[13:36:25.923]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.923]                   envs[common]]
[13:36:25.923]                 NAMES <- toupper(changed)
[13:36:25.923]                 args <- list()
[13:36:25.923]                 for (kk in seq_along(NAMES)) {
[13:36:25.923]                   name <- changed[[kk]]
[13:36:25.923]                   NAME <- NAMES[[kk]]
[13:36:25.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.923]                     next
[13:36:25.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.923]                 }
[13:36:25.923]                 NAMES <- toupper(added)
[13:36:25.923]                 for (kk in seq_along(NAMES)) {
[13:36:25.923]                   name <- added[[kk]]
[13:36:25.923]                   NAME <- NAMES[[kk]]
[13:36:25.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.923]                     next
[13:36:25.923]                   args[[name]] <- ""
[13:36:25.923]                 }
[13:36:25.923]                 NAMES <- toupper(removed)
[13:36:25.923]                 for (kk in seq_along(NAMES)) {
[13:36:25.923]                   name <- removed[[kk]]
[13:36:25.923]                   NAME <- NAMES[[kk]]
[13:36:25.923]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.923]                     next
[13:36:25.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.923]                 }
[13:36:25.923]                 if (length(args) > 0) 
[13:36:25.923]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.923]             }
[13:36:25.923]             else {
[13:36:25.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.923]             }
[13:36:25.923]             {
[13:36:25.923]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.923]                   0L) {
[13:36:25.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.923]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.923]                   base::options(opts)
[13:36:25.923]                 }
[13:36:25.923]                 {
[13:36:25.923]                   {
[13:36:25.923]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.923]                     NULL
[13:36:25.923]                   }
[13:36:25.923]                   options(future.plan = NULL)
[13:36:25.923]                   if (is.na(NA_character_)) 
[13:36:25.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.923]                     .init = FALSE)
[13:36:25.923]                 }
[13:36:25.923]             }
[13:36:25.923]         }
[13:36:25.923]     })
[13:36:25.923]     if (TRUE) {
[13:36:25.923]         base::sink(type = "output", split = FALSE)
[13:36:25.923]         if (TRUE) {
[13:36:25.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.923]         }
[13:36:25.923]         else {
[13:36:25.923]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.923]         }
[13:36:25.923]         base::close(...future.stdout)
[13:36:25.923]         ...future.stdout <- NULL
[13:36:25.923]     }
[13:36:25.923]     ...future.result$conditions <- ...future.conditions
[13:36:25.923]     ...future.result$finished <- base::Sys.time()
[13:36:25.923]     ...future.result
[13:36:25.923] }
[13:36:25.925] assign_globals() ...
[13:36:25.925] List of 1
[13:36:25.925]  $ ii: int 3
[13:36:25.925]  - attr(*, "where")=List of 1
[13:36:25.925]   ..$ ii:<environment: R_EmptyEnv> 
[13:36:25.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:25.925]  - attr(*, "resolved")= logi FALSE
[13:36:25.925]  - attr(*, "total_size")= num 56
[13:36:25.925]  - attr(*, "already-done")= logi TRUE
[13:36:25.929] - copied ‘ii’ to environment
[13:36:25.929] assign_globals() ... done
[13:36:25.930] requestCore(): workers = 2
[13:36:25.930] Poll #1 (0): usedCores() = 2, workers = 2
[13:36:25.941] result() for MulticoreFuture ...
[13:36:25.942] result() for MulticoreFuture ...
[13:36:25.942] result() for MulticoreFuture ... done
[13:36:25.942] result() for MulticoreFuture ... done
[13:36:25.943] result() for MulticoreFuture ...
[13:36:25.943] result() for MulticoreFuture ... done
[13:36:25.946] MulticoreFuture started
[13:36:25.946] - Launch lazy future ... done
[13:36:25.946] run() for ‘MulticoreFuture’ ... done
[13:36:25.947] result() for MulticoreFuture ...
[13:36:25.947] result() for MulticoreFuture ... done
[13:36:25.947] plan(): Setting new future strategy stack:
[13:36:25.947] result() for MulticoreFuture ...
[13:36:25.948] result() for MulticoreFuture ... done
[13:36:25.948] result() for MulticoreFuture ...
[13:36:25.947] List of future strategies:
[13:36:25.947] 1. sequential:
[13:36:25.947]    - args: function (..., envir = parent.frame())
[13:36:25.947]    - tweaked: FALSE
[13:36:25.947]    - call: NULL
[13:36:25.948] plan(): nbrOfWorkers() = 1
[13:36:25.951] plan(): Setting new future strategy stack:
[13:36:25.951] List of future strategies:
[13:36:25.951] 1. multicore:
[13:36:25.951]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.951]    - tweaked: FALSE
[13:36:25.951]    - call: plan(strategy)
[13:36:25.952] result() for MulticoreFuture ...
[13:36:25.952] result() for MulticoreFuture ... done
[13:36:25.952] signalConditions() ...
[13:36:25.952]  - include = ‘immediateCondition’
[13:36:25.952]  - exclude = 
[13:36:25.953]  - resignal = FALSE
[13:36:25.953]  - Number of conditions: 1
[13:36:25.953] signalConditions() ... done
[13:36:25.953] result() for MulticoreFuture ... done
[13:36:25.953] result() for MulticoreFuture ...
[13:36:25.953] result() for MulticoreFuture ... done
[13:36:25.954] signalConditions() ...
[13:36:25.954]  - include = ‘immediateCondition’
[13:36:25.954]  - exclude = 
[13:36:25.954]  - resignal = FALSE
[13:36:25.954]  - Number of conditions: 1
[13:36:25.955] signalConditions() ... done
[13:36:25.955] Future state: ‘finished’
[13:36:25.955] result() for MulticoreFuture ...
[13:36:25.955] result() for MulticoreFuture ... done
[13:36:25.955] signalConditions() ...
[13:36:25.955]  - include = ‘condition’
[13:36:25.956]  - exclude = ‘immediateCondition’
[13:36:25.956]  - resignal = TRUE
[13:36:25.956]  - Number of conditions: 1
[13:36:25.956]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.956] plan(): nbrOfWorkers() = 2
[13:36:25.956] signalConditions() ... done
[13:36:25.957] result() for MulticoreFuture ...
[13:36:25.957] result() for MulticoreFuture ...
[13:36:25.958] result() for MulticoreFuture ... done
[13:36:25.958] result() for MulticoreFuture ... done
[13:36:25.958] result() for MulticoreFuture ...
[13:36:25.958] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:36:25.958] result() for MulticoreFuture ...
[13:36:25.959] result() for MulticoreFuture ... done
[13:36:25.959] result() for MulticoreFuture ...
[13:36:25.959] result() for MulticoreFuture ... done
[13:36:25.959] signalConditions() ...
[13:36:25.959]  - include = ‘immediateCondition’
[13:36:25.959]  - exclude = 
[13:36:25.959]  - resignal = FALSE
[13:36:25.959]  - Number of conditions: 1
[13:36:25.960] signalConditions() ... done
[13:36:25.960] Future state: ‘finished’
[13:36:25.960] result() for MulticoreFuture ...
[13:36:25.960] result() for MulticoreFuture ... done
[13:36:25.960] signalConditions() ...
[13:36:25.960]  - include = ‘condition’
[13:36:25.960]  - exclude = ‘immediateCondition’
[13:36:25.960]  - resignal = TRUE
[13:36:25.960]  - Number of conditions: 1
[13:36:25.961]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.961] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:36:25.961] result() for MulticoreFuture ...
[13:36:25.961] result() for MulticoreFuture ... done
[13:36:25.961] result() for MulticoreFuture ...
[13:36:25.961] result() for MulticoreFuture ... done
[13:36:25.962] signalConditions() ...
[13:36:25.962]  - include = ‘immediateCondition’
[13:36:25.962]  - exclude = 
[13:36:25.962]  - resignal = FALSE
[13:36:25.962]  - Number of conditions: 1
[13:36:25.962] signalConditions() ... done
[13:36:25.962] Future state: ‘finished’
[13:36:25.962] result() for MulticoreFuture ...
[13:36:25.962] result() for MulticoreFuture ... done
[13:36:25.963] signalConditions() ...
[13:36:25.963]  - include = ‘condition’
[13:36:25.963]  - exclude = ‘immediateCondition’
[13:36:25.963]  - resignal = TRUE
[13:36:25.966]  - Number of conditions: 1
[13:36:25.966]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.966] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:36:25.967] getGlobalsAndPackages() ...
[13:36:25.967] Searching for globals...
[13:36:25.970] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:36:25.970] Searching for globals ... DONE
[13:36:25.970] Resolving globals: FALSE
[13:36:25.971] 
[13:36:25.971] 
[13:36:25.971] getGlobalsAndPackages() ... DONE
[13:36:25.971] run() for ‘Future’ ...
[13:36:25.971] - state: ‘created’
[13:36:25.971] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:25.976] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:25.976] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:25.976]   - Field: ‘label’
[13:36:25.976]   - Field: ‘local’
[13:36:25.976]   - Field: ‘owner’
[13:36:25.977]   - Field: ‘envir’
[13:36:25.977]   - Field: ‘workers’
[13:36:25.977]   - Field: ‘packages’
[13:36:25.977]   - Field: ‘gc’
[13:36:25.977]   - Field: ‘job’
[13:36:25.977]   - Field: ‘conditions’
[13:36:25.977]   - Field: ‘expr’
[13:36:25.978]   - Field: ‘uuid’
[13:36:25.978]   - Field: ‘seed’
[13:36:25.978]   - Field: ‘version’
[13:36:25.978]   - Field: ‘result’
[13:36:25.978]   - Field: ‘asynchronous’
[13:36:25.978]   - Field: ‘calls’
[13:36:25.978]   - Field: ‘globals’
[13:36:25.978]   - Field: ‘stdout’
[13:36:25.979]   - Field: ‘earlySignal’
[13:36:25.979]   - Field: ‘lazy’
[13:36:25.979]   - Field: ‘state’
[13:36:25.979] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:25.979] - Launch lazy future ...
[13:36:25.979] Packages needed by the future expression (n = 0): <none>
[13:36:25.980] Packages needed by future strategies (n = 0): <none>
[13:36:25.980] {
[13:36:25.980]     {
[13:36:25.980]         {
[13:36:25.980]             ...future.startTime <- base::Sys.time()
[13:36:25.980]             {
[13:36:25.980]                 {
[13:36:25.980]                   {
[13:36:25.980]                     {
[13:36:25.980]                       base::local({
[13:36:25.980]                         has_future <- base::requireNamespace("future", 
[13:36:25.980]                           quietly = TRUE)
[13:36:25.980]                         if (has_future) {
[13:36:25.980]                           ns <- base::getNamespace("future")
[13:36:25.980]                           version <- ns[[".package"]][["version"]]
[13:36:25.980]                           if (is.null(version)) 
[13:36:25.980]                             version <- utils::packageVersion("future")
[13:36:25.980]                         }
[13:36:25.980]                         else {
[13:36:25.980]                           version <- NULL
[13:36:25.980]                         }
[13:36:25.980]                         if (!has_future || version < "1.8.0") {
[13:36:25.980]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:25.980]                             "", base::R.version$version.string), 
[13:36:25.980]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:25.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:25.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:25.980]                               "release", "version")], collapse = " "), 
[13:36:25.980]                             hostname = base::Sys.info()[["nodename"]])
[13:36:25.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:25.980]                             info)
[13:36:25.980]                           info <- base::paste(info, collapse = "; ")
[13:36:25.980]                           if (!has_future) {
[13:36:25.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:25.980]                               info)
[13:36:25.980]                           }
[13:36:25.980]                           else {
[13:36:25.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:25.980]                               info, version)
[13:36:25.980]                           }
[13:36:25.980]                           base::stop(msg)
[13:36:25.980]                         }
[13:36:25.980]                       })
[13:36:25.980]                     }
[13:36:25.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:25.980]                     base::options(mc.cores = 1L)
[13:36:25.980]                   }
[13:36:25.980]                   ...future.strategy.old <- future::plan("list")
[13:36:25.980]                   options(future.plan = NULL)
[13:36:25.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:25.980]                 }
[13:36:25.980]                 ...future.workdir <- getwd()
[13:36:25.980]             }
[13:36:25.980]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:25.980]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:25.980]         }
[13:36:25.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:25.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:25.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:25.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:25.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:25.980]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:25.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:25.980]             base::names(...future.oldOptions))
[13:36:25.980]     }
[13:36:25.980]     if (FALSE) {
[13:36:25.980]     }
[13:36:25.980]     else {
[13:36:25.980]         if (TRUE) {
[13:36:25.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:25.980]                 open = "w")
[13:36:25.980]         }
[13:36:25.980]         else {
[13:36:25.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:25.980]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:25.980]         }
[13:36:25.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:25.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:25.980]             base::sink(type = "output", split = FALSE)
[13:36:25.980]             base::close(...future.stdout)
[13:36:25.980]         }, add = TRUE)
[13:36:25.980]     }
[13:36:25.980]     ...future.frame <- base::sys.nframe()
[13:36:25.980]     ...future.conditions <- base::list()
[13:36:25.980]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:25.980]     if (FALSE) {
[13:36:25.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:25.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:25.980]     }
[13:36:25.980]     ...future.result <- base::tryCatch({
[13:36:25.980]         base::withCallingHandlers({
[13:36:25.980]             ...future.value <- base::withVisible(base::local({
[13:36:25.980]                 withCallingHandlers({
[13:36:25.980]                   {
[13:36:25.980]                     cat("Processing: ")
[13:36:25.980]                     for (ii in 1:10) {
[13:36:25.980]                       cat(".")
[13:36:25.980]                     }
[13:36:25.980]                     cat(" [100%]\n")
[13:36:25.980]                     4
[13:36:25.980]                   }
[13:36:25.980]                 }, immediateCondition = function(cond) {
[13:36:25.980]                   save_rds <- function (object, pathname, ...) 
[13:36:25.980]                   {
[13:36:25.980]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:25.980]                     if (file_test("-f", pathname_tmp)) {
[13:36:25.980]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.980]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:25.980]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.980]                         fi_tmp[["mtime"]])
[13:36:25.980]                     }
[13:36:25.980]                     tryCatch({
[13:36:25.980]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:25.980]                     }, error = function(ex) {
[13:36:25.980]                       msg <- conditionMessage(ex)
[13:36:25.980]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.980]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:25.980]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.980]                         fi_tmp[["mtime"]], msg)
[13:36:25.980]                       ex$message <- msg
[13:36:25.980]                       stop(ex)
[13:36:25.980]                     })
[13:36:25.980]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:25.980]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:25.980]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:25.980]                       fi_tmp <- file.info(pathname_tmp)
[13:36:25.980]                       fi <- file.info(pathname)
[13:36:25.980]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:25.980]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:25.980]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:25.980]                         fi[["size"]], fi[["mtime"]])
[13:36:25.980]                       stop(msg)
[13:36:25.980]                     }
[13:36:25.980]                     invisible(pathname)
[13:36:25.980]                   }
[13:36:25.980]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:25.980]                     rootPath = tempdir()) 
[13:36:25.980]                   {
[13:36:25.980]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:25.980]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:25.980]                       tmpdir = path, fileext = ".rds")
[13:36:25.980]                     save_rds(obj, file)
[13:36:25.980]                   }
[13:36:25.980]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:25.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.980]                   {
[13:36:25.980]                     inherits <- base::inherits
[13:36:25.980]                     invokeRestart <- base::invokeRestart
[13:36:25.980]                     is.null <- base::is.null
[13:36:25.980]                     muffled <- FALSE
[13:36:25.980]                     if (inherits(cond, "message")) {
[13:36:25.980]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:25.980]                       if (muffled) 
[13:36:25.980]                         invokeRestart("muffleMessage")
[13:36:25.980]                     }
[13:36:25.980]                     else if (inherits(cond, "warning")) {
[13:36:25.980]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:25.980]                       if (muffled) 
[13:36:25.980]                         invokeRestart("muffleWarning")
[13:36:25.980]                     }
[13:36:25.980]                     else if (inherits(cond, "condition")) {
[13:36:25.980]                       if (!is.null(pattern)) {
[13:36:25.980]                         computeRestarts <- base::computeRestarts
[13:36:25.980]                         grepl <- base::grepl
[13:36:25.980]                         restarts <- computeRestarts(cond)
[13:36:25.980]                         for (restart in restarts) {
[13:36:25.980]                           name <- restart$name
[13:36:25.980]                           if (is.null(name)) 
[13:36:25.980]                             next
[13:36:25.980]                           if (!grepl(pattern, name)) 
[13:36:25.980]                             next
[13:36:25.980]                           invokeRestart(restart)
[13:36:25.980]                           muffled <- TRUE
[13:36:25.980]                           break
[13:36:25.980]                         }
[13:36:25.980]                       }
[13:36:25.980]                     }
[13:36:25.980]                     invisible(muffled)
[13:36:25.980]                   }
[13:36:25.980]                   muffleCondition(cond)
[13:36:25.980]                 })
[13:36:25.980]             }))
[13:36:25.980]             future::FutureResult(value = ...future.value$value, 
[13:36:25.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.980]                   ...future.rng), globalenv = if (FALSE) 
[13:36:25.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:25.980]                     ...future.globalenv.names))
[13:36:25.980]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:25.980]         }, condition = base::local({
[13:36:25.980]             c <- base::c
[13:36:25.980]             inherits <- base::inherits
[13:36:25.980]             invokeRestart <- base::invokeRestart
[13:36:25.980]             length <- base::length
[13:36:25.980]             list <- base::list
[13:36:25.980]             seq.int <- base::seq.int
[13:36:25.980]             signalCondition <- base::signalCondition
[13:36:25.980]             sys.calls <- base::sys.calls
[13:36:25.980]             `[[` <- base::`[[`
[13:36:25.980]             `+` <- base::`+`
[13:36:25.980]             `<<-` <- base::`<<-`
[13:36:25.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:25.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:25.980]                   3L)]
[13:36:25.980]             }
[13:36:25.980]             function(cond) {
[13:36:25.980]                 is_error <- inherits(cond, "error")
[13:36:25.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:25.980]                   NULL)
[13:36:25.980]                 if (is_error) {
[13:36:25.980]                   sessionInformation <- function() {
[13:36:25.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:25.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:25.980]                       search = base::search(), system = base::Sys.info())
[13:36:25.980]                   }
[13:36:25.980]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:25.980]                     cond$call), session = sessionInformation(), 
[13:36:25.980]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:25.980]                   signalCondition(cond)
[13:36:25.980]                 }
[13:36:25.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:25.980]                 "immediateCondition"))) {
[13:36:25.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:25.980]                   ...future.conditions[[length(...future.conditions) + 
[13:36:25.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:25.980]                   if (TRUE && !signal) {
[13:36:25.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.980]                     {
[13:36:25.980]                       inherits <- base::inherits
[13:36:25.980]                       invokeRestart <- base::invokeRestart
[13:36:25.980]                       is.null <- base::is.null
[13:36:25.980]                       muffled <- FALSE
[13:36:25.980]                       if (inherits(cond, "message")) {
[13:36:25.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.980]                         if (muffled) 
[13:36:25.980]                           invokeRestart("muffleMessage")
[13:36:25.980]                       }
[13:36:25.980]                       else if (inherits(cond, "warning")) {
[13:36:25.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.980]                         if (muffled) 
[13:36:25.980]                           invokeRestart("muffleWarning")
[13:36:25.980]                       }
[13:36:25.980]                       else if (inherits(cond, "condition")) {
[13:36:25.980]                         if (!is.null(pattern)) {
[13:36:25.980]                           computeRestarts <- base::computeRestarts
[13:36:25.980]                           grepl <- base::grepl
[13:36:25.980]                           restarts <- computeRestarts(cond)
[13:36:25.980]                           for (restart in restarts) {
[13:36:25.980]                             name <- restart$name
[13:36:25.980]                             if (is.null(name)) 
[13:36:25.980]                               next
[13:36:25.980]                             if (!grepl(pattern, name)) 
[13:36:25.980]                               next
[13:36:25.980]                             invokeRestart(restart)
[13:36:25.980]                             muffled <- TRUE
[13:36:25.980]                             break
[13:36:25.980]                           }
[13:36:25.980]                         }
[13:36:25.980]                       }
[13:36:25.980]                       invisible(muffled)
[13:36:25.980]                     }
[13:36:25.980]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.980]                   }
[13:36:25.980]                 }
[13:36:25.980]                 else {
[13:36:25.980]                   if (TRUE) {
[13:36:25.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:25.980]                     {
[13:36:25.980]                       inherits <- base::inherits
[13:36:25.980]                       invokeRestart <- base::invokeRestart
[13:36:25.980]                       is.null <- base::is.null
[13:36:25.980]                       muffled <- FALSE
[13:36:25.980]                       if (inherits(cond, "message")) {
[13:36:25.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:25.980]                         if (muffled) 
[13:36:25.980]                           invokeRestart("muffleMessage")
[13:36:25.980]                       }
[13:36:25.980]                       else if (inherits(cond, "warning")) {
[13:36:25.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:25.980]                         if (muffled) 
[13:36:25.980]                           invokeRestart("muffleWarning")
[13:36:25.980]                       }
[13:36:25.980]                       else if (inherits(cond, "condition")) {
[13:36:25.980]                         if (!is.null(pattern)) {
[13:36:25.980]                           computeRestarts <- base::computeRestarts
[13:36:25.980]                           grepl <- base::grepl
[13:36:25.980]                           restarts <- computeRestarts(cond)
[13:36:25.980]                           for (restart in restarts) {
[13:36:25.980]                             name <- restart$name
[13:36:25.980]                             if (is.null(name)) 
[13:36:25.980]                               next
[13:36:25.980]                             if (!grepl(pattern, name)) 
[13:36:25.980]                               next
[13:36:25.980]                             invokeRestart(restart)
[13:36:25.980]                             muffled <- TRUE
[13:36:25.980]                             break
[13:36:25.980]                           }
[13:36:25.980]                         }
[13:36:25.980]                       }
[13:36:25.980]                       invisible(muffled)
[13:36:25.980]                     }
[13:36:25.980]                     muffleCondition(cond, pattern = "^muffle")
[13:36:25.980]                   }
[13:36:25.980]                 }
[13:36:25.980]             }
[13:36:25.980]         }))
[13:36:25.980]     }, error = function(ex) {
[13:36:25.980]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:25.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:25.980]                 ...future.rng), started = ...future.startTime, 
[13:36:25.980]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:25.980]             version = "1.8"), class = "FutureResult")
[13:36:25.980]     }, finally = {
[13:36:25.980]         if (!identical(...future.workdir, getwd())) 
[13:36:25.980]             setwd(...future.workdir)
[13:36:25.980]         {
[13:36:25.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:25.980]                 ...future.oldOptions$nwarnings <- NULL
[13:36:25.980]             }
[13:36:25.980]             base::options(...future.oldOptions)
[13:36:25.980]             if (.Platform$OS.type == "windows") {
[13:36:25.980]                 old_names <- names(...future.oldEnvVars)
[13:36:25.980]                 envs <- base::Sys.getenv()
[13:36:25.980]                 names <- names(envs)
[13:36:25.980]                 common <- intersect(names, old_names)
[13:36:25.980]                 added <- setdiff(names, old_names)
[13:36:25.980]                 removed <- setdiff(old_names, names)
[13:36:25.980]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:25.980]                   envs[common]]
[13:36:25.980]                 NAMES <- toupper(changed)
[13:36:25.980]                 args <- list()
[13:36:25.980]                 for (kk in seq_along(NAMES)) {
[13:36:25.980]                   name <- changed[[kk]]
[13:36:25.980]                   NAME <- NAMES[[kk]]
[13:36:25.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.980]                     next
[13:36:25.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.980]                 }
[13:36:25.980]                 NAMES <- toupper(added)
[13:36:25.980]                 for (kk in seq_along(NAMES)) {
[13:36:25.980]                   name <- added[[kk]]
[13:36:25.980]                   NAME <- NAMES[[kk]]
[13:36:25.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.980]                     next
[13:36:25.980]                   args[[name]] <- ""
[13:36:25.980]                 }
[13:36:25.980]                 NAMES <- toupper(removed)
[13:36:25.980]                 for (kk in seq_along(NAMES)) {
[13:36:25.980]                   name <- removed[[kk]]
[13:36:25.980]                   NAME <- NAMES[[kk]]
[13:36:25.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:25.980]                     next
[13:36:25.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:25.980]                 }
[13:36:25.980]                 if (length(args) > 0) 
[13:36:25.980]                   base::do.call(base::Sys.setenv, args = args)
[13:36:25.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:25.980]             }
[13:36:25.980]             else {
[13:36:25.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:25.980]             }
[13:36:25.980]             {
[13:36:25.980]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:25.980]                   0L) {
[13:36:25.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:25.980]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:25.980]                   base::options(opts)
[13:36:25.980]                 }
[13:36:25.980]                 {
[13:36:25.980]                   {
[13:36:25.980]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:25.980]                     NULL
[13:36:25.980]                   }
[13:36:25.980]                   options(future.plan = NULL)
[13:36:25.980]                   if (is.na(NA_character_)) 
[13:36:25.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:25.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:25.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:25.980]                     .init = FALSE)
[13:36:25.980]                 }
[13:36:25.980]             }
[13:36:25.980]         }
[13:36:25.980]     })
[13:36:25.980]     if (TRUE) {
[13:36:25.980]         base::sink(type = "output", split = FALSE)
[13:36:25.980]         if (TRUE) {
[13:36:25.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:25.980]         }
[13:36:25.980]         else {
[13:36:25.980]             ...future.result["stdout"] <- base::list(NULL)
[13:36:25.980]         }
[13:36:25.980]         base::close(...future.stdout)
[13:36:25.980]         ...future.stdout <- NULL
[13:36:25.980]     }
[13:36:25.980]     ...future.result$conditions <- ...future.conditions
[13:36:25.980]     ...future.result$finished <- base::Sys.time()
[13:36:25.980]     ...future.result
[13:36:25.980] }
[13:36:25.982] requestCore(): workers = 2
[13:36:25.984] MulticoreFuture started
[13:36:25.984] - Launch lazy future ... done
[13:36:25.985] run() for ‘MulticoreFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:36:25.985] plan(): Setting new future strategy stack:
[13:36:25.986] result() for MulticoreFuture ...
[13:36:25.986] result() for MulticoreFuture ... done
[13:36:25.986] result() for MulticoreFuture ...
[13:36:25.986] result() for MulticoreFuture ... done
[13:36:25.986] List of future strategies:
[13:36:25.986] 1. sequential:
[13:36:25.986]    - args: function (..., envir = parent.frame())
[13:36:25.986]    - tweaked: FALSE
[13:36:25.986]    - call: NULL
[13:36:25.986] signalConditions() ...
[13:36:25.986]  - include = ‘immediateCondition’
[13:36:25.987] plan(): nbrOfWorkers() = 1
[13:36:25.987]  - exclude = 
[13:36:25.987]  - resignal = FALSE
[13:36:25.987]  - Number of conditions: 1
[13:36:25.987] signalConditions() ... done
[13:36:25.987] Future state: ‘finished’
[13:36:25.987] result() for MulticoreFuture ...
[13:36:25.988] result() for MulticoreFuture ... done
[13:36:25.988] signalConditions() ...
[13:36:25.988]  - include = ‘condition’
[13:36:25.988]  - exclude = ‘immediateCondition’
[13:36:25.988]  - resignal = TRUE
[13:36:25.988]  - Number of conditions: 1
[13:36:25.988] plan(): Setting new future strategy stack:
[13:36:25.988]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:25.989] signalConditions() ... done
v3: <simpleError> (as expect)
[13:36:25.989] result() for MulticoreFuture ...
[13:36:25.989] List of future strategies:
[13:36:25.989] 1. multicore:
[13:36:25.989]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:25.989]    - tweaked: FALSE
[13:36:25.989]    - call: plan(strategy)
[13:36:25.993] plan(): nbrOfWorkers() = 2
[13:36:25.994] result() for MulticoreFuture ...
[13:36:25.994] result() for MulticoreFuture ... done
[13:36:25.995] result() for MulticoreFuture ... done
[13:36:25.995] result() for MulticoreFuture ...
[13:36:25.995] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:36:25.995] getGlobalsAndPackages() ...
[13:36:25.996] Searching for globals...
[13:36:25.996] 
[13:36:25.996] Searching for globals ... DONE
[13:36:25.996] - globals: [0] <none>
[13:36:25.996] getGlobalsAndPackages() ... DONE
[13:36:25.997] run() for ‘Future’ ...
[13:36:25.997] - state: ‘created’
[13:36:25.997] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.002] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:26.002]   - Field: ‘label’
[13:36:26.002]   - Field: ‘local’
[13:36:26.002]   - Field: ‘owner’
[13:36:26.002]   - Field: ‘envir’
[13:36:26.002]   - Field: ‘workers’
[13:36:26.002]   - Field: ‘packages’
[13:36:26.003]   - Field: ‘gc’
[13:36:26.003]   - Field: ‘job’
[13:36:26.003]   - Field: ‘conditions’
[13:36:26.003]   - Field: ‘expr’
[13:36:26.003]   - Field: ‘uuid’
[13:36:26.003]   - Field: ‘seed’
[13:36:26.003]   - Field: ‘version’
[13:36:26.003]   - Field: ‘result’
[13:36:26.003]   - Field: ‘asynchronous’
[13:36:26.004]   - Field: ‘calls’
[13:36:26.004]   - Field: ‘globals’
[13:36:26.004]   - Field: ‘stdout’
[13:36:26.004]   - Field: ‘earlySignal’
[13:36:26.004]   - Field: ‘lazy’
[13:36:26.004]   - Field: ‘state’
[13:36:26.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:26.004] - Launch lazy future ...
[13:36:26.005] Packages needed by the future expression (n = 0): <none>
[13:36:26.005] Packages needed by future strategies (n = 0): <none>
[13:36:26.005] {
[13:36:26.005]     {
[13:36:26.005]         {
[13:36:26.005]             ...future.startTime <- base::Sys.time()
[13:36:26.005]             {
[13:36:26.005]                 {
[13:36:26.005]                   {
[13:36:26.005]                     {
[13:36:26.005]                       base::local({
[13:36:26.005]                         has_future <- base::requireNamespace("future", 
[13:36:26.005]                           quietly = TRUE)
[13:36:26.005]                         if (has_future) {
[13:36:26.005]                           ns <- base::getNamespace("future")
[13:36:26.005]                           version <- ns[[".package"]][["version"]]
[13:36:26.005]                           if (is.null(version)) 
[13:36:26.005]                             version <- utils::packageVersion("future")
[13:36:26.005]                         }
[13:36:26.005]                         else {
[13:36:26.005]                           version <- NULL
[13:36:26.005]                         }
[13:36:26.005]                         if (!has_future || version < "1.8.0") {
[13:36:26.005]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.005]                             "", base::R.version$version.string), 
[13:36:26.005]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.005]                               "release", "version")], collapse = " "), 
[13:36:26.005]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.005]                             info)
[13:36:26.005]                           info <- base::paste(info, collapse = "; ")
[13:36:26.005]                           if (!has_future) {
[13:36:26.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.005]                               info)
[13:36:26.005]                           }
[13:36:26.005]                           else {
[13:36:26.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.005]                               info, version)
[13:36:26.005]                           }
[13:36:26.005]                           base::stop(msg)
[13:36:26.005]                         }
[13:36:26.005]                       })
[13:36:26.005]                     }
[13:36:26.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.005]                     base::options(mc.cores = 1L)
[13:36:26.005]                   }
[13:36:26.005]                   ...future.strategy.old <- future::plan("list")
[13:36:26.005]                   options(future.plan = NULL)
[13:36:26.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.005]                 }
[13:36:26.005]                 ...future.workdir <- getwd()
[13:36:26.005]             }
[13:36:26.005]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.005]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.005]         }
[13:36:26.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.005]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.005]             base::names(...future.oldOptions))
[13:36:26.005]     }
[13:36:26.005]     if (FALSE) {
[13:36:26.005]     }
[13:36:26.005]     else {
[13:36:26.005]         if (TRUE) {
[13:36:26.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.005]                 open = "w")
[13:36:26.005]         }
[13:36:26.005]         else {
[13:36:26.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.005]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.005]         }
[13:36:26.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.005]             base::sink(type = "output", split = FALSE)
[13:36:26.005]             base::close(...future.stdout)
[13:36:26.005]         }, add = TRUE)
[13:36:26.005]     }
[13:36:26.005]     ...future.frame <- base::sys.nframe()
[13:36:26.005]     ...future.conditions <- base::list()
[13:36:26.005]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.005]     if (FALSE) {
[13:36:26.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.005]     }
[13:36:26.005]     ...future.result <- base::tryCatch({
[13:36:26.005]         base::withCallingHandlers({
[13:36:26.005]             ...future.value <- base::withVisible(base::local({
[13:36:26.005]                 withCallingHandlers({
[13:36:26.005]                   1
[13:36:26.005]                 }, immediateCondition = function(cond) {
[13:36:26.005]                   save_rds <- function (object, pathname, ...) 
[13:36:26.005]                   {
[13:36:26.005]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:26.005]                     if (file_test("-f", pathname_tmp)) {
[13:36:26.005]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.005]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:26.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.005]                         fi_tmp[["mtime"]])
[13:36:26.005]                     }
[13:36:26.005]                     tryCatch({
[13:36:26.005]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:26.005]                     }, error = function(ex) {
[13:36:26.005]                       msg <- conditionMessage(ex)
[13:36:26.005]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.005]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:26.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.005]                         fi_tmp[["mtime"]], msg)
[13:36:26.005]                       ex$message <- msg
[13:36:26.005]                       stop(ex)
[13:36:26.005]                     })
[13:36:26.005]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:26.005]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:26.005]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:26.005]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.005]                       fi <- file.info(pathname)
[13:36:26.005]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:26.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.005]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:26.005]                         fi[["size"]], fi[["mtime"]])
[13:36:26.005]                       stop(msg)
[13:36:26.005]                     }
[13:36:26.005]                     invisible(pathname)
[13:36:26.005]                   }
[13:36:26.005]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:26.005]                     rootPath = tempdir()) 
[13:36:26.005]                   {
[13:36:26.005]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:26.005]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:26.005]                       tmpdir = path, fileext = ".rds")
[13:36:26.005]                     save_rds(obj, file)
[13:36:26.005]                   }
[13:36:26.005]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:26.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.005]                   {
[13:36:26.005]                     inherits <- base::inherits
[13:36:26.005]                     invokeRestart <- base::invokeRestart
[13:36:26.005]                     is.null <- base::is.null
[13:36:26.005]                     muffled <- FALSE
[13:36:26.005]                     if (inherits(cond, "message")) {
[13:36:26.005]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.005]                       if (muffled) 
[13:36:26.005]                         invokeRestart("muffleMessage")
[13:36:26.005]                     }
[13:36:26.005]                     else if (inherits(cond, "warning")) {
[13:36:26.005]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.005]                       if (muffled) 
[13:36:26.005]                         invokeRestart("muffleWarning")
[13:36:26.005]                     }
[13:36:26.005]                     else if (inherits(cond, "condition")) {
[13:36:26.005]                       if (!is.null(pattern)) {
[13:36:26.005]                         computeRestarts <- base::computeRestarts
[13:36:26.005]                         grepl <- base::grepl
[13:36:26.005]                         restarts <- computeRestarts(cond)
[13:36:26.005]                         for (restart in restarts) {
[13:36:26.005]                           name <- restart$name
[13:36:26.005]                           if (is.null(name)) 
[13:36:26.005]                             next
[13:36:26.005]                           if (!grepl(pattern, name)) 
[13:36:26.005]                             next
[13:36:26.005]                           invokeRestart(restart)
[13:36:26.005]                           muffled <- TRUE
[13:36:26.005]                           break
[13:36:26.005]                         }
[13:36:26.005]                       }
[13:36:26.005]                     }
[13:36:26.005]                     invisible(muffled)
[13:36:26.005]                   }
[13:36:26.005]                   muffleCondition(cond)
[13:36:26.005]                 })
[13:36:26.005]             }))
[13:36:26.005]             future::FutureResult(value = ...future.value$value, 
[13:36:26.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.005]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.005]                     ...future.globalenv.names))
[13:36:26.005]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.005]         }, condition = base::local({
[13:36:26.005]             c <- base::c
[13:36:26.005]             inherits <- base::inherits
[13:36:26.005]             invokeRestart <- base::invokeRestart
[13:36:26.005]             length <- base::length
[13:36:26.005]             list <- base::list
[13:36:26.005]             seq.int <- base::seq.int
[13:36:26.005]             signalCondition <- base::signalCondition
[13:36:26.005]             sys.calls <- base::sys.calls
[13:36:26.005]             `[[` <- base::`[[`
[13:36:26.005]             `+` <- base::`+`
[13:36:26.005]             `<<-` <- base::`<<-`
[13:36:26.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.005]                   3L)]
[13:36:26.005]             }
[13:36:26.005]             function(cond) {
[13:36:26.005]                 is_error <- inherits(cond, "error")
[13:36:26.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.005]                   NULL)
[13:36:26.005]                 if (is_error) {
[13:36:26.005]                   sessionInformation <- function() {
[13:36:26.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.005]                       search = base::search(), system = base::Sys.info())
[13:36:26.005]                   }
[13:36:26.005]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.005]                     cond$call), session = sessionInformation(), 
[13:36:26.005]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.005]                   signalCondition(cond)
[13:36:26.005]                 }
[13:36:26.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.005]                 "immediateCondition"))) {
[13:36:26.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.005]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.005]                   if (TRUE && !signal) {
[13:36:26.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.005]                     {
[13:36:26.005]                       inherits <- base::inherits
[13:36:26.005]                       invokeRestart <- base::invokeRestart
[13:36:26.005]                       is.null <- base::is.null
[13:36:26.005]                       muffled <- FALSE
[13:36:26.005]                       if (inherits(cond, "message")) {
[13:36:26.005]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.005]                         if (muffled) 
[13:36:26.005]                           invokeRestart("muffleMessage")
[13:36:26.005]                       }
[13:36:26.005]                       else if (inherits(cond, "warning")) {
[13:36:26.005]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.005]                         if (muffled) 
[13:36:26.005]                           invokeRestart("muffleWarning")
[13:36:26.005]                       }
[13:36:26.005]                       else if (inherits(cond, "condition")) {
[13:36:26.005]                         if (!is.null(pattern)) {
[13:36:26.005]                           computeRestarts <- base::computeRestarts
[13:36:26.005]                           grepl <- base::grepl
[13:36:26.005]                           restarts <- computeRestarts(cond)
[13:36:26.005]                           for (restart in restarts) {
[13:36:26.005]                             name <- restart$name
[13:36:26.005]                             if (is.null(name)) 
[13:36:26.005]                               next
[13:36:26.005]                             if (!grepl(pattern, name)) 
[13:36:26.005]                               next
[13:36:26.005]                             invokeRestart(restart)
[13:36:26.005]                             muffled <- TRUE
[13:36:26.005]                             break
[13:36:26.005]                           }
[13:36:26.005]                         }
[13:36:26.005]                       }
[13:36:26.005]                       invisible(muffled)
[13:36:26.005]                     }
[13:36:26.005]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.005]                   }
[13:36:26.005]                 }
[13:36:26.005]                 else {
[13:36:26.005]                   if (TRUE) {
[13:36:26.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.005]                     {
[13:36:26.005]                       inherits <- base::inherits
[13:36:26.005]                       invokeRestart <- base::invokeRestart
[13:36:26.005]                       is.null <- base::is.null
[13:36:26.005]                       muffled <- FALSE
[13:36:26.005]                       if (inherits(cond, "message")) {
[13:36:26.005]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.005]                         if (muffled) 
[13:36:26.005]                           invokeRestart("muffleMessage")
[13:36:26.005]                       }
[13:36:26.005]                       else if (inherits(cond, "warning")) {
[13:36:26.005]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.005]                         if (muffled) 
[13:36:26.005]                           invokeRestart("muffleWarning")
[13:36:26.005]                       }
[13:36:26.005]                       else if (inherits(cond, "condition")) {
[13:36:26.005]                         if (!is.null(pattern)) {
[13:36:26.005]                           computeRestarts <- base::computeRestarts
[13:36:26.005]                           grepl <- base::grepl
[13:36:26.005]                           restarts <- computeRestarts(cond)
[13:36:26.005]                           for (restart in restarts) {
[13:36:26.005]                             name <- restart$name
[13:36:26.005]                             if (is.null(name)) 
[13:36:26.005]                               next
[13:36:26.005]                             if (!grepl(pattern, name)) 
[13:36:26.005]                               next
[13:36:26.005]                             invokeRestart(restart)
[13:36:26.005]                             muffled <- TRUE
[13:36:26.005]                             break
[13:36:26.005]                           }
[13:36:26.005]                         }
[13:36:26.005]                       }
[13:36:26.005]                       invisible(muffled)
[13:36:26.005]                     }
[13:36:26.005]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.005]                   }
[13:36:26.005]                 }
[13:36:26.005]             }
[13:36:26.005]         }))
[13:36:26.005]     }, error = function(ex) {
[13:36:26.005]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.005]                 ...future.rng), started = ...future.startTime, 
[13:36:26.005]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.005]             version = "1.8"), class = "FutureResult")
[13:36:26.005]     }, finally = {
[13:36:26.005]         if (!identical(...future.workdir, getwd())) 
[13:36:26.005]             setwd(...future.workdir)
[13:36:26.005]         {
[13:36:26.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.005]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.005]             }
[13:36:26.005]             base::options(...future.oldOptions)
[13:36:26.005]             if (.Platform$OS.type == "windows") {
[13:36:26.005]                 old_names <- names(...future.oldEnvVars)
[13:36:26.005]                 envs <- base::Sys.getenv()
[13:36:26.005]                 names <- names(envs)
[13:36:26.005]                 common <- intersect(names, old_names)
[13:36:26.005]                 added <- setdiff(names, old_names)
[13:36:26.005]                 removed <- setdiff(old_names, names)
[13:36:26.005]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.005]                   envs[common]]
[13:36:26.005]                 NAMES <- toupper(changed)
[13:36:26.005]                 args <- list()
[13:36:26.005]                 for (kk in seq_along(NAMES)) {
[13:36:26.005]                   name <- changed[[kk]]
[13:36:26.005]                   NAME <- NAMES[[kk]]
[13:36:26.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.005]                     next
[13:36:26.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.005]                 }
[13:36:26.005]                 NAMES <- toupper(added)
[13:36:26.005]                 for (kk in seq_along(NAMES)) {
[13:36:26.005]                   name <- added[[kk]]
[13:36:26.005]                   NAME <- NAMES[[kk]]
[13:36:26.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.005]                     next
[13:36:26.005]                   args[[name]] <- ""
[13:36:26.005]                 }
[13:36:26.005]                 NAMES <- toupper(removed)
[13:36:26.005]                 for (kk in seq_along(NAMES)) {
[13:36:26.005]                   name <- removed[[kk]]
[13:36:26.005]                   NAME <- NAMES[[kk]]
[13:36:26.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.005]                     next
[13:36:26.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.005]                 }
[13:36:26.005]                 if (length(args) > 0) 
[13:36:26.005]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.005]             }
[13:36:26.005]             else {
[13:36:26.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.005]             }
[13:36:26.005]             {
[13:36:26.005]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.005]                   0L) {
[13:36:26.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.005]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.005]                   base::options(opts)
[13:36:26.005]                 }
[13:36:26.005]                 {
[13:36:26.005]                   {
[13:36:26.005]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.005]                     NULL
[13:36:26.005]                   }
[13:36:26.005]                   options(future.plan = NULL)
[13:36:26.005]                   if (is.na(NA_character_)) 
[13:36:26.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.005]                     .init = FALSE)
[13:36:26.005]                 }
[13:36:26.005]             }
[13:36:26.005]         }
[13:36:26.005]     })
[13:36:26.005]     if (TRUE) {
[13:36:26.005]         base::sink(type = "output", split = FALSE)
[13:36:26.005]         if (TRUE) {
[13:36:26.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.005]         }
[13:36:26.005]         else {
[13:36:26.005]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.005]         }
[13:36:26.005]         base::close(...future.stdout)
[13:36:26.005]         ...future.stdout <- NULL
[13:36:26.005]     }
[13:36:26.005]     ...future.result$conditions <- ...future.conditions
[13:36:26.005]     ...future.result$finished <- base::Sys.time()
[13:36:26.005]     ...future.result
[13:36:26.005] }
[13:36:26.011] requestCore(): workers = 2
[13:36:26.013] MulticoreFuture started
[13:36:26.013] - Launch lazy future ... done
[13:36:26.013] run() for ‘MulticoreFuture’ ... done
[13:36:26.014] result() for MulticoreFuture ...
[13:36:26.014] plan(): Setting new future strategy stack:
[13:36:26.014] List of future strategies:
[13:36:26.014] 1. sequential:
[13:36:26.014]    - args: function (..., envir = parent.frame())
[13:36:26.014]    - tweaked: FALSE
[13:36:26.014]    - call: NULL
[13:36:26.015] plan(): nbrOfWorkers() = 1
[13:36:26.018] plan(): Setting new future strategy stack:
[13:36:26.018] List of future strategies:
[13:36:26.018] 1. multicore:
[13:36:26.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:26.018]    - tweaked: FALSE
[13:36:26.018]    - call: plan(strategy)
[13:36:26.024] plan(): nbrOfWorkers() = 2
[13:36:26.025] result() for MulticoreFuture ...
[13:36:26.025] result() for MulticoreFuture ... done
[13:36:26.025] result() for MulticoreFuture ... done
[13:36:26.025] result() for MulticoreFuture ...
[13:36:26.025] result() for MulticoreFuture ... done
c = 1
[13:36:26.026] getGlobalsAndPackages() ...
[13:36:26.026] Searching for globals...
[13:36:26.027] 
[13:36:26.027] Searching for globals ... DONE
[13:36:26.027] - globals: [0] <none>
[13:36:26.027] getGlobalsAndPackages() ... DONE
[13:36:26.027] run() for ‘Future’ ...
[13:36:26.028] - state: ‘created’
[13:36:26.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.032] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:26.032]   - Field: ‘label’
[13:36:26.032]   - Field: ‘local’
[13:36:26.032]   - Field: ‘owner’
[13:36:26.033]   - Field: ‘envir’
[13:36:26.033]   - Field: ‘workers’
[13:36:26.033]   - Field: ‘packages’
[13:36:26.033]   - Field: ‘gc’
[13:36:26.033]   - Field: ‘job’
[13:36:26.033]   - Field: ‘conditions’
[13:36:26.033]   - Field: ‘expr’
[13:36:26.033]   - Field: ‘uuid’
[13:36:26.034]   - Field: ‘seed’
[13:36:26.034]   - Field: ‘version’
[13:36:26.034]   - Field: ‘result’
[13:36:26.034]   - Field: ‘asynchronous’
[13:36:26.034]   - Field: ‘calls’
[13:36:26.034]   - Field: ‘globals’
[13:36:26.034]   - Field: ‘stdout’
[13:36:26.034]   - Field: ‘earlySignal’
[13:36:26.035]   - Field: ‘lazy’
[13:36:26.035]   - Field: ‘state’
[13:36:26.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:26.035] - Launch lazy future ...
[13:36:26.035] Packages needed by the future expression (n = 0): <none>
[13:36:26.035] Packages needed by future strategies (n = 0): <none>
[13:36:26.036] {
[13:36:26.036]     {
[13:36:26.036]         {
[13:36:26.036]             ...future.startTime <- base::Sys.time()
[13:36:26.036]             {
[13:36:26.036]                 {
[13:36:26.036]                   {
[13:36:26.036]                     {
[13:36:26.036]                       base::local({
[13:36:26.036]                         has_future <- base::requireNamespace("future", 
[13:36:26.036]                           quietly = TRUE)
[13:36:26.036]                         if (has_future) {
[13:36:26.036]                           ns <- base::getNamespace("future")
[13:36:26.036]                           version <- ns[[".package"]][["version"]]
[13:36:26.036]                           if (is.null(version)) 
[13:36:26.036]                             version <- utils::packageVersion("future")
[13:36:26.036]                         }
[13:36:26.036]                         else {
[13:36:26.036]                           version <- NULL
[13:36:26.036]                         }
[13:36:26.036]                         if (!has_future || version < "1.8.0") {
[13:36:26.036]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.036]                             "", base::R.version$version.string), 
[13:36:26.036]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.036]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.036]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.036]                               "release", "version")], collapse = " "), 
[13:36:26.036]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.036]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.036]                             info)
[13:36:26.036]                           info <- base::paste(info, collapse = "; ")
[13:36:26.036]                           if (!has_future) {
[13:36:26.036]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.036]                               info)
[13:36:26.036]                           }
[13:36:26.036]                           else {
[13:36:26.036]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.036]                               info, version)
[13:36:26.036]                           }
[13:36:26.036]                           base::stop(msg)
[13:36:26.036]                         }
[13:36:26.036]                       })
[13:36:26.036]                     }
[13:36:26.036]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.036]                     base::options(mc.cores = 1L)
[13:36:26.036]                   }
[13:36:26.036]                   ...future.strategy.old <- future::plan("list")
[13:36:26.036]                   options(future.plan = NULL)
[13:36:26.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.036]                 }
[13:36:26.036]                 ...future.workdir <- getwd()
[13:36:26.036]             }
[13:36:26.036]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.036]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.036]         }
[13:36:26.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.036]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.036]             base::names(...future.oldOptions))
[13:36:26.036]     }
[13:36:26.036]     if (FALSE) {
[13:36:26.036]     }
[13:36:26.036]     else {
[13:36:26.036]         if (TRUE) {
[13:36:26.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.036]                 open = "w")
[13:36:26.036]         }
[13:36:26.036]         else {
[13:36:26.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.036]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.036]         }
[13:36:26.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.036]             base::sink(type = "output", split = FALSE)
[13:36:26.036]             base::close(...future.stdout)
[13:36:26.036]         }, add = TRUE)
[13:36:26.036]     }
[13:36:26.036]     ...future.frame <- base::sys.nframe()
[13:36:26.036]     ...future.conditions <- base::list()
[13:36:26.036]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.036]     if (FALSE) {
[13:36:26.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.036]     }
[13:36:26.036]     ...future.result <- base::tryCatch({
[13:36:26.036]         base::withCallingHandlers({
[13:36:26.036]             ...future.value <- base::withVisible(base::local({
[13:36:26.036]                 withCallingHandlers({
[13:36:26.036]                   1
[13:36:26.036]                 }, immediateCondition = function(cond) {
[13:36:26.036]                   save_rds <- function (object, pathname, ...) 
[13:36:26.036]                   {
[13:36:26.036]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:26.036]                     if (file_test("-f", pathname_tmp)) {
[13:36:26.036]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.036]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:26.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.036]                         fi_tmp[["mtime"]])
[13:36:26.036]                     }
[13:36:26.036]                     tryCatch({
[13:36:26.036]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:26.036]                     }, error = function(ex) {
[13:36:26.036]                       msg <- conditionMessage(ex)
[13:36:26.036]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.036]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:26.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.036]                         fi_tmp[["mtime"]], msg)
[13:36:26.036]                       ex$message <- msg
[13:36:26.036]                       stop(ex)
[13:36:26.036]                     })
[13:36:26.036]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:26.036]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:26.036]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:26.036]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.036]                       fi <- file.info(pathname)
[13:36:26.036]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:26.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.036]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:26.036]                         fi[["size"]], fi[["mtime"]])
[13:36:26.036]                       stop(msg)
[13:36:26.036]                     }
[13:36:26.036]                     invisible(pathname)
[13:36:26.036]                   }
[13:36:26.036]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:26.036]                     rootPath = tempdir()) 
[13:36:26.036]                   {
[13:36:26.036]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:26.036]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:26.036]                       tmpdir = path, fileext = ".rds")
[13:36:26.036]                     save_rds(obj, file)
[13:36:26.036]                   }
[13:36:26.036]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:26.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.036]                   {
[13:36:26.036]                     inherits <- base::inherits
[13:36:26.036]                     invokeRestart <- base::invokeRestart
[13:36:26.036]                     is.null <- base::is.null
[13:36:26.036]                     muffled <- FALSE
[13:36:26.036]                     if (inherits(cond, "message")) {
[13:36:26.036]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.036]                       if (muffled) 
[13:36:26.036]                         invokeRestart("muffleMessage")
[13:36:26.036]                     }
[13:36:26.036]                     else if (inherits(cond, "warning")) {
[13:36:26.036]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.036]                       if (muffled) 
[13:36:26.036]                         invokeRestart("muffleWarning")
[13:36:26.036]                     }
[13:36:26.036]                     else if (inherits(cond, "condition")) {
[13:36:26.036]                       if (!is.null(pattern)) {
[13:36:26.036]                         computeRestarts <- base::computeRestarts
[13:36:26.036]                         grepl <- base::grepl
[13:36:26.036]                         restarts <- computeRestarts(cond)
[13:36:26.036]                         for (restart in restarts) {
[13:36:26.036]                           name <- restart$name
[13:36:26.036]                           if (is.null(name)) 
[13:36:26.036]                             next
[13:36:26.036]                           if (!grepl(pattern, name)) 
[13:36:26.036]                             next
[13:36:26.036]                           invokeRestart(restart)
[13:36:26.036]                           muffled <- TRUE
[13:36:26.036]                           break
[13:36:26.036]                         }
[13:36:26.036]                       }
[13:36:26.036]                     }
[13:36:26.036]                     invisible(muffled)
[13:36:26.036]                   }
[13:36:26.036]                   muffleCondition(cond)
[13:36:26.036]                 })
[13:36:26.036]             }))
[13:36:26.036]             future::FutureResult(value = ...future.value$value, 
[13:36:26.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.036]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.036]                     ...future.globalenv.names))
[13:36:26.036]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.036]         }, condition = base::local({
[13:36:26.036]             c <- base::c
[13:36:26.036]             inherits <- base::inherits
[13:36:26.036]             invokeRestart <- base::invokeRestart
[13:36:26.036]             length <- base::length
[13:36:26.036]             list <- base::list
[13:36:26.036]             seq.int <- base::seq.int
[13:36:26.036]             signalCondition <- base::signalCondition
[13:36:26.036]             sys.calls <- base::sys.calls
[13:36:26.036]             `[[` <- base::`[[`
[13:36:26.036]             `+` <- base::`+`
[13:36:26.036]             `<<-` <- base::`<<-`
[13:36:26.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.036]                   3L)]
[13:36:26.036]             }
[13:36:26.036]             function(cond) {
[13:36:26.036]                 is_error <- inherits(cond, "error")
[13:36:26.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.036]                   NULL)
[13:36:26.036]                 if (is_error) {
[13:36:26.036]                   sessionInformation <- function() {
[13:36:26.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.036]                       search = base::search(), system = base::Sys.info())
[13:36:26.036]                   }
[13:36:26.036]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.036]                     cond$call), session = sessionInformation(), 
[13:36:26.036]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.036]                   signalCondition(cond)
[13:36:26.036]                 }
[13:36:26.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.036]                 "immediateCondition"))) {
[13:36:26.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.036]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.036]                   if (TRUE && !signal) {
[13:36:26.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.036]                     {
[13:36:26.036]                       inherits <- base::inherits
[13:36:26.036]                       invokeRestart <- base::invokeRestart
[13:36:26.036]                       is.null <- base::is.null
[13:36:26.036]                       muffled <- FALSE
[13:36:26.036]                       if (inherits(cond, "message")) {
[13:36:26.036]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.036]                         if (muffled) 
[13:36:26.036]                           invokeRestart("muffleMessage")
[13:36:26.036]                       }
[13:36:26.036]                       else if (inherits(cond, "warning")) {
[13:36:26.036]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.036]                         if (muffled) 
[13:36:26.036]                           invokeRestart("muffleWarning")
[13:36:26.036]                       }
[13:36:26.036]                       else if (inherits(cond, "condition")) {
[13:36:26.036]                         if (!is.null(pattern)) {
[13:36:26.036]                           computeRestarts <- base::computeRestarts
[13:36:26.036]                           grepl <- base::grepl
[13:36:26.036]                           restarts <- computeRestarts(cond)
[13:36:26.036]                           for (restart in restarts) {
[13:36:26.036]                             name <- restart$name
[13:36:26.036]                             if (is.null(name)) 
[13:36:26.036]                               next
[13:36:26.036]                             if (!grepl(pattern, name)) 
[13:36:26.036]                               next
[13:36:26.036]                             invokeRestart(restart)
[13:36:26.036]                             muffled <- TRUE
[13:36:26.036]                             break
[13:36:26.036]                           }
[13:36:26.036]                         }
[13:36:26.036]                       }
[13:36:26.036]                       invisible(muffled)
[13:36:26.036]                     }
[13:36:26.036]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.036]                   }
[13:36:26.036]                 }
[13:36:26.036]                 else {
[13:36:26.036]                   if (TRUE) {
[13:36:26.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.036]                     {
[13:36:26.036]                       inherits <- base::inherits
[13:36:26.036]                       invokeRestart <- base::invokeRestart
[13:36:26.036]                       is.null <- base::is.null
[13:36:26.036]                       muffled <- FALSE
[13:36:26.036]                       if (inherits(cond, "message")) {
[13:36:26.036]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.036]                         if (muffled) 
[13:36:26.036]                           invokeRestart("muffleMessage")
[13:36:26.036]                       }
[13:36:26.036]                       else if (inherits(cond, "warning")) {
[13:36:26.036]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.036]                         if (muffled) 
[13:36:26.036]                           invokeRestart("muffleWarning")
[13:36:26.036]                       }
[13:36:26.036]                       else if (inherits(cond, "condition")) {
[13:36:26.036]                         if (!is.null(pattern)) {
[13:36:26.036]                           computeRestarts <- base::computeRestarts
[13:36:26.036]                           grepl <- base::grepl
[13:36:26.036]                           restarts <- computeRestarts(cond)
[13:36:26.036]                           for (restart in restarts) {
[13:36:26.036]                             name <- restart$name
[13:36:26.036]                             if (is.null(name)) 
[13:36:26.036]                               next
[13:36:26.036]                             if (!grepl(pattern, name)) 
[13:36:26.036]                               next
[13:36:26.036]                             invokeRestart(restart)
[13:36:26.036]                             muffled <- TRUE
[13:36:26.036]                             break
[13:36:26.036]                           }
[13:36:26.036]                         }
[13:36:26.036]                       }
[13:36:26.036]                       invisible(muffled)
[13:36:26.036]                     }
[13:36:26.036]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.036]                   }
[13:36:26.036]                 }
[13:36:26.036]             }
[13:36:26.036]         }))
[13:36:26.036]     }, error = function(ex) {
[13:36:26.036]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.036]                 ...future.rng), started = ...future.startTime, 
[13:36:26.036]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.036]             version = "1.8"), class = "FutureResult")
[13:36:26.036]     }, finally = {
[13:36:26.036]         if (!identical(...future.workdir, getwd())) 
[13:36:26.036]             setwd(...future.workdir)
[13:36:26.036]         {
[13:36:26.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.036]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.036]             }
[13:36:26.036]             base::options(...future.oldOptions)
[13:36:26.036]             if (.Platform$OS.type == "windows") {
[13:36:26.036]                 old_names <- names(...future.oldEnvVars)
[13:36:26.036]                 envs <- base::Sys.getenv()
[13:36:26.036]                 names <- names(envs)
[13:36:26.036]                 common <- intersect(names, old_names)
[13:36:26.036]                 added <- setdiff(names, old_names)
[13:36:26.036]                 removed <- setdiff(old_names, names)
[13:36:26.036]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.036]                   envs[common]]
[13:36:26.036]                 NAMES <- toupper(changed)
[13:36:26.036]                 args <- list()
[13:36:26.036]                 for (kk in seq_along(NAMES)) {
[13:36:26.036]                   name <- changed[[kk]]
[13:36:26.036]                   NAME <- NAMES[[kk]]
[13:36:26.036]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.036]                     next
[13:36:26.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.036]                 }
[13:36:26.036]                 NAMES <- toupper(added)
[13:36:26.036]                 for (kk in seq_along(NAMES)) {
[13:36:26.036]                   name <- added[[kk]]
[13:36:26.036]                   NAME <- NAMES[[kk]]
[13:36:26.036]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.036]                     next
[13:36:26.036]                   args[[name]] <- ""
[13:36:26.036]                 }
[13:36:26.036]                 NAMES <- toupper(removed)
[13:36:26.036]                 for (kk in seq_along(NAMES)) {
[13:36:26.036]                   name <- removed[[kk]]
[13:36:26.036]                   NAME <- NAMES[[kk]]
[13:36:26.036]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.036]                     next
[13:36:26.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.036]                 }
[13:36:26.036]                 if (length(args) > 0) 
[13:36:26.036]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.036]             }
[13:36:26.036]             else {
[13:36:26.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.036]             }
[13:36:26.036]             {
[13:36:26.036]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.036]                   0L) {
[13:36:26.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.036]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.036]                   base::options(opts)
[13:36:26.036]                 }
[13:36:26.036]                 {
[13:36:26.036]                   {
[13:36:26.036]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.036]                     NULL
[13:36:26.036]                   }
[13:36:26.036]                   options(future.plan = NULL)
[13:36:26.036]                   if (is.na(NA_character_)) 
[13:36:26.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.036]                     .init = FALSE)
[13:36:26.036]                 }
[13:36:26.036]             }
[13:36:26.036]         }
[13:36:26.036]     })
[13:36:26.036]     if (TRUE) {
[13:36:26.036]         base::sink(type = "output", split = FALSE)
[13:36:26.036]         if (TRUE) {
[13:36:26.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.036]         }
[13:36:26.036]         else {
[13:36:26.036]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.036]         }
[13:36:26.036]         base::close(...future.stdout)
[13:36:26.036]         ...future.stdout <- NULL
[13:36:26.036]     }
[13:36:26.036]     ...future.result$conditions <- ...future.conditions
[13:36:26.036]     ...future.result$finished <- base::Sys.time()
[13:36:26.036]     ...future.result
[13:36:26.036] }
[13:36:26.039] requestCore(): workers = 2
[13:36:26.040] MulticoreFuture started
[13:36:26.041] - Launch lazy future ... done
[13:36:26.041] run() for ‘MulticoreFuture’ ... done
[13:36:26.041] result() for MulticoreFuture ...
[13:36:26.041] plan(): Setting new future strategy stack:
[13:36:26.042] List of future strategies:
[13:36:26.042] 1. sequential:
[13:36:26.042]    - args: function (..., envir = parent.frame())
[13:36:26.042]    - tweaked: FALSE
[13:36:26.042]    - call: NULL
[13:36:26.042] plan(): nbrOfWorkers() = 1
[13:36:26.044] plan(): Setting new future strategy stack:
[13:36:26.044] List of future strategies:
[13:36:26.044] 1. multicore:
[13:36:26.044]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:26.044]    - tweaked: FALSE
[13:36:26.044]    - call: plan(strategy)
[13:36:26.050] plan(): nbrOfWorkers() = 2
[13:36:26.050] result() for MulticoreFuture ...
[13:36:26.051] result() for MulticoreFuture ... done
[13:36:26.051] result() for MulticoreFuture ... done
[13:36:26.051] result() for MulticoreFuture ...
[13:36:26.051] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[13:36:26.052] getGlobalsAndPackages() ...
[13:36:26.052] Searching for globals...
[13:36:26.057] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:36:26.057] Searching for globals ... DONE
[13:36:26.057] Resolving globals: FALSE
[13:36:26.057] 
[13:36:26.058] - packages: [1] ‘future’
[13:36:26.058] getGlobalsAndPackages() ... DONE
[13:36:26.058] run() for ‘Future’ ...
[13:36:26.058] - state: ‘created’
[13:36:26.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:26.063]   - Field: ‘label’
[13:36:26.063]   - Field: ‘local’
[13:36:26.063]   - Field: ‘owner’
[13:36:26.063]   - Field: ‘envir’
[13:36:26.063]   - Field: ‘workers’
[13:36:26.063]   - Field: ‘packages’
[13:36:26.063]   - Field: ‘gc’
[13:36:26.063]   - Field: ‘job’
[13:36:26.064]   - Field: ‘conditions’
[13:36:26.064]   - Field: ‘expr’
[13:36:26.064]   - Field: ‘uuid’
[13:36:26.064]   - Field: ‘seed’
[13:36:26.064]   - Field: ‘version’
[13:36:26.067]   - Field: ‘result’
[13:36:26.067]   - Field: ‘asynchronous’
[13:36:26.067]   - Field: ‘calls’
[13:36:26.067]   - Field: ‘globals’
[13:36:26.067]   - Field: ‘stdout’
[13:36:26.067]   - Field: ‘earlySignal’
[13:36:26.068]   - Field: ‘lazy’
[13:36:26.068]   - Field: ‘state’
[13:36:26.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:26.068] - Launch lazy future ...
[13:36:26.068] Packages needed by the future expression (n = 1): ‘future’
[13:36:26.069] Packages needed by future strategies (n = 0): <none>
[13:36:26.069] {
[13:36:26.069]     {
[13:36:26.069]         {
[13:36:26.069]             ...future.startTime <- base::Sys.time()
[13:36:26.069]             {
[13:36:26.069]                 {
[13:36:26.069]                   {
[13:36:26.069]                     {
[13:36:26.069]                       {
[13:36:26.069]                         base::local({
[13:36:26.069]                           has_future <- base::requireNamespace("future", 
[13:36:26.069]                             quietly = TRUE)
[13:36:26.069]                           if (has_future) {
[13:36:26.069]                             ns <- base::getNamespace("future")
[13:36:26.069]                             version <- ns[[".package"]][["version"]]
[13:36:26.069]                             if (is.null(version)) 
[13:36:26.069]                               version <- utils::packageVersion("future")
[13:36:26.069]                           }
[13:36:26.069]                           else {
[13:36:26.069]                             version <- NULL
[13:36:26.069]                           }
[13:36:26.069]                           if (!has_future || version < "1.8.0") {
[13:36:26.069]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.069]                               "", base::R.version$version.string), 
[13:36:26.069]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:26.069]                                 base::R.version$platform, 8 * 
[13:36:26.069]                                   base::.Machine$sizeof.pointer), 
[13:36:26.069]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.069]                                 "release", "version")], collapse = " "), 
[13:36:26.069]                               hostname = base::Sys.info()[["nodename"]])
[13:36:26.069]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.069]                               info)
[13:36:26.069]                             info <- base::paste(info, collapse = "; ")
[13:36:26.069]                             if (!has_future) {
[13:36:26.069]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.069]                                 info)
[13:36:26.069]                             }
[13:36:26.069]                             else {
[13:36:26.069]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.069]                                 info, version)
[13:36:26.069]                             }
[13:36:26.069]                             base::stop(msg)
[13:36:26.069]                           }
[13:36:26.069]                         })
[13:36:26.069]                       }
[13:36:26.069]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.069]                       base::options(mc.cores = 1L)
[13:36:26.069]                     }
[13:36:26.069]                     base::local({
[13:36:26.069]                       for (pkg in "future") {
[13:36:26.069]                         base::loadNamespace(pkg)
[13:36:26.069]                         base::library(pkg, character.only = TRUE)
[13:36:26.069]                       }
[13:36:26.069]                     })
[13:36:26.069]                   }
[13:36:26.069]                   ...future.strategy.old <- future::plan("list")
[13:36:26.069]                   options(future.plan = NULL)
[13:36:26.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.069]                 }
[13:36:26.069]                 ...future.workdir <- getwd()
[13:36:26.069]             }
[13:36:26.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.069]         }
[13:36:26.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.069]             base::names(...future.oldOptions))
[13:36:26.069]     }
[13:36:26.069]     if (FALSE) {
[13:36:26.069]     }
[13:36:26.069]     else {
[13:36:26.069]         if (TRUE) {
[13:36:26.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.069]                 open = "w")
[13:36:26.069]         }
[13:36:26.069]         else {
[13:36:26.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.069]         }
[13:36:26.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.069]             base::sink(type = "output", split = FALSE)
[13:36:26.069]             base::close(...future.stdout)
[13:36:26.069]         }, add = TRUE)
[13:36:26.069]     }
[13:36:26.069]     ...future.frame <- base::sys.nframe()
[13:36:26.069]     ...future.conditions <- base::list()
[13:36:26.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.069]     if (FALSE) {
[13:36:26.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.069]     }
[13:36:26.069]     ...future.result <- base::tryCatch({
[13:36:26.069]         base::withCallingHandlers({
[13:36:26.069]             ...future.value <- base::withVisible(base::local({
[13:36:26.069]                 withCallingHandlers({
[13:36:26.069]                   {
[13:36:26.069]                     b <- 1
[13:36:26.069]                     c %<-% 2
[13:36:26.069]                     d <- 3
[13:36:26.069]                     4 %->% e
[13:36:26.069]                     b + c + d + e
[13:36:26.069]                   }
[13:36:26.069]                 }, immediateCondition = function(cond) {
[13:36:26.069]                   save_rds <- function (object, pathname, ...) 
[13:36:26.069]                   {
[13:36:26.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:26.069]                     if (file_test("-f", pathname_tmp)) {
[13:36:26.069]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:26.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.069]                         fi_tmp[["mtime"]])
[13:36:26.069]                     }
[13:36:26.069]                     tryCatch({
[13:36:26.069]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:26.069]                     }, error = function(ex) {
[13:36:26.069]                       msg <- conditionMessage(ex)
[13:36:26.069]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:26.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.069]                         fi_tmp[["mtime"]], msg)
[13:36:26.069]                       ex$message <- msg
[13:36:26.069]                       stop(ex)
[13:36:26.069]                     })
[13:36:26.069]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:26.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:26.069]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:26.069]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.069]                       fi <- file.info(pathname)
[13:36:26.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:26.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:26.069]                         fi[["size"]], fi[["mtime"]])
[13:36:26.069]                       stop(msg)
[13:36:26.069]                     }
[13:36:26.069]                     invisible(pathname)
[13:36:26.069]                   }
[13:36:26.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:26.069]                     rootPath = tempdir()) 
[13:36:26.069]                   {
[13:36:26.069]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:26.069]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:26.069]                       tmpdir = path, fileext = ".rds")
[13:36:26.069]                     save_rds(obj, file)
[13:36:26.069]                   }
[13:36:26.069]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:26.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.069]                   {
[13:36:26.069]                     inherits <- base::inherits
[13:36:26.069]                     invokeRestart <- base::invokeRestart
[13:36:26.069]                     is.null <- base::is.null
[13:36:26.069]                     muffled <- FALSE
[13:36:26.069]                     if (inherits(cond, "message")) {
[13:36:26.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.069]                       if (muffled) 
[13:36:26.069]                         invokeRestart("muffleMessage")
[13:36:26.069]                     }
[13:36:26.069]                     else if (inherits(cond, "warning")) {
[13:36:26.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.069]                       if (muffled) 
[13:36:26.069]                         invokeRestart("muffleWarning")
[13:36:26.069]                     }
[13:36:26.069]                     else if (inherits(cond, "condition")) {
[13:36:26.069]                       if (!is.null(pattern)) {
[13:36:26.069]                         computeRestarts <- base::computeRestarts
[13:36:26.069]                         grepl <- base::grepl
[13:36:26.069]                         restarts <- computeRestarts(cond)
[13:36:26.069]                         for (restart in restarts) {
[13:36:26.069]                           name <- restart$name
[13:36:26.069]                           if (is.null(name)) 
[13:36:26.069]                             next
[13:36:26.069]                           if (!grepl(pattern, name)) 
[13:36:26.069]                             next
[13:36:26.069]                           invokeRestart(restart)
[13:36:26.069]                           muffled <- TRUE
[13:36:26.069]                           break
[13:36:26.069]                         }
[13:36:26.069]                       }
[13:36:26.069]                     }
[13:36:26.069]                     invisible(muffled)
[13:36:26.069]                   }
[13:36:26.069]                   muffleCondition(cond)
[13:36:26.069]                 })
[13:36:26.069]             }))
[13:36:26.069]             future::FutureResult(value = ...future.value$value, 
[13:36:26.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.069]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.069]                     ...future.globalenv.names))
[13:36:26.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.069]         }, condition = base::local({
[13:36:26.069]             c <- base::c
[13:36:26.069]             inherits <- base::inherits
[13:36:26.069]             invokeRestart <- base::invokeRestart
[13:36:26.069]             length <- base::length
[13:36:26.069]             list <- base::list
[13:36:26.069]             seq.int <- base::seq.int
[13:36:26.069]             signalCondition <- base::signalCondition
[13:36:26.069]             sys.calls <- base::sys.calls
[13:36:26.069]             `[[` <- base::`[[`
[13:36:26.069]             `+` <- base::`+`
[13:36:26.069]             `<<-` <- base::`<<-`
[13:36:26.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.069]                   3L)]
[13:36:26.069]             }
[13:36:26.069]             function(cond) {
[13:36:26.069]                 is_error <- inherits(cond, "error")
[13:36:26.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.069]                   NULL)
[13:36:26.069]                 if (is_error) {
[13:36:26.069]                   sessionInformation <- function() {
[13:36:26.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.069]                       search = base::search(), system = base::Sys.info())
[13:36:26.069]                   }
[13:36:26.069]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.069]                     cond$call), session = sessionInformation(), 
[13:36:26.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.069]                   signalCondition(cond)
[13:36:26.069]                 }
[13:36:26.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.069]                 "immediateCondition"))) {
[13:36:26.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.069]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.069]                   if (TRUE && !signal) {
[13:36:26.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.069]                     {
[13:36:26.069]                       inherits <- base::inherits
[13:36:26.069]                       invokeRestart <- base::invokeRestart
[13:36:26.069]                       is.null <- base::is.null
[13:36:26.069]                       muffled <- FALSE
[13:36:26.069]                       if (inherits(cond, "message")) {
[13:36:26.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.069]                         if (muffled) 
[13:36:26.069]                           invokeRestart("muffleMessage")
[13:36:26.069]                       }
[13:36:26.069]                       else if (inherits(cond, "warning")) {
[13:36:26.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.069]                         if (muffled) 
[13:36:26.069]                           invokeRestart("muffleWarning")
[13:36:26.069]                       }
[13:36:26.069]                       else if (inherits(cond, "condition")) {
[13:36:26.069]                         if (!is.null(pattern)) {
[13:36:26.069]                           computeRestarts <- base::computeRestarts
[13:36:26.069]                           grepl <- base::grepl
[13:36:26.069]                           restarts <- computeRestarts(cond)
[13:36:26.069]                           for (restart in restarts) {
[13:36:26.069]                             name <- restart$name
[13:36:26.069]                             if (is.null(name)) 
[13:36:26.069]                               next
[13:36:26.069]                             if (!grepl(pattern, name)) 
[13:36:26.069]                               next
[13:36:26.069]                             invokeRestart(restart)
[13:36:26.069]                             muffled <- TRUE
[13:36:26.069]                             break
[13:36:26.069]                           }
[13:36:26.069]                         }
[13:36:26.069]                       }
[13:36:26.069]                       invisible(muffled)
[13:36:26.069]                     }
[13:36:26.069]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.069]                   }
[13:36:26.069]                 }
[13:36:26.069]                 else {
[13:36:26.069]                   if (TRUE) {
[13:36:26.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.069]                     {
[13:36:26.069]                       inherits <- base::inherits
[13:36:26.069]                       invokeRestart <- base::invokeRestart
[13:36:26.069]                       is.null <- base::is.null
[13:36:26.069]                       muffled <- FALSE
[13:36:26.069]                       if (inherits(cond, "message")) {
[13:36:26.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.069]                         if (muffled) 
[13:36:26.069]                           invokeRestart("muffleMessage")
[13:36:26.069]                       }
[13:36:26.069]                       else if (inherits(cond, "warning")) {
[13:36:26.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.069]                         if (muffled) 
[13:36:26.069]                           invokeRestart("muffleWarning")
[13:36:26.069]                       }
[13:36:26.069]                       else if (inherits(cond, "condition")) {
[13:36:26.069]                         if (!is.null(pattern)) {
[13:36:26.069]                           computeRestarts <- base::computeRestarts
[13:36:26.069]                           grepl <- base::grepl
[13:36:26.069]                           restarts <- computeRestarts(cond)
[13:36:26.069]                           for (restart in restarts) {
[13:36:26.069]                             name <- restart$name
[13:36:26.069]                             if (is.null(name)) 
[13:36:26.069]                               next
[13:36:26.069]                             if (!grepl(pattern, name)) 
[13:36:26.069]                               next
[13:36:26.069]                             invokeRestart(restart)
[13:36:26.069]                             muffled <- TRUE
[13:36:26.069]                             break
[13:36:26.069]                           }
[13:36:26.069]                         }
[13:36:26.069]                       }
[13:36:26.069]                       invisible(muffled)
[13:36:26.069]                     }
[13:36:26.069]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.069]                   }
[13:36:26.069]                 }
[13:36:26.069]             }
[13:36:26.069]         }))
[13:36:26.069]     }, error = function(ex) {
[13:36:26.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.069]                 ...future.rng), started = ...future.startTime, 
[13:36:26.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.069]             version = "1.8"), class = "FutureResult")
[13:36:26.069]     }, finally = {
[13:36:26.069]         if (!identical(...future.workdir, getwd())) 
[13:36:26.069]             setwd(...future.workdir)
[13:36:26.069]         {
[13:36:26.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.069]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.069]             }
[13:36:26.069]             base::options(...future.oldOptions)
[13:36:26.069]             if (.Platform$OS.type == "windows") {
[13:36:26.069]                 old_names <- names(...future.oldEnvVars)
[13:36:26.069]                 envs <- base::Sys.getenv()
[13:36:26.069]                 names <- names(envs)
[13:36:26.069]                 common <- intersect(names, old_names)
[13:36:26.069]                 added <- setdiff(names, old_names)
[13:36:26.069]                 removed <- setdiff(old_names, names)
[13:36:26.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.069]                   envs[common]]
[13:36:26.069]                 NAMES <- toupper(changed)
[13:36:26.069]                 args <- list()
[13:36:26.069]                 for (kk in seq_along(NAMES)) {
[13:36:26.069]                   name <- changed[[kk]]
[13:36:26.069]                   NAME <- NAMES[[kk]]
[13:36:26.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.069]                     next
[13:36:26.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.069]                 }
[13:36:26.069]                 NAMES <- toupper(added)
[13:36:26.069]                 for (kk in seq_along(NAMES)) {
[13:36:26.069]                   name <- added[[kk]]
[13:36:26.069]                   NAME <- NAMES[[kk]]
[13:36:26.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.069]                     next
[13:36:26.069]                   args[[name]] <- ""
[13:36:26.069]                 }
[13:36:26.069]                 NAMES <- toupper(removed)
[13:36:26.069]                 for (kk in seq_along(NAMES)) {
[13:36:26.069]                   name <- removed[[kk]]
[13:36:26.069]                   NAME <- NAMES[[kk]]
[13:36:26.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.069]                     next
[13:36:26.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.069]                 }
[13:36:26.069]                 if (length(args) > 0) 
[13:36:26.069]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.069]             }
[13:36:26.069]             else {
[13:36:26.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.069]             }
[13:36:26.069]             {
[13:36:26.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.069]                   0L) {
[13:36:26.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.069]                   base::options(opts)
[13:36:26.069]                 }
[13:36:26.069]                 {
[13:36:26.069]                   {
[13:36:26.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.069]                     NULL
[13:36:26.069]                   }
[13:36:26.069]                   options(future.plan = NULL)
[13:36:26.069]                   if (is.na(NA_character_)) 
[13:36:26.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.069]                     .init = FALSE)
[13:36:26.069]                 }
[13:36:26.069]             }
[13:36:26.069]         }
[13:36:26.069]     })
[13:36:26.069]     if (TRUE) {
[13:36:26.069]         base::sink(type = "output", split = FALSE)
[13:36:26.069]         if (TRUE) {
[13:36:26.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.069]         }
[13:36:26.069]         else {
[13:36:26.069]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.069]         }
[13:36:26.069]         base::close(...future.stdout)
[13:36:26.069]         ...future.stdout <- NULL
[13:36:26.069]     }
[13:36:26.069]     ...future.result$conditions <- ...future.conditions
[13:36:26.069]     ...future.result$finished <- base::Sys.time()
[13:36:26.069]     ...future.result
[13:36:26.069] }
[13:36:26.072] requestCore(): workers = 2
[13:36:26.073] MulticoreFuture started
[13:36:26.074] - Launch lazy future ... done
[13:36:26.074] run() for ‘MulticoreFuture’ ... done
[13:36:26.075] result() for MulticoreFuture ...
[13:36:26.075] plan(): Setting new future strategy stack:
[13:36:26.075] List of future strategies:
[13:36:26.075] 1. sequential:
[13:36:26.075]    - args: function (..., envir = parent.frame())
[13:36:26.075]    - tweaked: FALSE
[13:36:26.075]    - call: NULL
[13:36:26.076] plan(): nbrOfWorkers() = 1
[13:36:26.110] plan(): Setting new future strategy stack:
[13:36:26.110] List of future strategies:
[13:36:26.110] 1. multicore:
[13:36:26.110]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:26.110]    - tweaked: FALSE
[13:36:26.110]    - call: plan(strategy)
[13:36:26.115] plan(): nbrOfWorkers() = 2
[13:36:26.116] result() for MulticoreFuture ...
[13:36:26.116] result() for MulticoreFuture ... done
[13:36:26.116] signalConditions() ...
[13:36:26.117]  - include = ‘immediateCondition’
[13:36:26.117]  - exclude = 
[13:36:26.117]  - resignal = FALSE
[13:36:26.117]  - Number of conditions: 88
[13:36:26.117] signalConditions() ... done
[13:36:26.117] result() for MulticoreFuture ... done
[13:36:26.117] result() for MulticoreFuture ...
[13:36:26.118] result() for MulticoreFuture ... done
[13:36:26.118] signalConditions() ...
[13:36:26.118]  - include = ‘immediateCondition’
[13:36:26.118]  - exclude = 
[13:36:26.118]  - resignal = FALSE
[13:36:26.118]  - Number of conditions: 88
[13:36:26.118] signalConditions() ... done
[13:36:26.119] Future state: ‘finished’
[13:36:26.119] result() for MulticoreFuture ...
[13:36:26.119] result() for MulticoreFuture ... done
[13:36:26.119] signalConditions() ...
[13:36:26.119]  - include = ‘condition’
[13:36:26.119]  - exclude = ‘immediateCondition’
[13:36:26.119]  - resignal = TRUE
[13:36:26.119]  - Number of conditions: 88
[13:36:26.120]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.078] getGlobalsAndPackages() ...
[13:36:26.120]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.078] Searching for globals...
[13:36:26.120]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.079] 
[13:36:26.120]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.079] Searching for globals ... DONE
[13:36:26.120]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.079] - globals: [0] <none>
[13:36:26.120]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.080] getGlobalsAndPackages() ... DONE
[13:36:26.121]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.080] run() for ‘Future’ ...
[13:36:26.121]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.081] - state: ‘created’
[13:36:26.121]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.081] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:26.121]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.081] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:26.121]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:26.121]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.082]   - Field: ‘label’
[13:36:26.122]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.082]   - Field: ‘local’
[13:36:26.122]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.082]   - Field: ‘owner’
[13:36:26.122]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.083]   - Field: ‘envir’
[13:36:26.122]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.083]   - Field: ‘packages’
[13:36:26.122]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.083]   - Field: ‘gc’
[13:36:26.123]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.083]   - Field: ‘conditions’
[13:36:26.123]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.083]   - Field: ‘expr’
[13:36:26.123]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.083]   - Field: ‘uuid’
[13:36:26.123]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.084]   - Field: ‘seed’
[13:36:26.123]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.084]   - Field: ‘version’
[13:36:26.123]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.084]   - Field: ‘result’
[13:36:26.124]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.084]   - Field: ‘asynchronous’
[13:36:26.124]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.084]   - Field: ‘calls’
[13:36:26.124]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.085]   - Field: ‘globals’
[13:36:26.124]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.085]   - Field: ‘stdout’
[13:36:26.124]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.085]   - Field: ‘earlySignal’
[13:36:26.124]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.085]   - Field: ‘lazy’
[13:36:26.124]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.085]   - Field: ‘state’
[13:36:26.125]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:26.125]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.086] - Launch lazy future ...
[13:36:26.125]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.086] Packages needed by the future expression (n = 0): <none>
[13:36:26.125]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.086] Packages needed by future strategies (n = 0): <none>
[13:36:26.125]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.087] {
[13:36:26.087]     {
[13:36:26.087]         {
[13:36:26.087]             ...future.startTime <- base::Sys.time()
[13:36:26.087]             {
[13:36:26.087]                 {
[13:36:26.087]                   {
[13:36:26.087]                     base::local({
[13:36:26.087]                       has_future <- base::requireNamespace("future", 
[13:36:26.087]                         quietly = TRUE)
[13:36:26.087]                       if (has_future) {
[13:36:26.087]                         ns <- base::getNamespace("future")
[13:36:26.087]                         version <- ns[[".package"]][["version"]]
[13:36:26.087]                         if (is.null(version)) 
[13:36:26.087]                           version <- utils::packageVersion("future")
[13:36:26.087]                       }
[13:36:26.087]                       else {
[13:36:26.087]                         version <- NULL
[13:36:26.087]                       }
[13:36:26.087]                       if (!has_future || version < "1.8.0") {
[13:36:26.087]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.087]                           "", base::R.version$version.string), 
[13:36:26.087]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:26.087]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.087]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.087]                             "release", "version")], collapse = " "), 
[13:36:26.087]                           hostname = base::Sys.info()[["nodename"]])
[13:36:26.087]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.087]                           info)
[13:36:26.087]                         info <- base::paste(info, collapse = "; ")
[13:36:26.087]                         if (!has_future) {
[13:36:26.087]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.087]                             info)
[13:36:26.087]                         }
[13:36:26.087]                         else {
[13:36:26.087]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.087]                             info, version)
[13:36:26.087]                         }
[13:36:26.087]                         base::stop(msg)
[13:36:26.087]                       }
[13:36:26.087]                     })
[13:36:26.087]                   }
[13:36:26.087]                   ...future.strategy.old <- future::plan("list")
[13:36:26.087]                   options(future.plan = NULL)
[13:36:26.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.087]                 }
[13:36:26.087]                 ...future.workdir <- getwd()
[13:36:26.087]             }
[13:36:26.087]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.087]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.087]         }
[13:36:26.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.087]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.087]             base::names(...future.oldOptions))
[13:36:26.087]     }
[13:36:26.087]     if (FALSE) {
[13:36:26.087]     }
[13:36:26.087]     else {
[13:36:26.087]         if (TRUE) {
[13:36:26.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.087]                 open = "w")
[13:36:26.087]         }
[13:36:26.087]         else {
[13:36:26.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.087]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.087]         }
[13:36:26.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.087]             base::sink(type = "output", split = FALSE)
[13:36:26.087]             base::close(...future.stdout)
[13:36:26.087]         }, add = TRUE)
[13:36:26.087]     }
[13:36:26.087]     ...future.frame <- base::sys.nframe()
[13:36:26.087]     ...future.conditions <- base::list()
[13:36:26.087]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.087]     if (FALSE) {
[13:36:26.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.087]     }
[13:36:26.087]     ...future.result <- base::tryCatch({
[13:36:26.087]         base::withCallingHandlers({
[13:36:26.087]             ...future.value <- base::withVisible(base::local(2))
[13:36:26.087]             future::FutureResult(value = ...future.value$value, 
[13:36:26.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.087]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.087]                     ...future.globalenv.names))
[13:36:26.087]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.087]         }, condition = base::local({
[13:36:26.087]             c <- base::c
[13:36:26.087]             inherits <- base::inherits
[13:36:26.087]             invokeRestart <- base::invokeRestart
[13:36:26.087]             length <- base::length
[13:36:26.087]             list <- base::list
[13:36:26.087]             seq.int <- base::seq.int
[13:36:26.087]             signalCondition <- base::signalCondition
[13:36:26.087]             sys.calls <- base::sys.calls
[13:36:26.087]             `[[` <- base::`[[`
[13:36:26.087]             `+` <- base::`+`
[13:36:26.087]             `<<-` <- base::`<<-`
[13:36:26.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.087]                   3L)]
[13:36:26.087]             }
[13:36:26.087]             function(cond) {
[13:36:26.087]                 is_error <- inherits(cond, "error")
[13:36:26.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.087]                   NULL)
[13:36:26.087]                 if (is_error) {
[13:36:26.087]                   sessionInformation <- function() {
[13:36:26.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.087]                       search = base::search(), system = base::Sys.info())
[13:36:26.087]                   }
[13:36:26.087]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.087]                     cond$call), session = sessionInformation(), 
[13:36:26.087]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.087]                   signalCondition(cond)
[13:36:26.087]                 }
[13:36:26.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.087]                 "immediateCondition"))) {
[13:36:26.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.087]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.087]                   if (TRUE && !signal) {
[13:36:26.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.087]                     {
[13:36:26.087]                       inherits <- base::inherits
[13:36:26.087]                       invokeRestart <- base::invokeRestart
[13:36:26.087]                       is.null <- base::is.null
[13:36:26.087]                       muffled <- FALSE
[13:36:26.087]                       if (inherits(cond, "message")) {
[13:36:26.087]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.087]                         if (muffled) 
[13:36:26.087]                           invokeRestart("muffleMessage")
[13:36:26.087]                       }
[13:36:26.087]                       else if (inherits(cond, "warning")) {
[13:36:26.087]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.087]                         if (muffled) 
[13:36:26.087]                           invokeRestart("muffleWarning")
[13:36:26.087]                       }
[13:36:26.087]                       else if (inherits(cond, "condition")) {
[13:36:26.087]                         if (!is.null(pattern)) {
[13:36:26.087]                           computeRestarts <- base::computeRestarts
[13:36:26.087]                           grepl <- base::grepl
[13:36:26.087]                           restarts <- computeRestarts(cond)
[13:36:26.087]                           for (restart in restarts) {
[13:36:26.087]                             name <- restart$name
[13:36:26.087]                             if (is.null(name)) 
[13:36:26.087]                               next
[13:36:26.087]                             if (!grepl(pattern, name)) 
[13:36:26.087]                               next
[13:36:26.087]                             invokeRestart(restart)
[13:36:26.087]                             muffled <- TRUE
[13:36:26.087]                             break
[13:36:26.087]                           }
[13:36:26.087]                         }
[13:36:26.087]                       }
[13:36:26.087]                       invisible(muffled)
[13:36:26.087]                     }
[13:36:26.087]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.087]                   }
[13:36:26.087]                 }
[13:36:26.087]                 else {
[13:36:26.087]                   if (TRUE) {
[13:36:26.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.087]                     {
[13:36:26.087]                       inherits <- base::inherits
[13:36:26.087]                       invokeRestart <- base::invokeRestart
[13:36:26.087]                       is.null <- base::is.null
[13:36:26.087]                       muffled <- FALSE
[13:36:26.087]                       if (inherits(cond, "message")) {
[13:36:26.087]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.087]                         if (muffled) 
[13:36:26.087]                           invokeRestart("muffleMessage")
[13:36:26.087]                       }
[13:36:26.087]                       else if (inherits(cond, "warning")) {
[13:36:26.087]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.087]                         if (muffled) 
[13:36:26.087]                           invokeRestart("muffleWarning")
[13:36:26.087]                       }
[13:36:26.087]                       else if (inherits(cond, "condition")) {
[13:36:26.087]                         if (!is.null(pattern)) {
[13:36:26.087]                           computeRestarts <- base::computeRestarts
[13:36:26.087]                           grepl <- base::grepl
[13:36:26.087]                           restarts <- computeRestarts(cond)
[13:36:26.087]                           for (restart in restarts) {
[13:36:26.087]                             name <- restart$name
[13:36:26.087]                             if (is.null(name)) 
[13:36:26.087]                               next
[13:36:26.087]                             if (!grepl(pattern, name)) 
[13:36:26.087]                               next
[13:36:26.087]                             invokeRestart(restart)
[13:36:26.087]                             muffled <- TRUE
[13:36:26.087]                             break
[13:36:26.087]                           }
[13:36:26.087]                         }
[13:36:26.087]                       }
[13:36:26.087]                       invisible(muffled)
[13:36:26.087]                     }
[13:36:26.087]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.087]                   }
[13:36:26.087]                 }
[13:36:26.087]             }
[13:36:26.087]         }))
[13:36:26.087]     }, error = function(ex) {
[13:36:26.087]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.087]                 ...future.rng), started = ...future.startTime, 
[13:36:26.087]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.087]             version = "1.8"), class = "FutureResult")
[13:36:26.087]     }, finally = {
[13:36:26.087]         if (!identical(...future.workdir, getwd())) 
[13:36:26.087]             setwd(...future.workdir)
[13:36:26.087]         {
[13:36:26.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.087]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.087]             }
[13:36:26.087]             base::options(...future.oldOptions)
[13:36:26.087]             if (.Platform$OS.type == "windows") {
[13:36:26.087]                 old_names <- names(...future.oldEnvVars)
[13:36:26.087]                 envs <- base::Sys.getenv()
[13:36:26.087]                 names <- names(envs)
[13:36:26.087]                 common <- intersect(names, old_names)
[13:36:26.087]                 added <- setdiff(names, old_names)
[13:36:26.087]                 removed <- setdiff(old_names, names)
[13:36:26.087]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.087]                   envs[common]]
[13:36:26.087]                 NAMES <- toupper(changed)
[13:36:26.087]                 args <- list()
[13:36:26.087]                 for (kk in seq_along(NAMES)) {
[13:36:26.087]                   name <- changed[[kk]]
[13:36:26.087]                   NAME <- NAMES[[kk]]
[13:36:26.087]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.087]                     next
[13:36:26.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.087]                 }
[13:36:26.087]                 NAMES <- toupper(added)
[13:36:26.087]                 for (kk in seq_along(NAMES)) {
[13:36:26.087]                   name <- added[[kk]]
[13:36:26.087]                   NAME <- NAMES[[kk]]
[13:36:26.087]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.087]                     next
[13:36:26.087]                   args[[name]] <- ""
[13:36:26.087]                 }
[13:36:26.087]                 NAMES <- toupper(removed)
[13:36:26.087]                 for (kk in seq_along(NAMES)) {
[13:36:26.087]                   name <- removed[[kk]]
[13:36:26.087]                   NAME <- NAMES[[kk]]
[13:36:26.087]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.087]                     next
[13:36:26.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.087]                 }
[13:36:26.087]                 if (length(args) > 0) 
[13:36:26.087]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.087]             }
[13:36:26.087]             else {
[13:36:26.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.087]             }
[13:36:26.087]             {
[13:36:26.087]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.087]                   0L) {
[13:36:26.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.087]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.087]                   base::options(opts)
[13:36:26.087]                 }
[13:36:26.087]                 {
[13:36:26.087]                   {
[13:36:26.087]                     NULL
[13:36:26.087]                     RNGkind("Mersenne-Twister")
[13:36:26.087]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:26.087]                       inherits = FALSE)
[13:36:26.087]                   }
[13:36:26.087]                   options(future.plan = NULL)
[13:36:26.087]                   if (is.na(NA_character_)) 
[13:36:26.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.087]                     .init = FALSE)
[13:36:26.087]                 }
[13:36:26.087]             }
[13:36:26.087]         }
[13:36:26.087]     })
[13:36:26.087]     if (TRUE) {
[13:36:26.087]         base::sink(type = "output", split = FALSE)
[13:36:26.087]         if (TRUE) {
[13:36:26.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.087]         }
[13:36:26.087]         else {
[13:36:26.087]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.087]         }
[13:36:26.087]         base::close(...future.stdout)
[13:36:26.087]         ...future.stdout <- NULL
[13:36:26.087]     }
[13:36:26.087]     ...future.result$conditions <- ...future.conditions
[13:36:26.087]     ...future.result$finished <- base::Sys.time()
[13:36:26.087]     ...future.result
[13:36:26.087] }
[13:36:26.125]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.090] plan(): Setting new future strategy stack:
[13:36:26.126]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.090] List of future strategies:
[13:36:26.090] 1. sequential:
[13:36:26.090]    - args: function (..., envir = parent.frame())
[13:36:26.090]    - tweaked: FALSE
[13:36:26.090]    - call: NULL
[13:36:26.126]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.091] plan(): nbrOfWorkers() = 1
[13:36:26.126]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.092] plan(): Setting new future strategy stack:
[13:36:26.126]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.092] List of future strategies:
[13:36:26.092] 1. sequential:
[13:36:26.092]    - args: function (..., envir = parent.frame())
[13:36:26.092]    - tweaked: FALSE
[13:36:26.092]    - call: NULL
[13:36:26.126]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.092] plan(): nbrOfWorkers() = 1
[13:36:26.127]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.093] SequentialFuture started (and completed)
[13:36:26.127]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.093] - Launch lazy future ... done
[13:36:26.127]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.093] run() for ‘SequentialFuture’ ... done
[13:36:26.127]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.094] getGlobalsAndPackages() ...
[13:36:26.127]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.094] Searching for globals...
[13:36:26.127]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.094] 
[13:36:26.127]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.094] Searching for globals ... DONE
[13:36:26.128]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.095] - globals: [0] <none>
[13:36:26.128]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.095] getGlobalsAndPackages() ... DONE
[13:36:26.128]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.095] run() for ‘Future’ ...
[13:36:26.128]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.095] - state: ‘created’
[13:36:26.128]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:36:26.128]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.096] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:36:26.129]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:36:26.129]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.096]   - Field: ‘label’
[13:36:26.129]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.096]   - Field: ‘local’
[13:36:26.129]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘owner’
[13:36:26.129]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘envir’
[13:36:26.129]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘packages’
[13:36:26.129]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘gc’
[13:36:26.130]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘conditions’
[13:36:26.130]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘expr’
[13:36:26.130]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.097]   - Field: ‘uuid’
[13:36:26.130]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.098]   - Field: ‘seed’
[13:36:26.130]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.098]   - Field: ‘version’
[13:36:26.130]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.098]   - Field: ‘result’
[13:36:26.131]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.098]   - Field: ‘asynchronous’
[13:36:26.131]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.098]   - Field: ‘calls’
[13:36:26.131]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.098]   - Field: ‘globals’
[13:36:26.131]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.099]   - Field: ‘stdout’
[13:36:26.131]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.099]   - Field: ‘earlySignal’
[13:36:26.131]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.099]   - Field: ‘lazy’
[13:36:26.132]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.099]   - Field: ‘state’
[13:36:26.132]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:36:26.132]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.099] - Launch lazy future ...
[13:36:26.132]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.100] Packages needed by the future expression (n = 0): <none>
[13:36:26.132]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.100] Packages needed by future strategies (n = 0): <none>
[13:36:26.132]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.100] {
[13:36:26.100]     {
[13:36:26.100]         {
[13:36:26.100]             ...future.startTime <- base::Sys.time()
[13:36:26.100]             {
[13:36:26.100]                 {
[13:36:26.100]                   {
[13:36:26.100]                     base::local({
[13:36:26.100]                       has_future <- base::requireNamespace("future", 
[13:36:26.100]                         quietly = TRUE)
[13:36:26.100]                       if (has_future) {
[13:36:26.100]                         ns <- base::getNamespace("future")
[13:36:26.100]                         version <- ns[[".package"]][["version"]]
[13:36:26.100]                         if (is.null(version)) 
[13:36:26.100]                           version <- utils::packageVersion("future")
[13:36:26.100]                       }
[13:36:26.100]                       else {
[13:36:26.100]                         version <- NULL
[13:36:26.100]                       }
[13:36:26.100]                       if (!has_future || version < "1.8.0") {
[13:36:26.100]                         info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.100]                           "", base::R.version$version.string), 
[13:36:26.100]                           platform = base::sprintf("%s (%s-bit)", 
[13:36:26.100]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.100]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.100]                             "release", "version")], collapse = " "), 
[13:36:26.100]                           hostname = base::Sys.info()[["nodename"]])
[13:36:26.100]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.100]                           info)
[13:36:26.100]                         info <- base::paste(info, collapse = "; ")
[13:36:26.100]                         if (!has_future) {
[13:36:26.100]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.100]                             info)
[13:36:26.100]                         }
[13:36:26.100]                         else {
[13:36:26.100]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.100]                             info, version)
[13:36:26.100]                         }
[13:36:26.100]                         base::stop(msg)
[13:36:26.100]                       }
[13:36:26.100]                     })
[13:36:26.100]                   }
[13:36:26.100]                   ...future.strategy.old <- future::plan("list")
[13:36:26.100]                   options(future.plan = NULL)
[13:36:26.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.100]                 }
[13:36:26.100]                 ...future.workdir <- getwd()
[13:36:26.100]             }
[13:36:26.100]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.100]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.100]         }
[13:36:26.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.100]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.100]             base::names(...future.oldOptions))
[13:36:26.100]     }
[13:36:26.100]     if (FALSE) {
[13:36:26.100]     }
[13:36:26.100]     else {
[13:36:26.100]         if (TRUE) {
[13:36:26.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.100]                 open = "w")
[13:36:26.100]         }
[13:36:26.100]         else {
[13:36:26.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.100]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.100]         }
[13:36:26.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.100]             base::sink(type = "output", split = FALSE)
[13:36:26.100]             base::close(...future.stdout)
[13:36:26.100]         }, add = TRUE)
[13:36:26.100]     }
[13:36:26.100]     ...future.frame <- base::sys.nframe()
[13:36:26.100]     ...future.conditions <- base::list()
[13:36:26.100]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.100]     if (FALSE) {
[13:36:26.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.100]     }
[13:36:26.100]     ...future.result <- base::tryCatch({
[13:36:26.100]         base::withCallingHandlers({
[13:36:26.100]             ...future.value <- base::withVisible(base::local(4))
[13:36:26.100]             future::FutureResult(value = ...future.value$value, 
[13:36:26.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.100]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.100]                     ...future.globalenv.names))
[13:36:26.100]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.100]         }, condition = base::local({
[13:36:26.100]             c <- base::c
[13:36:26.100]             inherits <- base::inherits
[13:36:26.100]             invokeRestart <- base::invokeRestart
[13:36:26.100]             length <- base::length
[13:36:26.100]             list <- base::list
[13:36:26.100]             seq.int <- base::seq.int
[13:36:26.100]             signalCondition <- base::signalCondition
[13:36:26.100]             sys.calls <- base::sys.calls
[13:36:26.100]             `[[` <- base::`[[`
[13:36:26.100]             `+` <- base::`+`
[13:36:26.100]             `<<-` <- base::`<<-`
[13:36:26.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.100]                   3L)]
[13:36:26.100]             }
[13:36:26.100]             function(cond) {
[13:36:26.100]                 is_error <- inherits(cond, "error")
[13:36:26.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.100]                   NULL)
[13:36:26.100]                 if (is_error) {
[13:36:26.100]                   sessionInformation <- function() {
[13:36:26.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.100]                       search = base::search(), system = base::Sys.info())
[13:36:26.100]                   }
[13:36:26.100]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.100]                     cond$call), session = sessionInformation(), 
[13:36:26.100]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.100]                   signalCondition(cond)
[13:36:26.100]                 }
[13:36:26.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.100]                 "immediateCondition"))) {
[13:36:26.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.100]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.100]                   if (TRUE && !signal) {
[13:36:26.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.100]                     {
[13:36:26.100]                       inherits <- base::inherits
[13:36:26.100]                       invokeRestart <- base::invokeRestart
[13:36:26.100]                       is.null <- base::is.null
[13:36:26.100]                       muffled <- FALSE
[13:36:26.100]                       if (inherits(cond, "message")) {
[13:36:26.100]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.100]                         if (muffled) 
[13:36:26.100]                           invokeRestart("muffleMessage")
[13:36:26.100]                       }
[13:36:26.100]                       else if (inherits(cond, "warning")) {
[13:36:26.100]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.100]                         if (muffled) 
[13:36:26.100]                           invokeRestart("muffleWarning")
[13:36:26.100]                       }
[13:36:26.100]                       else if (inherits(cond, "condition")) {
[13:36:26.100]                         if (!is.null(pattern)) {
[13:36:26.100]                           computeRestarts <- base::computeRestarts
[13:36:26.100]                           grepl <- base::grepl
[13:36:26.100]                           restarts <- computeRestarts(cond)
[13:36:26.100]                           for (restart in restarts) {
[13:36:26.100]                             name <- restart$name
[13:36:26.100]                             if (is.null(name)) 
[13:36:26.100]                               next
[13:36:26.100]                             if (!grepl(pattern, name)) 
[13:36:26.100]                               next
[13:36:26.100]                             invokeRestart(restart)
[13:36:26.100]                             muffled <- TRUE
[13:36:26.100]                             break
[13:36:26.100]                           }
[13:36:26.100]                         }
[13:36:26.100]                       }
[13:36:26.100]                       invisible(muffled)
[13:36:26.100]                     }
[13:36:26.100]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.100]                   }
[13:36:26.100]                 }
[13:36:26.100]                 else {
[13:36:26.100]                   if (TRUE) {
[13:36:26.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.100]                     {
[13:36:26.100]                       inherits <- base::inherits
[13:36:26.100]                       invokeRestart <- base::invokeRestart
[13:36:26.100]                       is.null <- base::is.null
[13:36:26.100]                       muffled <- FALSE
[13:36:26.100]                       if (inherits(cond, "message")) {
[13:36:26.100]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.100]                         if (muffled) 
[13:36:26.100]                           invokeRestart("muffleMessage")
[13:36:26.100]                       }
[13:36:26.100]                       else if (inherits(cond, "warning")) {
[13:36:26.100]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.100]                         if (muffled) 
[13:36:26.100]                           invokeRestart("muffleWarning")
[13:36:26.100]                       }
[13:36:26.100]                       else if (inherits(cond, "condition")) {
[13:36:26.100]                         if (!is.null(pattern)) {
[13:36:26.100]                           computeRestarts <- base::computeRestarts
[13:36:26.100]                           grepl <- base::grepl
[13:36:26.100]                           restarts <- computeRestarts(cond)
[13:36:26.100]                           for (restart in restarts) {
[13:36:26.100]                             name <- restart$name
[13:36:26.100]                             if (is.null(name)) 
[13:36:26.100]                               next
[13:36:26.100]                             if (!grepl(pattern, name)) 
[13:36:26.100]                               next
[13:36:26.100]                             invokeRestart(restart)
[13:36:26.100]                             muffled <- TRUE
[13:36:26.100]                             break
[13:36:26.100]                           }
[13:36:26.100]                         }
[13:36:26.100]                       }
[13:36:26.100]                       invisible(muffled)
[13:36:26.100]                     }
[13:36:26.100]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.100]                   }
[13:36:26.100]                 }
[13:36:26.100]             }
[13:36:26.100]         }))
[13:36:26.100]     }, error = function(ex) {
[13:36:26.100]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.100]                 ...future.rng), started = ...future.startTime, 
[13:36:26.100]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.100]             version = "1.8"), class = "FutureResult")
[13:36:26.100]     }, finally = {
[13:36:26.100]         if (!identical(...future.workdir, getwd())) 
[13:36:26.100]             setwd(...future.workdir)
[13:36:26.100]         {
[13:36:26.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.100]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.100]             }
[13:36:26.100]             base::options(...future.oldOptions)
[13:36:26.100]             if (.Platform$OS.type == "windows") {
[13:36:26.100]                 old_names <- names(...future.oldEnvVars)
[13:36:26.100]                 envs <- base::Sys.getenv()
[13:36:26.100]                 names <- names(envs)
[13:36:26.100]                 common <- intersect(names, old_names)
[13:36:26.100]                 added <- setdiff(names, old_names)
[13:36:26.100]                 removed <- setdiff(old_names, names)
[13:36:26.100]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.100]                   envs[common]]
[13:36:26.100]                 NAMES <- toupper(changed)
[13:36:26.100]                 args <- list()
[13:36:26.100]                 for (kk in seq_along(NAMES)) {
[13:36:26.100]                   name <- changed[[kk]]
[13:36:26.100]                   NAME <- NAMES[[kk]]
[13:36:26.100]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.100]                     next
[13:36:26.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.100]                 }
[13:36:26.100]                 NAMES <- toupper(added)
[13:36:26.100]                 for (kk in seq_along(NAMES)) {
[13:36:26.100]                   name <- added[[kk]]
[13:36:26.100]                   NAME <- NAMES[[kk]]
[13:36:26.100]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.100]                     next
[13:36:26.100]                   args[[name]] <- ""
[13:36:26.100]                 }
[13:36:26.100]                 NAMES <- toupper(removed)
[13:36:26.100]                 for (kk in seq_along(NAMES)) {
[13:36:26.100]                   name <- removed[[kk]]
[13:36:26.100]                   NAME <- NAMES[[kk]]
[13:36:26.100]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.100]                     next
[13:36:26.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.100]                 }
[13:36:26.100]                 if (length(args) > 0) 
[13:36:26.100]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.100]             }
[13:36:26.100]             else {
[13:36:26.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.100]             }
[13:36:26.100]             {
[13:36:26.100]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.100]                   0L) {
[13:36:26.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.100]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.100]                   base::options(opts)
[13:36:26.100]                 }
[13:36:26.100]                 {
[13:36:26.100]                   {
[13:36:26.100]                     NULL
[13:36:26.100]                     RNGkind("Mersenne-Twister")
[13:36:26.100]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:36:26.100]                       inherits = FALSE)
[13:36:26.100]                   }
[13:36:26.100]                   options(future.plan = NULL)
[13:36:26.100]                   if (is.na(NA_character_)) 
[13:36:26.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.100]                     .init = FALSE)
[13:36:26.100]                 }
[13:36:26.100]             }
[13:36:26.100]         }
[13:36:26.100]     })
[13:36:26.100]     if (TRUE) {
[13:36:26.100]         base::sink(type = "output", split = FALSE)
[13:36:26.100]         if (TRUE) {
[13:36:26.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.100]         }
[13:36:26.100]         else {
[13:36:26.100]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.100]         }
[13:36:26.100]         base::close(...future.stdout)
[13:36:26.100]         ...future.stdout <- NULL
[13:36:26.100]     }
[13:36:26.100]     ...future.result$conditions <- ...future.conditions
[13:36:26.100]     ...future.result$finished <- base::Sys.time()
[13:36:26.100]     ...future.result
[13:36:26.100] }
[13:36:26.132]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.103] plan(): Setting new future strategy stack:
[13:36:26.133]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.103] List of future strategies:
[13:36:26.103] 1. sequential:
[13:36:26.103]    - args: function (..., envir = parent.frame())
[13:36:26.103]    - tweaked: FALSE
[13:36:26.103]    - call: NULL
[13:36:26.133]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.103] plan(): nbrOfWorkers() = 1
[13:36:26.133]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.104] plan(): Setting new future strategy stack:
[13:36:26.136]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.104] List of future strategies:
[13:36:26.104] 1. sequential:
[13:36:26.104]    - args: function (..., envir = parent.frame())
[13:36:26.104]    - tweaked: FALSE
[13:36:26.104]    - call: NULL
[13:36:26.136]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.108] plan(): nbrOfWorkers() = 1
[13:36:26.136]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.108] SequentialFuture started (and completed)
[13:36:26.136]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.108] - Launch lazy future ... done
[13:36:26.136]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[13:36:26.109] run() for ‘SequentialFuture’ ... done
[13:36:26.136] signalConditions() ... done
a = 10
[13:36:26.137] getGlobalsAndPackages() ...
[13:36:26.137] Searching for globals...
[13:36:26.139] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:36:26.139] Searching for globals ... DONE
[13:36:26.139] Resolving globals: FALSE
[13:36:26.139] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:26.140] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:26.140] - globals: [1] ‘a’
[13:36:26.140] 
[13:36:26.140] getGlobalsAndPackages() ... DONE
[13:36:26.140] run() for ‘Future’ ...
[13:36:26.140] - state: ‘created’
[13:36:26.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.144] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:36:26.145]   - Field: ‘label’
[13:36:26.145]   - Field: ‘local’
[13:36:26.145]   - Field: ‘owner’
[13:36:26.145]   - Field: ‘envir’
[13:36:26.145]   - Field: ‘workers’
[13:36:26.145]   - Field: ‘packages’
[13:36:26.145]   - Field: ‘gc’
[13:36:26.145]   - Field: ‘job’
[13:36:26.145]   - Field: ‘conditions’
[13:36:26.146]   - Field: ‘expr’
[13:36:26.146]   - Field: ‘uuid’
[13:36:26.146]   - Field: ‘seed’
[13:36:26.146]   - Field: ‘version’
[13:36:26.146]   - Field: ‘result’
[13:36:26.146]   - Field: ‘asynchronous’
[13:36:26.146]   - Field: ‘calls’
[13:36:26.146]   - Field: ‘globals’
[13:36:26.146]   - Field: ‘stdout’
[13:36:26.146]   - Field: ‘earlySignal’
[13:36:26.147]   - Field: ‘lazy’
[13:36:26.147]   - Field: ‘state’
[13:36:26.147] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:36:26.147] - Launch lazy future ...
[13:36:26.147] Packages needed by the future expression (n = 0): <none>
[13:36:26.147] Packages needed by future strategies (n = 0): <none>
[13:36:26.148] {
[13:36:26.148]     {
[13:36:26.148]         {
[13:36:26.148]             ...future.startTime <- base::Sys.time()
[13:36:26.148]             {
[13:36:26.148]                 {
[13:36:26.148]                   {
[13:36:26.148]                     {
[13:36:26.148]                       base::local({
[13:36:26.148]                         has_future <- base::requireNamespace("future", 
[13:36:26.148]                           quietly = TRUE)
[13:36:26.148]                         if (has_future) {
[13:36:26.148]                           ns <- base::getNamespace("future")
[13:36:26.148]                           version <- ns[[".package"]][["version"]]
[13:36:26.148]                           if (is.null(version)) 
[13:36:26.148]                             version <- utils::packageVersion("future")
[13:36:26.148]                         }
[13:36:26.148]                         else {
[13:36:26.148]                           version <- NULL
[13:36:26.148]                         }
[13:36:26.148]                         if (!has_future || version < "1.8.0") {
[13:36:26.148]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.148]                             "", base::R.version$version.string), 
[13:36:26.148]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.148]                               "release", "version")], collapse = " "), 
[13:36:26.148]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.148]                             info)
[13:36:26.148]                           info <- base::paste(info, collapse = "; ")
[13:36:26.148]                           if (!has_future) {
[13:36:26.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.148]                               info)
[13:36:26.148]                           }
[13:36:26.148]                           else {
[13:36:26.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.148]                               info, version)
[13:36:26.148]                           }
[13:36:26.148]                           base::stop(msg)
[13:36:26.148]                         }
[13:36:26.148]                       })
[13:36:26.148]                     }
[13:36:26.148]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.148]                     base::options(mc.cores = 1L)
[13:36:26.148]                   }
[13:36:26.148]                   ...future.strategy.old <- future::plan("list")
[13:36:26.148]                   options(future.plan = NULL)
[13:36:26.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.148]                 }
[13:36:26.148]                 ...future.workdir <- getwd()
[13:36:26.148]             }
[13:36:26.148]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.148]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.148]         }
[13:36:26.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.148]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.148]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.148]             base::names(...future.oldOptions))
[13:36:26.148]     }
[13:36:26.148]     if (FALSE) {
[13:36:26.148]     }
[13:36:26.148]     else {
[13:36:26.148]         if (TRUE) {
[13:36:26.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.148]                 open = "w")
[13:36:26.148]         }
[13:36:26.148]         else {
[13:36:26.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.148]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.148]         }
[13:36:26.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.148]             base::sink(type = "output", split = FALSE)
[13:36:26.148]             base::close(...future.stdout)
[13:36:26.148]         }, add = TRUE)
[13:36:26.148]     }
[13:36:26.148]     ...future.frame <- base::sys.nframe()
[13:36:26.148]     ...future.conditions <- base::list()
[13:36:26.148]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.148]     if (FALSE) {
[13:36:26.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.148]     }
[13:36:26.148]     ...future.result <- base::tryCatch({
[13:36:26.148]         base::withCallingHandlers({
[13:36:26.148]             ...future.value <- base::withVisible(base::local({
[13:36:26.148]                 withCallingHandlers({
[13:36:26.148]                   {
[13:36:26.148]                     a + 1
[13:36:26.148]                   }
[13:36:26.148]                 }, immediateCondition = function(cond) {
[13:36:26.148]                   save_rds <- function (object, pathname, ...) 
[13:36:26.148]                   {
[13:36:26.148]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:36:26.148]                     if (file_test("-f", pathname_tmp)) {
[13:36:26.148]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.148]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:36:26.148]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.148]                         fi_tmp[["mtime"]])
[13:36:26.148]                     }
[13:36:26.148]                     tryCatch({
[13:36:26.148]                       saveRDS(object, file = pathname_tmp, ...)
[13:36:26.148]                     }, error = function(ex) {
[13:36:26.148]                       msg <- conditionMessage(ex)
[13:36:26.148]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.148]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:36:26.148]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.148]                         fi_tmp[["mtime"]], msg)
[13:36:26.148]                       ex$message <- msg
[13:36:26.148]                       stop(ex)
[13:36:26.148]                     })
[13:36:26.148]                     stopifnot(file_test("-f", pathname_tmp))
[13:36:26.148]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:36:26.148]                     if (!res || file_test("-f", pathname_tmp)) {
[13:36:26.148]                       fi_tmp <- file.info(pathname_tmp)
[13:36:26.148]                       fi <- file.info(pathname)
[13:36:26.148]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:36:26.148]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:36:26.148]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:36:26.148]                         fi[["size"]], fi[["mtime"]])
[13:36:26.148]                       stop(msg)
[13:36:26.148]                     }
[13:36:26.148]                     invisible(pathname)
[13:36:26.148]                   }
[13:36:26.148]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:36:26.148]                     rootPath = tempdir()) 
[13:36:26.148]                   {
[13:36:26.148]                     obj <- list(time = Sys.time(), condition = cond)
[13:36:26.148]                     file <- tempfile(pattern = class(cond)[1], 
[13:36:26.148]                       tmpdir = path, fileext = ".rds")
[13:36:26.148]                     save_rds(obj, file)
[13:36:26.148]                   }
[13:36:26.148]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt79Oa4/.future/immediateConditions")
[13:36:26.148]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.148]                   {
[13:36:26.148]                     inherits <- base::inherits
[13:36:26.148]                     invokeRestart <- base::invokeRestart
[13:36:26.148]                     is.null <- base::is.null
[13:36:26.148]                     muffled <- FALSE
[13:36:26.148]                     if (inherits(cond, "message")) {
[13:36:26.148]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.148]                       if (muffled) 
[13:36:26.148]                         invokeRestart("muffleMessage")
[13:36:26.148]                     }
[13:36:26.148]                     else if (inherits(cond, "warning")) {
[13:36:26.148]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.148]                       if (muffled) 
[13:36:26.148]                         invokeRestart("muffleWarning")
[13:36:26.148]                     }
[13:36:26.148]                     else if (inherits(cond, "condition")) {
[13:36:26.148]                       if (!is.null(pattern)) {
[13:36:26.148]                         computeRestarts <- base::computeRestarts
[13:36:26.148]                         grepl <- base::grepl
[13:36:26.148]                         restarts <- computeRestarts(cond)
[13:36:26.148]                         for (restart in restarts) {
[13:36:26.148]                           name <- restart$name
[13:36:26.148]                           if (is.null(name)) 
[13:36:26.148]                             next
[13:36:26.148]                           if (!grepl(pattern, name)) 
[13:36:26.148]                             next
[13:36:26.148]                           invokeRestart(restart)
[13:36:26.148]                           muffled <- TRUE
[13:36:26.148]                           break
[13:36:26.148]                         }
[13:36:26.148]                       }
[13:36:26.148]                     }
[13:36:26.148]                     invisible(muffled)
[13:36:26.148]                   }
[13:36:26.148]                   muffleCondition(cond)
[13:36:26.148]                 })
[13:36:26.148]             }))
[13:36:26.148]             future::FutureResult(value = ...future.value$value, 
[13:36:26.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.148]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.148]                     ...future.globalenv.names))
[13:36:26.148]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.148]         }, condition = base::local({
[13:36:26.148]             c <- base::c
[13:36:26.148]             inherits <- base::inherits
[13:36:26.148]             invokeRestart <- base::invokeRestart
[13:36:26.148]             length <- base::length
[13:36:26.148]             list <- base::list
[13:36:26.148]             seq.int <- base::seq.int
[13:36:26.148]             signalCondition <- base::signalCondition
[13:36:26.148]             sys.calls <- base::sys.calls
[13:36:26.148]             `[[` <- base::`[[`
[13:36:26.148]             `+` <- base::`+`
[13:36:26.148]             `<<-` <- base::`<<-`
[13:36:26.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.148]                   3L)]
[13:36:26.148]             }
[13:36:26.148]             function(cond) {
[13:36:26.148]                 is_error <- inherits(cond, "error")
[13:36:26.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.148]                   NULL)
[13:36:26.148]                 if (is_error) {
[13:36:26.148]                   sessionInformation <- function() {
[13:36:26.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.148]                       search = base::search(), system = base::Sys.info())
[13:36:26.148]                   }
[13:36:26.148]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.148]                     cond$call), session = sessionInformation(), 
[13:36:26.148]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.148]                   signalCondition(cond)
[13:36:26.148]                 }
[13:36:26.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.148]                 "immediateCondition"))) {
[13:36:26.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.148]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.148]                   if (TRUE && !signal) {
[13:36:26.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.148]                     {
[13:36:26.148]                       inherits <- base::inherits
[13:36:26.148]                       invokeRestart <- base::invokeRestart
[13:36:26.148]                       is.null <- base::is.null
[13:36:26.148]                       muffled <- FALSE
[13:36:26.148]                       if (inherits(cond, "message")) {
[13:36:26.148]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.148]                         if (muffled) 
[13:36:26.148]                           invokeRestart("muffleMessage")
[13:36:26.148]                       }
[13:36:26.148]                       else if (inherits(cond, "warning")) {
[13:36:26.148]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.148]                         if (muffled) 
[13:36:26.148]                           invokeRestart("muffleWarning")
[13:36:26.148]                       }
[13:36:26.148]                       else if (inherits(cond, "condition")) {
[13:36:26.148]                         if (!is.null(pattern)) {
[13:36:26.148]                           computeRestarts <- base::computeRestarts
[13:36:26.148]                           grepl <- base::grepl
[13:36:26.148]                           restarts <- computeRestarts(cond)
[13:36:26.148]                           for (restart in restarts) {
[13:36:26.148]                             name <- restart$name
[13:36:26.148]                             if (is.null(name)) 
[13:36:26.148]                               next
[13:36:26.148]                             if (!grepl(pattern, name)) 
[13:36:26.148]                               next
[13:36:26.148]                             invokeRestart(restart)
[13:36:26.148]                             muffled <- TRUE
[13:36:26.148]                             break
[13:36:26.148]                           }
[13:36:26.148]                         }
[13:36:26.148]                       }
[13:36:26.148]                       invisible(muffled)
[13:36:26.148]                     }
[13:36:26.148]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.148]                   }
[13:36:26.148]                 }
[13:36:26.148]                 else {
[13:36:26.148]                   if (TRUE) {
[13:36:26.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.148]                     {
[13:36:26.148]                       inherits <- base::inherits
[13:36:26.148]                       invokeRestart <- base::invokeRestart
[13:36:26.148]                       is.null <- base::is.null
[13:36:26.148]                       muffled <- FALSE
[13:36:26.148]                       if (inherits(cond, "message")) {
[13:36:26.148]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.148]                         if (muffled) 
[13:36:26.148]                           invokeRestart("muffleMessage")
[13:36:26.148]                       }
[13:36:26.148]                       else if (inherits(cond, "warning")) {
[13:36:26.148]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.148]                         if (muffled) 
[13:36:26.148]                           invokeRestart("muffleWarning")
[13:36:26.148]                       }
[13:36:26.148]                       else if (inherits(cond, "condition")) {
[13:36:26.148]                         if (!is.null(pattern)) {
[13:36:26.148]                           computeRestarts <- base::computeRestarts
[13:36:26.148]                           grepl <- base::grepl
[13:36:26.148]                           restarts <- computeRestarts(cond)
[13:36:26.148]                           for (restart in restarts) {
[13:36:26.148]                             name <- restart$name
[13:36:26.148]                             if (is.null(name)) 
[13:36:26.148]                               next
[13:36:26.148]                             if (!grepl(pattern, name)) 
[13:36:26.148]                               next
[13:36:26.148]                             invokeRestart(restart)
[13:36:26.148]                             muffled <- TRUE
[13:36:26.148]                             break
[13:36:26.148]                           }
[13:36:26.148]                         }
[13:36:26.148]                       }
[13:36:26.148]                       invisible(muffled)
[13:36:26.148]                     }
[13:36:26.148]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.148]                   }
[13:36:26.148]                 }
[13:36:26.148]             }
[13:36:26.148]         }))
[13:36:26.148]     }, error = function(ex) {
[13:36:26.148]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.148]                 ...future.rng), started = ...future.startTime, 
[13:36:26.148]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.148]             version = "1.8"), class = "FutureResult")
[13:36:26.148]     }, finally = {
[13:36:26.148]         if (!identical(...future.workdir, getwd())) 
[13:36:26.148]             setwd(...future.workdir)
[13:36:26.148]         {
[13:36:26.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.148]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.148]             }
[13:36:26.148]             base::options(...future.oldOptions)
[13:36:26.148]             if (.Platform$OS.type == "windows") {
[13:36:26.148]                 old_names <- names(...future.oldEnvVars)
[13:36:26.148]                 envs <- base::Sys.getenv()
[13:36:26.148]                 names <- names(envs)
[13:36:26.148]                 common <- intersect(names, old_names)
[13:36:26.148]                 added <- setdiff(names, old_names)
[13:36:26.148]                 removed <- setdiff(old_names, names)
[13:36:26.148]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.148]                   envs[common]]
[13:36:26.148]                 NAMES <- toupper(changed)
[13:36:26.148]                 args <- list()
[13:36:26.148]                 for (kk in seq_along(NAMES)) {
[13:36:26.148]                   name <- changed[[kk]]
[13:36:26.148]                   NAME <- NAMES[[kk]]
[13:36:26.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.148]                     next
[13:36:26.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.148]                 }
[13:36:26.148]                 NAMES <- toupper(added)
[13:36:26.148]                 for (kk in seq_along(NAMES)) {
[13:36:26.148]                   name <- added[[kk]]
[13:36:26.148]                   NAME <- NAMES[[kk]]
[13:36:26.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.148]                     next
[13:36:26.148]                   args[[name]] <- ""
[13:36:26.148]                 }
[13:36:26.148]                 NAMES <- toupper(removed)
[13:36:26.148]                 for (kk in seq_along(NAMES)) {
[13:36:26.148]                   name <- removed[[kk]]
[13:36:26.148]                   NAME <- NAMES[[kk]]
[13:36:26.148]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.148]                     next
[13:36:26.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.148]                 }
[13:36:26.148]                 if (length(args) > 0) 
[13:36:26.148]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.148]             }
[13:36:26.148]             else {
[13:36:26.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.148]             }
[13:36:26.148]             {
[13:36:26.148]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.148]                   0L) {
[13:36:26.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.148]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.148]                   base::options(opts)
[13:36:26.148]                 }
[13:36:26.148]                 {
[13:36:26.148]                   {
[13:36:26.148]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.148]                     NULL
[13:36:26.148]                   }
[13:36:26.148]                   options(future.plan = NULL)
[13:36:26.148]                   if (is.na(NA_character_)) 
[13:36:26.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.148]                     .init = FALSE)
[13:36:26.148]                 }
[13:36:26.148]             }
[13:36:26.148]         }
[13:36:26.148]     })
[13:36:26.148]     if (TRUE) {
[13:36:26.148]         base::sink(type = "output", split = FALSE)
[13:36:26.148]         if (TRUE) {
[13:36:26.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.148]         }
[13:36:26.148]         else {
[13:36:26.148]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.148]         }
[13:36:26.148]         base::close(...future.stdout)
[13:36:26.148]         ...future.stdout <- NULL
[13:36:26.148]     }
[13:36:26.148]     ...future.result$conditions <- ...future.conditions
[13:36:26.148]     ...future.result$finished <- base::Sys.time()
[13:36:26.148]     ...future.result
[13:36:26.148] }
[13:36:26.150] assign_globals() ...
[13:36:26.150] List of 1
[13:36:26.150]  $ a: num 10
[13:36:26.150]  - attr(*, "where")=List of 1
[13:36:26.150]   ..$ a:<environment: R_EmptyEnv> 
[13:36:26.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:36:26.150]  - attr(*, "resolved")= logi FALSE
[13:36:26.150]  - attr(*, "total_size")= num 56
[13:36:26.150]  - attr(*, "already-done")= logi TRUE
[13:36:26.153] - copied ‘a’ to environment
[13:36:26.153] assign_globals() ... done
[13:36:26.153] requestCore(): workers = 2
[13:36:26.155] MulticoreFuture started
[13:36:26.155] - Launch lazy future ... done
[13:36:26.155] run() for ‘MulticoreFuture’ ... done
[13:36:26.156] result() for MulticoreFuture ...
[13:36:26.156] plan(): Setting new future strategy stack:
[13:36:26.156] List of future strategies:
[13:36:26.156] 1. sequential:
[13:36:26.156]    - args: function (..., envir = parent.frame())
[13:36:26.156]    - tweaked: FALSE
[13:36:26.156]    - call: NULL
[13:36:26.157] plan(): nbrOfWorkers() = 1
[13:36:26.159] plan(): Setting new future strategy stack:
[13:36:26.159] List of future strategies:
[13:36:26.159] 1. multicore:
[13:36:26.159]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:36:26.159]    - tweaked: FALSE
[13:36:26.159]    - call: plan(strategy)
[13:36:26.164] plan(): nbrOfWorkers() = 2
[13:36:26.165] result() for MulticoreFuture ...
[13:36:26.165] result() for MulticoreFuture ... done
[13:36:26.165] result() for MulticoreFuture ... done
[13:36:26.165] result() for MulticoreFuture ...
[13:36:26.166] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[13:36:26.166] plan(): Setting new future strategy stack:
[13:36:26.167] List of future strategies:
[13:36:26.167] 1. multisession:
[13:36:26.167]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:26.167]    - tweaked: FALSE
[13:36:26.167]    - call: plan(strategy)
[13:36:26.167] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:36:26.167] multisession:
[13:36:26.167] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:36:26.167] - tweaked: FALSE
[13:36:26.167] - call: plan(strategy)
[13:36:26.174] getGlobalsAndPackages() ...
[13:36:26.174] Not searching for globals
[13:36:26.174] - globals: [0] <none>
[13:36:26.175] getGlobalsAndPackages() ... DONE
[13:36:26.175] [local output] makeClusterPSOCK() ...
[13:36:26.223] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:36:26.224] [local output] Base port: 11406
[13:36:26.224] [local output] Getting setup options for 2 cluster nodes ...
[13:36:26.224] [local output]  - Node 1 of 2 ...
[13:36:26.225] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:26.225] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpt79Oa4/worker.rank=1.parallelly.parent=81713.13f3141491bcf.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpt79Oa4/worker.rank=1.parallelly.parent=81713.13f3141491bcf.pid")'’
[13:36:26.413] - Possible to infer worker's PID: TRUE
[13:36:26.413] [local output] Rscript port: 11406

[13:36:26.414] [local output]  - Node 2 of 2 ...
[13:36:26.414] [local output] localMachine=TRUE => revtunnel=FALSE

[13:36:26.415] [local output] Rscript port: 11406

[13:36:26.415] [local output] Getting setup options for 2 cluster nodes ... done
[13:36:26.415] [local output]  - Parallel setup requested for some PSOCK nodes
[13:36:26.416] [local output] Setting up PSOCK nodes in parallel
[13:36:26.416] List of 36
[13:36:26.416]  $ worker          : chr "localhost"
[13:36:26.416]   ..- attr(*, "localhost")= logi TRUE
[13:36:26.416]  $ master          : chr "localhost"
[13:36:26.416]  $ port            : int 11406
[13:36:26.416]  $ connectTimeout  : num 120
[13:36:26.416]  $ timeout         : num 2592000
[13:36:26.416]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:36:26.416]  $ homogeneous     : logi TRUE
[13:36:26.416]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:36:26.416]  $ rscript_envs    : NULL
[13:36:26.416]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:26.416]  $ rscript_startup : NULL
[13:36:26.416]  $ rscript_sh      : chr "sh"
[13:36:26.416]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:26.416]  $ methods         : logi TRUE
[13:36:26.416]  $ socketOptions   : chr "no-delay"
[13:36:26.416]  $ useXDR          : logi FALSE
[13:36:26.416]  $ outfile         : chr "/dev/null"
[13:36:26.416]  $ renice          : int NA
[13:36:26.416]  $ rshcmd          : NULL
[13:36:26.416]  $ user            : chr(0) 
[13:36:26.416]  $ revtunnel       : logi FALSE
[13:36:26.416]  $ rshlogfile      : NULL
[13:36:26.416]  $ rshopts         : chr(0) 
[13:36:26.416]  $ rank            : int 1
[13:36:26.416]  $ manual          : logi FALSE
[13:36:26.416]  $ dryrun          : logi FALSE
[13:36:26.416]  $ quiet           : logi FALSE
[13:36:26.416]  $ setup_strategy  : chr "parallel"
[13:36:26.416]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:26.416]  $ pidfile         : chr "/tmp/Rtmpt79Oa4/worker.rank=1.parallelly.parent=81713.13f3141491bcf.pid"
[13:36:26.416]  $ rshcmd_label    : NULL
[13:36:26.416]  $ rsh_call        : NULL
[13:36:26.416]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:36:26.416]  $ localMachine    : logi TRUE
[13:36:26.416]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:36:26.416]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:36:26.416]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:36:26.416]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:36:26.416]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:36:26.416]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:36:26.416]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:36:26.416]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:36:26.416]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:36:26.416]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:36:26.416]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:36:26.416]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:36:26.416]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:36:26.416]  $ arguments       :List of 28
[13:36:26.416]   ..$ worker          : chr "localhost"
[13:36:26.416]   ..$ master          : NULL
[13:36:26.416]   ..$ port            : int 11406
[13:36:26.416]   ..$ connectTimeout  : num 120
[13:36:26.416]   ..$ timeout         : num 2592000
[13:36:26.416]   ..$ rscript         : NULL
[13:36:26.416]   ..$ homogeneous     : NULL
[13:36:26.416]   ..$ rscript_args    : NULL
[13:36:26.416]   ..$ rscript_envs    : NULL
[13:36:26.416]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:36:26.416]   ..$ rscript_startup : NULL
[13:36:26.416]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:36:26.416]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:36:26.416]   ..$ methods         : logi TRUE
[13:36:26.416]   ..$ socketOptions   : chr "no-delay"
[13:36:26.416]   ..$ useXDR          : logi FALSE
[13:36:26.416]   ..$ outfile         : chr "/dev/null"
[13:36:26.416]   ..$ renice          : int NA
[13:36:26.416]   ..$ rshcmd          : NULL
[13:36:26.416]   ..$ user            : NULL
[13:36:26.416]   ..$ revtunnel       : logi NA
[13:36:26.416]   ..$ rshlogfile      : NULL
[13:36:26.416]   ..$ rshopts         : NULL
[13:36:26.416]   ..$ rank            : int 1
[13:36:26.416]   ..$ manual          : logi FALSE
[13:36:26.416]   ..$ dryrun          : logi FALSE
[13:36:26.416]   ..$ quiet           : logi FALSE
[13:36:26.416]   ..$ setup_strategy  : chr "parallel"
[13:36:26.416]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:36:26.433] [local output] System call to launch all workers:
[13:36:26.433] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpt79Oa4/worker.rank=1.parallelly.parent=81713.13f3141491bcf.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11406 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:36:26.433] [local output] Starting PSOCK main server
[13:36:26.439] [local output] Workers launched
[13:36:26.439] [local output] Waiting for workers to connect back
[13:36:26.439]  - [local output] 0 workers out of 2 ready
[13:36:26.683]  - [local output] 0 workers out of 2 ready
[13:36:26.683]  - [local output] 1 workers out of 2 ready
[13:36:26.689]  - [local output] 1 workers out of 2 ready
[13:36:26.689]  - [local output] 2 workers out of 2 ready
[13:36:26.690] [local output] Launching of workers completed
[13:36:26.690] [local output] Collecting session information from workers
[13:36:26.691] [local output]  - Worker #1 of 2
[13:36:26.691] [local output]  - Worker #2 of 2
[13:36:26.691] [local output] makeClusterPSOCK() ... done
[13:36:26.703] Packages needed by the future expression (n = 0): <none>
[13:36:26.703] Packages needed by future strategies (n = 0): <none>
[13:36:26.703] {
[13:36:26.703]     {
[13:36:26.703]         {
[13:36:26.703]             ...future.startTime <- base::Sys.time()
[13:36:26.703]             {
[13:36:26.703]                 {
[13:36:26.703]                   {
[13:36:26.703]                     {
[13:36:26.703]                       base::local({
[13:36:26.703]                         has_future <- base::requireNamespace("future", 
[13:36:26.703]                           quietly = TRUE)
[13:36:26.703]                         if (has_future) {
[13:36:26.703]                           ns <- base::getNamespace("future")
[13:36:26.703]                           version <- ns[[".package"]][["version"]]
[13:36:26.703]                           if (is.null(version)) 
[13:36:26.703]                             version <- utils::packageVersion("future")
[13:36:26.703]                         }
[13:36:26.703]                         else {
[13:36:26.703]                           version <- NULL
[13:36:26.703]                         }
[13:36:26.703]                         if (!has_future || version < "1.8.0") {
[13:36:26.703]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.703]                             "", base::R.version$version.string), 
[13:36:26.703]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.703]                               "release", "version")], collapse = " "), 
[13:36:26.703]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.703]                             info)
[13:36:26.703]                           info <- base::paste(info, collapse = "; ")
[13:36:26.703]                           if (!has_future) {
[13:36:26.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.703]                               info)
[13:36:26.703]                           }
[13:36:26.703]                           else {
[13:36:26.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.703]                               info, version)
[13:36:26.703]                           }
[13:36:26.703]                           base::stop(msg)
[13:36:26.703]                         }
[13:36:26.703]                       })
[13:36:26.703]                     }
[13:36:26.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.703]                     base::options(mc.cores = 1L)
[13:36:26.703]                   }
[13:36:26.703]                   ...future.strategy.old <- future::plan("list")
[13:36:26.703]                   options(future.plan = NULL)
[13:36:26.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.703]                 }
[13:36:26.703]                 ...future.workdir <- getwd()
[13:36:26.703]             }
[13:36:26.703]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.703]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.703]         }
[13:36:26.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.703]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.703]             base::names(...future.oldOptions))
[13:36:26.703]     }
[13:36:26.703]     if (FALSE) {
[13:36:26.703]     }
[13:36:26.703]     else {
[13:36:26.703]         if (TRUE) {
[13:36:26.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.703]                 open = "w")
[13:36:26.703]         }
[13:36:26.703]         else {
[13:36:26.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.703]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.703]         }
[13:36:26.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.703]             base::sink(type = "output", split = FALSE)
[13:36:26.703]             base::close(...future.stdout)
[13:36:26.703]         }, add = TRUE)
[13:36:26.703]     }
[13:36:26.703]     ...future.frame <- base::sys.nframe()
[13:36:26.703]     ...future.conditions <- base::list()
[13:36:26.703]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.703]     if (FALSE) {
[13:36:26.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.703]     }
[13:36:26.703]     ...future.result <- base::tryCatch({
[13:36:26.703]         base::withCallingHandlers({
[13:36:26.703]             ...future.value <- base::withVisible(base::local({
[13:36:26.703]                 ...future.makeSendCondition <- base::local({
[13:36:26.703]                   sendCondition <- NULL
[13:36:26.703]                   function(frame = 1L) {
[13:36:26.703]                     if (is.function(sendCondition)) 
[13:36:26.703]                       return(sendCondition)
[13:36:26.703]                     ns <- getNamespace("parallel")
[13:36:26.703]                     if (exists("sendData", mode = "function", 
[13:36:26.703]                       envir = ns)) {
[13:36:26.703]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:26.703]                         envir = ns)
[13:36:26.703]                       envir <- sys.frame(frame)
[13:36:26.703]                       master <- NULL
[13:36:26.703]                       while (!identical(envir, .GlobalEnv) && 
[13:36:26.703]                         !identical(envir, emptyenv())) {
[13:36:26.703]                         if (exists("master", mode = "list", envir = envir, 
[13:36:26.703]                           inherits = FALSE)) {
[13:36:26.703]                           master <- get("master", mode = "list", 
[13:36:26.703]                             envir = envir, inherits = FALSE)
[13:36:26.703]                           if (inherits(master, c("SOCKnode", 
[13:36:26.703]                             "SOCK0node"))) {
[13:36:26.703]                             sendCondition <<- function(cond) {
[13:36:26.703]                               data <- list(type = "VALUE", value = cond, 
[13:36:26.703]                                 success = TRUE)
[13:36:26.703]                               parallel_sendData(master, data)
[13:36:26.703]                             }
[13:36:26.703]                             return(sendCondition)
[13:36:26.703]                           }
[13:36:26.703]                         }
[13:36:26.703]                         frame <- frame + 1L
[13:36:26.703]                         envir <- sys.frame(frame)
[13:36:26.703]                       }
[13:36:26.703]                     }
[13:36:26.703]                     sendCondition <<- function(cond) NULL
[13:36:26.703]                   }
[13:36:26.703]                 })
[13:36:26.703]                 withCallingHandlers({
[13:36:26.703]                   NA
[13:36:26.703]                 }, immediateCondition = function(cond) {
[13:36:26.703]                   sendCondition <- ...future.makeSendCondition()
[13:36:26.703]                   sendCondition(cond)
[13:36:26.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.703]                   {
[13:36:26.703]                     inherits <- base::inherits
[13:36:26.703]                     invokeRestart <- base::invokeRestart
[13:36:26.703]                     is.null <- base::is.null
[13:36:26.703]                     muffled <- FALSE
[13:36:26.703]                     if (inherits(cond, "message")) {
[13:36:26.703]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.703]                       if (muffled) 
[13:36:26.703]                         invokeRestart("muffleMessage")
[13:36:26.703]                     }
[13:36:26.703]                     else if (inherits(cond, "warning")) {
[13:36:26.703]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.703]                       if (muffled) 
[13:36:26.703]                         invokeRestart("muffleWarning")
[13:36:26.703]                     }
[13:36:26.703]                     else if (inherits(cond, "condition")) {
[13:36:26.703]                       if (!is.null(pattern)) {
[13:36:26.703]                         computeRestarts <- base::computeRestarts
[13:36:26.703]                         grepl <- base::grepl
[13:36:26.703]                         restarts <- computeRestarts(cond)
[13:36:26.703]                         for (restart in restarts) {
[13:36:26.703]                           name <- restart$name
[13:36:26.703]                           if (is.null(name)) 
[13:36:26.703]                             next
[13:36:26.703]                           if (!grepl(pattern, name)) 
[13:36:26.703]                             next
[13:36:26.703]                           invokeRestart(restart)
[13:36:26.703]                           muffled <- TRUE
[13:36:26.703]                           break
[13:36:26.703]                         }
[13:36:26.703]                       }
[13:36:26.703]                     }
[13:36:26.703]                     invisible(muffled)
[13:36:26.703]                   }
[13:36:26.703]                   muffleCondition(cond)
[13:36:26.703]                 })
[13:36:26.703]             }))
[13:36:26.703]             future::FutureResult(value = ...future.value$value, 
[13:36:26.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.703]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.703]                     ...future.globalenv.names))
[13:36:26.703]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.703]         }, condition = base::local({
[13:36:26.703]             c <- base::c
[13:36:26.703]             inherits <- base::inherits
[13:36:26.703]             invokeRestart <- base::invokeRestart
[13:36:26.703]             length <- base::length
[13:36:26.703]             list <- base::list
[13:36:26.703]             seq.int <- base::seq.int
[13:36:26.703]             signalCondition <- base::signalCondition
[13:36:26.703]             sys.calls <- base::sys.calls
[13:36:26.703]             `[[` <- base::`[[`
[13:36:26.703]             `+` <- base::`+`
[13:36:26.703]             `<<-` <- base::`<<-`
[13:36:26.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.703]                   3L)]
[13:36:26.703]             }
[13:36:26.703]             function(cond) {
[13:36:26.703]                 is_error <- inherits(cond, "error")
[13:36:26.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.703]                   NULL)
[13:36:26.703]                 if (is_error) {
[13:36:26.703]                   sessionInformation <- function() {
[13:36:26.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.703]                       search = base::search(), system = base::Sys.info())
[13:36:26.703]                   }
[13:36:26.703]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.703]                     cond$call), session = sessionInformation(), 
[13:36:26.703]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.703]                   signalCondition(cond)
[13:36:26.703]                 }
[13:36:26.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.703]                 "immediateCondition"))) {
[13:36:26.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.703]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.703]                   if (TRUE && !signal) {
[13:36:26.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.703]                     {
[13:36:26.703]                       inherits <- base::inherits
[13:36:26.703]                       invokeRestart <- base::invokeRestart
[13:36:26.703]                       is.null <- base::is.null
[13:36:26.703]                       muffled <- FALSE
[13:36:26.703]                       if (inherits(cond, "message")) {
[13:36:26.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.703]                         if (muffled) 
[13:36:26.703]                           invokeRestart("muffleMessage")
[13:36:26.703]                       }
[13:36:26.703]                       else if (inherits(cond, "warning")) {
[13:36:26.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.703]                         if (muffled) 
[13:36:26.703]                           invokeRestart("muffleWarning")
[13:36:26.703]                       }
[13:36:26.703]                       else if (inherits(cond, "condition")) {
[13:36:26.703]                         if (!is.null(pattern)) {
[13:36:26.703]                           computeRestarts <- base::computeRestarts
[13:36:26.703]                           grepl <- base::grepl
[13:36:26.703]                           restarts <- computeRestarts(cond)
[13:36:26.703]                           for (restart in restarts) {
[13:36:26.703]                             name <- restart$name
[13:36:26.703]                             if (is.null(name)) 
[13:36:26.703]                               next
[13:36:26.703]                             if (!grepl(pattern, name)) 
[13:36:26.703]                               next
[13:36:26.703]                             invokeRestart(restart)
[13:36:26.703]                             muffled <- TRUE
[13:36:26.703]                             break
[13:36:26.703]                           }
[13:36:26.703]                         }
[13:36:26.703]                       }
[13:36:26.703]                       invisible(muffled)
[13:36:26.703]                     }
[13:36:26.703]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.703]                   }
[13:36:26.703]                 }
[13:36:26.703]                 else {
[13:36:26.703]                   if (TRUE) {
[13:36:26.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.703]                     {
[13:36:26.703]                       inherits <- base::inherits
[13:36:26.703]                       invokeRestart <- base::invokeRestart
[13:36:26.703]                       is.null <- base::is.null
[13:36:26.703]                       muffled <- FALSE
[13:36:26.703]                       if (inherits(cond, "message")) {
[13:36:26.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.703]                         if (muffled) 
[13:36:26.703]                           invokeRestart("muffleMessage")
[13:36:26.703]                       }
[13:36:26.703]                       else if (inherits(cond, "warning")) {
[13:36:26.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.703]                         if (muffled) 
[13:36:26.703]                           invokeRestart("muffleWarning")
[13:36:26.703]                       }
[13:36:26.703]                       else if (inherits(cond, "condition")) {
[13:36:26.703]                         if (!is.null(pattern)) {
[13:36:26.703]                           computeRestarts <- base::computeRestarts
[13:36:26.703]                           grepl <- base::grepl
[13:36:26.703]                           restarts <- computeRestarts(cond)
[13:36:26.703]                           for (restart in restarts) {
[13:36:26.703]                             name <- restart$name
[13:36:26.703]                             if (is.null(name)) 
[13:36:26.703]                               next
[13:36:26.703]                             if (!grepl(pattern, name)) 
[13:36:26.703]                               next
[13:36:26.703]                             invokeRestart(restart)
[13:36:26.703]                             muffled <- TRUE
[13:36:26.703]                             break
[13:36:26.703]                           }
[13:36:26.703]                         }
[13:36:26.703]                       }
[13:36:26.703]                       invisible(muffled)
[13:36:26.703]                     }
[13:36:26.703]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.703]                   }
[13:36:26.703]                 }
[13:36:26.703]             }
[13:36:26.703]         }))
[13:36:26.703]     }, error = function(ex) {
[13:36:26.703]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.703]                 ...future.rng), started = ...future.startTime, 
[13:36:26.703]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.703]             version = "1.8"), class = "FutureResult")
[13:36:26.703]     }, finally = {
[13:36:26.703]         if (!identical(...future.workdir, getwd())) 
[13:36:26.703]             setwd(...future.workdir)
[13:36:26.703]         {
[13:36:26.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.703]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.703]             }
[13:36:26.703]             base::options(...future.oldOptions)
[13:36:26.703]             if (.Platform$OS.type == "windows") {
[13:36:26.703]                 old_names <- names(...future.oldEnvVars)
[13:36:26.703]                 envs <- base::Sys.getenv()
[13:36:26.703]                 names <- names(envs)
[13:36:26.703]                 common <- intersect(names, old_names)
[13:36:26.703]                 added <- setdiff(names, old_names)
[13:36:26.703]                 removed <- setdiff(old_names, names)
[13:36:26.703]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.703]                   envs[common]]
[13:36:26.703]                 NAMES <- toupper(changed)
[13:36:26.703]                 args <- list()
[13:36:26.703]                 for (kk in seq_along(NAMES)) {
[13:36:26.703]                   name <- changed[[kk]]
[13:36:26.703]                   NAME <- NAMES[[kk]]
[13:36:26.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.703]                     next
[13:36:26.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.703]                 }
[13:36:26.703]                 NAMES <- toupper(added)
[13:36:26.703]                 for (kk in seq_along(NAMES)) {
[13:36:26.703]                   name <- added[[kk]]
[13:36:26.703]                   NAME <- NAMES[[kk]]
[13:36:26.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.703]                     next
[13:36:26.703]                   args[[name]] <- ""
[13:36:26.703]                 }
[13:36:26.703]                 NAMES <- toupper(removed)
[13:36:26.703]                 for (kk in seq_along(NAMES)) {
[13:36:26.703]                   name <- removed[[kk]]
[13:36:26.703]                   NAME <- NAMES[[kk]]
[13:36:26.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.703]                     next
[13:36:26.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.703]                 }
[13:36:26.703]                 if (length(args) > 0) 
[13:36:26.703]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.703]             }
[13:36:26.703]             else {
[13:36:26.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.703]             }
[13:36:26.703]             {
[13:36:26.703]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.703]                   0L) {
[13:36:26.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.703]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.703]                   base::options(opts)
[13:36:26.703]                 }
[13:36:26.703]                 {
[13:36:26.703]                   {
[13:36:26.703]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.703]                     NULL
[13:36:26.703]                   }
[13:36:26.703]                   options(future.plan = NULL)
[13:36:26.703]                   if (is.na(NA_character_)) 
[13:36:26.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.703]                     .init = FALSE)
[13:36:26.703]                 }
[13:36:26.703]             }
[13:36:26.703]         }
[13:36:26.703]     })
[13:36:26.703]     if (TRUE) {
[13:36:26.703]         base::sink(type = "output", split = FALSE)
[13:36:26.703]         if (TRUE) {
[13:36:26.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.703]         }
[13:36:26.703]         else {
[13:36:26.703]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.703]         }
[13:36:26.703]         base::close(...future.stdout)
[13:36:26.703]         ...future.stdout <- NULL
[13:36:26.703]     }
[13:36:26.703]     ...future.result$conditions <- ...future.conditions
[13:36:26.703]     ...future.result$finished <- base::Sys.time()
[13:36:26.703]     ...future.result
[13:36:26.703] }
[13:36:26.756] MultisessionFuture started
[13:36:26.756] result() for ClusterFuture ...
[13:36:26.757] receiveMessageFromWorker() for ClusterFuture ...
[13:36:26.758] - Validating connection of MultisessionFuture
[13:36:26.790] - received message: FutureResult
[13:36:26.790] - Received FutureResult
[13:36:26.790] - Erased future from FutureRegistry
[13:36:26.790] result() for ClusterFuture ...
[13:36:26.790] - result already collected: FutureResult
[13:36:26.791] result() for ClusterFuture ... done
[13:36:26.791] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:26.791] result() for ClusterFuture ... done
[13:36:26.791] result() for ClusterFuture ...
[13:36:26.791] - result already collected: FutureResult
[13:36:26.791] result() for ClusterFuture ... done
[13:36:26.791] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:36:26.795] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[13:36:26.796] getGlobalsAndPackages() ...
[13:36:26.796] Searching for globals...
[13:36:26.797] - globals found: [2] ‘{’, ‘<-’
[13:36:26.797] Searching for globals ... DONE
[13:36:26.797] Resolving globals: FALSE
[13:36:26.798] 
[13:36:26.798] 
[13:36:26.798] getGlobalsAndPackages() ... DONE
[13:36:26.798] run() for ‘Future’ ...
[13:36:26.798] - state: ‘created’
[13:36:26.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.813] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:26.813]   - Field: ‘node’
[13:36:26.813]   - Field: ‘label’
[13:36:26.813]   - Field: ‘local’
[13:36:26.813]   - Field: ‘owner’
[13:36:26.814]   - Field: ‘envir’
[13:36:26.814]   - Field: ‘workers’
[13:36:26.814]   - Field: ‘packages’
[13:36:26.814]   - Field: ‘gc’
[13:36:26.814]   - Field: ‘conditions’
[13:36:26.814]   - Field: ‘persistent’
[13:36:26.814]   - Field: ‘expr’
[13:36:26.814]   - Field: ‘uuid’
[13:36:26.814]   - Field: ‘seed’
[13:36:26.815]   - Field: ‘version’
[13:36:26.815]   - Field: ‘result’
[13:36:26.815]   - Field: ‘asynchronous’
[13:36:26.815]   - Field: ‘calls’
[13:36:26.815]   - Field: ‘globals’
[13:36:26.815]   - Field: ‘stdout’
[13:36:26.815]   - Field: ‘earlySignal’
[13:36:26.815]   - Field: ‘lazy’
[13:36:26.815]   - Field: ‘state’
[13:36:26.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:26.816] - Launch lazy future ...
[13:36:26.816] Packages needed by the future expression (n = 0): <none>
[13:36:26.816] Packages needed by future strategies (n = 0): <none>
[13:36:26.817] {
[13:36:26.817]     {
[13:36:26.817]         {
[13:36:26.817]             ...future.startTime <- base::Sys.time()
[13:36:26.817]             {
[13:36:26.817]                 {
[13:36:26.817]                   {
[13:36:26.817]                     {
[13:36:26.817]                       base::local({
[13:36:26.817]                         has_future <- base::requireNamespace("future", 
[13:36:26.817]                           quietly = TRUE)
[13:36:26.817]                         if (has_future) {
[13:36:26.817]                           ns <- base::getNamespace("future")
[13:36:26.817]                           version <- ns[[".package"]][["version"]]
[13:36:26.817]                           if (is.null(version)) 
[13:36:26.817]                             version <- utils::packageVersion("future")
[13:36:26.817]                         }
[13:36:26.817]                         else {
[13:36:26.817]                           version <- NULL
[13:36:26.817]                         }
[13:36:26.817]                         if (!has_future || version < "1.8.0") {
[13:36:26.817]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.817]                             "", base::R.version$version.string), 
[13:36:26.817]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.817]                               "release", "version")], collapse = " "), 
[13:36:26.817]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.817]                             info)
[13:36:26.817]                           info <- base::paste(info, collapse = "; ")
[13:36:26.817]                           if (!has_future) {
[13:36:26.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.817]                               info)
[13:36:26.817]                           }
[13:36:26.817]                           else {
[13:36:26.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.817]                               info, version)
[13:36:26.817]                           }
[13:36:26.817]                           base::stop(msg)
[13:36:26.817]                         }
[13:36:26.817]                       })
[13:36:26.817]                     }
[13:36:26.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.817]                     base::options(mc.cores = 1L)
[13:36:26.817]                   }
[13:36:26.817]                   ...future.strategy.old <- future::plan("list")
[13:36:26.817]                   options(future.plan = NULL)
[13:36:26.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.817]                 }
[13:36:26.817]                 ...future.workdir <- getwd()
[13:36:26.817]             }
[13:36:26.817]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.817]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.817]         }
[13:36:26.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.817]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.817]             base::names(...future.oldOptions))
[13:36:26.817]     }
[13:36:26.817]     if (FALSE) {
[13:36:26.817]     }
[13:36:26.817]     else {
[13:36:26.817]         if (TRUE) {
[13:36:26.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.817]                 open = "w")
[13:36:26.817]         }
[13:36:26.817]         else {
[13:36:26.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.817]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.817]         }
[13:36:26.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.817]             base::sink(type = "output", split = FALSE)
[13:36:26.817]             base::close(...future.stdout)
[13:36:26.817]         }, add = TRUE)
[13:36:26.817]     }
[13:36:26.817]     ...future.frame <- base::sys.nframe()
[13:36:26.817]     ...future.conditions <- base::list()
[13:36:26.817]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.817]     if (FALSE) {
[13:36:26.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.817]     }
[13:36:26.817]     ...future.result <- base::tryCatch({
[13:36:26.817]         base::withCallingHandlers({
[13:36:26.817]             ...future.value <- base::withVisible(base::local({
[13:36:26.817]                 ...future.makeSendCondition <- base::local({
[13:36:26.817]                   sendCondition <- NULL
[13:36:26.817]                   function(frame = 1L) {
[13:36:26.817]                     if (is.function(sendCondition)) 
[13:36:26.817]                       return(sendCondition)
[13:36:26.817]                     ns <- getNamespace("parallel")
[13:36:26.817]                     if (exists("sendData", mode = "function", 
[13:36:26.817]                       envir = ns)) {
[13:36:26.817]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:26.817]                         envir = ns)
[13:36:26.817]                       envir <- sys.frame(frame)
[13:36:26.817]                       master <- NULL
[13:36:26.817]                       while (!identical(envir, .GlobalEnv) && 
[13:36:26.817]                         !identical(envir, emptyenv())) {
[13:36:26.817]                         if (exists("master", mode = "list", envir = envir, 
[13:36:26.817]                           inherits = FALSE)) {
[13:36:26.817]                           master <- get("master", mode = "list", 
[13:36:26.817]                             envir = envir, inherits = FALSE)
[13:36:26.817]                           if (inherits(master, c("SOCKnode", 
[13:36:26.817]                             "SOCK0node"))) {
[13:36:26.817]                             sendCondition <<- function(cond) {
[13:36:26.817]                               data <- list(type = "VALUE", value = cond, 
[13:36:26.817]                                 success = TRUE)
[13:36:26.817]                               parallel_sendData(master, data)
[13:36:26.817]                             }
[13:36:26.817]                             return(sendCondition)
[13:36:26.817]                           }
[13:36:26.817]                         }
[13:36:26.817]                         frame <- frame + 1L
[13:36:26.817]                         envir <- sys.frame(frame)
[13:36:26.817]                       }
[13:36:26.817]                     }
[13:36:26.817]                     sendCondition <<- function(cond) NULL
[13:36:26.817]                   }
[13:36:26.817]                 })
[13:36:26.817]                 withCallingHandlers({
[13:36:26.817]                   {
[13:36:26.817]                     x <- 1
[13:36:26.817]                   }
[13:36:26.817]                 }, immediateCondition = function(cond) {
[13:36:26.817]                   sendCondition <- ...future.makeSendCondition()
[13:36:26.817]                   sendCondition(cond)
[13:36:26.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.817]                   {
[13:36:26.817]                     inherits <- base::inherits
[13:36:26.817]                     invokeRestart <- base::invokeRestart
[13:36:26.817]                     is.null <- base::is.null
[13:36:26.817]                     muffled <- FALSE
[13:36:26.817]                     if (inherits(cond, "message")) {
[13:36:26.817]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.817]                       if (muffled) 
[13:36:26.817]                         invokeRestart("muffleMessage")
[13:36:26.817]                     }
[13:36:26.817]                     else if (inherits(cond, "warning")) {
[13:36:26.817]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.817]                       if (muffled) 
[13:36:26.817]                         invokeRestart("muffleWarning")
[13:36:26.817]                     }
[13:36:26.817]                     else if (inherits(cond, "condition")) {
[13:36:26.817]                       if (!is.null(pattern)) {
[13:36:26.817]                         computeRestarts <- base::computeRestarts
[13:36:26.817]                         grepl <- base::grepl
[13:36:26.817]                         restarts <- computeRestarts(cond)
[13:36:26.817]                         for (restart in restarts) {
[13:36:26.817]                           name <- restart$name
[13:36:26.817]                           if (is.null(name)) 
[13:36:26.817]                             next
[13:36:26.817]                           if (!grepl(pattern, name)) 
[13:36:26.817]                             next
[13:36:26.817]                           invokeRestart(restart)
[13:36:26.817]                           muffled <- TRUE
[13:36:26.817]                           break
[13:36:26.817]                         }
[13:36:26.817]                       }
[13:36:26.817]                     }
[13:36:26.817]                     invisible(muffled)
[13:36:26.817]                   }
[13:36:26.817]                   muffleCondition(cond)
[13:36:26.817]                 })
[13:36:26.817]             }))
[13:36:26.817]             future::FutureResult(value = ...future.value$value, 
[13:36:26.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.817]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.817]                     ...future.globalenv.names))
[13:36:26.817]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.817]         }, condition = base::local({
[13:36:26.817]             c <- base::c
[13:36:26.817]             inherits <- base::inherits
[13:36:26.817]             invokeRestart <- base::invokeRestart
[13:36:26.817]             length <- base::length
[13:36:26.817]             list <- base::list
[13:36:26.817]             seq.int <- base::seq.int
[13:36:26.817]             signalCondition <- base::signalCondition
[13:36:26.817]             sys.calls <- base::sys.calls
[13:36:26.817]             `[[` <- base::`[[`
[13:36:26.817]             `+` <- base::`+`
[13:36:26.817]             `<<-` <- base::`<<-`
[13:36:26.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.817]                   3L)]
[13:36:26.817]             }
[13:36:26.817]             function(cond) {
[13:36:26.817]                 is_error <- inherits(cond, "error")
[13:36:26.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.817]                   NULL)
[13:36:26.817]                 if (is_error) {
[13:36:26.817]                   sessionInformation <- function() {
[13:36:26.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.817]                       search = base::search(), system = base::Sys.info())
[13:36:26.817]                   }
[13:36:26.817]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.817]                     cond$call), session = sessionInformation(), 
[13:36:26.817]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.817]                   signalCondition(cond)
[13:36:26.817]                 }
[13:36:26.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.817]                 "immediateCondition"))) {
[13:36:26.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.817]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.817]                   if (TRUE && !signal) {
[13:36:26.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.817]                     {
[13:36:26.817]                       inherits <- base::inherits
[13:36:26.817]                       invokeRestart <- base::invokeRestart
[13:36:26.817]                       is.null <- base::is.null
[13:36:26.817]                       muffled <- FALSE
[13:36:26.817]                       if (inherits(cond, "message")) {
[13:36:26.817]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.817]                         if (muffled) 
[13:36:26.817]                           invokeRestart("muffleMessage")
[13:36:26.817]                       }
[13:36:26.817]                       else if (inherits(cond, "warning")) {
[13:36:26.817]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.817]                         if (muffled) 
[13:36:26.817]                           invokeRestart("muffleWarning")
[13:36:26.817]                       }
[13:36:26.817]                       else if (inherits(cond, "condition")) {
[13:36:26.817]                         if (!is.null(pattern)) {
[13:36:26.817]                           computeRestarts <- base::computeRestarts
[13:36:26.817]                           grepl <- base::grepl
[13:36:26.817]                           restarts <- computeRestarts(cond)
[13:36:26.817]                           for (restart in restarts) {
[13:36:26.817]                             name <- restart$name
[13:36:26.817]                             if (is.null(name)) 
[13:36:26.817]                               next
[13:36:26.817]                             if (!grepl(pattern, name)) 
[13:36:26.817]                               next
[13:36:26.817]                             invokeRestart(restart)
[13:36:26.817]                             muffled <- TRUE
[13:36:26.817]                             break
[13:36:26.817]                           }
[13:36:26.817]                         }
[13:36:26.817]                       }
[13:36:26.817]                       invisible(muffled)
[13:36:26.817]                     }
[13:36:26.817]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.817]                   }
[13:36:26.817]                 }
[13:36:26.817]                 else {
[13:36:26.817]                   if (TRUE) {
[13:36:26.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.817]                     {
[13:36:26.817]                       inherits <- base::inherits
[13:36:26.817]                       invokeRestart <- base::invokeRestart
[13:36:26.817]                       is.null <- base::is.null
[13:36:26.817]                       muffled <- FALSE
[13:36:26.817]                       if (inherits(cond, "message")) {
[13:36:26.817]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.817]                         if (muffled) 
[13:36:26.817]                           invokeRestart("muffleMessage")
[13:36:26.817]                       }
[13:36:26.817]                       else if (inherits(cond, "warning")) {
[13:36:26.817]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.817]                         if (muffled) 
[13:36:26.817]                           invokeRestart("muffleWarning")
[13:36:26.817]                       }
[13:36:26.817]                       else if (inherits(cond, "condition")) {
[13:36:26.817]                         if (!is.null(pattern)) {
[13:36:26.817]                           computeRestarts <- base::computeRestarts
[13:36:26.817]                           grepl <- base::grepl
[13:36:26.817]                           restarts <- computeRestarts(cond)
[13:36:26.817]                           for (restart in restarts) {
[13:36:26.817]                             name <- restart$name
[13:36:26.817]                             if (is.null(name)) 
[13:36:26.817]                               next
[13:36:26.817]                             if (!grepl(pattern, name)) 
[13:36:26.817]                               next
[13:36:26.817]                             invokeRestart(restart)
[13:36:26.817]                             muffled <- TRUE
[13:36:26.817]                             break
[13:36:26.817]                           }
[13:36:26.817]                         }
[13:36:26.817]                       }
[13:36:26.817]                       invisible(muffled)
[13:36:26.817]                     }
[13:36:26.817]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.817]                   }
[13:36:26.817]                 }
[13:36:26.817]             }
[13:36:26.817]         }))
[13:36:26.817]     }, error = function(ex) {
[13:36:26.817]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.817]                 ...future.rng), started = ...future.startTime, 
[13:36:26.817]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.817]             version = "1.8"), class = "FutureResult")
[13:36:26.817]     }, finally = {
[13:36:26.817]         if (!identical(...future.workdir, getwd())) 
[13:36:26.817]             setwd(...future.workdir)
[13:36:26.817]         {
[13:36:26.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.817]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.817]             }
[13:36:26.817]             base::options(...future.oldOptions)
[13:36:26.817]             if (.Platform$OS.type == "windows") {
[13:36:26.817]                 old_names <- names(...future.oldEnvVars)
[13:36:26.817]                 envs <- base::Sys.getenv()
[13:36:26.817]                 names <- names(envs)
[13:36:26.817]                 common <- intersect(names, old_names)
[13:36:26.817]                 added <- setdiff(names, old_names)
[13:36:26.817]                 removed <- setdiff(old_names, names)
[13:36:26.817]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.817]                   envs[common]]
[13:36:26.817]                 NAMES <- toupper(changed)
[13:36:26.817]                 args <- list()
[13:36:26.817]                 for (kk in seq_along(NAMES)) {
[13:36:26.817]                   name <- changed[[kk]]
[13:36:26.817]                   NAME <- NAMES[[kk]]
[13:36:26.817]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.817]                     next
[13:36:26.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.817]                 }
[13:36:26.817]                 NAMES <- toupper(added)
[13:36:26.817]                 for (kk in seq_along(NAMES)) {
[13:36:26.817]                   name <- added[[kk]]
[13:36:26.817]                   NAME <- NAMES[[kk]]
[13:36:26.817]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.817]                     next
[13:36:26.817]                   args[[name]] <- ""
[13:36:26.817]                 }
[13:36:26.817]                 NAMES <- toupper(removed)
[13:36:26.817]                 for (kk in seq_along(NAMES)) {
[13:36:26.817]                   name <- removed[[kk]]
[13:36:26.817]                   NAME <- NAMES[[kk]]
[13:36:26.817]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.817]                     next
[13:36:26.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.817]                 }
[13:36:26.817]                 if (length(args) > 0) 
[13:36:26.817]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.817]             }
[13:36:26.817]             else {
[13:36:26.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.817]             }
[13:36:26.817]             {
[13:36:26.817]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.817]                   0L) {
[13:36:26.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.817]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.817]                   base::options(opts)
[13:36:26.817]                 }
[13:36:26.817]                 {
[13:36:26.817]                   {
[13:36:26.817]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.817]                     NULL
[13:36:26.817]                   }
[13:36:26.817]                   options(future.plan = NULL)
[13:36:26.817]                   if (is.na(NA_character_)) 
[13:36:26.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.817]                     .init = FALSE)
[13:36:26.817]                 }
[13:36:26.817]             }
[13:36:26.817]         }
[13:36:26.817]     })
[13:36:26.817]     if (TRUE) {
[13:36:26.817]         base::sink(type = "output", split = FALSE)
[13:36:26.817]         if (TRUE) {
[13:36:26.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.817]         }
[13:36:26.817]         else {
[13:36:26.817]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.817]         }
[13:36:26.817]         base::close(...future.stdout)
[13:36:26.817]         ...future.stdout <- NULL
[13:36:26.817]     }
[13:36:26.817]     ...future.result$conditions <- ...future.conditions
[13:36:26.817]     ...future.result$finished <- base::Sys.time()
[13:36:26.817]     ...future.result
[13:36:26.817] }
[13:36:26.820] MultisessionFuture started
[13:36:26.820] - Launch lazy future ... done
[13:36:26.820] run() for ‘MultisessionFuture’ ... done
[13:36:26.821] result() for ClusterFuture ...
[13:36:26.821] receiveMessageFromWorker() for ClusterFuture ...
[13:36:26.821] - Validating connection of MultisessionFuture
[13:36:26.825] - received message: FutureResult
[13:36:26.826] - Received FutureResult
[13:36:26.826] - Erased future from FutureRegistry
[13:36:26.826] result() for ClusterFuture ...
[13:36:26.826] - result already collected: FutureResult
[13:36:26.826] result() for ClusterFuture ... done
[13:36:26.826] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:26.826] result() for ClusterFuture ... done
[13:36:26.826] result() for ClusterFuture ...
[13:36:26.827] - result already collected: FutureResult
[13:36:26.827] result() for ClusterFuture ... done
** Future evaluation with globals
[13:36:26.827] getGlobalsAndPackages() ...
[13:36:26.827] Searching for globals...
[13:36:26.828] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:36:26.829] Searching for globals ... DONE
[13:36:26.829] Resolving globals: FALSE
[13:36:26.829] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:26.830] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:26.830] - globals: [1] ‘a’
[13:36:26.830] 
[13:36:26.830] getGlobalsAndPackages() ... DONE
[13:36:26.830] run() for ‘Future’ ...
[13:36:26.830] - state: ‘created’
[13:36:26.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:26.845]   - Field: ‘node’
[13:36:26.845]   - Field: ‘label’
[13:36:26.845]   - Field: ‘local’
[13:36:26.845]   - Field: ‘owner’
[13:36:26.845]   - Field: ‘envir’
[13:36:26.846]   - Field: ‘workers’
[13:36:26.846]   - Field: ‘packages’
[13:36:26.846]   - Field: ‘gc’
[13:36:26.846]   - Field: ‘conditions’
[13:36:26.846]   - Field: ‘persistent’
[13:36:26.846]   - Field: ‘expr’
[13:36:26.846]   - Field: ‘uuid’
[13:36:26.846]   - Field: ‘seed’
[13:36:26.846]   - Field: ‘version’
[13:36:26.847]   - Field: ‘result’
[13:36:26.847]   - Field: ‘asynchronous’
[13:36:26.847]   - Field: ‘calls’
[13:36:26.847]   - Field: ‘globals’
[13:36:26.847]   - Field: ‘stdout’
[13:36:26.847]   - Field: ‘earlySignal’
[13:36:26.847]   - Field: ‘lazy’
[13:36:26.847]   - Field: ‘state’
[13:36:26.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:26.848] - Launch lazy future ...
[13:36:26.848] Packages needed by the future expression (n = 0): <none>
[13:36:26.848] Packages needed by future strategies (n = 0): <none>
[13:36:26.849] {
[13:36:26.849]     {
[13:36:26.849]         {
[13:36:26.849]             ...future.startTime <- base::Sys.time()
[13:36:26.849]             {
[13:36:26.849]                 {
[13:36:26.849]                   {
[13:36:26.849]                     {
[13:36:26.849]                       base::local({
[13:36:26.849]                         has_future <- base::requireNamespace("future", 
[13:36:26.849]                           quietly = TRUE)
[13:36:26.849]                         if (has_future) {
[13:36:26.849]                           ns <- base::getNamespace("future")
[13:36:26.849]                           version <- ns[[".package"]][["version"]]
[13:36:26.849]                           if (is.null(version)) 
[13:36:26.849]                             version <- utils::packageVersion("future")
[13:36:26.849]                         }
[13:36:26.849]                         else {
[13:36:26.849]                           version <- NULL
[13:36:26.849]                         }
[13:36:26.849]                         if (!has_future || version < "1.8.0") {
[13:36:26.849]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.849]                             "", base::R.version$version.string), 
[13:36:26.849]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.849]                               "release", "version")], collapse = " "), 
[13:36:26.849]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.849]                             info)
[13:36:26.849]                           info <- base::paste(info, collapse = "; ")
[13:36:26.849]                           if (!has_future) {
[13:36:26.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.849]                               info)
[13:36:26.849]                           }
[13:36:26.849]                           else {
[13:36:26.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.849]                               info, version)
[13:36:26.849]                           }
[13:36:26.849]                           base::stop(msg)
[13:36:26.849]                         }
[13:36:26.849]                       })
[13:36:26.849]                     }
[13:36:26.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.849]                     base::options(mc.cores = 1L)
[13:36:26.849]                   }
[13:36:26.849]                   ...future.strategy.old <- future::plan("list")
[13:36:26.849]                   options(future.plan = NULL)
[13:36:26.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.849]                 }
[13:36:26.849]                 ...future.workdir <- getwd()
[13:36:26.849]             }
[13:36:26.849]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.849]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.849]         }
[13:36:26.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.849]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.849]             base::names(...future.oldOptions))
[13:36:26.849]     }
[13:36:26.849]     if (FALSE) {
[13:36:26.849]     }
[13:36:26.849]     else {
[13:36:26.849]         if (TRUE) {
[13:36:26.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.849]                 open = "w")
[13:36:26.849]         }
[13:36:26.849]         else {
[13:36:26.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.849]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.849]         }
[13:36:26.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.849]             base::sink(type = "output", split = FALSE)
[13:36:26.849]             base::close(...future.stdout)
[13:36:26.849]         }, add = TRUE)
[13:36:26.849]     }
[13:36:26.849]     ...future.frame <- base::sys.nframe()
[13:36:26.849]     ...future.conditions <- base::list()
[13:36:26.849]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.849]     if (FALSE) {
[13:36:26.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.849]     }
[13:36:26.849]     ...future.result <- base::tryCatch({
[13:36:26.849]         base::withCallingHandlers({
[13:36:26.849]             ...future.value <- base::withVisible(base::local({
[13:36:26.849]                 ...future.makeSendCondition <- base::local({
[13:36:26.849]                   sendCondition <- NULL
[13:36:26.849]                   function(frame = 1L) {
[13:36:26.849]                     if (is.function(sendCondition)) 
[13:36:26.849]                       return(sendCondition)
[13:36:26.849]                     ns <- getNamespace("parallel")
[13:36:26.849]                     if (exists("sendData", mode = "function", 
[13:36:26.849]                       envir = ns)) {
[13:36:26.849]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:26.849]                         envir = ns)
[13:36:26.849]                       envir <- sys.frame(frame)
[13:36:26.849]                       master <- NULL
[13:36:26.849]                       while (!identical(envir, .GlobalEnv) && 
[13:36:26.849]                         !identical(envir, emptyenv())) {
[13:36:26.849]                         if (exists("master", mode = "list", envir = envir, 
[13:36:26.849]                           inherits = FALSE)) {
[13:36:26.849]                           master <- get("master", mode = "list", 
[13:36:26.849]                             envir = envir, inherits = FALSE)
[13:36:26.849]                           if (inherits(master, c("SOCKnode", 
[13:36:26.849]                             "SOCK0node"))) {
[13:36:26.849]                             sendCondition <<- function(cond) {
[13:36:26.849]                               data <- list(type = "VALUE", value = cond, 
[13:36:26.849]                                 success = TRUE)
[13:36:26.849]                               parallel_sendData(master, data)
[13:36:26.849]                             }
[13:36:26.849]                             return(sendCondition)
[13:36:26.849]                           }
[13:36:26.849]                         }
[13:36:26.849]                         frame <- frame + 1L
[13:36:26.849]                         envir <- sys.frame(frame)
[13:36:26.849]                       }
[13:36:26.849]                     }
[13:36:26.849]                     sendCondition <<- function(cond) NULL
[13:36:26.849]                   }
[13:36:26.849]                 })
[13:36:26.849]                 withCallingHandlers({
[13:36:26.849]                   {
[13:36:26.849]                     x <- a
[13:36:26.849]                   }
[13:36:26.849]                 }, immediateCondition = function(cond) {
[13:36:26.849]                   sendCondition <- ...future.makeSendCondition()
[13:36:26.849]                   sendCondition(cond)
[13:36:26.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.849]                   {
[13:36:26.849]                     inherits <- base::inherits
[13:36:26.849]                     invokeRestart <- base::invokeRestart
[13:36:26.849]                     is.null <- base::is.null
[13:36:26.849]                     muffled <- FALSE
[13:36:26.849]                     if (inherits(cond, "message")) {
[13:36:26.849]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.849]                       if (muffled) 
[13:36:26.849]                         invokeRestart("muffleMessage")
[13:36:26.849]                     }
[13:36:26.849]                     else if (inherits(cond, "warning")) {
[13:36:26.849]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.849]                       if (muffled) 
[13:36:26.849]                         invokeRestart("muffleWarning")
[13:36:26.849]                     }
[13:36:26.849]                     else if (inherits(cond, "condition")) {
[13:36:26.849]                       if (!is.null(pattern)) {
[13:36:26.849]                         computeRestarts <- base::computeRestarts
[13:36:26.849]                         grepl <- base::grepl
[13:36:26.849]                         restarts <- computeRestarts(cond)
[13:36:26.849]                         for (restart in restarts) {
[13:36:26.849]                           name <- restart$name
[13:36:26.849]                           if (is.null(name)) 
[13:36:26.849]                             next
[13:36:26.849]                           if (!grepl(pattern, name)) 
[13:36:26.849]                             next
[13:36:26.849]                           invokeRestart(restart)
[13:36:26.849]                           muffled <- TRUE
[13:36:26.849]                           break
[13:36:26.849]                         }
[13:36:26.849]                       }
[13:36:26.849]                     }
[13:36:26.849]                     invisible(muffled)
[13:36:26.849]                   }
[13:36:26.849]                   muffleCondition(cond)
[13:36:26.849]                 })
[13:36:26.849]             }))
[13:36:26.849]             future::FutureResult(value = ...future.value$value, 
[13:36:26.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.849]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.849]                     ...future.globalenv.names))
[13:36:26.849]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.849]         }, condition = base::local({
[13:36:26.849]             c <- base::c
[13:36:26.849]             inherits <- base::inherits
[13:36:26.849]             invokeRestart <- base::invokeRestart
[13:36:26.849]             length <- base::length
[13:36:26.849]             list <- base::list
[13:36:26.849]             seq.int <- base::seq.int
[13:36:26.849]             signalCondition <- base::signalCondition
[13:36:26.849]             sys.calls <- base::sys.calls
[13:36:26.849]             `[[` <- base::`[[`
[13:36:26.849]             `+` <- base::`+`
[13:36:26.849]             `<<-` <- base::`<<-`
[13:36:26.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.849]                   3L)]
[13:36:26.849]             }
[13:36:26.849]             function(cond) {
[13:36:26.849]                 is_error <- inherits(cond, "error")
[13:36:26.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.849]                   NULL)
[13:36:26.849]                 if (is_error) {
[13:36:26.849]                   sessionInformation <- function() {
[13:36:26.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.849]                       search = base::search(), system = base::Sys.info())
[13:36:26.849]                   }
[13:36:26.849]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.849]                     cond$call), session = sessionInformation(), 
[13:36:26.849]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.849]                   signalCondition(cond)
[13:36:26.849]                 }
[13:36:26.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.849]                 "immediateCondition"))) {
[13:36:26.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.849]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.849]                   if (TRUE && !signal) {
[13:36:26.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.849]                     {
[13:36:26.849]                       inherits <- base::inherits
[13:36:26.849]                       invokeRestart <- base::invokeRestart
[13:36:26.849]                       is.null <- base::is.null
[13:36:26.849]                       muffled <- FALSE
[13:36:26.849]                       if (inherits(cond, "message")) {
[13:36:26.849]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.849]                         if (muffled) 
[13:36:26.849]                           invokeRestart("muffleMessage")
[13:36:26.849]                       }
[13:36:26.849]                       else if (inherits(cond, "warning")) {
[13:36:26.849]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.849]                         if (muffled) 
[13:36:26.849]                           invokeRestart("muffleWarning")
[13:36:26.849]                       }
[13:36:26.849]                       else if (inherits(cond, "condition")) {
[13:36:26.849]                         if (!is.null(pattern)) {
[13:36:26.849]                           computeRestarts <- base::computeRestarts
[13:36:26.849]                           grepl <- base::grepl
[13:36:26.849]                           restarts <- computeRestarts(cond)
[13:36:26.849]                           for (restart in restarts) {
[13:36:26.849]                             name <- restart$name
[13:36:26.849]                             if (is.null(name)) 
[13:36:26.849]                               next
[13:36:26.849]                             if (!grepl(pattern, name)) 
[13:36:26.849]                               next
[13:36:26.849]                             invokeRestart(restart)
[13:36:26.849]                             muffled <- TRUE
[13:36:26.849]                             break
[13:36:26.849]                           }
[13:36:26.849]                         }
[13:36:26.849]                       }
[13:36:26.849]                       invisible(muffled)
[13:36:26.849]                     }
[13:36:26.849]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.849]                   }
[13:36:26.849]                 }
[13:36:26.849]                 else {
[13:36:26.849]                   if (TRUE) {
[13:36:26.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.849]                     {
[13:36:26.849]                       inherits <- base::inherits
[13:36:26.849]                       invokeRestart <- base::invokeRestart
[13:36:26.849]                       is.null <- base::is.null
[13:36:26.849]                       muffled <- FALSE
[13:36:26.849]                       if (inherits(cond, "message")) {
[13:36:26.849]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.849]                         if (muffled) 
[13:36:26.849]                           invokeRestart("muffleMessage")
[13:36:26.849]                       }
[13:36:26.849]                       else if (inherits(cond, "warning")) {
[13:36:26.849]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.849]                         if (muffled) 
[13:36:26.849]                           invokeRestart("muffleWarning")
[13:36:26.849]                       }
[13:36:26.849]                       else if (inherits(cond, "condition")) {
[13:36:26.849]                         if (!is.null(pattern)) {
[13:36:26.849]                           computeRestarts <- base::computeRestarts
[13:36:26.849]                           grepl <- base::grepl
[13:36:26.849]                           restarts <- computeRestarts(cond)
[13:36:26.849]                           for (restart in restarts) {
[13:36:26.849]                             name <- restart$name
[13:36:26.849]                             if (is.null(name)) 
[13:36:26.849]                               next
[13:36:26.849]                             if (!grepl(pattern, name)) 
[13:36:26.849]                               next
[13:36:26.849]                             invokeRestart(restart)
[13:36:26.849]                             muffled <- TRUE
[13:36:26.849]                             break
[13:36:26.849]                           }
[13:36:26.849]                         }
[13:36:26.849]                       }
[13:36:26.849]                       invisible(muffled)
[13:36:26.849]                     }
[13:36:26.849]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.849]                   }
[13:36:26.849]                 }
[13:36:26.849]             }
[13:36:26.849]         }))
[13:36:26.849]     }, error = function(ex) {
[13:36:26.849]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.849]                 ...future.rng), started = ...future.startTime, 
[13:36:26.849]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.849]             version = "1.8"), class = "FutureResult")
[13:36:26.849]     }, finally = {
[13:36:26.849]         if (!identical(...future.workdir, getwd())) 
[13:36:26.849]             setwd(...future.workdir)
[13:36:26.849]         {
[13:36:26.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.849]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.849]             }
[13:36:26.849]             base::options(...future.oldOptions)
[13:36:26.849]             if (.Platform$OS.type == "windows") {
[13:36:26.849]                 old_names <- names(...future.oldEnvVars)
[13:36:26.849]                 envs <- base::Sys.getenv()
[13:36:26.849]                 names <- names(envs)
[13:36:26.849]                 common <- intersect(names, old_names)
[13:36:26.849]                 added <- setdiff(names, old_names)
[13:36:26.849]                 removed <- setdiff(old_names, names)
[13:36:26.849]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.849]                   envs[common]]
[13:36:26.849]                 NAMES <- toupper(changed)
[13:36:26.849]                 args <- list()
[13:36:26.849]                 for (kk in seq_along(NAMES)) {
[13:36:26.849]                   name <- changed[[kk]]
[13:36:26.849]                   NAME <- NAMES[[kk]]
[13:36:26.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.849]                     next
[13:36:26.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.849]                 }
[13:36:26.849]                 NAMES <- toupper(added)
[13:36:26.849]                 for (kk in seq_along(NAMES)) {
[13:36:26.849]                   name <- added[[kk]]
[13:36:26.849]                   NAME <- NAMES[[kk]]
[13:36:26.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.849]                     next
[13:36:26.849]                   args[[name]] <- ""
[13:36:26.849]                 }
[13:36:26.849]                 NAMES <- toupper(removed)
[13:36:26.849]                 for (kk in seq_along(NAMES)) {
[13:36:26.849]                   name <- removed[[kk]]
[13:36:26.849]                   NAME <- NAMES[[kk]]
[13:36:26.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.849]                     next
[13:36:26.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.849]                 }
[13:36:26.849]                 if (length(args) > 0) 
[13:36:26.849]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.849]             }
[13:36:26.849]             else {
[13:36:26.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.849]             }
[13:36:26.849]             {
[13:36:26.849]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.849]                   0L) {
[13:36:26.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.849]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.849]                   base::options(opts)
[13:36:26.849]                 }
[13:36:26.849]                 {
[13:36:26.849]                   {
[13:36:26.849]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.849]                     NULL
[13:36:26.849]                   }
[13:36:26.849]                   options(future.plan = NULL)
[13:36:26.849]                   if (is.na(NA_character_)) 
[13:36:26.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.849]                     .init = FALSE)
[13:36:26.849]                 }
[13:36:26.849]             }
[13:36:26.849]         }
[13:36:26.849]     })
[13:36:26.849]     if (TRUE) {
[13:36:26.849]         base::sink(type = "output", split = FALSE)
[13:36:26.849]         if (TRUE) {
[13:36:26.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.849]         }
[13:36:26.849]         else {
[13:36:26.849]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.849]         }
[13:36:26.849]         base::close(...future.stdout)
[13:36:26.849]         ...future.stdout <- NULL
[13:36:26.849]     }
[13:36:26.849]     ...future.result$conditions <- ...future.conditions
[13:36:26.849]     ...future.result$finished <- base::Sys.time()
[13:36:26.849]     ...future.result
[13:36:26.849] }
[13:36:26.851] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:36:26.852] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:36:26.852] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:36:26.852] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:36:26.853] MultisessionFuture started
[13:36:26.853] - Launch lazy future ... done
[13:36:26.853] run() for ‘MultisessionFuture’ ... done
[13:36:26.853] result() for ClusterFuture ...
[13:36:26.853] receiveMessageFromWorker() for ClusterFuture ...
[13:36:26.853] - Validating connection of MultisessionFuture
[13:36:26.854] - received message: FutureResult
[13:36:26.854] - Received FutureResult
[13:36:26.854] - Erased future from FutureRegistry
[13:36:26.855] result() for ClusterFuture ...
[13:36:26.855] - result already collected: FutureResult
[13:36:26.855] result() for ClusterFuture ... done
[13:36:26.855] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:26.855] result() for ClusterFuture ... done
[13:36:26.855] result() for ClusterFuture ...
[13:36:26.855] - result already collected: FutureResult
[13:36:26.855] result() for ClusterFuture ... done
** Future evaluation with errors
[13:36:26.856] getGlobalsAndPackages() ...
[13:36:26.856] Searching for globals...
[13:36:26.858] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:36:26.858] Searching for globals ... DONE
[13:36:26.858] Resolving globals: FALSE
[13:36:26.858] 
[13:36:26.858] 
[13:36:26.859] getGlobalsAndPackages() ... DONE
[13:36:26.859] run() for ‘Future’ ...
[13:36:26.859] - state: ‘created’
[13:36:26.859] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.873] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:26.874]   - Field: ‘node’
[13:36:26.874]   - Field: ‘label’
[13:36:26.874]   - Field: ‘local’
[13:36:26.874]   - Field: ‘owner’
[13:36:26.874]   - Field: ‘envir’
[13:36:26.874]   - Field: ‘workers’
[13:36:26.874]   - Field: ‘packages’
[13:36:26.874]   - Field: ‘gc’
[13:36:26.874]   - Field: ‘conditions’
[13:36:26.875]   - Field: ‘persistent’
[13:36:26.875]   - Field: ‘expr’
[13:36:26.875]   - Field: ‘uuid’
[13:36:26.875]   - Field: ‘seed’
[13:36:26.875]   - Field: ‘version’
[13:36:26.875]   - Field: ‘result’
[13:36:26.875]   - Field: ‘asynchronous’
[13:36:26.875]   - Field: ‘calls’
[13:36:26.875]   - Field: ‘globals’
[13:36:26.876]   - Field: ‘stdout’
[13:36:26.876]   - Field: ‘earlySignal’
[13:36:26.876]   - Field: ‘lazy’
[13:36:26.876]   - Field: ‘state’
[13:36:26.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:26.876] - Launch lazy future ...
[13:36:26.876] Packages needed by the future expression (n = 0): <none>
[13:36:26.877] Packages needed by future strategies (n = 0): <none>
[13:36:26.877] {
[13:36:26.877]     {
[13:36:26.877]         {
[13:36:26.877]             ...future.startTime <- base::Sys.time()
[13:36:26.877]             {
[13:36:26.877]                 {
[13:36:26.877]                   {
[13:36:26.877]                     {
[13:36:26.877]                       base::local({
[13:36:26.877]                         has_future <- base::requireNamespace("future", 
[13:36:26.877]                           quietly = TRUE)
[13:36:26.877]                         if (has_future) {
[13:36:26.877]                           ns <- base::getNamespace("future")
[13:36:26.877]                           version <- ns[[".package"]][["version"]]
[13:36:26.877]                           if (is.null(version)) 
[13:36:26.877]                             version <- utils::packageVersion("future")
[13:36:26.877]                         }
[13:36:26.877]                         else {
[13:36:26.877]                           version <- NULL
[13:36:26.877]                         }
[13:36:26.877]                         if (!has_future || version < "1.8.0") {
[13:36:26.877]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.877]                             "", base::R.version$version.string), 
[13:36:26.877]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.877]                               "release", "version")], collapse = " "), 
[13:36:26.877]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.877]                             info)
[13:36:26.877]                           info <- base::paste(info, collapse = "; ")
[13:36:26.877]                           if (!has_future) {
[13:36:26.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.877]                               info)
[13:36:26.877]                           }
[13:36:26.877]                           else {
[13:36:26.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.877]                               info, version)
[13:36:26.877]                           }
[13:36:26.877]                           base::stop(msg)
[13:36:26.877]                         }
[13:36:26.877]                       })
[13:36:26.877]                     }
[13:36:26.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.877]                     base::options(mc.cores = 1L)
[13:36:26.877]                   }
[13:36:26.877]                   ...future.strategy.old <- future::plan("list")
[13:36:26.877]                   options(future.plan = NULL)
[13:36:26.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.877]                 }
[13:36:26.877]                 ...future.workdir <- getwd()
[13:36:26.877]             }
[13:36:26.877]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.877]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.877]         }
[13:36:26.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.877]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.877]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.877]             base::names(...future.oldOptions))
[13:36:26.877]     }
[13:36:26.877]     if (FALSE) {
[13:36:26.877]     }
[13:36:26.877]     else {
[13:36:26.877]         if (TRUE) {
[13:36:26.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.877]                 open = "w")
[13:36:26.877]         }
[13:36:26.877]         else {
[13:36:26.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.877]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.877]         }
[13:36:26.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.877]             base::sink(type = "output", split = FALSE)
[13:36:26.877]             base::close(...future.stdout)
[13:36:26.877]         }, add = TRUE)
[13:36:26.877]     }
[13:36:26.877]     ...future.frame <- base::sys.nframe()
[13:36:26.877]     ...future.conditions <- base::list()
[13:36:26.877]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.877]     if (FALSE) {
[13:36:26.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.877]     }
[13:36:26.877]     ...future.result <- base::tryCatch({
[13:36:26.877]         base::withCallingHandlers({
[13:36:26.877]             ...future.value <- base::withVisible(base::local({
[13:36:26.877]                 ...future.makeSendCondition <- base::local({
[13:36:26.877]                   sendCondition <- NULL
[13:36:26.877]                   function(frame = 1L) {
[13:36:26.877]                     if (is.function(sendCondition)) 
[13:36:26.877]                       return(sendCondition)
[13:36:26.877]                     ns <- getNamespace("parallel")
[13:36:26.877]                     if (exists("sendData", mode = "function", 
[13:36:26.877]                       envir = ns)) {
[13:36:26.877]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:26.877]                         envir = ns)
[13:36:26.877]                       envir <- sys.frame(frame)
[13:36:26.877]                       master <- NULL
[13:36:26.877]                       while (!identical(envir, .GlobalEnv) && 
[13:36:26.877]                         !identical(envir, emptyenv())) {
[13:36:26.877]                         if (exists("master", mode = "list", envir = envir, 
[13:36:26.877]                           inherits = FALSE)) {
[13:36:26.877]                           master <- get("master", mode = "list", 
[13:36:26.877]                             envir = envir, inherits = FALSE)
[13:36:26.877]                           if (inherits(master, c("SOCKnode", 
[13:36:26.877]                             "SOCK0node"))) {
[13:36:26.877]                             sendCondition <<- function(cond) {
[13:36:26.877]                               data <- list(type = "VALUE", value = cond, 
[13:36:26.877]                                 success = TRUE)
[13:36:26.877]                               parallel_sendData(master, data)
[13:36:26.877]                             }
[13:36:26.877]                             return(sendCondition)
[13:36:26.877]                           }
[13:36:26.877]                         }
[13:36:26.877]                         frame <- frame + 1L
[13:36:26.877]                         envir <- sys.frame(frame)
[13:36:26.877]                       }
[13:36:26.877]                     }
[13:36:26.877]                     sendCondition <<- function(cond) NULL
[13:36:26.877]                   }
[13:36:26.877]                 })
[13:36:26.877]                 withCallingHandlers({
[13:36:26.877]                   {
[13:36:26.877]                     x <- 3
[13:36:26.877]                     stop("Woops!")
[13:36:26.877]                     x
[13:36:26.877]                   }
[13:36:26.877]                 }, immediateCondition = function(cond) {
[13:36:26.877]                   sendCondition <- ...future.makeSendCondition()
[13:36:26.877]                   sendCondition(cond)
[13:36:26.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.877]                   {
[13:36:26.877]                     inherits <- base::inherits
[13:36:26.877]                     invokeRestart <- base::invokeRestart
[13:36:26.877]                     is.null <- base::is.null
[13:36:26.877]                     muffled <- FALSE
[13:36:26.877]                     if (inherits(cond, "message")) {
[13:36:26.877]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.877]                       if (muffled) 
[13:36:26.877]                         invokeRestart("muffleMessage")
[13:36:26.877]                     }
[13:36:26.877]                     else if (inherits(cond, "warning")) {
[13:36:26.877]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.877]                       if (muffled) 
[13:36:26.877]                         invokeRestart("muffleWarning")
[13:36:26.877]                     }
[13:36:26.877]                     else if (inherits(cond, "condition")) {
[13:36:26.877]                       if (!is.null(pattern)) {
[13:36:26.877]                         computeRestarts <- base::computeRestarts
[13:36:26.877]                         grepl <- base::grepl
[13:36:26.877]                         restarts <- computeRestarts(cond)
[13:36:26.877]                         for (restart in restarts) {
[13:36:26.877]                           name <- restart$name
[13:36:26.877]                           if (is.null(name)) 
[13:36:26.877]                             next
[13:36:26.877]                           if (!grepl(pattern, name)) 
[13:36:26.877]                             next
[13:36:26.877]                           invokeRestart(restart)
[13:36:26.877]                           muffled <- TRUE
[13:36:26.877]                           break
[13:36:26.877]                         }
[13:36:26.877]                       }
[13:36:26.877]                     }
[13:36:26.877]                     invisible(muffled)
[13:36:26.877]                   }
[13:36:26.877]                   muffleCondition(cond)
[13:36:26.877]                 })
[13:36:26.877]             }))
[13:36:26.877]             future::FutureResult(value = ...future.value$value, 
[13:36:26.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.877]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.877]                     ...future.globalenv.names))
[13:36:26.877]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.877]         }, condition = base::local({
[13:36:26.877]             c <- base::c
[13:36:26.877]             inherits <- base::inherits
[13:36:26.877]             invokeRestart <- base::invokeRestart
[13:36:26.877]             length <- base::length
[13:36:26.877]             list <- base::list
[13:36:26.877]             seq.int <- base::seq.int
[13:36:26.877]             signalCondition <- base::signalCondition
[13:36:26.877]             sys.calls <- base::sys.calls
[13:36:26.877]             `[[` <- base::`[[`
[13:36:26.877]             `+` <- base::`+`
[13:36:26.877]             `<<-` <- base::`<<-`
[13:36:26.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.877]                   3L)]
[13:36:26.877]             }
[13:36:26.877]             function(cond) {
[13:36:26.877]                 is_error <- inherits(cond, "error")
[13:36:26.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.877]                   NULL)
[13:36:26.877]                 if (is_error) {
[13:36:26.877]                   sessionInformation <- function() {
[13:36:26.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.877]                       search = base::search(), system = base::Sys.info())
[13:36:26.877]                   }
[13:36:26.877]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.877]                     cond$call), session = sessionInformation(), 
[13:36:26.877]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.877]                   signalCondition(cond)
[13:36:26.877]                 }
[13:36:26.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.877]                 "immediateCondition"))) {
[13:36:26.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.877]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.877]                   if (TRUE && !signal) {
[13:36:26.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.877]                     {
[13:36:26.877]                       inherits <- base::inherits
[13:36:26.877]                       invokeRestart <- base::invokeRestart
[13:36:26.877]                       is.null <- base::is.null
[13:36:26.877]                       muffled <- FALSE
[13:36:26.877]                       if (inherits(cond, "message")) {
[13:36:26.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.877]                         if (muffled) 
[13:36:26.877]                           invokeRestart("muffleMessage")
[13:36:26.877]                       }
[13:36:26.877]                       else if (inherits(cond, "warning")) {
[13:36:26.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.877]                         if (muffled) 
[13:36:26.877]                           invokeRestart("muffleWarning")
[13:36:26.877]                       }
[13:36:26.877]                       else if (inherits(cond, "condition")) {
[13:36:26.877]                         if (!is.null(pattern)) {
[13:36:26.877]                           computeRestarts <- base::computeRestarts
[13:36:26.877]                           grepl <- base::grepl
[13:36:26.877]                           restarts <- computeRestarts(cond)
[13:36:26.877]                           for (restart in restarts) {
[13:36:26.877]                             name <- restart$name
[13:36:26.877]                             if (is.null(name)) 
[13:36:26.877]                               next
[13:36:26.877]                             if (!grepl(pattern, name)) 
[13:36:26.877]                               next
[13:36:26.877]                             invokeRestart(restart)
[13:36:26.877]                             muffled <- TRUE
[13:36:26.877]                             break
[13:36:26.877]                           }
[13:36:26.877]                         }
[13:36:26.877]                       }
[13:36:26.877]                       invisible(muffled)
[13:36:26.877]                     }
[13:36:26.877]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.877]                   }
[13:36:26.877]                 }
[13:36:26.877]                 else {
[13:36:26.877]                   if (TRUE) {
[13:36:26.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.877]                     {
[13:36:26.877]                       inherits <- base::inherits
[13:36:26.877]                       invokeRestart <- base::invokeRestart
[13:36:26.877]                       is.null <- base::is.null
[13:36:26.877]                       muffled <- FALSE
[13:36:26.877]                       if (inherits(cond, "message")) {
[13:36:26.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.877]                         if (muffled) 
[13:36:26.877]                           invokeRestart("muffleMessage")
[13:36:26.877]                       }
[13:36:26.877]                       else if (inherits(cond, "warning")) {
[13:36:26.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.877]                         if (muffled) 
[13:36:26.877]                           invokeRestart("muffleWarning")
[13:36:26.877]                       }
[13:36:26.877]                       else if (inherits(cond, "condition")) {
[13:36:26.877]                         if (!is.null(pattern)) {
[13:36:26.877]                           computeRestarts <- base::computeRestarts
[13:36:26.877]                           grepl <- base::grepl
[13:36:26.877]                           restarts <- computeRestarts(cond)
[13:36:26.877]                           for (restart in restarts) {
[13:36:26.877]                             name <- restart$name
[13:36:26.877]                             if (is.null(name)) 
[13:36:26.877]                               next
[13:36:26.877]                             if (!grepl(pattern, name)) 
[13:36:26.877]                               next
[13:36:26.877]                             invokeRestart(restart)
[13:36:26.877]                             muffled <- TRUE
[13:36:26.877]                             break
[13:36:26.877]                           }
[13:36:26.877]                         }
[13:36:26.877]                       }
[13:36:26.877]                       invisible(muffled)
[13:36:26.877]                     }
[13:36:26.877]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.877]                   }
[13:36:26.877]                 }
[13:36:26.877]             }
[13:36:26.877]         }))
[13:36:26.877]     }, error = function(ex) {
[13:36:26.877]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.877]                 ...future.rng), started = ...future.startTime, 
[13:36:26.877]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.877]             version = "1.8"), class = "FutureResult")
[13:36:26.877]     }, finally = {
[13:36:26.877]         if (!identical(...future.workdir, getwd())) 
[13:36:26.877]             setwd(...future.workdir)
[13:36:26.877]         {
[13:36:26.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.877]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.877]             }
[13:36:26.877]             base::options(...future.oldOptions)
[13:36:26.877]             if (.Platform$OS.type == "windows") {
[13:36:26.877]                 old_names <- names(...future.oldEnvVars)
[13:36:26.877]                 envs <- base::Sys.getenv()
[13:36:26.877]                 names <- names(envs)
[13:36:26.877]                 common <- intersect(names, old_names)
[13:36:26.877]                 added <- setdiff(names, old_names)
[13:36:26.877]                 removed <- setdiff(old_names, names)
[13:36:26.877]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.877]                   envs[common]]
[13:36:26.877]                 NAMES <- toupper(changed)
[13:36:26.877]                 args <- list()
[13:36:26.877]                 for (kk in seq_along(NAMES)) {
[13:36:26.877]                   name <- changed[[kk]]
[13:36:26.877]                   NAME <- NAMES[[kk]]
[13:36:26.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.877]                     next
[13:36:26.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.877]                 }
[13:36:26.877]                 NAMES <- toupper(added)
[13:36:26.877]                 for (kk in seq_along(NAMES)) {
[13:36:26.877]                   name <- added[[kk]]
[13:36:26.877]                   NAME <- NAMES[[kk]]
[13:36:26.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.877]                     next
[13:36:26.877]                   args[[name]] <- ""
[13:36:26.877]                 }
[13:36:26.877]                 NAMES <- toupper(removed)
[13:36:26.877]                 for (kk in seq_along(NAMES)) {
[13:36:26.877]                   name <- removed[[kk]]
[13:36:26.877]                   NAME <- NAMES[[kk]]
[13:36:26.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.877]                     next
[13:36:26.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.877]                 }
[13:36:26.877]                 if (length(args) > 0) 
[13:36:26.877]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.877]             }
[13:36:26.877]             else {
[13:36:26.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.877]             }
[13:36:26.877]             {
[13:36:26.877]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.877]                   0L) {
[13:36:26.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.877]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.877]                   base::options(opts)
[13:36:26.877]                 }
[13:36:26.877]                 {
[13:36:26.877]                   {
[13:36:26.877]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.877]                     NULL
[13:36:26.877]                   }
[13:36:26.877]                   options(future.plan = NULL)
[13:36:26.877]                   if (is.na(NA_character_)) 
[13:36:26.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.877]                     .init = FALSE)
[13:36:26.877]                 }
[13:36:26.877]             }
[13:36:26.877]         }
[13:36:26.877]     })
[13:36:26.877]     if (TRUE) {
[13:36:26.877]         base::sink(type = "output", split = FALSE)
[13:36:26.877]         if (TRUE) {
[13:36:26.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.877]         }
[13:36:26.877]         else {
[13:36:26.877]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.877]         }
[13:36:26.877]         base::close(...future.stdout)
[13:36:26.877]         ...future.stdout <- NULL
[13:36:26.877]     }
[13:36:26.877]     ...future.result$conditions <- ...future.conditions
[13:36:26.877]     ...future.result$finished <- base::Sys.time()
[13:36:26.877]     ...future.result
[13:36:26.877] }
[13:36:26.880] MultisessionFuture started
[13:36:26.880] - Launch lazy future ... done
[13:36:26.881] run() for ‘MultisessionFuture’ ... done
[13:36:26.881] result() for ClusterFuture ...
[13:36:26.881] receiveMessageFromWorker() for ClusterFuture ...
[13:36:26.881] - Validating connection of MultisessionFuture
[13:36:26.883] - received message: FutureResult
[13:36:26.883] - Received FutureResult
[13:36:26.883] - Erased future from FutureRegistry
[13:36:26.883] result() for ClusterFuture ...
[13:36:26.884] - result already collected: FutureResult
[13:36:26.884] result() for ClusterFuture ... done
[13:36:26.884] signalConditions() ...
[13:36:26.884]  - include = ‘immediateCondition’
[13:36:26.884]  - exclude = 
[13:36:26.884]  - resignal = FALSE
[13:36:26.884]  - Number of conditions: 1
[13:36:26.884] signalConditions() ... done
[13:36:26.884] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:26.885] result() for ClusterFuture ... done
[13:36:26.885] result() for ClusterFuture ...
[13:36:26.885] - result already collected: FutureResult
[13:36:26.885] result() for ClusterFuture ... done
[13:36:26.885] signalConditions() ...
[13:36:26.885]  - include = ‘immediateCondition’
[13:36:26.885]  - exclude = 
[13:36:26.885]  - resignal = FALSE
[13:36:26.885]  - Number of conditions: 1
[13:36:26.886] signalConditions() ... done
[13:36:26.886] Future state: ‘finished’
[13:36:26.886] result() for ClusterFuture ...
[13:36:26.886] - result already collected: FutureResult
[13:36:26.886] result() for ClusterFuture ... done
[13:36:26.886] signalConditions() ...
[13:36:26.886]  - include = ‘condition’
[13:36:26.886]  - exclude = ‘immediateCondition’
[13:36:26.887]  - resignal = TRUE
[13:36:26.887]  - Number of conditions: 1
[13:36:26.887]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:26.887] signalConditions() ... done
[13:36:26.887] getGlobalsAndPackages() ...
[13:36:26.887] Searching for globals...
[13:36:26.889] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:26.890] Searching for globals ... DONE
[13:36:26.890] Resolving globals: FALSE
[13:36:26.890] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:26.891] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:26.891] - globals: [1] ‘ii’
[13:36:26.891] 
[13:36:26.891] getGlobalsAndPackages() ... DONE
[13:36:26.891] run() for ‘Future’ ...
[13:36:26.891] - state: ‘created’
[13:36:26.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.909] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:26.910]   - Field: ‘node’
[13:36:26.910]   - Field: ‘label’
[13:36:26.910]   - Field: ‘local’
[13:36:26.910]   - Field: ‘owner’
[13:36:26.910]   - Field: ‘envir’
[13:36:26.910]   - Field: ‘workers’
[13:36:26.910]   - Field: ‘packages’
[13:36:26.910]   - Field: ‘gc’
[13:36:26.910]   - Field: ‘conditions’
[13:36:26.910]   - Field: ‘persistent’
[13:36:26.910]   - Field: ‘expr’
[13:36:26.911]   - Field: ‘uuid’
[13:36:26.911]   - Field: ‘seed’
[13:36:26.911]   - Field: ‘version’
[13:36:26.911]   - Field: ‘result’
[13:36:26.911]   - Field: ‘asynchronous’
[13:36:26.911]   - Field: ‘calls’
[13:36:26.911]   - Field: ‘globals’
[13:36:26.911]   - Field: ‘stdout’
[13:36:26.911]   - Field: ‘earlySignal’
[13:36:26.911]   - Field: ‘lazy’
[13:36:26.911]   - Field: ‘state’
[13:36:26.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:26.912] - Launch lazy future ...
[13:36:26.912] Packages needed by the future expression (n = 0): <none>
[13:36:26.912] Packages needed by future strategies (n = 0): <none>
[13:36:26.912] {
[13:36:26.912]     {
[13:36:26.912]         {
[13:36:26.912]             ...future.startTime <- base::Sys.time()
[13:36:26.912]             {
[13:36:26.912]                 {
[13:36:26.912]                   {
[13:36:26.912]                     {
[13:36:26.912]                       base::local({
[13:36:26.912]                         has_future <- base::requireNamespace("future", 
[13:36:26.912]                           quietly = TRUE)
[13:36:26.912]                         if (has_future) {
[13:36:26.912]                           ns <- base::getNamespace("future")
[13:36:26.912]                           version <- ns[[".package"]][["version"]]
[13:36:26.912]                           if (is.null(version)) 
[13:36:26.912]                             version <- utils::packageVersion("future")
[13:36:26.912]                         }
[13:36:26.912]                         else {
[13:36:26.912]                           version <- NULL
[13:36:26.912]                         }
[13:36:26.912]                         if (!has_future || version < "1.8.0") {
[13:36:26.912]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.912]                             "", base::R.version$version.string), 
[13:36:26.912]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.912]                               "release", "version")], collapse = " "), 
[13:36:26.912]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.912]                             info)
[13:36:26.912]                           info <- base::paste(info, collapse = "; ")
[13:36:26.912]                           if (!has_future) {
[13:36:26.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.912]                               info)
[13:36:26.912]                           }
[13:36:26.912]                           else {
[13:36:26.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.912]                               info, version)
[13:36:26.912]                           }
[13:36:26.912]                           base::stop(msg)
[13:36:26.912]                         }
[13:36:26.912]                       })
[13:36:26.912]                     }
[13:36:26.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.912]                     base::options(mc.cores = 1L)
[13:36:26.912]                   }
[13:36:26.912]                   ...future.strategy.old <- future::plan("list")
[13:36:26.912]                   options(future.plan = NULL)
[13:36:26.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.912]                 }
[13:36:26.912]                 ...future.workdir <- getwd()
[13:36:26.912]             }
[13:36:26.912]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.912]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.912]         }
[13:36:26.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.912]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.912]             base::names(...future.oldOptions))
[13:36:26.912]     }
[13:36:26.912]     if (FALSE) {
[13:36:26.912]     }
[13:36:26.912]     else {
[13:36:26.912]         if (TRUE) {
[13:36:26.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.912]                 open = "w")
[13:36:26.912]         }
[13:36:26.912]         else {
[13:36:26.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.912]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.912]         }
[13:36:26.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.912]             base::sink(type = "output", split = FALSE)
[13:36:26.912]             base::close(...future.stdout)
[13:36:26.912]         }, add = TRUE)
[13:36:26.912]     }
[13:36:26.912]     ...future.frame <- base::sys.nframe()
[13:36:26.912]     ...future.conditions <- base::list()
[13:36:26.912]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.912]     if (FALSE) {
[13:36:26.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.912]     }
[13:36:26.912]     ...future.result <- base::tryCatch({
[13:36:26.912]         base::withCallingHandlers({
[13:36:26.912]             ...future.value <- base::withVisible(base::local({
[13:36:26.912]                 ...future.makeSendCondition <- base::local({
[13:36:26.912]                   sendCondition <- NULL
[13:36:26.912]                   function(frame = 1L) {
[13:36:26.912]                     if (is.function(sendCondition)) 
[13:36:26.912]                       return(sendCondition)
[13:36:26.912]                     ns <- getNamespace("parallel")
[13:36:26.912]                     if (exists("sendData", mode = "function", 
[13:36:26.912]                       envir = ns)) {
[13:36:26.912]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:26.912]                         envir = ns)
[13:36:26.912]                       envir <- sys.frame(frame)
[13:36:26.912]                       master <- NULL
[13:36:26.912]                       while (!identical(envir, .GlobalEnv) && 
[13:36:26.912]                         !identical(envir, emptyenv())) {
[13:36:26.912]                         if (exists("master", mode = "list", envir = envir, 
[13:36:26.912]                           inherits = FALSE)) {
[13:36:26.912]                           master <- get("master", mode = "list", 
[13:36:26.912]                             envir = envir, inherits = FALSE)
[13:36:26.912]                           if (inherits(master, c("SOCKnode", 
[13:36:26.912]                             "SOCK0node"))) {
[13:36:26.912]                             sendCondition <<- function(cond) {
[13:36:26.912]                               data <- list(type = "VALUE", value = cond, 
[13:36:26.912]                                 success = TRUE)
[13:36:26.912]                               parallel_sendData(master, data)
[13:36:26.912]                             }
[13:36:26.912]                             return(sendCondition)
[13:36:26.912]                           }
[13:36:26.912]                         }
[13:36:26.912]                         frame <- frame + 1L
[13:36:26.912]                         envir <- sys.frame(frame)
[13:36:26.912]                       }
[13:36:26.912]                     }
[13:36:26.912]                     sendCondition <<- function(cond) NULL
[13:36:26.912]                   }
[13:36:26.912]                 })
[13:36:26.912]                 withCallingHandlers({
[13:36:26.912]                   {
[13:36:26.912]                     if (ii%%2 == 0) 
[13:36:26.912]                       stop("Woops!")
[13:36:26.912]                     ii
[13:36:26.912]                   }
[13:36:26.912]                 }, immediateCondition = function(cond) {
[13:36:26.912]                   sendCondition <- ...future.makeSendCondition()
[13:36:26.912]                   sendCondition(cond)
[13:36:26.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.912]                   {
[13:36:26.912]                     inherits <- base::inherits
[13:36:26.912]                     invokeRestart <- base::invokeRestart
[13:36:26.912]                     is.null <- base::is.null
[13:36:26.912]                     muffled <- FALSE
[13:36:26.912]                     if (inherits(cond, "message")) {
[13:36:26.912]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.912]                       if (muffled) 
[13:36:26.912]                         invokeRestart("muffleMessage")
[13:36:26.912]                     }
[13:36:26.912]                     else if (inherits(cond, "warning")) {
[13:36:26.912]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.912]                       if (muffled) 
[13:36:26.912]                         invokeRestart("muffleWarning")
[13:36:26.912]                     }
[13:36:26.912]                     else if (inherits(cond, "condition")) {
[13:36:26.912]                       if (!is.null(pattern)) {
[13:36:26.912]                         computeRestarts <- base::computeRestarts
[13:36:26.912]                         grepl <- base::grepl
[13:36:26.912]                         restarts <- computeRestarts(cond)
[13:36:26.912]                         for (restart in restarts) {
[13:36:26.912]                           name <- restart$name
[13:36:26.912]                           if (is.null(name)) 
[13:36:26.912]                             next
[13:36:26.912]                           if (!grepl(pattern, name)) 
[13:36:26.912]                             next
[13:36:26.912]                           invokeRestart(restart)
[13:36:26.912]                           muffled <- TRUE
[13:36:26.912]                           break
[13:36:26.912]                         }
[13:36:26.912]                       }
[13:36:26.912]                     }
[13:36:26.912]                     invisible(muffled)
[13:36:26.912]                   }
[13:36:26.912]                   muffleCondition(cond)
[13:36:26.912]                 })
[13:36:26.912]             }))
[13:36:26.912]             future::FutureResult(value = ...future.value$value, 
[13:36:26.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.912]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.912]                     ...future.globalenv.names))
[13:36:26.912]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.912]         }, condition = base::local({
[13:36:26.912]             c <- base::c
[13:36:26.912]             inherits <- base::inherits
[13:36:26.912]             invokeRestart <- base::invokeRestart
[13:36:26.912]             length <- base::length
[13:36:26.912]             list <- base::list
[13:36:26.912]             seq.int <- base::seq.int
[13:36:26.912]             signalCondition <- base::signalCondition
[13:36:26.912]             sys.calls <- base::sys.calls
[13:36:26.912]             `[[` <- base::`[[`
[13:36:26.912]             `+` <- base::`+`
[13:36:26.912]             `<<-` <- base::`<<-`
[13:36:26.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.912]                   3L)]
[13:36:26.912]             }
[13:36:26.912]             function(cond) {
[13:36:26.912]                 is_error <- inherits(cond, "error")
[13:36:26.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.912]                   NULL)
[13:36:26.912]                 if (is_error) {
[13:36:26.912]                   sessionInformation <- function() {
[13:36:26.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.912]                       search = base::search(), system = base::Sys.info())
[13:36:26.912]                   }
[13:36:26.912]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.912]                     cond$call), session = sessionInformation(), 
[13:36:26.912]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.912]                   signalCondition(cond)
[13:36:26.912]                 }
[13:36:26.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.912]                 "immediateCondition"))) {
[13:36:26.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.912]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.912]                   if (TRUE && !signal) {
[13:36:26.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.912]                     {
[13:36:26.912]                       inherits <- base::inherits
[13:36:26.912]                       invokeRestart <- base::invokeRestart
[13:36:26.912]                       is.null <- base::is.null
[13:36:26.912]                       muffled <- FALSE
[13:36:26.912]                       if (inherits(cond, "message")) {
[13:36:26.912]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.912]                         if (muffled) 
[13:36:26.912]                           invokeRestart("muffleMessage")
[13:36:26.912]                       }
[13:36:26.912]                       else if (inherits(cond, "warning")) {
[13:36:26.912]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.912]                         if (muffled) 
[13:36:26.912]                           invokeRestart("muffleWarning")
[13:36:26.912]                       }
[13:36:26.912]                       else if (inherits(cond, "condition")) {
[13:36:26.912]                         if (!is.null(pattern)) {
[13:36:26.912]                           computeRestarts <- base::computeRestarts
[13:36:26.912]                           grepl <- base::grepl
[13:36:26.912]                           restarts <- computeRestarts(cond)
[13:36:26.912]                           for (restart in restarts) {
[13:36:26.912]                             name <- restart$name
[13:36:26.912]                             if (is.null(name)) 
[13:36:26.912]                               next
[13:36:26.912]                             if (!grepl(pattern, name)) 
[13:36:26.912]                               next
[13:36:26.912]                             invokeRestart(restart)
[13:36:26.912]                             muffled <- TRUE
[13:36:26.912]                             break
[13:36:26.912]                           }
[13:36:26.912]                         }
[13:36:26.912]                       }
[13:36:26.912]                       invisible(muffled)
[13:36:26.912]                     }
[13:36:26.912]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.912]                   }
[13:36:26.912]                 }
[13:36:26.912]                 else {
[13:36:26.912]                   if (TRUE) {
[13:36:26.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.912]                     {
[13:36:26.912]                       inherits <- base::inherits
[13:36:26.912]                       invokeRestart <- base::invokeRestart
[13:36:26.912]                       is.null <- base::is.null
[13:36:26.912]                       muffled <- FALSE
[13:36:26.912]                       if (inherits(cond, "message")) {
[13:36:26.912]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.912]                         if (muffled) 
[13:36:26.912]                           invokeRestart("muffleMessage")
[13:36:26.912]                       }
[13:36:26.912]                       else if (inherits(cond, "warning")) {
[13:36:26.912]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.912]                         if (muffled) 
[13:36:26.912]                           invokeRestart("muffleWarning")
[13:36:26.912]                       }
[13:36:26.912]                       else if (inherits(cond, "condition")) {
[13:36:26.912]                         if (!is.null(pattern)) {
[13:36:26.912]                           computeRestarts <- base::computeRestarts
[13:36:26.912]                           grepl <- base::grepl
[13:36:26.912]                           restarts <- computeRestarts(cond)
[13:36:26.912]                           for (restart in restarts) {
[13:36:26.912]                             name <- restart$name
[13:36:26.912]                             if (is.null(name)) 
[13:36:26.912]                               next
[13:36:26.912]                             if (!grepl(pattern, name)) 
[13:36:26.912]                               next
[13:36:26.912]                             invokeRestart(restart)
[13:36:26.912]                             muffled <- TRUE
[13:36:26.912]                             break
[13:36:26.912]                           }
[13:36:26.912]                         }
[13:36:26.912]                       }
[13:36:26.912]                       invisible(muffled)
[13:36:26.912]                     }
[13:36:26.912]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.912]                   }
[13:36:26.912]                 }
[13:36:26.912]             }
[13:36:26.912]         }))
[13:36:26.912]     }, error = function(ex) {
[13:36:26.912]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.912]                 ...future.rng), started = ...future.startTime, 
[13:36:26.912]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.912]             version = "1.8"), class = "FutureResult")
[13:36:26.912]     }, finally = {
[13:36:26.912]         if (!identical(...future.workdir, getwd())) 
[13:36:26.912]             setwd(...future.workdir)
[13:36:26.912]         {
[13:36:26.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.912]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.912]             }
[13:36:26.912]             base::options(...future.oldOptions)
[13:36:26.912]             if (.Platform$OS.type == "windows") {
[13:36:26.912]                 old_names <- names(...future.oldEnvVars)
[13:36:26.912]                 envs <- base::Sys.getenv()
[13:36:26.912]                 names <- names(envs)
[13:36:26.912]                 common <- intersect(names, old_names)
[13:36:26.912]                 added <- setdiff(names, old_names)
[13:36:26.912]                 removed <- setdiff(old_names, names)
[13:36:26.912]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.912]                   envs[common]]
[13:36:26.912]                 NAMES <- toupper(changed)
[13:36:26.912]                 args <- list()
[13:36:26.912]                 for (kk in seq_along(NAMES)) {
[13:36:26.912]                   name <- changed[[kk]]
[13:36:26.912]                   NAME <- NAMES[[kk]]
[13:36:26.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.912]                     next
[13:36:26.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.912]                 }
[13:36:26.912]                 NAMES <- toupper(added)
[13:36:26.912]                 for (kk in seq_along(NAMES)) {
[13:36:26.912]                   name <- added[[kk]]
[13:36:26.912]                   NAME <- NAMES[[kk]]
[13:36:26.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.912]                     next
[13:36:26.912]                   args[[name]] <- ""
[13:36:26.912]                 }
[13:36:26.912]                 NAMES <- toupper(removed)
[13:36:26.912]                 for (kk in seq_along(NAMES)) {
[13:36:26.912]                   name <- removed[[kk]]
[13:36:26.912]                   NAME <- NAMES[[kk]]
[13:36:26.912]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.912]                     next
[13:36:26.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.912]                 }
[13:36:26.912]                 if (length(args) > 0) 
[13:36:26.912]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.912]             }
[13:36:26.912]             else {
[13:36:26.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.912]             }
[13:36:26.912]             {
[13:36:26.912]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.912]                   0L) {
[13:36:26.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.912]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.912]                   base::options(opts)
[13:36:26.912]                 }
[13:36:26.912]                 {
[13:36:26.912]                   {
[13:36:26.912]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.912]                     NULL
[13:36:26.912]                   }
[13:36:26.912]                   options(future.plan = NULL)
[13:36:26.912]                   if (is.na(NA_character_)) 
[13:36:26.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.912]                     .init = FALSE)
[13:36:26.912]                 }
[13:36:26.912]             }
[13:36:26.912]         }
[13:36:26.912]     })
[13:36:26.912]     if (TRUE) {
[13:36:26.912]         base::sink(type = "output", split = FALSE)
[13:36:26.912]         if (TRUE) {
[13:36:26.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.912]         }
[13:36:26.912]         else {
[13:36:26.912]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.912]         }
[13:36:26.912]         base::close(...future.stdout)
[13:36:26.912]         ...future.stdout <- NULL
[13:36:26.912]     }
[13:36:26.912]     ...future.result$conditions <- ...future.conditions
[13:36:26.912]     ...future.result$finished <- base::Sys.time()
[13:36:26.912]     ...future.result
[13:36:26.912] }
[13:36:26.915] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:36:26.915] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:26.915] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:26.915] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:36:26.916] MultisessionFuture started
[13:36:26.916] - Launch lazy future ... done
[13:36:26.916] run() for ‘MultisessionFuture’ ... done
[13:36:26.916] getGlobalsAndPackages() ...
[13:36:26.917] Searching for globals...
[13:36:26.918] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:26.918] Searching for globals ... DONE
[13:36:26.918] Resolving globals: FALSE
[13:36:26.919] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:26.919] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:26.919] - globals: [1] ‘ii’
[13:36:26.919] 
[13:36:26.919] getGlobalsAndPackages() ... DONE
[13:36:26.920] run() for ‘Future’ ...
[13:36:26.920] - state: ‘created’
[13:36:26.920] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:26.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:26.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:26.934]   - Field: ‘node’
[13:36:26.934]   - Field: ‘label’
[13:36:26.934]   - Field: ‘local’
[13:36:26.934]   - Field: ‘owner’
[13:36:26.934]   - Field: ‘envir’
[13:36:26.934]   - Field: ‘workers’
[13:36:26.934]   - Field: ‘packages’
[13:36:26.934]   - Field: ‘gc’
[13:36:26.934]   - Field: ‘conditions’
[13:36:26.935]   - Field: ‘persistent’
[13:36:26.935]   - Field: ‘expr’
[13:36:26.935]   - Field: ‘uuid’
[13:36:26.935]   - Field: ‘seed’
[13:36:26.935]   - Field: ‘version’
[13:36:26.935]   - Field: ‘result’
[13:36:26.935]   - Field: ‘asynchronous’
[13:36:26.935]   - Field: ‘calls’
[13:36:26.935]   - Field: ‘globals’
[13:36:26.935]   - Field: ‘stdout’
[13:36:26.935]   - Field: ‘earlySignal’
[13:36:26.936]   - Field: ‘lazy’
[13:36:26.936]   - Field: ‘state’
[13:36:26.936] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:26.936] - Launch lazy future ...
[13:36:26.936] Packages needed by the future expression (n = 0): <none>
[13:36:26.936] Packages needed by future strategies (n = 0): <none>
[13:36:26.937] {
[13:36:26.937]     {
[13:36:26.937]         {
[13:36:26.937]             ...future.startTime <- base::Sys.time()
[13:36:26.937]             {
[13:36:26.937]                 {
[13:36:26.937]                   {
[13:36:26.937]                     {
[13:36:26.937]                       base::local({
[13:36:26.937]                         has_future <- base::requireNamespace("future", 
[13:36:26.937]                           quietly = TRUE)
[13:36:26.937]                         if (has_future) {
[13:36:26.937]                           ns <- base::getNamespace("future")
[13:36:26.937]                           version <- ns[[".package"]][["version"]]
[13:36:26.937]                           if (is.null(version)) 
[13:36:26.937]                             version <- utils::packageVersion("future")
[13:36:26.937]                         }
[13:36:26.937]                         else {
[13:36:26.937]                           version <- NULL
[13:36:26.937]                         }
[13:36:26.937]                         if (!has_future || version < "1.8.0") {
[13:36:26.937]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:26.937]                             "", base::R.version$version.string), 
[13:36:26.937]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:26.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:26.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:26.937]                               "release", "version")], collapse = " "), 
[13:36:26.937]                             hostname = base::Sys.info()[["nodename"]])
[13:36:26.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:26.937]                             info)
[13:36:26.937]                           info <- base::paste(info, collapse = "; ")
[13:36:26.937]                           if (!has_future) {
[13:36:26.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:26.937]                               info)
[13:36:26.937]                           }
[13:36:26.937]                           else {
[13:36:26.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:26.937]                               info, version)
[13:36:26.937]                           }
[13:36:26.937]                           base::stop(msg)
[13:36:26.937]                         }
[13:36:26.937]                       })
[13:36:26.937]                     }
[13:36:26.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:26.937]                     base::options(mc.cores = 1L)
[13:36:26.937]                   }
[13:36:26.937]                   ...future.strategy.old <- future::plan("list")
[13:36:26.937]                   options(future.plan = NULL)
[13:36:26.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:26.937]                 }
[13:36:26.937]                 ...future.workdir <- getwd()
[13:36:26.937]             }
[13:36:26.937]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:26.937]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:26.937]         }
[13:36:26.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:26.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:26.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:26.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:26.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:26.937]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:26.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:26.937]             base::names(...future.oldOptions))
[13:36:26.937]     }
[13:36:26.937]     if (FALSE) {
[13:36:26.937]     }
[13:36:26.937]     else {
[13:36:26.937]         if (TRUE) {
[13:36:26.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:26.937]                 open = "w")
[13:36:26.937]         }
[13:36:26.937]         else {
[13:36:26.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:26.937]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:26.937]         }
[13:36:26.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:26.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:26.937]             base::sink(type = "output", split = FALSE)
[13:36:26.937]             base::close(...future.stdout)
[13:36:26.937]         }, add = TRUE)
[13:36:26.937]     }
[13:36:26.937]     ...future.frame <- base::sys.nframe()
[13:36:26.937]     ...future.conditions <- base::list()
[13:36:26.937]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:26.937]     if (FALSE) {
[13:36:26.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:26.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:26.937]     }
[13:36:26.937]     ...future.result <- base::tryCatch({
[13:36:26.937]         base::withCallingHandlers({
[13:36:26.937]             ...future.value <- base::withVisible(base::local({
[13:36:26.937]                 ...future.makeSendCondition <- base::local({
[13:36:26.937]                   sendCondition <- NULL
[13:36:26.937]                   function(frame = 1L) {
[13:36:26.937]                     if (is.function(sendCondition)) 
[13:36:26.937]                       return(sendCondition)
[13:36:26.937]                     ns <- getNamespace("parallel")
[13:36:26.937]                     if (exists("sendData", mode = "function", 
[13:36:26.937]                       envir = ns)) {
[13:36:26.937]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:26.937]                         envir = ns)
[13:36:26.937]                       envir <- sys.frame(frame)
[13:36:26.937]                       master <- NULL
[13:36:26.937]                       while (!identical(envir, .GlobalEnv) && 
[13:36:26.937]                         !identical(envir, emptyenv())) {
[13:36:26.937]                         if (exists("master", mode = "list", envir = envir, 
[13:36:26.937]                           inherits = FALSE)) {
[13:36:26.937]                           master <- get("master", mode = "list", 
[13:36:26.937]                             envir = envir, inherits = FALSE)
[13:36:26.937]                           if (inherits(master, c("SOCKnode", 
[13:36:26.937]                             "SOCK0node"))) {
[13:36:26.937]                             sendCondition <<- function(cond) {
[13:36:26.937]                               data <- list(type = "VALUE", value = cond, 
[13:36:26.937]                                 success = TRUE)
[13:36:26.937]                               parallel_sendData(master, data)
[13:36:26.937]                             }
[13:36:26.937]                             return(sendCondition)
[13:36:26.937]                           }
[13:36:26.937]                         }
[13:36:26.937]                         frame <- frame + 1L
[13:36:26.937]                         envir <- sys.frame(frame)
[13:36:26.937]                       }
[13:36:26.937]                     }
[13:36:26.937]                     sendCondition <<- function(cond) NULL
[13:36:26.937]                   }
[13:36:26.937]                 })
[13:36:26.937]                 withCallingHandlers({
[13:36:26.937]                   {
[13:36:26.937]                     if (ii%%2 == 0) 
[13:36:26.937]                       stop("Woops!")
[13:36:26.937]                     ii
[13:36:26.937]                   }
[13:36:26.937]                 }, immediateCondition = function(cond) {
[13:36:26.937]                   sendCondition <- ...future.makeSendCondition()
[13:36:26.937]                   sendCondition(cond)
[13:36:26.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.937]                   {
[13:36:26.937]                     inherits <- base::inherits
[13:36:26.937]                     invokeRestart <- base::invokeRestart
[13:36:26.937]                     is.null <- base::is.null
[13:36:26.937]                     muffled <- FALSE
[13:36:26.937]                     if (inherits(cond, "message")) {
[13:36:26.937]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:26.937]                       if (muffled) 
[13:36:26.937]                         invokeRestart("muffleMessage")
[13:36:26.937]                     }
[13:36:26.937]                     else if (inherits(cond, "warning")) {
[13:36:26.937]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:26.937]                       if (muffled) 
[13:36:26.937]                         invokeRestart("muffleWarning")
[13:36:26.937]                     }
[13:36:26.937]                     else if (inherits(cond, "condition")) {
[13:36:26.937]                       if (!is.null(pattern)) {
[13:36:26.937]                         computeRestarts <- base::computeRestarts
[13:36:26.937]                         grepl <- base::grepl
[13:36:26.937]                         restarts <- computeRestarts(cond)
[13:36:26.937]                         for (restart in restarts) {
[13:36:26.937]                           name <- restart$name
[13:36:26.937]                           if (is.null(name)) 
[13:36:26.937]                             next
[13:36:26.937]                           if (!grepl(pattern, name)) 
[13:36:26.937]                             next
[13:36:26.937]                           invokeRestart(restart)
[13:36:26.937]                           muffled <- TRUE
[13:36:26.937]                           break
[13:36:26.937]                         }
[13:36:26.937]                       }
[13:36:26.937]                     }
[13:36:26.937]                     invisible(muffled)
[13:36:26.937]                   }
[13:36:26.937]                   muffleCondition(cond)
[13:36:26.937]                 })
[13:36:26.937]             }))
[13:36:26.937]             future::FutureResult(value = ...future.value$value, 
[13:36:26.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.937]                   ...future.rng), globalenv = if (FALSE) 
[13:36:26.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:26.937]                     ...future.globalenv.names))
[13:36:26.937]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:26.937]         }, condition = base::local({
[13:36:26.937]             c <- base::c
[13:36:26.937]             inherits <- base::inherits
[13:36:26.937]             invokeRestart <- base::invokeRestart
[13:36:26.937]             length <- base::length
[13:36:26.937]             list <- base::list
[13:36:26.937]             seq.int <- base::seq.int
[13:36:26.937]             signalCondition <- base::signalCondition
[13:36:26.937]             sys.calls <- base::sys.calls
[13:36:26.937]             `[[` <- base::`[[`
[13:36:26.937]             `+` <- base::`+`
[13:36:26.937]             `<<-` <- base::`<<-`
[13:36:26.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:26.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:26.937]                   3L)]
[13:36:26.937]             }
[13:36:26.937]             function(cond) {
[13:36:26.937]                 is_error <- inherits(cond, "error")
[13:36:26.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:26.937]                   NULL)
[13:36:26.937]                 if (is_error) {
[13:36:26.937]                   sessionInformation <- function() {
[13:36:26.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:26.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:26.937]                       search = base::search(), system = base::Sys.info())
[13:36:26.937]                   }
[13:36:26.937]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:26.937]                     cond$call), session = sessionInformation(), 
[13:36:26.937]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:26.937]                   signalCondition(cond)
[13:36:26.937]                 }
[13:36:26.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:26.937]                 "immediateCondition"))) {
[13:36:26.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:26.937]                   ...future.conditions[[length(...future.conditions) + 
[13:36:26.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:26.937]                   if (TRUE && !signal) {
[13:36:26.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.937]                     {
[13:36:26.937]                       inherits <- base::inherits
[13:36:26.937]                       invokeRestart <- base::invokeRestart
[13:36:26.937]                       is.null <- base::is.null
[13:36:26.937]                       muffled <- FALSE
[13:36:26.937]                       if (inherits(cond, "message")) {
[13:36:26.937]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.937]                         if (muffled) 
[13:36:26.937]                           invokeRestart("muffleMessage")
[13:36:26.937]                       }
[13:36:26.937]                       else if (inherits(cond, "warning")) {
[13:36:26.937]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.937]                         if (muffled) 
[13:36:26.937]                           invokeRestart("muffleWarning")
[13:36:26.937]                       }
[13:36:26.937]                       else if (inherits(cond, "condition")) {
[13:36:26.937]                         if (!is.null(pattern)) {
[13:36:26.937]                           computeRestarts <- base::computeRestarts
[13:36:26.937]                           grepl <- base::grepl
[13:36:26.937]                           restarts <- computeRestarts(cond)
[13:36:26.937]                           for (restart in restarts) {
[13:36:26.937]                             name <- restart$name
[13:36:26.937]                             if (is.null(name)) 
[13:36:26.937]                               next
[13:36:26.937]                             if (!grepl(pattern, name)) 
[13:36:26.937]                               next
[13:36:26.937]                             invokeRestart(restart)
[13:36:26.937]                             muffled <- TRUE
[13:36:26.937]                             break
[13:36:26.937]                           }
[13:36:26.937]                         }
[13:36:26.937]                       }
[13:36:26.937]                       invisible(muffled)
[13:36:26.937]                     }
[13:36:26.937]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.937]                   }
[13:36:26.937]                 }
[13:36:26.937]                 else {
[13:36:26.937]                   if (TRUE) {
[13:36:26.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:26.937]                     {
[13:36:26.937]                       inherits <- base::inherits
[13:36:26.937]                       invokeRestart <- base::invokeRestart
[13:36:26.937]                       is.null <- base::is.null
[13:36:26.937]                       muffled <- FALSE
[13:36:26.937]                       if (inherits(cond, "message")) {
[13:36:26.937]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:26.937]                         if (muffled) 
[13:36:26.937]                           invokeRestart("muffleMessage")
[13:36:26.937]                       }
[13:36:26.937]                       else if (inherits(cond, "warning")) {
[13:36:26.937]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:26.937]                         if (muffled) 
[13:36:26.937]                           invokeRestart("muffleWarning")
[13:36:26.937]                       }
[13:36:26.937]                       else if (inherits(cond, "condition")) {
[13:36:26.937]                         if (!is.null(pattern)) {
[13:36:26.937]                           computeRestarts <- base::computeRestarts
[13:36:26.937]                           grepl <- base::grepl
[13:36:26.937]                           restarts <- computeRestarts(cond)
[13:36:26.937]                           for (restart in restarts) {
[13:36:26.937]                             name <- restart$name
[13:36:26.937]                             if (is.null(name)) 
[13:36:26.937]                               next
[13:36:26.937]                             if (!grepl(pattern, name)) 
[13:36:26.937]                               next
[13:36:26.937]                             invokeRestart(restart)
[13:36:26.937]                             muffled <- TRUE
[13:36:26.937]                             break
[13:36:26.937]                           }
[13:36:26.937]                         }
[13:36:26.937]                       }
[13:36:26.937]                       invisible(muffled)
[13:36:26.937]                     }
[13:36:26.937]                     muffleCondition(cond, pattern = "^muffle")
[13:36:26.937]                   }
[13:36:26.937]                 }
[13:36:26.937]             }
[13:36:26.937]         }))
[13:36:26.937]     }, error = function(ex) {
[13:36:26.937]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:26.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:26.937]                 ...future.rng), started = ...future.startTime, 
[13:36:26.937]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:26.937]             version = "1.8"), class = "FutureResult")
[13:36:26.937]     }, finally = {
[13:36:26.937]         if (!identical(...future.workdir, getwd())) 
[13:36:26.937]             setwd(...future.workdir)
[13:36:26.937]         {
[13:36:26.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:26.937]                 ...future.oldOptions$nwarnings <- NULL
[13:36:26.937]             }
[13:36:26.937]             base::options(...future.oldOptions)
[13:36:26.937]             if (.Platform$OS.type == "windows") {
[13:36:26.937]                 old_names <- names(...future.oldEnvVars)
[13:36:26.937]                 envs <- base::Sys.getenv()
[13:36:26.937]                 names <- names(envs)
[13:36:26.937]                 common <- intersect(names, old_names)
[13:36:26.937]                 added <- setdiff(names, old_names)
[13:36:26.937]                 removed <- setdiff(old_names, names)
[13:36:26.937]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:26.937]                   envs[common]]
[13:36:26.937]                 NAMES <- toupper(changed)
[13:36:26.937]                 args <- list()
[13:36:26.937]                 for (kk in seq_along(NAMES)) {
[13:36:26.937]                   name <- changed[[kk]]
[13:36:26.937]                   NAME <- NAMES[[kk]]
[13:36:26.937]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.937]                     next
[13:36:26.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.937]                 }
[13:36:26.937]                 NAMES <- toupper(added)
[13:36:26.937]                 for (kk in seq_along(NAMES)) {
[13:36:26.937]                   name <- added[[kk]]
[13:36:26.937]                   NAME <- NAMES[[kk]]
[13:36:26.937]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.937]                     next
[13:36:26.937]                   args[[name]] <- ""
[13:36:26.937]                 }
[13:36:26.937]                 NAMES <- toupper(removed)
[13:36:26.937]                 for (kk in seq_along(NAMES)) {
[13:36:26.937]                   name <- removed[[kk]]
[13:36:26.937]                   NAME <- NAMES[[kk]]
[13:36:26.937]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:26.937]                     next
[13:36:26.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:26.937]                 }
[13:36:26.937]                 if (length(args) > 0) 
[13:36:26.937]                   base::do.call(base::Sys.setenv, args = args)
[13:36:26.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:26.937]             }
[13:36:26.937]             else {
[13:36:26.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:26.937]             }
[13:36:26.937]             {
[13:36:26.937]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:26.937]                   0L) {
[13:36:26.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:26.937]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:26.937]                   base::options(opts)
[13:36:26.937]                 }
[13:36:26.937]                 {
[13:36:26.937]                   {
[13:36:26.937]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:26.937]                     NULL
[13:36:26.937]                   }
[13:36:26.937]                   options(future.plan = NULL)
[13:36:26.937]                   if (is.na(NA_character_)) 
[13:36:26.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:26.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:26.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:26.937]                     .init = FALSE)
[13:36:26.937]                 }
[13:36:26.937]             }
[13:36:26.937]         }
[13:36:26.937]     })
[13:36:26.937]     if (TRUE) {
[13:36:26.937]         base::sink(type = "output", split = FALSE)
[13:36:26.937]         if (TRUE) {
[13:36:26.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:26.937]         }
[13:36:26.937]         else {
[13:36:26.937]             ...future.result["stdout"] <- base::list(NULL)
[13:36:26.937]         }
[13:36:26.937]         base::close(...future.stdout)
[13:36:26.937]         ...future.stdout <- NULL
[13:36:26.937]     }
[13:36:26.937]     ...future.result$conditions <- ...future.conditions
[13:36:26.937]     ...future.result$finished <- base::Sys.time()
[13:36:26.937]     ...future.result
[13:36:26.937] }
[13:36:26.990] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:36:26.990] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:36:26.990] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:36:26.990] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:36:26.991] MultisessionFuture started
[13:36:26.991] - Launch lazy future ... done
[13:36:26.991] run() for ‘MultisessionFuture’ ... done
[13:36:26.992] getGlobalsAndPackages() ...
[13:36:26.992] Searching for globals...
[13:36:26.993] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:36:26.993] Searching for globals ... DONE
[13:36:26.994] Resolving globals: FALSE
[13:36:26.994] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:26.994] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:36:26.995] - globals: [1] ‘ii’
[13:36:26.995] 
[13:36:26.995] getGlobalsAndPackages() ... DONE
[13:36:26.995] run() for ‘Future’ ...
[13:36:26.995] - state: ‘created’
[13:36:26.995] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:27.011] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:27.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:27.011]   - Field: ‘node’
[13:36:27.011]   - Field: ‘label’
[13:36:27.011]   - Field: ‘local’
[13:36:27.011]   - Field: ‘owner’
[13:36:27.011]   - Field: ‘envir’
[13:36:27.012]   - Field: ‘workers’
[13:36:27.012]   - Field: ‘packages’
[13:36:27.012]   - Field: ‘gc’
[13:36:27.012]   - Field: ‘conditions’
[13:36:27.012]   - Field: ‘persistent’
[13:36:27.012]   - Field: ‘expr’
[13:36:27.012]   - Field: ‘uuid’
[13:36:27.012]   - Field: ‘seed’
[13:36:27.012]   - Field: ‘version’
[13:36:27.012]   - Field: ‘result’
[13:36:27.012]   - Field: ‘asynchronous’
[13:36:27.013]   - Field: ‘calls’
[13:36:27.013]   - Field: ‘globals’
[13:36:27.013]   - Field: ‘stdout’
[13:36:27.013]   - Field: ‘earlySignal’
[13:36:27.013]   - Field: ‘lazy’
[13:36:27.013]   - Field: ‘state’
[13:36:27.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:27.013] - Launch lazy future ...
[13:36:27.014] Packages needed by the future expression (n = 0): <none>
[13:36:27.014] Packages needed by future strategies (n = 0): <none>
[13:36:27.014] {
[13:36:27.014]     {
[13:36:27.014]         {
[13:36:27.014]             ...future.startTime <- base::Sys.time()
[13:36:27.014]             {
[13:36:27.014]                 {
[13:36:27.014]                   {
[13:36:27.014]                     {
[13:36:27.014]                       base::local({
[13:36:27.014]                         has_future <- base::requireNamespace("future", 
[13:36:27.014]                           quietly = TRUE)
[13:36:27.014]                         if (has_future) {
[13:36:27.014]                           ns <- base::getNamespace("future")
[13:36:27.014]                           version <- ns[[".package"]][["version"]]
[13:36:27.014]                           if (is.null(version)) 
[13:36:27.014]                             version <- utils::packageVersion("future")
[13:36:27.014]                         }
[13:36:27.014]                         else {
[13:36:27.014]                           version <- NULL
[13:36:27.014]                         }
[13:36:27.014]                         if (!has_future || version < "1.8.0") {
[13:36:27.014]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:27.014]                             "", base::R.version$version.string), 
[13:36:27.014]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:27.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:27.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:27.014]                               "release", "version")], collapse = " "), 
[13:36:27.014]                             hostname = base::Sys.info()[["nodename"]])
[13:36:27.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:27.014]                             info)
[13:36:27.014]                           info <- base::paste(info, collapse = "; ")
[13:36:27.014]                           if (!has_future) {
[13:36:27.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:27.014]                               info)
[13:36:27.014]                           }
[13:36:27.014]                           else {
[13:36:27.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:27.014]                               info, version)
[13:36:27.014]                           }
[13:36:27.014]                           base::stop(msg)
[13:36:27.014]                         }
[13:36:27.014]                       })
[13:36:27.014]                     }
[13:36:27.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:27.014]                     base::options(mc.cores = 1L)
[13:36:27.014]                   }
[13:36:27.014]                   ...future.strategy.old <- future::plan("list")
[13:36:27.014]                   options(future.plan = NULL)
[13:36:27.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:27.014]                 }
[13:36:27.014]                 ...future.workdir <- getwd()
[13:36:27.014]             }
[13:36:27.014]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:27.014]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:27.014]         }
[13:36:27.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:27.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:27.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:27.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:27.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:27.014]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:27.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:27.014]             base::names(...future.oldOptions))
[13:36:27.014]     }
[13:36:27.014]     if (FALSE) {
[13:36:27.014]     }
[13:36:27.014]     else {
[13:36:27.014]         if (TRUE) {
[13:36:27.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:27.014]                 open = "w")
[13:36:27.014]         }
[13:36:27.014]         else {
[13:36:27.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:27.014]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:27.014]         }
[13:36:27.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:27.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:27.014]             base::sink(type = "output", split = FALSE)
[13:36:27.014]             base::close(...future.stdout)
[13:36:27.014]         }, add = TRUE)
[13:36:27.014]     }
[13:36:27.014]     ...future.frame <- base::sys.nframe()
[13:36:27.014]     ...future.conditions <- base::list()
[13:36:27.014]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:27.014]     if (FALSE) {
[13:36:27.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:27.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:27.014]     }
[13:36:27.014]     ...future.result <- base::tryCatch({
[13:36:27.014]         base::withCallingHandlers({
[13:36:27.014]             ...future.value <- base::withVisible(base::local({
[13:36:27.014]                 ...future.makeSendCondition <- base::local({
[13:36:27.014]                   sendCondition <- NULL
[13:36:27.014]                   function(frame = 1L) {
[13:36:27.014]                     if (is.function(sendCondition)) 
[13:36:27.014]                       return(sendCondition)
[13:36:27.014]                     ns <- getNamespace("parallel")
[13:36:27.014]                     if (exists("sendData", mode = "function", 
[13:36:27.014]                       envir = ns)) {
[13:36:27.014]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:27.014]                         envir = ns)
[13:36:27.014]                       envir <- sys.frame(frame)
[13:36:27.014]                       master <- NULL
[13:36:27.014]                       while (!identical(envir, .GlobalEnv) && 
[13:36:27.014]                         !identical(envir, emptyenv())) {
[13:36:27.014]                         if (exists("master", mode = "list", envir = envir, 
[13:36:27.014]                           inherits = FALSE)) {
[13:36:27.014]                           master <- get("master", mode = "list", 
[13:36:27.014]                             envir = envir, inherits = FALSE)
[13:36:27.014]                           if (inherits(master, c("SOCKnode", 
[13:36:27.014]                             "SOCK0node"))) {
[13:36:27.014]                             sendCondition <<- function(cond) {
[13:36:27.014]                               data <- list(type = "VALUE", value = cond, 
[13:36:27.014]                                 success = TRUE)
[13:36:27.014]                               parallel_sendData(master, data)
[13:36:27.014]                             }
[13:36:27.014]                             return(sendCondition)
[13:36:27.014]                           }
[13:36:27.014]                         }
[13:36:27.014]                         frame <- frame + 1L
[13:36:27.014]                         envir <- sys.frame(frame)
[13:36:27.014]                       }
[13:36:27.014]                     }
[13:36:27.014]                     sendCondition <<- function(cond) NULL
[13:36:27.014]                   }
[13:36:27.014]                 })
[13:36:27.014]                 withCallingHandlers({
[13:36:27.014]                   {
[13:36:27.014]                     if (ii%%2 == 0) 
[13:36:27.014]                       stop("Woops!")
[13:36:27.014]                     ii
[13:36:27.014]                   }
[13:36:27.014]                 }, immediateCondition = function(cond) {
[13:36:27.014]                   sendCondition <- ...future.makeSendCondition()
[13:36:27.014]                   sendCondition(cond)
[13:36:27.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.014]                   {
[13:36:27.014]                     inherits <- base::inherits
[13:36:27.014]                     invokeRestart <- base::invokeRestart
[13:36:27.014]                     is.null <- base::is.null
[13:36:27.014]                     muffled <- FALSE
[13:36:27.014]                     if (inherits(cond, "message")) {
[13:36:27.014]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:27.014]                       if (muffled) 
[13:36:27.014]                         invokeRestart("muffleMessage")
[13:36:27.014]                     }
[13:36:27.014]                     else if (inherits(cond, "warning")) {
[13:36:27.014]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:27.014]                       if (muffled) 
[13:36:27.014]                         invokeRestart("muffleWarning")
[13:36:27.014]                     }
[13:36:27.014]                     else if (inherits(cond, "condition")) {
[13:36:27.014]                       if (!is.null(pattern)) {
[13:36:27.014]                         computeRestarts <- base::computeRestarts
[13:36:27.014]                         grepl <- base::grepl
[13:36:27.014]                         restarts <- computeRestarts(cond)
[13:36:27.014]                         for (restart in restarts) {
[13:36:27.014]                           name <- restart$name
[13:36:27.014]                           if (is.null(name)) 
[13:36:27.014]                             next
[13:36:27.014]                           if (!grepl(pattern, name)) 
[13:36:27.014]                             next
[13:36:27.014]                           invokeRestart(restart)
[13:36:27.014]                           muffled <- TRUE
[13:36:27.014]                           break
[13:36:27.014]                         }
[13:36:27.014]                       }
[13:36:27.014]                     }
[13:36:27.014]                     invisible(muffled)
[13:36:27.014]                   }
[13:36:27.014]                   muffleCondition(cond)
[13:36:27.014]                 })
[13:36:27.014]             }))
[13:36:27.014]             future::FutureResult(value = ...future.value$value, 
[13:36:27.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.014]                   ...future.rng), globalenv = if (FALSE) 
[13:36:27.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:27.014]                     ...future.globalenv.names))
[13:36:27.014]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:27.014]         }, condition = base::local({
[13:36:27.014]             c <- base::c
[13:36:27.014]             inherits <- base::inherits
[13:36:27.014]             invokeRestart <- base::invokeRestart
[13:36:27.014]             length <- base::length
[13:36:27.014]             list <- base::list
[13:36:27.014]             seq.int <- base::seq.int
[13:36:27.014]             signalCondition <- base::signalCondition
[13:36:27.014]             sys.calls <- base::sys.calls
[13:36:27.014]             `[[` <- base::`[[`
[13:36:27.014]             `+` <- base::`+`
[13:36:27.014]             `<<-` <- base::`<<-`
[13:36:27.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:27.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:27.014]                   3L)]
[13:36:27.014]             }
[13:36:27.014]             function(cond) {
[13:36:27.014]                 is_error <- inherits(cond, "error")
[13:36:27.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:27.014]                   NULL)
[13:36:27.014]                 if (is_error) {
[13:36:27.014]                   sessionInformation <- function() {
[13:36:27.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:27.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:27.014]                       search = base::search(), system = base::Sys.info())
[13:36:27.014]                   }
[13:36:27.014]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:27.014]                     cond$call), session = sessionInformation(), 
[13:36:27.014]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:27.014]                   signalCondition(cond)
[13:36:27.014]                 }
[13:36:27.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:27.014]                 "immediateCondition"))) {
[13:36:27.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:27.014]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:27.014]                   if (TRUE && !signal) {
[13:36:27.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.014]                     {
[13:36:27.014]                       inherits <- base::inherits
[13:36:27.014]                       invokeRestart <- base::invokeRestart
[13:36:27.014]                       is.null <- base::is.null
[13:36:27.014]                       muffled <- FALSE
[13:36:27.014]                       if (inherits(cond, "message")) {
[13:36:27.014]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.014]                         if (muffled) 
[13:36:27.014]                           invokeRestart("muffleMessage")
[13:36:27.014]                       }
[13:36:27.014]                       else if (inherits(cond, "warning")) {
[13:36:27.014]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.014]                         if (muffled) 
[13:36:27.014]                           invokeRestart("muffleWarning")
[13:36:27.014]                       }
[13:36:27.014]                       else if (inherits(cond, "condition")) {
[13:36:27.014]                         if (!is.null(pattern)) {
[13:36:27.014]                           computeRestarts <- base::computeRestarts
[13:36:27.014]                           grepl <- base::grepl
[13:36:27.014]                           restarts <- computeRestarts(cond)
[13:36:27.014]                           for (restart in restarts) {
[13:36:27.014]                             name <- restart$name
[13:36:27.014]                             if (is.null(name)) 
[13:36:27.014]                               next
[13:36:27.014]                             if (!grepl(pattern, name)) 
[13:36:27.014]                               next
[13:36:27.014]                             invokeRestart(restart)
[13:36:27.014]                             muffled <- TRUE
[13:36:27.014]                             break
[13:36:27.014]                           }
[13:36:27.014]                         }
[13:36:27.014]                       }
[13:36:27.014]                       invisible(muffled)
[13:36:27.014]                     }
[13:36:27.014]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.014]                   }
[13:36:27.014]                 }
[13:36:27.014]                 else {
[13:36:27.014]                   if (TRUE) {
[13:36:27.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.014]                     {
[13:36:27.014]                       inherits <- base::inherits
[13:36:27.014]                       invokeRestart <- base::invokeRestart
[13:36:27.014]                       is.null <- base::is.null
[13:36:27.014]                       muffled <- FALSE
[13:36:27.014]                       if (inherits(cond, "message")) {
[13:36:27.014]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.014]                         if (muffled) 
[13:36:27.014]                           invokeRestart("muffleMessage")
[13:36:27.014]                       }
[13:36:27.014]                       else if (inherits(cond, "warning")) {
[13:36:27.014]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.014]                         if (muffled) 
[13:36:27.014]                           invokeRestart("muffleWarning")
[13:36:27.014]                       }
[13:36:27.014]                       else if (inherits(cond, "condition")) {
[13:36:27.014]                         if (!is.null(pattern)) {
[13:36:27.014]                           computeRestarts <- base::computeRestarts
[13:36:27.014]                           grepl <- base::grepl
[13:36:27.014]                           restarts <- computeRestarts(cond)
[13:36:27.014]                           for (restart in restarts) {
[13:36:27.014]                             name <- restart$name
[13:36:27.014]                             if (is.null(name)) 
[13:36:27.014]                               next
[13:36:27.014]                             if (!grepl(pattern, name)) 
[13:36:27.014]                               next
[13:36:27.014]                             invokeRestart(restart)
[13:36:27.014]                             muffled <- TRUE
[13:36:27.014]                             break
[13:36:27.014]                           }
[13:36:27.014]                         }
[13:36:27.014]                       }
[13:36:27.014]                       invisible(muffled)
[13:36:27.014]                     }
[13:36:27.014]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.014]                   }
[13:36:27.014]                 }
[13:36:27.014]             }
[13:36:27.014]         }))
[13:36:27.014]     }, error = function(ex) {
[13:36:27.014]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:27.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.014]                 ...future.rng), started = ...future.startTime, 
[13:36:27.014]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:27.014]             version = "1.8"), class = "FutureResult")
[13:36:27.014]     }, finally = {
[13:36:27.014]         if (!identical(...future.workdir, getwd())) 
[13:36:27.014]             setwd(...future.workdir)
[13:36:27.014]         {
[13:36:27.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:27.014]                 ...future.oldOptions$nwarnings <- NULL
[13:36:27.014]             }
[13:36:27.014]             base::options(...future.oldOptions)
[13:36:27.014]             if (.Platform$OS.type == "windows") {
[13:36:27.014]                 old_names <- names(...future.oldEnvVars)
[13:36:27.014]                 envs <- base::Sys.getenv()
[13:36:27.014]                 names <- names(envs)
[13:36:27.014]                 common <- intersect(names, old_names)
[13:36:27.014]                 added <- setdiff(names, old_names)
[13:36:27.014]                 removed <- setdiff(old_names, names)
[13:36:27.014]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:27.014]                   envs[common]]
[13:36:27.014]                 NAMES <- toupper(changed)
[13:36:27.014]                 args <- list()
[13:36:27.014]                 for (kk in seq_along(NAMES)) {
[13:36:27.014]                   name <- changed[[kk]]
[13:36:27.014]                   NAME <- NAMES[[kk]]
[13:36:27.014]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.014]                     next
[13:36:27.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.014]                 }
[13:36:27.014]                 NAMES <- toupper(added)
[13:36:27.014]                 for (kk in seq_along(NAMES)) {
[13:36:27.014]                   name <- added[[kk]]
[13:36:27.014]                   NAME <- NAMES[[kk]]
[13:36:27.014]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.014]                     next
[13:36:27.014]                   args[[name]] <- ""
[13:36:27.014]                 }
[13:36:27.014]                 NAMES <- toupper(removed)
[13:36:27.014]                 for (kk in seq_along(NAMES)) {
[13:36:27.014]                   name <- removed[[kk]]
[13:36:27.014]                   NAME <- NAMES[[kk]]
[13:36:27.014]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.014]                     next
[13:36:27.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.014]                 }
[13:36:27.014]                 if (length(args) > 0) 
[13:36:27.014]                   base::do.call(base::Sys.setenv, args = args)
[13:36:27.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:27.014]             }
[13:36:27.014]             else {
[13:36:27.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:27.014]             }
[13:36:27.014]             {
[13:36:27.014]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:27.014]                   0L) {
[13:36:27.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:27.014]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:27.014]                   base::options(opts)
[13:36:27.014]                 }
[13:36:27.014]                 {
[13:36:27.014]                   {
[13:36:27.014]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:27.014]                     NULL
[13:36:27.014]                   }
[13:36:27.014]                   options(future.plan = NULL)
[13:36:27.014]                   if (is.na(NA_character_)) 
[13:36:27.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:27.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:27.014]                     .init = FALSE)
[13:36:27.014]                 }
[13:36:27.014]             }
[13:36:27.014]         }
[13:36:27.014]     })
[13:36:27.014]     if (TRUE) {
[13:36:27.014]         base::sink(type = "output", split = FALSE)
[13:36:27.014]         if (TRUE) {
[13:36:27.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:27.014]         }
[13:36:27.014]         else {
[13:36:27.014]             ...future.result["stdout"] <- base::list(NULL)
[13:36:27.014]         }
[13:36:27.014]         base::close(...future.stdout)
[13:36:27.014]         ...future.stdout <- NULL
[13:36:27.014]     }
[13:36:27.014]     ...future.result$conditions <- ...future.conditions
[13:36:27.014]     ...future.result$finished <- base::Sys.time()
[13:36:27.014]     ...future.result
[13:36:27.014] }
[13:36:27.016] Poll #1 (0): usedNodes() = 2, workers = 2
[13:36:27.036] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.036] - Validating connection of MultisessionFuture
[13:36:27.036] - received message: FutureResult
[13:36:27.036] - Received FutureResult
[13:36:27.036] - Erased future from FutureRegistry
[13:36:27.036] result() for ClusterFuture ...
[13:36:27.036] - result already collected: FutureResult
[13:36:27.036] result() for ClusterFuture ... done
[13:36:27.036] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.037] result() for ClusterFuture ...
[13:36:27.037] - result already collected: FutureResult
[13:36:27.037] result() for ClusterFuture ... done
[13:36:27.037] result() for ClusterFuture ...
[13:36:27.037] - result already collected: FutureResult
[13:36:27.037] result() for ClusterFuture ... done
[13:36:27.038] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:36:27.038] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:36:27.038] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:36:27.038] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:36:27.039] MultisessionFuture started
[13:36:27.039] - Launch lazy future ... done
[13:36:27.039] run() for ‘MultisessionFuture’ ... done
[13:36:27.040] result() for ClusterFuture ...
[13:36:27.040] - result already collected: FutureResult
[13:36:27.040] result() for ClusterFuture ... done
[13:36:27.040] result() for ClusterFuture ...
[13:36:27.040] - result already collected: FutureResult
[13:36:27.040] result() for ClusterFuture ... done
[13:36:27.041] result() for ClusterFuture ...
[13:36:27.041] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.041] - Validating connection of MultisessionFuture
[13:36:27.041] - received message: FutureResult
[13:36:27.042] - Received FutureResult
[13:36:27.042] - Erased future from FutureRegistry
[13:36:27.042] result() for ClusterFuture ...
[13:36:27.042] - result already collected: FutureResult
[13:36:27.042] result() for ClusterFuture ... done
[13:36:27.042] signalConditions() ...
[13:36:27.042]  - include = ‘immediateCondition’
[13:36:27.042]  - exclude = 
[13:36:27.042]  - resignal = FALSE
[13:36:27.043]  - Number of conditions: 1
[13:36:27.043] signalConditions() ... done
[13:36:27.043] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.043] result() for ClusterFuture ... done
[13:36:27.043] result() for ClusterFuture ...
[13:36:27.043] - result already collected: FutureResult
[13:36:27.043] result() for ClusterFuture ... done
[13:36:27.043] signalConditions() ...
[13:36:27.043]  - include = ‘immediateCondition’
[13:36:27.043]  - exclude = 
[13:36:27.043]  - resignal = FALSE
[13:36:27.043]  - Number of conditions: 1
[13:36:27.044] signalConditions() ... done
[13:36:27.044] Future state: ‘finished’
[13:36:27.044] result() for ClusterFuture ...
[13:36:27.044] - result already collected: FutureResult
[13:36:27.044] result() for ClusterFuture ... done
[13:36:27.044] signalConditions() ...
[13:36:27.044]  - include = ‘condition’
[13:36:27.044]  - exclude = ‘immediateCondition’
[13:36:27.044]  - resignal = TRUE
[13:36:27.044]  - Number of conditions: 1
[13:36:27.044]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:27.045] signalConditions() ... done
[13:36:27.045] result() for ClusterFuture ...
[13:36:27.045] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.045] - Validating connection of MultisessionFuture
[13:36:27.045] - received message: FutureResult
[13:36:27.045] - Received FutureResult
[13:36:27.045] - Erased future from FutureRegistry
[13:36:27.046] result() for ClusterFuture ...
[13:36:27.046] - result already collected: FutureResult
[13:36:27.046] result() for ClusterFuture ... done
[13:36:27.046] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.046] result() for ClusterFuture ... done
[13:36:27.046] result() for ClusterFuture ...
[13:36:27.046] - result already collected: FutureResult
[13:36:27.046] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:36:27.047] result() for ClusterFuture ...
[13:36:27.047] - result already collected: FutureResult
[13:36:27.047] result() for ClusterFuture ... done
[13:36:27.047] result() for ClusterFuture ...
[13:36:27.047] - result already collected: FutureResult
[13:36:27.047] result() for ClusterFuture ... done
[13:36:27.047] signalConditions() ...
[13:36:27.047]  - include = ‘immediateCondition’
[13:36:27.047]  - exclude = 
[13:36:27.047]  - resignal = FALSE
[13:36:27.047]  - Number of conditions: 1
[13:36:27.048] signalConditions() ... done
[13:36:27.048] Future state: ‘finished’
[13:36:27.048] result() for ClusterFuture ...
[13:36:27.048] - result already collected: FutureResult
[13:36:27.048] result() for ClusterFuture ... done
[13:36:27.048] signalConditions() ...
[13:36:27.048]  - include = ‘condition’
[13:36:27.048]  - exclude = ‘immediateCondition’
[13:36:27.048]  - resignal = TRUE
[13:36:27.048]  - Number of conditions: 1
[13:36:27.048]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:27.049] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:36:27.049] result() for ClusterFuture ...
[13:36:27.049] - result already collected: FutureResult
[13:36:27.049] result() for ClusterFuture ... done
[13:36:27.049] result() for ClusterFuture ...
[13:36:27.049] - result already collected: FutureResult
[13:36:27.049] result() for ClusterFuture ... done
[13:36:27.049] signalConditions() ...
[13:36:27.049]  - include = ‘immediateCondition’
[13:36:27.050]  - exclude = 
[13:36:27.050]  - resignal = FALSE
[13:36:27.050]  - Number of conditions: 1
[13:36:27.050] signalConditions() ... done
[13:36:27.050] Future state: ‘finished’
[13:36:27.050] result() for ClusterFuture ...
[13:36:27.050] - result already collected: FutureResult
[13:36:27.050] result() for ClusterFuture ... done
[13:36:27.050] signalConditions() ...
[13:36:27.050]  - include = ‘condition’
[13:36:27.050]  - exclude = ‘immediateCondition’
[13:36:27.051]  - resignal = TRUE
[13:36:27.051]  - Number of conditions: 1
[13:36:27.051]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:27.051] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:36:27.051] getGlobalsAndPackages() ...
[13:36:27.051] Searching for globals...
[13:36:27.053] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:36:27.053] Searching for globals ... DONE
[13:36:27.053] Resolving globals: FALSE
[13:36:27.054] 
[13:36:27.054] 
[13:36:27.054] getGlobalsAndPackages() ... DONE
[13:36:27.054] run() for ‘Future’ ...
[13:36:27.054] - state: ‘created’
[13:36:27.054] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:27.068] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:27.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:27.068]   - Field: ‘node’
[13:36:27.069]   - Field: ‘label’
[13:36:27.069]   - Field: ‘local’
[13:36:27.069]   - Field: ‘owner’
[13:36:27.069]   - Field: ‘envir’
[13:36:27.069]   - Field: ‘workers’
[13:36:27.069]   - Field: ‘packages’
[13:36:27.069]   - Field: ‘gc’
[13:36:27.069]   - Field: ‘conditions’
[13:36:27.069]   - Field: ‘persistent’
[13:36:27.069]   - Field: ‘expr’
[13:36:27.069]   - Field: ‘uuid’
[13:36:27.070]   - Field: ‘seed’
[13:36:27.070]   - Field: ‘version’
[13:36:27.070]   - Field: ‘result’
[13:36:27.070]   - Field: ‘asynchronous’
[13:36:27.070]   - Field: ‘calls’
[13:36:27.070]   - Field: ‘globals’
[13:36:27.070]   - Field: ‘stdout’
[13:36:27.070]   - Field: ‘earlySignal’
[13:36:27.070]   - Field: ‘lazy’
[13:36:27.070]   - Field: ‘state’
[13:36:27.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:27.071] - Launch lazy future ...
[13:36:27.071] Packages needed by the future expression (n = 0): <none>
[13:36:27.071] Packages needed by future strategies (n = 0): <none>
[13:36:27.071] {
[13:36:27.071]     {
[13:36:27.071]         {
[13:36:27.071]             ...future.startTime <- base::Sys.time()
[13:36:27.071]             {
[13:36:27.071]                 {
[13:36:27.071]                   {
[13:36:27.071]                     {
[13:36:27.071]                       base::local({
[13:36:27.071]                         has_future <- base::requireNamespace("future", 
[13:36:27.071]                           quietly = TRUE)
[13:36:27.071]                         if (has_future) {
[13:36:27.071]                           ns <- base::getNamespace("future")
[13:36:27.071]                           version <- ns[[".package"]][["version"]]
[13:36:27.071]                           if (is.null(version)) 
[13:36:27.071]                             version <- utils::packageVersion("future")
[13:36:27.071]                         }
[13:36:27.071]                         else {
[13:36:27.071]                           version <- NULL
[13:36:27.071]                         }
[13:36:27.071]                         if (!has_future || version < "1.8.0") {
[13:36:27.071]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:27.071]                             "", base::R.version$version.string), 
[13:36:27.071]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:27.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:27.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:27.071]                               "release", "version")], collapse = " "), 
[13:36:27.071]                             hostname = base::Sys.info()[["nodename"]])
[13:36:27.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:27.071]                             info)
[13:36:27.071]                           info <- base::paste(info, collapse = "; ")
[13:36:27.071]                           if (!has_future) {
[13:36:27.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:27.071]                               info)
[13:36:27.071]                           }
[13:36:27.071]                           else {
[13:36:27.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:27.071]                               info, version)
[13:36:27.071]                           }
[13:36:27.071]                           base::stop(msg)
[13:36:27.071]                         }
[13:36:27.071]                       })
[13:36:27.071]                     }
[13:36:27.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:27.071]                     base::options(mc.cores = 1L)
[13:36:27.071]                   }
[13:36:27.071]                   ...future.strategy.old <- future::plan("list")
[13:36:27.071]                   options(future.plan = NULL)
[13:36:27.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:27.071]                 }
[13:36:27.071]                 ...future.workdir <- getwd()
[13:36:27.071]             }
[13:36:27.071]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:27.071]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:27.071]         }
[13:36:27.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:27.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:27.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:27.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:27.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:27.071]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:27.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:27.071]             base::names(...future.oldOptions))
[13:36:27.071]     }
[13:36:27.071]     if (FALSE) {
[13:36:27.071]     }
[13:36:27.071]     else {
[13:36:27.071]         if (TRUE) {
[13:36:27.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:27.071]                 open = "w")
[13:36:27.071]         }
[13:36:27.071]         else {
[13:36:27.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:27.071]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:27.071]         }
[13:36:27.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:27.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:27.071]             base::sink(type = "output", split = FALSE)
[13:36:27.071]             base::close(...future.stdout)
[13:36:27.071]         }, add = TRUE)
[13:36:27.071]     }
[13:36:27.071]     ...future.frame <- base::sys.nframe()
[13:36:27.071]     ...future.conditions <- base::list()
[13:36:27.071]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:27.071]     if (FALSE) {
[13:36:27.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:27.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:27.071]     }
[13:36:27.071]     ...future.result <- base::tryCatch({
[13:36:27.071]         base::withCallingHandlers({
[13:36:27.071]             ...future.value <- base::withVisible(base::local({
[13:36:27.071]                 ...future.makeSendCondition <- base::local({
[13:36:27.071]                   sendCondition <- NULL
[13:36:27.071]                   function(frame = 1L) {
[13:36:27.071]                     if (is.function(sendCondition)) 
[13:36:27.071]                       return(sendCondition)
[13:36:27.071]                     ns <- getNamespace("parallel")
[13:36:27.071]                     if (exists("sendData", mode = "function", 
[13:36:27.071]                       envir = ns)) {
[13:36:27.071]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:27.071]                         envir = ns)
[13:36:27.071]                       envir <- sys.frame(frame)
[13:36:27.071]                       master <- NULL
[13:36:27.071]                       while (!identical(envir, .GlobalEnv) && 
[13:36:27.071]                         !identical(envir, emptyenv())) {
[13:36:27.071]                         if (exists("master", mode = "list", envir = envir, 
[13:36:27.071]                           inherits = FALSE)) {
[13:36:27.071]                           master <- get("master", mode = "list", 
[13:36:27.071]                             envir = envir, inherits = FALSE)
[13:36:27.071]                           if (inherits(master, c("SOCKnode", 
[13:36:27.071]                             "SOCK0node"))) {
[13:36:27.071]                             sendCondition <<- function(cond) {
[13:36:27.071]                               data <- list(type = "VALUE", value = cond, 
[13:36:27.071]                                 success = TRUE)
[13:36:27.071]                               parallel_sendData(master, data)
[13:36:27.071]                             }
[13:36:27.071]                             return(sendCondition)
[13:36:27.071]                           }
[13:36:27.071]                         }
[13:36:27.071]                         frame <- frame + 1L
[13:36:27.071]                         envir <- sys.frame(frame)
[13:36:27.071]                       }
[13:36:27.071]                     }
[13:36:27.071]                     sendCondition <<- function(cond) NULL
[13:36:27.071]                   }
[13:36:27.071]                 })
[13:36:27.071]                 withCallingHandlers({
[13:36:27.071]                   {
[13:36:27.071]                     cat("Processing: ")
[13:36:27.071]                     for (ii in 1:10) {
[13:36:27.071]                       cat(".")
[13:36:27.071]                     }
[13:36:27.071]                     cat(" [100%]\n")
[13:36:27.071]                     4
[13:36:27.071]                   }
[13:36:27.071]                 }, immediateCondition = function(cond) {
[13:36:27.071]                   sendCondition <- ...future.makeSendCondition()
[13:36:27.071]                   sendCondition(cond)
[13:36:27.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.071]                   {
[13:36:27.071]                     inherits <- base::inherits
[13:36:27.071]                     invokeRestart <- base::invokeRestart
[13:36:27.071]                     is.null <- base::is.null
[13:36:27.071]                     muffled <- FALSE
[13:36:27.071]                     if (inherits(cond, "message")) {
[13:36:27.071]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:27.071]                       if (muffled) 
[13:36:27.071]                         invokeRestart("muffleMessage")
[13:36:27.071]                     }
[13:36:27.071]                     else if (inherits(cond, "warning")) {
[13:36:27.071]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:27.071]                       if (muffled) 
[13:36:27.071]                         invokeRestart("muffleWarning")
[13:36:27.071]                     }
[13:36:27.071]                     else if (inherits(cond, "condition")) {
[13:36:27.071]                       if (!is.null(pattern)) {
[13:36:27.071]                         computeRestarts <- base::computeRestarts
[13:36:27.071]                         grepl <- base::grepl
[13:36:27.071]                         restarts <- computeRestarts(cond)
[13:36:27.071]                         for (restart in restarts) {
[13:36:27.071]                           name <- restart$name
[13:36:27.071]                           if (is.null(name)) 
[13:36:27.071]                             next
[13:36:27.071]                           if (!grepl(pattern, name)) 
[13:36:27.071]                             next
[13:36:27.071]                           invokeRestart(restart)
[13:36:27.071]                           muffled <- TRUE
[13:36:27.071]                           break
[13:36:27.071]                         }
[13:36:27.071]                       }
[13:36:27.071]                     }
[13:36:27.071]                     invisible(muffled)
[13:36:27.071]                   }
[13:36:27.071]                   muffleCondition(cond)
[13:36:27.071]                 })
[13:36:27.071]             }))
[13:36:27.071]             future::FutureResult(value = ...future.value$value, 
[13:36:27.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.071]                   ...future.rng), globalenv = if (FALSE) 
[13:36:27.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:27.071]                     ...future.globalenv.names))
[13:36:27.071]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:27.071]         }, condition = base::local({
[13:36:27.071]             c <- base::c
[13:36:27.071]             inherits <- base::inherits
[13:36:27.071]             invokeRestart <- base::invokeRestart
[13:36:27.071]             length <- base::length
[13:36:27.071]             list <- base::list
[13:36:27.071]             seq.int <- base::seq.int
[13:36:27.071]             signalCondition <- base::signalCondition
[13:36:27.071]             sys.calls <- base::sys.calls
[13:36:27.071]             `[[` <- base::`[[`
[13:36:27.071]             `+` <- base::`+`
[13:36:27.071]             `<<-` <- base::`<<-`
[13:36:27.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:27.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:27.071]                   3L)]
[13:36:27.071]             }
[13:36:27.071]             function(cond) {
[13:36:27.071]                 is_error <- inherits(cond, "error")
[13:36:27.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:27.071]                   NULL)
[13:36:27.071]                 if (is_error) {
[13:36:27.071]                   sessionInformation <- function() {
[13:36:27.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:27.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:27.071]                       search = base::search(), system = base::Sys.info())
[13:36:27.071]                   }
[13:36:27.071]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:27.071]                     cond$call), session = sessionInformation(), 
[13:36:27.071]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:27.071]                   signalCondition(cond)
[13:36:27.071]                 }
[13:36:27.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:27.071]                 "immediateCondition"))) {
[13:36:27.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:27.071]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:27.071]                   if (TRUE && !signal) {
[13:36:27.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.071]                     {
[13:36:27.071]                       inherits <- base::inherits
[13:36:27.071]                       invokeRestart <- base::invokeRestart
[13:36:27.071]                       is.null <- base::is.null
[13:36:27.071]                       muffled <- FALSE
[13:36:27.071]                       if (inherits(cond, "message")) {
[13:36:27.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.071]                         if (muffled) 
[13:36:27.071]                           invokeRestart("muffleMessage")
[13:36:27.071]                       }
[13:36:27.071]                       else if (inherits(cond, "warning")) {
[13:36:27.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.071]                         if (muffled) 
[13:36:27.071]                           invokeRestart("muffleWarning")
[13:36:27.071]                       }
[13:36:27.071]                       else if (inherits(cond, "condition")) {
[13:36:27.071]                         if (!is.null(pattern)) {
[13:36:27.071]                           computeRestarts <- base::computeRestarts
[13:36:27.071]                           grepl <- base::grepl
[13:36:27.071]                           restarts <- computeRestarts(cond)
[13:36:27.071]                           for (restart in restarts) {
[13:36:27.071]                             name <- restart$name
[13:36:27.071]                             if (is.null(name)) 
[13:36:27.071]                               next
[13:36:27.071]                             if (!grepl(pattern, name)) 
[13:36:27.071]                               next
[13:36:27.071]                             invokeRestart(restart)
[13:36:27.071]                             muffled <- TRUE
[13:36:27.071]                             break
[13:36:27.071]                           }
[13:36:27.071]                         }
[13:36:27.071]                       }
[13:36:27.071]                       invisible(muffled)
[13:36:27.071]                     }
[13:36:27.071]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.071]                   }
[13:36:27.071]                 }
[13:36:27.071]                 else {
[13:36:27.071]                   if (TRUE) {
[13:36:27.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.071]                     {
[13:36:27.071]                       inherits <- base::inherits
[13:36:27.071]                       invokeRestart <- base::invokeRestart
[13:36:27.071]                       is.null <- base::is.null
[13:36:27.071]                       muffled <- FALSE
[13:36:27.071]                       if (inherits(cond, "message")) {
[13:36:27.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.071]                         if (muffled) 
[13:36:27.071]                           invokeRestart("muffleMessage")
[13:36:27.071]                       }
[13:36:27.071]                       else if (inherits(cond, "warning")) {
[13:36:27.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.071]                         if (muffled) 
[13:36:27.071]                           invokeRestart("muffleWarning")
[13:36:27.071]                       }
[13:36:27.071]                       else if (inherits(cond, "condition")) {
[13:36:27.071]                         if (!is.null(pattern)) {
[13:36:27.071]                           computeRestarts <- base::computeRestarts
[13:36:27.071]                           grepl <- base::grepl
[13:36:27.071]                           restarts <- computeRestarts(cond)
[13:36:27.071]                           for (restart in restarts) {
[13:36:27.071]                             name <- restart$name
[13:36:27.071]                             if (is.null(name)) 
[13:36:27.071]                               next
[13:36:27.071]                             if (!grepl(pattern, name)) 
[13:36:27.071]                               next
[13:36:27.071]                             invokeRestart(restart)
[13:36:27.071]                             muffled <- TRUE
[13:36:27.071]                             break
[13:36:27.071]                           }
[13:36:27.071]                         }
[13:36:27.071]                       }
[13:36:27.071]                       invisible(muffled)
[13:36:27.071]                     }
[13:36:27.071]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.071]                   }
[13:36:27.071]                 }
[13:36:27.071]             }
[13:36:27.071]         }))
[13:36:27.071]     }, error = function(ex) {
[13:36:27.071]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:27.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.071]                 ...future.rng), started = ...future.startTime, 
[13:36:27.071]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:27.071]             version = "1.8"), class = "FutureResult")
[13:36:27.071]     }, finally = {
[13:36:27.071]         if (!identical(...future.workdir, getwd())) 
[13:36:27.071]             setwd(...future.workdir)
[13:36:27.071]         {
[13:36:27.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:27.071]                 ...future.oldOptions$nwarnings <- NULL
[13:36:27.071]             }
[13:36:27.071]             base::options(...future.oldOptions)
[13:36:27.071]             if (.Platform$OS.type == "windows") {
[13:36:27.071]                 old_names <- names(...future.oldEnvVars)
[13:36:27.071]                 envs <- base::Sys.getenv()
[13:36:27.071]                 names <- names(envs)
[13:36:27.071]                 common <- intersect(names, old_names)
[13:36:27.071]                 added <- setdiff(names, old_names)
[13:36:27.071]                 removed <- setdiff(old_names, names)
[13:36:27.071]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:27.071]                   envs[common]]
[13:36:27.071]                 NAMES <- toupper(changed)
[13:36:27.071]                 args <- list()
[13:36:27.071]                 for (kk in seq_along(NAMES)) {
[13:36:27.071]                   name <- changed[[kk]]
[13:36:27.071]                   NAME <- NAMES[[kk]]
[13:36:27.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.071]                     next
[13:36:27.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.071]                 }
[13:36:27.071]                 NAMES <- toupper(added)
[13:36:27.071]                 for (kk in seq_along(NAMES)) {
[13:36:27.071]                   name <- added[[kk]]
[13:36:27.071]                   NAME <- NAMES[[kk]]
[13:36:27.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.071]                     next
[13:36:27.071]                   args[[name]] <- ""
[13:36:27.071]                 }
[13:36:27.071]                 NAMES <- toupper(removed)
[13:36:27.071]                 for (kk in seq_along(NAMES)) {
[13:36:27.071]                   name <- removed[[kk]]
[13:36:27.071]                   NAME <- NAMES[[kk]]
[13:36:27.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.071]                     next
[13:36:27.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.071]                 }
[13:36:27.071]                 if (length(args) > 0) 
[13:36:27.071]                   base::do.call(base::Sys.setenv, args = args)
[13:36:27.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:27.071]             }
[13:36:27.071]             else {
[13:36:27.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:27.071]             }
[13:36:27.071]             {
[13:36:27.071]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:27.071]                   0L) {
[13:36:27.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:27.071]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:27.071]                   base::options(opts)
[13:36:27.071]                 }
[13:36:27.071]                 {
[13:36:27.071]                   {
[13:36:27.071]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:27.071]                     NULL
[13:36:27.071]                   }
[13:36:27.071]                   options(future.plan = NULL)
[13:36:27.071]                   if (is.na(NA_character_)) 
[13:36:27.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:27.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:27.071]                     .init = FALSE)
[13:36:27.071]                 }
[13:36:27.071]             }
[13:36:27.071]         }
[13:36:27.071]     })
[13:36:27.071]     if (TRUE) {
[13:36:27.071]         base::sink(type = "output", split = FALSE)
[13:36:27.071]         if (TRUE) {
[13:36:27.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:27.071]         }
[13:36:27.071]         else {
[13:36:27.071]             ...future.result["stdout"] <- base::list(NULL)
[13:36:27.071]         }
[13:36:27.071]         base::close(...future.stdout)
[13:36:27.071]         ...future.stdout <- NULL
[13:36:27.071]     }
[13:36:27.071]     ...future.result$conditions <- ...future.conditions
[13:36:27.071]     ...future.result$finished <- base::Sys.time()
[13:36:27.071]     ...future.result
[13:36:27.071] }
[13:36:27.074] MultisessionFuture started
[13:36:27.074] - Launch lazy future ... done
[13:36:27.075] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:36:27.075] result() for ClusterFuture ...
[13:36:27.075] - result already collected: FutureResult
[13:36:27.075] result() for ClusterFuture ... done
[13:36:27.076] result() for ClusterFuture ...
[13:36:27.076] - result already collected: FutureResult
[13:36:27.076] result() for ClusterFuture ... done
[13:36:27.076] signalConditions() ...
[13:36:27.076]  - include = ‘immediateCondition’
[13:36:27.076]  - exclude = 
[13:36:27.076]  - resignal = FALSE
[13:36:27.077]  - Number of conditions: 1
[13:36:27.077] signalConditions() ... done
[13:36:27.077] Future state: ‘finished’
[13:36:27.077] result() for ClusterFuture ...
[13:36:27.077] - result already collected: FutureResult
[13:36:27.077] result() for ClusterFuture ... done
[13:36:27.077] signalConditions() ...
[13:36:27.077]  - include = ‘condition’
[13:36:27.077]  - exclude = ‘immediateCondition’
[13:36:27.077]  - resignal = TRUE
[13:36:27.078]  - Number of conditions: 1
[13:36:27.078]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:36:27.078] signalConditions() ... done
v3: <simpleError> (as expect)
[13:36:27.078] result() for ClusterFuture ...
[13:36:27.078] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.078] - Validating connection of MultisessionFuture
[13:36:27.078] - received message: FutureResult
[13:36:27.078] - Received FutureResult
[13:36:27.079] - Erased future from FutureRegistry
[13:36:27.079] result() for ClusterFuture ...
[13:36:27.079] - result already collected: FutureResult
[13:36:27.079] result() for ClusterFuture ... done
[13:36:27.079] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.079] result() for ClusterFuture ... done
[13:36:27.079] result() for ClusterFuture ...
[13:36:27.079] - result already collected: FutureResult
[13:36:27.079] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:36:27.080] getGlobalsAndPackages() ...
[13:36:27.080] Searching for globals...
[13:36:27.080] 
[13:36:27.080] Searching for globals ... DONE
[13:36:27.080] - globals: [0] <none>
[13:36:27.080] getGlobalsAndPackages() ... DONE
[13:36:27.080] run() for ‘Future’ ...
[13:36:27.081] - state: ‘created’
[13:36:27.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:27.094] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:27.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:27.094]   - Field: ‘node’
[13:36:27.094]   - Field: ‘label’
[13:36:27.095]   - Field: ‘local’
[13:36:27.095]   - Field: ‘owner’
[13:36:27.095]   - Field: ‘envir’
[13:36:27.095]   - Field: ‘workers’
[13:36:27.095]   - Field: ‘packages’
[13:36:27.095]   - Field: ‘gc’
[13:36:27.095]   - Field: ‘conditions’
[13:36:27.095]   - Field: ‘persistent’
[13:36:27.095]   - Field: ‘expr’
[13:36:27.095]   - Field: ‘uuid’
[13:36:27.095]   - Field: ‘seed’
[13:36:27.096]   - Field: ‘version’
[13:36:27.096]   - Field: ‘result’
[13:36:27.096]   - Field: ‘asynchronous’
[13:36:27.096]   - Field: ‘calls’
[13:36:27.096]   - Field: ‘globals’
[13:36:27.096]   - Field: ‘stdout’
[13:36:27.096]   - Field: ‘earlySignal’
[13:36:27.096]   - Field: ‘lazy’
[13:36:27.096]   - Field: ‘state’
[13:36:27.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:27.096] - Launch lazy future ...
[13:36:27.097] Packages needed by the future expression (n = 0): <none>
[13:36:27.097] Packages needed by future strategies (n = 0): <none>
[13:36:27.099] {
[13:36:27.099]     {
[13:36:27.099]         {
[13:36:27.099]             ...future.startTime <- base::Sys.time()
[13:36:27.099]             {
[13:36:27.099]                 {
[13:36:27.099]                   {
[13:36:27.099]                     {
[13:36:27.099]                       base::local({
[13:36:27.099]                         has_future <- base::requireNamespace("future", 
[13:36:27.099]                           quietly = TRUE)
[13:36:27.099]                         if (has_future) {
[13:36:27.099]                           ns <- base::getNamespace("future")
[13:36:27.099]                           version <- ns[[".package"]][["version"]]
[13:36:27.099]                           if (is.null(version)) 
[13:36:27.099]                             version <- utils::packageVersion("future")
[13:36:27.099]                         }
[13:36:27.099]                         else {
[13:36:27.099]                           version <- NULL
[13:36:27.099]                         }
[13:36:27.099]                         if (!has_future || version < "1.8.0") {
[13:36:27.099]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:27.099]                             "", base::R.version$version.string), 
[13:36:27.099]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:27.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:27.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:27.099]                               "release", "version")], collapse = " "), 
[13:36:27.099]                             hostname = base::Sys.info()[["nodename"]])
[13:36:27.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:27.099]                             info)
[13:36:27.099]                           info <- base::paste(info, collapse = "; ")
[13:36:27.099]                           if (!has_future) {
[13:36:27.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:27.099]                               info)
[13:36:27.099]                           }
[13:36:27.099]                           else {
[13:36:27.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:27.099]                               info, version)
[13:36:27.099]                           }
[13:36:27.099]                           base::stop(msg)
[13:36:27.099]                         }
[13:36:27.099]                       })
[13:36:27.099]                     }
[13:36:27.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:27.099]                     base::options(mc.cores = 1L)
[13:36:27.099]                   }
[13:36:27.099]                   ...future.strategy.old <- future::plan("list")
[13:36:27.099]                   options(future.plan = NULL)
[13:36:27.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:27.099]                 }
[13:36:27.099]                 ...future.workdir <- getwd()
[13:36:27.099]             }
[13:36:27.099]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:27.099]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:27.099]         }
[13:36:27.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:27.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:27.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:27.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:27.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:27.099]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:27.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:27.099]             base::names(...future.oldOptions))
[13:36:27.099]     }
[13:36:27.099]     if (FALSE) {
[13:36:27.099]     }
[13:36:27.099]     else {
[13:36:27.099]         if (TRUE) {
[13:36:27.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:27.099]                 open = "w")
[13:36:27.099]         }
[13:36:27.099]         else {
[13:36:27.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:27.099]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:27.099]         }
[13:36:27.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:27.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:27.099]             base::sink(type = "output", split = FALSE)
[13:36:27.099]             base::close(...future.stdout)
[13:36:27.099]         }, add = TRUE)
[13:36:27.099]     }
[13:36:27.099]     ...future.frame <- base::sys.nframe()
[13:36:27.099]     ...future.conditions <- base::list()
[13:36:27.099]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:27.099]     if (FALSE) {
[13:36:27.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:27.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:27.099]     }
[13:36:27.099]     ...future.result <- base::tryCatch({
[13:36:27.099]         base::withCallingHandlers({
[13:36:27.099]             ...future.value <- base::withVisible(base::local({
[13:36:27.099]                 ...future.makeSendCondition <- base::local({
[13:36:27.099]                   sendCondition <- NULL
[13:36:27.099]                   function(frame = 1L) {
[13:36:27.099]                     if (is.function(sendCondition)) 
[13:36:27.099]                       return(sendCondition)
[13:36:27.099]                     ns <- getNamespace("parallel")
[13:36:27.099]                     if (exists("sendData", mode = "function", 
[13:36:27.099]                       envir = ns)) {
[13:36:27.099]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:27.099]                         envir = ns)
[13:36:27.099]                       envir <- sys.frame(frame)
[13:36:27.099]                       master <- NULL
[13:36:27.099]                       while (!identical(envir, .GlobalEnv) && 
[13:36:27.099]                         !identical(envir, emptyenv())) {
[13:36:27.099]                         if (exists("master", mode = "list", envir = envir, 
[13:36:27.099]                           inherits = FALSE)) {
[13:36:27.099]                           master <- get("master", mode = "list", 
[13:36:27.099]                             envir = envir, inherits = FALSE)
[13:36:27.099]                           if (inherits(master, c("SOCKnode", 
[13:36:27.099]                             "SOCK0node"))) {
[13:36:27.099]                             sendCondition <<- function(cond) {
[13:36:27.099]                               data <- list(type = "VALUE", value = cond, 
[13:36:27.099]                                 success = TRUE)
[13:36:27.099]                               parallel_sendData(master, data)
[13:36:27.099]                             }
[13:36:27.099]                             return(sendCondition)
[13:36:27.099]                           }
[13:36:27.099]                         }
[13:36:27.099]                         frame <- frame + 1L
[13:36:27.099]                         envir <- sys.frame(frame)
[13:36:27.099]                       }
[13:36:27.099]                     }
[13:36:27.099]                     sendCondition <<- function(cond) NULL
[13:36:27.099]                   }
[13:36:27.099]                 })
[13:36:27.099]                 withCallingHandlers({
[13:36:27.099]                   1
[13:36:27.099]                 }, immediateCondition = function(cond) {
[13:36:27.099]                   sendCondition <- ...future.makeSendCondition()
[13:36:27.099]                   sendCondition(cond)
[13:36:27.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.099]                   {
[13:36:27.099]                     inherits <- base::inherits
[13:36:27.099]                     invokeRestart <- base::invokeRestart
[13:36:27.099]                     is.null <- base::is.null
[13:36:27.099]                     muffled <- FALSE
[13:36:27.099]                     if (inherits(cond, "message")) {
[13:36:27.099]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:27.099]                       if (muffled) 
[13:36:27.099]                         invokeRestart("muffleMessage")
[13:36:27.099]                     }
[13:36:27.099]                     else if (inherits(cond, "warning")) {
[13:36:27.099]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:27.099]                       if (muffled) 
[13:36:27.099]                         invokeRestart("muffleWarning")
[13:36:27.099]                     }
[13:36:27.099]                     else if (inherits(cond, "condition")) {
[13:36:27.099]                       if (!is.null(pattern)) {
[13:36:27.099]                         computeRestarts <- base::computeRestarts
[13:36:27.099]                         grepl <- base::grepl
[13:36:27.099]                         restarts <- computeRestarts(cond)
[13:36:27.099]                         for (restart in restarts) {
[13:36:27.099]                           name <- restart$name
[13:36:27.099]                           if (is.null(name)) 
[13:36:27.099]                             next
[13:36:27.099]                           if (!grepl(pattern, name)) 
[13:36:27.099]                             next
[13:36:27.099]                           invokeRestart(restart)
[13:36:27.099]                           muffled <- TRUE
[13:36:27.099]                           break
[13:36:27.099]                         }
[13:36:27.099]                       }
[13:36:27.099]                     }
[13:36:27.099]                     invisible(muffled)
[13:36:27.099]                   }
[13:36:27.099]                   muffleCondition(cond)
[13:36:27.099]                 })
[13:36:27.099]             }))
[13:36:27.099]             future::FutureResult(value = ...future.value$value, 
[13:36:27.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.099]                   ...future.rng), globalenv = if (FALSE) 
[13:36:27.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:27.099]                     ...future.globalenv.names))
[13:36:27.099]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:27.099]         }, condition = base::local({
[13:36:27.099]             c <- base::c
[13:36:27.099]             inherits <- base::inherits
[13:36:27.099]             invokeRestart <- base::invokeRestart
[13:36:27.099]             length <- base::length
[13:36:27.099]             list <- base::list
[13:36:27.099]             seq.int <- base::seq.int
[13:36:27.099]             signalCondition <- base::signalCondition
[13:36:27.099]             sys.calls <- base::sys.calls
[13:36:27.099]             `[[` <- base::`[[`
[13:36:27.099]             `+` <- base::`+`
[13:36:27.099]             `<<-` <- base::`<<-`
[13:36:27.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:27.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:27.099]                   3L)]
[13:36:27.099]             }
[13:36:27.099]             function(cond) {
[13:36:27.099]                 is_error <- inherits(cond, "error")
[13:36:27.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:27.099]                   NULL)
[13:36:27.099]                 if (is_error) {
[13:36:27.099]                   sessionInformation <- function() {
[13:36:27.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:27.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:27.099]                       search = base::search(), system = base::Sys.info())
[13:36:27.099]                   }
[13:36:27.099]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:27.099]                     cond$call), session = sessionInformation(), 
[13:36:27.099]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:27.099]                   signalCondition(cond)
[13:36:27.099]                 }
[13:36:27.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:27.099]                 "immediateCondition"))) {
[13:36:27.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:27.099]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:27.099]                   if (TRUE && !signal) {
[13:36:27.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.099]                     {
[13:36:27.099]                       inherits <- base::inherits
[13:36:27.099]                       invokeRestart <- base::invokeRestart
[13:36:27.099]                       is.null <- base::is.null
[13:36:27.099]                       muffled <- FALSE
[13:36:27.099]                       if (inherits(cond, "message")) {
[13:36:27.099]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.099]                         if (muffled) 
[13:36:27.099]                           invokeRestart("muffleMessage")
[13:36:27.099]                       }
[13:36:27.099]                       else if (inherits(cond, "warning")) {
[13:36:27.099]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.099]                         if (muffled) 
[13:36:27.099]                           invokeRestart("muffleWarning")
[13:36:27.099]                       }
[13:36:27.099]                       else if (inherits(cond, "condition")) {
[13:36:27.099]                         if (!is.null(pattern)) {
[13:36:27.099]                           computeRestarts <- base::computeRestarts
[13:36:27.099]                           grepl <- base::grepl
[13:36:27.099]                           restarts <- computeRestarts(cond)
[13:36:27.099]                           for (restart in restarts) {
[13:36:27.099]                             name <- restart$name
[13:36:27.099]                             if (is.null(name)) 
[13:36:27.099]                               next
[13:36:27.099]                             if (!grepl(pattern, name)) 
[13:36:27.099]                               next
[13:36:27.099]                             invokeRestart(restart)
[13:36:27.099]                             muffled <- TRUE
[13:36:27.099]                             break
[13:36:27.099]                           }
[13:36:27.099]                         }
[13:36:27.099]                       }
[13:36:27.099]                       invisible(muffled)
[13:36:27.099]                     }
[13:36:27.099]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.099]                   }
[13:36:27.099]                 }
[13:36:27.099]                 else {
[13:36:27.099]                   if (TRUE) {
[13:36:27.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.099]                     {
[13:36:27.099]                       inherits <- base::inherits
[13:36:27.099]                       invokeRestart <- base::invokeRestart
[13:36:27.099]                       is.null <- base::is.null
[13:36:27.099]                       muffled <- FALSE
[13:36:27.099]                       if (inherits(cond, "message")) {
[13:36:27.099]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.099]                         if (muffled) 
[13:36:27.099]                           invokeRestart("muffleMessage")
[13:36:27.099]                       }
[13:36:27.099]                       else if (inherits(cond, "warning")) {
[13:36:27.099]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.099]                         if (muffled) 
[13:36:27.099]                           invokeRestart("muffleWarning")
[13:36:27.099]                       }
[13:36:27.099]                       else if (inherits(cond, "condition")) {
[13:36:27.099]                         if (!is.null(pattern)) {
[13:36:27.099]                           computeRestarts <- base::computeRestarts
[13:36:27.099]                           grepl <- base::grepl
[13:36:27.099]                           restarts <- computeRestarts(cond)
[13:36:27.099]                           for (restart in restarts) {
[13:36:27.099]                             name <- restart$name
[13:36:27.099]                             if (is.null(name)) 
[13:36:27.099]                               next
[13:36:27.099]                             if (!grepl(pattern, name)) 
[13:36:27.099]                               next
[13:36:27.099]                             invokeRestart(restart)
[13:36:27.099]                             muffled <- TRUE
[13:36:27.099]                             break
[13:36:27.099]                           }
[13:36:27.099]                         }
[13:36:27.099]                       }
[13:36:27.099]                       invisible(muffled)
[13:36:27.099]                     }
[13:36:27.099]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.099]                   }
[13:36:27.099]                 }
[13:36:27.099]             }
[13:36:27.099]         }))
[13:36:27.099]     }, error = function(ex) {
[13:36:27.099]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:27.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.099]                 ...future.rng), started = ...future.startTime, 
[13:36:27.099]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:27.099]             version = "1.8"), class = "FutureResult")
[13:36:27.099]     }, finally = {
[13:36:27.099]         if (!identical(...future.workdir, getwd())) 
[13:36:27.099]             setwd(...future.workdir)
[13:36:27.099]         {
[13:36:27.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:27.099]                 ...future.oldOptions$nwarnings <- NULL
[13:36:27.099]             }
[13:36:27.099]             base::options(...future.oldOptions)
[13:36:27.099]             if (.Platform$OS.type == "windows") {
[13:36:27.099]                 old_names <- names(...future.oldEnvVars)
[13:36:27.099]                 envs <- base::Sys.getenv()
[13:36:27.099]                 names <- names(envs)
[13:36:27.099]                 common <- intersect(names, old_names)
[13:36:27.099]                 added <- setdiff(names, old_names)
[13:36:27.099]                 removed <- setdiff(old_names, names)
[13:36:27.099]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:27.099]                   envs[common]]
[13:36:27.099]                 NAMES <- toupper(changed)
[13:36:27.099]                 args <- list()
[13:36:27.099]                 for (kk in seq_along(NAMES)) {
[13:36:27.099]                   name <- changed[[kk]]
[13:36:27.099]                   NAME <- NAMES[[kk]]
[13:36:27.099]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.099]                     next
[13:36:27.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.099]                 }
[13:36:27.099]                 NAMES <- toupper(added)
[13:36:27.099]                 for (kk in seq_along(NAMES)) {
[13:36:27.099]                   name <- added[[kk]]
[13:36:27.099]                   NAME <- NAMES[[kk]]
[13:36:27.099]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.099]                     next
[13:36:27.099]                   args[[name]] <- ""
[13:36:27.099]                 }
[13:36:27.099]                 NAMES <- toupper(removed)
[13:36:27.099]                 for (kk in seq_along(NAMES)) {
[13:36:27.099]                   name <- removed[[kk]]
[13:36:27.099]                   NAME <- NAMES[[kk]]
[13:36:27.099]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.099]                     next
[13:36:27.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.099]                 }
[13:36:27.099]                 if (length(args) > 0) 
[13:36:27.099]                   base::do.call(base::Sys.setenv, args = args)
[13:36:27.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:27.099]             }
[13:36:27.099]             else {
[13:36:27.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:27.099]             }
[13:36:27.099]             {
[13:36:27.099]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:27.099]                   0L) {
[13:36:27.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:27.099]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:27.099]                   base::options(opts)
[13:36:27.099]                 }
[13:36:27.099]                 {
[13:36:27.099]                   {
[13:36:27.099]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:27.099]                     NULL
[13:36:27.099]                   }
[13:36:27.099]                   options(future.plan = NULL)
[13:36:27.099]                   if (is.na(NA_character_)) 
[13:36:27.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:27.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:27.099]                     .init = FALSE)
[13:36:27.099]                 }
[13:36:27.099]             }
[13:36:27.099]         }
[13:36:27.099]     })
[13:36:27.099]     if (TRUE) {
[13:36:27.099]         base::sink(type = "output", split = FALSE)
[13:36:27.099]         if (TRUE) {
[13:36:27.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:27.099]         }
[13:36:27.099]         else {
[13:36:27.099]             ...future.result["stdout"] <- base::list(NULL)
[13:36:27.099]         }
[13:36:27.099]         base::close(...future.stdout)
[13:36:27.099]         ...future.stdout <- NULL
[13:36:27.099]     }
[13:36:27.099]     ...future.result$conditions <- ...future.conditions
[13:36:27.099]     ...future.result$finished <- base::Sys.time()
[13:36:27.099]     ...future.result
[13:36:27.099] }
[13:36:27.102] MultisessionFuture started
[13:36:27.102] - Launch lazy future ... done
[13:36:27.103] run() for ‘MultisessionFuture’ ... done
[13:36:27.103] result() for ClusterFuture ...
[13:36:27.103] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.103] - Validating connection of MultisessionFuture
[13:36:27.104] - received message: FutureResult
[13:36:27.104] - Received FutureResult
[13:36:27.104] - Erased future from FutureRegistry
[13:36:27.105] result() for ClusterFuture ...
[13:36:27.105] - result already collected: FutureResult
[13:36:27.105] result() for ClusterFuture ... done
[13:36:27.105] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.105] result() for ClusterFuture ... done
[13:36:27.105] result() for ClusterFuture ...
[13:36:27.105] - result already collected: FutureResult
[13:36:27.105] result() for ClusterFuture ... done
c = 1
[13:36:27.105] getGlobalsAndPackages() ...
[13:36:27.106] Searching for globals...
[13:36:27.106] 
[13:36:27.106] Searching for globals ... DONE
[13:36:27.106] - globals: [0] <none>
[13:36:27.106] getGlobalsAndPackages() ... DONE
[13:36:27.106] run() for ‘Future’ ...
[13:36:27.106] - state: ‘created’
[13:36:27.107] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:27.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:27.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:27.120]   - Field: ‘node’
[13:36:27.120]   - Field: ‘label’
[13:36:27.120]   - Field: ‘local’
[13:36:27.120]   - Field: ‘owner’
[13:36:27.120]   - Field: ‘envir’
[13:36:27.121]   - Field: ‘workers’
[13:36:27.121]   - Field: ‘packages’
[13:36:27.121]   - Field: ‘gc’
[13:36:27.121]   - Field: ‘conditions’
[13:36:27.121]   - Field: ‘persistent’
[13:36:27.121]   - Field: ‘expr’
[13:36:27.121]   - Field: ‘uuid’
[13:36:27.121]   - Field: ‘seed’
[13:36:27.121]   - Field: ‘version’
[13:36:27.121]   - Field: ‘result’
[13:36:27.121]   - Field: ‘asynchronous’
[13:36:27.122]   - Field: ‘calls’
[13:36:27.122]   - Field: ‘globals’
[13:36:27.122]   - Field: ‘stdout’
[13:36:27.122]   - Field: ‘earlySignal’
[13:36:27.122]   - Field: ‘lazy’
[13:36:27.122]   - Field: ‘state’
[13:36:27.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:27.122] - Launch lazy future ...
[13:36:27.122] Packages needed by the future expression (n = 0): <none>
[13:36:27.123] Packages needed by future strategies (n = 0): <none>
[13:36:27.123] {
[13:36:27.123]     {
[13:36:27.123]         {
[13:36:27.123]             ...future.startTime <- base::Sys.time()
[13:36:27.123]             {
[13:36:27.123]                 {
[13:36:27.123]                   {
[13:36:27.123]                     {
[13:36:27.123]                       base::local({
[13:36:27.123]                         has_future <- base::requireNamespace("future", 
[13:36:27.123]                           quietly = TRUE)
[13:36:27.123]                         if (has_future) {
[13:36:27.123]                           ns <- base::getNamespace("future")
[13:36:27.123]                           version <- ns[[".package"]][["version"]]
[13:36:27.123]                           if (is.null(version)) 
[13:36:27.123]                             version <- utils::packageVersion("future")
[13:36:27.123]                         }
[13:36:27.123]                         else {
[13:36:27.123]                           version <- NULL
[13:36:27.123]                         }
[13:36:27.123]                         if (!has_future || version < "1.8.0") {
[13:36:27.123]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:27.123]                             "", base::R.version$version.string), 
[13:36:27.123]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:27.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:27.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:27.123]                               "release", "version")], collapse = " "), 
[13:36:27.123]                             hostname = base::Sys.info()[["nodename"]])
[13:36:27.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:27.123]                             info)
[13:36:27.123]                           info <- base::paste(info, collapse = "; ")
[13:36:27.123]                           if (!has_future) {
[13:36:27.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:27.123]                               info)
[13:36:27.123]                           }
[13:36:27.123]                           else {
[13:36:27.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:27.123]                               info, version)
[13:36:27.123]                           }
[13:36:27.123]                           base::stop(msg)
[13:36:27.123]                         }
[13:36:27.123]                       })
[13:36:27.123]                     }
[13:36:27.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:27.123]                     base::options(mc.cores = 1L)
[13:36:27.123]                   }
[13:36:27.123]                   ...future.strategy.old <- future::plan("list")
[13:36:27.123]                   options(future.plan = NULL)
[13:36:27.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:27.123]                 }
[13:36:27.123]                 ...future.workdir <- getwd()
[13:36:27.123]             }
[13:36:27.123]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:27.123]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:27.123]         }
[13:36:27.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:27.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:27.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:27.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:27.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:27.123]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:27.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:27.123]             base::names(...future.oldOptions))
[13:36:27.123]     }
[13:36:27.123]     if (FALSE) {
[13:36:27.123]     }
[13:36:27.123]     else {
[13:36:27.123]         if (TRUE) {
[13:36:27.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:27.123]                 open = "w")
[13:36:27.123]         }
[13:36:27.123]         else {
[13:36:27.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:27.123]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:27.123]         }
[13:36:27.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:27.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:27.123]             base::sink(type = "output", split = FALSE)
[13:36:27.123]             base::close(...future.stdout)
[13:36:27.123]         }, add = TRUE)
[13:36:27.123]     }
[13:36:27.123]     ...future.frame <- base::sys.nframe()
[13:36:27.123]     ...future.conditions <- base::list()
[13:36:27.123]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:27.123]     if (FALSE) {
[13:36:27.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:27.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:27.123]     }
[13:36:27.123]     ...future.result <- base::tryCatch({
[13:36:27.123]         base::withCallingHandlers({
[13:36:27.123]             ...future.value <- base::withVisible(base::local({
[13:36:27.123]                 ...future.makeSendCondition <- base::local({
[13:36:27.123]                   sendCondition <- NULL
[13:36:27.123]                   function(frame = 1L) {
[13:36:27.123]                     if (is.function(sendCondition)) 
[13:36:27.123]                       return(sendCondition)
[13:36:27.123]                     ns <- getNamespace("parallel")
[13:36:27.123]                     if (exists("sendData", mode = "function", 
[13:36:27.123]                       envir = ns)) {
[13:36:27.123]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:27.123]                         envir = ns)
[13:36:27.123]                       envir <- sys.frame(frame)
[13:36:27.123]                       master <- NULL
[13:36:27.123]                       while (!identical(envir, .GlobalEnv) && 
[13:36:27.123]                         !identical(envir, emptyenv())) {
[13:36:27.123]                         if (exists("master", mode = "list", envir = envir, 
[13:36:27.123]                           inherits = FALSE)) {
[13:36:27.123]                           master <- get("master", mode = "list", 
[13:36:27.123]                             envir = envir, inherits = FALSE)
[13:36:27.123]                           if (inherits(master, c("SOCKnode", 
[13:36:27.123]                             "SOCK0node"))) {
[13:36:27.123]                             sendCondition <<- function(cond) {
[13:36:27.123]                               data <- list(type = "VALUE", value = cond, 
[13:36:27.123]                                 success = TRUE)
[13:36:27.123]                               parallel_sendData(master, data)
[13:36:27.123]                             }
[13:36:27.123]                             return(sendCondition)
[13:36:27.123]                           }
[13:36:27.123]                         }
[13:36:27.123]                         frame <- frame + 1L
[13:36:27.123]                         envir <- sys.frame(frame)
[13:36:27.123]                       }
[13:36:27.123]                     }
[13:36:27.123]                     sendCondition <<- function(cond) NULL
[13:36:27.123]                   }
[13:36:27.123]                 })
[13:36:27.123]                 withCallingHandlers({
[13:36:27.123]                   1
[13:36:27.123]                 }, immediateCondition = function(cond) {
[13:36:27.123]                   sendCondition <- ...future.makeSendCondition()
[13:36:27.123]                   sendCondition(cond)
[13:36:27.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.123]                   {
[13:36:27.123]                     inherits <- base::inherits
[13:36:27.123]                     invokeRestart <- base::invokeRestart
[13:36:27.123]                     is.null <- base::is.null
[13:36:27.123]                     muffled <- FALSE
[13:36:27.123]                     if (inherits(cond, "message")) {
[13:36:27.123]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:27.123]                       if (muffled) 
[13:36:27.123]                         invokeRestart("muffleMessage")
[13:36:27.123]                     }
[13:36:27.123]                     else if (inherits(cond, "warning")) {
[13:36:27.123]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:27.123]                       if (muffled) 
[13:36:27.123]                         invokeRestart("muffleWarning")
[13:36:27.123]                     }
[13:36:27.123]                     else if (inherits(cond, "condition")) {
[13:36:27.123]                       if (!is.null(pattern)) {
[13:36:27.123]                         computeRestarts <- base::computeRestarts
[13:36:27.123]                         grepl <- base::grepl
[13:36:27.123]                         restarts <- computeRestarts(cond)
[13:36:27.123]                         for (restart in restarts) {
[13:36:27.123]                           name <- restart$name
[13:36:27.123]                           if (is.null(name)) 
[13:36:27.123]                             next
[13:36:27.123]                           if (!grepl(pattern, name)) 
[13:36:27.123]                             next
[13:36:27.123]                           invokeRestart(restart)
[13:36:27.123]                           muffled <- TRUE
[13:36:27.123]                           break
[13:36:27.123]                         }
[13:36:27.123]                       }
[13:36:27.123]                     }
[13:36:27.123]                     invisible(muffled)
[13:36:27.123]                   }
[13:36:27.123]                   muffleCondition(cond)
[13:36:27.123]                 })
[13:36:27.123]             }))
[13:36:27.123]             future::FutureResult(value = ...future.value$value, 
[13:36:27.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.123]                   ...future.rng), globalenv = if (FALSE) 
[13:36:27.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:27.123]                     ...future.globalenv.names))
[13:36:27.123]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:27.123]         }, condition = base::local({
[13:36:27.123]             c <- base::c
[13:36:27.123]             inherits <- base::inherits
[13:36:27.123]             invokeRestart <- base::invokeRestart
[13:36:27.123]             length <- base::length
[13:36:27.123]             list <- base::list
[13:36:27.123]             seq.int <- base::seq.int
[13:36:27.123]             signalCondition <- base::signalCondition
[13:36:27.123]             sys.calls <- base::sys.calls
[13:36:27.123]             `[[` <- base::`[[`
[13:36:27.123]             `+` <- base::`+`
[13:36:27.123]             `<<-` <- base::`<<-`
[13:36:27.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:27.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:27.123]                   3L)]
[13:36:27.123]             }
[13:36:27.123]             function(cond) {
[13:36:27.123]                 is_error <- inherits(cond, "error")
[13:36:27.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:27.123]                   NULL)
[13:36:27.123]                 if (is_error) {
[13:36:27.123]                   sessionInformation <- function() {
[13:36:27.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:27.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:27.123]                       search = base::search(), system = base::Sys.info())
[13:36:27.123]                   }
[13:36:27.123]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:27.123]                     cond$call), session = sessionInformation(), 
[13:36:27.123]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:27.123]                   signalCondition(cond)
[13:36:27.123]                 }
[13:36:27.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:27.123]                 "immediateCondition"))) {
[13:36:27.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:27.123]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:27.123]                   if (TRUE && !signal) {
[13:36:27.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.123]                     {
[13:36:27.123]                       inherits <- base::inherits
[13:36:27.123]                       invokeRestart <- base::invokeRestart
[13:36:27.123]                       is.null <- base::is.null
[13:36:27.123]                       muffled <- FALSE
[13:36:27.123]                       if (inherits(cond, "message")) {
[13:36:27.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.123]                         if (muffled) 
[13:36:27.123]                           invokeRestart("muffleMessage")
[13:36:27.123]                       }
[13:36:27.123]                       else if (inherits(cond, "warning")) {
[13:36:27.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.123]                         if (muffled) 
[13:36:27.123]                           invokeRestart("muffleWarning")
[13:36:27.123]                       }
[13:36:27.123]                       else if (inherits(cond, "condition")) {
[13:36:27.123]                         if (!is.null(pattern)) {
[13:36:27.123]                           computeRestarts <- base::computeRestarts
[13:36:27.123]                           grepl <- base::grepl
[13:36:27.123]                           restarts <- computeRestarts(cond)
[13:36:27.123]                           for (restart in restarts) {
[13:36:27.123]                             name <- restart$name
[13:36:27.123]                             if (is.null(name)) 
[13:36:27.123]                               next
[13:36:27.123]                             if (!grepl(pattern, name)) 
[13:36:27.123]                               next
[13:36:27.123]                             invokeRestart(restart)
[13:36:27.123]                             muffled <- TRUE
[13:36:27.123]                             break
[13:36:27.123]                           }
[13:36:27.123]                         }
[13:36:27.123]                       }
[13:36:27.123]                       invisible(muffled)
[13:36:27.123]                     }
[13:36:27.123]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.123]                   }
[13:36:27.123]                 }
[13:36:27.123]                 else {
[13:36:27.123]                   if (TRUE) {
[13:36:27.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.123]                     {
[13:36:27.123]                       inherits <- base::inherits
[13:36:27.123]                       invokeRestart <- base::invokeRestart
[13:36:27.123]                       is.null <- base::is.null
[13:36:27.123]                       muffled <- FALSE
[13:36:27.123]                       if (inherits(cond, "message")) {
[13:36:27.123]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.123]                         if (muffled) 
[13:36:27.123]                           invokeRestart("muffleMessage")
[13:36:27.123]                       }
[13:36:27.123]                       else if (inherits(cond, "warning")) {
[13:36:27.123]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.123]                         if (muffled) 
[13:36:27.123]                           invokeRestart("muffleWarning")
[13:36:27.123]                       }
[13:36:27.123]                       else if (inherits(cond, "condition")) {
[13:36:27.123]                         if (!is.null(pattern)) {
[13:36:27.123]                           computeRestarts <- base::computeRestarts
[13:36:27.123]                           grepl <- base::grepl
[13:36:27.123]                           restarts <- computeRestarts(cond)
[13:36:27.123]                           for (restart in restarts) {
[13:36:27.123]                             name <- restart$name
[13:36:27.123]                             if (is.null(name)) 
[13:36:27.123]                               next
[13:36:27.123]                             if (!grepl(pattern, name)) 
[13:36:27.123]                               next
[13:36:27.123]                             invokeRestart(restart)
[13:36:27.123]                             muffled <- TRUE
[13:36:27.123]                             break
[13:36:27.123]                           }
[13:36:27.123]                         }
[13:36:27.123]                       }
[13:36:27.123]                       invisible(muffled)
[13:36:27.123]                     }
[13:36:27.123]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.123]                   }
[13:36:27.123]                 }
[13:36:27.123]             }
[13:36:27.123]         }))
[13:36:27.123]     }, error = function(ex) {
[13:36:27.123]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:27.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.123]                 ...future.rng), started = ...future.startTime, 
[13:36:27.123]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:27.123]             version = "1.8"), class = "FutureResult")
[13:36:27.123]     }, finally = {
[13:36:27.123]         if (!identical(...future.workdir, getwd())) 
[13:36:27.123]             setwd(...future.workdir)
[13:36:27.123]         {
[13:36:27.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:27.123]                 ...future.oldOptions$nwarnings <- NULL
[13:36:27.123]             }
[13:36:27.123]             base::options(...future.oldOptions)
[13:36:27.123]             if (.Platform$OS.type == "windows") {
[13:36:27.123]                 old_names <- names(...future.oldEnvVars)
[13:36:27.123]                 envs <- base::Sys.getenv()
[13:36:27.123]                 names <- names(envs)
[13:36:27.123]                 common <- intersect(names, old_names)
[13:36:27.123]                 added <- setdiff(names, old_names)
[13:36:27.123]                 removed <- setdiff(old_names, names)
[13:36:27.123]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:27.123]                   envs[common]]
[13:36:27.123]                 NAMES <- toupper(changed)
[13:36:27.123]                 args <- list()
[13:36:27.123]                 for (kk in seq_along(NAMES)) {
[13:36:27.123]                   name <- changed[[kk]]
[13:36:27.123]                   NAME <- NAMES[[kk]]
[13:36:27.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.123]                     next
[13:36:27.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.123]                 }
[13:36:27.123]                 NAMES <- toupper(added)
[13:36:27.123]                 for (kk in seq_along(NAMES)) {
[13:36:27.123]                   name <- added[[kk]]
[13:36:27.123]                   NAME <- NAMES[[kk]]
[13:36:27.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.123]                     next
[13:36:27.123]                   args[[name]] <- ""
[13:36:27.123]                 }
[13:36:27.123]                 NAMES <- toupper(removed)
[13:36:27.123]                 for (kk in seq_along(NAMES)) {
[13:36:27.123]                   name <- removed[[kk]]
[13:36:27.123]                   NAME <- NAMES[[kk]]
[13:36:27.123]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.123]                     next
[13:36:27.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.123]                 }
[13:36:27.123]                 if (length(args) > 0) 
[13:36:27.123]                   base::do.call(base::Sys.setenv, args = args)
[13:36:27.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:27.123]             }
[13:36:27.123]             else {
[13:36:27.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:27.123]             }
[13:36:27.123]             {
[13:36:27.123]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:27.123]                   0L) {
[13:36:27.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:27.123]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:27.123]                   base::options(opts)
[13:36:27.123]                 }
[13:36:27.123]                 {
[13:36:27.123]                   {
[13:36:27.123]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:27.123]                     NULL
[13:36:27.123]                   }
[13:36:27.123]                   options(future.plan = NULL)
[13:36:27.123]                   if (is.na(NA_character_)) 
[13:36:27.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:27.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:27.123]                     .init = FALSE)
[13:36:27.123]                 }
[13:36:27.123]             }
[13:36:27.123]         }
[13:36:27.123]     })
[13:36:27.123]     if (TRUE) {
[13:36:27.123]         base::sink(type = "output", split = FALSE)
[13:36:27.123]         if (TRUE) {
[13:36:27.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:27.123]         }
[13:36:27.123]         else {
[13:36:27.123]             ...future.result["stdout"] <- base::list(NULL)
[13:36:27.123]         }
[13:36:27.123]         base::close(...future.stdout)
[13:36:27.123]         ...future.stdout <- NULL
[13:36:27.123]     }
[13:36:27.123]     ...future.result$conditions <- ...future.conditions
[13:36:27.123]     ...future.result$finished <- base::Sys.time()
[13:36:27.123]     ...future.result
[13:36:27.123] }
[13:36:27.126] MultisessionFuture started
[13:36:27.126] - Launch lazy future ... done
[13:36:27.126] run() for ‘MultisessionFuture’ ... done
[13:36:27.126] result() for ClusterFuture ...
[13:36:27.126] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.127] - Validating connection of MultisessionFuture
[13:36:27.128] - received message: FutureResult
[13:36:27.128] - Received FutureResult
[13:36:27.128] - Erased future from FutureRegistry
[13:36:27.128] result() for ClusterFuture ...
[13:36:27.128] - result already collected: FutureResult
[13:36:27.128] result() for ClusterFuture ... done
[13:36:27.128] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.128] result() for ClusterFuture ... done
[13:36:27.128] result() for ClusterFuture ...
[13:36:27.128] - result already collected: FutureResult
[13:36:27.128] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[13:36:27.129] getGlobalsAndPackages() ...
[13:36:27.129] Searching for globals...
[13:36:27.132] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:36:27.133] Searching for globals ... DONE
[13:36:27.133] Resolving globals: FALSE
[13:36:27.133] 
[13:36:27.133] - packages: [1] ‘future’
[13:36:27.133] getGlobalsAndPackages() ... DONE
[13:36:27.133] run() for ‘Future’ ...
[13:36:27.134] - state: ‘created’
[13:36:27.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:27.148] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:27.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:27.148]   - Field: ‘node’
[13:36:27.148]   - Field: ‘label’
[13:36:27.148]   - Field: ‘local’
[13:36:27.148]   - Field: ‘owner’
[13:36:27.148]   - Field: ‘envir’
[13:36:27.148]   - Field: ‘workers’
[13:36:27.149]   - Field: ‘packages’
[13:36:27.149]   - Field: ‘gc’
[13:36:27.149]   - Field: ‘conditions’
[13:36:27.149]   - Field: ‘persistent’
[13:36:27.149]   - Field: ‘expr’
[13:36:27.149]   - Field: ‘uuid’
[13:36:27.149]   - Field: ‘seed’
[13:36:27.149]   - Field: ‘version’
[13:36:27.149]   - Field: ‘result’
[13:36:27.149]   - Field: ‘asynchronous’
[13:36:27.149]   - Field: ‘calls’
[13:36:27.150]   - Field: ‘globals’
[13:36:27.150]   - Field: ‘stdout’
[13:36:27.150]   - Field: ‘earlySignal’
[13:36:27.150]   - Field: ‘lazy’
[13:36:27.150]   - Field: ‘state’
[13:36:27.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:27.150] - Launch lazy future ...
[13:36:27.150] Packages needed by the future expression (n = 1): ‘future’
[13:36:27.151] Packages needed by future strategies (n = 0): <none>
[13:36:27.151] {
[13:36:27.151]     {
[13:36:27.151]         {
[13:36:27.151]             ...future.startTime <- base::Sys.time()
[13:36:27.151]             {
[13:36:27.151]                 {
[13:36:27.151]                   {
[13:36:27.151]                     {
[13:36:27.151]                       {
[13:36:27.151]                         base::local({
[13:36:27.151]                           has_future <- base::requireNamespace("future", 
[13:36:27.151]                             quietly = TRUE)
[13:36:27.151]                           if (has_future) {
[13:36:27.151]                             ns <- base::getNamespace("future")
[13:36:27.151]                             version <- ns[[".package"]][["version"]]
[13:36:27.151]                             if (is.null(version)) 
[13:36:27.151]                               version <- utils::packageVersion("future")
[13:36:27.151]                           }
[13:36:27.151]                           else {
[13:36:27.151]                             version <- NULL
[13:36:27.151]                           }
[13:36:27.151]                           if (!has_future || version < "1.8.0") {
[13:36:27.151]                             info <- base::c(r_version = base::gsub("R version ", 
[13:36:27.151]                               "", base::R.version$version.string), 
[13:36:27.151]                               platform = base::sprintf("%s (%s-bit)", 
[13:36:27.151]                                 base::R.version$platform, 8 * 
[13:36:27.151]                                   base::.Machine$sizeof.pointer), 
[13:36:27.151]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:27.151]                                 "release", "version")], collapse = " "), 
[13:36:27.151]                               hostname = base::Sys.info()[["nodename"]])
[13:36:27.151]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:36:27.151]                               info)
[13:36:27.151]                             info <- base::paste(info, collapse = "; ")
[13:36:27.151]                             if (!has_future) {
[13:36:27.151]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:27.151]                                 info)
[13:36:27.151]                             }
[13:36:27.151]                             else {
[13:36:27.151]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:27.151]                                 info, version)
[13:36:27.151]                             }
[13:36:27.151]                             base::stop(msg)
[13:36:27.151]                           }
[13:36:27.151]                         })
[13:36:27.151]                       }
[13:36:27.151]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:27.151]                       base::options(mc.cores = 1L)
[13:36:27.151]                     }
[13:36:27.151]                     base::local({
[13:36:27.151]                       for (pkg in "future") {
[13:36:27.151]                         base::loadNamespace(pkg)
[13:36:27.151]                         base::library(pkg, character.only = TRUE)
[13:36:27.151]                       }
[13:36:27.151]                     })
[13:36:27.151]                   }
[13:36:27.151]                   ...future.strategy.old <- future::plan("list")
[13:36:27.151]                   options(future.plan = NULL)
[13:36:27.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:27.151]                 }
[13:36:27.151]                 ...future.workdir <- getwd()
[13:36:27.151]             }
[13:36:27.151]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:27.151]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:27.151]         }
[13:36:27.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:27.151]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:27.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:27.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:27.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:27.151]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:27.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:27.151]             base::names(...future.oldOptions))
[13:36:27.151]     }
[13:36:27.151]     if (FALSE) {
[13:36:27.151]     }
[13:36:27.151]     else {
[13:36:27.151]         if (TRUE) {
[13:36:27.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:27.151]                 open = "w")
[13:36:27.151]         }
[13:36:27.151]         else {
[13:36:27.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:27.151]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:27.151]         }
[13:36:27.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:27.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:27.151]             base::sink(type = "output", split = FALSE)
[13:36:27.151]             base::close(...future.stdout)
[13:36:27.151]         }, add = TRUE)
[13:36:27.151]     }
[13:36:27.151]     ...future.frame <- base::sys.nframe()
[13:36:27.151]     ...future.conditions <- base::list()
[13:36:27.151]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:27.151]     if (FALSE) {
[13:36:27.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:27.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:27.151]     }
[13:36:27.151]     ...future.result <- base::tryCatch({
[13:36:27.151]         base::withCallingHandlers({
[13:36:27.151]             ...future.value <- base::withVisible(base::local({
[13:36:27.151]                 ...future.makeSendCondition <- base::local({
[13:36:27.151]                   sendCondition <- NULL
[13:36:27.151]                   function(frame = 1L) {
[13:36:27.151]                     if (is.function(sendCondition)) 
[13:36:27.151]                       return(sendCondition)
[13:36:27.151]                     ns <- getNamespace("parallel")
[13:36:27.151]                     if (exists("sendData", mode = "function", 
[13:36:27.151]                       envir = ns)) {
[13:36:27.151]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:27.151]                         envir = ns)
[13:36:27.151]                       envir <- sys.frame(frame)
[13:36:27.151]                       master <- NULL
[13:36:27.151]                       while (!identical(envir, .GlobalEnv) && 
[13:36:27.151]                         !identical(envir, emptyenv())) {
[13:36:27.151]                         if (exists("master", mode = "list", envir = envir, 
[13:36:27.151]                           inherits = FALSE)) {
[13:36:27.151]                           master <- get("master", mode = "list", 
[13:36:27.151]                             envir = envir, inherits = FALSE)
[13:36:27.151]                           if (inherits(master, c("SOCKnode", 
[13:36:27.151]                             "SOCK0node"))) {
[13:36:27.151]                             sendCondition <<- function(cond) {
[13:36:27.151]                               data <- list(type = "VALUE", value = cond, 
[13:36:27.151]                                 success = TRUE)
[13:36:27.151]                               parallel_sendData(master, data)
[13:36:27.151]                             }
[13:36:27.151]                             return(sendCondition)
[13:36:27.151]                           }
[13:36:27.151]                         }
[13:36:27.151]                         frame <- frame + 1L
[13:36:27.151]                         envir <- sys.frame(frame)
[13:36:27.151]                       }
[13:36:27.151]                     }
[13:36:27.151]                     sendCondition <<- function(cond) NULL
[13:36:27.151]                   }
[13:36:27.151]                 })
[13:36:27.151]                 withCallingHandlers({
[13:36:27.151]                   {
[13:36:27.151]                     b <- 1
[13:36:27.151]                     c %<-% 2
[13:36:27.151]                     d <- 3
[13:36:27.151]                     4 %->% e
[13:36:27.151]                     b + c + d + e
[13:36:27.151]                   }
[13:36:27.151]                 }, immediateCondition = function(cond) {
[13:36:27.151]                   sendCondition <- ...future.makeSendCondition()
[13:36:27.151]                   sendCondition(cond)
[13:36:27.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.151]                   {
[13:36:27.151]                     inherits <- base::inherits
[13:36:27.151]                     invokeRestart <- base::invokeRestart
[13:36:27.151]                     is.null <- base::is.null
[13:36:27.151]                     muffled <- FALSE
[13:36:27.151]                     if (inherits(cond, "message")) {
[13:36:27.151]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:27.151]                       if (muffled) 
[13:36:27.151]                         invokeRestart("muffleMessage")
[13:36:27.151]                     }
[13:36:27.151]                     else if (inherits(cond, "warning")) {
[13:36:27.151]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:27.151]                       if (muffled) 
[13:36:27.151]                         invokeRestart("muffleWarning")
[13:36:27.151]                     }
[13:36:27.151]                     else if (inherits(cond, "condition")) {
[13:36:27.151]                       if (!is.null(pattern)) {
[13:36:27.151]                         computeRestarts <- base::computeRestarts
[13:36:27.151]                         grepl <- base::grepl
[13:36:27.151]                         restarts <- computeRestarts(cond)
[13:36:27.151]                         for (restart in restarts) {
[13:36:27.151]                           name <- restart$name
[13:36:27.151]                           if (is.null(name)) 
[13:36:27.151]                             next
[13:36:27.151]                           if (!grepl(pattern, name)) 
[13:36:27.151]                             next
[13:36:27.151]                           invokeRestart(restart)
[13:36:27.151]                           muffled <- TRUE
[13:36:27.151]                           break
[13:36:27.151]                         }
[13:36:27.151]                       }
[13:36:27.151]                     }
[13:36:27.151]                     invisible(muffled)
[13:36:27.151]                   }
[13:36:27.151]                   muffleCondition(cond)
[13:36:27.151]                 })
[13:36:27.151]             }))
[13:36:27.151]             future::FutureResult(value = ...future.value$value, 
[13:36:27.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.151]                   ...future.rng), globalenv = if (FALSE) 
[13:36:27.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:27.151]                     ...future.globalenv.names))
[13:36:27.151]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:27.151]         }, condition = base::local({
[13:36:27.151]             c <- base::c
[13:36:27.151]             inherits <- base::inherits
[13:36:27.151]             invokeRestart <- base::invokeRestart
[13:36:27.151]             length <- base::length
[13:36:27.151]             list <- base::list
[13:36:27.151]             seq.int <- base::seq.int
[13:36:27.151]             signalCondition <- base::signalCondition
[13:36:27.151]             sys.calls <- base::sys.calls
[13:36:27.151]             `[[` <- base::`[[`
[13:36:27.151]             `+` <- base::`+`
[13:36:27.151]             `<<-` <- base::`<<-`
[13:36:27.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:27.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:27.151]                   3L)]
[13:36:27.151]             }
[13:36:27.151]             function(cond) {
[13:36:27.151]                 is_error <- inherits(cond, "error")
[13:36:27.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:27.151]                   NULL)
[13:36:27.151]                 if (is_error) {
[13:36:27.151]                   sessionInformation <- function() {
[13:36:27.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:27.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:27.151]                       search = base::search(), system = base::Sys.info())
[13:36:27.151]                   }
[13:36:27.151]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:27.151]                     cond$call), session = sessionInformation(), 
[13:36:27.151]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:27.151]                   signalCondition(cond)
[13:36:27.151]                 }
[13:36:27.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:27.151]                 "immediateCondition"))) {
[13:36:27.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:27.151]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:27.151]                   if (TRUE && !signal) {
[13:36:27.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.151]                     {
[13:36:27.151]                       inherits <- base::inherits
[13:36:27.151]                       invokeRestart <- base::invokeRestart
[13:36:27.151]                       is.null <- base::is.null
[13:36:27.151]                       muffled <- FALSE
[13:36:27.151]                       if (inherits(cond, "message")) {
[13:36:27.151]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.151]                         if (muffled) 
[13:36:27.151]                           invokeRestart("muffleMessage")
[13:36:27.151]                       }
[13:36:27.151]                       else if (inherits(cond, "warning")) {
[13:36:27.151]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.151]                         if (muffled) 
[13:36:27.151]                           invokeRestart("muffleWarning")
[13:36:27.151]                       }
[13:36:27.151]                       else if (inherits(cond, "condition")) {
[13:36:27.151]                         if (!is.null(pattern)) {
[13:36:27.151]                           computeRestarts <- base::computeRestarts
[13:36:27.151]                           grepl <- base::grepl
[13:36:27.151]                           restarts <- computeRestarts(cond)
[13:36:27.151]                           for (restart in restarts) {
[13:36:27.151]                             name <- restart$name
[13:36:27.151]                             if (is.null(name)) 
[13:36:27.151]                               next
[13:36:27.151]                             if (!grepl(pattern, name)) 
[13:36:27.151]                               next
[13:36:27.151]                             invokeRestart(restart)
[13:36:27.151]                             muffled <- TRUE
[13:36:27.151]                             break
[13:36:27.151]                           }
[13:36:27.151]                         }
[13:36:27.151]                       }
[13:36:27.151]                       invisible(muffled)
[13:36:27.151]                     }
[13:36:27.151]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.151]                   }
[13:36:27.151]                 }
[13:36:27.151]                 else {
[13:36:27.151]                   if (TRUE) {
[13:36:27.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.151]                     {
[13:36:27.151]                       inherits <- base::inherits
[13:36:27.151]                       invokeRestart <- base::invokeRestart
[13:36:27.151]                       is.null <- base::is.null
[13:36:27.151]                       muffled <- FALSE
[13:36:27.151]                       if (inherits(cond, "message")) {
[13:36:27.151]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.151]                         if (muffled) 
[13:36:27.151]                           invokeRestart("muffleMessage")
[13:36:27.151]                       }
[13:36:27.151]                       else if (inherits(cond, "warning")) {
[13:36:27.151]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.151]                         if (muffled) 
[13:36:27.151]                           invokeRestart("muffleWarning")
[13:36:27.151]                       }
[13:36:27.151]                       else if (inherits(cond, "condition")) {
[13:36:27.151]                         if (!is.null(pattern)) {
[13:36:27.151]                           computeRestarts <- base::computeRestarts
[13:36:27.151]                           grepl <- base::grepl
[13:36:27.151]                           restarts <- computeRestarts(cond)
[13:36:27.151]                           for (restart in restarts) {
[13:36:27.151]                             name <- restart$name
[13:36:27.151]                             if (is.null(name)) 
[13:36:27.151]                               next
[13:36:27.151]                             if (!grepl(pattern, name)) 
[13:36:27.151]                               next
[13:36:27.151]                             invokeRestart(restart)
[13:36:27.151]                             muffled <- TRUE
[13:36:27.151]                             break
[13:36:27.151]                           }
[13:36:27.151]                         }
[13:36:27.151]                       }
[13:36:27.151]                       invisible(muffled)
[13:36:27.151]                     }
[13:36:27.151]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.151]                   }
[13:36:27.151]                 }
[13:36:27.151]             }
[13:36:27.151]         }))
[13:36:27.151]     }, error = function(ex) {
[13:36:27.151]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:27.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.151]                 ...future.rng), started = ...future.startTime, 
[13:36:27.151]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:27.151]             version = "1.8"), class = "FutureResult")
[13:36:27.151]     }, finally = {
[13:36:27.151]         if (!identical(...future.workdir, getwd())) 
[13:36:27.151]             setwd(...future.workdir)
[13:36:27.151]         {
[13:36:27.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:27.151]                 ...future.oldOptions$nwarnings <- NULL
[13:36:27.151]             }
[13:36:27.151]             base::options(...future.oldOptions)
[13:36:27.151]             if (.Platform$OS.type == "windows") {
[13:36:27.151]                 old_names <- names(...future.oldEnvVars)
[13:36:27.151]                 envs <- base::Sys.getenv()
[13:36:27.151]                 names <- names(envs)
[13:36:27.151]                 common <- intersect(names, old_names)
[13:36:27.151]                 added <- setdiff(names, old_names)
[13:36:27.151]                 removed <- setdiff(old_names, names)
[13:36:27.151]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:27.151]                   envs[common]]
[13:36:27.151]                 NAMES <- toupper(changed)
[13:36:27.151]                 args <- list()
[13:36:27.151]                 for (kk in seq_along(NAMES)) {
[13:36:27.151]                   name <- changed[[kk]]
[13:36:27.151]                   NAME <- NAMES[[kk]]
[13:36:27.151]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.151]                     next
[13:36:27.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.151]                 }
[13:36:27.151]                 NAMES <- toupper(added)
[13:36:27.151]                 for (kk in seq_along(NAMES)) {
[13:36:27.151]                   name <- added[[kk]]
[13:36:27.151]                   NAME <- NAMES[[kk]]
[13:36:27.151]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.151]                     next
[13:36:27.151]                   args[[name]] <- ""
[13:36:27.151]                 }
[13:36:27.151]                 NAMES <- toupper(removed)
[13:36:27.151]                 for (kk in seq_along(NAMES)) {
[13:36:27.151]                   name <- removed[[kk]]
[13:36:27.151]                   NAME <- NAMES[[kk]]
[13:36:27.151]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.151]                     next
[13:36:27.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.151]                 }
[13:36:27.151]                 if (length(args) > 0) 
[13:36:27.151]                   base::do.call(base::Sys.setenv, args = args)
[13:36:27.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:27.151]             }
[13:36:27.151]             else {
[13:36:27.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:27.151]             }
[13:36:27.151]             {
[13:36:27.151]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:27.151]                   0L) {
[13:36:27.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:27.151]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:27.151]                   base::options(opts)
[13:36:27.151]                 }
[13:36:27.151]                 {
[13:36:27.151]                   {
[13:36:27.151]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:27.151]                     NULL
[13:36:27.151]                   }
[13:36:27.151]                   options(future.plan = NULL)
[13:36:27.151]                   if (is.na(NA_character_)) 
[13:36:27.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:27.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:27.151]                     .init = FALSE)
[13:36:27.151]                 }
[13:36:27.151]             }
[13:36:27.151]         }
[13:36:27.151]     })
[13:36:27.151]     if (TRUE) {
[13:36:27.151]         base::sink(type = "output", split = FALSE)
[13:36:27.151]         if (TRUE) {
[13:36:27.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:27.151]         }
[13:36:27.151]         else {
[13:36:27.151]             ...future.result["stdout"] <- base::list(NULL)
[13:36:27.151]         }
[13:36:27.151]         base::close(...future.stdout)
[13:36:27.151]         ...future.stdout <- NULL
[13:36:27.151]     }
[13:36:27.151]     ...future.result$conditions <- ...future.conditions
[13:36:27.151]     ...future.result$finished <- base::Sys.time()
[13:36:27.151]     ...future.result
[13:36:27.151] }
[13:36:27.154] MultisessionFuture started
[13:36:27.154] - Launch lazy future ... done
[13:36:27.154] run() for ‘MultisessionFuture’ ... done
[13:36:27.154] result() for ClusterFuture ...
[13:36:27.154] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.155] - Validating connection of MultisessionFuture
[13:36:27.210] - received message: FutureResult
[13:36:27.210] - Received FutureResult
[13:36:27.210] - Erased future from FutureRegistry
[13:36:27.210] result() for ClusterFuture ...
[13:36:27.210] - result already collected: FutureResult
[13:36:27.210] result() for ClusterFuture ... done
[13:36:27.210] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.211] result() for ClusterFuture ... done
[13:36:27.211] result() for ClusterFuture ...
[13:36:27.211] - result already collected: FutureResult
[13:36:27.211] result() for ClusterFuture ... done
a = 10
[13:36:27.211] getGlobalsAndPackages() ...
[13:36:27.211] Searching for globals...
[13:36:27.212] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:36:27.212] Searching for globals ... DONE
[13:36:27.212] Resolving globals: FALSE
[13:36:27.213] The total size of the 1 globals is 56 bytes (56 bytes)
[13:36:27.213] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:36:27.213] - globals: [1] ‘a’
[13:36:27.213] 
[13:36:27.213] getGlobalsAndPackages() ... DONE
[13:36:27.213] run() for ‘Future’ ...
[13:36:27.214] - state: ‘created’
[13:36:27.214] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:36:27.227] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:36:27.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:36:27.227]   - Field: ‘node’
[13:36:27.227]   - Field: ‘label’
[13:36:27.227]   - Field: ‘local’
[13:36:27.228]   - Field: ‘owner’
[13:36:27.228]   - Field: ‘envir’
[13:36:27.228]   - Field: ‘workers’
[13:36:27.228]   - Field: ‘packages’
[13:36:27.228]   - Field: ‘gc’
[13:36:27.228]   - Field: ‘conditions’
[13:36:27.228]   - Field: ‘persistent’
[13:36:27.228]   - Field: ‘expr’
[13:36:27.228]   - Field: ‘uuid’
[13:36:27.228]   - Field: ‘seed’
[13:36:27.228]   - Field: ‘version’
[13:36:27.229]   - Field: ‘result’
[13:36:27.229]   - Field: ‘asynchronous’
[13:36:27.229]   - Field: ‘calls’
[13:36:27.229]   - Field: ‘globals’
[13:36:27.229]   - Field: ‘stdout’
[13:36:27.229]   - Field: ‘earlySignal’
[13:36:27.229]   - Field: ‘lazy’
[13:36:27.229]   - Field: ‘state’
[13:36:27.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:36:27.229] - Launch lazy future ...
[13:36:27.230] Packages needed by the future expression (n = 0): <none>
[13:36:27.230] Packages needed by future strategies (n = 0): <none>
[13:36:27.230] {
[13:36:27.230]     {
[13:36:27.230]         {
[13:36:27.230]             ...future.startTime <- base::Sys.time()
[13:36:27.230]             {
[13:36:27.230]                 {
[13:36:27.230]                   {
[13:36:27.230]                     {
[13:36:27.230]                       base::local({
[13:36:27.230]                         has_future <- base::requireNamespace("future", 
[13:36:27.230]                           quietly = TRUE)
[13:36:27.230]                         if (has_future) {
[13:36:27.230]                           ns <- base::getNamespace("future")
[13:36:27.230]                           version <- ns[[".package"]][["version"]]
[13:36:27.230]                           if (is.null(version)) 
[13:36:27.230]                             version <- utils::packageVersion("future")
[13:36:27.230]                         }
[13:36:27.230]                         else {
[13:36:27.230]                           version <- NULL
[13:36:27.230]                         }
[13:36:27.230]                         if (!has_future || version < "1.8.0") {
[13:36:27.230]                           info <- base::c(r_version = base::gsub("R version ", 
[13:36:27.230]                             "", base::R.version$version.string), 
[13:36:27.230]                             platform = base::sprintf("%s (%s-bit)", 
[13:36:27.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:36:27.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:36:27.230]                               "release", "version")], collapse = " "), 
[13:36:27.230]                             hostname = base::Sys.info()[["nodename"]])
[13:36:27.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:36:27.230]                             info)
[13:36:27.230]                           info <- base::paste(info, collapse = "; ")
[13:36:27.230]                           if (!has_future) {
[13:36:27.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:36:27.230]                               info)
[13:36:27.230]                           }
[13:36:27.230]                           else {
[13:36:27.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:36:27.230]                               info, version)
[13:36:27.230]                           }
[13:36:27.230]                           base::stop(msg)
[13:36:27.230]                         }
[13:36:27.230]                       })
[13:36:27.230]                     }
[13:36:27.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:36:27.230]                     base::options(mc.cores = 1L)
[13:36:27.230]                   }
[13:36:27.230]                   ...future.strategy.old <- future::plan("list")
[13:36:27.230]                   options(future.plan = NULL)
[13:36:27.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:36:27.230]                 }
[13:36:27.230]                 ...future.workdir <- getwd()
[13:36:27.230]             }
[13:36:27.230]             ...future.oldOptions <- base::as.list(base::.Options)
[13:36:27.230]             ...future.oldEnvVars <- base::Sys.getenv()
[13:36:27.230]         }
[13:36:27.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:36:27.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:36:27.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:36:27.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:36:27.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:36:27.230]             future.stdout.windows.reencode = NULL, width = 80L)
[13:36:27.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:36:27.230]             base::names(...future.oldOptions))
[13:36:27.230]     }
[13:36:27.230]     if (FALSE) {
[13:36:27.230]     }
[13:36:27.230]     else {
[13:36:27.230]         if (TRUE) {
[13:36:27.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:36:27.230]                 open = "w")
[13:36:27.230]         }
[13:36:27.230]         else {
[13:36:27.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:36:27.230]                 windows = "NUL", "/dev/null"), open = "w")
[13:36:27.230]         }
[13:36:27.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:36:27.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:36:27.230]             base::sink(type = "output", split = FALSE)
[13:36:27.230]             base::close(...future.stdout)
[13:36:27.230]         }, add = TRUE)
[13:36:27.230]     }
[13:36:27.230]     ...future.frame <- base::sys.nframe()
[13:36:27.230]     ...future.conditions <- base::list()
[13:36:27.230]     ...future.rng <- base::globalenv()$.Random.seed
[13:36:27.230]     if (FALSE) {
[13:36:27.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:36:27.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:36:27.230]     }
[13:36:27.230]     ...future.result <- base::tryCatch({
[13:36:27.230]         base::withCallingHandlers({
[13:36:27.230]             ...future.value <- base::withVisible(base::local({
[13:36:27.230]                 ...future.makeSendCondition <- base::local({
[13:36:27.230]                   sendCondition <- NULL
[13:36:27.230]                   function(frame = 1L) {
[13:36:27.230]                     if (is.function(sendCondition)) 
[13:36:27.230]                       return(sendCondition)
[13:36:27.230]                     ns <- getNamespace("parallel")
[13:36:27.230]                     if (exists("sendData", mode = "function", 
[13:36:27.230]                       envir = ns)) {
[13:36:27.230]                       parallel_sendData <- get("sendData", mode = "function", 
[13:36:27.230]                         envir = ns)
[13:36:27.230]                       envir <- sys.frame(frame)
[13:36:27.230]                       master <- NULL
[13:36:27.230]                       while (!identical(envir, .GlobalEnv) && 
[13:36:27.230]                         !identical(envir, emptyenv())) {
[13:36:27.230]                         if (exists("master", mode = "list", envir = envir, 
[13:36:27.230]                           inherits = FALSE)) {
[13:36:27.230]                           master <- get("master", mode = "list", 
[13:36:27.230]                             envir = envir, inherits = FALSE)
[13:36:27.230]                           if (inherits(master, c("SOCKnode", 
[13:36:27.230]                             "SOCK0node"))) {
[13:36:27.230]                             sendCondition <<- function(cond) {
[13:36:27.230]                               data <- list(type = "VALUE", value = cond, 
[13:36:27.230]                                 success = TRUE)
[13:36:27.230]                               parallel_sendData(master, data)
[13:36:27.230]                             }
[13:36:27.230]                             return(sendCondition)
[13:36:27.230]                           }
[13:36:27.230]                         }
[13:36:27.230]                         frame <- frame + 1L
[13:36:27.230]                         envir <- sys.frame(frame)
[13:36:27.230]                       }
[13:36:27.230]                     }
[13:36:27.230]                     sendCondition <<- function(cond) NULL
[13:36:27.230]                   }
[13:36:27.230]                 })
[13:36:27.230]                 withCallingHandlers({
[13:36:27.230]                   {
[13:36:27.230]                     a + 1
[13:36:27.230]                   }
[13:36:27.230]                 }, immediateCondition = function(cond) {
[13:36:27.230]                   sendCondition <- ...future.makeSendCondition()
[13:36:27.230]                   sendCondition(cond)
[13:36:27.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.230]                   {
[13:36:27.230]                     inherits <- base::inherits
[13:36:27.230]                     invokeRestart <- base::invokeRestart
[13:36:27.230]                     is.null <- base::is.null
[13:36:27.230]                     muffled <- FALSE
[13:36:27.230]                     if (inherits(cond, "message")) {
[13:36:27.230]                       muffled <- grepl(pattern, "muffleMessage")
[13:36:27.230]                       if (muffled) 
[13:36:27.230]                         invokeRestart("muffleMessage")
[13:36:27.230]                     }
[13:36:27.230]                     else if (inherits(cond, "warning")) {
[13:36:27.230]                       muffled <- grepl(pattern, "muffleWarning")
[13:36:27.230]                       if (muffled) 
[13:36:27.230]                         invokeRestart("muffleWarning")
[13:36:27.230]                     }
[13:36:27.230]                     else if (inherits(cond, "condition")) {
[13:36:27.230]                       if (!is.null(pattern)) {
[13:36:27.230]                         computeRestarts <- base::computeRestarts
[13:36:27.230]                         grepl <- base::grepl
[13:36:27.230]                         restarts <- computeRestarts(cond)
[13:36:27.230]                         for (restart in restarts) {
[13:36:27.230]                           name <- restart$name
[13:36:27.230]                           if (is.null(name)) 
[13:36:27.230]                             next
[13:36:27.230]                           if (!grepl(pattern, name)) 
[13:36:27.230]                             next
[13:36:27.230]                           invokeRestart(restart)
[13:36:27.230]                           muffled <- TRUE
[13:36:27.230]                           break
[13:36:27.230]                         }
[13:36:27.230]                       }
[13:36:27.230]                     }
[13:36:27.230]                     invisible(muffled)
[13:36:27.230]                   }
[13:36:27.230]                   muffleCondition(cond)
[13:36:27.230]                 })
[13:36:27.230]             }))
[13:36:27.230]             future::FutureResult(value = ...future.value$value, 
[13:36:27.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.230]                   ...future.rng), globalenv = if (FALSE) 
[13:36:27.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:36:27.230]                     ...future.globalenv.names))
[13:36:27.230]                 else NULL, started = ...future.startTime, version = "1.8")
[13:36:27.230]         }, condition = base::local({
[13:36:27.230]             c <- base::c
[13:36:27.230]             inherits <- base::inherits
[13:36:27.230]             invokeRestart <- base::invokeRestart
[13:36:27.230]             length <- base::length
[13:36:27.230]             list <- base::list
[13:36:27.230]             seq.int <- base::seq.int
[13:36:27.230]             signalCondition <- base::signalCondition
[13:36:27.230]             sys.calls <- base::sys.calls
[13:36:27.230]             `[[` <- base::`[[`
[13:36:27.230]             `+` <- base::`+`
[13:36:27.230]             `<<-` <- base::`<<-`
[13:36:27.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:36:27.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:36:27.230]                   3L)]
[13:36:27.230]             }
[13:36:27.230]             function(cond) {
[13:36:27.230]                 is_error <- inherits(cond, "error")
[13:36:27.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:36:27.230]                   NULL)
[13:36:27.230]                 if (is_error) {
[13:36:27.230]                   sessionInformation <- function() {
[13:36:27.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:36:27.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:36:27.230]                       search = base::search(), system = base::Sys.info())
[13:36:27.230]                   }
[13:36:27.230]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:36:27.230]                     cond$call), session = sessionInformation(), 
[13:36:27.230]                     timestamp = base::Sys.time(), signaled = 0L)
[13:36:27.230]                   signalCondition(cond)
[13:36:27.230]                 }
[13:36:27.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:36:27.230]                 "immediateCondition"))) {
[13:36:27.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:36:27.230]                   ...future.conditions[[length(...future.conditions) + 
[13:36:27.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:36:27.230]                   if (TRUE && !signal) {
[13:36:27.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.230]                     {
[13:36:27.230]                       inherits <- base::inherits
[13:36:27.230]                       invokeRestart <- base::invokeRestart
[13:36:27.230]                       is.null <- base::is.null
[13:36:27.230]                       muffled <- FALSE
[13:36:27.230]                       if (inherits(cond, "message")) {
[13:36:27.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.230]                         if (muffled) 
[13:36:27.230]                           invokeRestart("muffleMessage")
[13:36:27.230]                       }
[13:36:27.230]                       else if (inherits(cond, "warning")) {
[13:36:27.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.230]                         if (muffled) 
[13:36:27.230]                           invokeRestart("muffleWarning")
[13:36:27.230]                       }
[13:36:27.230]                       else if (inherits(cond, "condition")) {
[13:36:27.230]                         if (!is.null(pattern)) {
[13:36:27.230]                           computeRestarts <- base::computeRestarts
[13:36:27.230]                           grepl <- base::grepl
[13:36:27.230]                           restarts <- computeRestarts(cond)
[13:36:27.230]                           for (restart in restarts) {
[13:36:27.230]                             name <- restart$name
[13:36:27.230]                             if (is.null(name)) 
[13:36:27.230]                               next
[13:36:27.230]                             if (!grepl(pattern, name)) 
[13:36:27.230]                               next
[13:36:27.230]                             invokeRestart(restart)
[13:36:27.230]                             muffled <- TRUE
[13:36:27.230]                             break
[13:36:27.230]                           }
[13:36:27.230]                         }
[13:36:27.230]                       }
[13:36:27.230]                       invisible(muffled)
[13:36:27.230]                     }
[13:36:27.230]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.230]                   }
[13:36:27.230]                 }
[13:36:27.230]                 else {
[13:36:27.230]                   if (TRUE) {
[13:36:27.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:36:27.230]                     {
[13:36:27.230]                       inherits <- base::inherits
[13:36:27.230]                       invokeRestart <- base::invokeRestart
[13:36:27.230]                       is.null <- base::is.null
[13:36:27.230]                       muffled <- FALSE
[13:36:27.230]                       if (inherits(cond, "message")) {
[13:36:27.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:36:27.230]                         if (muffled) 
[13:36:27.230]                           invokeRestart("muffleMessage")
[13:36:27.230]                       }
[13:36:27.230]                       else if (inherits(cond, "warning")) {
[13:36:27.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:36:27.230]                         if (muffled) 
[13:36:27.230]                           invokeRestart("muffleWarning")
[13:36:27.230]                       }
[13:36:27.230]                       else if (inherits(cond, "condition")) {
[13:36:27.230]                         if (!is.null(pattern)) {
[13:36:27.230]                           computeRestarts <- base::computeRestarts
[13:36:27.230]                           grepl <- base::grepl
[13:36:27.230]                           restarts <- computeRestarts(cond)
[13:36:27.230]                           for (restart in restarts) {
[13:36:27.230]                             name <- restart$name
[13:36:27.230]                             if (is.null(name)) 
[13:36:27.230]                               next
[13:36:27.230]                             if (!grepl(pattern, name)) 
[13:36:27.230]                               next
[13:36:27.230]                             invokeRestart(restart)
[13:36:27.230]                             muffled <- TRUE
[13:36:27.230]                             break
[13:36:27.230]                           }
[13:36:27.230]                         }
[13:36:27.230]                       }
[13:36:27.230]                       invisible(muffled)
[13:36:27.230]                     }
[13:36:27.230]                     muffleCondition(cond, pattern = "^muffle")
[13:36:27.230]                   }
[13:36:27.230]                 }
[13:36:27.230]             }
[13:36:27.230]         }))
[13:36:27.230]     }, error = function(ex) {
[13:36:27.230]         base::structure(base::list(value = NULL, visible = NULL, 
[13:36:27.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:36:27.230]                 ...future.rng), started = ...future.startTime, 
[13:36:27.230]             finished = Sys.time(), session_uuid = NA_character_, 
[13:36:27.230]             version = "1.8"), class = "FutureResult")
[13:36:27.230]     }, finally = {
[13:36:27.230]         if (!identical(...future.workdir, getwd())) 
[13:36:27.230]             setwd(...future.workdir)
[13:36:27.230]         {
[13:36:27.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:36:27.230]                 ...future.oldOptions$nwarnings <- NULL
[13:36:27.230]             }
[13:36:27.230]             base::options(...future.oldOptions)
[13:36:27.230]             if (.Platform$OS.type == "windows") {
[13:36:27.230]                 old_names <- names(...future.oldEnvVars)
[13:36:27.230]                 envs <- base::Sys.getenv()
[13:36:27.230]                 names <- names(envs)
[13:36:27.230]                 common <- intersect(names, old_names)
[13:36:27.230]                 added <- setdiff(names, old_names)
[13:36:27.230]                 removed <- setdiff(old_names, names)
[13:36:27.230]                 changed <- common[...future.oldEnvVars[common] != 
[13:36:27.230]                   envs[common]]
[13:36:27.230]                 NAMES <- toupper(changed)
[13:36:27.230]                 args <- list()
[13:36:27.230]                 for (kk in seq_along(NAMES)) {
[13:36:27.230]                   name <- changed[[kk]]
[13:36:27.230]                   NAME <- NAMES[[kk]]
[13:36:27.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.230]                     next
[13:36:27.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.230]                 }
[13:36:27.230]                 NAMES <- toupper(added)
[13:36:27.230]                 for (kk in seq_along(NAMES)) {
[13:36:27.230]                   name <- added[[kk]]
[13:36:27.230]                   NAME <- NAMES[[kk]]
[13:36:27.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.230]                     next
[13:36:27.230]                   args[[name]] <- ""
[13:36:27.230]                 }
[13:36:27.230]                 NAMES <- toupper(removed)
[13:36:27.230]                 for (kk in seq_along(NAMES)) {
[13:36:27.230]                   name <- removed[[kk]]
[13:36:27.230]                   NAME <- NAMES[[kk]]
[13:36:27.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:36:27.230]                     next
[13:36:27.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:36:27.230]                 }
[13:36:27.230]                 if (length(args) > 0) 
[13:36:27.230]                   base::do.call(base::Sys.setenv, args = args)
[13:36:27.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:36:27.230]             }
[13:36:27.230]             else {
[13:36:27.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:36:27.230]             }
[13:36:27.230]             {
[13:36:27.230]                 if (base::length(...future.futureOptionsAdded) > 
[13:36:27.230]                   0L) {
[13:36:27.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:36:27.230]                   base::names(opts) <- ...future.futureOptionsAdded
[13:36:27.230]                   base::options(opts)
[13:36:27.230]                 }
[13:36:27.230]                 {
[13:36:27.230]                   {
[13:36:27.230]                     base::options(mc.cores = ...future.mc.cores.old)
[13:36:27.230]                     NULL
[13:36:27.230]                   }
[13:36:27.230]                   options(future.plan = NULL)
[13:36:27.230]                   if (is.na(NA_character_)) 
[13:36:27.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:36:27.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:36:27.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:36:27.230]                     .init = FALSE)
[13:36:27.230]                 }
[13:36:27.230]             }
[13:36:27.230]         }
[13:36:27.230]     })
[13:36:27.230]     if (TRUE) {
[13:36:27.230]         base::sink(type = "output", split = FALSE)
[13:36:27.230]         if (TRUE) {
[13:36:27.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:36:27.230]         }
[13:36:27.230]         else {
[13:36:27.230]             ...future.result["stdout"] <- base::list(NULL)
[13:36:27.230]         }
[13:36:27.230]         base::close(...future.stdout)
[13:36:27.230]         ...future.stdout <- NULL
[13:36:27.230]     }
[13:36:27.230]     ...future.result$conditions <- ...future.conditions
[13:36:27.230]     ...future.result$finished <- base::Sys.time()
[13:36:27.230]     ...future.result
[13:36:27.230] }
[13:36:27.233] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:36:27.233] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:36:27.233] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:36:27.233] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:36:27.234] MultisessionFuture started
[13:36:27.234] - Launch lazy future ... done
[13:36:27.234] run() for ‘MultisessionFuture’ ... done
[13:36:27.234] result() for ClusterFuture ...
[13:36:27.234] receiveMessageFromWorker() for ClusterFuture ...
[13:36:27.235] - Validating connection of MultisessionFuture
[13:36:27.235] - received message: FutureResult
[13:36:27.236] - Received FutureResult
[13:36:27.236] - Erased future from FutureRegistry
[13:36:27.236] result() for ClusterFuture ...
[13:36:27.236] - result already collected: FutureResult
[13:36:27.236] result() for ClusterFuture ... done
[13:36:27.236] receiveMessageFromWorker() for ClusterFuture ... done
[13:36:27.236] result() for ClusterFuture ... done
[13:36:27.236] result() for ClusterFuture ...
[13:36:27.236] - result already collected: FutureResult
[13:36:27.236] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[13:36:27.237] plan(): Setting new future strategy stack:
[13:36:27.237] List of future strategies:
[13:36:27.237] 1. FutureStrategy:
[13:36:27.237]    - args: function (..., envir = parent.frame())
[13:36:27.237]    - tweaked: FALSE
[13:36:27.237]    - call: future::plan(oplan)
[13:36:27.238] plan(): nbrOfWorkers() = 1
> 
