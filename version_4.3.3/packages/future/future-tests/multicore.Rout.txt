
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:33:24.298] plan(): Setting new future strategy stack:
[10:33:24.299] List of future strategies:
[10:33:24.299] 1. sequential:
[10:33:24.299]    - args: function (..., envir = parent.frame())
[10:33:24.299]    - tweaked: FALSE
[10:33:24.299]    - call: future::plan("sequential")
[10:33:24.314] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[10:33:24.327] plan(): Setting new future strategy stack:
[10:33:24.327] List of future strategies:
[10:33:24.327] 1. multicore:
[10:33:24.327]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.327]    - tweaked: FALSE
[10:33:24.327]    - call: plan(multicore)
[10:33:24.341] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[10:33:24.398] getGlobalsAndPackages() ...
[10:33:24.398] Not searching for globals
[10:33:24.398] - globals: [0] <none>
[10:33:24.398] getGlobalsAndPackages() ... DONE
[10:33:24.399] Packages needed by the future expression (n = 0): <none>
[10:33:24.399] Packages needed by future strategies (n = 0): <none>
[10:33:24.400] {
[10:33:24.400]     {
[10:33:24.400]         {
[10:33:24.400]             ...future.startTime <- base::Sys.time()
[10:33:24.400]             {
[10:33:24.400]                 {
[10:33:24.400]                   {
[10:33:24.400]                     base::local({
[10:33:24.400]                       has_future <- base::requireNamespace("future", 
[10:33:24.400]                         quietly = TRUE)
[10:33:24.400]                       if (has_future) {
[10:33:24.400]                         ns <- base::getNamespace("future")
[10:33:24.400]                         version <- ns[[".package"]][["version"]]
[10:33:24.400]                         if (is.null(version)) 
[10:33:24.400]                           version <- utils::packageVersion("future")
[10:33:24.400]                       }
[10:33:24.400]                       else {
[10:33:24.400]                         version <- NULL
[10:33:24.400]                       }
[10:33:24.400]                       if (!has_future || version < "1.8.0") {
[10:33:24.400]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.400]                           "", base::R.version$version.string), 
[10:33:24.400]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.400]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.400]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.400]                             "release", "version")], collapse = " "), 
[10:33:24.400]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.400]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.400]                           info)
[10:33:24.400]                         info <- base::paste(info, collapse = "; ")
[10:33:24.400]                         if (!has_future) {
[10:33:24.400]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.400]                             info)
[10:33:24.400]                         }
[10:33:24.400]                         else {
[10:33:24.400]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.400]                             info, version)
[10:33:24.400]                         }
[10:33:24.400]                         base::stop(msg)
[10:33:24.400]                       }
[10:33:24.400]                     })
[10:33:24.400]                   }
[10:33:24.400]                   ...future.strategy.old <- future::plan("list")
[10:33:24.400]                   options(future.plan = NULL)
[10:33:24.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.400]                 }
[10:33:24.400]                 ...future.workdir <- getwd()
[10:33:24.400]             }
[10:33:24.400]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.400]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.400]         }
[10:33:24.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.400]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.400]             base::names(...future.oldOptions))
[10:33:24.400]     }
[10:33:24.400]     if (FALSE) {
[10:33:24.400]     }
[10:33:24.400]     else {
[10:33:24.400]         if (TRUE) {
[10:33:24.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.400]                 open = "w")
[10:33:24.400]         }
[10:33:24.400]         else {
[10:33:24.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.400]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.400]         }
[10:33:24.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.400]             base::sink(type = "output", split = FALSE)
[10:33:24.400]             base::close(...future.stdout)
[10:33:24.400]         }, add = TRUE)
[10:33:24.400]     }
[10:33:24.400]     ...future.frame <- base::sys.nframe()
[10:33:24.400]     ...future.conditions <- base::list()
[10:33:24.400]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.400]     if (FALSE) {
[10:33:24.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.400]     }
[10:33:24.400]     ...future.result <- base::tryCatch({
[10:33:24.400]         base::withCallingHandlers({
[10:33:24.400]             ...future.value <- base::withVisible(base::local({
[10:33:24.400]                 42L
[10:33:24.400]             }))
[10:33:24.400]             future::FutureResult(value = ...future.value$value, 
[10:33:24.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.400]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.400]                     ...future.globalenv.names))
[10:33:24.400]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.400]         }, condition = base::local({
[10:33:24.400]             c <- base::c
[10:33:24.400]             inherits <- base::inherits
[10:33:24.400]             invokeRestart <- base::invokeRestart
[10:33:24.400]             length <- base::length
[10:33:24.400]             list <- base::list
[10:33:24.400]             seq.int <- base::seq.int
[10:33:24.400]             signalCondition <- base::signalCondition
[10:33:24.400]             sys.calls <- base::sys.calls
[10:33:24.400]             `[[` <- base::`[[`
[10:33:24.400]             `+` <- base::`+`
[10:33:24.400]             `<<-` <- base::`<<-`
[10:33:24.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.400]                   3L)]
[10:33:24.400]             }
[10:33:24.400]             function(cond) {
[10:33:24.400]                 is_error <- inherits(cond, "error")
[10:33:24.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.400]                   NULL)
[10:33:24.400]                 if (is_error) {
[10:33:24.400]                   sessionInformation <- function() {
[10:33:24.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.400]                       search = base::search(), system = base::Sys.info())
[10:33:24.400]                   }
[10:33:24.400]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.400]                     cond$call), session = sessionInformation(), 
[10:33:24.400]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.400]                   signalCondition(cond)
[10:33:24.400]                 }
[10:33:24.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.400]                 "immediateCondition"))) {
[10:33:24.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.400]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.400]                   if (TRUE && !signal) {
[10:33:24.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.400]                     {
[10:33:24.400]                       inherits <- base::inherits
[10:33:24.400]                       invokeRestart <- base::invokeRestart
[10:33:24.400]                       is.null <- base::is.null
[10:33:24.400]                       muffled <- FALSE
[10:33:24.400]                       if (inherits(cond, "message")) {
[10:33:24.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.400]                         if (muffled) 
[10:33:24.400]                           invokeRestart("muffleMessage")
[10:33:24.400]                       }
[10:33:24.400]                       else if (inherits(cond, "warning")) {
[10:33:24.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.400]                         if (muffled) 
[10:33:24.400]                           invokeRestart("muffleWarning")
[10:33:24.400]                       }
[10:33:24.400]                       else if (inherits(cond, "condition")) {
[10:33:24.400]                         if (!is.null(pattern)) {
[10:33:24.400]                           computeRestarts <- base::computeRestarts
[10:33:24.400]                           grepl <- base::grepl
[10:33:24.400]                           restarts <- computeRestarts(cond)
[10:33:24.400]                           for (restart in restarts) {
[10:33:24.400]                             name <- restart$name
[10:33:24.400]                             if (is.null(name)) 
[10:33:24.400]                               next
[10:33:24.400]                             if (!grepl(pattern, name)) 
[10:33:24.400]                               next
[10:33:24.400]                             invokeRestart(restart)
[10:33:24.400]                             muffled <- TRUE
[10:33:24.400]                             break
[10:33:24.400]                           }
[10:33:24.400]                         }
[10:33:24.400]                       }
[10:33:24.400]                       invisible(muffled)
[10:33:24.400]                     }
[10:33:24.400]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.400]                   }
[10:33:24.400]                 }
[10:33:24.400]                 else {
[10:33:24.400]                   if (TRUE) {
[10:33:24.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.400]                     {
[10:33:24.400]                       inherits <- base::inherits
[10:33:24.400]                       invokeRestart <- base::invokeRestart
[10:33:24.400]                       is.null <- base::is.null
[10:33:24.400]                       muffled <- FALSE
[10:33:24.400]                       if (inherits(cond, "message")) {
[10:33:24.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.400]                         if (muffled) 
[10:33:24.400]                           invokeRestart("muffleMessage")
[10:33:24.400]                       }
[10:33:24.400]                       else if (inherits(cond, "warning")) {
[10:33:24.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.400]                         if (muffled) 
[10:33:24.400]                           invokeRestart("muffleWarning")
[10:33:24.400]                       }
[10:33:24.400]                       else if (inherits(cond, "condition")) {
[10:33:24.400]                         if (!is.null(pattern)) {
[10:33:24.400]                           computeRestarts <- base::computeRestarts
[10:33:24.400]                           grepl <- base::grepl
[10:33:24.400]                           restarts <- computeRestarts(cond)
[10:33:24.400]                           for (restart in restarts) {
[10:33:24.400]                             name <- restart$name
[10:33:24.400]                             if (is.null(name)) 
[10:33:24.400]                               next
[10:33:24.400]                             if (!grepl(pattern, name)) 
[10:33:24.400]                               next
[10:33:24.400]                             invokeRestart(restart)
[10:33:24.400]                             muffled <- TRUE
[10:33:24.400]                             break
[10:33:24.400]                           }
[10:33:24.400]                         }
[10:33:24.400]                       }
[10:33:24.400]                       invisible(muffled)
[10:33:24.400]                     }
[10:33:24.400]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.400]                   }
[10:33:24.400]                 }
[10:33:24.400]             }
[10:33:24.400]         }))
[10:33:24.400]     }, error = function(ex) {
[10:33:24.400]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.400]                 ...future.rng), started = ...future.startTime, 
[10:33:24.400]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.400]             version = "1.8"), class = "FutureResult")
[10:33:24.400]     }, finally = {
[10:33:24.400]         if (!identical(...future.workdir, getwd())) 
[10:33:24.400]             setwd(...future.workdir)
[10:33:24.400]         {
[10:33:24.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.400]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.400]             }
[10:33:24.400]             base::options(...future.oldOptions)
[10:33:24.400]             if (.Platform$OS.type == "windows") {
[10:33:24.400]                 old_names <- names(...future.oldEnvVars)
[10:33:24.400]                 envs <- base::Sys.getenv()
[10:33:24.400]                 names <- names(envs)
[10:33:24.400]                 common <- intersect(names, old_names)
[10:33:24.400]                 added <- setdiff(names, old_names)
[10:33:24.400]                 removed <- setdiff(old_names, names)
[10:33:24.400]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.400]                   envs[common]]
[10:33:24.400]                 NAMES <- toupper(changed)
[10:33:24.400]                 args <- list()
[10:33:24.400]                 for (kk in seq_along(NAMES)) {
[10:33:24.400]                   name <- changed[[kk]]
[10:33:24.400]                   NAME <- NAMES[[kk]]
[10:33:24.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.400]                     next
[10:33:24.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.400]                 }
[10:33:24.400]                 NAMES <- toupper(added)
[10:33:24.400]                 for (kk in seq_along(NAMES)) {
[10:33:24.400]                   name <- added[[kk]]
[10:33:24.400]                   NAME <- NAMES[[kk]]
[10:33:24.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.400]                     next
[10:33:24.400]                   args[[name]] <- ""
[10:33:24.400]                 }
[10:33:24.400]                 NAMES <- toupper(removed)
[10:33:24.400]                 for (kk in seq_along(NAMES)) {
[10:33:24.400]                   name <- removed[[kk]]
[10:33:24.400]                   NAME <- NAMES[[kk]]
[10:33:24.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.400]                     next
[10:33:24.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.400]                 }
[10:33:24.400]                 if (length(args) > 0) 
[10:33:24.400]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.400]             }
[10:33:24.400]             else {
[10:33:24.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.400]             }
[10:33:24.400]             {
[10:33:24.400]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.400]                   0L) {
[10:33:24.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.400]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.400]                   base::options(opts)
[10:33:24.400]                 }
[10:33:24.400]                 {
[10:33:24.400]                   {
[10:33:24.400]                     NULL
[10:33:24.400]                     RNGkind("Mersenne-Twister")
[10:33:24.400]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.400]                       inherits = FALSE)
[10:33:24.400]                   }
[10:33:24.400]                   options(future.plan = NULL)
[10:33:24.400]                   if (is.na(NA_character_)) 
[10:33:24.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.400]                     .init = FALSE)
[10:33:24.400]                 }
[10:33:24.400]             }
[10:33:24.400]         }
[10:33:24.400]     })
[10:33:24.400]     if (TRUE) {
[10:33:24.400]         base::sink(type = "output", split = FALSE)
[10:33:24.400]         if (TRUE) {
[10:33:24.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.400]         }
[10:33:24.400]         else {
[10:33:24.400]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.400]         }
[10:33:24.400]         base::close(...future.stdout)
[10:33:24.400]         ...future.stdout <- NULL
[10:33:24.400]     }
[10:33:24.400]     ...future.result$conditions <- ...future.conditions
[10:33:24.400]     ...future.result$finished <- base::Sys.time()
[10:33:24.400]     ...future.result
[10:33:24.400] }
[10:33:24.402] plan(): Setting new future strategy stack:
[10:33:24.402] List of future strategies:
[10:33:24.402] 1. sequential:
[10:33:24.402]    - args: function (..., envir = parent.frame())
[10:33:24.402]    - tweaked: FALSE
[10:33:24.402]    - call: NULL
[10:33:24.403] plan(): nbrOfWorkers() = 1
[10:33:24.404] plan(): Setting new future strategy stack:
[10:33:24.404] List of future strategies:
[10:33:24.404] 1. multicore:
[10:33:24.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.404]    - tweaked: FALSE
[10:33:24.404]    - call: plan(multicore)
[10:33:24.407] plan(): nbrOfWorkers() = 1
[10:33:24.407] SequentialFuture started (and completed)
[10:33:24.408] resolved() for ‘SequentialFuture’ ...
[10:33:24.408] - state: ‘finished’
[10:33:24.408] - run: TRUE
[10:33:24.409] - result: ‘FutureResult’
[10:33:24.409] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[10:33:24.412] getGlobalsAndPackages() ...
[10:33:24.412] Not searching for globals
[10:33:24.412] - globals: [0] <none>
[10:33:24.413] getGlobalsAndPackages() ... DONE
[10:33:24.413] Packages needed by the future expression (n = 0): <none>
[10:33:24.413] Packages needed by future strategies (n = 0): <none>
[10:33:24.413] {
[10:33:24.413]     {
[10:33:24.413]         {
[10:33:24.413]             ...future.startTime <- base::Sys.time()
[10:33:24.413]             {
[10:33:24.413]                 {
[10:33:24.413]                   {
[10:33:24.413]                     base::local({
[10:33:24.413]                       has_future <- base::requireNamespace("future", 
[10:33:24.413]                         quietly = TRUE)
[10:33:24.413]                       if (has_future) {
[10:33:24.413]                         ns <- base::getNamespace("future")
[10:33:24.413]                         version <- ns[[".package"]][["version"]]
[10:33:24.413]                         if (is.null(version)) 
[10:33:24.413]                           version <- utils::packageVersion("future")
[10:33:24.413]                       }
[10:33:24.413]                       else {
[10:33:24.413]                         version <- NULL
[10:33:24.413]                       }
[10:33:24.413]                       if (!has_future || version < "1.8.0") {
[10:33:24.413]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.413]                           "", base::R.version$version.string), 
[10:33:24.413]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.413]                             "release", "version")], collapse = " "), 
[10:33:24.413]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.413]                           info)
[10:33:24.413]                         info <- base::paste(info, collapse = "; ")
[10:33:24.413]                         if (!has_future) {
[10:33:24.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.413]                             info)
[10:33:24.413]                         }
[10:33:24.413]                         else {
[10:33:24.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.413]                             info, version)
[10:33:24.413]                         }
[10:33:24.413]                         base::stop(msg)
[10:33:24.413]                       }
[10:33:24.413]                     })
[10:33:24.413]                   }
[10:33:24.413]                   ...future.strategy.old <- future::plan("list")
[10:33:24.413]                   options(future.plan = NULL)
[10:33:24.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.413]                 }
[10:33:24.413]                 ...future.workdir <- getwd()
[10:33:24.413]             }
[10:33:24.413]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.413]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.413]         }
[10:33:24.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.413]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.413]             base::names(...future.oldOptions))
[10:33:24.413]     }
[10:33:24.413]     if (FALSE) {
[10:33:24.413]     }
[10:33:24.413]     else {
[10:33:24.413]         if (TRUE) {
[10:33:24.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.413]                 open = "w")
[10:33:24.413]         }
[10:33:24.413]         else {
[10:33:24.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.413]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.413]         }
[10:33:24.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.413]             base::sink(type = "output", split = FALSE)
[10:33:24.413]             base::close(...future.stdout)
[10:33:24.413]         }, add = TRUE)
[10:33:24.413]     }
[10:33:24.413]     ...future.frame <- base::sys.nframe()
[10:33:24.413]     ...future.conditions <- base::list()
[10:33:24.413]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.413]     if (FALSE) {
[10:33:24.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.413]     }
[10:33:24.413]     ...future.result <- base::tryCatch({
[10:33:24.413]         base::withCallingHandlers({
[10:33:24.413]             ...future.value <- base::withVisible(base::local({
[10:33:24.413]                 b <- 3
[10:33:24.413]                 c <- 2
[10:33:24.413]                 a * b * c
[10:33:24.413]             }))
[10:33:24.413]             future::FutureResult(value = ...future.value$value, 
[10:33:24.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.413]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.413]                     ...future.globalenv.names))
[10:33:24.413]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.413]         }, condition = base::local({
[10:33:24.413]             c <- base::c
[10:33:24.413]             inherits <- base::inherits
[10:33:24.413]             invokeRestart <- base::invokeRestart
[10:33:24.413]             length <- base::length
[10:33:24.413]             list <- base::list
[10:33:24.413]             seq.int <- base::seq.int
[10:33:24.413]             signalCondition <- base::signalCondition
[10:33:24.413]             sys.calls <- base::sys.calls
[10:33:24.413]             `[[` <- base::`[[`
[10:33:24.413]             `+` <- base::`+`
[10:33:24.413]             `<<-` <- base::`<<-`
[10:33:24.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.413]                   3L)]
[10:33:24.413]             }
[10:33:24.413]             function(cond) {
[10:33:24.413]                 is_error <- inherits(cond, "error")
[10:33:24.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.413]                   NULL)
[10:33:24.413]                 if (is_error) {
[10:33:24.413]                   sessionInformation <- function() {
[10:33:24.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.413]                       search = base::search(), system = base::Sys.info())
[10:33:24.413]                   }
[10:33:24.413]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.413]                     cond$call), session = sessionInformation(), 
[10:33:24.413]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.413]                   signalCondition(cond)
[10:33:24.413]                 }
[10:33:24.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.413]                 "immediateCondition"))) {
[10:33:24.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.413]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.413]                   if (TRUE && !signal) {
[10:33:24.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.413]                     {
[10:33:24.413]                       inherits <- base::inherits
[10:33:24.413]                       invokeRestart <- base::invokeRestart
[10:33:24.413]                       is.null <- base::is.null
[10:33:24.413]                       muffled <- FALSE
[10:33:24.413]                       if (inherits(cond, "message")) {
[10:33:24.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.413]                         if (muffled) 
[10:33:24.413]                           invokeRestart("muffleMessage")
[10:33:24.413]                       }
[10:33:24.413]                       else if (inherits(cond, "warning")) {
[10:33:24.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.413]                         if (muffled) 
[10:33:24.413]                           invokeRestart("muffleWarning")
[10:33:24.413]                       }
[10:33:24.413]                       else if (inherits(cond, "condition")) {
[10:33:24.413]                         if (!is.null(pattern)) {
[10:33:24.413]                           computeRestarts <- base::computeRestarts
[10:33:24.413]                           grepl <- base::grepl
[10:33:24.413]                           restarts <- computeRestarts(cond)
[10:33:24.413]                           for (restart in restarts) {
[10:33:24.413]                             name <- restart$name
[10:33:24.413]                             if (is.null(name)) 
[10:33:24.413]                               next
[10:33:24.413]                             if (!grepl(pattern, name)) 
[10:33:24.413]                               next
[10:33:24.413]                             invokeRestart(restart)
[10:33:24.413]                             muffled <- TRUE
[10:33:24.413]                             break
[10:33:24.413]                           }
[10:33:24.413]                         }
[10:33:24.413]                       }
[10:33:24.413]                       invisible(muffled)
[10:33:24.413]                     }
[10:33:24.413]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.413]                   }
[10:33:24.413]                 }
[10:33:24.413]                 else {
[10:33:24.413]                   if (TRUE) {
[10:33:24.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.413]                     {
[10:33:24.413]                       inherits <- base::inherits
[10:33:24.413]                       invokeRestart <- base::invokeRestart
[10:33:24.413]                       is.null <- base::is.null
[10:33:24.413]                       muffled <- FALSE
[10:33:24.413]                       if (inherits(cond, "message")) {
[10:33:24.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.413]                         if (muffled) 
[10:33:24.413]                           invokeRestart("muffleMessage")
[10:33:24.413]                       }
[10:33:24.413]                       else if (inherits(cond, "warning")) {
[10:33:24.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.413]                         if (muffled) 
[10:33:24.413]                           invokeRestart("muffleWarning")
[10:33:24.413]                       }
[10:33:24.413]                       else if (inherits(cond, "condition")) {
[10:33:24.413]                         if (!is.null(pattern)) {
[10:33:24.413]                           computeRestarts <- base::computeRestarts
[10:33:24.413]                           grepl <- base::grepl
[10:33:24.413]                           restarts <- computeRestarts(cond)
[10:33:24.413]                           for (restart in restarts) {
[10:33:24.413]                             name <- restart$name
[10:33:24.413]                             if (is.null(name)) 
[10:33:24.413]                               next
[10:33:24.413]                             if (!grepl(pattern, name)) 
[10:33:24.413]                               next
[10:33:24.413]                             invokeRestart(restart)
[10:33:24.413]                             muffled <- TRUE
[10:33:24.413]                             break
[10:33:24.413]                           }
[10:33:24.413]                         }
[10:33:24.413]                       }
[10:33:24.413]                       invisible(muffled)
[10:33:24.413]                     }
[10:33:24.413]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.413]                   }
[10:33:24.413]                 }
[10:33:24.413]             }
[10:33:24.413]         }))
[10:33:24.413]     }, error = function(ex) {
[10:33:24.413]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.413]                 ...future.rng), started = ...future.startTime, 
[10:33:24.413]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.413]             version = "1.8"), class = "FutureResult")
[10:33:24.413]     }, finally = {
[10:33:24.413]         if (!identical(...future.workdir, getwd())) 
[10:33:24.413]             setwd(...future.workdir)
[10:33:24.413]         {
[10:33:24.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.413]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.413]             }
[10:33:24.413]             base::options(...future.oldOptions)
[10:33:24.413]             if (.Platform$OS.type == "windows") {
[10:33:24.413]                 old_names <- names(...future.oldEnvVars)
[10:33:24.413]                 envs <- base::Sys.getenv()
[10:33:24.413]                 names <- names(envs)
[10:33:24.413]                 common <- intersect(names, old_names)
[10:33:24.413]                 added <- setdiff(names, old_names)
[10:33:24.413]                 removed <- setdiff(old_names, names)
[10:33:24.413]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.413]                   envs[common]]
[10:33:24.413]                 NAMES <- toupper(changed)
[10:33:24.413]                 args <- list()
[10:33:24.413]                 for (kk in seq_along(NAMES)) {
[10:33:24.413]                   name <- changed[[kk]]
[10:33:24.413]                   NAME <- NAMES[[kk]]
[10:33:24.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.413]                     next
[10:33:24.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.413]                 }
[10:33:24.413]                 NAMES <- toupper(added)
[10:33:24.413]                 for (kk in seq_along(NAMES)) {
[10:33:24.413]                   name <- added[[kk]]
[10:33:24.413]                   NAME <- NAMES[[kk]]
[10:33:24.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.413]                     next
[10:33:24.413]                   args[[name]] <- ""
[10:33:24.413]                 }
[10:33:24.413]                 NAMES <- toupper(removed)
[10:33:24.413]                 for (kk in seq_along(NAMES)) {
[10:33:24.413]                   name <- removed[[kk]]
[10:33:24.413]                   NAME <- NAMES[[kk]]
[10:33:24.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.413]                     next
[10:33:24.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.413]                 }
[10:33:24.413]                 if (length(args) > 0) 
[10:33:24.413]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.413]             }
[10:33:24.413]             else {
[10:33:24.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.413]             }
[10:33:24.413]             {
[10:33:24.413]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.413]                   0L) {
[10:33:24.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.413]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.413]                   base::options(opts)
[10:33:24.413]                 }
[10:33:24.413]                 {
[10:33:24.413]                   {
[10:33:24.413]                     NULL
[10:33:24.413]                     RNGkind("Mersenne-Twister")
[10:33:24.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.413]                       inherits = FALSE)
[10:33:24.413]                   }
[10:33:24.413]                   options(future.plan = NULL)
[10:33:24.413]                   if (is.na(NA_character_)) 
[10:33:24.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.413]                     .init = FALSE)
[10:33:24.413]                 }
[10:33:24.413]             }
[10:33:24.413]         }
[10:33:24.413]     })
[10:33:24.413]     if (TRUE) {
[10:33:24.413]         base::sink(type = "output", split = FALSE)
[10:33:24.413]         if (TRUE) {
[10:33:24.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.413]         }
[10:33:24.413]         else {
[10:33:24.413]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.413]         }
[10:33:24.413]         base::close(...future.stdout)
[10:33:24.413]         ...future.stdout <- NULL
[10:33:24.413]     }
[10:33:24.413]     ...future.result$conditions <- ...future.conditions
[10:33:24.413]     ...future.result$finished <- base::Sys.time()
[10:33:24.413]     ...future.result
[10:33:24.413] }
[10:33:24.415] plan(): Setting new future strategy stack:
[10:33:24.415] List of future strategies:
[10:33:24.415] 1. sequential:
[10:33:24.415]    - args: function (..., envir = parent.frame())
[10:33:24.415]    - tweaked: FALSE
[10:33:24.415]    - call: NULL
[10:33:24.416] plan(): nbrOfWorkers() = 1
[10:33:24.416] plan(): Setting new future strategy stack:
[10:33:24.416] List of future strategies:
[10:33:24.416] 1. multicore:
[10:33:24.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.416]    - tweaked: FALSE
[10:33:24.416]    - call: plan(multicore)
[10:33:24.420] plan(): nbrOfWorkers() = 1
[10:33:24.420] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[10:33:24.424] getGlobalsAndPackages() ...
[10:33:24.424] Not searching for globals
[10:33:24.424] - globals: [0] <none>
[10:33:24.425] getGlobalsAndPackages() ... DONE
[10:33:24.425] Packages needed by the future expression (n = 0): <none>
[10:33:24.425] Packages needed by future strategies (n = 0): <none>
[10:33:24.425] {
[10:33:24.425]     {
[10:33:24.425]         {
[10:33:24.425]             ...future.startTime <- base::Sys.time()
[10:33:24.425]             {
[10:33:24.425]                 {
[10:33:24.425]                   {
[10:33:24.425]                     base::local({
[10:33:24.425]                       has_future <- base::requireNamespace("future", 
[10:33:24.425]                         quietly = TRUE)
[10:33:24.425]                       if (has_future) {
[10:33:24.425]                         ns <- base::getNamespace("future")
[10:33:24.425]                         version <- ns[[".package"]][["version"]]
[10:33:24.425]                         if (is.null(version)) 
[10:33:24.425]                           version <- utils::packageVersion("future")
[10:33:24.425]                       }
[10:33:24.425]                       else {
[10:33:24.425]                         version <- NULL
[10:33:24.425]                       }
[10:33:24.425]                       if (!has_future || version < "1.8.0") {
[10:33:24.425]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.425]                           "", base::R.version$version.string), 
[10:33:24.425]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.425]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.425]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.425]                             "release", "version")], collapse = " "), 
[10:33:24.425]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.425]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.425]                           info)
[10:33:24.425]                         info <- base::paste(info, collapse = "; ")
[10:33:24.425]                         if (!has_future) {
[10:33:24.425]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.425]                             info)
[10:33:24.425]                         }
[10:33:24.425]                         else {
[10:33:24.425]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.425]                             info, version)
[10:33:24.425]                         }
[10:33:24.425]                         base::stop(msg)
[10:33:24.425]                       }
[10:33:24.425]                     })
[10:33:24.425]                   }
[10:33:24.425]                   ...future.strategy.old <- future::plan("list")
[10:33:24.425]                   options(future.plan = NULL)
[10:33:24.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.425]                 }
[10:33:24.425]                 ...future.workdir <- getwd()
[10:33:24.425]             }
[10:33:24.425]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.425]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.425]         }
[10:33:24.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.425]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.425]             base::names(...future.oldOptions))
[10:33:24.425]     }
[10:33:24.425]     if (FALSE) {
[10:33:24.425]     }
[10:33:24.425]     else {
[10:33:24.425]         if (TRUE) {
[10:33:24.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.425]                 open = "w")
[10:33:24.425]         }
[10:33:24.425]         else {
[10:33:24.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.425]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.425]         }
[10:33:24.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.425]             base::sink(type = "output", split = FALSE)
[10:33:24.425]             base::close(...future.stdout)
[10:33:24.425]         }, add = TRUE)
[10:33:24.425]     }
[10:33:24.425]     ...future.frame <- base::sys.nframe()
[10:33:24.425]     ...future.conditions <- base::list()
[10:33:24.425]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.425]     if (FALSE) {
[10:33:24.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.425]     }
[10:33:24.425]     ...future.result <- base::tryCatch({
[10:33:24.425]         base::withCallingHandlers({
[10:33:24.425]             ...future.value <- base::withVisible(base::local({
[10:33:24.425]                 ii
[10:33:24.425]             }))
[10:33:24.425]             future::FutureResult(value = ...future.value$value, 
[10:33:24.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.425]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.425]                     ...future.globalenv.names))
[10:33:24.425]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.425]         }, condition = base::local({
[10:33:24.425]             c <- base::c
[10:33:24.425]             inherits <- base::inherits
[10:33:24.425]             invokeRestart <- base::invokeRestart
[10:33:24.425]             length <- base::length
[10:33:24.425]             list <- base::list
[10:33:24.425]             seq.int <- base::seq.int
[10:33:24.425]             signalCondition <- base::signalCondition
[10:33:24.425]             sys.calls <- base::sys.calls
[10:33:24.425]             `[[` <- base::`[[`
[10:33:24.425]             `+` <- base::`+`
[10:33:24.425]             `<<-` <- base::`<<-`
[10:33:24.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.425]                   3L)]
[10:33:24.425]             }
[10:33:24.425]             function(cond) {
[10:33:24.425]                 is_error <- inherits(cond, "error")
[10:33:24.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.425]                   NULL)
[10:33:24.425]                 if (is_error) {
[10:33:24.425]                   sessionInformation <- function() {
[10:33:24.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.425]                       search = base::search(), system = base::Sys.info())
[10:33:24.425]                   }
[10:33:24.425]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.425]                     cond$call), session = sessionInformation(), 
[10:33:24.425]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.425]                   signalCondition(cond)
[10:33:24.425]                 }
[10:33:24.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.425]                 "immediateCondition"))) {
[10:33:24.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.425]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.425]                   if (TRUE && !signal) {
[10:33:24.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.425]                     {
[10:33:24.425]                       inherits <- base::inherits
[10:33:24.425]                       invokeRestart <- base::invokeRestart
[10:33:24.425]                       is.null <- base::is.null
[10:33:24.425]                       muffled <- FALSE
[10:33:24.425]                       if (inherits(cond, "message")) {
[10:33:24.425]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.425]                         if (muffled) 
[10:33:24.425]                           invokeRestart("muffleMessage")
[10:33:24.425]                       }
[10:33:24.425]                       else if (inherits(cond, "warning")) {
[10:33:24.425]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.425]                         if (muffled) 
[10:33:24.425]                           invokeRestart("muffleWarning")
[10:33:24.425]                       }
[10:33:24.425]                       else if (inherits(cond, "condition")) {
[10:33:24.425]                         if (!is.null(pattern)) {
[10:33:24.425]                           computeRestarts <- base::computeRestarts
[10:33:24.425]                           grepl <- base::grepl
[10:33:24.425]                           restarts <- computeRestarts(cond)
[10:33:24.425]                           for (restart in restarts) {
[10:33:24.425]                             name <- restart$name
[10:33:24.425]                             if (is.null(name)) 
[10:33:24.425]                               next
[10:33:24.425]                             if (!grepl(pattern, name)) 
[10:33:24.425]                               next
[10:33:24.425]                             invokeRestart(restart)
[10:33:24.425]                             muffled <- TRUE
[10:33:24.425]                             break
[10:33:24.425]                           }
[10:33:24.425]                         }
[10:33:24.425]                       }
[10:33:24.425]                       invisible(muffled)
[10:33:24.425]                     }
[10:33:24.425]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.425]                   }
[10:33:24.425]                 }
[10:33:24.425]                 else {
[10:33:24.425]                   if (TRUE) {
[10:33:24.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.425]                     {
[10:33:24.425]                       inherits <- base::inherits
[10:33:24.425]                       invokeRestart <- base::invokeRestart
[10:33:24.425]                       is.null <- base::is.null
[10:33:24.425]                       muffled <- FALSE
[10:33:24.425]                       if (inherits(cond, "message")) {
[10:33:24.425]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.425]                         if (muffled) 
[10:33:24.425]                           invokeRestart("muffleMessage")
[10:33:24.425]                       }
[10:33:24.425]                       else if (inherits(cond, "warning")) {
[10:33:24.425]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.425]                         if (muffled) 
[10:33:24.425]                           invokeRestart("muffleWarning")
[10:33:24.425]                       }
[10:33:24.425]                       else if (inherits(cond, "condition")) {
[10:33:24.425]                         if (!is.null(pattern)) {
[10:33:24.425]                           computeRestarts <- base::computeRestarts
[10:33:24.425]                           grepl <- base::grepl
[10:33:24.425]                           restarts <- computeRestarts(cond)
[10:33:24.425]                           for (restart in restarts) {
[10:33:24.425]                             name <- restart$name
[10:33:24.425]                             if (is.null(name)) 
[10:33:24.425]                               next
[10:33:24.425]                             if (!grepl(pattern, name)) 
[10:33:24.425]                               next
[10:33:24.425]                             invokeRestart(restart)
[10:33:24.425]                             muffled <- TRUE
[10:33:24.425]                             break
[10:33:24.425]                           }
[10:33:24.425]                         }
[10:33:24.425]                       }
[10:33:24.425]                       invisible(muffled)
[10:33:24.425]                     }
[10:33:24.425]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.425]                   }
[10:33:24.425]                 }
[10:33:24.425]             }
[10:33:24.425]         }))
[10:33:24.425]     }, error = function(ex) {
[10:33:24.425]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.425]                 ...future.rng), started = ...future.startTime, 
[10:33:24.425]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.425]             version = "1.8"), class = "FutureResult")
[10:33:24.425]     }, finally = {
[10:33:24.425]         if (!identical(...future.workdir, getwd())) 
[10:33:24.425]             setwd(...future.workdir)
[10:33:24.425]         {
[10:33:24.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.425]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.425]             }
[10:33:24.425]             base::options(...future.oldOptions)
[10:33:24.425]             if (.Platform$OS.type == "windows") {
[10:33:24.425]                 old_names <- names(...future.oldEnvVars)
[10:33:24.425]                 envs <- base::Sys.getenv()
[10:33:24.425]                 names <- names(envs)
[10:33:24.425]                 common <- intersect(names, old_names)
[10:33:24.425]                 added <- setdiff(names, old_names)
[10:33:24.425]                 removed <- setdiff(old_names, names)
[10:33:24.425]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.425]                   envs[common]]
[10:33:24.425]                 NAMES <- toupper(changed)
[10:33:24.425]                 args <- list()
[10:33:24.425]                 for (kk in seq_along(NAMES)) {
[10:33:24.425]                   name <- changed[[kk]]
[10:33:24.425]                   NAME <- NAMES[[kk]]
[10:33:24.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.425]                     next
[10:33:24.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.425]                 }
[10:33:24.425]                 NAMES <- toupper(added)
[10:33:24.425]                 for (kk in seq_along(NAMES)) {
[10:33:24.425]                   name <- added[[kk]]
[10:33:24.425]                   NAME <- NAMES[[kk]]
[10:33:24.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.425]                     next
[10:33:24.425]                   args[[name]] <- ""
[10:33:24.425]                 }
[10:33:24.425]                 NAMES <- toupper(removed)
[10:33:24.425]                 for (kk in seq_along(NAMES)) {
[10:33:24.425]                   name <- removed[[kk]]
[10:33:24.425]                   NAME <- NAMES[[kk]]
[10:33:24.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.425]                     next
[10:33:24.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.425]                 }
[10:33:24.425]                 if (length(args) > 0) 
[10:33:24.425]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.425]             }
[10:33:24.425]             else {
[10:33:24.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.425]             }
[10:33:24.425]             {
[10:33:24.425]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.425]                   0L) {
[10:33:24.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.425]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.425]                   base::options(opts)
[10:33:24.425]                 }
[10:33:24.425]                 {
[10:33:24.425]                   {
[10:33:24.425]                     NULL
[10:33:24.425]                     RNGkind("Mersenne-Twister")
[10:33:24.425]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.425]                       inherits = FALSE)
[10:33:24.425]                   }
[10:33:24.425]                   options(future.plan = NULL)
[10:33:24.425]                   if (is.na(NA_character_)) 
[10:33:24.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.425]                     .init = FALSE)
[10:33:24.425]                 }
[10:33:24.425]             }
[10:33:24.425]         }
[10:33:24.425]     })
[10:33:24.425]     if (TRUE) {
[10:33:24.425]         base::sink(type = "output", split = FALSE)
[10:33:24.425]         if (TRUE) {
[10:33:24.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.425]         }
[10:33:24.425]         else {
[10:33:24.425]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.425]         }
[10:33:24.425]         base::close(...future.stdout)
[10:33:24.425]         ...future.stdout <- NULL
[10:33:24.425]     }
[10:33:24.425]     ...future.result$conditions <- ...future.conditions
[10:33:24.425]     ...future.result$finished <- base::Sys.time()
[10:33:24.425]     ...future.result
[10:33:24.425] }
[10:33:24.427] plan(): Setting new future strategy stack:
[10:33:24.427] List of future strategies:
[10:33:24.427] 1. sequential:
[10:33:24.427]    - args: function (..., envir = parent.frame())
[10:33:24.427]    - tweaked: FALSE
[10:33:24.427]    - call: NULL
[10:33:24.428] plan(): nbrOfWorkers() = 1
[10:33:24.428] plan(): Setting new future strategy stack:
[10:33:24.428] List of future strategies:
[10:33:24.428] 1. multicore:
[10:33:24.428]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.428]    - tweaked: FALSE
[10:33:24.428]    - call: plan(multicore)
[10:33:24.432] plan(): nbrOfWorkers() = 1
[10:33:24.432] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[10:33:24.437] getGlobalsAndPackages() ...
[10:33:24.437] Not searching for globals
[10:33:24.438] - globals: [0] <none>
[10:33:24.438] getGlobalsAndPackages() ... DONE
[10:33:24.438] Packages needed by the future expression (n = 0): <none>
[10:33:24.438] Packages needed by future strategies (n = 0): <none>
[10:33:24.438] {
[10:33:24.438]     {
[10:33:24.438]         {
[10:33:24.438]             ...future.startTime <- base::Sys.time()
[10:33:24.438]             {
[10:33:24.438]                 {
[10:33:24.438]                   {
[10:33:24.438]                     base::local({
[10:33:24.438]                       has_future <- base::requireNamespace("future", 
[10:33:24.438]                         quietly = TRUE)
[10:33:24.438]                       if (has_future) {
[10:33:24.438]                         ns <- base::getNamespace("future")
[10:33:24.438]                         version <- ns[[".package"]][["version"]]
[10:33:24.438]                         if (is.null(version)) 
[10:33:24.438]                           version <- utils::packageVersion("future")
[10:33:24.438]                       }
[10:33:24.438]                       else {
[10:33:24.438]                         version <- NULL
[10:33:24.438]                       }
[10:33:24.438]                       if (!has_future || version < "1.8.0") {
[10:33:24.438]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.438]                           "", base::R.version$version.string), 
[10:33:24.438]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.438]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.438]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.438]                             "release", "version")], collapse = " "), 
[10:33:24.438]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.438]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.438]                           info)
[10:33:24.438]                         info <- base::paste(info, collapse = "; ")
[10:33:24.438]                         if (!has_future) {
[10:33:24.438]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.438]                             info)
[10:33:24.438]                         }
[10:33:24.438]                         else {
[10:33:24.438]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.438]                             info, version)
[10:33:24.438]                         }
[10:33:24.438]                         base::stop(msg)
[10:33:24.438]                       }
[10:33:24.438]                     })
[10:33:24.438]                   }
[10:33:24.438]                   ...future.strategy.old <- future::plan("list")
[10:33:24.438]                   options(future.plan = NULL)
[10:33:24.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.438]                 }
[10:33:24.438]                 ...future.workdir <- getwd()
[10:33:24.438]             }
[10:33:24.438]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.438]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.438]         }
[10:33:24.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.438]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.438]             base::names(...future.oldOptions))
[10:33:24.438]     }
[10:33:24.438]     if (FALSE) {
[10:33:24.438]     }
[10:33:24.438]     else {
[10:33:24.438]         if (TRUE) {
[10:33:24.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.438]                 open = "w")
[10:33:24.438]         }
[10:33:24.438]         else {
[10:33:24.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.438]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.438]         }
[10:33:24.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.438]             base::sink(type = "output", split = FALSE)
[10:33:24.438]             base::close(...future.stdout)
[10:33:24.438]         }, add = TRUE)
[10:33:24.438]     }
[10:33:24.438]     ...future.frame <- base::sys.nframe()
[10:33:24.438]     ...future.conditions <- base::list()
[10:33:24.438]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.438]     if (FALSE) {
[10:33:24.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.438]     }
[10:33:24.438]     ...future.result <- base::tryCatch({
[10:33:24.438]         base::withCallingHandlers({
[10:33:24.438]             ...future.value <- base::withVisible(base::local({
[10:33:24.438]                 ii
[10:33:24.438]             }))
[10:33:24.438]             future::FutureResult(value = ...future.value$value, 
[10:33:24.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.438]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.438]                     ...future.globalenv.names))
[10:33:24.438]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.438]         }, condition = base::local({
[10:33:24.438]             c <- base::c
[10:33:24.438]             inherits <- base::inherits
[10:33:24.438]             invokeRestart <- base::invokeRestart
[10:33:24.438]             length <- base::length
[10:33:24.438]             list <- base::list
[10:33:24.438]             seq.int <- base::seq.int
[10:33:24.438]             signalCondition <- base::signalCondition
[10:33:24.438]             sys.calls <- base::sys.calls
[10:33:24.438]             `[[` <- base::`[[`
[10:33:24.438]             `+` <- base::`+`
[10:33:24.438]             `<<-` <- base::`<<-`
[10:33:24.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.438]                   3L)]
[10:33:24.438]             }
[10:33:24.438]             function(cond) {
[10:33:24.438]                 is_error <- inherits(cond, "error")
[10:33:24.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.438]                   NULL)
[10:33:24.438]                 if (is_error) {
[10:33:24.438]                   sessionInformation <- function() {
[10:33:24.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.438]                       search = base::search(), system = base::Sys.info())
[10:33:24.438]                   }
[10:33:24.438]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.438]                     cond$call), session = sessionInformation(), 
[10:33:24.438]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.438]                   signalCondition(cond)
[10:33:24.438]                 }
[10:33:24.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.438]                 "immediateCondition"))) {
[10:33:24.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.438]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.438]                   if (TRUE && !signal) {
[10:33:24.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.438]                     {
[10:33:24.438]                       inherits <- base::inherits
[10:33:24.438]                       invokeRestart <- base::invokeRestart
[10:33:24.438]                       is.null <- base::is.null
[10:33:24.438]                       muffled <- FALSE
[10:33:24.438]                       if (inherits(cond, "message")) {
[10:33:24.438]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.438]                         if (muffled) 
[10:33:24.438]                           invokeRestart("muffleMessage")
[10:33:24.438]                       }
[10:33:24.438]                       else if (inherits(cond, "warning")) {
[10:33:24.438]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.438]                         if (muffled) 
[10:33:24.438]                           invokeRestart("muffleWarning")
[10:33:24.438]                       }
[10:33:24.438]                       else if (inherits(cond, "condition")) {
[10:33:24.438]                         if (!is.null(pattern)) {
[10:33:24.438]                           computeRestarts <- base::computeRestarts
[10:33:24.438]                           grepl <- base::grepl
[10:33:24.438]                           restarts <- computeRestarts(cond)
[10:33:24.438]                           for (restart in restarts) {
[10:33:24.438]                             name <- restart$name
[10:33:24.438]                             if (is.null(name)) 
[10:33:24.438]                               next
[10:33:24.438]                             if (!grepl(pattern, name)) 
[10:33:24.438]                               next
[10:33:24.438]                             invokeRestart(restart)
[10:33:24.438]                             muffled <- TRUE
[10:33:24.438]                             break
[10:33:24.438]                           }
[10:33:24.438]                         }
[10:33:24.438]                       }
[10:33:24.438]                       invisible(muffled)
[10:33:24.438]                     }
[10:33:24.438]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.438]                   }
[10:33:24.438]                 }
[10:33:24.438]                 else {
[10:33:24.438]                   if (TRUE) {
[10:33:24.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.438]                     {
[10:33:24.438]                       inherits <- base::inherits
[10:33:24.438]                       invokeRestart <- base::invokeRestart
[10:33:24.438]                       is.null <- base::is.null
[10:33:24.438]                       muffled <- FALSE
[10:33:24.438]                       if (inherits(cond, "message")) {
[10:33:24.438]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.438]                         if (muffled) 
[10:33:24.438]                           invokeRestart("muffleMessage")
[10:33:24.438]                       }
[10:33:24.438]                       else if (inherits(cond, "warning")) {
[10:33:24.438]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.438]                         if (muffled) 
[10:33:24.438]                           invokeRestart("muffleWarning")
[10:33:24.438]                       }
[10:33:24.438]                       else if (inherits(cond, "condition")) {
[10:33:24.438]                         if (!is.null(pattern)) {
[10:33:24.438]                           computeRestarts <- base::computeRestarts
[10:33:24.438]                           grepl <- base::grepl
[10:33:24.438]                           restarts <- computeRestarts(cond)
[10:33:24.438]                           for (restart in restarts) {
[10:33:24.438]                             name <- restart$name
[10:33:24.438]                             if (is.null(name)) 
[10:33:24.438]                               next
[10:33:24.438]                             if (!grepl(pattern, name)) 
[10:33:24.438]                               next
[10:33:24.438]                             invokeRestart(restart)
[10:33:24.438]                             muffled <- TRUE
[10:33:24.438]                             break
[10:33:24.438]                           }
[10:33:24.438]                         }
[10:33:24.438]                       }
[10:33:24.438]                       invisible(muffled)
[10:33:24.438]                     }
[10:33:24.438]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.438]                   }
[10:33:24.438]                 }
[10:33:24.438]             }
[10:33:24.438]         }))
[10:33:24.438]     }, error = function(ex) {
[10:33:24.438]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.438]                 ...future.rng), started = ...future.startTime, 
[10:33:24.438]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.438]             version = "1.8"), class = "FutureResult")
[10:33:24.438]     }, finally = {
[10:33:24.438]         if (!identical(...future.workdir, getwd())) 
[10:33:24.438]             setwd(...future.workdir)
[10:33:24.438]         {
[10:33:24.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.438]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.438]             }
[10:33:24.438]             base::options(...future.oldOptions)
[10:33:24.438]             if (.Platform$OS.type == "windows") {
[10:33:24.438]                 old_names <- names(...future.oldEnvVars)
[10:33:24.438]                 envs <- base::Sys.getenv()
[10:33:24.438]                 names <- names(envs)
[10:33:24.438]                 common <- intersect(names, old_names)
[10:33:24.438]                 added <- setdiff(names, old_names)
[10:33:24.438]                 removed <- setdiff(old_names, names)
[10:33:24.438]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.438]                   envs[common]]
[10:33:24.438]                 NAMES <- toupper(changed)
[10:33:24.438]                 args <- list()
[10:33:24.438]                 for (kk in seq_along(NAMES)) {
[10:33:24.438]                   name <- changed[[kk]]
[10:33:24.438]                   NAME <- NAMES[[kk]]
[10:33:24.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.438]                     next
[10:33:24.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.438]                 }
[10:33:24.438]                 NAMES <- toupper(added)
[10:33:24.438]                 for (kk in seq_along(NAMES)) {
[10:33:24.438]                   name <- added[[kk]]
[10:33:24.438]                   NAME <- NAMES[[kk]]
[10:33:24.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.438]                     next
[10:33:24.438]                   args[[name]] <- ""
[10:33:24.438]                 }
[10:33:24.438]                 NAMES <- toupper(removed)
[10:33:24.438]                 for (kk in seq_along(NAMES)) {
[10:33:24.438]                   name <- removed[[kk]]
[10:33:24.438]                   NAME <- NAMES[[kk]]
[10:33:24.438]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.438]                     next
[10:33:24.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.438]                 }
[10:33:24.438]                 if (length(args) > 0) 
[10:33:24.438]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.438]             }
[10:33:24.438]             else {
[10:33:24.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.438]             }
[10:33:24.438]             {
[10:33:24.438]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.438]                   0L) {
[10:33:24.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.438]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.438]                   base::options(opts)
[10:33:24.438]                 }
[10:33:24.438]                 {
[10:33:24.438]                   {
[10:33:24.438]                     NULL
[10:33:24.438]                     RNGkind("Mersenne-Twister")
[10:33:24.438]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.438]                       inherits = FALSE)
[10:33:24.438]                   }
[10:33:24.438]                   options(future.plan = NULL)
[10:33:24.438]                   if (is.na(NA_character_)) 
[10:33:24.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.438]                     .init = FALSE)
[10:33:24.438]                 }
[10:33:24.438]             }
[10:33:24.438]         }
[10:33:24.438]     })
[10:33:24.438]     if (TRUE) {
[10:33:24.438]         base::sink(type = "output", split = FALSE)
[10:33:24.438]         if (TRUE) {
[10:33:24.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.438]         }
[10:33:24.438]         else {
[10:33:24.438]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.438]         }
[10:33:24.438]         base::close(...future.stdout)
[10:33:24.438]         ...future.stdout <- NULL
[10:33:24.438]     }
[10:33:24.438]     ...future.result$conditions <- ...future.conditions
[10:33:24.438]     ...future.result$finished <- base::Sys.time()
[10:33:24.438]     ...future.result
[10:33:24.438] }
[10:33:24.440] plan(): Setting new future strategy stack:
[10:33:24.440] List of future strategies:
[10:33:24.440] 1. sequential:
[10:33:24.440]    - args: function (..., envir = parent.frame())
[10:33:24.440]    - tweaked: FALSE
[10:33:24.440]    - call: NULL
[10:33:24.441] plan(): nbrOfWorkers() = 1
[10:33:24.441] plan(): Setting new future strategy stack:
[10:33:24.441] List of future strategies:
[10:33:24.441] 1. multicore:
[10:33:24.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.441]    - tweaked: FALSE
[10:33:24.441]    - call: plan(multicore)
[10:33:24.445] plan(): nbrOfWorkers() = 1
[10:33:24.445] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[10:33:24.448] getGlobalsAndPackages() ...
[10:33:24.448] Not searching for globals
[10:33:24.448] - globals: [0] <none>
[10:33:24.448] getGlobalsAndPackages() ... DONE
[10:33:24.449] Packages needed by the future expression (n = 0): <none>
[10:33:24.449] Packages needed by future strategies (n = 0): <none>
[10:33:24.449] {
[10:33:24.449]     {
[10:33:24.449]         {
[10:33:24.449]             ...future.startTime <- base::Sys.time()
[10:33:24.449]             {
[10:33:24.449]                 {
[10:33:24.449]                   {
[10:33:24.449]                     base::local({
[10:33:24.449]                       has_future <- base::requireNamespace("future", 
[10:33:24.449]                         quietly = TRUE)
[10:33:24.449]                       if (has_future) {
[10:33:24.449]                         ns <- base::getNamespace("future")
[10:33:24.449]                         version <- ns[[".package"]][["version"]]
[10:33:24.449]                         if (is.null(version)) 
[10:33:24.449]                           version <- utils::packageVersion("future")
[10:33:24.449]                       }
[10:33:24.449]                       else {
[10:33:24.449]                         version <- NULL
[10:33:24.449]                       }
[10:33:24.449]                       if (!has_future || version < "1.8.0") {
[10:33:24.449]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.449]                           "", base::R.version$version.string), 
[10:33:24.449]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.449]                             "release", "version")], collapse = " "), 
[10:33:24.449]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.449]                           info)
[10:33:24.449]                         info <- base::paste(info, collapse = "; ")
[10:33:24.449]                         if (!has_future) {
[10:33:24.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.449]                             info)
[10:33:24.449]                         }
[10:33:24.449]                         else {
[10:33:24.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.449]                             info, version)
[10:33:24.449]                         }
[10:33:24.449]                         base::stop(msg)
[10:33:24.449]                       }
[10:33:24.449]                     })
[10:33:24.449]                   }
[10:33:24.449]                   ...future.strategy.old <- future::plan("list")
[10:33:24.449]                   options(future.plan = NULL)
[10:33:24.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.449]                 }
[10:33:24.449]                 ...future.workdir <- getwd()
[10:33:24.449]             }
[10:33:24.449]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.449]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.449]         }
[10:33:24.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.449]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.449]             base::names(...future.oldOptions))
[10:33:24.449]     }
[10:33:24.449]     if (FALSE) {
[10:33:24.449]     }
[10:33:24.449]     else {
[10:33:24.449]         if (TRUE) {
[10:33:24.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.449]                 open = "w")
[10:33:24.449]         }
[10:33:24.449]         else {
[10:33:24.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.449]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.449]         }
[10:33:24.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.449]             base::sink(type = "output", split = FALSE)
[10:33:24.449]             base::close(...future.stdout)
[10:33:24.449]         }, add = TRUE)
[10:33:24.449]     }
[10:33:24.449]     ...future.frame <- base::sys.nframe()
[10:33:24.449]     ...future.conditions <- base::list()
[10:33:24.449]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.449]     if (FALSE) {
[10:33:24.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.449]     }
[10:33:24.449]     ...future.result <- base::tryCatch({
[10:33:24.449]         base::withCallingHandlers({
[10:33:24.449]             ...future.value <- base::withVisible(base::local({
[10:33:24.449]                 ii
[10:33:24.449]             }))
[10:33:24.449]             future::FutureResult(value = ...future.value$value, 
[10:33:24.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.449]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.449]                     ...future.globalenv.names))
[10:33:24.449]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.449]         }, condition = base::local({
[10:33:24.449]             c <- base::c
[10:33:24.449]             inherits <- base::inherits
[10:33:24.449]             invokeRestart <- base::invokeRestart
[10:33:24.449]             length <- base::length
[10:33:24.449]             list <- base::list
[10:33:24.449]             seq.int <- base::seq.int
[10:33:24.449]             signalCondition <- base::signalCondition
[10:33:24.449]             sys.calls <- base::sys.calls
[10:33:24.449]             `[[` <- base::`[[`
[10:33:24.449]             `+` <- base::`+`
[10:33:24.449]             `<<-` <- base::`<<-`
[10:33:24.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.449]                   3L)]
[10:33:24.449]             }
[10:33:24.449]             function(cond) {
[10:33:24.449]                 is_error <- inherits(cond, "error")
[10:33:24.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.449]                   NULL)
[10:33:24.449]                 if (is_error) {
[10:33:24.449]                   sessionInformation <- function() {
[10:33:24.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.449]                       search = base::search(), system = base::Sys.info())
[10:33:24.449]                   }
[10:33:24.449]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.449]                     cond$call), session = sessionInformation(), 
[10:33:24.449]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.449]                   signalCondition(cond)
[10:33:24.449]                 }
[10:33:24.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.449]                 "immediateCondition"))) {
[10:33:24.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.449]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.449]                   if (TRUE && !signal) {
[10:33:24.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.449]                     {
[10:33:24.449]                       inherits <- base::inherits
[10:33:24.449]                       invokeRestart <- base::invokeRestart
[10:33:24.449]                       is.null <- base::is.null
[10:33:24.449]                       muffled <- FALSE
[10:33:24.449]                       if (inherits(cond, "message")) {
[10:33:24.449]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.449]                         if (muffled) 
[10:33:24.449]                           invokeRestart("muffleMessage")
[10:33:24.449]                       }
[10:33:24.449]                       else if (inherits(cond, "warning")) {
[10:33:24.449]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.449]                         if (muffled) 
[10:33:24.449]                           invokeRestart("muffleWarning")
[10:33:24.449]                       }
[10:33:24.449]                       else if (inherits(cond, "condition")) {
[10:33:24.449]                         if (!is.null(pattern)) {
[10:33:24.449]                           computeRestarts <- base::computeRestarts
[10:33:24.449]                           grepl <- base::grepl
[10:33:24.449]                           restarts <- computeRestarts(cond)
[10:33:24.449]                           for (restart in restarts) {
[10:33:24.449]                             name <- restart$name
[10:33:24.449]                             if (is.null(name)) 
[10:33:24.449]                               next
[10:33:24.449]                             if (!grepl(pattern, name)) 
[10:33:24.449]                               next
[10:33:24.449]                             invokeRestart(restart)
[10:33:24.449]                             muffled <- TRUE
[10:33:24.449]                             break
[10:33:24.449]                           }
[10:33:24.449]                         }
[10:33:24.449]                       }
[10:33:24.449]                       invisible(muffled)
[10:33:24.449]                     }
[10:33:24.449]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.449]                   }
[10:33:24.449]                 }
[10:33:24.449]                 else {
[10:33:24.449]                   if (TRUE) {
[10:33:24.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.449]                     {
[10:33:24.449]                       inherits <- base::inherits
[10:33:24.449]                       invokeRestart <- base::invokeRestart
[10:33:24.449]                       is.null <- base::is.null
[10:33:24.449]                       muffled <- FALSE
[10:33:24.449]                       if (inherits(cond, "message")) {
[10:33:24.449]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.449]                         if (muffled) 
[10:33:24.449]                           invokeRestart("muffleMessage")
[10:33:24.449]                       }
[10:33:24.449]                       else if (inherits(cond, "warning")) {
[10:33:24.449]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.449]                         if (muffled) 
[10:33:24.449]                           invokeRestart("muffleWarning")
[10:33:24.449]                       }
[10:33:24.449]                       else if (inherits(cond, "condition")) {
[10:33:24.449]                         if (!is.null(pattern)) {
[10:33:24.449]                           computeRestarts <- base::computeRestarts
[10:33:24.449]                           grepl <- base::grepl
[10:33:24.449]                           restarts <- computeRestarts(cond)
[10:33:24.449]                           for (restart in restarts) {
[10:33:24.449]                             name <- restart$name
[10:33:24.449]                             if (is.null(name)) 
[10:33:24.449]                               next
[10:33:24.449]                             if (!grepl(pattern, name)) 
[10:33:24.449]                               next
[10:33:24.449]                             invokeRestart(restart)
[10:33:24.449]                             muffled <- TRUE
[10:33:24.449]                             break
[10:33:24.449]                           }
[10:33:24.449]                         }
[10:33:24.449]                       }
[10:33:24.449]                       invisible(muffled)
[10:33:24.449]                     }
[10:33:24.449]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.449]                   }
[10:33:24.449]                 }
[10:33:24.449]             }
[10:33:24.449]         }))
[10:33:24.449]     }, error = function(ex) {
[10:33:24.449]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.449]                 ...future.rng), started = ...future.startTime, 
[10:33:24.449]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.449]             version = "1.8"), class = "FutureResult")
[10:33:24.449]     }, finally = {
[10:33:24.449]         if (!identical(...future.workdir, getwd())) 
[10:33:24.449]             setwd(...future.workdir)
[10:33:24.449]         {
[10:33:24.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.449]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.449]             }
[10:33:24.449]             base::options(...future.oldOptions)
[10:33:24.449]             if (.Platform$OS.type == "windows") {
[10:33:24.449]                 old_names <- names(...future.oldEnvVars)
[10:33:24.449]                 envs <- base::Sys.getenv()
[10:33:24.449]                 names <- names(envs)
[10:33:24.449]                 common <- intersect(names, old_names)
[10:33:24.449]                 added <- setdiff(names, old_names)
[10:33:24.449]                 removed <- setdiff(old_names, names)
[10:33:24.449]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.449]                   envs[common]]
[10:33:24.449]                 NAMES <- toupper(changed)
[10:33:24.449]                 args <- list()
[10:33:24.449]                 for (kk in seq_along(NAMES)) {
[10:33:24.449]                   name <- changed[[kk]]
[10:33:24.449]                   NAME <- NAMES[[kk]]
[10:33:24.449]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.449]                     next
[10:33:24.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.449]                 }
[10:33:24.449]                 NAMES <- toupper(added)
[10:33:24.449]                 for (kk in seq_along(NAMES)) {
[10:33:24.449]                   name <- added[[kk]]
[10:33:24.449]                   NAME <- NAMES[[kk]]
[10:33:24.449]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.449]                     next
[10:33:24.449]                   args[[name]] <- ""
[10:33:24.449]                 }
[10:33:24.449]                 NAMES <- toupper(removed)
[10:33:24.449]                 for (kk in seq_along(NAMES)) {
[10:33:24.449]                   name <- removed[[kk]]
[10:33:24.449]                   NAME <- NAMES[[kk]]
[10:33:24.449]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.449]                     next
[10:33:24.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.449]                 }
[10:33:24.449]                 if (length(args) > 0) 
[10:33:24.449]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.449]             }
[10:33:24.449]             else {
[10:33:24.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.449]             }
[10:33:24.449]             {
[10:33:24.449]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.449]                   0L) {
[10:33:24.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.449]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.449]                   base::options(opts)
[10:33:24.449]                 }
[10:33:24.449]                 {
[10:33:24.449]                   {
[10:33:24.449]                     NULL
[10:33:24.449]                     RNGkind("Mersenne-Twister")
[10:33:24.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.449]                       inherits = FALSE)
[10:33:24.449]                   }
[10:33:24.449]                   options(future.plan = NULL)
[10:33:24.449]                   if (is.na(NA_character_)) 
[10:33:24.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.449]                     .init = FALSE)
[10:33:24.449]                 }
[10:33:24.449]             }
[10:33:24.449]         }
[10:33:24.449]     })
[10:33:24.449]     if (TRUE) {
[10:33:24.449]         base::sink(type = "output", split = FALSE)
[10:33:24.449]         if (TRUE) {
[10:33:24.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.449]         }
[10:33:24.449]         else {
[10:33:24.449]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.449]         }
[10:33:24.449]         base::close(...future.stdout)
[10:33:24.449]         ...future.stdout <- NULL
[10:33:24.449]     }
[10:33:24.449]     ...future.result$conditions <- ...future.conditions
[10:33:24.449]     ...future.result$finished <- base::Sys.time()
[10:33:24.449]     ...future.result
[10:33:24.449] }
[10:33:24.451] plan(): Setting new future strategy stack:
[10:33:24.451] List of future strategies:
[10:33:24.451] 1. sequential:
[10:33:24.451]    - args: function (..., envir = parent.frame())
[10:33:24.451]    - tweaked: FALSE
[10:33:24.451]    - call: NULL
[10:33:24.451] plan(): nbrOfWorkers() = 1
[10:33:24.452] plan(): Setting new future strategy stack:
[10:33:24.452] List of future strategies:
[10:33:24.452] 1. multicore:
[10:33:24.452]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.452]    - tweaked: FALSE
[10:33:24.452]    - call: plan(multicore)
[10:33:24.455] plan(): nbrOfWorkers() = 1
[10:33:24.456] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[10:33:24.459] getGlobalsAndPackages() ...
[10:33:24.459] Not searching for globals
[10:33:24.459] - globals: [0] <none>
[10:33:24.459] getGlobalsAndPackages() ... DONE
[10:33:24.459] Packages needed by the future expression (n = 0): <none>
[10:33:24.460] Packages needed by future strategies (n = 0): <none>
[10:33:24.460] {
[10:33:24.460]     {
[10:33:24.460]         {
[10:33:24.460]             ...future.startTime <- base::Sys.time()
[10:33:24.460]             {
[10:33:24.460]                 {
[10:33:24.460]                   {
[10:33:24.460]                     base::local({
[10:33:24.460]                       has_future <- base::requireNamespace("future", 
[10:33:24.460]                         quietly = TRUE)
[10:33:24.460]                       if (has_future) {
[10:33:24.460]                         ns <- base::getNamespace("future")
[10:33:24.460]                         version <- ns[[".package"]][["version"]]
[10:33:24.460]                         if (is.null(version)) 
[10:33:24.460]                           version <- utils::packageVersion("future")
[10:33:24.460]                       }
[10:33:24.460]                       else {
[10:33:24.460]                         version <- NULL
[10:33:24.460]                       }
[10:33:24.460]                       if (!has_future || version < "1.8.0") {
[10:33:24.460]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.460]                           "", base::R.version$version.string), 
[10:33:24.460]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.460]                             "release", "version")], collapse = " "), 
[10:33:24.460]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.460]                           info)
[10:33:24.460]                         info <- base::paste(info, collapse = "; ")
[10:33:24.460]                         if (!has_future) {
[10:33:24.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.460]                             info)
[10:33:24.460]                         }
[10:33:24.460]                         else {
[10:33:24.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.460]                             info, version)
[10:33:24.460]                         }
[10:33:24.460]                         base::stop(msg)
[10:33:24.460]                       }
[10:33:24.460]                     })
[10:33:24.460]                   }
[10:33:24.460]                   ...future.strategy.old <- future::plan("list")
[10:33:24.460]                   options(future.plan = NULL)
[10:33:24.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.460]                 }
[10:33:24.460]                 ...future.workdir <- getwd()
[10:33:24.460]             }
[10:33:24.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.460]         }
[10:33:24.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.460]             base::names(...future.oldOptions))
[10:33:24.460]     }
[10:33:24.460]     if (FALSE) {
[10:33:24.460]     }
[10:33:24.460]     else {
[10:33:24.460]         if (TRUE) {
[10:33:24.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.460]                 open = "w")
[10:33:24.460]         }
[10:33:24.460]         else {
[10:33:24.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.460]         }
[10:33:24.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.460]             base::sink(type = "output", split = FALSE)
[10:33:24.460]             base::close(...future.stdout)
[10:33:24.460]         }, add = TRUE)
[10:33:24.460]     }
[10:33:24.460]     ...future.frame <- base::sys.nframe()
[10:33:24.460]     ...future.conditions <- base::list()
[10:33:24.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.460]     if (FALSE) {
[10:33:24.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.460]     }
[10:33:24.460]     ...future.result <- base::tryCatch({
[10:33:24.460]         base::withCallingHandlers({
[10:33:24.460]             ...future.value <- base::withVisible(base::local({
[10:33:24.460]                 ii
[10:33:24.460]             }))
[10:33:24.460]             future::FutureResult(value = ...future.value$value, 
[10:33:24.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.460]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.460]                     ...future.globalenv.names))
[10:33:24.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.460]         }, condition = base::local({
[10:33:24.460]             c <- base::c
[10:33:24.460]             inherits <- base::inherits
[10:33:24.460]             invokeRestart <- base::invokeRestart
[10:33:24.460]             length <- base::length
[10:33:24.460]             list <- base::list
[10:33:24.460]             seq.int <- base::seq.int
[10:33:24.460]             signalCondition <- base::signalCondition
[10:33:24.460]             sys.calls <- base::sys.calls
[10:33:24.460]             `[[` <- base::`[[`
[10:33:24.460]             `+` <- base::`+`
[10:33:24.460]             `<<-` <- base::`<<-`
[10:33:24.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.460]                   3L)]
[10:33:24.460]             }
[10:33:24.460]             function(cond) {
[10:33:24.460]                 is_error <- inherits(cond, "error")
[10:33:24.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.460]                   NULL)
[10:33:24.460]                 if (is_error) {
[10:33:24.460]                   sessionInformation <- function() {
[10:33:24.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.460]                       search = base::search(), system = base::Sys.info())
[10:33:24.460]                   }
[10:33:24.460]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.460]                     cond$call), session = sessionInformation(), 
[10:33:24.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.460]                   signalCondition(cond)
[10:33:24.460]                 }
[10:33:24.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.460]                 "immediateCondition"))) {
[10:33:24.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.460]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.460]                   if (TRUE && !signal) {
[10:33:24.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.460]                     {
[10:33:24.460]                       inherits <- base::inherits
[10:33:24.460]                       invokeRestart <- base::invokeRestart
[10:33:24.460]                       is.null <- base::is.null
[10:33:24.460]                       muffled <- FALSE
[10:33:24.460]                       if (inherits(cond, "message")) {
[10:33:24.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.460]                         if (muffled) 
[10:33:24.460]                           invokeRestart("muffleMessage")
[10:33:24.460]                       }
[10:33:24.460]                       else if (inherits(cond, "warning")) {
[10:33:24.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.460]                         if (muffled) 
[10:33:24.460]                           invokeRestart("muffleWarning")
[10:33:24.460]                       }
[10:33:24.460]                       else if (inherits(cond, "condition")) {
[10:33:24.460]                         if (!is.null(pattern)) {
[10:33:24.460]                           computeRestarts <- base::computeRestarts
[10:33:24.460]                           grepl <- base::grepl
[10:33:24.460]                           restarts <- computeRestarts(cond)
[10:33:24.460]                           for (restart in restarts) {
[10:33:24.460]                             name <- restart$name
[10:33:24.460]                             if (is.null(name)) 
[10:33:24.460]                               next
[10:33:24.460]                             if (!grepl(pattern, name)) 
[10:33:24.460]                               next
[10:33:24.460]                             invokeRestart(restart)
[10:33:24.460]                             muffled <- TRUE
[10:33:24.460]                             break
[10:33:24.460]                           }
[10:33:24.460]                         }
[10:33:24.460]                       }
[10:33:24.460]                       invisible(muffled)
[10:33:24.460]                     }
[10:33:24.460]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.460]                   }
[10:33:24.460]                 }
[10:33:24.460]                 else {
[10:33:24.460]                   if (TRUE) {
[10:33:24.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.460]                     {
[10:33:24.460]                       inherits <- base::inherits
[10:33:24.460]                       invokeRestart <- base::invokeRestart
[10:33:24.460]                       is.null <- base::is.null
[10:33:24.460]                       muffled <- FALSE
[10:33:24.460]                       if (inherits(cond, "message")) {
[10:33:24.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.460]                         if (muffled) 
[10:33:24.460]                           invokeRestart("muffleMessage")
[10:33:24.460]                       }
[10:33:24.460]                       else if (inherits(cond, "warning")) {
[10:33:24.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.460]                         if (muffled) 
[10:33:24.460]                           invokeRestart("muffleWarning")
[10:33:24.460]                       }
[10:33:24.460]                       else if (inherits(cond, "condition")) {
[10:33:24.460]                         if (!is.null(pattern)) {
[10:33:24.460]                           computeRestarts <- base::computeRestarts
[10:33:24.460]                           grepl <- base::grepl
[10:33:24.460]                           restarts <- computeRestarts(cond)
[10:33:24.460]                           for (restart in restarts) {
[10:33:24.460]                             name <- restart$name
[10:33:24.460]                             if (is.null(name)) 
[10:33:24.460]                               next
[10:33:24.460]                             if (!grepl(pattern, name)) 
[10:33:24.460]                               next
[10:33:24.460]                             invokeRestart(restart)
[10:33:24.460]                             muffled <- TRUE
[10:33:24.460]                             break
[10:33:24.460]                           }
[10:33:24.460]                         }
[10:33:24.460]                       }
[10:33:24.460]                       invisible(muffled)
[10:33:24.460]                     }
[10:33:24.460]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.460]                   }
[10:33:24.460]                 }
[10:33:24.460]             }
[10:33:24.460]         }))
[10:33:24.460]     }, error = function(ex) {
[10:33:24.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.460]                 ...future.rng), started = ...future.startTime, 
[10:33:24.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.460]             version = "1.8"), class = "FutureResult")
[10:33:24.460]     }, finally = {
[10:33:24.460]         if (!identical(...future.workdir, getwd())) 
[10:33:24.460]             setwd(...future.workdir)
[10:33:24.460]         {
[10:33:24.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.460]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.460]             }
[10:33:24.460]             base::options(...future.oldOptions)
[10:33:24.460]             if (.Platform$OS.type == "windows") {
[10:33:24.460]                 old_names <- names(...future.oldEnvVars)
[10:33:24.460]                 envs <- base::Sys.getenv()
[10:33:24.460]                 names <- names(envs)
[10:33:24.460]                 common <- intersect(names, old_names)
[10:33:24.460]                 added <- setdiff(names, old_names)
[10:33:24.460]                 removed <- setdiff(old_names, names)
[10:33:24.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.460]                   envs[common]]
[10:33:24.460]                 NAMES <- toupper(changed)
[10:33:24.460]                 args <- list()
[10:33:24.460]                 for (kk in seq_along(NAMES)) {
[10:33:24.460]                   name <- changed[[kk]]
[10:33:24.460]                   NAME <- NAMES[[kk]]
[10:33:24.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.460]                     next
[10:33:24.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.460]                 }
[10:33:24.460]                 NAMES <- toupper(added)
[10:33:24.460]                 for (kk in seq_along(NAMES)) {
[10:33:24.460]                   name <- added[[kk]]
[10:33:24.460]                   NAME <- NAMES[[kk]]
[10:33:24.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.460]                     next
[10:33:24.460]                   args[[name]] <- ""
[10:33:24.460]                 }
[10:33:24.460]                 NAMES <- toupper(removed)
[10:33:24.460]                 for (kk in seq_along(NAMES)) {
[10:33:24.460]                   name <- removed[[kk]]
[10:33:24.460]                   NAME <- NAMES[[kk]]
[10:33:24.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.460]                     next
[10:33:24.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.460]                 }
[10:33:24.460]                 if (length(args) > 0) 
[10:33:24.460]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.460]             }
[10:33:24.460]             else {
[10:33:24.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.460]             }
[10:33:24.460]             {
[10:33:24.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.460]                   0L) {
[10:33:24.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.460]                   base::options(opts)
[10:33:24.460]                 }
[10:33:24.460]                 {
[10:33:24.460]                   {
[10:33:24.460]                     NULL
[10:33:24.460]                     RNGkind("Mersenne-Twister")
[10:33:24.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.460]                       inherits = FALSE)
[10:33:24.460]                   }
[10:33:24.460]                   options(future.plan = NULL)
[10:33:24.460]                   if (is.na(NA_character_)) 
[10:33:24.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.460]                     .init = FALSE)
[10:33:24.460]                 }
[10:33:24.460]             }
[10:33:24.460]         }
[10:33:24.460]     })
[10:33:24.460]     if (TRUE) {
[10:33:24.460]         base::sink(type = "output", split = FALSE)
[10:33:24.460]         if (TRUE) {
[10:33:24.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.460]         }
[10:33:24.460]         else {
[10:33:24.460]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.460]         }
[10:33:24.460]         base::close(...future.stdout)
[10:33:24.460]         ...future.stdout <- NULL
[10:33:24.460]     }
[10:33:24.460]     ...future.result$conditions <- ...future.conditions
[10:33:24.460]     ...future.result$finished <- base::Sys.time()
[10:33:24.460]     ...future.result
[10:33:24.460] }
[10:33:24.462] plan(): Setting new future strategy stack:
[10:33:24.462] List of future strategies:
[10:33:24.462] 1. sequential:
[10:33:24.462]    - args: function (..., envir = parent.frame())
[10:33:24.462]    - tweaked: FALSE
[10:33:24.462]    - call: NULL
[10:33:24.462] plan(): nbrOfWorkers() = 1
[10:33:24.463] plan(): Setting new future strategy stack:
[10:33:24.463] List of future strategies:
[10:33:24.463] 1. multicore:
[10:33:24.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.463]    - tweaked: FALSE
[10:33:24.463]    - call: plan(multicore)
[10:33:24.466] plan(): nbrOfWorkers() = 1
[10:33:24.466] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[10:33:24.470] getGlobalsAndPackages() ...
[10:33:24.470] Not searching for globals
[10:33:24.470] - globals: [0] <none>
[10:33:24.471] getGlobalsAndPackages() ... DONE
[10:33:24.471] Packages needed by the future expression (n = 0): <none>
[10:33:24.471] Packages needed by future strategies (n = 0): <none>
[10:33:24.471] {
[10:33:24.471]     {
[10:33:24.471]         {
[10:33:24.471]             ...future.startTime <- base::Sys.time()
[10:33:24.471]             {
[10:33:24.471]                 {
[10:33:24.471]                   {
[10:33:24.471]                     base::local({
[10:33:24.471]                       has_future <- base::requireNamespace("future", 
[10:33:24.471]                         quietly = TRUE)
[10:33:24.471]                       if (has_future) {
[10:33:24.471]                         ns <- base::getNamespace("future")
[10:33:24.471]                         version <- ns[[".package"]][["version"]]
[10:33:24.471]                         if (is.null(version)) 
[10:33:24.471]                           version <- utils::packageVersion("future")
[10:33:24.471]                       }
[10:33:24.471]                       else {
[10:33:24.471]                         version <- NULL
[10:33:24.471]                       }
[10:33:24.471]                       if (!has_future || version < "1.8.0") {
[10:33:24.471]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.471]                           "", base::R.version$version.string), 
[10:33:24.471]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.471]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.471]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.471]                             "release", "version")], collapse = " "), 
[10:33:24.471]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.471]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.471]                           info)
[10:33:24.471]                         info <- base::paste(info, collapse = "; ")
[10:33:24.471]                         if (!has_future) {
[10:33:24.471]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.471]                             info)
[10:33:24.471]                         }
[10:33:24.471]                         else {
[10:33:24.471]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.471]                             info, version)
[10:33:24.471]                         }
[10:33:24.471]                         base::stop(msg)
[10:33:24.471]                       }
[10:33:24.471]                     })
[10:33:24.471]                   }
[10:33:24.471]                   ...future.strategy.old <- future::plan("list")
[10:33:24.471]                   options(future.plan = NULL)
[10:33:24.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.471]                 }
[10:33:24.471]                 ...future.workdir <- getwd()
[10:33:24.471]             }
[10:33:24.471]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.471]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.471]         }
[10:33:24.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.471]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.471]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.471]             base::names(...future.oldOptions))
[10:33:24.471]     }
[10:33:24.471]     if (FALSE) {
[10:33:24.471]     }
[10:33:24.471]     else {
[10:33:24.471]         if (TRUE) {
[10:33:24.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.471]                 open = "w")
[10:33:24.471]         }
[10:33:24.471]         else {
[10:33:24.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.471]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.471]         }
[10:33:24.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.471]             base::sink(type = "output", split = FALSE)
[10:33:24.471]             base::close(...future.stdout)
[10:33:24.471]         }, add = TRUE)
[10:33:24.471]     }
[10:33:24.471]     ...future.frame <- base::sys.nframe()
[10:33:24.471]     ...future.conditions <- base::list()
[10:33:24.471]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.471]     if (FALSE) {
[10:33:24.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.471]     }
[10:33:24.471]     ...future.result <- base::tryCatch({
[10:33:24.471]         base::withCallingHandlers({
[10:33:24.471]             ...future.value <- base::withVisible(base::local({
[10:33:24.471]                 stop("Whoops!")
[10:33:24.471]                 1
[10:33:24.471]             }))
[10:33:24.471]             future::FutureResult(value = ...future.value$value, 
[10:33:24.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.471]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.471]                     ...future.globalenv.names))
[10:33:24.471]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.471]         }, condition = base::local({
[10:33:24.471]             c <- base::c
[10:33:24.471]             inherits <- base::inherits
[10:33:24.471]             invokeRestart <- base::invokeRestart
[10:33:24.471]             length <- base::length
[10:33:24.471]             list <- base::list
[10:33:24.471]             seq.int <- base::seq.int
[10:33:24.471]             signalCondition <- base::signalCondition
[10:33:24.471]             sys.calls <- base::sys.calls
[10:33:24.471]             `[[` <- base::`[[`
[10:33:24.471]             `+` <- base::`+`
[10:33:24.471]             `<<-` <- base::`<<-`
[10:33:24.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.471]                   3L)]
[10:33:24.471]             }
[10:33:24.471]             function(cond) {
[10:33:24.471]                 is_error <- inherits(cond, "error")
[10:33:24.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.471]                   NULL)
[10:33:24.471]                 if (is_error) {
[10:33:24.471]                   sessionInformation <- function() {
[10:33:24.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.471]                       search = base::search(), system = base::Sys.info())
[10:33:24.471]                   }
[10:33:24.471]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.471]                     cond$call), session = sessionInformation(), 
[10:33:24.471]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.471]                   signalCondition(cond)
[10:33:24.471]                 }
[10:33:24.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.471]                 "immediateCondition"))) {
[10:33:24.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.471]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.471]                   if (TRUE && !signal) {
[10:33:24.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.471]                     {
[10:33:24.471]                       inherits <- base::inherits
[10:33:24.471]                       invokeRestart <- base::invokeRestart
[10:33:24.471]                       is.null <- base::is.null
[10:33:24.471]                       muffled <- FALSE
[10:33:24.471]                       if (inherits(cond, "message")) {
[10:33:24.471]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.471]                         if (muffled) 
[10:33:24.471]                           invokeRestart("muffleMessage")
[10:33:24.471]                       }
[10:33:24.471]                       else if (inherits(cond, "warning")) {
[10:33:24.471]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.471]                         if (muffled) 
[10:33:24.471]                           invokeRestart("muffleWarning")
[10:33:24.471]                       }
[10:33:24.471]                       else if (inherits(cond, "condition")) {
[10:33:24.471]                         if (!is.null(pattern)) {
[10:33:24.471]                           computeRestarts <- base::computeRestarts
[10:33:24.471]                           grepl <- base::grepl
[10:33:24.471]                           restarts <- computeRestarts(cond)
[10:33:24.471]                           for (restart in restarts) {
[10:33:24.471]                             name <- restart$name
[10:33:24.471]                             if (is.null(name)) 
[10:33:24.471]                               next
[10:33:24.471]                             if (!grepl(pattern, name)) 
[10:33:24.471]                               next
[10:33:24.471]                             invokeRestart(restart)
[10:33:24.471]                             muffled <- TRUE
[10:33:24.471]                             break
[10:33:24.471]                           }
[10:33:24.471]                         }
[10:33:24.471]                       }
[10:33:24.471]                       invisible(muffled)
[10:33:24.471]                     }
[10:33:24.471]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.471]                   }
[10:33:24.471]                 }
[10:33:24.471]                 else {
[10:33:24.471]                   if (TRUE) {
[10:33:24.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.471]                     {
[10:33:24.471]                       inherits <- base::inherits
[10:33:24.471]                       invokeRestart <- base::invokeRestart
[10:33:24.471]                       is.null <- base::is.null
[10:33:24.471]                       muffled <- FALSE
[10:33:24.471]                       if (inherits(cond, "message")) {
[10:33:24.471]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.471]                         if (muffled) 
[10:33:24.471]                           invokeRestart("muffleMessage")
[10:33:24.471]                       }
[10:33:24.471]                       else if (inherits(cond, "warning")) {
[10:33:24.471]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.471]                         if (muffled) 
[10:33:24.471]                           invokeRestart("muffleWarning")
[10:33:24.471]                       }
[10:33:24.471]                       else if (inherits(cond, "condition")) {
[10:33:24.471]                         if (!is.null(pattern)) {
[10:33:24.471]                           computeRestarts <- base::computeRestarts
[10:33:24.471]                           grepl <- base::grepl
[10:33:24.471]                           restarts <- computeRestarts(cond)
[10:33:24.471]                           for (restart in restarts) {
[10:33:24.471]                             name <- restart$name
[10:33:24.471]                             if (is.null(name)) 
[10:33:24.471]                               next
[10:33:24.471]                             if (!grepl(pattern, name)) 
[10:33:24.471]                               next
[10:33:24.471]                             invokeRestart(restart)
[10:33:24.471]                             muffled <- TRUE
[10:33:24.471]                             break
[10:33:24.471]                           }
[10:33:24.471]                         }
[10:33:24.471]                       }
[10:33:24.471]                       invisible(muffled)
[10:33:24.471]                     }
[10:33:24.471]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.471]                   }
[10:33:24.471]                 }
[10:33:24.471]             }
[10:33:24.471]         }))
[10:33:24.471]     }, error = function(ex) {
[10:33:24.471]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.471]                 ...future.rng), started = ...future.startTime, 
[10:33:24.471]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.471]             version = "1.8"), class = "FutureResult")
[10:33:24.471]     }, finally = {
[10:33:24.471]         if (!identical(...future.workdir, getwd())) 
[10:33:24.471]             setwd(...future.workdir)
[10:33:24.471]         {
[10:33:24.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.471]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.471]             }
[10:33:24.471]             base::options(...future.oldOptions)
[10:33:24.471]             if (.Platform$OS.type == "windows") {
[10:33:24.471]                 old_names <- names(...future.oldEnvVars)
[10:33:24.471]                 envs <- base::Sys.getenv()
[10:33:24.471]                 names <- names(envs)
[10:33:24.471]                 common <- intersect(names, old_names)
[10:33:24.471]                 added <- setdiff(names, old_names)
[10:33:24.471]                 removed <- setdiff(old_names, names)
[10:33:24.471]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.471]                   envs[common]]
[10:33:24.471]                 NAMES <- toupper(changed)
[10:33:24.471]                 args <- list()
[10:33:24.471]                 for (kk in seq_along(NAMES)) {
[10:33:24.471]                   name <- changed[[kk]]
[10:33:24.471]                   NAME <- NAMES[[kk]]
[10:33:24.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.471]                     next
[10:33:24.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.471]                 }
[10:33:24.471]                 NAMES <- toupper(added)
[10:33:24.471]                 for (kk in seq_along(NAMES)) {
[10:33:24.471]                   name <- added[[kk]]
[10:33:24.471]                   NAME <- NAMES[[kk]]
[10:33:24.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.471]                     next
[10:33:24.471]                   args[[name]] <- ""
[10:33:24.471]                 }
[10:33:24.471]                 NAMES <- toupper(removed)
[10:33:24.471]                 for (kk in seq_along(NAMES)) {
[10:33:24.471]                   name <- removed[[kk]]
[10:33:24.471]                   NAME <- NAMES[[kk]]
[10:33:24.471]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.471]                     next
[10:33:24.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.471]                 }
[10:33:24.471]                 if (length(args) > 0) 
[10:33:24.471]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.471]             }
[10:33:24.471]             else {
[10:33:24.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.471]             }
[10:33:24.471]             {
[10:33:24.471]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.471]                   0L) {
[10:33:24.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.471]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.471]                   base::options(opts)
[10:33:24.471]                 }
[10:33:24.471]                 {
[10:33:24.471]                   {
[10:33:24.471]                     NULL
[10:33:24.471]                     RNGkind("Mersenne-Twister")
[10:33:24.471]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.471]                       inherits = FALSE)
[10:33:24.471]                   }
[10:33:24.471]                   options(future.plan = NULL)
[10:33:24.471]                   if (is.na(NA_character_)) 
[10:33:24.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.471]                     .init = FALSE)
[10:33:24.471]                 }
[10:33:24.471]             }
[10:33:24.471]         }
[10:33:24.471]     })
[10:33:24.471]     if (TRUE) {
[10:33:24.471]         base::sink(type = "output", split = FALSE)
[10:33:24.471]         if (TRUE) {
[10:33:24.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.471]         }
[10:33:24.471]         else {
[10:33:24.471]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.471]         }
[10:33:24.471]         base::close(...future.stdout)
[10:33:24.471]         ...future.stdout <- NULL
[10:33:24.471]     }
[10:33:24.471]     ...future.result$conditions <- ...future.conditions
[10:33:24.471]     ...future.result$finished <- base::Sys.time()
[10:33:24.471]     ...future.result
[10:33:24.471] }
[10:33:24.473] plan(): Setting new future strategy stack:
[10:33:24.473] List of future strategies:
[10:33:24.473] 1. sequential:
[10:33:24.473]    - args: function (..., envir = parent.frame())
[10:33:24.473]    - tweaked: FALSE
[10:33:24.473]    - call: NULL
[10:33:24.474] plan(): nbrOfWorkers() = 1
[10:33:24.474] plan(): Setting new future strategy stack:
[10:33:24.475] List of future strategies:
[10:33:24.475] 1. multicore:
[10:33:24.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.475]    - tweaked: FALSE
[10:33:24.475]    - call: plan(multicore)
[10:33:24.478] plan(): nbrOfWorkers() = 1
[10:33:24.478] SequentialFuture started (and completed)
[10:33:24.478] signalConditions() ...
[10:33:24.478]  - include = ‘immediateCondition’
[10:33:24.479]  - exclude = 
[10:33:24.479]  - resignal = FALSE
[10:33:24.479]  - Number of conditions: 1
[10:33:24.479] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:24.479] signalConditions() ...
[10:33:24.479]  - include = ‘immediateCondition’
[10:33:24.480]  - exclude = 
[10:33:24.480]  - resignal = FALSE
[10:33:24.480]  - Number of conditions: 1
[10:33:24.480] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:33:24.480] signalConditions() ...
[10:33:24.480]  - include = ‘immediateCondition’
[10:33:24.480]  - exclude = 
[10:33:24.480]  - resignal = FALSE
[10:33:24.480]  - Number of conditions: 1
[10:33:24.481] signalConditions() ... done
[10:33:24.481] Future state: ‘finished’
[10:33:24.481] signalConditions() ...
[10:33:24.481]  - include = ‘condition’
[10:33:24.481]  - exclude = ‘immediateCondition’
[10:33:24.481]  - resignal = TRUE
[10:33:24.481]  - Number of conditions: 1
[10:33:24.481]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:24.481] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:33:24.482] signalConditions() ...
[10:33:24.482]  - include = ‘immediateCondition’
[10:33:24.482]  - exclude = 
[10:33:24.482]  - resignal = FALSE
[10:33:24.482]  - Number of conditions: 1
[10:33:24.482] signalConditions() ... done
[10:33:24.482] Future state: ‘finished’
[10:33:24.483] signalConditions() ...
[10:33:24.483]  - include = ‘condition’
[10:33:24.483]  - exclude = ‘immediateCondition’
[10:33:24.483]  - resignal = TRUE
[10:33:24.483]  - Number of conditions: 1
[10:33:24.483]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:24.483] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:33:24.486] getGlobalsAndPackages() ...
[10:33:24.487] Searching for globals...
[10:33:24.495] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[10:33:24.495] Searching for globals ... DONE
[10:33:24.496] Resolving globals: FALSE
[10:33:24.496] 
[10:33:24.496] 
[10:33:24.496] getGlobalsAndPackages() ... DONE
[10:33:24.497] Packages needed by the future expression (n = 0): <none>
[10:33:24.497] Packages needed by future strategies (n = 0): <none>
[10:33:24.497] {
[10:33:24.497]     {
[10:33:24.497]         {
[10:33:24.497]             ...future.startTime <- base::Sys.time()
[10:33:24.497]             {
[10:33:24.497]                 {
[10:33:24.497]                   {
[10:33:24.497]                     base::local({
[10:33:24.497]                       has_future <- base::requireNamespace("future", 
[10:33:24.497]                         quietly = TRUE)
[10:33:24.497]                       if (has_future) {
[10:33:24.497]                         ns <- base::getNamespace("future")
[10:33:24.497]                         version <- ns[[".package"]][["version"]]
[10:33:24.497]                         if (is.null(version)) 
[10:33:24.497]                           version <- utils::packageVersion("future")
[10:33:24.497]                       }
[10:33:24.497]                       else {
[10:33:24.497]                         version <- NULL
[10:33:24.497]                       }
[10:33:24.497]                       if (!has_future || version < "1.8.0") {
[10:33:24.497]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.497]                           "", base::R.version$version.string), 
[10:33:24.497]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.497]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.497]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.497]                             "release", "version")], collapse = " "), 
[10:33:24.497]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.497]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.497]                           info)
[10:33:24.497]                         info <- base::paste(info, collapse = "; ")
[10:33:24.497]                         if (!has_future) {
[10:33:24.497]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.497]                             info)
[10:33:24.497]                         }
[10:33:24.497]                         else {
[10:33:24.497]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.497]                             info, version)
[10:33:24.497]                         }
[10:33:24.497]                         base::stop(msg)
[10:33:24.497]                       }
[10:33:24.497]                     })
[10:33:24.497]                   }
[10:33:24.497]                   ...future.strategy.old <- future::plan("list")
[10:33:24.497]                   options(future.plan = NULL)
[10:33:24.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.497]                 }
[10:33:24.497]                 ...future.workdir <- getwd()
[10:33:24.497]             }
[10:33:24.497]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.497]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.497]         }
[10:33:24.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.497]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.497]             base::names(...future.oldOptions))
[10:33:24.497]     }
[10:33:24.497]     if (FALSE) {
[10:33:24.497]     }
[10:33:24.497]     else {
[10:33:24.497]         if (TRUE) {
[10:33:24.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.497]                 open = "w")
[10:33:24.497]         }
[10:33:24.497]         else {
[10:33:24.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.497]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.497]         }
[10:33:24.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.497]             base::sink(type = "output", split = FALSE)
[10:33:24.497]             base::close(...future.stdout)
[10:33:24.497]         }, add = TRUE)
[10:33:24.497]     }
[10:33:24.497]     ...future.frame <- base::sys.nframe()
[10:33:24.497]     ...future.conditions <- base::list()
[10:33:24.497]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.497]     if (FALSE) {
[10:33:24.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.497]     }
[10:33:24.497]     ...future.result <- base::tryCatch({
[10:33:24.497]         base::withCallingHandlers({
[10:33:24.497]             ...future.value <- base::withVisible(base::local({
[10:33:24.497]                 stop(structure(list(message = "boom"), class = c("MyError", 
[10:33:24.497]                   "error", "condition")))
[10:33:24.497]             }))
[10:33:24.497]             future::FutureResult(value = ...future.value$value, 
[10:33:24.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.497]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.497]                     ...future.globalenv.names))
[10:33:24.497]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.497]         }, condition = base::local({
[10:33:24.497]             c <- base::c
[10:33:24.497]             inherits <- base::inherits
[10:33:24.497]             invokeRestart <- base::invokeRestart
[10:33:24.497]             length <- base::length
[10:33:24.497]             list <- base::list
[10:33:24.497]             seq.int <- base::seq.int
[10:33:24.497]             signalCondition <- base::signalCondition
[10:33:24.497]             sys.calls <- base::sys.calls
[10:33:24.497]             `[[` <- base::`[[`
[10:33:24.497]             `+` <- base::`+`
[10:33:24.497]             `<<-` <- base::`<<-`
[10:33:24.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.497]                   3L)]
[10:33:24.497]             }
[10:33:24.497]             function(cond) {
[10:33:24.497]                 is_error <- inherits(cond, "error")
[10:33:24.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.497]                   NULL)
[10:33:24.497]                 if (is_error) {
[10:33:24.497]                   sessionInformation <- function() {
[10:33:24.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.497]                       search = base::search(), system = base::Sys.info())
[10:33:24.497]                   }
[10:33:24.497]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.497]                     cond$call), session = sessionInformation(), 
[10:33:24.497]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.497]                   signalCondition(cond)
[10:33:24.497]                 }
[10:33:24.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.497]                 "immediateCondition"))) {
[10:33:24.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.497]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.497]                   if (TRUE && !signal) {
[10:33:24.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.497]                     {
[10:33:24.497]                       inherits <- base::inherits
[10:33:24.497]                       invokeRestart <- base::invokeRestart
[10:33:24.497]                       is.null <- base::is.null
[10:33:24.497]                       muffled <- FALSE
[10:33:24.497]                       if (inherits(cond, "message")) {
[10:33:24.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.497]                         if (muffled) 
[10:33:24.497]                           invokeRestart("muffleMessage")
[10:33:24.497]                       }
[10:33:24.497]                       else if (inherits(cond, "warning")) {
[10:33:24.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.497]                         if (muffled) 
[10:33:24.497]                           invokeRestart("muffleWarning")
[10:33:24.497]                       }
[10:33:24.497]                       else if (inherits(cond, "condition")) {
[10:33:24.497]                         if (!is.null(pattern)) {
[10:33:24.497]                           computeRestarts <- base::computeRestarts
[10:33:24.497]                           grepl <- base::grepl
[10:33:24.497]                           restarts <- computeRestarts(cond)
[10:33:24.497]                           for (restart in restarts) {
[10:33:24.497]                             name <- restart$name
[10:33:24.497]                             if (is.null(name)) 
[10:33:24.497]                               next
[10:33:24.497]                             if (!grepl(pattern, name)) 
[10:33:24.497]                               next
[10:33:24.497]                             invokeRestart(restart)
[10:33:24.497]                             muffled <- TRUE
[10:33:24.497]                             break
[10:33:24.497]                           }
[10:33:24.497]                         }
[10:33:24.497]                       }
[10:33:24.497]                       invisible(muffled)
[10:33:24.497]                     }
[10:33:24.497]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.497]                   }
[10:33:24.497]                 }
[10:33:24.497]                 else {
[10:33:24.497]                   if (TRUE) {
[10:33:24.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.497]                     {
[10:33:24.497]                       inherits <- base::inherits
[10:33:24.497]                       invokeRestart <- base::invokeRestart
[10:33:24.497]                       is.null <- base::is.null
[10:33:24.497]                       muffled <- FALSE
[10:33:24.497]                       if (inherits(cond, "message")) {
[10:33:24.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.497]                         if (muffled) 
[10:33:24.497]                           invokeRestart("muffleMessage")
[10:33:24.497]                       }
[10:33:24.497]                       else if (inherits(cond, "warning")) {
[10:33:24.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.497]                         if (muffled) 
[10:33:24.497]                           invokeRestart("muffleWarning")
[10:33:24.497]                       }
[10:33:24.497]                       else if (inherits(cond, "condition")) {
[10:33:24.497]                         if (!is.null(pattern)) {
[10:33:24.497]                           computeRestarts <- base::computeRestarts
[10:33:24.497]                           grepl <- base::grepl
[10:33:24.497]                           restarts <- computeRestarts(cond)
[10:33:24.497]                           for (restart in restarts) {
[10:33:24.497]                             name <- restart$name
[10:33:24.497]                             if (is.null(name)) 
[10:33:24.497]                               next
[10:33:24.497]                             if (!grepl(pattern, name)) 
[10:33:24.497]                               next
[10:33:24.497]                             invokeRestart(restart)
[10:33:24.497]                             muffled <- TRUE
[10:33:24.497]                             break
[10:33:24.497]                           }
[10:33:24.497]                         }
[10:33:24.497]                       }
[10:33:24.497]                       invisible(muffled)
[10:33:24.497]                     }
[10:33:24.497]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.497]                   }
[10:33:24.497]                 }
[10:33:24.497]             }
[10:33:24.497]         }))
[10:33:24.497]     }, error = function(ex) {
[10:33:24.497]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.497]                 ...future.rng), started = ...future.startTime, 
[10:33:24.497]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.497]             version = "1.8"), class = "FutureResult")
[10:33:24.497]     }, finally = {
[10:33:24.497]         if (!identical(...future.workdir, getwd())) 
[10:33:24.497]             setwd(...future.workdir)
[10:33:24.497]         {
[10:33:24.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.497]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.497]             }
[10:33:24.497]             base::options(...future.oldOptions)
[10:33:24.497]             if (.Platform$OS.type == "windows") {
[10:33:24.497]                 old_names <- names(...future.oldEnvVars)
[10:33:24.497]                 envs <- base::Sys.getenv()
[10:33:24.497]                 names <- names(envs)
[10:33:24.497]                 common <- intersect(names, old_names)
[10:33:24.497]                 added <- setdiff(names, old_names)
[10:33:24.497]                 removed <- setdiff(old_names, names)
[10:33:24.497]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.497]                   envs[common]]
[10:33:24.497]                 NAMES <- toupper(changed)
[10:33:24.497]                 args <- list()
[10:33:24.497]                 for (kk in seq_along(NAMES)) {
[10:33:24.497]                   name <- changed[[kk]]
[10:33:24.497]                   NAME <- NAMES[[kk]]
[10:33:24.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.497]                     next
[10:33:24.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.497]                 }
[10:33:24.497]                 NAMES <- toupper(added)
[10:33:24.497]                 for (kk in seq_along(NAMES)) {
[10:33:24.497]                   name <- added[[kk]]
[10:33:24.497]                   NAME <- NAMES[[kk]]
[10:33:24.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.497]                     next
[10:33:24.497]                   args[[name]] <- ""
[10:33:24.497]                 }
[10:33:24.497]                 NAMES <- toupper(removed)
[10:33:24.497]                 for (kk in seq_along(NAMES)) {
[10:33:24.497]                   name <- removed[[kk]]
[10:33:24.497]                   NAME <- NAMES[[kk]]
[10:33:24.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.497]                     next
[10:33:24.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.497]                 }
[10:33:24.497]                 if (length(args) > 0) 
[10:33:24.497]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.497]             }
[10:33:24.497]             else {
[10:33:24.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.497]             }
[10:33:24.497]             {
[10:33:24.497]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.497]                   0L) {
[10:33:24.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.497]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.497]                   base::options(opts)
[10:33:24.497]                 }
[10:33:24.497]                 {
[10:33:24.497]                   {
[10:33:24.497]                     NULL
[10:33:24.497]                     RNGkind("Mersenne-Twister")
[10:33:24.497]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.497]                       inherits = FALSE)
[10:33:24.497]                   }
[10:33:24.497]                   options(future.plan = NULL)
[10:33:24.497]                   if (is.na(NA_character_)) 
[10:33:24.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.497]                     .init = FALSE)
[10:33:24.497]                 }
[10:33:24.497]             }
[10:33:24.497]         }
[10:33:24.497]     })
[10:33:24.497]     if (TRUE) {
[10:33:24.497]         base::sink(type = "output", split = FALSE)
[10:33:24.497]         if (TRUE) {
[10:33:24.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.497]         }
[10:33:24.497]         else {
[10:33:24.497]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.497]         }
[10:33:24.497]         base::close(...future.stdout)
[10:33:24.497]         ...future.stdout <- NULL
[10:33:24.497]     }
[10:33:24.497]     ...future.result$conditions <- ...future.conditions
[10:33:24.497]     ...future.result$finished <- base::Sys.time()
[10:33:24.497]     ...future.result
[10:33:24.497] }
[10:33:24.499] plan(): Setting new future strategy stack:
[10:33:24.499] List of future strategies:
[10:33:24.499] 1. sequential:
[10:33:24.499]    - args: function (..., envir = parent.frame())
[10:33:24.499]    - tweaked: FALSE
[10:33:24.499]    - call: NULL
[10:33:24.500] plan(): nbrOfWorkers() = 1
[10:33:24.500] plan(): Setting new future strategy stack:
[10:33:24.500] List of future strategies:
[10:33:24.500] 1. multicore:
[10:33:24.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.500]    - tweaked: FALSE
[10:33:24.500]    - call: plan(multicore)
[10:33:24.504] plan(): nbrOfWorkers() = 1
[10:33:24.504] SequentialFuture started (and completed)
[10:33:24.504] signalConditions() ...
[10:33:24.504]  - include = ‘immediateCondition’
[10:33:24.504]  - exclude = 
[10:33:24.504]  - resignal = FALSE
[10:33:24.504]  - Number of conditions: 1
[10:33:24.504] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:24.505] signalConditions() ...
[10:33:24.505]  - include = ‘immediateCondition’
[10:33:24.505]  - exclude = 
[10:33:24.505]  - resignal = FALSE
[10:33:24.505]  - Number of conditions: 1
[10:33:24.506] signalConditions() ... done
<MyError: boom>
[10:33:24.506] signalConditions() ...
[10:33:24.506]  - include = ‘immediateCondition’
[10:33:24.506]  - exclude = 
[10:33:24.506]  - resignal = FALSE
[10:33:24.506]  - Number of conditions: 1
[10:33:24.506] signalConditions() ... done
[10:33:24.506] Future state: ‘finished’
[10:33:24.506] signalConditions() ...
[10:33:24.507]  - include = ‘condition’
[10:33:24.507]  - exclude = ‘immediateCondition’
[10:33:24.507]  - resignal = TRUE
[10:33:24.507]  - Number of conditions: 1
[10:33:24.507]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:33:24.507] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[10:33:24.510] getGlobalsAndPackages() ...
[10:33:24.510] Searching for globals...
[10:33:24.511] - globals found: [1] ‘{’
[10:33:24.511] Searching for globals ... DONE
[10:33:24.511] Resolving globals: FALSE
[10:33:24.511] 
[10:33:24.511] 
[10:33:24.511] getGlobalsAndPackages() ... DONE
[10:33:24.512] Packages needed by the future expression (n = 0): <none>
[10:33:24.512] Packages needed by future strategies (n = 0): <none>
[10:33:24.512] {
[10:33:24.512]     {
[10:33:24.512]         {
[10:33:24.512]             ...future.startTime <- base::Sys.time()
[10:33:24.512]             {
[10:33:24.512]                 {
[10:33:24.512]                   {
[10:33:24.512]                     base::local({
[10:33:24.512]                       has_future <- base::requireNamespace("future", 
[10:33:24.512]                         quietly = TRUE)
[10:33:24.512]                       if (has_future) {
[10:33:24.512]                         ns <- base::getNamespace("future")
[10:33:24.512]                         version <- ns[[".package"]][["version"]]
[10:33:24.512]                         if (is.null(version)) 
[10:33:24.512]                           version <- utils::packageVersion("future")
[10:33:24.512]                       }
[10:33:24.512]                       else {
[10:33:24.512]                         version <- NULL
[10:33:24.512]                       }
[10:33:24.512]                       if (!has_future || version < "1.8.0") {
[10:33:24.512]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.512]                           "", base::R.version$version.string), 
[10:33:24.512]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.512]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.512]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.512]                             "release", "version")], collapse = " "), 
[10:33:24.512]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.512]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.512]                           info)
[10:33:24.512]                         info <- base::paste(info, collapse = "; ")
[10:33:24.512]                         if (!has_future) {
[10:33:24.512]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.512]                             info)
[10:33:24.512]                         }
[10:33:24.512]                         else {
[10:33:24.512]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.512]                             info, version)
[10:33:24.512]                         }
[10:33:24.512]                         base::stop(msg)
[10:33:24.512]                       }
[10:33:24.512]                     })
[10:33:24.512]                   }
[10:33:24.512]                   ...future.strategy.old <- future::plan("list")
[10:33:24.512]                   options(future.plan = NULL)
[10:33:24.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.512]                 }
[10:33:24.512]                 ...future.workdir <- getwd()
[10:33:24.512]             }
[10:33:24.512]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.512]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.512]         }
[10:33:24.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.512]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.512]             base::names(...future.oldOptions))
[10:33:24.512]     }
[10:33:24.512]     if (FALSE) {
[10:33:24.512]     }
[10:33:24.512]     else {
[10:33:24.512]         if (TRUE) {
[10:33:24.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.512]                 open = "w")
[10:33:24.512]         }
[10:33:24.512]         else {
[10:33:24.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.512]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.512]         }
[10:33:24.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.512]             base::sink(type = "output", split = FALSE)
[10:33:24.512]             base::close(...future.stdout)
[10:33:24.512]         }, add = TRUE)
[10:33:24.512]     }
[10:33:24.512]     ...future.frame <- base::sys.nframe()
[10:33:24.512]     ...future.conditions <- base::list()
[10:33:24.512]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.512]     if (FALSE) {
[10:33:24.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.512]     }
[10:33:24.512]     ...future.result <- base::tryCatch({
[10:33:24.512]         base::withCallingHandlers({
[10:33:24.512]             ...future.value <- base::withVisible(base::local({
[10:33:24.512]                 42L
[10:33:24.512]             }))
[10:33:24.512]             future::FutureResult(value = ...future.value$value, 
[10:33:24.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.512]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.512]                     ...future.globalenv.names))
[10:33:24.512]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.512]         }, condition = base::local({
[10:33:24.512]             c <- base::c
[10:33:24.512]             inherits <- base::inherits
[10:33:24.512]             invokeRestart <- base::invokeRestart
[10:33:24.512]             length <- base::length
[10:33:24.512]             list <- base::list
[10:33:24.512]             seq.int <- base::seq.int
[10:33:24.512]             signalCondition <- base::signalCondition
[10:33:24.512]             sys.calls <- base::sys.calls
[10:33:24.512]             `[[` <- base::`[[`
[10:33:24.512]             `+` <- base::`+`
[10:33:24.512]             `<<-` <- base::`<<-`
[10:33:24.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.512]                   3L)]
[10:33:24.512]             }
[10:33:24.512]             function(cond) {
[10:33:24.512]                 is_error <- inherits(cond, "error")
[10:33:24.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.512]                   NULL)
[10:33:24.512]                 if (is_error) {
[10:33:24.512]                   sessionInformation <- function() {
[10:33:24.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.512]                       search = base::search(), system = base::Sys.info())
[10:33:24.512]                   }
[10:33:24.512]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.512]                     cond$call), session = sessionInformation(), 
[10:33:24.512]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.512]                   signalCondition(cond)
[10:33:24.512]                 }
[10:33:24.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.512]                 "immediateCondition"))) {
[10:33:24.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.512]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.512]                   if (TRUE && !signal) {
[10:33:24.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.512]                     {
[10:33:24.512]                       inherits <- base::inherits
[10:33:24.512]                       invokeRestart <- base::invokeRestart
[10:33:24.512]                       is.null <- base::is.null
[10:33:24.512]                       muffled <- FALSE
[10:33:24.512]                       if (inherits(cond, "message")) {
[10:33:24.512]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.512]                         if (muffled) 
[10:33:24.512]                           invokeRestart("muffleMessage")
[10:33:24.512]                       }
[10:33:24.512]                       else if (inherits(cond, "warning")) {
[10:33:24.512]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.512]                         if (muffled) 
[10:33:24.512]                           invokeRestart("muffleWarning")
[10:33:24.512]                       }
[10:33:24.512]                       else if (inherits(cond, "condition")) {
[10:33:24.512]                         if (!is.null(pattern)) {
[10:33:24.512]                           computeRestarts <- base::computeRestarts
[10:33:24.512]                           grepl <- base::grepl
[10:33:24.512]                           restarts <- computeRestarts(cond)
[10:33:24.512]                           for (restart in restarts) {
[10:33:24.512]                             name <- restart$name
[10:33:24.512]                             if (is.null(name)) 
[10:33:24.512]                               next
[10:33:24.512]                             if (!grepl(pattern, name)) 
[10:33:24.512]                               next
[10:33:24.512]                             invokeRestart(restart)
[10:33:24.512]                             muffled <- TRUE
[10:33:24.512]                             break
[10:33:24.512]                           }
[10:33:24.512]                         }
[10:33:24.512]                       }
[10:33:24.512]                       invisible(muffled)
[10:33:24.512]                     }
[10:33:24.512]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.512]                   }
[10:33:24.512]                 }
[10:33:24.512]                 else {
[10:33:24.512]                   if (TRUE) {
[10:33:24.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.512]                     {
[10:33:24.512]                       inherits <- base::inherits
[10:33:24.512]                       invokeRestart <- base::invokeRestart
[10:33:24.512]                       is.null <- base::is.null
[10:33:24.512]                       muffled <- FALSE
[10:33:24.512]                       if (inherits(cond, "message")) {
[10:33:24.512]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.512]                         if (muffled) 
[10:33:24.512]                           invokeRestart("muffleMessage")
[10:33:24.512]                       }
[10:33:24.512]                       else if (inherits(cond, "warning")) {
[10:33:24.512]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.512]                         if (muffled) 
[10:33:24.512]                           invokeRestart("muffleWarning")
[10:33:24.512]                       }
[10:33:24.512]                       else if (inherits(cond, "condition")) {
[10:33:24.512]                         if (!is.null(pattern)) {
[10:33:24.512]                           computeRestarts <- base::computeRestarts
[10:33:24.512]                           grepl <- base::grepl
[10:33:24.512]                           restarts <- computeRestarts(cond)
[10:33:24.512]                           for (restart in restarts) {
[10:33:24.512]                             name <- restart$name
[10:33:24.512]                             if (is.null(name)) 
[10:33:24.512]                               next
[10:33:24.512]                             if (!grepl(pattern, name)) 
[10:33:24.512]                               next
[10:33:24.512]                             invokeRestart(restart)
[10:33:24.512]                             muffled <- TRUE
[10:33:24.512]                             break
[10:33:24.512]                           }
[10:33:24.512]                         }
[10:33:24.512]                       }
[10:33:24.512]                       invisible(muffled)
[10:33:24.512]                     }
[10:33:24.512]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.512]                   }
[10:33:24.512]                 }
[10:33:24.512]             }
[10:33:24.512]         }))
[10:33:24.512]     }, error = function(ex) {
[10:33:24.512]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.512]                 ...future.rng), started = ...future.startTime, 
[10:33:24.512]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.512]             version = "1.8"), class = "FutureResult")
[10:33:24.512]     }, finally = {
[10:33:24.512]         if (!identical(...future.workdir, getwd())) 
[10:33:24.512]             setwd(...future.workdir)
[10:33:24.512]         {
[10:33:24.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.512]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.512]             }
[10:33:24.512]             base::options(...future.oldOptions)
[10:33:24.512]             if (.Platform$OS.type == "windows") {
[10:33:24.512]                 old_names <- names(...future.oldEnvVars)
[10:33:24.512]                 envs <- base::Sys.getenv()
[10:33:24.512]                 names <- names(envs)
[10:33:24.512]                 common <- intersect(names, old_names)
[10:33:24.512]                 added <- setdiff(names, old_names)
[10:33:24.512]                 removed <- setdiff(old_names, names)
[10:33:24.512]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.512]                   envs[common]]
[10:33:24.512]                 NAMES <- toupper(changed)
[10:33:24.512]                 args <- list()
[10:33:24.512]                 for (kk in seq_along(NAMES)) {
[10:33:24.512]                   name <- changed[[kk]]
[10:33:24.512]                   NAME <- NAMES[[kk]]
[10:33:24.512]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.512]                     next
[10:33:24.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.512]                 }
[10:33:24.512]                 NAMES <- toupper(added)
[10:33:24.512]                 for (kk in seq_along(NAMES)) {
[10:33:24.512]                   name <- added[[kk]]
[10:33:24.512]                   NAME <- NAMES[[kk]]
[10:33:24.512]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.512]                     next
[10:33:24.512]                   args[[name]] <- ""
[10:33:24.512]                 }
[10:33:24.512]                 NAMES <- toupper(removed)
[10:33:24.512]                 for (kk in seq_along(NAMES)) {
[10:33:24.512]                   name <- removed[[kk]]
[10:33:24.512]                   NAME <- NAMES[[kk]]
[10:33:24.512]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.512]                     next
[10:33:24.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.512]                 }
[10:33:24.512]                 if (length(args) > 0) 
[10:33:24.512]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.512]             }
[10:33:24.512]             else {
[10:33:24.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.512]             }
[10:33:24.512]             {
[10:33:24.512]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.512]                   0L) {
[10:33:24.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.512]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.512]                   base::options(opts)
[10:33:24.512]                 }
[10:33:24.512]                 {
[10:33:24.512]                   {
[10:33:24.512]                     NULL
[10:33:24.512]                     RNGkind("Mersenne-Twister")
[10:33:24.512]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.512]                       inherits = FALSE)
[10:33:24.512]                   }
[10:33:24.512]                   options(future.plan = NULL)
[10:33:24.512]                   if (is.na(NA_character_)) 
[10:33:24.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.512]                     .init = FALSE)
[10:33:24.512]                 }
[10:33:24.512]             }
[10:33:24.512]         }
[10:33:24.512]     })
[10:33:24.512]     if (TRUE) {
[10:33:24.512]         base::sink(type = "output", split = FALSE)
[10:33:24.512]         if (TRUE) {
[10:33:24.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.512]         }
[10:33:24.512]         else {
[10:33:24.512]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.512]         }
[10:33:24.512]         base::close(...future.stdout)
[10:33:24.512]         ...future.stdout <- NULL
[10:33:24.512]     }
[10:33:24.512]     ...future.result$conditions <- ...future.conditions
[10:33:24.512]     ...future.result$finished <- base::Sys.time()
[10:33:24.512]     ...future.result
[10:33:24.512] }
[10:33:24.514] plan(): Setting new future strategy stack:
[10:33:24.514] List of future strategies:
[10:33:24.514] 1. sequential:
[10:33:24.514]    - args: function (..., envir = parent.frame())
[10:33:24.514]    - tweaked: FALSE
[10:33:24.514]    - call: NULL
[10:33:24.514] plan(): nbrOfWorkers() = 1
[10:33:24.515] plan(): Setting new future strategy stack:
[10:33:24.515] List of future strategies:
[10:33:24.515] 1. multicore:
[10:33:24.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.515]    - tweaked: FALSE
[10:33:24.515]    - call: plan(multicore)
[10:33:24.519] plan(): nbrOfWorkers() = 1
[10:33:24.519] SequentialFuture started (and completed)
[10:33:24.519] resolved() for ‘SequentialFuture’ ...
[10:33:24.519] - state: ‘finished’
[10:33:24.519] - run: TRUE
[10:33:24.519] - result: ‘FutureResult’
[10:33:24.519] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[10:33:24.523] getGlobalsAndPackages() ...
[10:33:24.523] Searching for globals...
[10:33:24.525] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:33:24.525] Searching for globals ... DONE
[10:33:24.525] Resolving globals: FALSE
[10:33:24.526] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.526] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:24.526] - globals: [1] ‘a’
[10:33:24.526] 
[10:33:24.526] getGlobalsAndPackages() ... DONE
[10:33:24.527] Packages needed by the future expression (n = 0): <none>
[10:33:24.527] Packages needed by future strategies (n = 0): <none>
[10:33:24.527] {
[10:33:24.527]     {
[10:33:24.527]         {
[10:33:24.527]             ...future.startTime <- base::Sys.time()
[10:33:24.527]             {
[10:33:24.527]                 {
[10:33:24.527]                   {
[10:33:24.527]                     base::local({
[10:33:24.527]                       has_future <- base::requireNamespace("future", 
[10:33:24.527]                         quietly = TRUE)
[10:33:24.527]                       if (has_future) {
[10:33:24.527]                         ns <- base::getNamespace("future")
[10:33:24.527]                         version <- ns[[".package"]][["version"]]
[10:33:24.527]                         if (is.null(version)) 
[10:33:24.527]                           version <- utils::packageVersion("future")
[10:33:24.527]                       }
[10:33:24.527]                       else {
[10:33:24.527]                         version <- NULL
[10:33:24.527]                       }
[10:33:24.527]                       if (!has_future || version < "1.8.0") {
[10:33:24.527]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.527]                           "", base::R.version$version.string), 
[10:33:24.527]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.527]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.527]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.527]                             "release", "version")], collapse = " "), 
[10:33:24.527]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.527]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.527]                           info)
[10:33:24.527]                         info <- base::paste(info, collapse = "; ")
[10:33:24.527]                         if (!has_future) {
[10:33:24.527]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.527]                             info)
[10:33:24.527]                         }
[10:33:24.527]                         else {
[10:33:24.527]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.527]                             info, version)
[10:33:24.527]                         }
[10:33:24.527]                         base::stop(msg)
[10:33:24.527]                       }
[10:33:24.527]                     })
[10:33:24.527]                   }
[10:33:24.527]                   ...future.strategy.old <- future::plan("list")
[10:33:24.527]                   options(future.plan = NULL)
[10:33:24.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.527]                 }
[10:33:24.527]                 ...future.workdir <- getwd()
[10:33:24.527]             }
[10:33:24.527]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.527]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.527]         }
[10:33:24.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.527]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.527]             base::names(...future.oldOptions))
[10:33:24.527]     }
[10:33:24.527]     if (FALSE) {
[10:33:24.527]     }
[10:33:24.527]     else {
[10:33:24.527]         if (TRUE) {
[10:33:24.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.527]                 open = "w")
[10:33:24.527]         }
[10:33:24.527]         else {
[10:33:24.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.527]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.527]         }
[10:33:24.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.527]             base::sink(type = "output", split = FALSE)
[10:33:24.527]             base::close(...future.stdout)
[10:33:24.527]         }, add = TRUE)
[10:33:24.527]     }
[10:33:24.527]     ...future.frame <- base::sys.nframe()
[10:33:24.527]     ...future.conditions <- base::list()
[10:33:24.527]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.527]     if (FALSE) {
[10:33:24.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.527]     }
[10:33:24.527]     ...future.result <- base::tryCatch({
[10:33:24.527]         base::withCallingHandlers({
[10:33:24.527]             ...future.value <- base::withVisible(base::local({
[10:33:24.527]                 b <- 3
[10:33:24.527]                 c <- 2
[10:33:24.527]                 a * b * c
[10:33:24.527]             }))
[10:33:24.527]             future::FutureResult(value = ...future.value$value, 
[10:33:24.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.527]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.527]                     ...future.globalenv.names))
[10:33:24.527]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.527]         }, condition = base::local({
[10:33:24.527]             c <- base::c
[10:33:24.527]             inherits <- base::inherits
[10:33:24.527]             invokeRestart <- base::invokeRestart
[10:33:24.527]             length <- base::length
[10:33:24.527]             list <- base::list
[10:33:24.527]             seq.int <- base::seq.int
[10:33:24.527]             signalCondition <- base::signalCondition
[10:33:24.527]             sys.calls <- base::sys.calls
[10:33:24.527]             `[[` <- base::`[[`
[10:33:24.527]             `+` <- base::`+`
[10:33:24.527]             `<<-` <- base::`<<-`
[10:33:24.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.527]                   3L)]
[10:33:24.527]             }
[10:33:24.527]             function(cond) {
[10:33:24.527]                 is_error <- inherits(cond, "error")
[10:33:24.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.527]                   NULL)
[10:33:24.527]                 if (is_error) {
[10:33:24.527]                   sessionInformation <- function() {
[10:33:24.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.527]                       search = base::search(), system = base::Sys.info())
[10:33:24.527]                   }
[10:33:24.527]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.527]                     cond$call), session = sessionInformation(), 
[10:33:24.527]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.527]                   signalCondition(cond)
[10:33:24.527]                 }
[10:33:24.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.527]                 "immediateCondition"))) {
[10:33:24.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.527]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.527]                   if (TRUE && !signal) {
[10:33:24.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.527]                     {
[10:33:24.527]                       inherits <- base::inherits
[10:33:24.527]                       invokeRestart <- base::invokeRestart
[10:33:24.527]                       is.null <- base::is.null
[10:33:24.527]                       muffled <- FALSE
[10:33:24.527]                       if (inherits(cond, "message")) {
[10:33:24.527]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.527]                         if (muffled) 
[10:33:24.527]                           invokeRestart("muffleMessage")
[10:33:24.527]                       }
[10:33:24.527]                       else if (inherits(cond, "warning")) {
[10:33:24.527]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.527]                         if (muffled) 
[10:33:24.527]                           invokeRestart("muffleWarning")
[10:33:24.527]                       }
[10:33:24.527]                       else if (inherits(cond, "condition")) {
[10:33:24.527]                         if (!is.null(pattern)) {
[10:33:24.527]                           computeRestarts <- base::computeRestarts
[10:33:24.527]                           grepl <- base::grepl
[10:33:24.527]                           restarts <- computeRestarts(cond)
[10:33:24.527]                           for (restart in restarts) {
[10:33:24.527]                             name <- restart$name
[10:33:24.527]                             if (is.null(name)) 
[10:33:24.527]                               next
[10:33:24.527]                             if (!grepl(pattern, name)) 
[10:33:24.527]                               next
[10:33:24.527]                             invokeRestart(restart)
[10:33:24.527]                             muffled <- TRUE
[10:33:24.527]                             break
[10:33:24.527]                           }
[10:33:24.527]                         }
[10:33:24.527]                       }
[10:33:24.527]                       invisible(muffled)
[10:33:24.527]                     }
[10:33:24.527]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.527]                   }
[10:33:24.527]                 }
[10:33:24.527]                 else {
[10:33:24.527]                   if (TRUE) {
[10:33:24.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.527]                     {
[10:33:24.527]                       inherits <- base::inherits
[10:33:24.527]                       invokeRestart <- base::invokeRestart
[10:33:24.527]                       is.null <- base::is.null
[10:33:24.527]                       muffled <- FALSE
[10:33:24.527]                       if (inherits(cond, "message")) {
[10:33:24.527]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.527]                         if (muffled) 
[10:33:24.527]                           invokeRestart("muffleMessage")
[10:33:24.527]                       }
[10:33:24.527]                       else if (inherits(cond, "warning")) {
[10:33:24.527]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.527]                         if (muffled) 
[10:33:24.527]                           invokeRestart("muffleWarning")
[10:33:24.527]                       }
[10:33:24.527]                       else if (inherits(cond, "condition")) {
[10:33:24.527]                         if (!is.null(pattern)) {
[10:33:24.527]                           computeRestarts <- base::computeRestarts
[10:33:24.527]                           grepl <- base::grepl
[10:33:24.527]                           restarts <- computeRestarts(cond)
[10:33:24.527]                           for (restart in restarts) {
[10:33:24.527]                             name <- restart$name
[10:33:24.527]                             if (is.null(name)) 
[10:33:24.527]                               next
[10:33:24.527]                             if (!grepl(pattern, name)) 
[10:33:24.527]                               next
[10:33:24.527]                             invokeRestart(restart)
[10:33:24.527]                             muffled <- TRUE
[10:33:24.527]                             break
[10:33:24.527]                           }
[10:33:24.527]                         }
[10:33:24.527]                       }
[10:33:24.527]                       invisible(muffled)
[10:33:24.527]                     }
[10:33:24.527]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.527]                   }
[10:33:24.527]                 }
[10:33:24.527]             }
[10:33:24.527]         }))
[10:33:24.527]     }, error = function(ex) {
[10:33:24.527]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.527]                 ...future.rng), started = ...future.startTime, 
[10:33:24.527]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.527]             version = "1.8"), class = "FutureResult")
[10:33:24.527]     }, finally = {
[10:33:24.527]         if (!identical(...future.workdir, getwd())) 
[10:33:24.527]             setwd(...future.workdir)
[10:33:24.527]         {
[10:33:24.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.527]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.527]             }
[10:33:24.527]             base::options(...future.oldOptions)
[10:33:24.527]             if (.Platform$OS.type == "windows") {
[10:33:24.527]                 old_names <- names(...future.oldEnvVars)
[10:33:24.527]                 envs <- base::Sys.getenv()
[10:33:24.527]                 names <- names(envs)
[10:33:24.527]                 common <- intersect(names, old_names)
[10:33:24.527]                 added <- setdiff(names, old_names)
[10:33:24.527]                 removed <- setdiff(old_names, names)
[10:33:24.527]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.527]                   envs[common]]
[10:33:24.527]                 NAMES <- toupper(changed)
[10:33:24.527]                 args <- list()
[10:33:24.527]                 for (kk in seq_along(NAMES)) {
[10:33:24.527]                   name <- changed[[kk]]
[10:33:24.527]                   NAME <- NAMES[[kk]]
[10:33:24.527]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.527]                     next
[10:33:24.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.527]                 }
[10:33:24.527]                 NAMES <- toupper(added)
[10:33:24.527]                 for (kk in seq_along(NAMES)) {
[10:33:24.527]                   name <- added[[kk]]
[10:33:24.527]                   NAME <- NAMES[[kk]]
[10:33:24.527]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.527]                     next
[10:33:24.527]                   args[[name]] <- ""
[10:33:24.527]                 }
[10:33:24.527]                 NAMES <- toupper(removed)
[10:33:24.527]                 for (kk in seq_along(NAMES)) {
[10:33:24.527]                   name <- removed[[kk]]
[10:33:24.527]                   NAME <- NAMES[[kk]]
[10:33:24.527]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.527]                     next
[10:33:24.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.527]                 }
[10:33:24.527]                 if (length(args) > 0) 
[10:33:24.527]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.527]             }
[10:33:24.527]             else {
[10:33:24.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.527]             }
[10:33:24.527]             {
[10:33:24.527]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.527]                   0L) {
[10:33:24.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.527]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.527]                   base::options(opts)
[10:33:24.527]                 }
[10:33:24.527]                 {
[10:33:24.527]                   {
[10:33:24.527]                     NULL
[10:33:24.527]                     RNGkind("Mersenne-Twister")
[10:33:24.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.527]                       inherits = FALSE)
[10:33:24.527]                   }
[10:33:24.527]                   options(future.plan = NULL)
[10:33:24.527]                   if (is.na(NA_character_)) 
[10:33:24.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.527]                     .init = FALSE)
[10:33:24.527]                 }
[10:33:24.527]             }
[10:33:24.527]         }
[10:33:24.527]     })
[10:33:24.527]     if (TRUE) {
[10:33:24.527]         base::sink(type = "output", split = FALSE)
[10:33:24.527]         if (TRUE) {
[10:33:24.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.527]         }
[10:33:24.527]         else {
[10:33:24.527]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.527]         }
[10:33:24.527]         base::close(...future.stdout)
[10:33:24.527]         ...future.stdout <- NULL
[10:33:24.527]     }
[10:33:24.527]     ...future.result$conditions <- ...future.conditions
[10:33:24.527]     ...future.result$finished <- base::Sys.time()
[10:33:24.527]     ...future.result
[10:33:24.527] }
[10:33:24.529] assign_globals() ...
[10:33:24.529] List of 1
[10:33:24.529]  $ a: num 0
[10:33:24.529]  - attr(*, "where")=List of 1
[10:33:24.529]   ..$ a:<environment: R_EmptyEnv> 
[10:33:24.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.529]  - attr(*, "resolved")= logi FALSE
[10:33:24.529]  - attr(*, "total_size")= num 56
[10:33:24.535] - copied ‘a’ to environment
[10:33:24.535] assign_globals() ... done
[10:33:24.536] plan(): Setting new future strategy stack:
[10:33:24.536] List of future strategies:
[10:33:24.536] 1. sequential:
[10:33:24.536]    - args: function (..., envir = parent.frame())
[10:33:24.536]    - tweaked: FALSE
[10:33:24.536]    - call: NULL
[10:33:24.536] plan(): nbrOfWorkers() = 1
[10:33:24.537] plan(): Setting new future strategy stack:
[10:33:24.537] List of future strategies:
[10:33:24.537] 1. multicore:
[10:33:24.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.537]    - tweaked: FALSE
[10:33:24.537]    - call: plan(multicore)
[10:33:24.540] plan(): nbrOfWorkers() = 1
[10:33:24.540] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[10:33:24.544] getGlobalsAndPackages() ...
[10:33:24.545] Searching for globals...
[10:33:24.545] - globals found: [2] ‘{’, ‘ii’
[10:33:24.545] Searching for globals ... DONE
[10:33:24.546] Resolving globals: FALSE
[10:33:24.546] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.546] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.546] - globals: [1] ‘ii’
[10:33:24.546] 
[10:33:24.546] getGlobalsAndPackages() ... DONE
[10:33:24.547] Packages needed by the future expression (n = 0): <none>
[10:33:24.547] Packages needed by future strategies (n = 0): <none>
[10:33:24.547] {
[10:33:24.547]     {
[10:33:24.547]         {
[10:33:24.547]             ...future.startTime <- base::Sys.time()
[10:33:24.547]             {
[10:33:24.547]                 {
[10:33:24.547]                   {
[10:33:24.547]                     base::local({
[10:33:24.547]                       has_future <- base::requireNamespace("future", 
[10:33:24.547]                         quietly = TRUE)
[10:33:24.547]                       if (has_future) {
[10:33:24.547]                         ns <- base::getNamespace("future")
[10:33:24.547]                         version <- ns[[".package"]][["version"]]
[10:33:24.547]                         if (is.null(version)) 
[10:33:24.547]                           version <- utils::packageVersion("future")
[10:33:24.547]                       }
[10:33:24.547]                       else {
[10:33:24.547]                         version <- NULL
[10:33:24.547]                       }
[10:33:24.547]                       if (!has_future || version < "1.8.0") {
[10:33:24.547]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.547]                           "", base::R.version$version.string), 
[10:33:24.547]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.547]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.547]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.547]                             "release", "version")], collapse = " "), 
[10:33:24.547]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.547]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.547]                           info)
[10:33:24.547]                         info <- base::paste(info, collapse = "; ")
[10:33:24.547]                         if (!has_future) {
[10:33:24.547]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.547]                             info)
[10:33:24.547]                         }
[10:33:24.547]                         else {
[10:33:24.547]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.547]                             info, version)
[10:33:24.547]                         }
[10:33:24.547]                         base::stop(msg)
[10:33:24.547]                       }
[10:33:24.547]                     })
[10:33:24.547]                   }
[10:33:24.547]                   ...future.strategy.old <- future::plan("list")
[10:33:24.547]                   options(future.plan = NULL)
[10:33:24.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.547]                 }
[10:33:24.547]                 ...future.workdir <- getwd()
[10:33:24.547]             }
[10:33:24.547]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.547]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.547]         }
[10:33:24.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.547]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.547]             base::names(...future.oldOptions))
[10:33:24.547]     }
[10:33:24.547]     if (FALSE) {
[10:33:24.547]     }
[10:33:24.547]     else {
[10:33:24.547]         if (TRUE) {
[10:33:24.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.547]                 open = "w")
[10:33:24.547]         }
[10:33:24.547]         else {
[10:33:24.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.547]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.547]         }
[10:33:24.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.547]             base::sink(type = "output", split = FALSE)
[10:33:24.547]             base::close(...future.stdout)
[10:33:24.547]         }, add = TRUE)
[10:33:24.547]     }
[10:33:24.547]     ...future.frame <- base::sys.nframe()
[10:33:24.547]     ...future.conditions <- base::list()
[10:33:24.547]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.547]     if (FALSE) {
[10:33:24.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.547]     }
[10:33:24.547]     ...future.result <- base::tryCatch({
[10:33:24.547]         base::withCallingHandlers({
[10:33:24.547]             ...future.value <- base::withVisible(base::local({
[10:33:24.547]                 ii
[10:33:24.547]             }))
[10:33:24.547]             future::FutureResult(value = ...future.value$value, 
[10:33:24.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.547]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.547]                     ...future.globalenv.names))
[10:33:24.547]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.547]         }, condition = base::local({
[10:33:24.547]             c <- base::c
[10:33:24.547]             inherits <- base::inherits
[10:33:24.547]             invokeRestart <- base::invokeRestart
[10:33:24.547]             length <- base::length
[10:33:24.547]             list <- base::list
[10:33:24.547]             seq.int <- base::seq.int
[10:33:24.547]             signalCondition <- base::signalCondition
[10:33:24.547]             sys.calls <- base::sys.calls
[10:33:24.547]             `[[` <- base::`[[`
[10:33:24.547]             `+` <- base::`+`
[10:33:24.547]             `<<-` <- base::`<<-`
[10:33:24.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.547]                   3L)]
[10:33:24.547]             }
[10:33:24.547]             function(cond) {
[10:33:24.547]                 is_error <- inherits(cond, "error")
[10:33:24.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.547]                   NULL)
[10:33:24.547]                 if (is_error) {
[10:33:24.547]                   sessionInformation <- function() {
[10:33:24.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.547]                       search = base::search(), system = base::Sys.info())
[10:33:24.547]                   }
[10:33:24.547]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.547]                     cond$call), session = sessionInformation(), 
[10:33:24.547]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.547]                   signalCondition(cond)
[10:33:24.547]                 }
[10:33:24.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.547]                 "immediateCondition"))) {
[10:33:24.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.547]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.547]                   if (TRUE && !signal) {
[10:33:24.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.547]                     {
[10:33:24.547]                       inherits <- base::inherits
[10:33:24.547]                       invokeRestart <- base::invokeRestart
[10:33:24.547]                       is.null <- base::is.null
[10:33:24.547]                       muffled <- FALSE
[10:33:24.547]                       if (inherits(cond, "message")) {
[10:33:24.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.547]                         if (muffled) 
[10:33:24.547]                           invokeRestart("muffleMessage")
[10:33:24.547]                       }
[10:33:24.547]                       else if (inherits(cond, "warning")) {
[10:33:24.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.547]                         if (muffled) 
[10:33:24.547]                           invokeRestart("muffleWarning")
[10:33:24.547]                       }
[10:33:24.547]                       else if (inherits(cond, "condition")) {
[10:33:24.547]                         if (!is.null(pattern)) {
[10:33:24.547]                           computeRestarts <- base::computeRestarts
[10:33:24.547]                           grepl <- base::grepl
[10:33:24.547]                           restarts <- computeRestarts(cond)
[10:33:24.547]                           for (restart in restarts) {
[10:33:24.547]                             name <- restart$name
[10:33:24.547]                             if (is.null(name)) 
[10:33:24.547]                               next
[10:33:24.547]                             if (!grepl(pattern, name)) 
[10:33:24.547]                               next
[10:33:24.547]                             invokeRestart(restart)
[10:33:24.547]                             muffled <- TRUE
[10:33:24.547]                             break
[10:33:24.547]                           }
[10:33:24.547]                         }
[10:33:24.547]                       }
[10:33:24.547]                       invisible(muffled)
[10:33:24.547]                     }
[10:33:24.547]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.547]                   }
[10:33:24.547]                 }
[10:33:24.547]                 else {
[10:33:24.547]                   if (TRUE) {
[10:33:24.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.547]                     {
[10:33:24.547]                       inherits <- base::inherits
[10:33:24.547]                       invokeRestart <- base::invokeRestart
[10:33:24.547]                       is.null <- base::is.null
[10:33:24.547]                       muffled <- FALSE
[10:33:24.547]                       if (inherits(cond, "message")) {
[10:33:24.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.547]                         if (muffled) 
[10:33:24.547]                           invokeRestart("muffleMessage")
[10:33:24.547]                       }
[10:33:24.547]                       else if (inherits(cond, "warning")) {
[10:33:24.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.547]                         if (muffled) 
[10:33:24.547]                           invokeRestart("muffleWarning")
[10:33:24.547]                       }
[10:33:24.547]                       else if (inherits(cond, "condition")) {
[10:33:24.547]                         if (!is.null(pattern)) {
[10:33:24.547]                           computeRestarts <- base::computeRestarts
[10:33:24.547]                           grepl <- base::grepl
[10:33:24.547]                           restarts <- computeRestarts(cond)
[10:33:24.547]                           for (restart in restarts) {
[10:33:24.547]                             name <- restart$name
[10:33:24.547]                             if (is.null(name)) 
[10:33:24.547]                               next
[10:33:24.547]                             if (!grepl(pattern, name)) 
[10:33:24.547]                               next
[10:33:24.547]                             invokeRestart(restart)
[10:33:24.547]                             muffled <- TRUE
[10:33:24.547]                             break
[10:33:24.547]                           }
[10:33:24.547]                         }
[10:33:24.547]                       }
[10:33:24.547]                       invisible(muffled)
[10:33:24.547]                     }
[10:33:24.547]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.547]                   }
[10:33:24.547]                 }
[10:33:24.547]             }
[10:33:24.547]         }))
[10:33:24.547]     }, error = function(ex) {
[10:33:24.547]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.547]                 ...future.rng), started = ...future.startTime, 
[10:33:24.547]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.547]             version = "1.8"), class = "FutureResult")
[10:33:24.547]     }, finally = {
[10:33:24.547]         if (!identical(...future.workdir, getwd())) 
[10:33:24.547]             setwd(...future.workdir)
[10:33:24.547]         {
[10:33:24.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.547]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.547]             }
[10:33:24.547]             base::options(...future.oldOptions)
[10:33:24.547]             if (.Platform$OS.type == "windows") {
[10:33:24.547]                 old_names <- names(...future.oldEnvVars)
[10:33:24.547]                 envs <- base::Sys.getenv()
[10:33:24.547]                 names <- names(envs)
[10:33:24.547]                 common <- intersect(names, old_names)
[10:33:24.547]                 added <- setdiff(names, old_names)
[10:33:24.547]                 removed <- setdiff(old_names, names)
[10:33:24.547]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.547]                   envs[common]]
[10:33:24.547]                 NAMES <- toupper(changed)
[10:33:24.547]                 args <- list()
[10:33:24.547]                 for (kk in seq_along(NAMES)) {
[10:33:24.547]                   name <- changed[[kk]]
[10:33:24.547]                   NAME <- NAMES[[kk]]
[10:33:24.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.547]                     next
[10:33:24.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.547]                 }
[10:33:24.547]                 NAMES <- toupper(added)
[10:33:24.547]                 for (kk in seq_along(NAMES)) {
[10:33:24.547]                   name <- added[[kk]]
[10:33:24.547]                   NAME <- NAMES[[kk]]
[10:33:24.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.547]                     next
[10:33:24.547]                   args[[name]] <- ""
[10:33:24.547]                 }
[10:33:24.547]                 NAMES <- toupper(removed)
[10:33:24.547]                 for (kk in seq_along(NAMES)) {
[10:33:24.547]                   name <- removed[[kk]]
[10:33:24.547]                   NAME <- NAMES[[kk]]
[10:33:24.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.547]                     next
[10:33:24.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.547]                 }
[10:33:24.547]                 if (length(args) > 0) 
[10:33:24.547]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.547]             }
[10:33:24.547]             else {
[10:33:24.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.547]             }
[10:33:24.547]             {
[10:33:24.547]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.547]                   0L) {
[10:33:24.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.547]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.547]                   base::options(opts)
[10:33:24.547]                 }
[10:33:24.547]                 {
[10:33:24.547]                   {
[10:33:24.547]                     NULL
[10:33:24.547]                     RNGkind("Mersenne-Twister")
[10:33:24.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.547]                       inherits = FALSE)
[10:33:24.547]                   }
[10:33:24.547]                   options(future.plan = NULL)
[10:33:24.547]                   if (is.na(NA_character_)) 
[10:33:24.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.547]                     .init = FALSE)
[10:33:24.547]                 }
[10:33:24.547]             }
[10:33:24.547]         }
[10:33:24.547]     })
[10:33:24.547]     if (TRUE) {
[10:33:24.547]         base::sink(type = "output", split = FALSE)
[10:33:24.547]         if (TRUE) {
[10:33:24.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.547]         }
[10:33:24.547]         else {
[10:33:24.547]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.547]         }
[10:33:24.547]         base::close(...future.stdout)
[10:33:24.547]         ...future.stdout <- NULL
[10:33:24.547]     }
[10:33:24.547]     ...future.result$conditions <- ...future.conditions
[10:33:24.547]     ...future.result$finished <- base::Sys.time()
[10:33:24.547]     ...future.result
[10:33:24.547] }
[10:33:24.549] assign_globals() ...
[10:33:24.549] List of 1
[10:33:24.549]  $ ii: int 1
[10:33:24.549]  - attr(*, "where")=List of 1
[10:33:24.549]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.549]  - attr(*, "resolved")= logi FALSE
[10:33:24.549]  - attr(*, "total_size")= num 56
[10:33:24.551] - copied ‘ii’ to environment
[10:33:24.551] assign_globals() ... done
[10:33:24.551] plan(): Setting new future strategy stack:
[10:33:24.551] List of future strategies:
[10:33:24.551] 1. sequential:
[10:33:24.551]    - args: function (..., envir = parent.frame())
[10:33:24.551]    - tweaked: FALSE
[10:33:24.551]    - call: NULL
[10:33:24.552] plan(): nbrOfWorkers() = 1
[10:33:24.552] plan(): Setting new future strategy stack:
[10:33:24.553] List of future strategies:
[10:33:24.553] 1. multicore:
[10:33:24.553]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.553]    - tweaked: FALSE
[10:33:24.553]    - call: plan(multicore)
[10:33:24.556] plan(): nbrOfWorkers() = 1
[10:33:24.556] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[10:33:24.560] getGlobalsAndPackages() ...
[10:33:24.560] Searching for globals...
[10:33:24.561] - globals found: [2] ‘{’, ‘ii’
[10:33:24.561] Searching for globals ... DONE
[10:33:24.561] Resolving globals: FALSE
[10:33:24.561] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.562] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.562] - globals: [1] ‘ii’
[10:33:24.562] 
[10:33:24.562] getGlobalsAndPackages() ... DONE
[10:33:24.562] Packages needed by the future expression (n = 0): <none>
[10:33:24.563] Packages needed by future strategies (n = 0): <none>
[10:33:24.563] {
[10:33:24.563]     {
[10:33:24.563]         {
[10:33:24.563]             ...future.startTime <- base::Sys.time()
[10:33:24.563]             {
[10:33:24.563]                 {
[10:33:24.563]                   {
[10:33:24.563]                     base::local({
[10:33:24.563]                       has_future <- base::requireNamespace("future", 
[10:33:24.563]                         quietly = TRUE)
[10:33:24.563]                       if (has_future) {
[10:33:24.563]                         ns <- base::getNamespace("future")
[10:33:24.563]                         version <- ns[[".package"]][["version"]]
[10:33:24.563]                         if (is.null(version)) 
[10:33:24.563]                           version <- utils::packageVersion("future")
[10:33:24.563]                       }
[10:33:24.563]                       else {
[10:33:24.563]                         version <- NULL
[10:33:24.563]                       }
[10:33:24.563]                       if (!has_future || version < "1.8.0") {
[10:33:24.563]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.563]                           "", base::R.version$version.string), 
[10:33:24.563]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.563]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.563]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.563]                             "release", "version")], collapse = " "), 
[10:33:24.563]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.563]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.563]                           info)
[10:33:24.563]                         info <- base::paste(info, collapse = "; ")
[10:33:24.563]                         if (!has_future) {
[10:33:24.563]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.563]                             info)
[10:33:24.563]                         }
[10:33:24.563]                         else {
[10:33:24.563]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.563]                             info, version)
[10:33:24.563]                         }
[10:33:24.563]                         base::stop(msg)
[10:33:24.563]                       }
[10:33:24.563]                     })
[10:33:24.563]                   }
[10:33:24.563]                   ...future.strategy.old <- future::plan("list")
[10:33:24.563]                   options(future.plan = NULL)
[10:33:24.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.563]                 }
[10:33:24.563]                 ...future.workdir <- getwd()
[10:33:24.563]             }
[10:33:24.563]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.563]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.563]         }
[10:33:24.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.563]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.563]             base::names(...future.oldOptions))
[10:33:24.563]     }
[10:33:24.563]     if (FALSE) {
[10:33:24.563]     }
[10:33:24.563]     else {
[10:33:24.563]         if (TRUE) {
[10:33:24.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.563]                 open = "w")
[10:33:24.563]         }
[10:33:24.563]         else {
[10:33:24.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.563]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.563]         }
[10:33:24.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.563]             base::sink(type = "output", split = FALSE)
[10:33:24.563]             base::close(...future.stdout)
[10:33:24.563]         }, add = TRUE)
[10:33:24.563]     }
[10:33:24.563]     ...future.frame <- base::sys.nframe()
[10:33:24.563]     ...future.conditions <- base::list()
[10:33:24.563]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.563]     if (FALSE) {
[10:33:24.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.563]     }
[10:33:24.563]     ...future.result <- base::tryCatch({
[10:33:24.563]         base::withCallingHandlers({
[10:33:24.563]             ...future.value <- base::withVisible(base::local({
[10:33:24.563]                 ii
[10:33:24.563]             }))
[10:33:24.563]             future::FutureResult(value = ...future.value$value, 
[10:33:24.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.563]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.563]                     ...future.globalenv.names))
[10:33:24.563]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.563]         }, condition = base::local({
[10:33:24.563]             c <- base::c
[10:33:24.563]             inherits <- base::inherits
[10:33:24.563]             invokeRestart <- base::invokeRestart
[10:33:24.563]             length <- base::length
[10:33:24.563]             list <- base::list
[10:33:24.563]             seq.int <- base::seq.int
[10:33:24.563]             signalCondition <- base::signalCondition
[10:33:24.563]             sys.calls <- base::sys.calls
[10:33:24.563]             `[[` <- base::`[[`
[10:33:24.563]             `+` <- base::`+`
[10:33:24.563]             `<<-` <- base::`<<-`
[10:33:24.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.563]                   3L)]
[10:33:24.563]             }
[10:33:24.563]             function(cond) {
[10:33:24.563]                 is_error <- inherits(cond, "error")
[10:33:24.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.563]                   NULL)
[10:33:24.563]                 if (is_error) {
[10:33:24.563]                   sessionInformation <- function() {
[10:33:24.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.563]                       search = base::search(), system = base::Sys.info())
[10:33:24.563]                   }
[10:33:24.563]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.563]                     cond$call), session = sessionInformation(), 
[10:33:24.563]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.563]                   signalCondition(cond)
[10:33:24.563]                 }
[10:33:24.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.563]                 "immediateCondition"))) {
[10:33:24.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.563]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.563]                   if (TRUE && !signal) {
[10:33:24.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.563]                     {
[10:33:24.563]                       inherits <- base::inherits
[10:33:24.563]                       invokeRestart <- base::invokeRestart
[10:33:24.563]                       is.null <- base::is.null
[10:33:24.563]                       muffled <- FALSE
[10:33:24.563]                       if (inherits(cond, "message")) {
[10:33:24.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.563]                         if (muffled) 
[10:33:24.563]                           invokeRestart("muffleMessage")
[10:33:24.563]                       }
[10:33:24.563]                       else if (inherits(cond, "warning")) {
[10:33:24.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.563]                         if (muffled) 
[10:33:24.563]                           invokeRestart("muffleWarning")
[10:33:24.563]                       }
[10:33:24.563]                       else if (inherits(cond, "condition")) {
[10:33:24.563]                         if (!is.null(pattern)) {
[10:33:24.563]                           computeRestarts <- base::computeRestarts
[10:33:24.563]                           grepl <- base::grepl
[10:33:24.563]                           restarts <- computeRestarts(cond)
[10:33:24.563]                           for (restart in restarts) {
[10:33:24.563]                             name <- restart$name
[10:33:24.563]                             if (is.null(name)) 
[10:33:24.563]                               next
[10:33:24.563]                             if (!grepl(pattern, name)) 
[10:33:24.563]                               next
[10:33:24.563]                             invokeRestart(restart)
[10:33:24.563]                             muffled <- TRUE
[10:33:24.563]                             break
[10:33:24.563]                           }
[10:33:24.563]                         }
[10:33:24.563]                       }
[10:33:24.563]                       invisible(muffled)
[10:33:24.563]                     }
[10:33:24.563]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.563]                   }
[10:33:24.563]                 }
[10:33:24.563]                 else {
[10:33:24.563]                   if (TRUE) {
[10:33:24.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.563]                     {
[10:33:24.563]                       inherits <- base::inherits
[10:33:24.563]                       invokeRestart <- base::invokeRestart
[10:33:24.563]                       is.null <- base::is.null
[10:33:24.563]                       muffled <- FALSE
[10:33:24.563]                       if (inherits(cond, "message")) {
[10:33:24.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.563]                         if (muffled) 
[10:33:24.563]                           invokeRestart("muffleMessage")
[10:33:24.563]                       }
[10:33:24.563]                       else if (inherits(cond, "warning")) {
[10:33:24.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.563]                         if (muffled) 
[10:33:24.563]                           invokeRestart("muffleWarning")
[10:33:24.563]                       }
[10:33:24.563]                       else if (inherits(cond, "condition")) {
[10:33:24.563]                         if (!is.null(pattern)) {
[10:33:24.563]                           computeRestarts <- base::computeRestarts
[10:33:24.563]                           grepl <- base::grepl
[10:33:24.563]                           restarts <- computeRestarts(cond)
[10:33:24.563]                           for (restart in restarts) {
[10:33:24.563]                             name <- restart$name
[10:33:24.563]                             if (is.null(name)) 
[10:33:24.563]                               next
[10:33:24.563]                             if (!grepl(pattern, name)) 
[10:33:24.563]                               next
[10:33:24.563]                             invokeRestart(restart)
[10:33:24.563]                             muffled <- TRUE
[10:33:24.563]                             break
[10:33:24.563]                           }
[10:33:24.563]                         }
[10:33:24.563]                       }
[10:33:24.563]                       invisible(muffled)
[10:33:24.563]                     }
[10:33:24.563]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.563]                   }
[10:33:24.563]                 }
[10:33:24.563]             }
[10:33:24.563]         }))
[10:33:24.563]     }, error = function(ex) {
[10:33:24.563]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.563]                 ...future.rng), started = ...future.startTime, 
[10:33:24.563]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.563]             version = "1.8"), class = "FutureResult")
[10:33:24.563]     }, finally = {
[10:33:24.563]         if (!identical(...future.workdir, getwd())) 
[10:33:24.563]             setwd(...future.workdir)
[10:33:24.563]         {
[10:33:24.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.563]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.563]             }
[10:33:24.563]             base::options(...future.oldOptions)
[10:33:24.563]             if (.Platform$OS.type == "windows") {
[10:33:24.563]                 old_names <- names(...future.oldEnvVars)
[10:33:24.563]                 envs <- base::Sys.getenv()
[10:33:24.563]                 names <- names(envs)
[10:33:24.563]                 common <- intersect(names, old_names)
[10:33:24.563]                 added <- setdiff(names, old_names)
[10:33:24.563]                 removed <- setdiff(old_names, names)
[10:33:24.563]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.563]                   envs[common]]
[10:33:24.563]                 NAMES <- toupper(changed)
[10:33:24.563]                 args <- list()
[10:33:24.563]                 for (kk in seq_along(NAMES)) {
[10:33:24.563]                   name <- changed[[kk]]
[10:33:24.563]                   NAME <- NAMES[[kk]]
[10:33:24.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.563]                     next
[10:33:24.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.563]                 }
[10:33:24.563]                 NAMES <- toupper(added)
[10:33:24.563]                 for (kk in seq_along(NAMES)) {
[10:33:24.563]                   name <- added[[kk]]
[10:33:24.563]                   NAME <- NAMES[[kk]]
[10:33:24.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.563]                     next
[10:33:24.563]                   args[[name]] <- ""
[10:33:24.563]                 }
[10:33:24.563]                 NAMES <- toupper(removed)
[10:33:24.563]                 for (kk in seq_along(NAMES)) {
[10:33:24.563]                   name <- removed[[kk]]
[10:33:24.563]                   NAME <- NAMES[[kk]]
[10:33:24.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.563]                     next
[10:33:24.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.563]                 }
[10:33:24.563]                 if (length(args) > 0) 
[10:33:24.563]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.563]             }
[10:33:24.563]             else {
[10:33:24.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.563]             }
[10:33:24.563]             {
[10:33:24.563]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.563]                   0L) {
[10:33:24.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.563]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.563]                   base::options(opts)
[10:33:24.563]                 }
[10:33:24.563]                 {
[10:33:24.563]                   {
[10:33:24.563]                     NULL
[10:33:24.563]                     RNGkind("Mersenne-Twister")
[10:33:24.563]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.563]                       inherits = FALSE)
[10:33:24.563]                   }
[10:33:24.563]                   options(future.plan = NULL)
[10:33:24.563]                   if (is.na(NA_character_)) 
[10:33:24.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.563]                     .init = FALSE)
[10:33:24.563]                 }
[10:33:24.563]             }
[10:33:24.563]         }
[10:33:24.563]     })
[10:33:24.563]     if (TRUE) {
[10:33:24.563]         base::sink(type = "output", split = FALSE)
[10:33:24.563]         if (TRUE) {
[10:33:24.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.563]         }
[10:33:24.563]         else {
[10:33:24.563]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.563]         }
[10:33:24.563]         base::close(...future.stdout)
[10:33:24.563]         ...future.stdout <- NULL
[10:33:24.563]     }
[10:33:24.563]     ...future.result$conditions <- ...future.conditions
[10:33:24.563]     ...future.result$finished <- base::Sys.time()
[10:33:24.563]     ...future.result
[10:33:24.563] }
[10:33:24.565] assign_globals() ...
[10:33:24.565] List of 1
[10:33:24.565]  $ ii: int 2
[10:33:24.565]  - attr(*, "where")=List of 1
[10:33:24.565]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.565]  - attr(*, "resolved")= logi FALSE
[10:33:24.565]  - attr(*, "total_size")= num 56
[10:33:24.567] - copied ‘ii’ to environment
[10:33:24.567] assign_globals() ... done
[10:33:24.567] plan(): Setting new future strategy stack:
[10:33:24.567] List of future strategies:
[10:33:24.567] 1. sequential:
[10:33:24.567]    - args: function (..., envir = parent.frame())
[10:33:24.567]    - tweaked: FALSE
[10:33:24.567]    - call: NULL
[10:33:24.568] plan(): nbrOfWorkers() = 1
[10:33:24.568] plan(): Setting new future strategy stack:
[10:33:24.568] List of future strategies:
[10:33:24.568] 1. multicore:
[10:33:24.568]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.568]    - tweaked: FALSE
[10:33:24.568]    - call: plan(multicore)
[10:33:24.572] plan(): nbrOfWorkers() = 1
[10:33:24.572] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[10:33:24.575] getGlobalsAndPackages() ...
[10:33:24.575] Searching for globals...
[10:33:24.576] - globals found: [2] ‘{’, ‘ii’
[10:33:24.576] Searching for globals ... DONE
[10:33:24.578] Resolving globals: FALSE
[10:33:24.578] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.579] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.579] - globals: [1] ‘ii’
[10:33:24.579] 
[10:33:24.579] getGlobalsAndPackages() ... DONE
[10:33:24.579] Packages needed by the future expression (n = 0): <none>
[10:33:24.579] Packages needed by future strategies (n = 0): <none>
[10:33:24.580] {
[10:33:24.580]     {
[10:33:24.580]         {
[10:33:24.580]             ...future.startTime <- base::Sys.time()
[10:33:24.580]             {
[10:33:24.580]                 {
[10:33:24.580]                   {
[10:33:24.580]                     base::local({
[10:33:24.580]                       has_future <- base::requireNamespace("future", 
[10:33:24.580]                         quietly = TRUE)
[10:33:24.580]                       if (has_future) {
[10:33:24.580]                         ns <- base::getNamespace("future")
[10:33:24.580]                         version <- ns[[".package"]][["version"]]
[10:33:24.580]                         if (is.null(version)) 
[10:33:24.580]                           version <- utils::packageVersion("future")
[10:33:24.580]                       }
[10:33:24.580]                       else {
[10:33:24.580]                         version <- NULL
[10:33:24.580]                       }
[10:33:24.580]                       if (!has_future || version < "1.8.0") {
[10:33:24.580]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.580]                           "", base::R.version$version.string), 
[10:33:24.580]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.580]                             "release", "version")], collapse = " "), 
[10:33:24.580]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.580]                           info)
[10:33:24.580]                         info <- base::paste(info, collapse = "; ")
[10:33:24.580]                         if (!has_future) {
[10:33:24.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.580]                             info)
[10:33:24.580]                         }
[10:33:24.580]                         else {
[10:33:24.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.580]                             info, version)
[10:33:24.580]                         }
[10:33:24.580]                         base::stop(msg)
[10:33:24.580]                       }
[10:33:24.580]                     })
[10:33:24.580]                   }
[10:33:24.580]                   ...future.strategy.old <- future::plan("list")
[10:33:24.580]                   options(future.plan = NULL)
[10:33:24.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.580]                 }
[10:33:24.580]                 ...future.workdir <- getwd()
[10:33:24.580]             }
[10:33:24.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.580]         }
[10:33:24.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.580]             base::names(...future.oldOptions))
[10:33:24.580]     }
[10:33:24.580]     if (FALSE) {
[10:33:24.580]     }
[10:33:24.580]     else {
[10:33:24.580]         if (TRUE) {
[10:33:24.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.580]                 open = "w")
[10:33:24.580]         }
[10:33:24.580]         else {
[10:33:24.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.580]         }
[10:33:24.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.580]             base::sink(type = "output", split = FALSE)
[10:33:24.580]             base::close(...future.stdout)
[10:33:24.580]         }, add = TRUE)
[10:33:24.580]     }
[10:33:24.580]     ...future.frame <- base::sys.nframe()
[10:33:24.580]     ...future.conditions <- base::list()
[10:33:24.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.580]     if (FALSE) {
[10:33:24.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.580]     }
[10:33:24.580]     ...future.result <- base::tryCatch({
[10:33:24.580]         base::withCallingHandlers({
[10:33:24.580]             ...future.value <- base::withVisible(base::local({
[10:33:24.580]                 ii
[10:33:24.580]             }))
[10:33:24.580]             future::FutureResult(value = ...future.value$value, 
[10:33:24.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.580]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.580]                     ...future.globalenv.names))
[10:33:24.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.580]         }, condition = base::local({
[10:33:24.580]             c <- base::c
[10:33:24.580]             inherits <- base::inherits
[10:33:24.580]             invokeRestart <- base::invokeRestart
[10:33:24.580]             length <- base::length
[10:33:24.580]             list <- base::list
[10:33:24.580]             seq.int <- base::seq.int
[10:33:24.580]             signalCondition <- base::signalCondition
[10:33:24.580]             sys.calls <- base::sys.calls
[10:33:24.580]             `[[` <- base::`[[`
[10:33:24.580]             `+` <- base::`+`
[10:33:24.580]             `<<-` <- base::`<<-`
[10:33:24.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.580]                   3L)]
[10:33:24.580]             }
[10:33:24.580]             function(cond) {
[10:33:24.580]                 is_error <- inherits(cond, "error")
[10:33:24.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.580]                   NULL)
[10:33:24.580]                 if (is_error) {
[10:33:24.580]                   sessionInformation <- function() {
[10:33:24.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.580]                       search = base::search(), system = base::Sys.info())
[10:33:24.580]                   }
[10:33:24.580]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.580]                     cond$call), session = sessionInformation(), 
[10:33:24.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.580]                   signalCondition(cond)
[10:33:24.580]                 }
[10:33:24.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.580]                 "immediateCondition"))) {
[10:33:24.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.580]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.580]                   if (TRUE && !signal) {
[10:33:24.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.580]                     {
[10:33:24.580]                       inherits <- base::inherits
[10:33:24.580]                       invokeRestart <- base::invokeRestart
[10:33:24.580]                       is.null <- base::is.null
[10:33:24.580]                       muffled <- FALSE
[10:33:24.580]                       if (inherits(cond, "message")) {
[10:33:24.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.580]                         if (muffled) 
[10:33:24.580]                           invokeRestart("muffleMessage")
[10:33:24.580]                       }
[10:33:24.580]                       else if (inherits(cond, "warning")) {
[10:33:24.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.580]                         if (muffled) 
[10:33:24.580]                           invokeRestart("muffleWarning")
[10:33:24.580]                       }
[10:33:24.580]                       else if (inherits(cond, "condition")) {
[10:33:24.580]                         if (!is.null(pattern)) {
[10:33:24.580]                           computeRestarts <- base::computeRestarts
[10:33:24.580]                           grepl <- base::grepl
[10:33:24.580]                           restarts <- computeRestarts(cond)
[10:33:24.580]                           for (restart in restarts) {
[10:33:24.580]                             name <- restart$name
[10:33:24.580]                             if (is.null(name)) 
[10:33:24.580]                               next
[10:33:24.580]                             if (!grepl(pattern, name)) 
[10:33:24.580]                               next
[10:33:24.580]                             invokeRestart(restart)
[10:33:24.580]                             muffled <- TRUE
[10:33:24.580]                             break
[10:33:24.580]                           }
[10:33:24.580]                         }
[10:33:24.580]                       }
[10:33:24.580]                       invisible(muffled)
[10:33:24.580]                     }
[10:33:24.580]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.580]                   }
[10:33:24.580]                 }
[10:33:24.580]                 else {
[10:33:24.580]                   if (TRUE) {
[10:33:24.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.580]                     {
[10:33:24.580]                       inherits <- base::inherits
[10:33:24.580]                       invokeRestart <- base::invokeRestart
[10:33:24.580]                       is.null <- base::is.null
[10:33:24.580]                       muffled <- FALSE
[10:33:24.580]                       if (inherits(cond, "message")) {
[10:33:24.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.580]                         if (muffled) 
[10:33:24.580]                           invokeRestart("muffleMessage")
[10:33:24.580]                       }
[10:33:24.580]                       else if (inherits(cond, "warning")) {
[10:33:24.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.580]                         if (muffled) 
[10:33:24.580]                           invokeRestart("muffleWarning")
[10:33:24.580]                       }
[10:33:24.580]                       else if (inherits(cond, "condition")) {
[10:33:24.580]                         if (!is.null(pattern)) {
[10:33:24.580]                           computeRestarts <- base::computeRestarts
[10:33:24.580]                           grepl <- base::grepl
[10:33:24.580]                           restarts <- computeRestarts(cond)
[10:33:24.580]                           for (restart in restarts) {
[10:33:24.580]                             name <- restart$name
[10:33:24.580]                             if (is.null(name)) 
[10:33:24.580]                               next
[10:33:24.580]                             if (!grepl(pattern, name)) 
[10:33:24.580]                               next
[10:33:24.580]                             invokeRestart(restart)
[10:33:24.580]                             muffled <- TRUE
[10:33:24.580]                             break
[10:33:24.580]                           }
[10:33:24.580]                         }
[10:33:24.580]                       }
[10:33:24.580]                       invisible(muffled)
[10:33:24.580]                     }
[10:33:24.580]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.580]                   }
[10:33:24.580]                 }
[10:33:24.580]             }
[10:33:24.580]         }))
[10:33:24.580]     }, error = function(ex) {
[10:33:24.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.580]                 ...future.rng), started = ...future.startTime, 
[10:33:24.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.580]             version = "1.8"), class = "FutureResult")
[10:33:24.580]     }, finally = {
[10:33:24.580]         if (!identical(...future.workdir, getwd())) 
[10:33:24.580]             setwd(...future.workdir)
[10:33:24.580]         {
[10:33:24.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.580]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.580]             }
[10:33:24.580]             base::options(...future.oldOptions)
[10:33:24.580]             if (.Platform$OS.type == "windows") {
[10:33:24.580]                 old_names <- names(...future.oldEnvVars)
[10:33:24.580]                 envs <- base::Sys.getenv()
[10:33:24.580]                 names <- names(envs)
[10:33:24.580]                 common <- intersect(names, old_names)
[10:33:24.580]                 added <- setdiff(names, old_names)
[10:33:24.580]                 removed <- setdiff(old_names, names)
[10:33:24.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.580]                   envs[common]]
[10:33:24.580]                 NAMES <- toupper(changed)
[10:33:24.580]                 args <- list()
[10:33:24.580]                 for (kk in seq_along(NAMES)) {
[10:33:24.580]                   name <- changed[[kk]]
[10:33:24.580]                   NAME <- NAMES[[kk]]
[10:33:24.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.580]                     next
[10:33:24.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.580]                 }
[10:33:24.580]                 NAMES <- toupper(added)
[10:33:24.580]                 for (kk in seq_along(NAMES)) {
[10:33:24.580]                   name <- added[[kk]]
[10:33:24.580]                   NAME <- NAMES[[kk]]
[10:33:24.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.580]                     next
[10:33:24.580]                   args[[name]] <- ""
[10:33:24.580]                 }
[10:33:24.580]                 NAMES <- toupper(removed)
[10:33:24.580]                 for (kk in seq_along(NAMES)) {
[10:33:24.580]                   name <- removed[[kk]]
[10:33:24.580]                   NAME <- NAMES[[kk]]
[10:33:24.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.580]                     next
[10:33:24.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.580]                 }
[10:33:24.580]                 if (length(args) > 0) 
[10:33:24.580]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.580]             }
[10:33:24.580]             else {
[10:33:24.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.580]             }
[10:33:24.580]             {
[10:33:24.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.580]                   0L) {
[10:33:24.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.580]                   base::options(opts)
[10:33:24.580]                 }
[10:33:24.580]                 {
[10:33:24.580]                   {
[10:33:24.580]                     NULL
[10:33:24.580]                     RNGkind("Mersenne-Twister")
[10:33:24.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.580]                       inherits = FALSE)
[10:33:24.580]                   }
[10:33:24.580]                   options(future.plan = NULL)
[10:33:24.580]                   if (is.na(NA_character_)) 
[10:33:24.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.580]                     .init = FALSE)
[10:33:24.580]                 }
[10:33:24.580]             }
[10:33:24.580]         }
[10:33:24.580]     })
[10:33:24.580]     if (TRUE) {
[10:33:24.580]         base::sink(type = "output", split = FALSE)
[10:33:24.580]         if (TRUE) {
[10:33:24.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.580]         }
[10:33:24.580]         else {
[10:33:24.580]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.580]         }
[10:33:24.580]         base::close(...future.stdout)
[10:33:24.580]         ...future.stdout <- NULL
[10:33:24.580]     }
[10:33:24.580]     ...future.result$conditions <- ...future.conditions
[10:33:24.580]     ...future.result$finished <- base::Sys.time()
[10:33:24.580]     ...future.result
[10:33:24.580] }
[10:33:24.581] assign_globals() ...
[10:33:24.581] List of 1
[10:33:24.581]  $ ii: int 3
[10:33:24.581]  - attr(*, "where")=List of 1
[10:33:24.581]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.581]  - attr(*, "resolved")= logi FALSE
[10:33:24.581]  - attr(*, "total_size")= num 56
[10:33:24.583] - copied ‘ii’ to environment
[10:33:24.584] assign_globals() ... done
[10:33:24.584] plan(): Setting new future strategy stack:
[10:33:24.584] List of future strategies:
[10:33:24.584] 1. sequential:
[10:33:24.584]    - args: function (..., envir = parent.frame())
[10:33:24.584]    - tweaked: FALSE
[10:33:24.584]    - call: NULL
[10:33:24.584] plan(): nbrOfWorkers() = 1
[10:33:24.585] plan(): Setting new future strategy stack:
[10:33:24.585] List of future strategies:
[10:33:24.585] 1. multicore:
[10:33:24.585]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.585]    - tweaked: FALSE
[10:33:24.585]    - call: plan(multicore)
[10:33:24.588] plan(): nbrOfWorkers() = 1
[10:33:24.588] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[10:33:24.592] getGlobalsAndPackages() ...
[10:33:24.592] Searching for globals...
[10:33:24.592] - globals found: [2] ‘{’, ‘ii’
[10:33:24.593] Searching for globals ... DONE
[10:33:24.593] Resolving globals: FALSE
[10:33:24.593] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.593] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.593] - globals: [1] ‘ii’
[10:33:24.594] 
[10:33:24.594] getGlobalsAndPackages() ... DONE
[10:33:24.594] Packages needed by the future expression (n = 0): <none>
[10:33:24.594] Packages needed by future strategies (n = 0): <none>
[10:33:24.594] {
[10:33:24.594]     {
[10:33:24.594]         {
[10:33:24.594]             ...future.startTime <- base::Sys.time()
[10:33:24.594]             {
[10:33:24.594]                 {
[10:33:24.594]                   {
[10:33:24.594]                     base::local({
[10:33:24.594]                       has_future <- base::requireNamespace("future", 
[10:33:24.594]                         quietly = TRUE)
[10:33:24.594]                       if (has_future) {
[10:33:24.594]                         ns <- base::getNamespace("future")
[10:33:24.594]                         version <- ns[[".package"]][["version"]]
[10:33:24.594]                         if (is.null(version)) 
[10:33:24.594]                           version <- utils::packageVersion("future")
[10:33:24.594]                       }
[10:33:24.594]                       else {
[10:33:24.594]                         version <- NULL
[10:33:24.594]                       }
[10:33:24.594]                       if (!has_future || version < "1.8.0") {
[10:33:24.594]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.594]                           "", base::R.version$version.string), 
[10:33:24.594]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.594]                             "release", "version")], collapse = " "), 
[10:33:24.594]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.594]                           info)
[10:33:24.594]                         info <- base::paste(info, collapse = "; ")
[10:33:24.594]                         if (!has_future) {
[10:33:24.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.594]                             info)
[10:33:24.594]                         }
[10:33:24.594]                         else {
[10:33:24.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.594]                             info, version)
[10:33:24.594]                         }
[10:33:24.594]                         base::stop(msg)
[10:33:24.594]                       }
[10:33:24.594]                     })
[10:33:24.594]                   }
[10:33:24.594]                   ...future.strategy.old <- future::plan("list")
[10:33:24.594]                   options(future.plan = NULL)
[10:33:24.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.594]                 }
[10:33:24.594]                 ...future.workdir <- getwd()
[10:33:24.594]             }
[10:33:24.594]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.594]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.594]         }
[10:33:24.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.594]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.594]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.594]             base::names(...future.oldOptions))
[10:33:24.594]     }
[10:33:24.594]     if (FALSE) {
[10:33:24.594]     }
[10:33:24.594]     else {
[10:33:24.594]         if (TRUE) {
[10:33:24.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.594]                 open = "w")
[10:33:24.594]         }
[10:33:24.594]         else {
[10:33:24.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.594]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.594]         }
[10:33:24.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.594]             base::sink(type = "output", split = FALSE)
[10:33:24.594]             base::close(...future.stdout)
[10:33:24.594]         }, add = TRUE)
[10:33:24.594]     }
[10:33:24.594]     ...future.frame <- base::sys.nframe()
[10:33:24.594]     ...future.conditions <- base::list()
[10:33:24.594]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.594]     if (FALSE) {
[10:33:24.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.594]     }
[10:33:24.594]     ...future.result <- base::tryCatch({
[10:33:24.594]         base::withCallingHandlers({
[10:33:24.594]             ...future.value <- base::withVisible(base::local({
[10:33:24.594]                 ii
[10:33:24.594]             }))
[10:33:24.594]             future::FutureResult(value = ...future.value$value, 
[10:33:24.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.594]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.594]                     ...future.globalenv.names))
[10:33:24.594]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.594]         }, condition = base::local({
[10:33:24.594]             c <- base::c
[10:33:24.594]             inherits <- base::inherits
[10:33:24.594]             invokeRestart <- base::invokeRestart
[10:33:24.594]             length <- base::length
[10:33:24.594]             list <- base::list
[10:33:24.594]             seq.int <- base::seq.int
[10:33:24.594]             signalCondition <- base::signalCondition
[10:33:24.594]             sys.calls <- base::sys.calls
[10:33:24.594]             `[[` <- base::`[[`
[10:33:24.594]             `+` <- base::`+`
[10:33:24.594]             `<<-` <- base::`<<-`
[10:33:24.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.594]                   3L)]
[10:33:24.594]             }
[10:33:24.594]             function(cond) {
[10:33:24.594]                 is_error <- inherits(cond, "error")
[10:33:24.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.594]                   NULL)
[10:33:24.594]                 if (is_error) {
[10:33:24.594]                   sessionInformation <- function() {
[10:33:24.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.594]                       search = base::search(), system = base::Sys.info())
[10:33:24.594]                   }
[10:33:24.594]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.594]                     cond$call), session = sessionInformation(), 
[10:33:24.594]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.594]                   signalCondition(cond)
[10:33:24.594]                 }
[10:33:24.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.594]                 "immediateCondition"))) {
[10:33:24.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.594]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.594]                   if (TRUE && !signal) {
[10:33:24.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.594]                     {
[10:33:24.594]                       inherits <- base::inherits
[10:33:24.594]                       invokeRestart <- base::invokeRestart
[10:33:24.594]                       is.null <- base::is.null
[10:33:24.594]                       muffled <- FALSE
[10:33:24.594]                       if (inherits(cond, "message")) {
[10:33:24.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.594]                         if (muffled) 
[10:33:24.594]                           invokeRestart("muffleMessage")
[10:33:24.594]                       }
[10:33:24.594]                       else if (inherits(cond, "warning")) {
[10:33:24.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.594]                         if (muffled) 
[10:33:24.594]                           invokeRestart("muffleWarning")
[10:33:24.594]                       }
[10:33:24.594]                       else if (inherits(cond, "condition")) {
[10:33:24.594]                         if (!is.null(pattern)) {
[10:33:24.594]                           computeRestarts <- base::computeRestarts
[10:33:24.594]                           grepl <- base::grepl
[10:33:24.594]                           restarts <- computeRestarts(cond)
[10:33:24.594]                           for (restart in restarts) {
[10:33:24.594]                             name <- restart$name
[10:33:24.594]                             if (is.null(name)) 
[10:33:24.594]                               next
[10:33:24.594]                             if (!grepl(pattern, name)) 
[10:33:24.594]                               next
[10:33:24.594]                             invokeRestart(restart)
[10:33:24.594]                             muffled <- TRUE
[10:33:24.594]                             break
[10:33:24.594]                           }
[10:33:24.594]                         }
[10:33:24.594]                       }
[10:33:24.594]                       invisible(muffled)
[10:33:24.594]                     }
[10:33:24.594]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.594]                   }
[10:33:24.594]                 }
[10:33:24.594]                 else {
[10:33:24.594]                   if (TRUE) {
[10:33:24.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.594]                     {
[10:33:24.594]                       inherits <- base::inherits
[10:33:24.594]                       invokeRestart <- base::invokeRestart
[10:33:24.594]                       is.null <- base::is.null
[10:33:24.594]                       muffled <- FALSE
[10:33:24.594]                       if (inherits(cond, "message")) {
[10:33:24.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.594]                         if (muffled) 
[10:33:24.594]                           invokeRestart("muffleMessage")
[10:33:24.594]                       }
[10:33:24.594]                       else if (inherits(cond, "warning")) {
[10:33:24.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.594]                         if (muffled) 
[10:33:24.594]                           invokeRestart("muffleWarning")
[10:33:24.594]                       }
[10:33:24.594]                       else if (inherits(cond, "condition")) {
[10:33:24.594]                         if (!is.null(pattern)) {
[10:33:24.594]                           computeRestarts <- base::computeRestarts
[10:33:24.594]                           grepl <- base::grepl
[10:33:24.594]                           restarts <- computeRestarts(cond)
[10:33:24.594]                           for (restart in restarts) {
[10:33:24.594]                             name <- restart$name
[10:33:24.594]                             if (is.null(name)) 
[10:33:24.594]                               next
[10:33:24.594]                             if (!grepl(pattern, name)) 
[10:33:24.594]                               next
[10:33:24.594]                             invokeRestart(restart)
[10:33:24.594]                             muffled <- TRUE
[10:33:24.594]                             break
[10:33:24.594]                           }
[10:33:24.594]                         }
[10:33:24.594]                       }
[10:33:24.594]                       invisible(muffled)
[10:33:24.594]                     }
[10:33:24.594]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.594]                   }
[10:33:24.594]                 }
[10:33:24.594]             }
[10:33:24.594]         }))
[10:33:24.594]     }, error = function(ex) {
[10:33:24.594]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.594]                 ...future.rng), started = ...future.startTime, 
[10:33:24.594]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.594]             version = "1.8"), class = "FutureResult")
[10:33:24.594]     }, finally = {
[10:33:24.594]         if (!identical(...future.workdir, getwd())) 
[10:33:24.594]             setwd(...future.workdir)
[10:33:24.594]         {
[10:33:24.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.594]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.594]             }
[10:33:24.594]             base::options(...future.oldOptions)
[10:33:24.594]             if (.Platform$OS.type == "windows") {
[10:33:24.594]                 old_names <- names(...future.oldEnvVars)
[10:33:24.594]                 envs <- base::Sys.getenv()
[10:33:24.594]                 names <- names(envs)
[10:33:24.594]                 common <- intersect(names, old_names)
[10:33:24.594]                 added <- setdiff(names, old_names)
[10:33:24.594]                 removed <- setdiff(old_names, names)
[10:33:24.594]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.594]                   envs[common]]
[10:33:24.594]                 NAMES <- toupper(changed)
[10:33:24.594]                 args <- list()
[10:33:24.594]                 for (kk in seq_along(NAMES)) {
[10:33:24.594]                   name <- changed[[kk]]
[10:33:24.594]                   NAME <- NAMES[[kk]]
[10:33:24.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.594]                     next
[10:33:24.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.594]                 }
[10:33:24.594]                 NAMES <- toupper(added)
[10:33:24.594]                 for (kk in seq_along(NAMES)) {
[10:33:24.594]                   name <- added[[kk]]
[10:33:24.594]                   NAME <- NAMES[[kk]]
[10:33:24.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.594]                     next
[10:33:24.594]                   args[[name]] <- ""
[10:33:24.594]                 }
[10:33:24.594]                 NAMES <- toupper(removed)
[10:33:24.594]                 for (kk in seq_along(NAMES)) {
[10:33:24.594]                   name <- removed[[kk]]
[10:33:24.594]                   NAME <- NAMES[[kk]]
[10:33:24.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.594]                     next
[10:33:24.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.594]                 }
[10:33:24.594]                 if (length(args) > 0) 
[10:33:24.594]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.594]             }
[10:33:24.594]             else {
[10:33:24.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.594]             }
[10:33:24.594]             {
[10:33:24.594]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.594]                   0L) {
[10:33:24.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.594]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.594]                   base::options(opts)
[10:33:24.594]                 }
[10:33:24.594]                 {
[10:33:24.594]                   {
[10:33:24.594]                     NULL
[10:33:24.594]                     RNGkind("Mersenne-Twister")
[10:33:24.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.594]                       inherits = FALSE)
[10:33:24.594]                   }
[10:33:24.594]                   options(future.plan = NULL)
[10:33:24.594]                   if (is.na(NA_character_)) 
[10:33:24.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.594]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.594]                     .init = FALSE)
[10:33:24.594]                 }
[10:33:24.594]             }
[10:33:24.594]         }
[10:33:24.594]     })
[10:33:24.594]     if (TRUE) {
[10:33:24.594]         base::sink(type = "output", split = FALSE)
[10:33:24.594]         if (TRUE) {
[10:33:24.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.594]         }
[10:33:24.594]         else {
[10:33:24.594]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.594]         }
[10:33:24.594]         base::close(...future.stdout)
[10:33:24.594]         ...future.stdout <- NULL
[10:33:24.594]     }
[10:33:24.594]     ...future.result$conditions <- ...future.conditions
[10:33:24.594]     ...future.result$finished <- base::Sys.time()
[10:33:24.594]     ...future.result
[10:33:24.594] }
[10:33:24.596] assign_globals() ...
[10:33:24.596] List of 1
[10:33:24.596]  $ ii: int 4
[10:33:24.596]  - attr(*, "where")=List of 1
[10:33:24.596]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.596]  - attr(*, "resolved")= logi FALSE
[10:33:24.596]  - attr(*, "total_size")= num 56
[10:33:24.598] - copied ‘ii’ to environment
[10:33:24.598] assign_globals() ... done
[10:33:24.599] plan(): Setting new future strategy stack:
[10:33:24.599] List of future strategies:
[10:33:24.599] 1. sequential:
[10:33:24.599]    - args: function (..., envir = parent.frame())
[10:33:24.599]    - tweaked: FALSE
[10:33:24.599]    - call: NULL
[10:33:24.599] plan(): nbrOfWorkers() = 1
[10:33:24.600] plan(): Setting new future strategy stack:
[10:33:24.600] List of future strategies:
[10:33:24.600] 1. multicore:
[10:33:24.600]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.600]    - tweaked: FALSE
[10:33:24.600]    - call: plan(multicore)
[10:33:24.603] plan(): nbrOfWorkers() = 1
[10:33:24.603] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[10:33:24.607] getGlobalsAndPackages() ...
[10:33:24.607] Searching for globals...
[10:33:24.608] - globals found: [2] ‘{’, ‘stop’
[10:33:24.608] Searching for globals ... DONE
[10:33:24.608] Resolving globals: FALSE
[10:33:24.608] 
[10:33:24.609] 
[10:33:24.609] getGlobalsAndPackages() ... DONE
[10:33:24.609] Packages needed by the future expression (n = 0): <none>
[10:33:24.609] Packages needed by future strategies (n = 0): <none>
[10:33:24.609] {
[10:33:24.609]     {
[10:33:24.609]         {
[10:33:24.609]             ...future.startTime <- base::Sys.time()
[10:33:24.609]             {
[10:33:24.609]                 {
[10:33:24.609]                   {
[10:33:24.609]                     base::local({
[10:33:24.609]                       has_future <- base::requireNamespace("future", 
[10:33:24.609]                         quietly = TRUE)
[10:33:24.609]                       if (has_future) {
[10:33:24.609]                         ns <- base::getNamespace("future")
[10:33:24.609]                         version <- ns[[".package"]][["version"]]
[10:33:24.609]                         if (is.null(version)) 
[10:33:24.609]                           version <- utils::packageVersion("future")
[10:33:24.609]                       }
[10:33:24.609]                       else {
[10:33:24.609]                         version <- NULL
[10:33:24.609]                       }
[10:33:24.609]                       if (!has_future || version < "1.8.0") {
[10:33:24.609]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.609]                           "", base::R.version$version.string), 
[10:33:24.609]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.609]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.609]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.609]                             "release", "version")], collapse = " "), 
[10:33:24.609]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.609]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.609]                           info)
[10:33:24.609]                         info <- base::paste(info, collapse = "; ")
[10:33:24.609]                         if (!has_future) {
[10:33:24.609]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.609]                             info)
[10:33:24.609]                         }
[10:33:24.609]                         else {
[10:33:24.609]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.609]                             info, version)
[10:33:24.609]                         }
[10:33:24.609]                         base::stop(msg)
[10:33:24.609]                       }
[10:33:24.609]                     })
[10:33:24.609]                   }
[10:33:24.609]                   ...future.strategy.old <- future::plan("list")
[10:33:24.609]                   options(future.plan = NULL)
[10:33:24.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.609]                 }
[10:33:24.609]                 ...future.workdir <- getwd()
[10:33:24.609]             }
[10:33:24.609]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.609]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.609]         }
[10:33:24.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.609]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.609]             base::names(...future.oldOptions))
[10:33:24.609]     }
[10:33:24.609]     if (FALSE) {
[10:33:24.609]     }
[10:33:24.609]     else {
[10:33:24.609]         if (TRUE) {
[10:33:24.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.609]                 open = "w")
[10:33:24.609]         }
[10:33:24.609]         else {
[10:33:24.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.609]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.609]         }
[10:33:24.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.609]             base::sink(type = "output", split = FALSE)
[10:33:24.609]             base::close(...future.stdout)
[10:33:24.609]         }, add = TRUE)
[10:33:24.609]     }
[10:33:24.609]     ...future.frame <- base::sys.nframe()
[10:33:24.609]     ...future.conditions <- base::list()
[10:33:24.609]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.609]     if (FALSE) {
[10:33:24.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.609]     }
[10:33:24.609]     ...future.result <- base::tryCatch({
[10:33:24.609]         base::withCallingHandlers({
[10:33:24.609]             ...future.value <- base::withVisible(base::local({
[10:33:24.609]                 stop("Whoops!")
[10:33:24.609]                 1
[10:33:24.609]             }))
[10:33:24.609]             future::FutureResult(value = ...future.value$value, 
[10:33:24.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.609]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.609]                     ...future.globalenv.names))
[10:33:24.609]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.609]         }, condition = base::local({
[10:33:24.609]             c <- base::c
[10:33:24.609]             inherits <- base::inherits
[10:33:24.609]             invokeRestart <- base::invokeRestart
[10:33:24.609]             length <- base::length
[10:33:24.609]             list <- base::list
[10:33:24.609]             seq.int <- base::seq.int
[10:33:24.609]             signalCondition <- base::signalCondition
[10:33:24.609]             sys.calls <- base::sys.calls
[10:33:24.609]             `[[` <- base::`[[`
[10:33:24.609]             `+` <- base::`+`
[10:33:24.609]             `<<-` <- base::`<<-`
[10:33:24.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.609]                   3L)]
[10:33:24.609]             }
[10:33:24.609]             function(cond) {
[10:33:24.609]                 is_error <- inherits(cond, "error")
[10:33:24.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.609]                   NULL)
[10:33:24.609]                 if (is_error) {
[10:33:24.609]                   sessionInformation <- function() {
[10:33:24.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.609]                       search = base::search(), system = base::Sys.info())
[10:33:24.609]                   }
[10:33:24.609]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.609]                     cond$call), session = sessionInformation(), 
[10:33:24.609]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.609]                   signalCondition(cond)
[10:33:24.609]                 }
[10:33:24.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.609]                 "immediateCondition"))) {
[10:33:24.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.609]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.609]                   if (TRUE && !signal) {
[10:33:24.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.609]                     {
[10:33:24.609]                       inherits <- base::inherits
[10:33:24.609]                       invokeRestart <- base::invokeRestart
[10:33:24.609]                       is.null <- base::is.null
[10:33:24.609]                       muffled <- FALSE
[10:33:24.609]                       if (inherits(cond, "message")) {
[10:33:24.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.609]                         if (muffled) 
[10:33:24.609]                           invokeRestart("muffleMessage")
[10:33:24.609]                       }
[10:33:24.609]                       else if (inherits(cond, "warning")) {
[10:33:24.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.609]                         if (muffled) 
[10:33:24.609]                           invokeRestart("muffleWarning")
[10:33:24.609]                       }
[10:33:24.609]                       else if (inherits(cond, "condition")) {
[10:33:24.609]                         if (!is.null(pattern)) {
[10:33:24.609]                           computeRestarts <- base::computeRestarts
[10:33:24.609]                           grepl <- base::grepl
[10:33:24.609]                           restarts <- computeRestarts(cond)
[10:33:24.609]                           for (restart in restarts) {
[10:33:24.609]                             name <- restart$name
[10:33:24.609]                             if (is.null(name)) 
[10:33:24.609]                               next
[10:33:24.609]                             if (!grepl(pattern, name)) 
[10:33:24.609]                               next
[10:33:24.609]                             invokeRestart(restart)
[10:33:24.609]                             muffled <- TRUE
[10:33:24.609]                             break
[10:33:24.609]                           }
[10:33:24.609]                         }
[10:33:24.609]                       }
[10:33:24.609]                       invisible(muffled)
[10:33:24.609]                     }
[10:33:24.609]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.609]                   }
[10:33:24.609]                 }
[10:33:24.609]                 else {
[10:33:24.609]                   if (TRUE) {
[10:33:24.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.609]                     {
[10:33:24.609]                       inherits <- base::inherits
[10:33:24.609]                       invokeRestart <- base::invokeRestart
[10:33:24.609]                       is.null <- base::is.null
[10:33:24.609]                       muffled <- FALSE
[10:33:24.609]                       if (inherits(cond, "message")) {
[10:33:24.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.609]                         if (muffled) 
[10:33:24.609]                           invokeRestart("muffleMessage")
[10:33:24.609]                       }
[10:33:24.609]                       else if (inherits(cond, "warning")) {
[10:33:24.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.609]                         if (muffled) 
[10:33:24.609]                           invokeRestart("muffleWarning")
[10:33:24.609]                       }
[10:33:24.609]                       else if (inherits(cond, "condition")) {
[10:33:24.609]                         if (!is.null(pattern)) {
[10:33:24.609]                           computeRestarts <- base::computeRestarts
[10:33:24.609]                           grepl <- base::grepl
[10:33:24.609]                           restarts <- computeRestarts(cond)
[10:33:24.609]                           for (restart in restarts) {
[10:33:24.609]                             name <- restart$name
[10:33:24.609]                             if (is.null(name)) 
[10:33:24.609]                               next
[10:33:24.609]                             if (!grepl(pattern, name)) 
[10:33:24.609]                               next
[10:33:24.609]                             invokeRestart(restart)
[10:33:24.609]                             muffled <- TRUE
[10:33:24.609]                             break
[10:33:24.609]                           }
[10:33:24.609]                         }
[10:33:24.609]                       }
[10:33:24.609]                       invisible(muffled)
[10:33:24.609]                     }
[10:33:24.609]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.609]                   }
[10:33:24.609]                 }
[10:33:24.609]             }
[10:33:24.609]         }))
[10:33:24.609]     }, error = function(ex) {
[10:33:24.609]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.609]                 ...future.rng), started = ...future.startTime, 
[10:33:24.609]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.609]             version = "1.8"), class = "FutureResult")
[10:33:24.609]     }, finally = {
[10:33:24.609]         if (!identical(...future.workdir, getwd())) 
[10:33:24.609]             setwd(...future.workdir)
[10:33:24.609]         {
[10:33:24.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.609]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.609]             }
[10:33:24.609]             base::options(...future.oldOptions)
[10:33:24.609]             if (.Platform$OS.type == "windows") {
[10:33:24.609]                 old_names <- names(...future.oldEnvVars)
[10:33:24.609]                 envs <- base::Sys.getenv()
[10:33:24.609]                 names <- names(envs)
[10:33:24.609]                 common <- intersect(names, old_names)
[10:33:24.609]                 added <- setdiff(names, old_names)
[10:33:24.609]                 removed <- setdiff(old_names, names)
[10:33:24.609]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.609]                   envs[common]]
[10:33:24.609]                 NAMES <- toupper(changed)
[10:33:24.609]                 args <- list()
[10:33:24.609]                 for (kk in seq_along(NAMES)) {
[10:33:24.609]                   name <- changed[[kk]]
[10:33:24.609]                   NAME <- NAMES[[kk]]
[10:33:24.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.609]                     next
[10:33:24.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.609]                 }
[10:33:24.609]                 NAMES <- toupper(added)
[10:33:24.609]                 for (kk in seq_along(NAMES)) {
[10:33:24.609]                   name <- added[[kk]]
[10:33:24.609]                   NAME <- NAMES[[kk]]
[10:33:24.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.609]                     next
[10:33:24.609]                   args[[name]] <- ""
[10:33:24.609]                 }
[10:33:24.609]                 NAMES <- toupper(removed)
[10:33:24.609]                 for (kk in seq_along(NAMES)) {
[10:33:24.609]                   name <- removed[[kk]]
[10:33:24.609]                   NAME <- NAMES[[kk]]
[10:33:24.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.609]                     next
[10:33:24.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.609]                 }
[10:33:24.609]                 if (length(args) > 0) 
[10:33:24.609]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.609]             }
[10:33:24.609]             else {
[10:33:24.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.609]             }
[10:33:24.609]             {
[10:33:24.609]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.609]                   0L) {
[10:33:24.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.609]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.609]                   base::options(opts)
[10:33:24.609]                 }
[10:33:24.609]                 {
[10:33:24.609]                   {
[10:33:24.609]                     NULL
[10:33:24.609]                     RNGkind("Mersenne-Twister")
[10:33:24.609]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.609]                       inherits = FALSE)
[10:33:24.609]                   }
[10:33:24.609]                   options(future.plan = NULL)
[10:33:24.609]                   if (is.na(NA_character_)) 
[10:33:24.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.609]                     .init = FALSE)
[10:33:24.609]                 }
[10:33:24.609]             }
[10:33:24.609]         }
[10:33:24.609]     })
[10:33:24.609]     if (TRUE) {
[10:33:24.609]         base::sink(type = "output", split = FALSE)
[10:33:24.609]         if (TRUE) {
[10:33:24.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.609]         }
[10:33:24.609]         else {
[10:33:24.609]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.609]         }
[10:33:24.609]         base::close(...future.stdout)
[10:33:24.609]         ...future.stdout <- NULL
[10:33:24.609]     }
[10:33:24.609]     ...future.result$conditions <- ...future.conditions
[10:33:24.609]     ...future.result$finished <- base::Sys.time()
[10:33:24.609]     ...future.result
[10:33:24.609] }
[10:33:24.611] plan(): Setting new future strategy stack:
[10:33:24.611] List of future strategies:
[10:33:24.611] 1. sequential:
[10:33:24.611]    - args: function (..., envir = parent.frame())
[10:33:24.611]    - tweaked: FALSE
[10:33:24.611]    - call: NULL
[10:33:24.612] plan(): nbrOfWorkers() = 1
[10:33:24.612] plan(): Setting new future strategy stack:
[10:33:24.613] List of future strategies:
[10:33:24.613] 1. multicore:
[10:33:24.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.613]    - tweaked: FALSE
[10:33:24.613]    - call: plan(multicore)
[10:33:24.616] plan(): nbrOfWorkers() = 1
[10:33:24.616] SequentialFuture started (and completed)
[10:33:24.616] signalConditions() ...
[10:33:24.616]  - include = ‘immediateCondition’
[10:33:24.616]  - exclude = 
[10:33:24.616]  - resignal = FALSE
[10:33:24.617]  - Number of conditions: 1
[10:33:24.617] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:24.617] signalConditions() ...
[10:33:24.617]  - include = ‘immediateCondition’
[10:33:24.619]  - exclude = 
[10:33:24.619]  - resignal = FALSE
[10:33:24.619]  - Number of conditions: 1
[10:33:24.619] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:33:24.620] signalConditions() ...
[10:33:24.620]  - include = ‘immediateCondition’
[10:33:24.620]  - exclude = 
[10:33:24.620]  - resignal = FALSE
[10:33:24.620]  - Number of conditions: 1
[10:33:24.620] signalConditions() ... done
[10:33:24.620] Future state: ‘finished’
[10:33:24.620] signalConditions() ...
[10:33:24.620]  - include = ‘condition’
[10:33:24.620]  - exclude = ‘immediateCondition’
[10:33:24.621]  - resignal = TRUE
[10:33:24.621]  - Number of conditions: 1
[10:33:24.621]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:24.621] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:33:24.621] signalConditions() ...
[10:33:24.621]  - include = ‘immediateCondition’
[10:33:24.621]  - exclude = 
[10:33:24.622]  - resignal = FALSE
[10:33:24.622]  - Number of conditions: 1
[10:33:24.622] signalConditions() ... done
[10:33:24.622] Future state: ‘finished’
[10:33:24.622] signalConditions() ...
[10:33:24.622]  - include = ‘condition’
[10:33:24.622]  - exclude = ‘immediateCondition’
[10:33:24.622]  - resignal = TRUE
[10:33:24.622]  - Number of conditions: 1
[10:33:24.622]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:24.623] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:33:24.626] getGlobalsAndPackages() ...
[10:33:24.626] Searching for globals...
[10:33:24.627] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[10:33:24.627] Searching for globals ... DONE
[10:33:24.627] Resolving globals: FALSE
[10:33:24.628] 
[10:33:24.628] 
[10:33:24.628] getGlobalsAndPackages() ... DONE
[10:33:24.628] Packages needed by the future expression (n = 0): <none>
[10:33:24.628] Packages needed by future strategies (n = 0): <none>
[10:33:24.629] {
[10:33:24.629]     {
[10:33:24.629]         {
[10:33:24.629]             ...future.startTime <- base::Sys.time()
[10:33:24.629]             {
[10:33:24.629]                 {
[10:33:24.629]                   {
[10:33:24.629]                     base::local({
[10:33:24.629]                       has_future <- base::requireNamespace("future", 
[10:33:24.629]                         quietly = TRUE)
[10:33:24.629]                       if (has_future) {
[10:33:24.629]                         ns <- base::getNamespace("future")
[10:33:24.629]                         version <- ns[[".package"]][["version"]]
[10:33:24.629]                         if (is.null(version)) 
[10:33:24.629]                           version <- utils::packageVersion("future")
[10:33:24.629]                       }
[10:33:24.629]                       else {
[10:33:24.629]                         version <- NULL
[10:33:24.629]                       }
[10:33:24.629]                       if (!has_future || version < "1.8.0") {
[10:33:24.629]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.629]                           "", base::R.version$version.string), 
[10:33:24.629]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.629]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.629]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.629]                             "release", "version")], collapse = " "), 
[10:33:24.629]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.629]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.629]                           info)
[10:33:24.629]                         info <- base::paste(info, collapse = "; ")
[10:33:24.629]                         if (!has_future) {
[10:33:24.629]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.629]                             info)
[10:33:24.629]                         }
[10:33:24.629]                         else {
[10:33:24.629]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.629]                             info, version)
[10:33:24.629]                         }
[10:33:24.629]                         base::stop(msg)
[10:33:24.629]                       }
[10:33:24.629]                     })
[10:33:24.629]                   }
[10:33:24.629]                   ...future.strategy.old <- future::plan("list")
[10:33:24.629]                   options(future.plan = NULL)
[10:33:24.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.629]                 }
[10:33:24.629]                 ...future.workdir <- getwd()
[10:33:24.629]             }
[10:33:24.629]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.629]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.629]         }
[10:33:24.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.629]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.629]             base::names(...future.oldOptions))
[10:33:24.629]     }
[10:33:24.629]     if (FALSE) {
[10:33:24.629]     }
[10:33:24.629]     else {
[10:33:24.629]         if (TRUE) {
[10:33:24.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.629]                 open = "w")
[10:33:24.629]         }
[10:33:24.629]         else {
[10:33:24.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.629]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.629]         }
[10:33:24.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.629]             base::sink(type = "output", split = FALSE)
[10:33:24.629]             base::close(...future.stdout)
[10:33:24.629]         }, add = TRUE)
[10:33:24.629]     }
[10:33:24.629]     ...future.frame <- base::sys.nframe()
[10:33:24.629]     ...future.conditions <- base::list()
[10:33:24.629]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.629]     if (FALSE) {
[10:33:24.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.629]     }
[10:33:24.629]     ...future.result <- base::tryCatch({
[10:33:24.629]         base::withCallingHandlers({
[10:33:24.629]             ...future.value <- base::withVisible(base::local({
[10:33:24.629]                 stop(structure(list(message = "boom"), class = c("MyError", 
[10:33:24.629]                   "error", "condition")))
[10:33:24.629]             }))
[10:33:24.629]             future::FutureResult(value = ...future.value$value, 
[10:33:24.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.629]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.629]                     ...future.globalenv.names))
[10:33:24.629]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.629]         }, condition = base::local({
[10:33:24.629]             c <- base::c
[10:33:24.629]             inherits <- base::inherits
[10:33:24.629]             invokeRestart <- base::invokeRestart
[10:33:24.629]             length <- base::length
[10:33:24.629]             list <- base::list
[10:33:24.629]             seq.int <- base::seq.int
[10:33:24.629]             signalCondition <- base::signalCondition
[10:33:24.629]             sys.calls <- base::sys.calls
[10:33:24.629]             `[[` <- base::`[[`
[10:33:24.629]             `+` <- base::`+`
[10:33:24.629]             `<<-` <- base::`<<-`
[10:33:24.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.629]                   3L)]
[10:33:24.629]             }
[10:33:24.629]             function(cond) {
[10:33:24.629]                 is_error <- inherits(cond, "error")
[10:33:24.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.629]                   NULL)
[10:33:24.629]                 if (is_error) {
[10:33:24.629]                   sessionInformation <- function() {
[10:33:24.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.629]                       search = base::search(), system = base::Sys.info())
[10:33:24.629]                   }
[10:33:24.629]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.629]                     cond$call), session = sessionInformation(), 
[10:33:24.629]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.629]                   signalCondition(cond)
[10:33:24.629]                 }
[10:33:24.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.629]                 "immediateCondition"))) {
[10:33:24.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.629]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.629]                   if (TRUE && !signal) {
[10:33:24.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.629]                     {
[10:33:24.629]                       inherits <- base::inherits
[10:33:24.629]                       invokeRestart <- base::invokeRestart
[10:33:24.629]                       is.null <- base::is.null
[10:33:24.629]                       muffled <- FALSE
[10:33:24.629]                       if (inherits(cond, "message")) {
[10:33:24.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.629]                         if (muffled) 
[10:33:24.629]                           invokeRestart("muffleMessage")
[10:33:24.629]                       }
[10:33:24.629]                       else if (inherits(cond, "warning")) {
[10:33:24.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.629]                         if (muffled) 
[10:33:24.629]                           invokeRestart("muffleWarning")
[10:33:24.629]                       }
[10:33:24.629]                       else if (inherits(cond, "condition")) {
[10:33:24.629]                         if (!is.null(pattern)) {
[10:33:24.629]                           computeRestarts <- base::computeRestarts
[10:33:24.629]                           grepl <- base::grepl
[10:33:24.629]                           restarts <- computeRestarts(cond)
[10:33:24.629]                           for (restart in restarts) {
[10:33:24.629]                             name <- restart$name
[10:33:24.629]                             if (is.null(name)) 
[10:33:24.629]                               next
[10:33:24.629]                             if (!grepl(pattern, name)) 
[10:33:24.629]                               next
[10:33:24.629]                             invokeRestart(restart)
[10:33:24.629]                             muffled <- TRUE
[10:33:24.629]                             break
[10:33:24.629]                           }
[10:33:24.629]                         }
[10:33:24.629]                       }
[10:33:24.629]                       invisible(muffled)
[10:33:24.629]                     }
[10:33:24.629]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.629]                   }
[10:33:24.629]                 }
[10:33:24.629]                 else {
[10:33:24.629]                   if (TRUE) {
[10:33:24.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.629]                     {
[10:33:24.629]                       inherits <- base::inherits
[10:33:24.629]                       invokeRestart <- base::invokeRestart
[10:33:24.629]                       is.null <- base::is.null
[10:33:24.629]                       muffled <- FALSE
[10:33:24.629]                       if (inherits(cond, "message")) {
[10:33:24.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.629]                         if (muffled) 
[10:33:24.629]                           invokeRestart("muffleMessage")
[10:33:24.629]                       }
[10:33:24.629]                       else if (inherits(cond, "warning")) {
[10:33:24.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.629]                         if (muffled) 
[10:33:24.629]                           invokeRestart("muffleWarning")
[10:33:24.629]                       }
[10:33:24.629]                       else if (inherits(cond, "condition")) {
[10:33:24.629]                         if (!is.null(pattern)) {
[10:33:24.629]                           computeRestarts <- base::computeRestarts
[10:33:24.629]                           grepl <- base::grepl
[10:33:24.629]                           restarts <- computeRestarts(cond)
[10:33:24.629]                           for (restart in restarts) {
[10:33:24.629]                             name <- restart$name
[10:33:24.629]                             if (is.null(name)) 
[10:33:24.629]                               next
[10:33:24.629]                             if (!grepl(pattern, name)) 
[10:33:24.629]                               next
[10:33:24.629]                             invokeRestart(restart)
[10:33:24.629]                             muffled <- TRUE
[10:33:24.629]                             break
[10:33:24.629]                           }
[10:33:24.629]                         }
[10:33:24.629]                       }
[10:33:24.629]                       invisible(muffled)
[10:33:24.629]                     }
[10:33:24.629]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.629]                   }
[10:33:24.629]                 }
[10:33:24.629]             }
[10:33:24.629]         }))
[10:33:24.629]     }, error = function(ex) {
[10:33:24.629]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.629]                 ...future.rng), started = ...future.startTime, 
[10:33:24.629]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.629]             version = "1.8"), class = "FutureResult")
[10:33:24.629]     }, finally = {
[10:33:24.629]         if (!identical(...future.workdir, getwd())) 
[10:33:24.629]             setwd(...future.workdir)
[10:33:24.629]         {
[10:33:24.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.629]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.629]             }
[10:33:24.629]             base::options(...future.oldOptions)
[10:33:24.629]             if (.Platform$OS.type == "windows") {
[10:33:24.629]                 old_names <- names(...future.oldEnvVars)
[10:33:24.629]                 envs <- base::Sys.getenv()
[10:33:24.629]                 names <- names(envs)
[10:33:24.629]                 common <- intersect(names, old_names)
[10:33:24.629]                 added <- setdiff(names, old_names)
[10:33:24.629]                 removed <- setdiff(old_names, names)
[10:33:24.629]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.629]                   envs[common]]
[10:33:24.629]                 NAMES <- toupper(changed)
[10:33:24.629]                 args <- list()
[10:33:24.629]                 for (kk in seq_along(NAMES)) {
[10:33:24.629]                   name <- changed[[kk]]
[10:33:24.629]                   NAME <- NAMES[[kk]]
[10:33:24.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.629]                     next
[10:33:24.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.629]                 }
[10:33:24.629]                 NAMES <- toupper(added)
[10:33:24.629]                 for (kk in seq_along(NAMES)) {
[10:33:24.629]                   name <- added[[kk]]
[10:33:24.629]                   NAME <- NAMES[[kk]]
[10:33:24.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.629]                     next
[10:33:24.629]                   args[[name]] <- ""
[10:33:24.629]                 }
[10:33:24.629]                 NAMES <- toupper(removed)
[10:33:24.629]                 for (kk in seq_along(NAMES)) {
[10:33:24.629]                   name <- removed[[kk]]
[10:33:24.629]                   NAME <- NAMES[[kk]]
[10:33:24.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.629]                     next
[10:33:24.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.629]                 }
[10:33:24.629]                 if (length(args) > 0) 
[10:33:24.629]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.629]             }
[10:33:24.629]             else {
[10:33:24.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.629]             }
[10:33:24.629]             {
[10:33:24.629]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.629]                   0L) {
[10:33:24.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.629]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.629]                   base::options(opts)
[10:33:24.629]                 }
[10:33:24.629]                 {
[10:33:24.629]                   {
[10:33:24.629]                     NULL
[10:33:24.629]                     RNGkind("Mersenne-Twister")
[10:33:24.629]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.629]                       inherits = FALSE)
[10:33:24.629]                   }
[10:33:24.629]                   options(future.plan = NULL)
[10:33:24.629]                   if (is.na(NA_character_)) 
[10:33:24.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.629]                     .init = FALSE)
[10:33:24.629]                 }
[10:33:24.629]             }
[10:33:24.629]         }
[10:33:24.629]     })
[10:33:24.629]     if (TRUE) {
[10:33:24.629]         base::sink(type = "output", split = FALSE)
[10:33:24.629]         if (TRUE) {
[10:33:24.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.629]         }
[10:33:24.629]         else {
[10:33:24.629]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.629]         }
[10:33:24.629]         base::close(...future.stdout)
[10:33:24.629]         ...future.stdout <- NULL
[10:33:24.629]     }
[10:33:24.629]     ...future.result$conditions <- ...future.conditions
[10:33:24.629]     ...future.result$finished <- base::Sys.time()
[10:33:24.629]     ...future.result
[10:33:24.629] }
[10:33:24.631] plan(): Setting new future strategy stack:
[10:33:24.631] List of future strategies:
[10:33:24.631] 1. sequential:
[10:33:24.631]    - args: function (..., envir = parent.frame())
[10:33:24.631]    - tweaked: FALSE
[10:33:24.631]    - call: NULL
[10:33:24.631] plan(): nbrOfWorkers() = 1
[10:33:24.632] plan(): Setting new future strategy stack:
[10:33:24.632] List of future strategies:
[10:33:24.632] 1. multicore:
[10:33:24.632]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.632]    - tweaked: FALSE
[10:33:24.632]    - call: plan(multicore)
[10:33:24.635] plan(): nbrOfWorkers() = 1
[10:33:24.635] SequentialFuture started (and completed)
[10:33:24.636] signalConditions() ...
[10:33:24.636]  - include = ‘immediateCondition’
[10:33:24.636]  - exclude = 
[10:33:24.636]  - resignal = FALSE
[10:33:24.636]  - Number of conditions: 1
[10:33:24.636] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:24.637] signalConditions() ...
[10:33:24.637]  - include = ‘immediateCondition’
[10:33:24.637]  - exclude = 
[10:33:24.637]  - resignal = FALSE
[10:33:24.637]  - Number of conditions: 1
[10:33:24.637] signalConditions() ... done
<MyError: boom>
[10:33:24.637] signalConditions() ...
[10:33:24.637]  - include = ‘immediateCondition’
[10:33:24.637]  - exclude = 
[10:33:24.638]  - resignal = FALSE
[10:33:24.638]  - Number of conditions: 1
[10:33:24.638] signalConditions() ... done
[10:33:24.638] Future state: ‘finished’
[10:33:24.638] signalConditions() ...
[10:33:24.638]  - include = ‘condition’
[10:33:24.638]  - exclude = ‘immediateCondition’
[10:33:24.638]  - resignal = TRUE
[10:33:24.638]  - Number of conditions: 1
[10:33:24.638]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:33:24.639] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[10:33:24.639] getGlobalsAndPackages() ...
[10:33:24.639] Searching for globals...
[10:33:24.640] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:33:24.640] Searching for globals ... DONE
[10:33:24.640] Resolving globals: FALSE
[10:33:24.640] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:24.641] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[10:33:24.641] - globals: [2] ‘a’, ‘b’
[10:33:24.641] 
[10:33:24.641] getGlobalsAndPackages() ... DONE
[10:33:24.641] Packages needed by the future expression (n = 0): <none>
[10:33:24.641] Packages needed by future strategies (n = 0): <none>
[10:33:24.642] {
[10:33:24.642]     {
[10:33:24.642]         {
[10:33:24.642]             ...future.startTime <- base::Sys.time()
[10:33:24.642]             {
[10:33:24.642]                 {
[10:33:24.642]                   {
[10:33:24.642]                     base::local({
[10:33:24.642]                       has_future <- base::requireNamespace("future", 
[10:33:24.642]                         quietly = TRUE)
[10:33:24.642]                       if (has_future) {
[10:33:24.642]                         ns <- base::getNamespace("future")
[10:33:24.642]                         version <- ns[[".package"]][["version"]]
[10:33:24.642]                         if (is.null(version)) 
[10:33:24.642]                           version <- utils::packageVersion("future")
[10:33:24.642]                       }
[10:33:24.642]                       else {
[10:33:24.642]                         version <- NULL
[10:33:24.642]                       }
[10:33:24.642]                       if (!has_future || version < "1.8.0") {
[10:33:24.642]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.642]                           "", base::R.version$version.string), 
[10:33:24.642]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:24.642]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.642]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.642]                             "release", "version")], collapse = " "), 
[10:33:24.642]                           hostname = base::Sys.info()[["nodename"]])
[10:33:24.642]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.642]                           info)
[10:33:24.642]                         info <- base::paste(info, collapse = "; ")
[10:33:24.642]                         if (!has_future) {
[10:33:24.642]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.642]                             info)
[10:33:24.642]                         }
[10:33:24.642]                         else {
[10:33:24.642]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.642]                             info, version)
[10:33:24.642]                         }
[10:33:24.642]                         base::stop(msg)
[10:33:24.642]                       }
[10:33:24.642]                     })
[10:33:24.642]                   }
[10:33:24.642]                   ...future.strategy.old <- future::plan("list")
[10:33:24.642]                   options(future.plan = NULL)
[10:33:24.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.642]                 }
[10:33:24.642]                 ...future.workdir <- getwd()
[10:33:24.642]             }
[10:33:24.642]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.642]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.642]         }
[10:33:24.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.642]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.642]             base::names(...future.oldOptions))
[10:33:24.642]     }
[10:33:24.642]     if (FALSE) {
[10:33:24.642]     }
[10:33:24.642]     else {
[10:33:24.642]         if (TRUE) {
[10:33:24.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.642]                 open = "w")
[10:33:24.642]         }
[10:33:24.642]         else {
[10:33:24.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.642]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.642]         }
[10:33:24.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.642]             base::sink(type = "output", split = FALSE)
[10:33:24.642]             base::close(...future.stdout)
[10:33:24.642]         }, add = TRUE)
[10:33:24.642]     }
[10:33:24.642]     ...future.frame <- base::sys.nframe()
[10:33:24.642]     ...future.conditions <- base::list()
[10:33:24.642]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.642]     if (FALSE) {
[10:33:24.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.642]     }
[10:33:24.642]     ...future.result <- base::tryCatch({
[10:33:24.642]         base::withCallingHandlers({
[10:33:24.642]             ...future.value <- base::withVisible(base::local({
[10:33:24.642]                 a * b
[10:33:24.642]             }))
[10:33:24.642]             future::FutureResult(value = ...future.value$value, 
[10:33:24.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.642]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.642]                     ...future.globalenv.names))
[10:33:24.642]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.642]         }, condition = base::local({
[10:33:24.642]             c <- base::c
[10:33:24.642]             inherits <- base::inherits
[10:33:24.642]             invokeRestart <- base::invokeRestart
[10:33:24.642]             length <- base::length
[10:33:24.642]             list <- base::list
[10:33:24.642]             seq.int <- base::seq.int
[10:33:24.642]             signalCondition <- base::signalCondition
[10:33:24.642]             sys.calls <- base::sys.calls
[10:33:24.642]             `[[` <- base::`[[`
[10:33:24.642]             `+` <- base::`+`
[10:33:24.642]             `<<-` <- base::`<<-`
[10:33:24.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.642]                   3L)]
[10:33:24.642]             }
[10:33:24.642]             function(cond) {
[10:33:24.642]                 is_error <- inherits(cond, "error")
[10:33:24.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.642]                   NULL)
[10:33:24.642]                 if (is_error) {
[10:33:24.642]                   sessionInformation <- function() {
[10:33:24.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.642]                       search = base::search(), system = base::Sys.info())
[10:33:24.642]                   }
[10:33:24.642]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.642]                     cond$call), session = sessionInformation(), 
[10:33:24.642]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.642]                   signalCondition(cond)
[10:33:24.642]                 }
[10:33:24.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.642]                 "immediateCondition"))) {
[10:33:24.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.642]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.642]                   if (TRUE && !signal) {
[10:33:24.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.642]                     {
[10:33:24.642]                       inherits <- base::inherits
[10:33:24.642]                       invokeRestart <- base::invokeRestart
[10:33:24.642]                       is.null <- base::is.null
[10:33:24.642]                       muffled <- FALSE
[10:33:24.642]                       if (inherits(cond, "message")) {
[10:33:24.642]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.642]                         if (muffled) 
[10:33:24.642]                           invokeRestart("muffleMessage")
[10:33:24.642]                       }
[10:33:24.642]                       else if (inherits(cond, "warning")) {
[10:33:24.642]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.642]                         if (muffled) 
[10:33:24.642]                           invokeRestart("muffleWarning")
[10:33:24.642]                       }
[10:33:24.642]                       else if (inherits(cond, "condition")) {
[10:33:24.642]                         if (!is.null(pattern)) {
[10:33:24.642]                           computeRestarts <- base::computeRestarts
[10:33:24.642]                           grepl <- base::grepl
[10:33:24.642]                           restarts <- computeRestarts(cond)
[10:33:24.642]                           for (restart in restarts) {
[10:33:24.642]                             name <- restart$name
[10:33:24.642]                             if (is.null(name)) 
[10:33:24.642]                               next
[10:33:24.642]                             if (!grepl(pattern, name)) 
[10:33:24.642]                               next
[10:33:24.642]                             invokeRestart(restart)
[10:33:24.642]                             muffled <- TRUE
[10:33:24.642]                             break
[10:33:24.642]                           }
[10:33:24.642]                         }
[10:33:24.642]                       }
[10:33:24.642]                       invisible(muffled)
[10:33:24.642]                     }
[10:33:24.642]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.642]                   }
[10:33:24.642]                 }
[10:33:24.642]                 else {
[10:33:24.642]                   if (TRUE) {
[10:33:24.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.642]                     {
[10:33:24.642]                       inherits <- base::inherits
[10:33:24.642]                       invokeRestart <- base::invokeRestart
[10:33:24.642]                       is.null <- base::is.null
[10:33:24.642]                       muffled <- FALSE
[10:33:24.642]                       if (inherits(cond, "message")) {
[10:33:24.642]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.642]                         if (muffled) 
[10:33:24.642]                           invokeRestart("muffleMessage")
[10:33:24.642]                       }
[10:33:24.642]                       else if (inherits(cond, "warning")) {
[10:33:24.642]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.642]                         if (muffled) 
[10:33:24.642]                           invokeRestart("muffleWarning")
[10:33:24.642]                       }
[10:33:24.642]                       else if (inherits(cond, "condition")) {
[10:33:24.642]                         if (!is.null(pattern)) {
[10:33:24.642]                           computeRestarts <- base::computeRestarts
[10:33:24.642]                           grepl <- base::grepl
[10:33:24.642]                           restarts <- computeRestarts(cond)
[10:33:24.642]                           for (restart in restarts) {
[10:33:24.642]                             name <- restart$name
[10:33:24.642]                             if (is.null(name)) 
[10:33:24.642]                               next
[10:33:24.642]                             if (!grepl(pattern, name)) 
[10:33:24.642]                               next
[10:33:24.642]                             invokeRestart(restart)
[10:33:24.642]                             muffled <- TRUE
[10:33:24.642]                             break
[10:33:24.642]                           }
[10:33:24.642]                         }
[10:33:24.642]                       }
[10:33:24.642]                       invisible(muffled)
[10:33:24.642]                     }
[10:33:24.642]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.642]                   }
[10:33:24.642]                 }
[10:33:24.642]             }
[10:33:24.642]         }))
[10:33:24.642]     }, error = function(ex) {
[10:33:24.642]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.642]                 ...future.rng), started = ...future.startTime, 
[10:33:24.642]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.642]             version = "1.8"), class = "FutureResult")
[10:33:24.642]     }, finally = {
[10:33:24.642]         if (!identical(...future.workdir, getwd())) 
[10:33:24.642]             setwd(...future.workdir)
[10:33:24.642]         {
[10:33:24.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.642]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.642]             }
[10:33:24.642]             base::options(...future.oldOptions)
[10:33:24.642]             if (.Platform$OS.type == "windows") {
[10:33:24.642]                 old_names <- names(...future.oldEnvVars)
[10:33:24.642]                 envs <- base::Sys.getenv()
[10:33:24.642]                 names <- names(envs)
[10:33:24.642]                 common <- intersect(names, old_names)
[10:33:24.642]                 added <- setdiff(names, old_names)
[10:33:24.642]                 removed <- setdiff(old_names, names)
[10:33:24.642]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.642]                   envs[common]]
[10:33:24.642]                 NAMES <- toupper(changed)
[10:33:24.642]                 args <- list()
[10:33:24.642]                 for (kk in seq_along(NAMES)) {
[10:33:24.642]                   name <- changed[[kk]]
[10:33:24.642]                   NAME <- NAMES[[kk]]
[10:33:24.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.642]                     next
[10:33:24.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.642]                 }
[10:33:24.642]                 NAMES <- toupper(added)
[10:33:24.642]                 for (kk in seq_along(NAMES)) {
[10:33:24.642]                   name <- added[[kk]]
[10:33:24.642]                   NAME <- NAMES[[kk]]
[10:33:24.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.642]                     next
[10:33:24.642]                   args[[name]] <- ""
[10:33:24.642]                 }
[10:33:24.642]                 NAMES <- toupper(removed)
[10:33:24.642]                 for (kk in seq_along(NAMES)) {
[10:33:24.642]                   name <- removed[[kk]]
[10:33:24.642]                   NAME <- NAMES[[kk]]
[10:33:24.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.642]                     next
[10:33:24.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.642]                 }
[10:33:24.642]                 if (length(args) > 0) 
[10:33:24.642]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.642]             }
[10:33:24.642]             else {
[10:33:24.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.642]             }
[10:33:24.642]             {
[10:33:24.642]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.642]                   0L) {
[10:33:24.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.642]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.642]                   base::options(opts)
[10:33:24.642]                 }
[10:33:24.642]                 {
[10:33:24.642]                   {
[10:33:24.642]                     NULL
[10:33:24.642]                     RNGkind("Mersenne-Twister")
[10:33:24.642]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:24.642]                       inherits = FALSE)
[10:33:24.642]                   }
[10:33:24.642]                   options(future.plan = NULL)
[10:33:24.642]                   if (is.na(NA_character_)) 
[10:33:24.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.642]                     .init = FALSE)
[10:33:24.642]                 }
[10:33:24.642]             }
[10:33:24.642]         }
[10:33:24.642]     })
[10:33:24.642]     if (TRUE) {
[10:33:24.642]         base::sink(type = "output", split = FALSE)
[10:33:24.642]         if (TRUE) {
[10:33:24.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.642]         }
[10:33:24.642]         else {
[10:33:24.642]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.642]         }
[10:33:24.642]         base::close(...future.stdout)
[10:33:24.642]         ...future.stdout <- NULL
[10:33:24.642]     }
[10:33:24.642]     ...future.result$conditions <- ...future.conditions
[10:33:24.642]     ...future.result$finished <- base::Sys.time()
[10:33:24.642]     ...future.result
[10:33:24.642] }
[10:33:24.643] assign_globals() ...
[10:33:24.643] List of 2
[10:33:24.643]  $ a: num 2
[10:33:24.643]  $ b: num 3
[10:33:24.643]  - attr(*, "where")=List of 2
[10:33:24.643]   ..$ a:<environment: R_EmptyEnv> 
[10:33:24.643]   ..$ b:<environment: R_EmptyEnv> 
[10:33:24.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.643]  - attr(*, "resolved")= logi FALSE
[10:33:24.643]  - attr(*, "total_size")= num 112
[10:33:24.646] - copied ‘a’ to environment
[10:33:24.646] - copied ‘b’ to environment
[10:33:24.646] assign_globals() ... done
[10:33:24.647] plan(): Setting new future strategy stack:
[10:33:24.647] List of future strategies:
[10:33:24.647] 1. sequential:
[10:33:24.647]    - args: function (..., envir = parent.frame())
[10:33:24.647]    - tweaked: FALSE
[10:33:24.647]    - call: NULL
[10:33:24.647] plan(): nbrOfWorkers() = 1
[10:33:24.648] plan(): Setting new future strategy stack:
[10:33:24.648] List of future strategies:
[10:33:24.648] 1. multicore:
[10:33:24.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.648]    - tweaked: FALSE
[10:33:24.648]    - call: plan(multicore)
[10:33:24.651] plan(): nbrOfWorkers() = 1
[10:33:24.651] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[10:33:24.660] getGlobalsAndPackages() ...
[10:33:24.660] Not searching for globals
[10:33:24.660] - globals: [0] <none>
[10:33:24.660] getGlobalsAndPackages() ... DONE
[10:33:24.661] Packages needed by the future expression (n = 0): <none>
[10:33:24.662] Packages needed by future strategies (n = 0): <none>
[10:33:24.662] {
[10:33:24.662]     {
[10:33:24.662]         {
[10:33:24.662]             ...future.startTime <- base::Sys.time()
[10:33:24.662]             {
[10:33:24.662]                 {
[10:33:24.662]                   {
[10:33:24.662]                     {
[10:33:24.662]                       base::local({
[10:33:24.662]                         has_future <- base::requireNamespace("future", 
[10:33:24.662]                           quietly = TRUE)
[10:33:24.662]                         if (has_future) {
[10:33:24.662]                           ns <- base::getNamespace("future")
[10:33:24.662]                           version <- ns[[".package"]][["version"]]
[10:33:24.662]                           if (is.null(version)) 
[10:33:24.662]                             version <- utils::packageVersion("future")
[10:33:24.662]                         }
[10:33:24.662]                         else {
[10:33:24.662]                           version <- NULL
[10:33:24.662]                         }
[10:33:24.662]                         if (!has_future || version < "1.8.0") {
[10:33:24.662]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.662]                             "", base::R.version$version.string), 
[10:33:24.662]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.662]                               "release", "version")], collapse = " "), 
[10:33:24.662]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.662]                             info)
[10:33:24.662]                           info <- base::paste(info, collapse = "; ")
[10:33:24.662]                           if (!has_future) {
[10:33:24.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.662]                               info)
[10:33:24.662]                           }
[10:33:24.662]                           else {
[10:33:24.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.662]                               info, version)
[10:33:24.662]                           }
[10:33:24.662]                           base::stop(msg)
[10:33:24.662]                         }
[10:33:24.662]                       })
[10:33:24.662]                     }
[10:33:24.662]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.662]                     base::options(mc.cores = 1L)
[10:33:24.662]                   }
[10:33:24.662]                   ...future.strategy.old <- future::plan("list")
[10:33:24.662]                   options(future.plan = NULL)
[10:33:24.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.662]                 }
[10:33:24.662]                 ...future.workdir <- getwd()
[10:33:24.662]             }
[10:33:24.662]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.662]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.662]         }
[10:33:24.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.662]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.662]             base::names(...future.oldOptions))
[10:33:24.662]     }
[10:33:24.662]     if (FALSE) {
[10:33:24.662]     }
[10:33:24.662]     else {
[10:33:24.662]         if (TRUE) {
[10:33:24.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.662]                 open = "w")
[10:33:24.662]         }
[10:33:24.662]         else {
[10:33:24.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.662]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.662]         }
[10:33:24.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.662]             base::sink(type = "output", split = FALSE)
[10:33:24.662]             base::close(...future.stdout)
[10:33:24.662]         }, add = TRUE)
[10:33:24.662]     }
[10:33:24.662]     ...future.frame <- base::sys.nframe()
[10:33:24.662]     ...future.conditions <- base::list()
[10:33:24.662]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.662]     if (FALSE) {
[10:33:24.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.662]     }
[10:33:24.662]     ...future.result <- base::tryCatch({
[10:33:24.662]         base::withCallingHandlers({
[10:33:24.662]             ...future.value <- base::withVisible(base::local({
[10:33:24.662]                 withCallingHandlers({
[10:33:24.662]                   {
[10:33:24.662]                     42L
[10:33:24.662]                   }
[10:33:24.662]                 }, immediateCondition = function(cond) {
[10:33:24.662]                   save_rds <- function (object, pathname, ...) 
[10:33:24.662]                   {
[10:33:24.662]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.662]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.662]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.662]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.662]                         fi_tmp[["mtime"]])
[10:33:24.662]                     }
[10:33:24.662]                     tryCatch({
[10:33:24.662]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.662]                     }, error = function(ex) {
[10:33:24.662]                       msg <- conditionMessage(ex)
[10:33:24.662]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.662]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.662]                         fi_tmp[["mtime"]], msg)
[10:33:24.662]                       ex$message <- msg
[10:33:24.662]                       stop(ex)
[10:33:24.662]                     })
[10:33:24.662]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.662]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.662]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.662]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.662]                       fi <- file.info(pathname)
[10:33:24.662]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.662]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.662]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.662]                         fi[["size"]], fi[["mtime"]])
[10:33:24.662]                       stop(msg)
[10:33:24.662]                     }
[10:33:24.662]                     invisible(pathname)
[10:33:24.662]                   }
[10:33:24.662]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.662]                     rootPath = tempdir()) 
[10:33:24.662]                   {
[10:33:24.662]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.662]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.662]                       tmpdir = path, fileext = ".rds")
[10:33:24.662]                     save_rds(obj, file)
[10:33:24.662]                   }
[10:33:24.662]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.662]                   {
[10:33:24.662]                     inherits <- base::inherits
[10:33:24.662]                     invokeRestart <- base::invokeRestart
[10:33:24.662]                     is.null <- base::is.null
[10:33:24.662]                     muffled <- FALSE
[10:33:24.662]                     if (inherits(cond, "message")) {
[10:33:24.662]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.662]                       if (muffled) 
[10:33:24.662]                         invokeRestart("muffleMessage")
[10:33:24.662]                     }
[10:33:24.662]                     else if (inherits(cond, "warning")) {
[10:33:24.662]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.662]                       if (muffled) 
[10:33:24.662]                         invokeRestart("muffleWarning")
[10:33:24.662]                     }
[10:33:24.662]                     else if (inherits(cond, "condition")) {
[10:33:24.662]                       if (!is.null(pattern)) {
[10:33:24.662]                         computeRestarts <- base::computeRestarts
[10:33:24.662]                         grepl <- base::grepl
[10:33:24.662]                         restarts <- computeRestarts(cond)
[10:33:24.662]                         for (restart in restarts) {
[10:33:24.662]                           name <- restart$name
[10:33:24.662]                           if (is.null(name)) 
[10:33:24.662]                             next
[10:33:24.662]                           if (!grepl(pattern, name)) 
[10:33:24.662]                             next
[10:33:24.662]                           invokeRestart(restart)
[10:33:24.662]                           muffled <- TRUE
[10:33:24.662]                           break
[10:33:24.662]                         }
[10:33:24.662]                       }
[10:33:24.662]                     }
[10:33:24.662]                     invisible(muffled)
[10:33:24.662]                   }
[10:33:24.662]                   muffleCondition(cond)
[10:33:24.662]                 })
[10:33:24.662]             }))
[10:33:24.662]             future::FutureResult(value = ...future.value$value, 
[10:33:24.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.662]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.662]                     ...future.globalenv.names))
[10:33:24.662]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.662]         }, condition = base::local({
[10:33:24.662]             c <- base::c
[10:33:24.662]             inherits <- base::inherits
[10:33:24.662]             invokeRestart <- base::invokeRestart
[10:33:24.662]             length <- base::length
[10:33:24.662]             list <- base::list
[10:33:24.662]             seq.int <- base::seq.int
[10:33:24.662]             signalCondition <- base::signalCondition
[10:33:24.662]             sys.calls <- base::sys.calls
[10:33:24.662]             `[[` <- base::`[[`
[10:33:24.662]             `+` <- base::`+`
[10:33:24.662]             `<<-` <- base::`<<-`
[10:33:24.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.662]                   3L)]
[10:33:24.662]             }
[10:33:24.662]             function(cond) {
[10:33:24.662]                 is_error <- inherits(cond, "error")
[10:33:24.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.662]                   NULL)
[10:33:24.662]                 if (is_error) {
[10:33:24.662]                   sessionInformation <- function() {
[10:33:24.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.662]                       search = base::search(), system = base::Sys.info())
[10:33:24.662]                   }
[10:33:24.662]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.662]                     cond$call), session = sessionInformation(), 
[10:33:24.662]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.662]                   signalCondition(cond)
[10:33:24.662]                 }
[10:33:24.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.662]                 "immediateCondition"))) {
[10:33:24.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.662]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.662]                   if (TRUE && !signal) {
[10:33:24.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.662]                     {
[10:33:24.662]                       inherits <- base::inherits
[10:33:24.662]                       invokeRestart <- base::invokeRestart
[10:33:24.662]                       is.null <- base::is.null
[10:33:24.662]                       muffled <- FALSE
[10:33:24.662]                       if (inherits(cond, "message")) {
[10:33:24.662]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.662]                         if (muffled) 
[10:33:24.662]                           invokeRestart("muffleMessage")
[10:33:24.662]                       }
[10:33:24.662]                       else if (inherits(cond, "warning")) {
[10:33:24.662]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.662]                         if (muffled) 
[10:33:24.662]                           invokeRestart("muffleWarning")
[10:33:24.662]                       }
[10:33:24.662]                       else if (inherits(cond, "condition")) {
[10:33:24.662]                         if (!is.null(pattern)) {
[10:33:24.662]                           computeRestarts <- base::computeRestarts
[10:33:24.662]                           grepl <- base::grepl
[10:33:24.662]                           restarts <- computeRestarts(cond)
[10:33:24.662]                           for (restart in restarts) {
[10:33:24.662]                             name <- restart$name
[10:33:24.662]                             if (is.null(name)) 
[10:33:24.662]                               next
[10:33:24.662]                             if (!grepl(pattern, name)) 
[10:33:24.662]                               next
[10:33:24.662]                             invokeRestart(restart)
[10:33:24.662]                             muffled <- TRUE
[10:33:24.662]                             break
[10:33:24.662]                           }
[10:33:24.662]                         }
[10:33:24.662]                       }
[10:33:24.662]                       invisible(muffled)
[10:33:24.662]                     }
[10:33:24.662]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.662]                   }
[10:33:24.662]                 }
[10:33:24.662]                 else {
[10:33:24.662]                   if (TRUE) {
[10:33:24.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.662]                     {
[10:33:24.662]                       inherits <- base::inherits
[10:33:24.662]                       invokeRestart <- base::invokeRestart
[10:33:24.662]                       is.null <- base::is.null
[10:33:24.662]                       muffled <- FALSE
[10:33:24.662]                       if (inherits(cond, "message")) {
[10:33:24.662]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.662]                         if (muffled) 
[10:33:24.662]                           invokeRestart("muffleMessage")
[10:33:24.662]                       }
[10:33:24.662]                       else if (inherits(cond, "warning")) {
[10:33:24.662]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.662]                         if (muffled) 
[10:33:24.662]                           invokeRestart("muffleWarning")
[10:33:24.662]                       }
[10:33:24.662]                       else if (inherits(cond, "condition")) {
[10:33:24.662]                         if (!is.null(pattern)) {
[10:33:24.662]                           computeRestarts <- base::computeRestarts
[10:33:24.662]                           grepl <- base::grepl
[10:33:24.662]                           restarts <- computeRestarts(cond)
[10:33:24.662]                           for (restart in restarts) {
[10:33:24.662]                             name <- restart$name
[10:33:24.662]                             if (is.null(name)) 
[10:33:24.662]                               next
[10:33:24.662]                             if (!grepl(pattern, name)) 
[10:33:24.662]                               next
[10:33:24.662]                             invokeRestart(restart)
[10:33:24.662]                             muffled <- TRUE
[10:33:24.662]                             break
[10:33:24.662]                           }
[10:33:24.662]                         }
[10:33:24.662]                       }
[10:33:24.662]                       invisible(muffled)
[10:33:24.662]                     }
[10:33:24.662]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.662]                   }
[10:33:24.662]                 }
[10:33:24.662]             }
[10:33:24.662]         }))
[10:33:24.662]     }, error = function(ex) {
[10:33:24.662]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.662]                 ...future.rng), started = ...future.startTime, 
[10:33:24.662]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.662]             version = "1.8"), class = "FutureResult")
[10:33:24.662]     }, finally = {
[10:33:24.662]         if (!identical(...future.workdir, getwd())) 
[10:33:24.662]             setwd(...future.workdir)
[10:33:24.662]         {
[10:33:24.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.662]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.662]             }
[10:33:24.662]             base::options(...future.oldOptions)
[10:33:24.662]             if (.Platform$OS.type == "windows") {
[10:33:24.662]                 old_names <- names(...future.oldEnvVars)
[10:33:24.662]                 envs <- base::Sys.getenv()
[10:33:24.662]                 names <- names(envs)
[10:33:24.662]                 common <- intersect(names, old_names)
[10:33:24.662]                 added <- setdiff(names, old_names)
[10:33:24.662]                 removed <- setdiff(old_names, names)
[10:33:24.662]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.662]                   envs[common]]
[10:33:24.662]                 NAMES <- toupper(changed)
[10:33:24.662]                 args <- list()
[10:33:24.662]                 for (kk in seq_along(NAMES)) {
[10:33:24.662]                   name <- changed[[kk]]
[10:33:24.662]                   NAME <- NAMES[[kk]]
[10:33:24.662]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.662]                     next
[10:33:24.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.662]                 }
[10:33:24.662]                 NAMES <- toupper(added)
[10:33:24.662]                 for (kk in seq_along(NAMES)) {
[10:33:24.662]                   name <- added[[kk]]
[10:33:24.662]                   NAME <- NAMES[[kk]]
[10:33:24.662]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.662]                     next
[10:33:24.662]                   args[[name]] <- ""
[10:33:24.662]                 }
[10:33:24.662]                 NAMES <- toupper(removed)
[10:33:24.662]                 for (kk in seq_along(NAMES)) {
[10:33:24.662]                   name <- removed[[kk]]
[10:33:24.662]                   NAME <- NAMES[[kk]]
[10:33:24.662]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.662]                     next
[10:33:24.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.662]                 }
[10:33:24.662]                 if (length(args) > 0) 
[10:33:24.662]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.662]             }
[10:33:24.662]             else {
[10:33:24.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.662]             }
[10:33:24.662]             {
[10:33:24.662]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.662]                   0L) {
[10:33:24.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.662]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.662]                   base::options(opts)
[10:33:24.662]                 }
[10:33:24.662]                 {
[10:33:24.662]                   {
[10:33:24.662]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.662]                     NULL
[10:33:24.662]                   }
[10:33:24.662]                   options(future.plan = NULL)
[10:33:24.662]                   if (is.na(NA_character_)) 
[10:33:24.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.662]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.662]                     .init = FALSE)
[10:33:24.662]                 }
[10:33:24.662]             }
[10:33:24.662]         }
[10:33:24.662]     })
[10:33:24.662]     if (TRUE) {
[10:33:24.662]         base::sink(type = "output", split = FALSE)
[10:33:24.662]         if (TRUE) {
[10:33:24.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.662]         }
[10:33:24.662]         else {
[10:33:24.662]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.662]         }
[10:33:24.662]         base::close(...future.stdout)
[10:33:24.662]         ...future.stdout <- NULL
[10:33:24.662]     }
[10:33:24.662]     ...future.result$conditions <- ...future.conditions
[10:33:24.662]     ...future.result$finished <- base::Sys.time()
[10:33:24.662]     ...future.result
[10:33:24.662] }
[10:33:24.664] requestCore(): workers = 2
[10:33:24.667] MulticoreFuture started
[10:33:24.668] plan(): Setting new future strategy stack:
[10:33:24.668] List of future strategies:
[10:33:24.668] 1. sequential:
[10:33:24.668]    - args: function (..., envir = parent.frame())
[10:33:24.668]    - tweaked: FALSE
[10:33:24.668]    - call: NULL
[10:33:24.669] plan(): nbrOfWorkers() = 1
[10:33:24.671] plan(): Setting new future strategy stack:
[10:33:24.671] List of future strategies:
[10:33:24.671] 1. multicore:
[10:33:24.671]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.671]    - tweaked: FALSE
[10:33:24.671]    - call: plan(multicore)
[10:33:24.676] plan(): nbrOfWorkers() = 2
[1] TRUE
[10:33:24.678] result() for MulticoreFuture ...
[10:33:24.683] result() for MulticoreFuture ...
[10:33:24.683] result() for MulticoreFuture ... done
[10:33:24.683] result() for MulticoreFuture ... done
[10:33:24.683] result() for MulticoreFuture ...
[10:33:24.683] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = FALSE) with globals
[10:33:24.687] getGlobalsAndPackages() ...
[10:33:24.687] Not searching for globals
[10:33:24.687] - globals: [0] <none>
[10:33:24.688] getGlobalsAndPackages() ... DONE
[10:33:24.688] Packages needed by the future expression (n = 0): <none>
[10:33:24.688] Packages needed by future strategies (n = 0): <none>
[10:33:24.689] {
[10:33:24.689]     {
[10:33:24.689]         {
[10:33:24.689]             ...future.startTime <- base::Sys.time()
[10:33:24.689]             {
[10:33:24.689]                 {
[10:33:24.689]                   {
[10:33:24.689]                     {
[10:33:24.689]                       base::local({
[10:33:24.689]                         has_future <- base::requireNamespace("future", 
[10:33:24.689]                           quietly = TRUE)
[10:33:24.689]                         if (has_future) {
[10:33:24.689]                           ns <- base::getNamespace("future")
[10:33:24.689]                           version <- ns[[".package"]][["version"]]
[10:33:24.689]                           if (is.null(version)) 
[10:33:24.689]                             version <- utils::packageVersion("future")
[10:33:24.689]                         }
[10:33:24.689]                         else {
[10:33:24.689]                           version <- NULL
[10:33:24.689]                         }
[10:33:24.689]                         if (!has_future || version < "1.8.0") {
[10:33:24.689]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.689]                             "", base::R.version$version.string), 
[10:33:24.689]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.689]                               "release", "version")], collapse = " "), 
[10:33:24.689]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.689]                             info)
[10:33:24.689]                           info <- base::paste(info, collapse = "; ")
[10:33:24.689]                           if (!has_future) {
[10:33:24.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.689]                               info)
[10:33:24.689]                           }
[10:33:24.689]                           else {
[10:33:24.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.689]                               info, version)
[10:33:24.689]                           }
[10:33:24.689]                           base::stop(msg)
[10:33:24.689]                         }
[10:33:24.689]                       })
[10:33:24.689]                     }
[10:33:24.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.689]                     base::options(mc.cores = 1L)
[10:33:24.689]                   }
[10:33:24.689]                   ...future.strategy.old <- future::plan("list")
[10:33:24.689]                   options(future.plan = NULL)
[10:33:24.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.689]                 }
[10:33:24.689]                 ...future.workdir <- getwd()
[10:33:24.689]             }
[10:33:24.689]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.689]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.689]         }
[10:33:24.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.689]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.689]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.689]             base::names(...future.oldOptions))
[10:33:24.689]     }
[10:33:24.689]     if (FALSE) {
[10:33:24.689]     }
[10:33:24.689]     else {
[10:33:24.689]         if (TRUE) {
[10:33:24.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.689]                 open = "w")
[10:33:24.689]         }
[10:33:24.689]         else {
[10:33:24.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.689]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.689]         }
[10:33:24.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.689]             base::sink(type = "output", split = FALSE)
[10:33:24.689]             base::close(...future.stdout)
[10:33:24.689]         }, add = TRUE)
[10:33:24.689]     }
[10:33:24.689]     ...future.frame <- base::sys.nframe()
[10:33:24.689]     ...future.conditions <- base::list()
[10:33:24.689]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.689]     if (FALSE) {
[10:33:24.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.689]     }
[10:33:24.689]     ...future.result <- base::tryCatch({
[10:33:24.689]         base::withCallingHandlers({
[10:33:24.689]             ...future.value <- base::withVisible(base::local({
[10:33:24.689]                 withCallingHandlers({
[10:33:24.689]                   {
[10:33:24.689]                     b <- 3
[10:33:24.689]                     c <- 2
[10:33:24.689]                     a * b * c
[10:33:24.689]                   }
[10:33:24.689]                 }, immediateCondition = function(cond) {
[10:33:24.689]                   save_rds <- function (object, pathname, ...) 
[10:33:24.689]                   {
[10:33:24.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.689]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.689]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.689]                         fi_tmp[["mtime"]])
[10:33:24.689]                     }
[10:33:24.689]                     tryCatch({
[10:33:24.689]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.689]                     }, error = function(ex) {
[10:33:24.689]                       msg <- conditionMessage(ex)
[10:33:24.689]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.689]                         fi_tmp[["mtime"]], msg)
[10:33:24.689]                       ex$message <- msg
[10:33:24.689]                       stop(ex)
[10:33:24.689]                     })
[10:33:24.689]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.689]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.689]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.689]                       fi <- file.info(pathname)
[10:33:24.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.689]                         fi[["size"]], fi[["mtime"]])
[10:33:24.689]                       stop(msg)
[10:33:24.689]                     }
[10:33:24.689]                     invisible(pathname)
[10:33:24.689]                   }
[10:33:24.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.689]                     rootPath = tempdir()) 
[10:33:24.689]                   {
[10:33:24.689]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.689]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.689]                       tmpdir = path, fileext = ".rds")
[10:33:24.689]                     save_rds(obj, file)
[10:33:24.689]                   }
[10:33:24.689]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.689]                   {
[10:33:24.689]                     inherits <- base::inherits
[10:33:24.689]                     invokeRestart <- base::invokeRestart
[10:33:24.689]                     is.null <- base::is.null
[10:33:24.689]                     muffled <- FALSE
[10:33:24.689]                     if (inherits(cond, "message")) {
[10:33:24.689]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.689]                       if (muffled) 
[10:33:24.689]                         invokeRestart("muffleMessage")
[10:33:24.689]                     }
[10:33:24.689]                     else if (inherits(cond, "warning")) {
[10:33:24.689]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.689]                       if (muffled) 
[10:33:24.689]                         invokeRestart("muffleWarning")
[10:33:24.689]                     }
[10:33:24.689]                     else if (inherits(cond, "condition")) {
[10:33:24.689]                       if (!is.null(pattern)) {
[10:33:24.689]                         computeRestarts <- base::computeRestarts
[10:33:24.689]                         grepl <- base::grepl
[10:33:24.689]                         restarts <- computeRestarts(cond)
[10:33:24.689]                         for (restart in restarts) {
[10:33:24.689]                           name <- restart$name
[10:33:24.689]                           if (is.null(name)) 
[10:33:24.689]                             next
[10:33:24.689]                           if (!grepl(pattern, name)) 
[10:33:24.689]                             next
[10:33:24.689]                           invokeRestart(restart)
[10:33:24.689]                           muffled <- TRUE
[10:33:24.689]                           break
[10:33:24.689]                         }
[10:33:24.689]                       }
[10:33:24.689]                     }
[10:33:24.689]                     invisible(muffled)
[10:33:24.689]                   }
[10:33:24.689]                   muffleCondition(cond)
[10:33:24.689]                 })
[10:33:24.689]             }))
[10:33:24.689]             future::FutureResult(value = ...future.value$value, 
[10:33:24.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.689]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.689]                     ...future.globalenv.names))
[10:33:24.689]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.689]         }, condition = base::local({
[10:33:24.689]             c <- base::c
[10:33:24.689]             inherits <- base::inherits
[10:33:24.689]             invokeRestart <- base::invokeRestart
[10:33:24.689]             length <- base::length
[10:33:24.689]             list <- base::list
[10:33:24.689]             seq.int <- base::seq.int
[10:33:24.689]             signalCondition <- base::signalCondition
[10:33:24.689]             sys.calls <- base::sys.calls
[10:33:24.689]             `[[` <- base::`[[`
[10:33:24.689]             `+` <- base::`+`
[10:33:24.689]             `<<-` <- base::`<<-`
[10:33:24.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.689]                   3L)]
[10:33:24.689]             }
[10:33:24.689]             function(cond) {
[10:33:24.689]                 is_error <- inherits(cond, "error")
[10:33:24.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.689]                   NULL)
[10:33:24.689]                 if (is_error) {
[10:33:24.689]                   sessionInformation <- function() {
[10:33:24.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.689]                       search = base::search(), system = base::Sys.info())
[10:33:24.689]                   }
[10:33:24.689]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.689]                     cond$call), session = sessionInformation(), 
[10:33:24.689]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.689]                   signalCondition(cond)
[10:33:24.689]                 }
[10:33:24.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.689]                 "immediateCondition"))) {
[10:33:24.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.689]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.689]                   if (TRUE && !signal) {
[10:33:24.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.689]                     {
[10:33:24.689]                       inherits <- base::inherits
[10:33:24.689]                       invokeRestart <- base::invokeRestart
[10:33:24.689]                       is.null <- base::is.null
[10:33:24.689]                       muffled <- FALSE
[10:33:24.689]                       if (inherits(cond, "message")) {
[10:33:24.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.689]                         if (muffled) 
[10:33:24.689]                           invokeRestart("muffleMessage")
[10:33:24.689]                       }
[10:33:24.689]                       else if (inherits(cond, "warning")) {
[10:33:24.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.689]                         if (muffled) 
[10:33:24.689]                           invokeRestart("muffleWarning")
[10:33:24.689]                       }
[10:33:24.689]                       else if (inherits(cond, "condition")) {
[10:33:24.689]                         if (!is.null(pattern)) {
[10:33:24.689]                           computeRestarts <- base::computeRestarts
[10:33:24.689]                           grepl <- base::grepl
[10:33:24.689]                           restarts <- computeRestarts(cond)
[10:33:24.689]                           for (restart in restarts) {
[10:33:24.689]                             name <- restart$name
[10:33:24.689]                             if (is.null(name)) 
[10:33:24.689]                               next
[10:33:24.689]                             if (!grepl(pattern, name)) 
[10:33:24.689]                               next
[10:33:24.689]                             invokeRestart(restart)
[10:33:24.689]                             muffled <- TRUE
[10:33:24.689]                             break
[10:33:24.689]                           }
[10:33:24.689]                         }
[10:33:24.689]                       }
[10:33:24.689]                       invisible(muffled)
[10:33:24.689]                     }
[10:33:24.689]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.689]                   }
[10:33:24.689]                 }
[10:33:24.689]                 else {
[10:33:24.689]                   if (TRUE) {
[10:33:24.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.689]                     {
[10:33:24.689]                       inherits <- base::inherits
[10:33:24.689]                       invokeRestart <- base::invokeRestart
[10:33:24.689]                       is.null <- base::is.null
[10:33:24.689]                       muffled <- FALSE
[10:33:24.689]                       if (inherits(cond, "message")) {
[10:33:24.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.689]                         if (muffled) 
[10:33:24.689]                           invokeRestart("muffleMessage")
[10:33:24.689]                       }
[10:33:24.689]                       else if (inherits(cond, "warning")) {
[10:33:24.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.689]                         if (muffled) 
[10:33:24.689]                           invokeRestart("muffleWarning")
[10:33:24.689]                       }
[10:33:24.689]                       else if (inherits(cond, "condition")) {
[10:33:24.689]                         if (!is.null(pattern)) {
[10:33:24.689]                           computeRestarts <- base::computeRestarts
[10:33:24.689]                           grepl <- base::grepl
[10:33:24.689]                           restarts <- computeRestarts(cond)
[10:33:24.689]                           for (restart in restarts) {
[10:33:24.689]                             name <- restart$name
[10:33:24.689]                             if (is.null(name)) 
[10:33:24.689]                               next
[10:33:24.689]                             if (!grepl(pattern, name)) 
[10:33:24.689]                               next
[10:33:24.689]                             invokeRestart(restart)
[10:33:24.689]                             muffled <- TRUE
[10:33:24.689]                             break
[10:33:24.689]                           }
[10:33:24.689]                         }
[10:33:24.689]                       }
[10:33:24.689]                       invisible(muffled)
[10:33:24.689]                     }
[10:33:24.689]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.689]                   }
[10:33:24.689]                 }
[10:33:24.689]             }
[10:33:24.689]         }))
[10:33:24.689]     }, error = function(ex) {
[10:33:24.689]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.689]                 ...future.rng), started = ...future.startTime, 
[10:33:24.689]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.689]             version = "1.8"), class = "FutureResult")
[10:33:24.689]     }, finally = {
[10:33:24.689]         if (!identical(...future.workdir, getwd())) 
[10:33:24.689]             setwd(...future.workdir)
[10:33:24.689]         {
[10:33:24.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.689]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.689]             }
[10:33:24.689]             base::options(...future.oldOptions)
[10:33:24.689]             if (.Platform$OS.type == "windows") {
[10:33:24.689]                 old_names <- names(...future.oldEnvVars)
[10:33:24.689]                 envs <- base::Sys.getenv()
[10:33:24.689]                 names <- names(envs)
[10:33:24.689]                 common <- intersect(names, old_names)
[10:33:24.689]                 added <- setdiff(names, old_names)
[10:33:24.689]                 removed <- setdiff(old_names, names)
[10:33:24.689]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.689]                   envs[common]]
[10:33:24.689]                 NAMES <- toupper(changed)
[10:33:24.689]                 args <- list()
[10:33:24.689]                 for (kk in seq_along(NAMES)) {
[10:33:24.689]                   name <- changed[[kk]]
[10:33:24.689]                   NAME <- NAMES[[kk]]
[10:33:24.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.689]                     next
[10:33:24.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.689]                 }
[10:33:24.689]                 NAMES <- toupper(added)
[10:33:24.689]                 for (kk in seq_along(NAMES)) {
[10:33:24.689]                   name <- added[[kk]]
[10:33:24.689]                   NAME <- NAMES[[kk]]
[10:33:24.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.689]                     next
[10:33:24.689]                   args[[name]] <- ""
[10:33:24.689]                 }
[10:33:24.689]                 NAMES <- toupper(removed)
[10:33:24.689]                 for (kk in seq_along(NAMES)) {
[10:33:24.689]                   name <- removed[[kk]]
[10:33:24.689]                   NAME <- NAMES[[kk]]
[10:33:24.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.689]                     next
[10:33:24.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.689]                 }
[10:33:24.689]                 if (length(args) > 0) 
[10:33:24.689]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.689]             }
[10:33:24.689]             else {
[10:33:24.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.689]             }
[10:33:24.689]             {
[10:33:24.689]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.689]                   0L) {
[10:33:24.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.689]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.689]                   base::options(opts)
[10:33:24.689]                 }
[10:33:24.689]                 {
[10:33:24.689]                   {
[10:33:24.689]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.689]                     NULL
[10:33:24.689]                   }
[10:33:24.689]                   options(future.plan = NULL)
[10:33:24.689]                   if (is.na(NA_character_)) 
[10:33:24.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.689]                     .init = FALSE)
[10:33:24.689]                 }
[10:33:24.689]             }
[10:33:24.689]         }
[10:33:24.689]     })
[10:33:24.689]     if (TRUE) {
[10:33:24.689]         base::sink(type = "output", split = FALSE)
[10:33:24.689]         if (TRUE) {
[10:33:24.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.689]         }
[10:33:24.689]         else {
[10:33:24.689]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.689]         }
[10:33:24.689]         base::close(...future.stdout)
[10:33:24.689]         ...future.stdout <- NULL
[10:33:24.689]     }
[10:33:24.689]     ...future.result$conditions <- ...future.conditions
[10:33:24.689]     ...future.result$finished <- base::Sys.time()
[10:33:24.689]     ...future.result
[10:33:24.689] }
[10:33:24.691] requestCore(): workers = 2
[10:33:24.693] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:33:24.694] plan(): Setting new future strategy stack:
[10:33:24.695] List of future strategies:
[10:33:24.695] 1. sequential:
[10:33:24.695]    - args: function (..., envir = parent.frame())
[10:33:24.695]    - tweaked: FALSE
[10:33:24.695]    - call: NULL
[10:33:24.695] plan(): nbrOfWorkers() = 1
[10:33:24.697] plan(): Setting new future strategy stack:
[10:33:24.698] List of future strategies:
[10:33:24.698] 1. multicore:
[10:33:24.698]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.698]    - tweaked: FALSE
[10:33:24.698]    - call: plan(multicore)
[10:33:24.703] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:24.704] result() for MulticoreFuture ...
[10:33:24.705] result() for MulticoreFuture ...
[10:33:24.705] result() for MulticoreFuture ... done
[10:33:24.705] result() for MulticoreFuture ... done
[10:33:24.705] result() for MulticoreFuture ...
[10:33:24.705] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[10:33:24.710] getGlobalsAndPackages() ...
[10:33:24.710] Not searching for globals
[10:33:24.710] - globals: [0] <none>
[10:33:24.710] getGlobalsAndPackages() ... DONE
[10:33:24.711] Packages needed by the future expression (n = 0): <none>
[10:33:24.711] Packages needed by future strategies (n = 0): <none>
[10:33:24.712] {
[10:33:24.712]     {
[10:33:24.712]         {
[10:33:24.712]             ...future.startTime <- base::Sys.time()
[10:33:24.712]             {
[10:33:24.712]                 {
[10:33:24.712]                   {
[10:33:24.712]                     {
[10:33:24.712]                       base::local({
[10:33:24.712]                         has_future <- base::requireNamespace("future", 
[10:33:24.712]                           quietly = TRUE)
[10:33:24.712]                         if (has_future) {
[10:33:24.712]                           ns <- base::getNamespace("future")
[10:33:24.712]                           version <- ns[[".package"]][["version"]]
[10:33:24.712]                           if (is.null(version)) 
[10:33:24.712]                             version <- utils::packageVersion("future")
[10:33:24.712]                         }
[10:33:24.712]                         else {
[10:33:24.712]                           version <- NULL
[10:33:24.712]                         }
[10:33:24.712]                         if (!has_future || version < "1.8.0") {
[10:33:24.712]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.712]                             "", base::R.version$version.string), 
[10:33:24.712]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.712]                               "release", "version")], collapse = " "), 
[10:33:24.712]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.712]                             info)
[10:33:24.712]                           info <- base::paste(info, collapse = "; ")
[10:33:24.712]                           if (!has_future) {
[10:33:24.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.712]                               info)
[10:33:24.712]                           }
[10:33:24.712]                           else {
[10:33:24.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.712]                               info, version)
[10:33:24.712]                           }
[10:33:24.712]                           base::stop(msg)
[10:33:24.712]                         }
[10:33:24.712]                       })
[10:33:24.712]                     }
[10:33:24.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.712]                     base::options(mc.cores = 1L)
[10:33:24.712]                   }
[10:33:24.712]                   ...future.strategy.old <- future::plan("list")
[10:33:24.712]                   options(future.plan = NULL)
[10:33:24.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.712]                 }
[10:33:24.712]                 ...future.workdir <- getwd()
[10:33:24.712]             }
[10:33:24.712]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.712]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.712]         }
[10:33:24.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.712]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.712]             base::names(...future.oldOptions))
[10:33:24.712]     }
[10:33:24.712]     if (FALSE) {
[10:33:24.712]     }
[10:33:24.712]     else {
[10:33:24.712]         if (TRUE) {
[10:33:24.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.712]                 open = "w")
[10:33:24.712]         }
[10:33:24.712]         else {
[10:33:24.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.712]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.712]         }
[10:33:24.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.712]             base::sink(type = "output", split = FALSE)
[10:33:24.712]             base::close(...future.stdout)
[10:33:24.712]         }, add = TRUE)
[10:33:24.712]     }
[10:33:24.712]     ...future.frame <- base::sys.nframe()
[10:33:24.712]     ...future.conditions <- base::list()
[10:33:24.712]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.712]     if (FALSE) {
[10:33:24.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.712]     }
[10:33:24.712]     ...future.result <- base::tryCatch({
[10:33:24.712]         base::withCallingHandlers({
[10:33:24.712]             ...future.value <- base::withVisible(base::local({
[10:33:24.712]                 withCallingHandlers({
[10:33:24.712]                   {
[10:33:24.712]                     ii
[10:33:24.712]                   }
[10:33:24.712]                 }, immediateCondition = function(cond) {
[10:33:24.712]                   save_rds <- function (object, pathname, ...) 
[10:33:24.712]                   {
[10:33:24.712]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.712]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.712]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.712]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.712]                         fi_tmp[["mtime"]])
[10:33:24.712]                     }
[10:33:24.712]                     tryCatch({
[10:33:24.712]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.712]                     }, error = function(ex) {
[10:33:24.712]                       msg <- conditionMessage(ex)
[10:33:24.712]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.712]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.712]                         fi_tmp[["mtime"]], msg)
[10:33:24.712]                       ex$message <- msg
[10:33:24.712]                       stop(ex)
[10:33:24.712]                     })
[10:33:24.712]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.712]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.712]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.712]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.712]                       fi <- file.info(pathname)
[10:33:24.712]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.712]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.712]                         fi[["size"]], fi[["mtime"]])
[10:33:24.712]                       stop(msg)
[10:33:24.712]                     }
[10:33:24.712]                     invisible(pathname)
[10:33:24.712]                   }
[10:33:24.712]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.712]                     rootPath = tempdir()) 
[10:33:24.712]                   {
[10:33:24.712]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.712]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.712]                       tmpdir = path, fileext = ".rds")
[10:33:24.712]                     save_rds(obj, file)
[10:33:24.712]                   }
[10:33:24.712]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.712]                   {
[10:33:24.712]                     inherits <- base::inherits
[10:33:24.712]                     invokeRestart <- base::invokeRestart
[10:33:24.712]                     is.null <- base::is.null
[10:33:24.712]                     muffled <- FALSE
[10:33:24.712]                     if (inherits(cond, "message")) {
[10:33:24.712]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.712]                       if (muffled) 
[10:33:24.712]                         invokeRestart("muffleMessage")
[10:33:24.712]                     }
[10:33:24.712]                     else if (inherits(cond, "warning")) {
[10:33:24.712]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.712]                       if (muffled) 
[10:33:24.712]                         invokeRestart("muffleWarning")
[10:33:24.712]                     }
[10:33:24.712]                     else if (inherits(cond, "condition")) {
[10:33:24.712]                       if (!is.null(pattern)) {
[10:33:24.712]                         computeRestarts <- base::computeRestarts
[10:33:24.712]                         grepl <- base::grepl
[10:33:24.712]                         restarts <- computeRestarts(cond)
[10:33:24.712]                         for (restart in restarts) {
[10:33:24.712]                           name <- restart$name
[10:33:24.712]                           if (is.null(name)) 
[10:33:24.712]                             next
[10:33:24.712]                           if (!grepl(pattern, name)) 
[10:33:24.712]                             next
[10:33:24.712]                           invokeRestart(restart)
[10:33:24.712]                           muffled <- TRUE
[10:33:24.712]                           break
[10:33:24.712]                         }
[10:33:24.712]                       }
[10:33:24.712]                     }
[10:33:24.712]                     invisible(muffled)
[10:33:24.712]                   }
[10:33:24.712]                   muffleCondition(cond)
[10:33:24.712]                 })
[10:33:24.712]             }))
[10:33:24.712]             future::FutureResult(value = ...future.value$value, 
[10:33:24.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.712]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.712]                     ...future.globalenv.names))
[10:33:24.712]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.712]         }, condition = base::local({
[10:33:24.712]             c <- base::c
[10:33:24.712]             inherits <- base::inherits
[10:33:24.712]             invokeRestart <- base::invokeRestart
[10:33:24.712]             length <- base::length
[10:33:24.712]             list <- base::list
[10:33:24.712]             seq.int <- base::seq.int
[10:33:24.712]             signalCondition <- base::signalCondition
[10:33:24.712]             sys.calls <- base::sys.calls
[10:33:24.712]             `[[` <- base::`[[`
[10:33:24.712]             `+` <- base::`+`
[10:33:24.712]             `<<-` <- base::`<<-`
[10:33:24.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.712]                   3L)]
[10:33:24.712]             }
[10:33:24.712]             function(cond) {
[10:33:24.712]                 is_error <- inherits(cond, "error")
[10:33:24.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.712]                   NULL)
[10:33:24.712]                 if (is_error) {
[10:33:24.712]                   sessionInformation <- function() {
[10:33:24.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.712]                       search = base::search(), system = base::Sys.info())
[10:33:24.712]                   }
[10:33:24.712]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.712]                     cond$call), session = sessionInformation(), 
[10:33:24.712]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.712]                   signalCondition(cond)
[10:33:24.712]                 }
[10:33:24.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.712]                 "immediateCondition"))) {
[10:33:24.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.712]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.712]                   if (TRUE && !signal) {
[10:33:24.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.712]                     {
[10:33:24.712]                       inherits <- base::inherits
[10:33:24.712]                       invokeRestart <- base::invokeRestart
[10:33:24.712]                       is.null <- base::is.null
[10:33:24.712]                       muffled <- FALSE
[10:33:24.712]                       if (inherits(cond, "message")) {
[10:33:24.712]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.712]                         if (muffled) 
[10:33:24.712]                           invokeRestart("muffleMessage")
[10:33:24.712]                       }
[10:33:24.712]                       else if (inherits(cond, "warning")) {
[10:33:24.712]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.712]                         if (muffled) 
[10:33:24.712]                           invokeRestart("muffleWarning")
[10:33:24.712]                       }
[10:33:24.712]                       else if (inherits(cond, "condition")) {
[10:33:24.712]                         if (!is.null(pattern)) {
[10:33:24.712]                           computeRestarts <- base::computeRestarts
[10:33:24.712]                           grepl <- base::grepl
[10:33:24.712]                           restarts <- computeRestarts(cond)
[10:33:24.712]                           for (restart in restarts) {
[10:33:24.712]                             name <- restart$name
[10:33:24.712]                             if (is.null(name)) 
[10:33:24.712]                               next
[10:33:24.712]                             if (!grepl(pattern, name)) 
[10:33:24.712]                               next
[10:33:24.712]                             invokeRestart(restart)
[10:33:24.712]                             muffled <- TRUE
[10:33:24.712]                             break
[10:33:24.712]                           }
[10:33:24.712]                         }
[10:33:24.712]                       }
[10:33:24.712]                       invisible(muffled)
[10:33:24.712]                     }
[10:33:24.712]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.712]                   }
[10:33:24.712]                 }
[10:33:24.712]                 else {
[10:33:24.712]                   if (TRUE) {
[10:33:24.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.712]                     {
[10:33:24.712]                       inherits <- base::inherits
[10:33:24.712]                       invokeRestart <- base::invokeRestart
[10:33:24.712]                       is.null <- base::is.null
[10:33:24.712]                       muffled <- FALSE
[10:33:24.712]                       if (inherits(cond, "message")) {
[10:33:24.712]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.712]                         if (muffled) 
[10:33:24.712]                           invokeRestart("muffleMessage")
[10:33:24.712]                       }
[10:33:24.712]                       else if (inherits(cond, "warning")) {
[10:33:24.712]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.712]                         if (muffled) 
[10:33:24.712]                           invokeRestart("muffleWarning")
[10:33:24.712]                       }
[10:33:24.712]                       else if (inherits(cond, "condition")) {
[10:33:24.712]                         if (!is.null(pattern)) {
[10:33:24.712]                           computeRestarts <- base::computeRestarts
[10:33:24.712]                           grepl <- base::grepl
[10:33:24.712]                           restarts <- computeRestarts(cond)
[10:33:24.712]                           for (restart in restarts) {
[10:33:24.712]                             name <- restart$name
[10:33:24.712]                             if (is.null(name)) 
[10:33:24.712]                               next
[10:33:24.712]                             if (!grepl(pattern, name)) 
[10:33:24.712]                               next
[10:33:24.712]                             invokeRestart(restart)
[10:33:24.712]                             muffled <- TRUE
[10:33:24.712]                             break
[10:33:24.712]                           }
[10:33:24.712]                         }
[10:33:24.712]                       }
[10:33:24.712]                       invisible(muffled)
[10:33:24.712]                     }
[10:33:24.712]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.712]                   }
[10:33:24.712]                 }
[10:33:24.712]             }
[10:33:24.712]         }))
[10:33:24.712]     }, error = function(ex) {
[10:33:24.712]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.712]                 ...future.rng), started = ...future.startTime, 
[10:33:24.712]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.712]             version = "1.8"), class = "FutureResult")
[10:33:24.712]     }, finally = {
[10:33:24.712]         if (!identical(...future.workdir, getwd())) 
[10:33:24.712]             setwd(...future.workdir)
[10:33:24.712]         {
[10:33:24.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.712]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.712]             }
[10:33:24.712]             base::options(...future.oldOptions)
[10:33:24.712]             if (.Platform$OS.type == "windows") {
[10:33:24.712]                 old_names <- names(...future.oldEnvVars)
[10:33:24.712]                 envs <- base::Sys.getenv()
[10:33:24.712]                 names <- names(envs)
[10:33:24.712]                 common <- intersect(names, old_names)
[10:33:24.712]                 added <- setdiff(names, old_names)
[10:33:24.712]                 removed <- setdiff(old_names, names)
[10:33:24.712]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.712]                   envs[common]]
[10:33:24.712]                 NAMES <- toupper(changed)
[10:33:24.712]                 args <- list()
[10:33:24.712]                 for (kk in seq_along(NAMES)) {
[10:33:24.712]                   name <- changed[[kk]]
[10:33:24.712]                   NAME <- NAMES[[kk]]
[10:33:24.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.712]                     next
[10:33:24.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.712]                 }
[10:33:24.712]                 NAMES <- toupper(added)
[10:33:24.712]                 for (kk in seq_along(NAMES)) {
[10:33:24.712]                   name <- added[[kk]]
[10:33:24.712]                   NAME <- NAMES[[kk]]
[10:33:24.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.712]                     next
[10:33:24.712]                   args[[name]] <- ""
[10:33:24.712]                 }
[10:33:24.712]                 NAMES <- toupper(removed)
[10:33:24.712]                 for (kk in seq_along(NAMES)) {
[10:33:24.712]                   name <- removed[[kk]]
[10:33:24.712]                   NAME <- NAMES[[kk]]
[10:33:24.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.712]                     next
[10:33:24.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.712]                 }
[10:33:24.712]                 if (length(args) > 0) 
[10:33:24.712]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.712]             }
[10:33:24.712]             else {
[10:33:24.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.712]             }
[10:33:24.712]             {
[10:33:24.712]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.712]                   0L) {
[10:33:24.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.712]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.712]                   base::options(opts)
[10:33:24.712]                 }
[10:33:24.712]                 {
[10:33:24.712]                   {
[10:33:24.712]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.712]                     NULL
[10:33:24.712]                   }
[10:33:24.712]                   options(future.plan = NULL)
[10:33:24.712]                   if (is.na(NA_character_)) 
[10:33:24.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.712]                     .init = FALSE)
[10:33:24.712]                 }
[10:33:24.712]             }
[10:33:24.712]         }
[10:33:24.712]     })
[10:33:24.712]     if (TRUE) {
[10:33:24.712]         base::sink(type = "output", split = FALSE)
[10:33:24.712]         if (TRUE) {
[10:33:24.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.712]         }
[10:33:24.712]         else {
[10:33:24.712]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.712]         }
[10:33:24.712]         base::close(...future.stdout)
[10:33:24.712]         ...future.stdout <- NULL
[10:33:24.712]     }
[10:33:24.712]     ...future.result$conditions <- ...future.conditions
[10:33:24.712]     ...future.result$finished <- base::Sys.time()
[10:33:24.712]     ...future.result
[10:33:24.712] }
[10:33:24.714] requestCore(): workers = 2
[10:33:24.716] MulticoreFuture started
 - Creating multicore future #2 ...
[10:33:24.717] plan(): Setting new future strategy stack:
[10:33:24.718] List of future strategies:
[10:33:24.718] 1. sequential:
[10:33:24.718]    - args: function (..., envir = parent.frame())
[10:33:24.718]    - tweaked: FALSE
[10:33:24.718]    - call: NULL
[10:33:24.718] plan(): nbrOfWorkers() = 1
[10:33:24.720] plan(): Setting new future strategy stack:
[10:33:24.721] List of future strategies:
[10:33:24.721] 1. multicore:
[10:33:24.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.721]    - tweaked: FALSE
[10:33:24.721]    - call: plan(multicore)
[10:33:24.722] getGlobalsAndPackages() ...
[10:33:24.723] Not searching for globals
[10:33:24.723] - globals: [0] <none>
[10:33:24.723] getGlobalsAndPackages() ... DONE
[10:33:24.724] Packages needed by the future expression (n = 0): <none>
[10:33:24.724] Packages needed by future strategies (n = 0): <none>
[10:33:24.726] plan(): nbrOfWorkers() = 2
[10:33:24.725] {
[10:33:24.725]     {
[10:33:24.725]         {
[10:33:24.725]             ...future.startTime <- base::Sys.time()
[10:33:24.725]             {
[10:33:24.725]                 {
[10:33:24.725]                   {
[10:33:24.725]                     {
[10:33:24.725]                       base::local({
[10:33:24.725]                         has_future <- base::requireNamespace("future", 
[10:33:24.725]                           quietly = TRUE)
[10:33:24.725]                         if (has_future) {
[10:33:24.725]                           ns <- base::getNamespace("future")
[10:33:24.725]                           version <- ns[[".package"]][["version"]]
[10:33:24.725]                           if (is.null(version)) 
[10:33:24.725]                             version <- utils::packageVersion("future")
[10:33:24.725]                         }
[10:33:24.725]                         else {
[10:33:24.725]                           version <- NULL
[10:33:24.725]                         }
[10:33:24.725]                         if (!has_future || version < "1.8.0") {
[10:33:24.725]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.725]                             "", base::R.version$version.string), 
[10:33:24.725]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.725]                               "release", "version")], collapse = " "), 
[10:33:24.725]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.725]                             info)
[10:33:24.725]                           info <- base::paste(info, collapse = "; ")
[10:33:24.725]                           if (!has_future) {
[10:33:24.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.725]                               info)
[10:33:24.725]                           }
[10:33:24.725]                           else {
[10:33:24.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.725]                               info, version)
[10:33:24.725]                           }
[10:33:24.725]                           base::stop(msg)
[10:33:24.725]                         }
[10:33:24.725]                       })
[10:33:24.725]                     }
[10:33:24.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.725]                     base::options(mc.cores = 1L)
[10:33:24.725]                   }
[10:33:24.725]                   ...future.strategy.old <- future::plan("list")
[10:33:24.725]                   options(future.plan = NULL)
[10:33:24.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.725]                 }
[10:33:24.725]                 ...future.workdir <- getwd()
[10:33:24.725]             }
[10:33:24.725]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.725]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.725]         }
[10:33:24.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.725]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.725]             base::names(...future.oldOptions))
[10:33:24.725]     }
[10:33:24.725]     if (FALSE) {
[10:33:24.725]     }
[10:33:24.725]     else {
[10:33:24.725]         if (TRUE) {
[10:33:24.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.725]                 open = "w")
[10:33:24.725]         }
[10:33:24.725]         else {
[10:33:24.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.725]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.725]         }
[10:33:24.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.725]             base::sink(type = "output", split = FALSE)
[10:33:24.725]             base::close(...future.stdout)
[10:33:24.725]         }, add = TRUE)
[10:33:24.725]     }
[10:33:24.725]     ...future.frame <- base::sys.nframe()
[10:33:24.725]     ...future.conditions <- base::list()
[10:33:24.725]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.725]     if (FALSE) {
[10:33:24.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.725]     }
[10:33:24.725]     ...future.result <- base::tryCatch({
[10:33:24.725]         base::withCallingHandlers({
[10:33:24.725]             ...future.value <- base::withVisible(base::local({
[10:33:24.725]                 withCallingHandlers({
[10:33:24.725]                   {
[10:33:24.725]                     ii
[10:33:24.725]                   }
[10:33:24.725]                 }, immediateCondition = function(cond) {
[10:33:24.725]                   save_rds <- function (object, pathname, ...) 
[10:33:24.725]                   {
[10:33:24.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.725]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.725]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.725]                         fi_tmp[["mtime"]])
[10:33:24.725]                     }
[10:33:24.725]                     tryCatch({
[10:33:24.725]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.725]                     }, error = function(ex) {
[10:33:24.725]                       msg <- conditionMessage(ex)
[10:33:24.725]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.725]                         fi_tmp[["mtime"]], msg)
[10:33:24.725]                       ex$message <- msg
[10:33:24.725]                       stop(ex)
[10:33:24.725]                     })
[10:33:24.725]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.725]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.725]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.725]                       fi <- file.info(pathname)
[10:33:24.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.725]                         fi[["size"]], fi[["mtime"]])
[10:33:24.725]                       stop(msg)
[10:33:24.725]                     }
[10:33:24.725]                     invisible(pathname)
[10:33:24.725]                   }
[10:33:24.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.725]                     rootPath = tempdir()) 
[10:33:24.725]                   {
[10:33:24.725]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.725]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.725]                       tmpdir = path, fileext = ".rds")
[10:33:24.725]                     save_rds(obj, file)
[10:33:24.725]                   }
[10:33:24.725]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.725]                   {
[10:33:24.725]                     inherits <- base::inherits
[10:33:24.725]                     invokeRestart <- base::invokeRestart
[10:33:24.725]                     is.null <- base::is.null
[10:33:24.725]                     muffled <- FALSE
[10:33:24.725]                     if (inherits(cond, "message")) {
[10:33:24.725]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.725]                       if (muffled) 
[10:33:24.725]                         invokeRestart("muffleMessage")
[10:33:24.725]                     }
[10:33:24.725]                     else if (inherits(cond, "warning")) {
[10:33:24.725]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.725]                       if (muffled) 
[10:33:24.725]                         invokeRestart("muffleWarning")
[10:33:24.725]                     }
[10:33:24.725]                     else if (inherits(cond, "condition")) {
[10:33:24.725]                       if (!is.null(pattern)) {
[10:33:24.725]                         computeRestarts <- base::computeRestarts
[10:33:24.725]                         grepl <- base::grepl
[10:33:24.725]                         restarts <- computeRestarts(cond)
[10:33:24.725]                         for (restart in restarts) {
[10:33:24.725]                           name <- restart$name
[10:33:24.725]                           if (is.null(name)) 
[10:33:24.725]                             next
[10:33:24.725]                           if (!grepl(pattern, name)) 
[10:33:24.725]                             next
[10:33:24.725]                           invokeRestart(restart)
[10:33:24.725]                           muffled <- TRUE
[10:33:24.725]                           break
[10:33:24.725]                         }
[10:33:24.725]                       }
[10:33:24.725]                     }
[10:33:24.725]                     invisible(muffled)
[10:33:24.725]                   }
[10:33:24.725]                   muffleCondition(cond)
[10:33:24.725]                 })
[10:33:24.725]             }))
[10:33:24.725]             future::FutureResult(value = ...future.value$value, 
[10:33:24.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.725]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.725]                     ...future.globalenv.names))
[10:33:24.725]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.725]         }, condition = base::local({
[10:33:24.725]             c <- base::c
[10:33:24.725]             inherits <- base::inherits
[10:33:24.725]             invokeRestart <- base::invokeRestart
[10:33:24.725]             length <- base::length
[10:33:24.725]             list <- base::list
[10:33:24.725]             seq.int <- base::seq.int
[10:33:24.725]             signalCondition <- base::signalCondition
[10:33:24.725]             sys.calls <- base::sys.calls
[10:33:24.725]             `[[` <- base::`[[`
[10:33:24.725]             `+` <- base::`+`
[10:33:24.725]             `<<-` <- base::`<<-`
[10:33:24.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.725]                   3L)]
[10:33:24.725]             }
[10:33:24.725]             function(cond) {
[10:33:24.725]                 is_error <- inherits(cond, "error")
[10:33:24.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.725]                   NULL)
[10:33:24.725]                 if (is_error) {
[10:33:24.725]                   sessionInformation <- function() {
[10:33:24.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.725]                       search = base::search(), system = base::Sys.info())
[10:33:24.725]                   }
[10:33:24.725]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.725]                     cond$call), session = sessionInformation(), 
[10:33:24.725]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.725]                   signalCondition(cond)
[10:33:24.725]                 }
[10:33:24.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.725]                 "immediateCondition"))) {
[10:33:24.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.725]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.725]                   if (TRUE && !signal) {
[10:33:24.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.725]                     {
[10:33:24.725]                       inherits <- base::inherits
[10:33:24.725]                       invokeRestart <- base::invokeRestart
[10:33:24.725]                       is.null <- base::is.null
[10:33:24.725]                       muffled <- FALSE
[10:33:24.725]                       if (inherits(cond, "message")) {
[10:33:24.725]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.725]                         if (muffled) 
[10:33:24.725]                           invokeRestart("muffleMessage")
[10:33:24.725]                       }
[10:33:24.725]                       else if (inherits(cond, "warning")) {
[10:33:24.725]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.725]                         if (muffled) 
[10:33:24.725]                           invokeRestart("muffleWarning")
[10:33:24.725]                       }
[10:33:24.725]                       else if (inherits(cond, "condition")) {
[10:33:24.725]                         if (!is.null(pattern)) {
[10:33:24.725]                           computeRestarts <- base::computeRestarts
[10:33:24.725]                           grepl <- base::grepl
[10:33:24.725]                           restarts <- computeRestarts(cond)
[10:33:24.725]                           for (restart in restarts) {
[10:33:24.725]                             name <- restart$name
[10:33:24.725]                             if (is.null(name)) 
[10:33:24.725]                               next
[10:33:24.725]                             if (!grepl(pattern, name)) 
[10:33:24.725]                               next
[10:33:24.725]                             invokeRestart(restart)
[10:33:24.725]                             muffled <- TRUE
[10:33:24.725]                             break
[10:33:24.725]                           }
[10:33:24.725]                         }
[10:33:24.725]                       }
[10:33:24.725]                       invisible(muffled)
[10:33:24.725]                     }
[10:33:24.725]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.725]                   }
[10:33:24.725]                 }
[10:33:24.725]                 else {
[10:33:24.725]                   if (TRUE) {
[10:33:24.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.725]                     {
[10:33:24.725]                       inherits <- base::inherits
[10:33:24.725]                       invokeRestart <- base::invokeRestart
[10:33:24.725]                       is.null <- base::is.null
[10:33:24.725]                       muffled <- FALSE
[10:33:24.725]                       if (inherits(cond, "message")) {
[10:33:24.725]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.725]                         if (muffled) 
[10:33:24.725]                           invokeRestart("muffleMessage")
[10:33:24.725]                       }
[10:33:24.725]                       else if (inherits(cond, "warning")) {
[10:33:24.725]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.725]                         if (muffled) 
[10:33:24.725]                           invokeRestart("muffleWarning")
[10:33:24.725]                       }
[10:33:24.725]                       else if (inherits(cond, "condition")) {
[10:33:24.725]                         if (!is.null(pattern)) {
[10:33:24.725]                           computeRestarts <- base::computeRestarts
[10:33:24.725]                           grepl <- base::grepl
[10:33:24.725]                           restarts <- computeRestarts(cond)
[10:33:24.725]                           for (restart in restarts) {
[10:33:24.725]                             name <- restart$name
[10:33:24.725]                             if (is.null(name)) 
[10:33:24.725]                               next
[10:33:24.725]                             if (!grepl(pattern, name)) 
[10:33:24.725]                               next
[10:33:24.725]                             invokeRestart(restart)
[10:33:24.725]                             muffled <- TRUE
[10:33:24.725]                             break
[10:33:24.725]                           }
[10:33:24.725]                         }
[10:33:24.725]                       }
[10:33:24.725]                       invisible(muffled)
[10:33:24.725]                     }
[10:33:24.725]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.725]                   }
[10:33:24.725]                 }
[10:33:24.725]             }
[10:33:24.725]         }))
[10:33:24.725]     }, error = function(ex) {
[10:33:24.725]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.725]                 ...future.rng), started = ...future.startTime, 
[10:33:24.725]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.725]             version = "1.8"), class = "FutureResult")
[10:33:24.725]     }, finally = {
[10:33:24.725]         if (!identical(...future.workdir, getwd())) 
[10:33:24.725]             setwd(...future.workdir)
[10:33:24.725]         {
[10:33:24.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.725]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.725]             }
[10:33:24.725]             base::options(...future.oldOptions)
[10:33:24.725]             if (.Platform$OS.type == "windows") {
[10:33:24.725]                 old_names <- names(...future.oldEnvVars)
[10:33:24.725]                 envs <- base::Sys.getenv()
[10:33:24.725]                 names <- names(envs)
[10:33:24.725]                 common <- intersect(names, old_names)
[10:33:24.725]                 added <- setdiff(names, old_names)
[10:33:24.725]                 removed <- setdiff(old_names, names)
[10:33:24.725]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.725]                   envs[common]]
[10:33:24.725]                 NAMES <- toupper(changed)
[10:33:24.725]                 args <- list()
[10:33:24.725]                 for (kk in seq_along(NAMES)) {
[10:33:24.725]                   name <- changed[[kk]]
[10:33:24.725]                   NAME <- NAMES[[kk]]
[10:33:24.725]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.725]                     next
[10:33:24.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.725]                 }
[10:33:24.725]                 NAMES <- toupper(added)
[10:33:24.725]                 for (kk in seq_along(NAMES)) {
[10:33:24.725]                   name <- added[[kk]]
[10:33:24.725]                   NAME <- NAMES[[kk]]
[10:33:24.725]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.725]                     next
[10:33:24.725]                   args[[name]] <- ""
[10:33:24.725]                 }
[10:33:24.725]                 NAMES <- toupper(removed)
[10:33:24.725]                 for (kk in seq_along(NAMES)) {
[10:33:24.725]                   name <- removed[[kk]]
[10:33:24.725]                   NAME <- NAMES[[kk]]
[10:33:24.725]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.725]                     next
[10:33:24.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.725]                 }
[10:33:24.725]                 if (length(args) > 0) 
[10:33:24.725]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.725]             }
[10:33:24.725]             else {
[10:33:24.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.725]             }
[10:33:24.725]             {
[10:33:24.725]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.725]                   0L) {
[10:33:24.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.725]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.725]                   base::options(opts)
[10:33:24.725]                 }
[10:33:24.725]                 {
[10:33:24.725]                   {
[10:33:24.725]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.725]                     NULL
[10:33:24.725]                   }
[10:33:24.725]                   options(future.plan = NULL)
[10:33:24.725]                   if (is.na(NA_character_)) 
[10:33:24.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.725]                     .init = FALSE)
[10:33:24.725]                 }
[10:33:24.725]             }
[10:33:24.725]         }
[10:33:24.725]     })
[10:33:24.725]     if (TRUE) {
[10:33:24.725]         base::sink(type = "output", split = FALSE)
[10:33:24.725]         if (TRUE) {
[10:33:24.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.725]         }
[10:33:24.725]         else {
[10:33:24.725]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.725]         }
[10:33:24.725]         base::close(...future.stdout)
[10:33:24.725]         ...future.stdout <- NULL
[10:33:24.725]     }
[10:33:24.725]     ...future.result$conditions <- ...future.conditions
[10:33:24.725]     ...future.result$finished <- base::Sys.time()
[10:33:24.725]     ...future.result
[10:33:24.725] }
[10:33:24.729] requestCore(): workers = 2
[10:33:24.731] MulticoreFuture started
 - Creating multicore future #3 ...
[10:33:24.732] plan(): Setting new future strategy stack:
[10:33:24.732] List of future strategies:
[10:33:24.732] 1. sequential:
[10:33:24.732]    - args: function (..., envir = parent.frame())
[10:33:24.732]    - tweaked: FALSE
[10:33:24.732]    - call: NULL
[10:33:24.733] plan(): nbrOfWorkers() = 1
[10:33:24.735] plan(): Setting new future strategy stack:
[10:33:24.735] List of future strategies:
[10:33:24.735] 1. multicore:
[10:33:24.735]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.735]    - tweaked: FALSE
[10:33:24.735]    - call: plan(multicore)
[10:33:24.736] getGlobalsAndPackages() ...
[10:33:24.736] Not searching for globals
[10:33:24.737] - globals: [0] <none>
[10:33:24.737] getGlobalsAndPackages() ... DONE
[10:33:24.738] Packages needed by the future expression (n = 0): <none>
[10:33:24.738] Packages needed by future strategies (n = 0): <none>
[10:33:24.740] plan(): nbrOfWorkers() = 2
[10:33:24.739] {
[10:33:24.739]     {
[10:33:24.739]         {
[10:33:24.739]             ...future.startTime <- base::Sys.time()
[10:33:24.739]             {
[10:33:24.739]                 {
[10:33:24.739]                   {
[10:33:24.739]                     {
[10:33:24.739]                       base::local({
[10:33:24.739]                         has_future <- base::requireNamespace("future", 
[10:33:24.739]                           quietly = TRUE)
[10:33:24.739]                         if (has_future) {
[10:33:24.739]                           ns <- base::getNamespace("future")
[10:33:24.739]                           version <- ns[[".package"]][["version"]]
[10:33:24.739]                           if (is.null(version)) 
[10:33:24.739]                             version <- utils::packageVersion("future")
[10:33:24.739]                         }
[10:33:24.739]                         else {
[10:33:24.739]                           version <- NULL
[10:33:24.739]                         }
[10:33:24.739]                         if (!has_future || version < "1.8.0") {
[10:33:24.739]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.739]                             "", base::R.version$version.string), 
[10:33:24.739]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.739]                               "release", "version")], collapse = " "), 
[10:33:24.739]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.739]                             info)
[10:33:24.739]                           info <- base::paste(info, collapse = "; ")
[10:33:24.739]                           if (!has_future) {
[10:33:24.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.739]                               info)
[10:33:24.739]                           }
[10:33:24.739]                           else {
[10:33:24.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.739]                               info, version)
[10:33:24.739]                           }
[10:33:24.739]                           base::stop(msg)
[10:33:24.739]                         }
[10:33:24.739]                       })
[10:33:24.739]                     }
[10:33:24.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.739]                     base::options(mc.cores = 1L)
[10:33:24.739]                   }
[10:33:24.739]                   ...future.strategy.old <- future::plan("list")
[10:33:24.739]                   options(future.plan = NULL)
[10:33:24.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.739]                 }
[10:33:24.739]                 ...future.workdir <- getwd()
[10:33:24.739]             }
[10:33:24.739]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.739]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.739]         }
[10:33:24.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.739]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.739]             base::names(...future.oldOptions))
[10:33:24.739]     }
[10:33:24.739]     if (FALSE) {
[10:33:24.739]     }
[10:33:24.739]     else {
[10:33:24.739]         if (TRUE) {
[10:33:24.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.739]                 open = "w")
[10:33:24.739]         }
[10:33:24.739]         else {
[10:33:24.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.739]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.739]         }
[10:33:24.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.739]             base::sink(type = "output", split = FALSE)
[10:33:24.739]             base::close(...future.stdout)
[10:33:24.739]         }, add = TRUE)
[10:33:24.739]     }
[10:33:24.739]     ...future.frame <- base::sys.nframe()
[10:33:24.739]     ...future.conditions <- base::list()
[10:33:24.739]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.739]     if (FALSE) {
[10:33:24.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.739]     }
[10:33:24.739]     ...future.result <- base::tryCatch({
[10:33:24.739]         base::withCallingHandlers({
[10:33:24.739]             ...future.value <- base::withVisible(base::local({
[10:33:24.739]                 withCallingHandlers({
[10:33:24.739]                   {
[10:33:24.739]                     ii
[10:33:24.739]                   }
[10:33:24.739]                 }, immediateCondition = function(cond) {
[10:33:24.739]                   save_rds <- function (object, pathname, ...) 
[10:33:24.739]                   {
[10:33:24.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.739]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.739]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.739]                         fi_tmp[["mtime"]])
[10:33:24.739]                     }
[10:33:24.739]                     tryCatch({
[10:33:24.739]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.739]                     }, error = function(ex) {
[10:33:24.739]                       msg <- conditionMessage(ex)
[10:33:24.739]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.739]                         fi_tmp[["mtime"]], msg)
[10:33:24.739]                       ex$message <- msg
[10:33:24.739]                       stop(ex)
[10:33:24.739]                     })
[10:33:24.739]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.739]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.739]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.739]                       fi <- file.info(pathname)
[10:33:24.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.739]                         fi[["size"]], fi[["mtime"]])
[10:33:24.739]                       stop(msg)
[10:33:24.739]                     }
[10:33:24.739]                     invisible(pathname)
[10:33:24.739]                   }
[10:33:24.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.739]                     rootPath = tempdir()) 
[10:33:24.739]                   {
[10:33:24.739]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.739]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.739]                       tmpdir = path, fileext = ".rds")
[10:33:24.739]                     save_rds(obj, file)
[10:33:24.739]                   }
[10:33:24.739]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.739]                   {
[10:33:24.739]                     inherits <- base::inherits
[10:33:24.739]                     invokeRestart <- base::invokeRestart
[10:33:24.739]                     is.null <- base::is.null
[10:33:24.739]                     muffled <- FALSE
[10:33:24.739]                     if (inherits(cond, "message")) {
[10:33:24.739]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.739]                       if (muffled) 
[10:33:24.739]                         invokeRestart("muffleMessage")
[10:33:24.739]                     }
[10:33:24.739]                     else if (inherits(cond, "warning")) {
[10:33:24.739]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.739]                       if (muffled) 
[10:33:24.739]                         invokeRestart("muffleWarning")
[10:33:24.739]                     }
[10:33:24.739]                     else if (inherits(cond, "condition")) {
[10:33:24.739]                       if (!is.null(pattern)) {
[10:33:24.739]                         computeRestarts <- base::computeRestarts
[10:33:24.739]                         grepl <- base::grepl
[10:33:24.739]                         restarts <- computeRestarts(cond)
[10:33:24.739]                         for (restart in restarts) {
[10:33:24.739]                           name <- restart$name
[10:33:24.739]                           if (is.null(name)) 
[10:33:24.739]                             next
[10:33:24.739]                           if (!grepl(pattern, name)) 
[10:33:24.739]                             next
[10:33:24.739]                           invokeRestart(restart)
[10:33:24.739]                           muffled <- TRUE
[10:33:24.739]                           break
[10:33:24.739]                         }
[10:33:24.739]                       }
[10:33:24.739]                     }
[10:33:24.739]                     invisible(muffled)
[10:33:24.739]                   }
[10:33:24.739]                   muffleCondition(cond)
[10:33:24.739]                 })
[10:33:24.739]             }))
[10:33:24.739]             future::FutureResult(value = ...future.value$value, 
[10:33:24.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.739]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.739]                     ...future.globalenv.names))
[10:33:24.739]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.739]         }, condition = base::local({
[10:33:24.739]             c <- base::c
[10:33:24.739]             inherits <- base::inherits
[10:33:24.739]             invokeRestart <- base::invokeRestart
[10:33:24.739]             length <- base::length
[10:33:24.739]             list <- base::list
[10:33:24.739]             seq.int <- base::seq.int
[10:33:24.739]             signalCondition <- base::signalCondition
[10:33:24.739]             sys.calls <- base::sys.calls
[10:33:24.739]             `[[` <- base::`[[`
[10:33:24.739]             `+` <- base::`+`
[10:33:24.739]             `<<-` <- base::`<<-`
[10:33:24.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.739]                   3L)]
[10:33:24.739]             }
[10:33:24.739]             function(cond) {
[10:33:24.739]                 is_error <- inherits(cond, "error")
[10:33:24.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.739]                   NULL)
[10:33:24.739]                 if (is_error) {
[10:33:24.739]                   sessionInformation <- function() {
[10:33:24.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.739]                       search = base::search(), system = base::Sys.info())
[10:33:24.739]                   }
[10:33:24.739]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.739]                     cond$call), session = sessionInformation(), 
[10:33:24.739]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.739]                   signalCondition(cond)
[10:33:24.739]                 }
[10:33:24.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.739]                 "immediateCondition"))) {
[10:33:24.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.739]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.739]                   if (TRUE && !signal) {
[10:33:24.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.739]                     {
[10:33:24.739]                       inherits <- base::inherits
[10:33:24.739]                       invokeRestart <- base::invokeRestart
[10:33:24.739]                       is.null <- base::is.null
[10:33:24.739]                       muffled <- FALSE
[10:33:24.739]                       if (inherits(cond, "message")) {
[10:33:24.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.739]                         if (muffled) 
[10:33:24.739]                           invokeRestart("muffleMessage")
[10:33:24.739]                       }
[10:33:24.739]                       else if (inherits(cond, "warning")) {
[10:33:24.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.739]                         if (muffled) 
[10:33:24.739]                           invokeRestart("muffleWarning")
[10:33:24.739]                       }
[10:33:24.739]                       else if (inherits(cond, "condition")) {
[10:33:24.739]                         if (!is.null(pattern)) {
[10:33:24.739]                           computeRestarts <- base::computeRestarts
[10:33:24.739]                           grepl <- base::grepl
[10:33:24.739]                           restarts <- computeRestarts(cond)
[10:33:24.739]                           for (restart in restarts) {
[10:33:24.739]                             name <- restart$name
[10:33:24.739]                             if (is.null(name)) 
[10:33:24.739]                               next
[10:33:24.739]                             if (!grepl(pattern, name)) 
[10:33:24.739]                               next
[10:33:24.739]                             invokeRestart(restart)
[10:33:24.739]                             muffled <- TRUE
[10:33:24.739]                             break
[10:33:24.739]                           }
[10:33:24.739]                         }
[10:33:24.739]                       }
[10:33:24.739]                       invisible(muffled)
[10:33:24.739]                     }
[10:33:24.739]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.739]                   }
[10:33:24.739]                 }
[10:33:24.739]                 else {
[10:33:24.739]                   if (TRUE) {
[10:33:24.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.739]                     {
[10:33:24.739]                       inherits <- base::inherits
[10:33:24.739]                       invokeRestart <- base::invokeRestart
[10:33:24.739]                       is.null <- base::is.null
[10:33:24.739]                       muffled <- FALSE
[10:33:24.739]                       if (inherits(cond, "message")) {
[10:33:24.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.739]                         if (muffled) 
[10:33:24.739]                           invokeRestart("muffleMessage")
[10:33:24.739]                       }
[10:33:24.739]                       else if (inherits(cond, "warning")) {
[10:33:24.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.739]                         if (muffled) 
[10:33:24.739]                           invokeRestart("muffleWarning")
[10:33:24.739]                       }
[10:33:24.739]                       else if (inherits(cond, "condition")) {
[10:33:24.739]                         if (!is.null(pattern)) {
[10:33:24.739]                           computeRestarts <- base::computeRestarts
[10:33:24.739]                           grepl <- base::grepl
[10:33:24.739]                           restarts <- computeRestarts(cond)
[10:33:24.739]                           for (restart in restarts) {
[10:33:24.739]                             name <- restart$name
[10:33:24.739]                             if (is.null(name)) 
[10:33:24.739]                               next
[10:33:24.739]                             if (!grepl(pattern, name)) 
[10:33:24.739]                               next
[10:33:24.739]                             invokeRestart(restart)
[10:33:24.739]                             muffled <- TRUE
[10:33:24.739]                             break
[10:33:24.739]                           }
[10:33:24.739]                         }
[10:33:24.739]                       }
[10:33:24.739]                       invisible(muffled)
[10:33:24.739]                     }
[10:33:24.739]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.739]                   }
[10:33:24.739]                 }
[10:33:24.739]             }
[10:33:24.739]         }))
[10:33:24.739]     }, error = function(ex) {
[10:33:24.739]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.739]                 ...future.rng), started = ...future.startTime, 
[10:33:24.739]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.739]             version = "1.8"), class = "FutureResult")
[10:33:24.739]     }, finally = {
[10:33:24.739]         if (!identical(...future.workdir, getwd())) 
[10:33:24.739]             setwd(...future.workdir)
[10:33:24.739]         {
[10:33:24.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.739]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.739]             }
[10:33:24.739]             base::options(...future.oldOptions)
[10:33:24.739]             if (.Platform$OS.type == "windows") {
[10:33:24.739]                 old_names <- names(...future.oldEnvVars)
[10:33:24.739]                 envs <- base::Sys.getenv()
[10:33:24.739]                 names <- names(envs)
[10:33:24.739]                 common <- intersect(names, old_names)
[10:33:24.739]                 added <- setdiff(names, old_names)
[10:33:24.739]                 removed <- setdiff(old_names, names)
[10:33:24.739]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.739]                   envs[common]]
[10:33:24.739]                 NAMES <- toupper(changed)
[10:33:24.739]                 args <- list()
[10:33:24.739]                 for (kk in seq_along(NAMES)) {
[10:33:24.739]                   name <- changed[[kk]]
[10:33:24.739]                   NAME <- NAMES[[kk]]
[10:33:24.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.739]                     next
[10:33:24.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.739]                 }
[10:33:24.739]                 NAMES <- toupper(added)
[10:33:24.739]                 for (kk in seq_along(NAMES)) {
[10:33:24.739]                   name <- added[[kk]]
[10:33:24.739]                   NAME <- NAMES[[kk]]
[10:33:24.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.739]                     next
[10:33:24.739]                   args[[name]] <- ""
[10:33:24.739]                 }
[10:33:24.739]                 NAMES <- toupper(removed)
[10:33:24.739]                 for (kk in seq_along(NAMES)) {
[10:33:24.739]                   name <- removed[[kk]]
[10:33:24.739]                   NAME <- NAMES[[kk]]
[10:33:24.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.739]                     next
[10:33:24.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.739]                 }
[10:33:24.739]                 if (length(args) > 0) 
[10:33:24.739]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.739]             }
[10:33:24.739]             else {
[10:33:24.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.739]             }
[10:33:24.739]             {
[10:33:24.739]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.739]                   0L) {
[10:33:24.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.739]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.739]                   base::options(opts)
[10:33:24.739]                 }
[10:33:24.739]                 {
[10:33:24.739]                   {
[10:33:24.739]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.739]                     NULL
[10:33:24.739]                   }
[10:33:24.739]                   options(future.plan = NULL)
[10:33:24.739]                   if (is.na(NA_character_)) 
[10:33:24.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.739]                     .init = FALSE)
[10:33:24.739]                 }
[10:33:24.739]             }
[10:33:24.739]         }
[10:33:24.739]     })
[10:33:24.739]     if (TRUE) {
[10:33:24.739]         base::sink(type = "output", split = FALSE)
[10:33:24.739]         if (TRUE) {
[10:33:24.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.739]         }
[10:33:24.739]         else {
[10:33:24.739]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.739]         }
[10:33:24.739]         base::close(...future.stdout)
[10:33:24.739]         ...future.stdout <- NULL
[10:33:24.739]     }
[10:33:24.739]     ...future.result$conditions <- ...future.conditions
[10:33:24.739]     ...future.result$finished <- base::Sys.time()
[10:33:24.739]     ...future.result
[10:33:24.739] }
[10:33:24.742] requestCore(): workers = 2
[10:33:24.742] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:24.753] result() for MulticoreFuture ...
[10:33:24.754] result() for MulticoreFuture ...
[10:33:24.754] result() for MulticoreFuture ... done
[10:33:24.754] result() for MulticoreFuture ... done
[10:33:24.755] result() for MulticoreFuture ...
[10:33:24.755] result() for MulticoreFuture ... done
[10:33:24.758] MulticoreFuture started
 - Creating multicore future #4 ...
[10:33:24.759] plan(): Setting new future strategy stack:
[10:33:24.759] List of future strategies:
[10:33:24.759] 1. sequential:
[10:33:24.759]    - args: function (..., envir = parent.frame())
[10:33:24.759]    - tweaked: FALSE
[10:33:24.759]    - call: NULL
[10:33:24.760] plan(): nbrOfWorkers() = 1
[10:33:24.762] plan(): Setting new future strategy stack:
[10:33:24.762] List of future strategies:
[10:33:24.762] 1. multicore:
[10:33:24.762]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.762]    - tweaked: FALSE
[10:33:24.762]    - call: plan(multicore)
[10:33:24.764] getGlobalsAndPackages() ...
[10:33:24.764] Not searching for globals
[10:33:24.765] - globals: [0] <none>
[10:33:24.765] getGlobalsAndPackages() ... DONE
[10:33:24.766] Packages needed by the future expression (n = 0): <none>
[10:33:24.772] Packages needed by future strategies (n = 0): <none>
[10:33:24.774] plan(): nbrOfWorkers() = 2
[10:33:24.773] {
[10:33:24.773]     {
[10:33:24.773]         {
[10:33:24.773]             ...future.startTime <- base::Sys.time()
[10:33:24.773]             {
[10:33:24.773]                 {
[10:33:24.773]                   {
[10:33:24.773]                     {
[10:33:24.773]                       base::local({
[10:33:24.773]                         has_future <- base::requireNamespace("future", 
[10:33:24.773]                           quietly = TRUE)
[10:33:24.773]                         if (has_future) {
[10:33:24.773]                           ns <- base::getNamespace("future")
[10:33:24.773]                           version <- ns[[".package"]][["version"]]
[10:33:24.773]                           if (is.null(version)) 
[10:33:24.773]                             version <- utils::packageVersion("future")
[10:33:24.773]                         }
[10:33:24.773]                         else {
[10:33:24.773]                           version <- NULL
[10:33:24.773]                         }
[10:33:24.773]                         if (!has_future || version < "1.8.0") {
[10:33:24.773]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.773]                             "", base::R.version$version.string), 
[10:33:24.773]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.773]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.773]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.773]                               "release", "version")], collapse = " "), 
[10:33:24.773]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.773]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.773]                             info)
[10:33:24.773]                           info <- base::paste(info, collapse = "; ")
[10:33:24.773]                           if (!has_future) {
[10:33:24.773]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.773]                               info)
[10:33:24.773]                           }
[10:33:24.773]                           else {
[10:33:24.773]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.773]                               info, version)
[10:33:24.773]                           }
[10:33:24.773]                           base::stop(msg)
[10:33:24.773]                         }
[10:33:24.773]                       })
[10:33:24.773]                     }
[10:33:24.773]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.773]                     base::options(mc.cores = 1L)
[10:33:24.773]                   }
[10:33:24.773]                   ...future.strategy.old <- future::plan("list")
[10:33:24.773]                   options(future.plan = NULL)
[10:33:24.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.773]                 }
[10:33:24.773]                 ...future.workdir <- getwd()
[10:33:24.773]             }
[10:33:24.773]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.773]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.773]         }
[10:33:24.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.773]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.773]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.773]             base::names(...future.oldOptions))
[10:33:24.773]     }
[10:33:24.773]     if (FALSE) {
[10:33:24.773]     }
[10:33:24.773]     else {
[10:33:24.773]         if (TRUE) {
[10:33:24.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.773]                 open = "w")
[10:33:24.773]         }
[10:33:24.773]         else {
[10:33:24.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.773]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.773]         }
[10:33:24.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.773]             base::sink(type = "output", split = FALSE)
[10:33:24.773]             base::close(...future.stdout)
[10:33:24.773]         }, add = TRUE)
[10:33:24.773]     }
[10:33:24.773]     ...future.frame <- base::sys.nframe()
[10:33:24.773]     ...future.conditions <- base::list()
[10:33:24.773]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.773]     if (FALSE) {
[10:33:24.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.773]     }
[10:33:24.773]     ...future.result <- base::tryCatch({
[10:33:24.773]         base::withCallingHandlers({
[10:33:24.773]             ...future.value <- base::withVisible(base::local({
[10:33:24.773]                 withCallingHandlers({
[10:33:24.773]                   {
[10:33:24.773]                     ii
[10:33:24.773]                   }
[10:33:24.773]                 }, immediateCondition = function(cond) {
[10:33:24.773]                   save_rds <- function (object, pathname, ...) 
[10:33:24.773]                   {
[10:33:24.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.773]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.773]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.773]                         fi_tmp[["mtime"]])
[10:33:24.773]                     }
[10:33:24.773]                     tryCatch({
[10:33:24.773]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.773]                     }, error = function(ex) {
[10:33:24.773]                       msg <- conditionMessage(ex)
[10:33:24.773]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.773]                         fi_tmp[["mtime"]], msg)
[10:33:24.773]                       ex$message <- msg
[10:33:24.773]                       stop(ex)
[10:33:24.773]                     })
[10:33:24.773]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.773]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.773]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.773]                       fi <- file.info(pathname)
[10:33:24.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.773]                         fi[["size"]], fi[["mtime"]])
[10:33:24.773]                       stop(msg)
[10:33:24.773]                     }
[10:33:24.773]                     invisible(pathname)
[10:33:24.773]                   }
[10:33:24.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.773]                     rootPath = tempdir()) 
[10:33:24.773]                   {
[10:33:24.773]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.773]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.773]                       tmpdir = path, fileext = ".rds")
[10:33:24.773]                     save_rds(obj, file)
[10:33:24.773]                   }
[10:33:24.773]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.773]                   {
[10:33:24.773]                     inherits <- base::inherits
[10:33:24.773]                     invokeRestart <- base::invokeRestart
[10:33:24.773]                     is.null <- base::is.null
[10:33:24.773]                     muffled <- FALSE
[10:33:24.773]                     if (inherits(cond, "message")) {
[10:33:24.773]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.773]                       if (muffled) 
[10:33:24.773]                         invokeRestart("muffleMessage")
[10:33:24.773]                     }
[10:33:24.773]                     else if (inherits(cond, "warning")) {
[10:33:24.773]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.773]                       if (muffled) 
[10:33:24.773]                         invokeRestart("muffleWarning")
[10:33:24.773]                     }
[10:33:24.773]                     else if (inherits(cond, "condition")) {
[10:33:24.773]                       if (!is.null(pattern)) {
[10:33:24.773]                         computeRestarts <- base::computeRestarts
[10:33:24.773]                         grepl <- base::grepl
[10:33:24.773]                         restarts <- computeRestarts(cond)
[10:33:24.773]                         for (restart in restarts) {
[10:33:24.773]                           name <- restart$name
[10:33:24.773]                           if (is.null(name)) 
[10:33:24.773]                             next
[10:33:24.773]                           if (!grepl(pattern, name)) 
[10:33:24.773]                             next
[10:33:24.773]                           invokeRestart(restart)
[10:33:24.773]                           muffled <- TRUE
[10:33:24.773]                           break
[10:33:24.773]                         }
[10:33:24.773]                       }
[10:33:24.773]                     }
[10:33:24.773]                     invisible(muffled)
[10:33:24.773]                   }
[10:33:24.773]                   muffleCondition(cond)
[10:33:24.773]                 })
[10:33:24.773]             }))
[10:33:24.773]             future::FutureResult(value = ...future.value$value, 
[10:33:24.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.773]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.773]                     ...future.globalenv.names))
[10:33:24.773]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.773]         }, condition = base::local({
[10:33:24.773]             c <- base::c
[10:33:24.773]             inherits <- base::inherits
[10:33:24.773]             invokeRestart <- base::invokeRestart
[10:33:24.773]             length <- base::length
[10:33:24.773]             list <- base::list
[10:33:24.773]             seq.int <- base::seq.int
[10:33:24.773]             signalCondition <- base::signalCondition
[10:33:24.773]             sys.calls <- base::sys.calls
[10:33:24.773]             `[[` <- base::`[[`
[10:33:24.773]             `+` <- base::`+`
[10:33:24.773]             `<<-` <- base::`<<-`
[10:33:24.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.773]                   3L)]
[10:33:24.773]             }
[10:33:24.773]             function(cond) {
[10:33:24.773]                 is_error <- inherits(cond, "error")
[10:33:24.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.773]                   NULL)
[10:33:24.773]                 if (is_error) {
[10:33:24.773]                   sessionInformation <- function() {
[10:33:24.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.773]                       search = base::search(), system = base::Sys.info())
[10:33:24.773]                   }
[10:33:24.773]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.773]                     cond$call), session = sessionInformation(), 
[10:33:24.773]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.773]                   signalCondition(cond)
[10:33:24.773]                 }
[10:33:24.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.773]                 "immediateCondition"))) {
[10:33:24.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.773]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.773]                   if (TRUE && !signal) {
[10:33:24.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.773]                     {
[10:33:24.773]                       inherits <- base::inherits
[10:33:24.773]                       invokeRestart <- base::invokeRestart
[10:33:24.773]                       is.null <- base::is.null
[10:33:24.773]                       muffled <- FALSE
[10:33:24.773]                       if (inherits(cond, "message")) {
[10:33:24.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.773]                         if (muffled) 
[10:33:24.773]                           invokeRestart("muffleMessage")
[10:33:24.773]                       }
[10:33:24.773]                       else if (inherits(cond, "warning")) {
[10:33:24.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.773]                         if (muffled) 
[10:33:24.773]                           invokeRestart("muffleWarning")
[10:33:24.773]                       }
[10:33:24.773]                       else if (inherits(cond, "condition")) {
[10:33:24.773]                         if (!is.null(pattern)) {
[10:33:24.773]                           computeRestarts <- base::computeRestarts
[10:33:24.773]                           grepl <- base::grepl
[10:33:24.773]                           restarts <- computeRestarts(cond)
[10:33:24.773]                           for (restart in restarts) {
[10:33:24.773]                             name <- restart$name
[10:33:24.773]                             if (is.null(name)) 
[10:33:24.773]                               next
[10:33:24.773]                             if (!grepl(pattern, name)) 
[10:33:24.773]                               next
[10:33:24.773]                             invokeRestart(restart)
[10:33:24.773]                             muffled <- TRUE
[10:33:24.773]                             break
[10:33:24.773]                           }
[10:33:24.773]                         }
[10:33:24.773]                       }
[10:33:24.773]                       invisible(muffled)
[10:33:24.773]                     }
[10:33:24.773]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.773]                   }
[10:33:24.773]                 }
[10:33:24.773]                 else {
[10:33:24.773]                   if (TRUE) {
[10:33:24.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.773]                     {
[10:33:24.773]                       inherits <- base::inherits
[10:33:24.773]                       invokeRestart <- base::invokeRestart
[10:33:24.773]                       is.null <- base::is.null
[10:33:24.773]                       muffled <- FALSE
[10:33:24.773]                       if (inherits(cond, "message")) {
[10:33:24.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.773]                         if (muffled) 
[10:33:24.773]                           invokeRestart("muffleMessage")
[10:33:24.773]                       }
[10:33:24.773]                       else if (inherits(cond, "warning")) {
[10:33:24.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.773]                         if (muffled) 
[10:33:24.773]                           invokeRestart("muffleWarning")
[10:33:24.773]                       }
[10:33:24.773]                       else if (inherits(cond, "condition")) {
[10:33:24.773]                         if (!is.null(pattern)) {
[10:33:24.773]                           computeRestarts <- base::computeRestarts
[10:33:24.773]                           grepl <- base::grepl
[10:33:24.773]                           restarts <- computeRestarts(cond)
[10:33:24.773]                           for (restart in restarts) {
[10:33:24.773]                             name <- restart$name
[10:33:24.773]                             if (is.null(name)) 
[10:33:24.773]                               next
[10:33:24.773]                             if (!grepl(pattern, name)) 
[10:33:24.773]                               next
[10:33:24.773]                             invokeRestart(restart)
[10:33:24.773]                             muffled <- TRUE
[10:33:24.773]                             break
[10:33:24.773]                           }
[10:33:24.773]                         }
[10:33:24.773]                       }
[10:33:24.773]                       invisible(muffled)
[10:33:24.773]                     }
[10:33:24.773]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.773]                   }
[10:33:24.773]                 }
[10:33:24.773]             }
[10:33:24.773]         }))
[10:33:24.773]     }, error = function(ex) {
[10:33:24.773]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.773]                 ...future.rng), started = ...future.startTime, 
[10:33:24.773]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.773]             version = "1.8"), class = "FutureResult")
[10:33:24.773]     }, finally = {
[10:33:24.773]         if (!identical(...future.workdir, getwd())) 
[10:33:24.773]             setwd(...future.workdir)
[10:33:24.773]         {
[10:33:24.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.773]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.773]             }
[10:33:24.773]             base::options(...future.oldOptions)
[10:33:24.773]             if (.Platform$OS.type == "windows") {
[10:33:24.773]                 old_names <- names(...future.oldEnvVars)
[10:33:24.773]                 envs <- base::Sys.getenv()
[10:33:24.773]                 names <- names(envs)
[10:33:24.773]                 common <- intersect(names, old_names)
[10:33:24.773]                 added <- setdiff(names, old_names)
[10:33:24.773]                 removed <- setdiff(old_names, names)
[10:33:24.773]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.773]                   envs[common]]
[10:33:24.773]                 NAMES <- toupper(changed)
[10:33:24.773]                 args <- list()
[10:33:24.773]                 for (kk in seq_along(NAMES)) {
[10:33:24.773]                   name <- changed[[kk]]
[10:33:24.773]                   NAME <- NAMES[[kk]]
[10:33:24.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.773]                     next
[10:33:24.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.773]                 }
[10:33:24.773]                 NAMES <- toupper(added)
[10:33:24.773]                 for (kk in seq_along(NAMES)) {
[10:33:24.773]                   name <- added[[kk]]
[10:33:24.773]                   NAME <- NAMES[[kk]]
[10:33:24.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.773]                     next
[10:33:24.773]                   args[[name]] <- ""
[10:33:24.773]                 }
[10:33:24.773]                 NAMES <- toupper(removed)
[10:33:24.773]                 for (kk in seq_along(NAMES)) {
[10:33:24.773]                   name <- removed[[kk]]
[10:33:24.773]                   NAME <- NAMES[[kk]]
[10:33:24.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.773]                     next
[10:33:24.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.773]                 }
[10:33:24.773]                 if (length(args) > 0) 
[10:33:24.773]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.773]             }
[10:33:24.773]             else {
[10:33:24.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.773]             }
[10:33:24.773]             {
[10:33:24.773]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.773]                   0L) {
[10:33:24.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.773]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.773]                   base::options(opts)
[10:33:24.773]                 }
[10:33:24.773]                 {
[10:33:24.773]                   {
[10:33:24.773]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.773]                     NULL
[10:33:24.773]                   }
[10:33:24.773]                   options(future.plan = NULL)
[10:33:24.773]                   if (is.na(NA_character_)) 
[10:33:24.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.773]                     .init = FALSE)
[10:33:24.773]                 }
[10:33:24.773]             }
[10:33:24.773]         }
[10:33:24.773]     })
[10:33:24.773]     if (TRUE) {
[10:33:24.773]         base::sink(type = "output", split = FALSE)
[10:33:24.773]         if (TRUE) {
[10:33:24.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.773]         }
[10:33:24.773]         else {
[10:33:24.773]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.773]         }
[10:33:24.773]         base::close(...future.stdout)
[10:33:24.773]         ...future.stdout <- NULL
[10:33:24.773]     }
[10:33:24.773]     ...future.result$conditions <- ...future.conditions
[10:33:24.773]     ...future.result$finished <- base::Sys.time()
[10:33:24.773]     ...future.result
[10:33:24.773] }
[10:33:24.776] requestCore(): workers = 2
[10:33:24.777] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:24.800] result() for MulticoreFuture ...
[10:33:24.801] result() for MulticoreFuture ...
[10:33:24.801] result() for MulticoreFuture ... done
[10:33:24.801] result() for MulticoreFuture ... done
[10:33:24.802] result() for MulticoreFuture ...
[10:33:24.802] result() for MulticoreFuture ... done
[10:33:24.804] MulticoreFuture started
 - Resolving 4 multicore futures
[10:33:24.805] result() for MulticoreFuture ...
[10:33:24.805] result() for MulticoreFuture ... done
[10:33:24.805] plan(): Setting new future strategy stack:
[10:33:24.806] result() for MulticoreFuture ...
[10:33:24.806] result() for MulticoreFuture ... done
[10:33:24.806] result() for MulticoreFuture ...
[10:33:24.806] result() for MulticoreFuture ... done
[10:33:24.806] List of future strategies:
[10:33:24.806] 1. sequential:
[10:33:24.806]    - args: function (..., envir = parent.frame())
[10:33:24.806]    - tweaked: FALSE
[10:33:24.806]    - call: NULL
[10:33:24.807] result() for MulticoreFuture ...
[10:33:24.807] result() for MulticoreFuture ... done
[10:33:24.807] plan(): nbrOfWorkers() = 1
[10:33:24.807] result() for MulticoreFuture ...
[10:33:24.809] result() for MulticoreFuture ...
[10:33:24.809] result() for MulticoreFuture ... done
[10:33:24.809] result() for MulticoreFuture ... done
[10:33:24.809] result() for MulticoreFuture ...
[10:33:24.810] result() for MulticoreFuture ... done
[10:33:24.810] plan(): Setting new future strategy stack:
[10:33:24.810] result() for MulticoreFuture ...
[10:33:24.810] List of future strategies:
[10:33:24.810] 1. multicore:
[10:33:24.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.810]    - tweaked: FALSE
[10:33:24.810]    - call: plan(multicore)
[10:33:24.815] plan(): nbrOfWorkers() = 2
[10:33:24.816] result() for MulticoreFuture ...
[10:33:24.816] result() for MulticoreFuture ... done
[10:33:24.816] result() for MulticoreFuture ... done
[10:33:24.816] result() for MulticoreFuture ...
[10:33:24.817] result() for MulticoreFuture ... done
*** multicore(..., globals = FALSE) and errors
[10:33:24.821] getGlobalsAndPackages() ...
[10:33:24.821] Not searching for globals
[10:33:24.821] - globals: [0] <none>
[10:33:24.821] getGlobalsAndPackages() ... DONE
[10:33:24.822] Packages needed by the future expression (n = 0): <none>
[10:33:24.822] Packages needed by future strategies (n = 0): <none>
[10:33:24.823] {
[10:33:24.823]     {
[10:33:24.823]         {
[10:33:24.823]             ...future.startTime <- base::Sys.time()
[10:33:24.823]             {
[10:33:24.823]                 {
[10:33:24.823]                   {
[10:33:24.823]                     {
[10:33:24.823]                       base::local({
[10:33:24.823]                         has_future <- base::requireNamespace("future", 
[10:33:24.823]                           quietly = TRUE)
[10:33:24.823]                         if (has_future) {
[10:33:24.823]                           ns <- base::getNamespace("future")
[10:33:24.823]                           version <- ns[[".package"]][["version"]]
[10:33:24.823]                           if (is.null(version)) 
[10:33:24.823]                             version <- utils::packageVersion("future")
[10:33:24.823]                         }
[10:33:24.823]                         else {
[10:33:24.823]                           version <- NULL
[10:33:24.823]                         }
[10:33:24.823]                         if (!has_future || version < "1.8.0") {
[10:33:24.823]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.823]                             "", base::R.version$version.string), 
[10:33:24.823]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.823]                               "release", "version")], collapse = " "), 
[10:33:24.823]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.823]                             info)
[10:33:24.823]                           info <- base::paste(info, collapse = "; ")
[10:33:24.823]                           if (!has_future) {
[10:33:24.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.823]                               info)
[10:33:24.823]                           }
[10:33:24.823]                           else {
[10:33:24.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.823]                               info, version)
[10:33:24.823]                           }
[10:33:24.823]                           base::stop(msg)
[10:33:24.823]                         }
[10:33:24.823]                       })
[10:33:24.823]                     }
[10:33:24.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.823]                     base::options(mc.cores = 1L)
[10:33:24.823]                   }
[10:33:24.823]                   ...future.strategy.old <- future::plan("list")
[10:33:24.823]                   options(future.plan = NULL)
[10:33:24.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.823]                 }
[10:33:24.823]                 ...future.workdir <- getwd()
[10:33:24.823]             }
[10:33:24.823]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.823]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.823]         }
[10:33:24.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.823]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.823]             base::names(...future.oldOptions))
[10:33:24.823]     }
[10:33:24.823]     if (FALSE) {
[10:33:24.823]     }
[10:33:24.823]     else {
[10:33:24.823]         if (TRUE) {
[10:33:24.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.823]                 open = "w")
[10:33:24.823]         }
[10:33:24.823]         else {
[10:33:24.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.823]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.823]         }
[10:33:24.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.823]             base::sink(type = "output", split = FALSE)
[10:33:24.823]             base::close(...future.stdout)
[10:33:24.823]         }, add = TRUE)
[10:33:24.823]     }
[10:33:24.823]     ...future.frame <- base::sys.nframe()
[10:33:24.823]     ...future.conditions <- base::list()
[10:33:24.823]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.823]     if (FALSE) {
[10:33:24.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.823]     }
[10:33:24.823]     ...future.result <- base::tryCatch({
[10:33:24.823]         base::withCallingHandlers({
[10:33:24.823]             ...future.value <- base::withVisible(base::local({
[10:33:24.823]                 withCallingHandlers({
[10:33:24.823]                   {
[10:33:24.823]                     stop("Whoops!")
[10:33:24.823]                     1
[10:33:24.823]                   }
[10:33:24.823]                 }, immediateCondition = function(cond) {
[10:33:24.823]                   save_rds <- function (object, pathname, ...) 
[10:33:24.823]                   {
[10:33:24.823]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.823]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.823]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.823]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.823]                         fi_tmp[["mtime"]])
[10:33:24.823]                     }
[10:33:24.823]                     tryCatch({
[10:33:24.823]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.823]                     }, error = function(ex) {
[10:33:24.823]                       msg <- conditionMessage(ex)
[10:33:24.823]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.823]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.823]                         fi_tmp[["mtime"]], msg)
[10:33:24.823]                       ex$message <- msg
[10:33:24.823]                       stop(ex)
[10:33:24.823]                     })
[10:33:24.823]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.823]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.823]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.823]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.823]                       fi <- file.info(pathname)
[10:33:24.823]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.823]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.823]                         fi[["size"]], fi[["mtime"]])
[10:33:24.823]                       stop(msg)
[10:33:24.823]                     }
[10:33:24.823]                     invisible(pathname)
[10:33:24.823]                   }
[10:33:24.823]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.823]                     rootPath = tempdir()) 
[10:33:24.823]                   {
[10:33:24.823]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.823]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.823]                       tmpdir = path, fileext = ".rds")
[10:33:24.823]                     save_rds(obj, file)
[10:33:24.823]                   }
[10:33:24.823]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.823]                   {
[10:33:24.823]                     inherits <- base::inherits
[10:33:24.823]                     invokeRestart <- base::invokeRestart
[10:33:24.823]                     is.null <- base::is.null
[10:33:24.823]                     muffled <- FALSE
[10:33:24.823]                     if (inherits(cond, "message")) {
[10:33:24.823]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.823]                       if (muffled) 
[10:33:24.823]                         invokeRestart("muffleMessage")
[10:33:24.823]                     }
[10:33:24.823]                     else if (inherits(cond, "warning")) {
[10:33:24.823]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.823]                       if (muffled) 
[10:33:24.823]                         invokeRestart("muffleWarning")
[10:33:24.823]                     }
[10:33:24.823]                     else if (inherits(cond, "condition")) {
[10:33:24.823]                       if (!is.null(pattern)) {
[10:33:24.823]                         computeRestarts <- base::computeRestarts
[10:33:24.823]                         grepl <- base::grepl
[10:33:24.823]                         restarts <- computeRestarts(cond)
[10:33:24.823]                         for (restart in restarts) {
[10:33:24.823]                           name <- restart$name
[10:33:24.823]                           if (is.null(name)) 
[10:33:24.823]                             next
[10:33:24.823]                           if (!grepl(pattern, name)) 
[10:33:24.823]                             next
[10:33:24.823]                           invokeRestart(restart)
[10:33:24.823]                           muffled <- TRUE
[10:33:24.823]                           break
[10:33:24.823]                         }
[10:33:24.823]                       }
[10:33:24.823]                     }
[10:33:24.823]                     invisible(muffled)
[10:33:24.823]                   }
[10:33:24.823]                   muffleCondition(cond)
[10:33:24.823]                 })
[10:33:24.823]             }))
[10:33:24.823]             future::FutureResult(value = ...future.value$value, 
[10:33:24.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.823]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.823]                     ...future.globalenv.names))
[10:33:24.823]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.823]         }, condition = base::local({
[10:33:24.823]             c <- base::c
[10:33:24.823]             inherits <- base::inherits
[10:33:24.823]             invokeRestart <- base::invokeRestart
[10:33:24.823]             length <- base::length
[10:33:24.823]             list <- base::list
[10:33:24.823]             seq.int <- base::seq.int
[10:33:24.823]             signalCondition <- base::signalCondition
[10:33:24.823]             sys.calls <- base::sys.calls
[10:33:24.823]             `[[` <- base::`[[`
[10:33:24.823]             `+` <- base::`+`
[10:33:24.823]             `<<-` <- base::`<<-`
[10:33:24.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.823]                   3L)]
[10:33:24.823]             }
[10:33:24.823]             function(cond) {
[10:33:24.823]                 is_error <- inherits(cond, "error")
[10:33:24.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.823]                   NULL)
[10:33:24.823]                 if (is_error) {
[10:33:24.823]                   sessionInformation <- function() {
[10:33:24.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.823]                       search = base::search(), system = base::Sys.info())
[10:33:24.823]                   }
[10:33:24.823]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.823]                     cond$call), session = sessionInformation(), 
[10:33:24.823]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.823]                   signalCondition(cond)
[10:33:24.823]                 }
[10:33:24.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.823]                 "immediateCondition"))) {
[10:33:24.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.823]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.823]                   if (TRUE && !signal) {
[10:33:24.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.823]                     {
[10:33:24.823]                       inherits <- base::inherits
[10:33:24.823]                       invokeRestart <- base::invokeRestart
[10:33:24.823]                       is.null <- base::is.null
[10:33:24.823]                       muffled <- FALSE
[10:33:24.823]                       if (inherits(cond, "message")) {
[10:33:24.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.823]                         if (muffled) 
[10:33:24.823]                           invokeRestart("muffleMessage")
[10:33:24.823]                       }
[10:33:24.823]                       else if (inherits(cond, "warning")) {
[10:33:24.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.823]                         if (muffled) 
[10:33:24.823]                           invokeRestart("muffleWarning")
[10:33:24.823]                       }
[10:33:24.823]                       else if (inherits(cond, "condition")) {
[10:33:24.823]                         if (!is.null(pattern)) {
[10:33:24.823]                           computeRestarts <- base::computeRestarts
[10:33:24.823]                           grepl <- base::grepl
[10:33:24.823]                           restarts <- computeRestarts(cond)
[10:33:24.823]                           for (restart in restarts) {
[10:33:24.823]                             name <- restart$name
[10:33:24.823]                             if (is.null(name)) 
[10:33:24.823]                               next
[10:33:24.823]                             if (!grepl(pattern, name)) 
[10:33:24.823]                               next
[10:33:24.823]                             invokeRestart(restart)
[10:33:24.823]                             muffled <- TRUE
[10:33:24.823]                             break
[10:33:24.823]                           }
[10:33:24.823]                         }
[10:33:24.823]                       }
[10:33:24.823]                       invisible(muffled)
[10:33:24.823]                     }
[10:33:24.823]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.823]                   }
[10:33:24.823]                 }
[10:33:24.823]                 else {
[10:33:24.823]                   if (TRUE) {
[10:33:24.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.823]                     {
[10:33:24.823]                       inherits <- base::inherits
[10:33:24.823]                       invokeRestart <- base::invokeRestart
[10:33:24.823]                       is.null <- base::is.null
[10:33:24.823]                       muffled <- FALSE
[10:33:24.823]                       if (inherits(cond, "message")) {
[10:33:24.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.823]                         if (muffled) 
[10:33:24.823]                           invokeRestart("muffleMessage")
[10:33:24.823]                       }
[10:33:24.823]                       else if (inherits(cond, "warning")) {
[10:33:24.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.823]                         if (muffled) 
[10:33:24.823]                           invokeRestart("muffleWarning")
[10:33:24.823]                       }
[10:33:24.823]                       else if (inherits(cond, "condition")) {
[10:33:24.823]                         if (!is.null(pattern)) {
[10:33:24.823]                           computeRestarts <- base::computeRestarts
[10:33:24.823]                           grepl <- base::grepl
[10:33:24.823]                           restarts <- computeRestarts(cond)
[10:33:24.823]                           for (restart in restarts) {
[10:33:24.823]                             name <- restart$name
[10:33:24.823]                             if (is.null(name)) 
[10:33:24.823]                               next
[10:33:24.823]                             if (!grepl(pattern, name)) 
[10:33:24.823]                               next
[10:33:24.823]                             invokeRestart(restart)
[10:33:24.823]                             muffled <- TRUE
[10:33:24.823]                             break
[10:33:24.823]                           }
[10:33:24.823]                         }
[10:33:24.823]                       }
[10:33:24.823]                       invisible(muffled)
[10:33:24.823]                     }
[10:33:24.823]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.823]                   }
[10:33:24.823]                 }
[10:33:24.823]             }
[10:33:24.823]         }))
[10:33:24.823]     }, error = function(ex) {
[10:33:24.823]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.823]                 ...future.rng), started = ...future.startTime, 
[10:33:24.823]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.823]             version = "1.8"), class = "FutureResult")
[10:33:24.823]     }, finally = {
[10:33:24.823]         if (!identical(...future.workdir, getwd())) 
[10:33:24.823]             setwd(...future.workdir)
[10:33:24.823]         {
[10:33:24.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.823]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.823]             }
[10:33:24.823]             base::options(...future.oldOptions)
[10:33:24.823]             if (.Platform$OS.type == "windows") {
[10:33:24.823]                 old_names <- names(...future.oldEnvVars)
[10:33:24.823]                 envs <- base::Sys.getenv()
[10:33:24.823]                 names <- names(envs)
[10:33:24.823]                 common <- intersect(names, old_names)
[10:33:24.823]                 added <- setdiff(names, old_names)
[10:33:24.823]                 removed <- setdiff(old_names, names)
[10:33:24.823]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.823]                   envs[common]]
[10:33:24.823]                 NAMES <- toupper(changed)
[10:33:24.823]                 args <- list()
[10:33:24.823]                 for (kk in seq_along(NAMES)) {
[10:33:24.823]                   name <- changed[[kk]]
[10:33:24.823]                   NAME <- NAMES[[kk]]
[10:33:24.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.823]                     next
[10:33:24.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.823]                 }
[10:33:24.823]                 NAMES <- toupper(added)
[10:33:24.823]                 for (kk in seq_along(NAMES)) {
[10:33:24.823]                   name <- added[[kk]]
[10:33:24.823]                   NAME <- NAMES[[kk]]
[10:33:24.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.823]                     next
[10:33:24.823]                   args[[name]] <- ""
[10:33:24.823]                 }
[10:33:24.823]                 NAMES <- toupper(removed)
[10:33:24.823]                 for (kk in seq_along(NAMES)) {
[10:33:24.823]                   name <- removed[[kk]]
[10:33:24.823]                   NAME <- NAMES[[kk]]
[10:33:24.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.823]                     next
[10:33:24.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.823]                 }
[10:33:24.823]                 if (length(args) > 0) 
[10:33:24.823]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.823]             }
[10:33:24.823]             else {
[10:33:24.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.823]             }
[10:33:24.823]             {
[10:33:24.823]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.823]                   0L) {
[10:33:24.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.823]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.823]                   base::options(opts)
[10:33:24.823]                 }
[10:33:24.823]                 {
[10:33:24.823]                   {
[10:33:24.823]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.823]                     NULL
[10:33:24.823]                   }
[10:33:24.823]                   options(future.plan = NULL)
[10:33:24.823]                   if (is.na(NA_character_)) 
[10:33:24.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.823]                     .init = FALSE)
[10:33:24.823]                 }
[10:33:24.823]             }
[10:33:24.823]         }
[10:33:24.823]     })
[10:33:24.823]     if (TRUE) {
[10:33:24.823]         base::sink(type = "output", split = FALSE)
[10:33:24.823]         if (TRUE) {
[10:33:24.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.823]         }
[10:33:24.823]         else {
[10:33:24.823]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.823]         }
[10:33:24.823]         base::close(...future.stdout)
[10:33:24.823]         ...future.stdout <- NULL
[10:33:24.823]     }
[10:33:24.823]     ...future.result$conditions <- ...future.conditions
[10:33:24.823]     ...future.result$finished <- base::Sys.time()
[10:33:24.823]     ...future.result
[10:33:24.823] }
[10:33:24.825] requestCore(): workers = 2
[10:33:24.827] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:33:24.828] plan(): Setting new future strategy stack:
[10:33:24.828] List of future strategies:
[10:33:24.828] 1. sequential:
[10:33:24.828]    - args: function (..., envir = parent.frame())
[10:33:24.828]    - tweaked: FALSE
[10:33:24.828]    - call: NULL
[10:33:24.829] plan(): nbrOfWorkers() = 1
[10:33:24.831] plan(): Setting new future strategy stack:
[10:33:24.831] List of future strategies:
[10:33:24.831] 1. multicore:
[10:33:24.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.831]    - tweaked: FALSE
[10:33:24.831]    - call: plan(multicore)
[10:33:24.836] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:24.839] result() for MulticoreFuture ...
[10:33:24.841] result() for MulticoreFuture ...
[10:33:24.841] result() for MulticoreFuture ... done
[10:33:24.842] signalConditions() ...
[10:33:24.842]  - include = ‘immediateCondition’
[10:33:24.842]  - exclude = 
[10:33:24.842]  - resignal = FALSE
[10:33:24.842]  - Number of conditions: 1
[10:33:24.842] signalConditions() ... done
[10:33:24.842] result() for MulticoreFuture ... done
[10:33:24.842] result() for MulticoreFuture ...
[10:33:24.843] result() for MulticoreFuture ... done
[10:33:24.843] signalConditions() ...
[10:33:24.843]  - include = ‘immediateCondition’
[10:33:24.843]  - exclude = 
[10:33:24.843]  - resignal = FALSE
[10:33:24.843]  - Number of conditions: 1
[10:33:24.843] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:33:24.844] result() for MulticoreFuture ...
[10:33:24.844] result() for MulticoreFuture ... done
[10:33:24.844] result() for MulticoreFuture ...
[10:33:24.844] result() for MulticoreFuture ... done
[10:33:24.844] signalConditions() ...
[10:33:24.845]  - include = ‘immediateCondition’
[10:33:24.845]  - exclude = 
[10:33:24.845]  - resignal = FALSE
[10:33:24.845]  - Number of conditions: 1
[10:33:24.845] signalConditions() ... done
[10:33:24.845] Future state: ‘finished’
[10:33:24.848] result() for MulticoreFuture ...
[10:33:24.848] result() for MulticoreFuture ... done
[10:33:24.848] signalConditions() ...
[10:33:24.848]  - include = ‘condition’
[10:33:24.849]  - exclude = ‘immediateCondition’
[10:33:24.849]  - resignal = TRUE
[10:33:24.849]  - Number of conditions: 1
[10:33:24.849]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:24.849] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:33:24.850] result() for MulticoreFuture ...
[10:33:24.850] result() for MulticoreFuture ... done
[10:33:24.850] result() for MulticoreFuture ...
[10:33:24.851] result() for MulticoreFuture ... done
[10:33:24.851] signalConditions() ...
[10:33:24.851]  - include = ‘immediateCondition’
[10:33:24.851]  - exclude = 
[10:33:24.851]  - resignal = FALSE
[10:33:24.851]  - Number of conditions: 1
[10:33:24.851] signalConditions() ... done
[10:33:24.851] Future state: ‘finished’
[10:33:24.852] result() for MulticoreFuture ...
[10:33:24.852] result() for MulticoreFuture ... done
[10:33:24.852] signalConditions() ...
[10:33:24.852]  - include = ‘condition’
[10:33:24.852]  - exclude = ‘immediateCondition’
[10:33:24.852]  - resignal = TRUE
[10:33:24.852]  - Number of conditions: 1
[10:33:24.852]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:24.853] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:33:24.857] getGlobalsAndPackages() ...
[10:33:24.857] 
[10:33:24.858] - globals: [0] <none>
[10:33:24.858] getGlobalsAndPackages() ... DONE
[10:33:24.858] Packages needed by the future expression (n = 0): <none>
[10:33:24.858] Packages needed by future strategies (n = 0): <none>
[10:33:24.859] {
[10:33:24.859]     {
[10:33:24.859]         {
[10:33:24.859]             ...future.startTime <- base::Sys.time()
[10:33:24.859]             {
[10:33:24.859]                 {
[10:33:24.859]                   {
[10:33:24.859]                     {
[10:33:24.859]                       base::local({
[10:33:24.859]                         has_future <- base::requireNamespace("future", 
[10:33:24.859]                           quietly = TRUE)
[10:33:24.859]                         if (has_future) {
[10:33:24.859]                           ns <- base::getNamespace("future")
[10:33:24.859]                           version <- ns[[".package"]][["version"]]
[10:33:24.859]                           if (is.null(version)) 
[10:33:24.859]                             version <- utils::packageVersion("future")
[10:33:24.859]                         }
[10:33:24.859]                         else {
[10:33:24.859]                           version <- NULL
[10:33:24.859]                         }
[10:33:24.859]                         if (!has_future || version < "1.8.0") {
[10:33:24.859]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.859]                             "", base::R.version$version.string), 
[10:33:24.859]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.859]                               "release", "version")], collapse = " "), 
[10:33:24.859]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.859]                             info)
[10:33:24.859]                           info <- base::paste(info, collapse = "; ")
[10:33:24.859]                           if (!has_future) {
[10:33:24.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.859]                               info)
[10:33:24.859]                           }
[10:33:24.859]                           else {
[10:33:24.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.859]                               info, version)
[10:33:24.859]                           }
[10:33:24.859]                           base::stop(msg)
[10:33:24.859]                         }
[10:33:24.859]                       })
[10:33:24.859]                     }
[10:33:24.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.859]                     base::options(mc.cores = 1L)
[10:33:24.859]                   }
[10:33:24.859]                   ...future.strategy.old <- future::plan("list")
[10:33:24.859]                   options(future.plan = NULL)
[10:33:24.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.859]                 }
[10:33:24.859]                 ...future.workdir <- getwd()
[10:33:24.859]             }
[10:33:24.859]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.859]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.859]         }
[10:33:24.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.859]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.859]             base::names(...future.oldOptions))
[10:33:24.859]     }
[10:33:24.859]     if (FALSE) {
[10:33:24.859]     }
[10:33:24.859]     else {
[10:33:24.859]         if (TRUE) {
[10:33:24.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.859]                 open = "w")
[10:33:24.859]         }
[10:33:24.859]         else {
[10:33:24.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.859]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.859]         }
[10:33:24.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.859]             base::sink(type = "output", split = FALSE)
[10:33:24.859]             base::close(...future.stdout)
[10:33:24.859]         }, add = TRUE)
[10:33:24.859]     }
[10:33:24.859]     ...future.frame <- base::sys.nframe()
[10:33:24.859]     ...future.conditions <- base::list()
[10:33:24.859]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.859]     if (FALSE) {
[10:33:24.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.859]     }
[10:33:24.859]     ...future.result <- base::tryCatch({
[10:33:24.859]         base::withCallingHandlers({
[10:33:24.859]             ...future.value <- base::withVisible(base::local({
[10:33:24.859]                 withCallingHandlers({
[10:33:24.859]                   {
[10:33:24.859]                     stop(structure(list(message = "boom"), class = c("MyError", 
[10:33:24.859]                       "error", "condition")))
[10:33:24.859]                   }
[10:33:24.859]                 }, immediateCondition = function(cond) {
[10:33:24.859]                   save_rds <- function (object, pathname, ...) 
[10:33:24.859]                   {
[10:33:24.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.859]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.859]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.859]                         fi_tmp[["mtime"]])
[10:33:24.859]                     }
[10:33:24.859]                     tryCatch({
[10:33:24.859]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.859]                     }, error = function(ex) {
[10:33:24.859]                       msg <- conditionMessage(ex)
[10:33:24.859]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.859]                         fi_tmp[["mtime"]], msg)
[10:33:24.859]                       ex$message <- msg
[10:33:24.859]                       stop(ex)
[10:33:24.859]                     })
[10:33:24.859]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.859]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.859]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.859]                       fi <- file.info(pathname)
[10:33:24.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.859]                         fi[["size"]], fi[["mtime"]])
[10:33:24.859]                       stop(msg)
[10:33:24.859]                     }
[10:33:24.859]                     invisible(pathname)
[10:33:24.859]                   }
[10:33:24.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.859]                     rootPath = tempdir()) 
[10:33:24.859]                   {
[10:33:24.859]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.859]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.859]                       tmpdir = path, fileext = ".rds")
[10:33:24.859]                     save_rds(obj, file)
[10:33:24.859]                   }
[10:33:24.859]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.859]                   {
[10:33:24.859]                     inherits <- base::inherits
[10:33:24.859]                     invokeRestart <- base::invokeRestart
[10:33:24.859]                     is.null <- base::is.null
[10:33:24.859]                     muffled <- FALSE
[10:33:24.859]                     if (inherits(cond, "message")) {
[10:33:24.859]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.859]                       if (muffled) 
[10:33:24.859]                         invokeRestart("muffleMessage")
[10:33:24.859]                     }
[10:33:24.859]                     else if (inherits(cond, "warning")) {
[10:33:24.859]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.859]                       if (muffled) 
[10:33:24.859]                         invokeRestart("muffleWarning")
[10:33:24.859]                     }
[10:33:24.859]                     else if (inherits(cond, "condition")) {
[10:33:24.859]                       if (!is.null(pattern)) {
[10:33:24.859]                         computeRestarts <- base::computeRestarts
[10:33:24.859]                         grepl <- base::grepl
[10:33:24.859]                         restarts <- computeRestarts(cond)
[10:33:24.859]                         for (restart in restarts) {
[10:33:24.859]                           name <- restart$name
[10:33:24.859]                           if (is.null(name)) 
[10:33:24.859]                             next
[10:33:24.859]                           if (!grepl(pattern, name)) 
[10:33:24.859]                             next
[10:33:24.859]                           invokeRestart(restart)
[10:33:24.859]                           muffled <- TRUE
[10:33:24.859]                           break
[10:33:24.859]                         }
[10:33:24.859]                       }
[10:33:24.859]                     }
[10:33:24.859]                     invisible(muffled)
[10:33:24.859]                   }
[10:33:24.859]                   muffleCondition(cond)
[10:33:24.859]                 })
[10:33:24.859]             }))
[10:33:24.859]             future::FutureResult(value = ...future.value$value, 
[10:33:24.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.859]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.859]                     ...future.globalenv.names))
[10:33:24.859]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.859]         }, condition = base::local({
[10:33:24.859]             c <- base::c
[10:33:24.859]             inherits <- base::inherits
[10:33:24.859]             invokeRestart <- base::invokeRestart
[10:33:24.859]             length <- base::length
[10:33:24.859]             list <- base::list
[10:33:24.859]             seq.int <- base::seq.int
[10:33:24.859]             signalCondition <- base::signalCondition
[10:33:24.859]             sys.calls <- base::sys.calls
[10:33:24.859]             `[[` <- base::`[[`
[10:33:24.859]             `+` <- base::`+`
[10:33:24.859]             `<<-` <- base::`<<-`
[10:33:24.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.859]                   3L)]
[10:33:24.859]             }
[10:33:24.859]             function(cond) {
[10:33:24.859]                 is_error <- inherits(cond, "error")
[10:33:24.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.859]                   NULL)
[10:33:24.859]                 if (is_error) {
[10:33:24.859]                   sessionInformation <- function() {
[10:33:24.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.859]                       search = base::search(), system = base::Sys.info())
[10:33:24.859]                   }
[10:33:24.859]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.859]                     cond$call), session = sessionInformation(), 
[10:33:24.859]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.859]                   signalCondition(cond)
[10:33:24.859]                 }
[10:33:24.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.859]                 "immediateCondition"))) {
[10:33:24.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.859]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.859]                   if (TRUE && !signal) {
[10:33:24.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.859]                     {
[10:33:24.859]                       inherits <- base::inherits
[10:33:24.859]                       invokeRestart <- base::invokeRestart
[10:33:24.859]                       is.null <- base::is.null
[10:33:24.859]                       muffled <- FALSE
[10:33:24.859]                       if (inherits(cond, "message")) {
[10:33:24.859]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.859]                         if (muffled) 
[10:33:24.859]                           invokeRestart("muffleMessage")
[10:33:24.859]                       }
[10:33:24.859]                       else if (inherits(cond, "warning")) {
[10:33:24.859]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.859]                         if (muffled) 
[10:33:24.859]                           invokeRestart("muffleWarning")
[10:33:24.859]                       }
[10:33:24.859]                       else if (inherits(cond, "condition")) {
[10:33:24.859]                         if (!is.null(pattern)) {
[10:33:24.859]                           computeRestarts <- base::computeRestarts
[10:33:24.859]                           grepl <- base::grepl
[10:33:24.859]                           restarts <- computeRestarts(cond)
[10:33:24.859]                           for (restart in restarts) {
[10:33:24.859]                             name <- restart$name
[10:33:24.859]                             if (is.null(name)) 
[10:33:24.859]                               next
[10:33:24.859]                             if (!grepl(pattern, name)) 
[10:33:24.859]                               next
[10:33:24.859]                             invokeRestart(restart)
[10:33:24.859]                             muffled <- TRUE
[10:33:24.859]                             break
[10:33:24.859]                           }
[10:33:24.859]                         }
[10:33:24.859]                       }
[10:33:24.859]                       invisible(muffled)
[10:33:24.859]                     }
[10:33:24.859]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.859]                   }
[10:33:24.859]                 }
[10:33:24.859]                 else {
[10:33:24.859]                   if (TRUE) {
[10:33:24.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.859]                     {
[10:33:24.859]                       inherits <- base::inherits
[10:33:24.859]                       invokeRestart <- base::invokeRestart
[10:33:24.859]                       is.null <- base::is.null
[10:33:24.859]                       muffled <- FALSE
[10:33:24.859]                       if (inherits(cond, "message")) {
[10:33:24.859]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.859]                         if (muffled) 
[10:33:24.859]                           invokeRestart("muffleMessage")
[10:33:24.859]                       }
[10:33:24.859]                       else if (inherits(cond, "warning")) {
[10:33:24.859]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.859]                         if (muffled) 
[10:33:24.859]                           invokeRestart("muffleWarning")
[10:33:24.859]                       }
[10:33:24.859]                       else if (inherits(cond, "condition")) {
[10:33:24.859]                         if (!is.null(pattern)) {
[10:33:24.859]                           computeRestarts <- base::computeRestarts
[10:33:24.859]                           grepl <- base::grepl
[10:33:24.859]                           restarts <- computeRestarts(cond)
[10:33:24.859]                           for (restart in restarts) {
[10:33:24.859]                             name <- restart$name
[10:33:24.859]                             if (is.null(name)) 
[10:33:24.859]                               next
[10:33:24.859]                             if (!grepl(pattern, name)) 
[10:33:24.859]                               next
[10:33:24.859]                             invokeRestart(restart)
[10:33:24.859]                             muffled <- TRUE
[10:33:24.859]                             break
[10:33:24.859]                           }
[10:33:24.859]                         }
[10:33:24.859]                       }
[10:33:24.859]                       invisible(muffled)
[10:33:24.859]                     }
[10:33:24.859]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.859]                   }
[10:33:24.859]                 }
[10:33:24.859]             }
[10:33:24.859]         }))
[10:33:24.859]     }, error = function(ex) {
[10:33:24.859]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.859]                 ...future.rng), started = ...future.startTime, 
[10:33:24.859]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.859]             version = "1.8"), class = "FutureResult")
[10:33:24.859]     }, finally = {
[10:33:24.859]         if (!identical(...future.workdir, getwd())) 
[10:33:24.859]             setwd(...future.workdir)
[10:33:24.859]         {
[10:33:24.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.859]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.859]             }
[10:33:24.859]             base::options(...future.oldOptions)
[10:33:24.859]             if (.Platform$OS.type == "windows") {
[10:33:24.859]                 old_names <- names(...future.oldEnvVars)
[10:33:24.859]                 envs <- base::Sys.getenv()
[10:33:24.859]                 names <- names(envs)
[10:33:24.859]                 common <- intersect(names, old_names)
[10:33:24.859]                 added <- setdiff(names, old_names)
[10:33:24.859]                 removed <- setdiff(old_names, names)
[10:33:24.859]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.859]                   envs[common]]
[10:33:24.859]                 NAMES <- toupper(changed)
[10:33:24.859]                 args <- list()
[10:33:24.859]                 for (kk in seq_along(NAMES)) {
[10:33:24.859]                   name <- changed[[kk]]
[10:33:24.859]                   NAME <- NAMES[[kk]]
[10:33:24.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.859]                     next
[10:33:24.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.859]                 }
[10:33:24.859]                 NAMES <- toupper(added)
[10:33:24.859]                 for (kk in seq_along(NAMES)) {
[10:33:24.859]                   name <- added[[kk]]
[10:33:24.859]                   NAME <- NAMES[[kk]]
[10:33:24.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.859]                     next
[10:33:24.859]                   args[[name]] <- ""
[10:33:24.859]                 }
[10:33:24.859]                 NAMES <- toupper(removed)
[10:33:24.859]                 for (kk in seq_along(NAMES)) {
[10:33:24.859]                   name <- removed[[kk]]
[10:33:24.859]                   NAME <- NAMES[[kk]]
[10:33:24.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.859]                     next
[10:33:24.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.859]                 }
[10:33:24.859]                 if (length(args) > 0) 
[10:33:24.859]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.859]             }
[10:33:24.859]             else {
[10:33:24.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.859]             }
[10:33:24.859]             {
[10:33:24.859]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.859]                   0L) {
[10:33:24.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.859]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.859]                   base::options(opts)
[10:33:24.859]                 }
[10:33:24.859]                 {
[10:33:24.859]                   {
[10:33:24.859]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.859]                     NULL
[10:33:24.859]                   }
[10:33:24.859]                   options(future.plan = NULL)
[10:33:24.859]                   if (is.na(NA_character_)) 
[10:33:24.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.859]                     .init = FALSE)
[10:33:24.859]                 }
[10:33:24.859]             }
[10:33:24.859]         }
[10:33:24.859]     })
[10:33:24.859]     if (TRUE) {
[10:33:24.859]         base::sink(type = "output", split = FALSE)
[10:33:24.859]         if (TRUE) {
[10:33:24.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.859]         }
[10:33:24.859]         else {
[10:33:24.859]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.859]         }
[10:33:24.859]         base::close(...future.stdout)
[10:33:24.859]         ...future.stdout <- NULL
[10:33:24.859]     }
[10:33:24.859]     ...future.result$conditions <- ...future.conditions
[10:33:24.859]     ...future.result$finished <- base::Sys.time()
[10:33:24.859]     ...future.result
[10:33:24.859] }
[10:33:24.861] requestCore(): workers = 2
[10:33:24.863] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:33:24.864] plan(): Setting new future strategy stack:
[10:33:24.864] List of future strategies:
[10:33:24.864] 1. sequential:
[10:33:24.864]    - args: function (..., envir = parent.frame())
[10:33:24.864]    - tweaked: FALSE
[10:33:24.864]    - call: NULL
[10:33:24.865] plan(): nbrOfWorkers() = 1
[10:33:24.867] plan(): Setting new future strategy stack:
[10:33:24.867] List of future strategies:
[10:33:24.867] 1. multicore:
[10:33:24.867]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.867]    - tweaked: FALSE
[10:33:24.867]    - call: plan(multicore)
[10:33:24.872] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:24.875] result() for MulticoreFuture ...
[10:33:24.877] result() for MulticoreFuture ...
[10:33:24.877] result() for MulticoreFuture ... done
[10:33:24.878] signalConditions() ...
[10:33:24.878]  - include = ‘immediateCondition’
[10:33:24.878]  - exclude = 
[10:33:24.878]  - resignal = FALSE
[10:33:24.878]  - Number of conditions: 1
[10:33:24.878] signalConditions() ... done
[10:33:24.878] result() for MulticoreFuture ... done
[10:33:24.878] result() for MulticoreFuture ...
[10:33:24.879] result() for MulticoreFuture ... done
[10:33:24.879] signalConditions() ...
[10:33:24.879]  - include = ‘immediateCondition’
[10:33:24.879]  - exclude = 
[10:33:24.879]  - resignal = FALSE
[10:33:24.879]  - Number of conditions: 1
[10:33:24.879] signalConditions() ... done
<MyError: boom>
[10:33:24.880] result() for MulticoreFuture ...
[10:33:24.880] result() for MulticoreFuture ... done
[10:33:24.880] result() for MulticoreFuture ...
[10:33:24.880] result() for MulticoreFuture ... done
[10:33:24.880] signalConditions() ...
[10:33:24.880]  - include = ‘immediateCondition’
[10:33:24.880]  - exclude = 
[10:33:24.880]  - resignal = FALSE
[10:33:24.880]  - Number of conditions: 1
[10:33:24.881] signalConditions() ... done
[10:33:24.881] Future state: ‘finished’
[10:33:24.881] result() for MulticoreFuture ...
[10:33:24.881] result() for MulticoreFuture ... done
[10:33:24.881] signalConditions() ...
[10:33:24.881]  - include = ‘condition’
[10:33:24.881]  - exclude = ‘immediateCondition’
[10:33:24.881]  - resignal = TRUE
[10:33:24.881]  - Number of conditions: 1
[10:33:24.882]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:33:24.882] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[10:33:24.886] getGlobalsAndPackages() ...
[10:33:24.886] Searching for globals...
[10:33:24.887] - globals found: [1] ‘{’
[10:33:24.887] Searching for globals ... DONE
[10:33:24.887] Resolving globals: FALSE
[10:33:24.887] 
[10:33:24.888] 
[10:33:24.888] getGlobalsAndPackages() ... DONE
[10:33:24.888] Packages needed by the future expression (n = 0): <none>
[10:33:24.888] Packages needed by future strategies (n = 0): <none>
[10:33:24.889] {
[10:33:24.889]     {
[10:33:24.889]         {
[10:33:24.889]             ...future.startTime <- base::Sys.time()
[10:33:24.889]             {
[10:33:24.889]                 {
[10:33:24.889]                   {
[10:33:24.889]                     {
[10:33:24.889]                       base::local({
[10:33:24.889]                         has_future <- base::requireNamespace("future", 
[10:33:24.889]                           quietly = TRUE)
[10:33:24.889]                         if (has_future) {
[10:33:24.889]                           ns <- base::getNamespace("future")
[10:33:24.889]                           version <- ns[[".package"]][["version"]]
[10:33:24.889]                           if (is.null(version)) 
[10:33:24.889]                             version <- utils::packageVersion("future")
[10:33:24.889]                         }
[10:33:24.889]                         else {
[10:33:24.889]                           version <- NULL
[10:33:24.889]                         }
[10:33:24.889]                         if (!has_future || version < "1.8.0") {
[10:33:24.889]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.889]                             "", base::R.version$version.string), 
[10:33:24.889]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.889]                               "release", "version")], collapse = " "), 
[10:33:24.889]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.889]                             info)
[10:33:24.889]                           info <- base::paste(info, collapse = "; ")
[10:33:24.889]                           if (!has_future) {
[10:33:24.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.889]                               info)
[10:33:24.889]                           }
[10:33:24.889]                           else {
[10:33:24.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.889]                               info, version)
[10:33:24.889]                           }
[10:33:24.889]                           base::stop(msg)
[10:33:24.889]                         }
[10:33:24.889]                       })
[10:33:24.889]                     }
[10:33:24.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.889]                     base::options(mc.cores = 1L)
[10:33:24.889]                   }
[10:33:24.889]                   ...future.strategy.old <- future::plan("list")
[10:33:24.889]                   options(future.plan = NULL)
[10:33:24.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.889]                 }
[10:33:24.889]                 ...future.workdir <- getwd()
[10:33:24.889]             }
[10:33:24.889]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.889]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.889]         }
[10:33:24.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.889]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.889]             base::names(...future.oldOptions))
[10:33:24.889]     }
[10:33:24.889]     if (FALSE) {
[10:33:24.889]     }
[10:33:24.889]     else {
[10:33:24.889]         if (TRUE) {
[10:33:24.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.889]                 open = "w")
[10:33:24.889]         }
[10:33:24.889]         else {
[10:33:24.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.889]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.889]         }
[10:33:24.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.889]             base::sink(type = "output", split = FALSE)
[10:33:24.889]             base::close(...future.stdout)
[10:33:24.889]         }, add = TRUE)
[10:33:24.889]     }
[10:33:24.889]     ...future.frame <- base::sys.nframe()
[10:33:24.889]     ...future.conditions <- base::list()
[10:33:24.889]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.889]     if (FALSE) {
[10:33:24.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.889]     }
[10:33:24.889]     ...future.result <- base::tryCatch({
[10:33:24.889]         base::withCallingHandlers({
[10:33:24.889]             ...future.value <- base::withVisible(base::local({
[10:33:24.889]                 withCallingHandlers({
[10:33:24.889]                   {
[10:33:24.889]                     42L
[10:33:24.889]                   }
[10:33:24.889]                 }, immediateCondition = function(cond) {
[10:33:24.889]                   save_rds <- function (object, pathname, ...) 
[10:33:24.889]                   {
[10:33:24.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.889]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.889]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.889]                         fi_tmp[["mtime"]])
[10:33:24.889]                     }
[10:33:24.889]                     tryCatch({
[10:33:24.889]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.889]                     }, error = function(ex) {
[10:33:24.889]                       msg <- conditionMessage(ex)
[10:33:24.889]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.889]                         fi_tmp[["mtime"]], msg)
[10:33:24.889]                       ex$message <- msg
[10:33:24.889]                       stop(ex)
[10:33:24.889]                     })
[10:33:24.889]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.889]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.889]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.889]                       fi <- file.info(pathname)
[10:33:24.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.889]                         fi[["size"]], fi[["mtime"]])
[10:33:24.889]                       stop(msg)
[10:33:24.889]                     }
[10:33:24.889]                     invisible(pathname)
[10:33:24.889]                   }
[10:33:24.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.889]                     rootPath = tempdir()) 
[10:33:24.889]                   {
[10:33:24.889]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.889]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.889]                       tmpdir = path, fileext = ".rds")
[10:33:24.889]                     save_rds(obj, file)
[10:33:24.889]                   }
[10:33:24.889]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.889]                   {
[10:33:24.889]                     inherits <- base::inherits
[10:33:24.889]                     invokeRestart <- base::invokeRestart
[10:33:24.889]                     is.null <- base::is.null
[10:33:24.889]                     muffled <- FALSE
[10:33:24.889]                     if (inherits(cond, "message")) {
[10:33:24.889]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.889]                       if (muffled) 
[10:33:24.889]                         invokeRestart("muffleMessage")
[10:33:24.889]                     }
[10:33:24.889]                     else if (inherits(cond, "warning")) {
[10:33:24.889]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.889]                       if (muffled) 
[10:33:24.889]                         invokeRestart("muffleWarning")
[10:33:24.889]                     }
[10:33:24.889]                     else if (inherits(cond, "condition")) {
[10:33:24.889]                       if (!is.null(pattern)) {
[10:33:24.889]                         computeRestarts <- base::computeRestarts
[10:33:24.889]                         grepl <- base::grepl
[10:33:24.889]                         restarts <- computeRestarts(cond)
[10:33:24.889]                         for (restart in restarts) {
[10:33:24.889]                           name <- restart$name
[10:33:24.889]                           if (is.null(name)) 
[10:33:24.889]                             next
[10:33:24.889]                           if (!grepl(pattern, name)) 
[10:33:24.889]                             next
[10:33:24.889]                           invokeRestart(restart)
[10:33:24.889]                           muffled <- TRUE
[10:33:24.889]                           break
[10:33:24.889]                         }
[10:33:24.889]                       }
[10:33:24.889]                     }
[10:33:24.889]                     invisible(muffled)
[10:33:24.889]                   }
[10:33:24.889]                   muffleCondition(cond)
[10:33:24.889]                 })
[10:33:24.889]             }))
[10:33:24.889]             future::FutureResult(value = ...future.value$value, 
[10:33:24.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.889]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.889]                     ...future.globalenv.names))
[10:33:24.889]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.889]         }, condition = base::local({
[10:33:24.889]             c <- base::c
[10:33:24.889]             inherits <- base::inherits
[10:33:24.889]             invokeRestart <- base::invokeRestart
[10:33:24.889]             length <- base::length
[10:33:24.889]             list <- base::list
[10:33:24.889]             seq.int <- base::seq.int
[10:33:24.889]             signalCondition <- base::signalCondition
[10:33:24.889]             sys.calls <- base::sys.calls
[10:33:24.889]             `[[` <- base::`[[`
[10:33:24.889]             `+` <- base::`+`
[10:33:24.889]             `<<-` <- base::`<<-`
[10:33:24.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.889]                   3L)]
[10:33:24.889]             }
[10:33:24.889]             function(cond) {
[10:33:24.889]                 is_error <- inherits(cond, "error")
[10:33:24.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.889]                   NULL)
[10:33:24.889]                 if (is_error) {
[10:33:24.889]                   sessionInformation <- function() {
[10:33:24.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.889]                       search = base::search(), system = base::Sys.info())
[10:33:24.889]                   }
[10:33:24.889]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.889]                     cond$call), session = sessionInformation(), 
[10:33:24.889]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.889]                   signalCondition(cond)
[10:33:24.889]                 }
[10:33:24.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.889]                 "immediateCondition"))) {
[10:33:24.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.889]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.889]                   if (TRUE && !signal) {
[10:33:24.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.889]                     {
[10:33:24.889]                       inherits <- base::inherits
[10:33:24.889]                       invokeRestart <- base::invokeRestart
[10:33:24.889]                       is.null <- base::is.null
[10:33:24.889]                       muffled <- FALSE
[10:33:24.889]                       if (inherits(cond, "message")) {
[10:33:24.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.889]                         if (muffled) 
[10:33:24.889]                           invokeRestart("muffleMessage")
[10:33:24.889]                       }
[10:33:24.889]                       else if (inherits(cond, "warning")) {
[10:33:24.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.889]                         if (muffled) 
[10:33:24.889]                           invokeRestart("muffleWarning")
[10:33:24.889]                       }
[10:33:24.889]                       else if (inherits(cond, "condition")) {
[10:33:24.889]                         if (!is.null(pattern)) {
[10:33:24.889]                           computeRestarts <- base::computeRestarts
[10:33:24.889]                           grepl <- base::grepl
[10:33:24.889]                           restarts <- computeRestarts(cond)
[10:33:24.889]                           for (restart in restarts) {
[10:33:24.889]                             name <- restart$name
[10:33:24.889]                             if (is.null(name)) 
[10:33:24.889]                               next
[10:33:24.889]                             if (!grepl(pattern, name)) 
[10:33:24.889]                               next
[10:33:24.889]                             invokeRestart(restart)
[10:33:24.889]                             muffled <- TRUE
[10:33:24.889]                             break
[10:33:24.889]                           }
[10:33:24.889]                         }
[10:33:24.889]                       }
[10:33:24.889]                       invisible(muffled)
[10:33:24.889]                     }
[10:33:24.889]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.889]                   }
[10:33:24.889]                 }
[10:33:24.889]                 else {
[10:33:24.889]                   if (TRUE) {
[10:33:24.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.889]                     {
[10:33:24.889]                       inherits <- base::inherits
[10:33:24.889]                       invokeRestart <- base::invokeRestart
[10:33:24.889]                       is.null <- base::is.null
[10:33:24.889]                       muffled <- FALSE
[10:33:24.889]                       if (inherits(cond, "message")) {
[10:33:24.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.889]                         if (muffled) 
[10:33:24.889]                           invokeRestart("muffleMessage")
[10:33:24.889]                       }
[10:33:24.889]                       else if (inherits(cond, "warning")) {
[10:33:24.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.889]                         if (muffled) 
[10:33:24.889]                           invokeRestart("muffleWarning")
[10:33:24.889]                       }
[10:33:24.889]                       else if (inherits(cond, "condition")) {
[10:33:24.889]                         if (!is.null(pattern)) {
[10:33:24.889]                           computeRestarts <- base::computeRestarts
[10:33:24.889]                           grepl <- base::grepl
[10:33:24.889]                           restarts <- computeRestarts(cond)
[10:33:24.889]                           for (restart in restarts) {
[10:33:24.889]                             name <- restart$name
[10:33:24.889]                             if (is.null(name)) 
[10:33:24.889]                               next
[10:33:24.889]                             if (!grepl(pattern, name)) 
[10:33:24.889]                               next
[10:33:24.889]                             invokeRestart(restart)
[10:33:24.889]                             muffled <- TRUE
[10:33:24.889]                             break
[10:33:24.889]                           }
[10:33:24.889]                         }
[10:33:24.889]                       }
[10:33:24.889]                       invisible(muffled)
[10:33:24.889]                     }
[10:33:24.889]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.889]                   }
[10:33:24.889]                 }
[10:33:24.889]             }
[10:33:24.889]         }))
[10:33:24.889]     }, error = function(ex) {
[10:33:24.889]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.889]                 ...future.rng), started = ...future.startTime, 
[10:33:24.889]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.889]             version = "1.8"), class = "FutureResult")
[10:33:24.889]     }, finally = {
[10:33:24.889]         if (!identical(...future.workdir, getwd())) 
[10:33:24.889]             setwd(...future.workdir)
[10:33:24.889]         {
[10:33:24.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.889]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.889]             }
[10:33:24.889]             base::options(...future.oldOptions)
[10:33:24.889]             if (.Platform$OS.type == "windows") {
[10:33:24.889]                 old_names <- names(...future.oldEnvVars)
[10:33:24.889]                 envs <- base::Sys.getenv()
[10:33:24.889]                 names <- names(envs)
[10:33:24.889]                 common <- intersect(names, old_names)
[10:33:24.889]                 added <- setdiff(names, old_names)
[10:33:24.889]                 removed <- setdiff(old_names, names)
[10:33:24.889]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.889]                   envs[common]]
[10:33:24.889]                 NAMES <- toupper(changed)
[10:33:24.889]                 args <- list()
[10:33:24.889]                 for (kk in seq_along(NAMES)) {
[10:33:24.889]                   name <- changed[[kk]]
[10:33:24.889]                   NAME <- NAMES[[kk]]
[10:33:24.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.889]                     next
[10:33:24.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.889]                 }
[10:33:24.889]                 NAMES <- toupper(added)
[10:33:24.889]                 for (kk in seq_along(NAMES)) {
[10:33:24.889]                   name <- added[[kk]]
[10:33:24.889]                   NAME <- NAMES[[kk]]
[10:33:24.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.889]                     next
[10:33:24.889]                   args[[name]] <- ""
[10:33:24.889]                 }
[10:33:24.889]                 NAMES <- toupper(removed)
[10:33:24.889]                 for (kk in seq_along(NAMES)) {
[10:33:24.889]                   name <- removed[[kk]]
[10:33:24.889]                   NAME <- NAMES[[kk]]
[10:33:24.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.889]                     next
[10:33:24.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.889]                 }
[10:33:24.889]                 if (length(args) > 0) 
[10:33:24.889]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.889]             }
[10:33:24.889]             else {
[10:33:24.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.889]             }
[10:33:24.889]             {
[10:33:24.889]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.889]                   0L) {
[10:33:24.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.889]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.889]                   base::options(opts)
[10:33:24.889]                 }
[10:33:24.889]                 {
[10:33:24.889]                   {
[10:33:24.889]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.889]                     NULL
[10:33:24.889]                   }
[10:33:24.889]                   options(future.plan = NULL)
[10:33:24.889]                   if (is.na(NA_character_)) 
[10:33:24.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.889]                     .init = FALSE)
[10:33:24.889]                 }
[10:33:24.889]             }
[10:33:24.889]         }
[10:33:24.889]     })
[10:33:24.889]     if (TRUE) {
[10:33:24.889]         base::sink(type = "output", split = FALSE)
[10:33:24.889]         if (TRUE) {
[10:33:24.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.889]         }
[10:33:24.889]         else {
[10:33:24.889]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.889]         }
[10:33:24.889]         base::close(...future.stdout)
[10:33:24.889]         ...future.stdout <- NULL
[10:33:24.889]     }
[10:33:24.889]     ...future.result$conditions <- ...future.conditions
[10:33:24.889]     ...future.result$finished <- base::Sys.time()
[10:33:24.889]     ...future.result
[10:33:24.889] }
[10:33:24.892] requestCore(): workers = 2
[10:33:24.893] MulticoreFuture started
[10:33:24.894] plan(): Setting new future strategy stack:
[10:33:24.895] List of future strategies:
[10:33:24.895] 1. sequential:
[10:33:24.895]    - args: function (..., envir = parent.frame())
[10:33:24.895]    - tweaked: FALSE
[10:33:24.895]    - call: NULL
[10:33:24.896] plan(): nbrOfWorkers() = 1
[10:33:24.898] plan(): Setting new future strategy stack:
[10:33:24.898] List of future strategies:
[10:33:24.898] 1. multicore:
[10:33:24.898]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.898]    - tweaked: FALSE
[10:33:24.898]    - call: plan(multicore)
[10:33:24.903] plan(): nbrOfWorkers() = 2
[1] TRUE
[10:33:24.903] result() for MulticoreFuture ...
[10:33:24.905] result() for MulticoreFuture ...
[10:33:24.905] result() for MulticoreFuture ... done
[10:33:24.905] result() for MulticoreFuture ... done
[10:33:24.905] result() for MulticoreFuture ...
[10:33:24.905] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = TRUE) with globals
[10:33:24.909] getGlobalsAndPackages() ...
[10:33:24.909] Searching for globals...
[10:33:24.912] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:33:24.912] Searching for globals ... DONE
[10:33:24.912] Resolving globals: FALSE
[10:33:24.912] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.913] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:33:24.913] - globals: [1] ‘a’
[10:33:24.913] 
[10:33:24.913] getGlobalsAndPackages() ... DONE
[10:33:24.914] Packages needed by the future expression (n = 0): <none>
[10:33:24.914] Packages needed by future strategies (n = 0): <none>
[10:33:24.918] {
[10:33:24.918]     {
[10:33:24.918]         {
[10:33:24.918]             ...future.startTime <- base::Sys.time()
[10:33:24.918]             {
[10:33:24.918]                 {
[10:33:24.918]                   {
[10:33:24.918]                     {
[10:33:24.918]                       base::local({
[10:33:24.918]                         has_future <- base::requireNamespace("future", 
[10:33:24.918]                           quietly = TRUE)
[10:33:24.918]                         if (has_future) {
[10:33:24.918]                           ns <- base::getNamespace("future")
[10:33:24.918]                           version <- ns[[".package"]][["version"]]
[10:33:24.918]                           if (is.null(version)) 
[10:33:24.918]                             version <- utils::packageVersion("future")
[10:33:24.918]                         }
[10:33:24.918]                         else {
[10:33:24.918]                           version <- NULL
[10:33:24.918]                         }
[10:33:24.918]                         if (!has_future || version < "1.8.0") {
[10:33:24.918]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.918]                             "", base::R.version$version.string), 
[10:33:24.918]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.918]                               "release", "version")], collapse = " "), 
[10:33:24.918]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.918]                             info)
[10:33:24.918]                           info <- base::paste(info, collapse = "; ")
[10:33:24.918]                           if (!has_future) {
[10:33:24.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.918]                               info)
[10:33:24.918]                           }
[10:33:24.918]                           else {
[10:33:24.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.918]                               info, version)
[10:33:24.918]                           }
[10:33:24.918]                           base::stop(msg)
[10:33:24.918]                         }
[10:33:24.918]                       })
[10:33:24.918]                     }
[10:33:24.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.918]                     base::options(mc.cores = 1L)
[10:33:24.918]                   }
[10:33:24.918]                   ...future.strategy.old <- future::plan("list")
[10:33:24.918]                   options(future.plan = NULL)
[10:33:24.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.918]                 }
[10:33:24.918]                 ...future.workdir <- getwd()
[10:33:24.918]             }
[10:33:24.918]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.918]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.918]         }
[10:33:24.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.918]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.918]             base::names(...future.oldOptions))
[10:33:24.918]     }
[10:33:24.918]     if (FALSE) {
[10:33:24.918]     }
[10:33:24.918]     else {
[10:33:24.918]         if (TRUE) {
[10:33:24.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.918]                 open = "w")
[10:33:24.918]         }
[10:33:24.918]         else {
[10:33:24.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.918]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.918]         }
[10:33:24.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.918]             base::sink(type = "output", split = FALSE)
[10:33:24.918]             base::close(...future.stdout)
[10:33:24.918]         }, add = TRUE)
[10:33:24.918]     }
[10:33:24.918]     ...future.frame <- base::sys.nframe()
[10:33:24.918]     ...future.conditions <- base::list()
[10:33:24.918]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.918]     if (FALSE) {
[10:33:24.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.918]     }
[10:33:24.918]     ...future.result <- base::tryCatch({
[10:33:24.918]         base::withCallingHandlers({
[10:33:24.918]             ...future.value <- base::withVisible(base::local({
[10:33:24.918]                 withCallingHandlers({
[10:33:24.918]                   {
[10:33:24.918]                     b <- 3
[10:33:24.918]                     c <- 2
[10:33:24.918]                     a * b * c
[10:33:24.918]                   }
[10:33:24.918]                 }, immediateCondition = function(cond) {
[10:33:24.918]                   save_rds <- function (object, pathname, ...) 
[10:33:24.918]                   {
[10:33:24.918]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.918]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.918]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.918]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.918]                         fi_tmp[["mtime"]])
[10:33:24.918]                     }
[10:33:24.918]                     tryCatch({
[10:33:24.918]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.918]                     }, error = function(ex) {
[10:33:24.918]                       msg <- conditionMessage(ex)
[10:33:24.918]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.918]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.918]                         fi_tmp[["mtime"]], msg)
[10:33:24.918]                       ex$message <- msg
[10:33:24.918]                       stop(ex)
[10:33:24.918]                     })
[10:33:24.918]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.918]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.918]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.918]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.918]                       fi <- file.info(pathname)
[10:33:24.918]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.918]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.918]                         fi[["size"]], fi[["mtime"]])
[10:33:24.918]                       stop(msg)
[10:33:24.918]                     }
[10:33:24.918]                     invisible(pathname)
[10:33:24.918]                   }
[10:33:24.918]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.918]                     rootPath = tempdir()) 
[10:33:24.918]                   {
[10:33:24.918]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.918]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.918]                       tmpdir = path, fileext = ".rds")
[10:33:24.918]                     save_rds(obj, file)
[10:33:24.918]                   }
[10:33:24.918]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.918]                   {
[10:33:24.918]                     inherits <- base::inherits
[10:33:24.918]                     invokeRestart <- base::invokeRestart
[10:33:24.918]                     is.null <- base::is.null
[10:33:24.918]                     muffled <- FALSE
[10:33:24.918]                     if (inherits(cond, "message")) {
[10:33:24.918]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.918]                       if (muffled) 
[10:33:24.918]                         invokeRestart("muffleMessage")
[10:33:24.918]                     }
[10:33:24.918]                     else if (inherits(cond, "warning")) {
[10:33:24.918]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.918]                       if (muffled) 
[10:33:24.918]                         invokeRestart("muffleWarning")
[10:33:24.918]                     }
[10:33:24.918]                     else if (inherits(cond, "condition")) {
[10:33:24.918]                       if (!is.null(pattern)) {
[10:33:24.918]                         computeRestarts <- base::computeRestarts
[10:33:24.918]                         grepl <- base::grepl
[10:33:24.918]                         restarts <- computeRestarts(cond)
[10:33:24.918]                         for (restart in restarts) {
[10:33:24.918]                           name <- restart$name
[10:33:24.918]                           if (is.null(name)) 
[10:33:24.918]                             next
[10:33:24.918]                           if (!grepl(pattern, name)) 
[10:33:24.918]                             next
[10:33:24.918]                           invokeRestart(restart)
[10:33:24.918]                           muffled <- TRUE
[10:33:24.918]                           break
[10:33:24.918]                         }
[10:33:24.918]                       }
[10:33:24.918]                     }
[10:33:24.918]                     invisible(muffled)
[10:33:24.918]                   }
[10:33:24.918]                   muffleCondition(cond)
[10:33:24.918]                 })
[10:33:24.918]             }))
[10:33:24.918]             future::FutureResult(value = ...future.value$value, 
[10:33:24.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.918]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.918]                     ...future.globalenv.names))
[10:33:24.918]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.918]         }, condition = base::local({
[10:33:24.918]             c <- base::c
[10:33:24.918]             inherits <- base::inherits
[10:33:24.918]             invokeRestart <- base::invokeRestart
[10:33:24.918]             length <- base::length
[10:33:24.918]             list <- base::list
[10:33:24.918]             seq.int <- base::seq.int
[10:33:24.918]             signalCondition <- base::signalCondition
[10:33:24.918]             sys.calls <- base::sys.calls
[10:33:24.918]             `[[` <- base::`[[`
[10:33:24.918]             `+` <- base::`+`
[10:33:24.918]             `<<-` <- base::`<<-`
[10:33:24.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.918]                   3L)]
[10:33:24.918]             }
[10:33:24.918]             function(cond) {
[10:33:24.918]                 is_error <- inherits(cond, "error")
[10:33:24.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.918]                   NULL)
[10:33:24.918]                 if (is_error) {
[10:33:24.918]                   sessionInformation <- function() {
[10:33:24.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.918]                       search = base::search(), system = base::Sys.info())
[10:33:24.918]                   }
[10:33:24.918]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.918]                     cond$call), session = sessionInformation(), 
[10:33:24.918]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.918]                   signalCondition(cond)
[10:33:24.918]                 }
[10:33:24.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.918]                 "immediateCondition"))) {
[10:33:24.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.918]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.918]                   if (TRUE && !signal) {
[10:33:24.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.918]                     {
[10:33:24.918]                       inherits <- base::inherits
[10:33:24.918]                       invokeRestart <- base::invokeRestart
[10:33:24.918]                       is.null <- base::is.null
[10:33:24.918]                       muffled <- FALSE
[10:33:24.918]                       if (inherits(cond, "message")) {
[10:33:24.918]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.918]                         if (muffled) 
[10:33:24.918]                           invokeRestart("muffleMessage")
[10:33:24.918]                       }
[10:33:24.918]                       else if (inherits(cond, "warning")) {
[10:33:24.918]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.918]                         if (muffled) 
[10:33:24.918]                           invokeRestart("muffleWarning")
[10:33:24.918]                       }
[10:33:24.918]                       else if (inherits(cond, "condition")) {
[10:33:24.918]                         if (!is.null(pattern)) {
[10:33:24.918]                           computeRestarts <- base::computeRestarts
[10:33:24.918]                           grepl <- base::grepl
[10:33:24.918]                           restarts <- computeRestarts(cond)
[10:33:24.918]                           for (restart in restarts) {
[10:33:24.918]                             name <- restart$name
[10:33:24.918]                             if (is.null(name)) 
[10:33:24.918]                               next
[10:33:24.918]                             if (!grepl(pattern, name)) 
[10:33:24.918]                               next
[10:33:24.918]                             invokeRestart(restart)
[10:33:24.918]                             muffled <- TRUE
[10:33:24.918]                             break
[10:33:24.918]                           }
[10:33:24.918]                         }
[10:33:24.918]                       }
[10:33:24.918]                       invisible(muffled)
[10:33:24.918]                     }
[10:33:24.918]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.918]                   }
[10:33:24.918]                 }
[10:33:24.918]                 else {
[10:33:24.918]                   if (TRUE) {
[10:33:24.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.918]                     {
[10:33:24.918]                       inherits <- base::inherits
[10:33:24.918]                       invokeRestart <- base::invokeRestart
[10:33:24.918]                       is.null <- base::is.null
[10:33:24.918]                       muffled <- FALSE
[10:33:24.918]                       if (inherits(cond, "message")) {
[10:33:24.918]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.918]                         if (muffled) 
[10:33:24.918]                           invokeRestart("muffleMessage")
[10:33:24.918]                       }
[10:33:24.918]                       else if (inherits(cond, "warning")) {
[10:33:24.918]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.918]                         if (muffled) 
[10:33:24.918]                           invokeRestart("muffleWarning")
[10:33:24.918]                       }
[10:33:24.918]                       else if (inherits(cond, "condition")) {
[10:33:24.918]                         if (!is.null(pattern)) {
[10:33:24.918]                           computeRestarts <- base::computeRestarts
[10:33:24.918]                           grepl <- base::grepl
[10:33:24.918]                           restarts <- computeRestarts(cond)
[10:33:24.918]                           for (restart in restarts) {
[10:33:24.918]                             name <- restart$name
[10:33:24.918]                             if (is.null(name)) 
[10:33:24.918]                               next
[10:33:24.918]                             if (!grepl(pattern, name)) 
[10:33:24.918]                               next
[10:33:24.918]                             invokeRestart(restart)
[10:33:24.918]                             muffled <- TRUE
[10:33:24.918]                             break
[10:33:24.918]                           }
[10:33:24.918]                         }
[10:33:24.918]                       }
[10:33:24.918]                       invisible(muffled)
[10:33:24.918]                     }
[10:33:24.918]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.918]                   }
[10:33:24.918]                 }
[10:33:24.918]             }
[10:33:24.918]         }))
[10:33:24.918]     }, error = function(ex) {
[10:33:24.918]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.918]                 ...future.rng), started = ...future.startTime, 
[10:33:24.918]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.918]             version = "1.8"), class = "FutureResult")
[10:33:24.918]     }, finally = {
[10:33:24.918]         if (!identical(...future.workdir, getwd())) 
[10:33:24.918]             setwd(...future.workdir)
[10:33:24.918]         {
[10:33:24.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.918]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.918]             }
[10:33:24.918]             base::options(...future.oldOptions)
[10:33:24.918]             if (.Platform$OS.type == "windows") {
[10:33:24.918]                 old_names <- names(...future.oldEnvVars)
[10:33:24.918]                 envs <- base::Sys.getenv()
[10:33:24.918]                 names <- names(envs)
[10:33:24.918]                 common <- intersect(names, old_names)
[10:33:24.918]                 added <- setdiff(names, old_names)
[10:33:24.918]                 removed <- setdiff(old_names, names)
[10:33:24.918]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.918]                   envs[common]]
[10:33:24.918]                 NAMES <- toupper(changed)
[10:33:24.918]                 args <- list()
[10:33:24.918]                 for (kk in seq_along(NAMES)) {
[10:33:24.918]                   name <- changed[[kk]]
[10:33:24.918]                   NAME <- NAMES[[kk]]
[10:33:24.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.918]                     next
[10:33:24.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.918]                 }
[10:33:24.918]                 NAMES <- toupper(added)
[10:33:24.918]                 for (kk in seq_along(NAMES)) {
[10:33:24.918]                   name <- added[[kk]]
[10:33:24.918]                   NAME <- NAMES[[kk]]
[10:33:24.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.918]                     next
[10:33:24.918]                   args[[name]] <- ""
[10:33:24.918]                 }
[10:33:24.918]                 NAMES <- toupper(removed)
[10:33:24.918]                 for (kk in seq_along(NAMES)) {
[10:33:24.918]                   name <- removed[[kk]]
[10:33:24.918]                   NAME <- NAMES[[kk]]
[10:33:24.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.918]                     next
[10:33:24.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.918]                 }
[10:33:24.918]                 if (length(args) > 0) 
[10:33:24.918]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.918]             }
[10:33:24.918]             else {
[10:33:24.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.918]             }
[10:33:24.918]             {
[10:33:24.918]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.918]                   0L) {
[10:33:24.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.918]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.918]                   base::options(opts)
[10:33:24.918]                 }
[10:33:24.918]                 {
[10:33:24.918]                   {
[10:33:24.918]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.918]                     NULL
[10:33:24.918]                   }
[10:33:24.918]                   options(future.plan = NULL)
[10:33:24.918]                   if (is.na(NA_character_)) 
[10:33:24.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.918]                     .init = FALSE)
[10:33:24.918]                 }
[10:33:24.918]             }
[10:33:24.918]         }
[10:33:24.918]     })
[10:33:24.918]     if (TRUE) {
[10:33:24.918]         base::sink(type = "output", split = FALSE)
[10:33:24.918]         if (TRUE) {
[10:33:24.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.918]         }
[10:33:24.918]         else {
[10:33:24.918]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.918]         }
[10:33:24.918]         base::close(...future.stdout)
[10:33:24.918]         ...future.stdout <- NULL
[10:33:24.918]     }
[10:33:24.918]     ...future.result$conditions <- ...future.conditions
[10:33:24.918]     ...future.result$finished <- base::Sys.time()
[10:33:24.918]     ...future.result
[10:33:24.918] }
[10:33:24.920] assign_globals() ...
[10:33:24.920] List of 1
[10:33:24.920]  $ a: num 0
[10:33:24.920]  - attr(*, "where")=List of 1
[10:33:24.920]   ..$ a:<environment: R_EmptyEnv> 
[10:33:24.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.920]  - attr(*, "resolved")= logi FALSE
[10:33:24.920]  - attr(*, "total_size")= num 56
[10:33:24.923] - copied ‘a’ to environment
[10:33:24.923] assign_globals() ... done
[10:33:24.923] requestCore(): workers = 2
[10:33:24.925] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
[10:33:24.927] plan(): Setting new future strategy stack:
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:33:24.927] List of future strategies:
[10:33:24.927] 1. sequential:
[10:33:24.927]    - args: function (..., envir = parent.frame())
[10:33:24.927]    - tweaked: FALSE
[10:33:24.927]    - call: NULL
[10:33:24.928] plan(): nbrOfWorkers() = 1
[10:33:24.930] plan(): Setting new future strategy stack:
[10:33:24.930] List of future strategies:
[10:33:24.930] 1. multicore:
[10:33:24.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.930]    - tweaked: FALSE
[10:33:24.930]    - call: plan(multicore)
[10:33:24.935] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:24.936] result() for MulticoreFuture ...
[10:33:24.937] result() for MulticoreFuture ...
[10:33:24.937] result() for MulticoreFuture ... done
[10:33:24.937] result() for MulticoreFuture ... done
[10:33:24.937] result() for MulticoreFuture ...
[10:33:24.938] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[10:33:24.943] getGlobalsAndPackages() ...
[10:33:24.943] Searching for globals...
[10:33:24.944] - globals found: [2] ‘{’, ‘ii’
[10:33:24.944] Searching for globals ... DONE
[10:33:24.944] Resolving globals: FALSE
[10:33:24.945] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.945] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.946] - globals: [1] ‘ii’
[10:33:24.946] 
[10:33:24.946] getGlobalsAndPackages() ... DONE
[10:33:24.946] Packages needed by the future expression (n = 0): <none>
[10:33:24.946] Packages needed by future strategies (n = 0): <none>
[10:33:24.947] {
[10:33:24.947]     {
[10:33:24.947]         {
[10:33:24.947]             ...future.startTime <- base::Sys.time()
[10:33:24.947]             {
[10:33:24.947]                 {
[10:33:24.947]                   {
[10:33:24.947]                     {
[10:33:24.947]                       base::local({
[10:33:24.947]                         has_future <- base::requireNamespace("future", 
[10:33:24.947]                           quietly = TRUE)
[10:33:24.947]                         if (has_future) {
[10:33:24.947]                           ns <- base::getNamespace("future")
[10:33:24.947]                           version <- ns[[".package"]][["version"]]
[10:33:24.947]                           if (is.null(version)) 
[10:33:24.947]                             version <- utils::packageVersion("future")
[10:33:24.947]                         }
[10:33:24.947]                         else {
[10:33:24.947]                           version <- NULL
[10:33:24.947]                         }
[10:33:24.947]                         if (!has_future || version < "1.8.0") {
[10:33:24.947]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.947]                             "", base::R.version$version.string), 
[10:33:24.947]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.947]                               "release", "version")], collapse = " "), 
[10:33:24.947]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.947]                             info)
[10:33:24.947]                           info <- base::paste(info, collapse = "; ")
[10:33:24.947]                           if (!has_future) {
[10:33:24.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.947]                               info)
[10:33:24.947]                           }
[10:33:24.947]                           else {
[10:33:24.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.947]                               info, version)
[10:33:24.947]                           }
[10:33:24.947]                           base::stop(msg)
[10:33:24.947]                         }
[10:33:24.947]                       })
[10:33:24.947]                     }
[10:33:24.947]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.947]                     base::options(mc.cores = 1L)
[10:33:24.947]                   }
[10:33:24.947]                   ...future.strategy.old <- future::plan("list")
[10:33:24.947]                   options(future.plan = NULL)
[10:33:24.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.947]                 }
[10:33:24.947]                 ...future.workdir <- getwd()
[10:33:24.947]             }
[10:33:24.947]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.947]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.947]         }
[10:33:24.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.947]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.947]             base::names(...future.oldOptions))
[10:33:24.947]     }
[10:33:24.947]     if (FALSE) {
[10:33:24.947]     }
[10:33:24.947]     else {
[10:33:24.947]         if (TRUE) {
[10:33:24.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.947]                 open = "w")
[10:33:24.947]         }
[10:33:24.947]         else {
[10:33:24.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.947]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.947]         }
[10:33:24.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.947]             base::sink(type = "output", split = FALSE)
[10:33:24.947]             base::close(...future.stdout)
[10:33:24.947]         }, add = TRUE)
[10:33:24.947]     }
[10:33:24.947]     ...future.frame <- base::sys.nframe()
[10:33:24.947]     ...future.conditions <- base::list()
[10:33:24.947]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.947]     if (FALSE) {
[10:33:24.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.947]     }
[10:33:24.947]     ...future.result <- base::tryCatch({
[10:33:24.947]         base::withCallingHandlers({
[10:33:24.947]             ...future.value <- base::withVisible(base::local({
[10:33:24.947]                 withCallingHandlers({
[10:33:24.947]                   {
[10:33:24.947]                     ii
[10:33:24.947]                   }
[10:33:24.947]                 }, immediateCondition = function(cond) {
[10:33:24.947]                   save_rds <- function (object, pathname, ...) 
[10:33:24.947]                   {
[10:33:24.947]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.947]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.947]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.947]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.947]                         fi_tmp[["mtime"]])
[10:33:24.947]                     }
[10:33:24.947]                     tryCatch({
[10:33:24.947]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.947]                     }, error = function(ex) {
[10:33:24.947]                       msg <- conditionMessage(ex)
[10:33:24.947]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.947]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.947]                         fi_tmp[["mtime"]], msg)
[10:33:24.947]                       ex$message <- msg
[10:33:24.947]                       stop(ex)
[10:33:24.947]                     })
[10:33:24.947]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.947]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.947]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.947]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.947]                       fi <- file.info(pathname)
[10:33:24.947]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.947]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.947]                         fi[["size"]], fi[["mtime"]])
[10:33:24.947]                       stop(msg)
[10:33:24.947]                     }
[10:33:24.947]                     invisible(pathname)
[10:33:24.947]                   }
[10:33:24.947]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.947]                     rootPath = tempdir()) 
[10:33:24.947]                   {
[10:33:24.947]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.947]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.947]                       tmpdir = path, fileext = ".rds")
[10:33:24.947]                     save_rds(obj, file)
[10:33:24.947]                   }
[10:33:24.947]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.947]                   {
[10:33:24.947]                     inherits <- base::inherits
[10:33:24.947]                     invokeRestart <- base::invokeRestart
[10:33:24.947]                     is.null <- base::is.null
[10:33:24.947]                     muffled <- FALSE
[10:33:24.947]                     if (inherits(cond, "message")) {
[10:33:24.947]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.947]                       if (muffled) 
[10:33:24.947]                         invokeRestart("muffleMessage")
[10:33:24.947]                     }
[10:33:24.947]                     else if (inherits(cond, "warning")) {
[10:33:24.947]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.947]                       if (muffled) 
[10:33:24.947]                         invokeRestart("muffleWarning")
[10:33:24.947]                     }
[10:33:24.947]                     else if (inherits(cond, "condition")) {
[10:33:24.947]                       if (!is.null(pattern)) {
[10:33:24.947]                         computeRestarts <- base::computeRestarts
[10:33:24.947]                         grepl <- base::grepl
[10:33:24.947]                         restarts <- computeRestarts(cond)
[10:33:24.947]                         for (restart in restarts) {
[10:33:24.947]                           name <- restart$name
[10:33:24.947]                           if (is.null(name)) 
[10:33:24.947]                             next
[10:33:24.947]                           if (!grepl(pattern, name)) 
[10:33:24.947]                             next
[10:33:24.947]                           invokeRestart(restart)
[10:33:24.947]                           muffled <- TRUE
[10:33:24.947]                           break
[10:33:24.947]                         }
[10:33:24.947]                       }
[10:33:24.947]                     }
[10:33:24.947]                     invisible(muffled)
[10:33:24.947]                   }
[10:33:24.947]                   muffleCondition(cond)
[10:33:24.947]                 })
[10:33:24.947]             }))
[10:33:24.947]             future::FutureResult(value = ...future.value$value, 
[10:33:24.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.947]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.947]                     ...future.globalenv.names))
[10:33:24.947]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.947]         }, condition = base::local({
[10:33:24.947]             c <- base::c
[10:33:24.947]             inherits <- base::inherits
[10:33:24.947]             invokeRestart <- base::invokeRestart
[10:33:24.947]             length <- base::length
[10:33:24.947]             list <- base::list
[10:33:24.947]             seq.int <- base::seq.int
[10:33:24.947]             signalCondition <- base::signalCondition
[10:33:24.947]             sys.calls <- base::sys.calls
[10:33:24.947]             `[[` <- base::`[[`
[10:33:24.947]             `+` <- base::`+`
[10:33:24.947]             `<<-` <- base::`<<-`
[10:33:24.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.947]                   3L)]
[10:33:24.947]             }
[10:33:24.947]             function(cond) {
[10:33:24.947]                 is_error <- inherits(cond, "error")
[10:33:24.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.947]                   NULL)
[10:33:24.947]                 if (is_error) {
[10:33:24.947]                   sessionInformation <- function() {
[10:33:24.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.947]                       search = base::search(), system = base::Sys.info())
[10:33:24.947]                   }
[10:33:24.947]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.947]                     cond$call), session = sessionInformation(), 
[10:33:24.947]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.947]                   signalCondition(cond)
[10:33:24.947]                 }
[10:33:24.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.947]                 "immediateCondition"))) {
[10:33:24.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.947]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.947]                   if (TRUE && !signal) {
[10:33:24.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.947]                     {
[10:33:24.947]                       inherits <- base::inherits
[10:33:24.947]                       invokeRestart <- base::invokeRestart
[10:33:24.947]                       is.null <- base::is.null
[10:33:24.947]                       muffled <- FALSE
[10:33:24.947]                       if (inherits(cond, "message")) {
[10:33:24.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.947]                         if (muffled) 
[10:33:24.947]                           invokeRestart("muffleMessage")
[10:33:24.947]                       }
[10:33:24.947]                       else if (inherits(cond, "warning")) {
[10:33:24.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.947]                         if (muffled) 
[10:33:24.947]                           invokeRestart("muffleWarning")
[10:33:24.947]                       }
[10:33:24.947]                       else if (inherits(cond, "condition")) {
[10:33:24.947]                         if (!is.null(pattern)) {
[10:33:24.947]                           computeRestarts <- base::computeRestarts
[10:33:24.947]                           grepl <- base::grepl
[10:33:24.947]                           restarts <- computeRestarts(cond)
[10:33:24.947]                           for (restart in restarts) {
[10:33:24.947]                             name <- restart$name
[10:33:24.947]                             if (is.null(name)) 
[10:33:24.947]                               next
[10:33:24.947]                             if (!grepl(pattern, name)) 
[10:33:24.947]                               next
[10:33:24.947]                             invokeRestart(restart)
[10:33:24.947]                             muffled <- TRUE
[10:33:24.947]                             break
[10:33:24.947]                           }
[10:33:24.947]                         }
[10:33:24.947]                       }
[10:33:24.947]                       invisible(muffled)
[10:33:24.947]                     }
[10:33:24.947]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.947]                   }
[10:33:24.947]                 }
[10:33:24.947]                 else {
[10:33:24.947]                   if (TRUE) {
[10:33:24.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.947]                     {
[10:33:24.947]                       inherits <- base::inherits
[10:33:24.947]                       invokeRestart <- base::invokeRestart
[10:33:24.947]                       is.null <- base::is.null
[10:33:24.947]                       muffled <- FALSE
[10:33:24.947]                       if (inherits(cond, "message")) {
[10:33:24.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.947]                         if (muffled) 
[10:33:24.947]                           invokeRestart("muffleMessage")
[10:33:24.947]                       }
[10:33:24.947]                       else if (inherits(cond, "warning")) {
[10:33:24.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.947]                         if (muffled) 
[10:33:24.947]                           invokeRestart("muffleWarning")
[10:33:24.947]                       }
[10:33:24.947]                       else if (inherits(cond, "condition")) {
[10:33:24.947]                         if (!is.null(pattern)) {
[10:33:24.947]                           computeRestarts <- base::computeRestarts
[10:33:24.947]                           grepl <- base::grepl
[10:33:24.947]                           restarts <- computeRestarts(cond)
[10:33:24.947]                           for (restart in restarts) {
[10:33:24.947]                             name <- restart$name
[10:33:24.947]                             if (is.null(name)) 
[10:33:24.947]                               next
[10:33:24.947]                             if (!grepl(pattern, name)) 
[10:33:24.947]                               next
[10:33:24.947]                             invokeRestart(restart)
[10:33:24.947]                             muffled <- TRUE
[10:33:24.947]                             break
[10:33:24.947]                           }
[10:33:24.947]                         }
[10:33:24.947]                       }
[10:33:24.947]                       invisible(muffled)
[10:33:24.947]                     }
[10:33:24.947]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.947]                   }
[10:33:24.947]                 }
[10:33:24.947]             }
[10:33:24.947]         }))
[10:33:24.947]     }, error = function(ex) {
[10:33:24.947]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.947]                 ...future.rng), started = ...future.startTime, 
[10:33:24.947]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.947]             version = "1.8"), class = "FutureResult")
[10:33:24.947]     }, finally = {
[10:33:24.947]         if (!identical(...future.workdir, getwd())) 
[10:33:24.947]             setwd(...future.workdir)
[10:33:24.947]         {
[10:33:24.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.947]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.947]             }
[10:33:24.947]             base::options(...future.oldOptions)
[10:33:24.947]             if (.Platform$OS.type == "windows") {
[10:33:24.947]                 old_names <- names(...future.oldEnvVars)
[10:33:24.947]                 envs <- base::Sys.getenv()
[10:33:24.947]                 names <- names(envs)
[10:33:24.947]                 common <- intersect(names, old_names)
[10:33:24.947]                 added <- setdiff(names, old_names)
[10:33:24.947]                 removed <- setdiff(old_names, names)
[10:33:24.947]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.947]                   envs[common]]
[10:33:24.947]                 NAMES <- toupper(changed)
[10:33:24.947]                 args <- list()
[10:33:24.947]                 for (kk in seq_along(NAMES)) {
[10:33:24.947]                   name <- changed[[kk]]
[10:33:24.947]                   NAME <- NAMES[[kk]]
[10:33:24.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.947]                     next
[10:33:24.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.947]                 }
[10:33:24.947]                 NAMES <- toupper(added)
[10:33:24.947]                 for (kk in seq_along(NAMES)) {
[10:33:24.947]                   name <- added[[kk]]
[10:33:24.947]                   NAME <- NAMES[[kk]]
[10:33:24.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.947]                     next
[10:33:24.947]                   args[[name]] <- ""
[10:33:24.947]                 }
[10:33:24.947]                 NAMES <- toupper(removed)
[10:33:24.947]                 for (kk in seq_along(NAMES)) {
[10:33:24.947]                   name <- removed[[kk]]
[10:33:24.947]                   NAME <- NAMES[[kk]]
[10:33:24.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.947]                     next
[10:33:24.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.947]                 }
[10:33:24.947]                 if (length(args) > 0) 
[10:33:24.947]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.947]             }
[10:33:24.947]             else {
[10:33:24.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.947]             }
[10:33:24.947]             {
[10:33:24.947]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.947]                   0L) {
[10:33:24.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.947]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.947]                   base::options(opts)
[10:33:24.947]                 }
[10:33:24.947]                 {
[10:33:24.947]                   {
[10:33:24.947]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.947]                     NULL
[10:33:24.947]                   }
[10:33:24.947]                   options(future.plan = NULL)
[10:33:24.947]                   if (is.na(NA_character_)) 
[10:33:24.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.947]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.947]                     .init = FALSE)
[10:33:24.947]                 }
[10:33:24.947]             }
[10:33:24.947]         }
[10:33:24.947]     })
[10:33:24.947]     if (TRUE) {
[10:33:24.947]         base::sink(type = "output", split = FALSE)
[10:33:24.947]         if (TRUE) {
[10:33:24.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.947]         }
[10:33:24.947]         else {
[10:33:24.947]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.947]         }
[10:33:24.947]         base::close(...future.stdout)
[10:33:24.947]         ...future.stdout <- NULL
[10:33:24.947]     }
[10:33:24.947]     ...future.result$conditions <- ...future.conditions
[10:33:24.947]     ...future.result$finished <- base::Sys.time()
[10:33:24.947]     ...future.result
[10:33:24.947] }
[10:33:24.950] assign_globals() ...
[10:33:24.950] List of 1
[10:33:24.950]  $ ii: int 1
[10:33:24.950]  - attr(*, "where")=List of 1
[10:33:24.950]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.950]  - attr(*, "resolved")= logi FALSE
[10:33:24.950]  - attr(*, "total_size")= num 56
[10:33:24.952] - copied ‘ii’ to environment
[10:33:24.953] assign_globals() ... done
[10:33:24.953] requestCore(): workers = 2
[10:33:24.955] MulticoreFuture started
 - Creating multicore future #2 ...
[10:33:24.956] plan(): Setting new future strategy stack:
[10:33:24.956] List of future strategies:
[10:33:24.956] 1. sequential:
[10:33:24.956]    - args: function (..., envir = parent.frame())
[10:33:24.956]    - tweaked: FALSE
[10:33:24.956]    - call: NULL
[10:33:24.957] plan(): nbrOfWorkers() = 1
[10:33:24.959] plan(): Setting new future strategy stack:
[10:33:24.959] List of future strategies:
[10:33:24.959] 1. multicore:
[10:33:24.959]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.959]    - tweaked: FALSE
[10:33:24.959]    - call: plan(multicore)
[10:33:24.960] getGlobalsAndPackages() ...
[10:33:24.960] Searching for globals...
[10:33:24.962] - globals found: [2] ‘{’, ‘ii’
[10:33:24.962] Searching for globals ... DONE
[10:33:24.962] Resolving globals: FALSE
[10:33:24.963] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.963] plan(): nbrOfWorkers() = 2
[10:33:24.963] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.963] - globals: [1] ‘ii’
[10:33:24.964] 
[10:33:24.964] getGlobalsAndPackages() ... DONE
[10:33:24.964] Packages needed by the future expression (n = 0): <none>
[10:33:24.965] Packages needed by future strategies (n = 0): <none>
[10:33:24.965] {
[10:33:24.965]     {
[10:33:24.965]         {
[10:33:24.965]             ...future.startTime <- base::Sys.time()
[10:33:24.965]             {
[10:33:24.965]                 {
[10:33:24.965]                   {
[10:33:24.965]                     {
[10:33:24.965]                       base::local({
[10:33:24.965]                         has_future <- base::requireNamespace("future", 
[10:33:24.965]                           quietly = TRUE)
[10:33:24.965]                         if (has_future) {
[10:33:24.965]                           ns <- base::getNamespace("future")
[10:33:24.965]                           version <- ns[[".package"]][["version"]]
[10:33:24.965]                           if (is.null(version)) 
[10:33:24.965]                             version <- utils::packageVersion("future")
[10:33:24.965]                         }
[10:33:24.965]                         else {
[10:33:24.965]                           version <- NULL
[10:33:24.965]                         }
[10:33:24.965]                         if (!has_future || version < "1.8.0") {
[10:33:24.965]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.965]                             "", base::R.version$version.string), 
[10:33:24.965]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.965]                               "release", "version")], collapse = " "), 
[10:33:24.965]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.965]                             info)
[10:33:24.965]                           info <- base::paste(info, collapse = "; ")
[10:33:24.965]                           if (!has_future) {
[10:33:24.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.965]                               info)
[10:33:24.965]                           }
[10:33:24.965]                           else {
[10:33:24.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.965]                               info, version)
[10:33:24.965]                           }
[10:33:24.965]                           base::stop(msg)
[10:33:24.965]                         }
[10:33:24.965]                       })
[10:33:24.965]                     }
[10:33:24.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.965]                     base::options(mc.cores = 1L)
[10:33:24.965]                   }
[10:33:24.965]                   ...future.strategy.old <- future::plan("list")
[10:33:24.965]                   options(future.plan = NULL)
[10:33:24.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.965]                 }
[10:33:24.965]                 ...future.workdir <- getwd()
[10:33:24.965]             }
[10:33:24.965]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.965]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.965]         }
[10:33:24.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.965]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.965]             base::names(...future.oldOptions))
[10:33:24.965]     }
[10:33:24.965]     if (FALSE) {
[10:33:24.965]     }
[10:33:24.965]     else {
[10:33:24.965]         if (TRUE) {
[10:33:24.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.965]                 open = "w")
[10:33:24.965]         }
[10:33:24.965]         else {
[10:33:24.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.965]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.965]         }
[10:33:24.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.965]             base::sink(type = "output", split = FALSE)
[10:33:24.965]             base::close(...future.stdout)
[10:33:24.965]         }, add = TRUE)
[10:33:24.965]     }
[10:33:24.965]     ...future.frame <- base::sys.nframe()
[10:33:24.965]     ...future.conditions <- base::list()
[10:33:24.965]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.965]     if (FALSE) {
[10:33:24.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.965]     }
[10:33:24.965]     ...future.result <- base::tryCatch({
[10:33:24.965]         base::withCallingHandlers({
[10:33:24.965]             ...future.value <- base::withVisible(base::local({
[10:33:24.965]                 withCallingHandlers({
[10:33:24.965]                   {
[10:33:24.965]                     ii
[10:33:24.965]                   }
[10:33:24.965]                 }, immediateCondition = function(cond) {
[10:33:24.965]                   save_rds <- function (object, pathname, ...) 
[10:33:24.965]                   {
[10:33:24.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.965]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.965]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.965]                         fi_tmp[["mtime"]])
[10:33:24.965]                     }
[10:33:24.965]                     tryCatch({
[10:33:24.965]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.965]                     }, error = function(ex) {
[10:33:24.965]                       msg <- conditionMessage(ex)
[10:33:24.965]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.965]                         fi_tmp[["mtime"]], msg)
[10:33:24.965]                       ex$message <- msg
[10:33:24.965]                       stop(ex)
[10:33:24.965]                     })
[10:33:24.965]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.965]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.965]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.965]                       fi <- file.info(pathname)
[10:33:24.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.965]                         fi[["size"]], fi[["mtime"]])
[10:33:24.965]                       stop(msg)
[10:33:24.965]                     }
[10:33:24.965]                     invisible(pathname)
[10:33:24.965]                   }
[10:33:24.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.965]                     rootPath = tempdir()) 
[10:33:24.965]                   {
[10:33:24.965]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.965]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.965]                       tmpdir = path, fileext = ".rds")
[10:33:24.965]                     save_rds(obj, file)
[10:33:24.965]                   }
[10:33:24.965]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.965]                   {
[10:33:24.965]                     inherits <- base::inherits
[10:33:24.965]                     invokeRestart <- base::invokeRestart
[10:33:24.965]                     is.null <- base::is.null
[10:33:24.965]                     muffled <- FALSE
[10:33:24.965]                     if (inherits(cond, "message")) {
[10:33:24.965]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.965]                       if (muffled) 
[10:33:24.965]                         invokeRestart("muffleMessage")
[10:33:24.965]                     }
[10:33:24.965]                     else if (inherits(cond, "warning")) {
[10:33:24.965]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.965]                       if (muffled) 
[10:33:24.965]                         invokeRestart("muffleWarning")
[10:33:24.965]                     }
[10:33:24.965]                     else if (inherits(cond, "condition")) {
[10:33:24.965]                       if (!is.null(pattern)) {
[10:33:24.965]                         computeRestarts <- base::computeRestarts
[10:33:24.965]                         grepl <- base::grepl
[10:33:24.965]                         restarts <- computeRestarts(cond)
[10:33:24.965]                         for (restart in restarts) {
[10:33:24.965]                           name <- restart$name
[10:33:24.965]                           if (is.null(name)) 
[10:33:24.965]                             next
[10:33:24.965]                           if (!grepl(pattern, name)) 
[10:33:24.965]                             next
[10:33:24.965]                           invokeRestart(restart)
[10:33:24.965]                           muffled <- TRUE
[10:33:24.965]                           break
[10:33:24.965]                         }
[10:33:24.965]                       }
[10:33:24.965]                     }
[10:33:24.965]                     invisible(muffled)
[10:33:24.965]                   }
[10:33:24.965]                   muffleCondition(cond)
[10:33:24.965]                 })
[10:33:24.965]             }))
[10:33:24.965]             future::FutureResult(value = ...future.value$value, 
[10:33:24.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.965]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.965]                     ...future.globalenv.names))
[10:33:24.965]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.965]         }, condition = base::local({
[10:33:24.965]             c <- base::c
[10:33:24.965]             inherits <- base::inherits
[10:33:24.965]             invokeRestart <- base::invokeRestart
[10:33:24.965]             length <- base::length
[10:33:24.965]             list <- base::list
[10:33:24.965]             seq.int <- base::seq.int
[10:33:24.965]             signalCondition <- base::signalCondition
[10:33:24.965]             sys.calls <- base::sys.calls
[10:33:24.965]             `[[` <- base::`[[`
[10:33:24.965]             `+` <- base::`+`
[10:33:24.965]             `<<-` <- base::`<<-`
[10:33:24.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.965]                   3L)]
[10:33:24.965]             }
[10:33:24.965]             function(cond) {
[10:33:24.965]                 is_error <- inherits(cond, "error")
[10:33:24.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.965]                   NULL)
[10:33:24.965]                 if (is_error) {
[10:33:24.965]                   sessionInformation <- function() {
[10:33:24.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.965]                       search = base::search(), system = base::Sys.info())
[10:33:24.965]                   }
[10:33:24.965]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.965]                     cond$call), session = sessionInformation(), 
[10:33:24.965]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.965]                   signalCondition(cond)
[10:33:24.965]                 }
[10:33:24.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.965]                 "immediateCondition"))) {
[10:33:24.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.965]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.965]                   if (TRUE && !signal) {
[10:33:24.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.965]                     {
[10:33:24.965]                       inherits <- base::inherits
[10:33:24.965]                       invokeRestart <- base::invokeRestart
[10:33:24.965]                       is.null <- base::is.null
[10:33:24.965]                       muffled <- FALSE
[10:33:24.965]                       if (inherits(cond, "message")) {
[10:33:24.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.965]                         if (muffled) 
[10:33:24.965]                           invokeRestart("muffleMessage")
[10:33:24.965]                       }
[10:33:24.965]                       else if (inherits(cond, "warning")) {
[10:33:24.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.965]                         if (muffled) 
[10:33:24.965]                           invokeRestart("muffleWarning")
[10:33:24.965]                       }
[10:33:24.965]                       else if (inherits(cond, "condition")) {
[10:33:24.965]                         if (!is.null(pattern)) {
[10:33:24.965]                           computeRestarts <- base::computeRestarts
[10:33:24.965]                           grepl <- base::grepl
[10:33:24.965]                           restarts <- computeRestarts(cond)
[10:33:24.965]                           for (restart in restarts) {
[10:33:24.965]                             name <- restart$name
[10:33:24.965]                             if (is.null(name)) 
[10:33:24.965]                               next
[10:33:24.965]                             if (!grepl(pattern, name)) 
[10:33:24.965]                               next
[10:33:24.965]                             invokeRestart(restart)
[10:33:24.965]                             muffled <- TRUE
[10:33:24.965]                             break
[10:33:24.965]                           }
[10:33:24.965]                         }
[10:33:24.965]                       }
[10:33:24.965]                       invisible(muffled)
[10:33:24.965]                     }
[10:33:24.965]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.965]                   }
[10:33:24.965]                 }
[10:33:24.965]                 else {
[10:33:24.965]                   if (TRUE) {
[10:33:24.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.965]                     {
[10:33:24.965]                       inherits <- base::inherits
[10:33:24.965]                       invokeRestart <- base::invokeRestart
[10:33:24.965]                       is.null <- base::is.null
[10:33:24.965]                       muffled <- FALSE
[10:33:24.965]                       if (inherits(cond, "message")) {
[10:33:24.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.965]                         if (muffled) 
[10:33:24.965]                           invokeRestart("muffleMessage")
[10:33:24.965]                       }
[10:33:24.965]                       else if (inherits(cond, "warning")) {
[10:33:24.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.965]                         if (muffled) 
[10:33:24.965]                           invokeRestart("muffleWarning")
[10:33:24.965]                       }
[10:33:24.965]                       else if (inherits(cond, "condition")) {
[10:33:24.965]                         if (!is.null(pattern)) {
[10:33:24.965]                           computeRestarts <- base::computeRestarts
[10:33:24.965]                           grepl <- base::grepl
[10:33:24.965]                           restarts <- computeRestarts(cond)
[10:33:24.965]                           for (restart in restarts) {
[10:33:24.965]                             name <- restart$name
[10:33:24.965]                             if (is.null(name)) 
[10:33:24.965]                               next
[10:33:24.965]                             if (!grepl(pattern, name)) 
[10:33:24.965]                               next
[10:33:24.965]                             invokeRestart(restart)
[10:33:24.965]                             muffled <- TRUE
[10:33:24.965]                             break
[10:33:24.965]                           }
[10:33:24.965]                         }
[10:33:24.965]                       }
[10:33:24.965]                       invisible(muffled)
[10:33:24.965]                     }
[10:33:24.965]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.965]                   }
[10:33:24.965]                 }
[10:33:24.965]             }
[10:33:24.965]         }))
[10:33:24.965]     }, error = function(ex) {
[10:33:24.965]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.965]                 ...future.rng), started = ...future.startTime, 
[10:33:24.965]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.965]             version = "1.8"), class = "FutureResult")
[10:33:24.965]     }, finally = {
[10:33:24.965]         if (!identical(...future.workdir, getwd())) 
[10:33:24.965]             setwd(...future.workdir)
[10:33:24.965]         {
[10:33:24.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.965]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.965]             }
[10:33:24.965]             base::options(...future.oldOptions)
[10:33:24.965]             if (.Platform$OS.type == "windows") {
[10:33:24.965]                 old_names <- names(...future.oldEnvVars)
[10:33:24.965]                 envs <- base::Sys.getenv()
[10:33:24.965]                 names <- names(envs)
[10:33:24.965]                 common <- intersect(names, old_names)
[10:33:24.965]                 added <- setdiff(names, old_names)
[10:33:24.965]                 removed <- setdiff(old_names, names)
[10:33:24.965]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.965]                   envs[common]]
[10:33:24.965]                 NAMES <- toupper(changed)
[10:33:24.965]                 args <- list()
[10:33:24.965]                 for (kk in seq_along(NAMES)) {
[10:33:24.965]                   name <- changed[[kk]]
[10:33:24.965]                   NAME <- NAMES[[kk]]
[10:33:24.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.965]                     next
[10:33:24.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.965]                 }
[10:33:24.965]                 NAMES <- toupper(added)
[10:33:24.965]                 for (kk in seq_along(NAMES)) {
[10:33:24.965]                   name <- added[[kk]]
[10:33:24.965]                   NAME <- NAMES[[kk]]
[10:33:24.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.965]                     next
[10:33:24.965]                   args[[name]] <- ""
[10:33:24.965]                 }
[10:33:24.965]                 NAMES <- toupper(removed)
[10:33:24.965]                 for (kk in seq_along(NAMES)) {
[10:33:24.965]                   name <- removed[[kk]]
[10:33:24.965]                   NAME <- NAMES[[kk]]
[10:33:24.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.965]                     next
[10:33:24.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.965]                 }
[10:33:24.965]                 if (length(args) > 0) 
[10:33:24.965]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.965]             }
[10:33:24.965]             else {
[10:33:24.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.965]             }
[10:33:24.965]             {
[10:33:24.965]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.965]                   0L) {
[10:33:24.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.965]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.965]                   base::options(opts)
[10:33:24.965]                 }
[10:33:24.965]                 {
[10:33:24.965]                   {
[10:33:24.965]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.965]                     NULL
[10:33:24.965]                   }
[10:33:24.965]                   options(future.plan = NULL)
[10:33:24.965]                   if (is.na(NA_character_)) 
[10:33:24.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.965]                     .init = FALSE)
[10:33:24.965]                 }
[10:33:24.965]             }
[10:33:24.965]         }
[10:33:24.965]     })
[10:33:24.965]     if (TRUE) {
[10:33:24.965]         base::sink(type = "output", split = FALSE)
[10:33:24.965]         if (TRUE) {
[10:33:24.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.965]         }
[10:33:24.965]         else {
[10:33:24.965]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.965]         }
[10:33:24.965]         base::close(...future.stdout)
[10:33:24.965]         ...future.stdout <- NULL
[10:33:24.965]     }
[10:33:24.965]     ...future.result$conditions <- ...future.conditions
[10:33:24.965]     ...future.result$finished <- base::Sys.time()
[10:33:24.965]     ...future.result
[10:33:24.965] }
[10:33:24.969] assign_globals() ...
[10:33:24.969] List of 1
[10:33:24.969]  $ ii: int 2
[10:33:24.969]  - attr(*, "where")=List of 1
[10:33:24.969]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.969]  - attr(*, "resolved")= logi FALSE
[10:33:24.969]  - attr(*, "total_size")= num 56
[10:33:24.972] - copied ‘ii’ to environment
[10:33:24.972] assign_globals() ... done
[10:33:24.973] requestCore(): workers = 2
[10:33:24.975] MulticoreFuture started
 - Creating multicore future #3 ...
[10:33:24.976] plan(): Setting new future strategy stack:
[10:33:24.976] List of future strategies:
[10:33:24.976] 1. sequential:
[10:33:24.976]    - args: function (..., envir = parent.frame())
[10:33:24.976]    - tweaked: FALSE
[10:33:24.976]    - call: NULL
[10:33:24.977] plan(): nbrOfWorkers() = 1
[10:33:24.979] plan(): Setting new future strategy stack:
[10:33:24.979] List of future strategies:
[10:33:24.979] 1. multicore:
[10:33:24.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:24.979]    - tweaked: FALSE
[10:33:24.979]    - call: plan(multicore)
[10:33:24.980] getGlobalsAndPackages() ...
[10:33:24.981] Searching for globals...
[10:33:24.986] - globals found: [2] ‘{’, ‘ii’
[10:33:24.986] Searching for globals ... DONE
[10:33:24.986] Resolving globals: FALSE
[10:33:24.987] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:24.988] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:24.988] - globals: [1] ‘ii’
[10:33:24.988] 
[10:33:24.989] getGlobalsAndPackages() ... DONE
[10:33:24.989] plan(): nbrOfWorkers() = 2
[10:33:24.989] Packages needed by the future expression (n = 0): <none>
[10:33:24.990] Packages needed by future strategies (n = 0): <none>
[10:33:24.990] {
[10:33:24.990]     {
[10:33:24.990]         {
[10:33:24.990]             ...future.startTime <- base::Sys.time()
[10:33:24.990]             {
[10:33:24.990]                 {
[10:33:24.990]                   {
[10:33:24.990]                     {
[10:33:24.990]                       base::local({
[10:33:24.990]                         has_future <- base::requireNamespace("future", 
[10:33:24.990]                           quietly = TRUE)
[10:33:24.990]                         if (has_future) {
[10:33:24.990]                           ns <- base::getNamespace("future")
[10:33:24.990]                           version <- ns[[".package"]][["version"]]
[10:33:24.990]                           if (is.null(version)) 
[10:33:24.990]                             version <- utils::packageVersion("future")
[10:33:24.990]                         }
[10:33:24.990]                         else {
[10:33:24.990]                           version <- NULL
[10:33:24.990]                         }
[10:33:24.990]                         if (!has_future || version < "1.8.0") {
[10:33:24.990]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:24.990]                             "", base::R.version$version.string), 
[10:33:24.990]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:24.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:24.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:24.990]                               "release", "version")], collapse = " "), 
[10:33:24.990]                             hostname = base::Sys.info()[["nodename"]])
[10:33:24.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:24.990]                             info)
[10:33:24.990]                           info <- base::paste(info, collapse = "; ")
[10:33:24.990]                           if (!has_future) {
[10:33:24.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:24.990]                               info)
[10:33:24.990]                           }
[10:33:24.990]                           else {
[10:33:24.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:24.990]                               info, version)
[10:33:24.990]                           }
[10:33:24.990]                           base::stop(msg)
[10:33:24.990]                         }
[10:33:24.990]                       })
[10:33:24.990]                     }
[10:33:24.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:24.990]                     base::options(mc.cores = 1L)
[10:33:24.990]                   }
[10:33:24.990]                   ...future.strategy.old <- future::plan("list")
[10:33:24.990]                   options(future.plan = NULL)
[10:33:24.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:24.990]                 }
[10:33:24.990]                 ...future.workdir <- getwd()
[10:33:24.990]             }
[10:33:24.990]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:24.990]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:24.990]         }
[10:33:24.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:24.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:24.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:24.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:24.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:24.990]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:24.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:24.990]             base::names(...future.oldOptions))
[10:33:24.990]     }
[10:33:24.990]     if (FALSE) {
[10:33:24.990]     }
[10:33:24.990]     else {
[10:33:24.990]         if (TRUE) {
[10:33:24.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:24.990]                 open = "w")
[10:33:24.990]         }
[10:33:24.990]         else {
[10:33:24.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:24.990]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:24.990]         }
[10:33:24.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:24.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:24.990]             base::sink(type = "output", split = FALSE)
[10:33:24.990]             base::close(...future.stdout)
[10:33:24.990]         }, add = TRUE)
[10:33:24.990]     }
[10:33:24.990]     ...future.frame <- base::sys.nframe()
[10:33:24.990]     ...future.conditions <- base::list()
[10:33:24.990]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:24.990]     if (FALSE) {
[10:33:24.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:24.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:24.990]     }
[10:33:24.990]     ...future.result <- base::tryCatch({
[10:33:24.990]         base::withCallingHandlers({
[10:33:24.990]             ...future.value <- base::withVisible(base::local({
[10:33:24.990]                 withCallingHandlers({
[10:33:24.990]                   {
[10:33:24.990]                     ii
[10:33:24.990]                   }
[10:33:24.990]                 }, immediateCondition = function(cond) {
[10:33:24.990]                   save_rds <- function (object, pathname, ...) 
[10:33:24.990]                   {
[10:33:24.990]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:24.990]                     if (file_test("-f", pathname_tmp)) {
[10:33:24.990]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.990]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:24.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.990]                         fi_tmp[["mtime"]])
[10:33:24.990]                     }
[10:33:24.990]                     tryCatch({
[10:33:24.990]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:24.990]                     }, error = function(ex) {
[10:33:24.990]                       msg <- conditionMessage(ex)
[10:33:24.990]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.990]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:24.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.990]                         fi_tmp[["mtime"]], msg)
[10:33:24.990]                       ex$message <- msg
[10:33:24.990]                       stop(ex)
[10:33:24.990]                     })
[10:33:24.990]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:24.990]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:24.990]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:24.990]                       fi_tmp <- file.info(pathname_tmp)
[10:33:24.990]                       fi <- file.info(pathname)
[10:33:24.990]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:24.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:24.990]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:24.990]                         fi[["size"]], fi[["mtime"]])
[10:33:24.990]                       stop(msg)
[10:33:24.990]                     }
[10:33:24.990]                     invisible(pathname)
[10:33:24.990]                   }
[10:33:24.990]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:24.990]                     rootPath = tempdir()) 
[10:33:24.990]                   {
[10:33:24.990]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:24.990]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:24.990]                       tmpdir = path, fileext = ".rds")
[10:33:24.990]                     save_rds(obj, file)
[10:33:24.990]                   }
[10:33:24.990]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:24.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.990]                   {
[10:33:24.990]                     inherits <- base::inherits
[10:33:24.990]                     invokeRestart <- base::invokeRestart
[10:33:24.990]                     is.null <- base::is.null
[10:33:24.990]                     muffled <- FALSE
[10:33:24.990]                     if (inherits(cond, "message")) {
[10:33:24.990]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:24.990]                       if (muffled) 
[10:33:24.990]                         invokeRestart("muffleMessage")
[10:33:24.990]                     }
[10:33:24.990]                     else if (inherits(cond, "warning")) {
[10:33:24.990]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:24.990]                       if (muffled) 
[10:33:24.990]                         invokeRestart("muffleWarning")
[10:33:24.990]                     }
[10:33:24.990]                     else if (inherits(cond, "condition")) {
[10:33:24.990]                       if (!is.null(pattern)) {
[10:33:24.990]                         computeRestarts <- base::computeRestarts
[10:33:24.990]                         grepl <- base::grepl
[10:33:24.990]                         restarts <- computeRestarts(cond)
[10:33:24.990]                         for (restart in restarts) {
[10:33:24.990]                           name <- restart$name
[10:33:24.990]                           if (is.null(name)) 
[10:33:24.990]                             next
[10:33:24.990]                           if (!grepl(pattern, name)) 
[10:33:24.990]                             next
[10:33:24.990]                           invokeRestart(restart)
[10:33:24.990]                           muffled <- TRUE
[10:33:24.990]                           break
[10:33:24.990]                         }
[10:33:24.990]                       }
[10:33:24.990]                     }
[10:33:24.990]                     invisible(muffled)
[10:33:24.990]                   }
[10:33:24.990]                   muffleCondition(cond)
[10:33:24.990]                 })
[10:33:24.990]             }))
[10:33:24.990]             future::FutureResult(value = ...future.value$value, 
[10:33:24.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.990]                   ...future.rng), globalenv = if (FALSE) 
[10:33:24.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:24.990]                     ...future.globalenv.names))
[10:33:24.990]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:24.990]         }, condition = base::local({
[10:33:24.990]             c <- base::c
[10:33:24.990]             inherits <- base::inherits
[10:33:24.990]             invokeRestart <- base::invokeRestart
[10:33:24.990]             length <- base::length
[10:33:24.990]             list <- base::list
[10:33:24.990]             seq.int <- base::seq.int
[10:33:24.990]             signalCondition <- base::signalCondition
[10:33:24.990]             sys.calls <- base::sys.calls
[10:33:24.990]             `[[` <- base::`[[`
[10:33:24.990]             `+` <- base::`+`
[10:33:24.990]             `<<-` <- base::`<<-`
[10:33:24.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:24.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:24.990]                   3L)]
[10:33:24.990]             }
[10:33:24.990]             function(cond) {
[10:33:24.990]                 is_error <- inherits(cond, "error")
[10:33:24.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:24.990]                   NULL)
[10:33:24.990]                 if (is_error) {
[10:33:24.990]                   sessionInformation <- function() {
[10:33:24.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:24.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:24.990]                       search = base::search(), system = base::Sys.info())
[10:33:24.990]                   }
[10:33:24.990]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:24.990]                     cond$call), session = sessionInformation(), 
[10:33:24.990]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:24.990]                   signalCondition(cond)
[10:33:24.990]                 }
[10:33:24.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:24.990]                 "immediateCondition"))) {
[10:33:24.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:24.990]                   ...future.conditions[[length(...future.conditions) + 
[10:33:24.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:24.990]                   if (TRUE && !signal) {
[10:33:24.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.990]                     {
[10:33:24.990]                       inherits <- base::inherits
[10:33:24.990]                       invokeRestart <- base::invokeRestart
[10:33:24.990]                       is.null <- base::is.null
[10:33:24.990]                       muffled <- FALSE
[10:33:24.990]                       if (inherits(cond, "message")) {
[10:33:24.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.990]                         if (muffled) 
[10:33:24.990]                           invokeRestart("muffleMessage")
[10:33:24.990]                       }
[10:33:24.990]                       else if (inherits(cond, "warning")) {
[10:33:24.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.990]                         if (muffled) 
[10:33:24.990]                           invokeRestart("muffleWarning")
[10:33:24.990]                       }
[10:33:24.990]                       else if (inherits(cond, "condition")) {
[10:33:24.990]                         if (!is.null(pattern)) {
[10:33:24.990]                           computeRestarts <- base::computeRestarts
[10:33:24.990]                           grepl <- base::grepl
[10:33:24.990]                           restarts <- computeRestarts(cond)
[10:33:24.990]                           for (restart in restarts) {
[10:33:24.990]                             name <- restart$name
[10:33:24.990]                             if (is.null(name)) 
[10:33:24.990]                               next
[10:33:24.990]                             if (!grepl(pattern, name)) 
[10:33:24.990]                               next
[10:33:24.990]                             invokeRestart(restart)
[10:33:24.990]                             muffled <- TRUE
[10:33:24.990]                             break
[10:33:24.990]                           }
[10:33:24.990]                         }
[10:33:24.990]                       }
[10:33:24.990]                       invisible(muffled)
[10:33:24.990]                     }
[10:33:24.990]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.990]                   }
[10:33:24.990]                 }
[10:33:24.990]                 else {
[10:33:24.990]                   if (TRUE) {
[10:33:24.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:24.990]                     {
[10:33:24.990]                       inherits <- base::inherits
[10:33:24.990]                       invokeRestart <- base::invokeRestart
[10:33:24.990]                       is.null <- base::is.null
[10:33:24.990]                       muffled <- FALSE
[10:33:24.990]                       if (inherits(cond, "message")) {
[10:33:24.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:24.990]                         if (muffled) 
[10:33:24.990]                           invokeRestart("muffleMessage")
[10:33:24.990]                       }
[10:33:24.990]                       else if (inherits(cond, "warning")) {
[10:33:24.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:24.990]                         if (muffled) 
[10:33:24.990]                           invokeRestart("muffleWarning")
[10:33:24.990]                       }
[10:33:24.990]                       else if (inherits(cond, "condition")) {
[10:33:24.990]                         if (!is.null(pattern)) {
[10:33:24.990]                           computeRestarts <- base::computeRestarts
[10:33:24.990]                           grepl <- base::grepl
[10:33:24.990]                           restarts <- computeRestarts(cond)
[10:33:24.990]                           for (restart in restarts) {
[10:33:24.990]                             name <- restart$name
[10:33:24.990]                             if (is.null(name)) 
[10:33:24.990]                               next
[10:33:24.990]                             if (!grepl(pattern, name)) 
[10:33:24.990]                               next
[10:33:24.990]                             invokeRestart(restart)
[10:33:24.990]                             muffled <- TRUE
[10:33:24.990]                             break
[10:33:24.990]                           }
[10:33:24.990]                         }
[10:33:24.990]                       }
[10:33:24.990]                       invisible(muffled)
[10:33:24.990]                     }
[10:33:24.990]                     muffleCondition(cond, pattern = "^muffle")
[10:33:24.990]                   }
[10:33:24.990]                 }
[10:33:24.990]             }
[10:33:24.990]         }))
[10:33:24.990]     }, error = function(ex) {
[10:33:24.990]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:24.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:24.990]                 ...future.rng), started = ...future.startTime, 
[10:33:24.990]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:24.990]             version = "1.8"), class = "FutureResult")
[10:33:24.990]     }, finally = {
[10:33:24.990]         if (!identical(...future.workdir, getwd())) 
[10:33:24.990]             setwd(...future.workdir)
[10:33:24.990]         {
[10:33:24.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:24.990]                 ...future.oldOptions$nwarnings <- NULL
[10:33:24.990]             }
[10:33:24.990]             base::options(...future.oldOptions)
[10:33:24.990]             if (.Platform$OS.type == "windows") {
[10:33:24.990]                 old_names <- names(...future.oldEnvVars)
[10:33:24.990]                 envs <- base::Sys.getenv()
[10:33:24.990]                 names <- names(envs)
[10:33:24.990]                 common <- intersect(names, old_names)
[10:33:24.990]                 added <- setdiff(names, old_names)
[10:33:24.990]                 removed <- setdiff(old_names, names)
[10:33:24.990]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:24.990]                   envs[common]]
[10:33:24.990]                 NAMES <- toupper(changed)
[10:33:24.990]                 args <- list()
[10:33:24.990]                 for (kk in seq_along(NAMES)) {
[10:33:24.990]                   name <- changed[[kk]]
[10:33:24.990]                   NAME <- NAMES[[kk]]
[10:33:24.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.990]                     next
[10:33:24.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.990]                 }
[10:33:24.990]                 NAMES <- toupper(added)
[10:33:24.990]                 for (kk in seq_along(NAMES)) {
[10:33:24.990]                   name <- added[[kk]]
[10:33:24.990]                   NAME <- NAMES[[kk]]
[10:33:24.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.990]                     next
[10:33:24.990]                   args[[name]] <- ""
[10:33:24.990]                 }
[10:33:24.990]                 NAMES <- toupper(removed)
[10:33:24.990]                 for (kk in seq_along(NAMES)) {
[10:33:24.990]                   name <- removed[[kk]]
[10:33:24.990]                   NAME <- NAMES[[kk]]
[10:33:24.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:24.990]                     next
[10:33:24.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:24.990]                 }
[10:33:24.990]                 if (length(args) > 0) 
[10:33:24.990]                   base::do.call(base::Sys.setenv, args = args)
[10:33:24.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:24.990]             }
[10:33:24.990]             else {
[10:33:24.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:24.990]             }
[10:33:24.990]             {
[10:33:24.990]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:24.990]                   0L) {
[10:33:24.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:24.990]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:24.990]                   base::options(opts)
[10:33:24.990]                 }
[10:33:24.990]                 {
[10:33:24.990]                   {
[10:33:24.990]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:24.990]                     NULL
[10:33:24.990]                   }
[10:33:24.990]                   options(future.plan = NULL)
[10:33:24.990]                   if (is.na(NA_character_)) 
[10:33:24.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:24.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:24.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:24.990]                     .init = FALSE)
[10:33:24.990]                 }
[10:33:24.990]             }
[10:33:24.990]         }
[10:33:24.990]     })
[10:33:24.990]     if (TRUE) {
[10:33:24.990]         base::sink(type = "output", split = FALSE)
[10:33:24.990]         if (TRUE) {
[10:33:24.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:24.990]         }
[10:33:24.990]         else {
[10:33:24.990]             ...future.result["stdout"] <- base::list(NULL)
[10:33:24.990]         }
[10:33:24.990]         base::close(...future.stdout)
[10:33:24.990]         ...future.stdout <- NULL
[10:33:24.990]     }
[10:33:24.990]     ...future.result$conditions <- ...future.conditions
[10:33:24.990]     ...future.result$finished <- base::Sys.time()
[10:33:24.990]     ...future.result
[10:33:24.990] }
[10:33:24.993] assign_globals() ...
[10:33:24.993] List of 1
[10:33:24.993]  $ ii: int 3
[10:33:24.993]  - attr(*, "where")=List of 1
[10:33:24.993]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:24.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:24.993]  - attr(*, "resolved")= logi FALSE
[10:33:24.993]  - attr(*, "total_size")= num 56
[10:33:24.997] - copied ‘ii’ to environment
[10:33:24.997] assign_globals() ... done
[10:33:24.997] requestCore(): workers = 2
[10:33:24.998] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:25.008] result() for MulticoreFuture ...
[10:33:25.009] result() for MulticoreFuture ...
[10:33:25.009] result() for MulticoreFuture ... done
[10:33:25.009] result() for MulticoreFuture ... done
[10:33:25.010] result() for MulticoreFuture ...
[10:33:25.010] result() for MulticoreFuture ... done
[10:33:25.012] MulticoreFuture started
 - Creating multicore future #4 ...
[10:33:25.013] plan(): Setting new future strategy stack:
[10:33:25.014] List of future strategies:
[10:33:25.014] 1. sequential:
[10:33:25.014]    - args: function (..., envir = parent.frame())
[10:33:25.014]    - tweaked: FALSE
[10:33:25.014]    - call: NULL
[10:33:25.015] plan(): nbrOfWorkers() = 1
[10:33:25.017] plan(): Setting new future strategy stack:
[10:33:25.017] List of future strategies:
[10:33:25.017] 1. multicore:
[10:33:25.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:25.017]    - tweaked: FALSE
[10:33:25.017]    - call: plan(multicore)
[10:33:25.019] getGlobalsAndPackages() ...
[10:33:25.020] Searching for globals...
[10:33:25.021] - globals found: [2] ‘{’, ‘ii’
[10:33:25.022] Searching for globals ... DONE
[10:33:25.022] Resolving globals: FALSE
[10:33:25.023] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:25.023] plan(): nbrOfWorkers() = 2
[10:33:25.024] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:33:25.024] - globals: [1] ‘ii’
[10:33:25.024] 
[10:33:25.024] getGlobalsAndPackages() ... DONE
[10:33:25.025] Packages needed by the future expression (n = 0): <none>
[10:33:25.025] Packages needed by future strategies (n = 0): <none>
[10:33:25.026] {
[10:33:25.026]     {
[10:33:25.026]         {
[10:33:25.026]             ...future.startTime <- base::Sys.time()
[10:33:25.026]             {
[10:33:25.026]                 {
[10:33:25.026]                   {
[10:33:25.026]                     {
[10:33:25.026]                       base::local({
[10:33:25.026]                         has_future <- base::requireNamespace("future", 
[10:33:25.026]                           quietly = TRUE)
[10:33:25.026]                         if (has_future) {
[10:33:25.026]                           ns <- base::getNamespace("future")
[10:33:25.026]                           version <- ns[[".package"]][["version"]]
[10:33:25.026]                           if (is.null(version)) 
[10:33:25.026]                             version <- utils::packageVersion("future")
[10:33:25.026]                         }
[10:33:25.026]                         else {
[10:33:25.026]                           version <- NULL
[10:33:25.026]                         }
[10:33:25.026]                         if (!has_future || version < "1.8.0") {
[10:33:25.026]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:25.026]                             "", base::R.version$version.string), 
[10:33:25.026]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:25.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:25.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:25.026]                               "release", "version")], collapse = " "), 
[10:33:25.026]                             hostname = base::Sys.info()[["nodename"]])
[10:33:25.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:25.026]                             info)
[10:33:25.026]                           info <- base::paste(info, collapse = "; ")
[10:33:25.026]                           if (!has_future) {
[10:33:25.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:25.026]                               info)
[10:33:25.026]                           }
[10:33:25.026]                           else {
[10:33:25.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:25.026]                               info, version)
[10:33:25.026]                           }
[10:33:25.026]                           base::stop(msg)
[10:33:25.026]                         }
[10:33:25.026]                       })
[10:33:25.026]                     }
[10:33:25.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:25.026]                     base::options(mc.cores = 1L)
[10:33:25.026]                   }
[10:33:25.026]                   ...future.strategy.old <- future::plan("list")
[10:33:25.026]                   options(future.plan = NULL)
[10:33:25.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:25.026]                 }
[10:33:25.026]                 ...future.workdir <- getwd()
[10:33:25.026]             }
[10:33:25.026]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:25.026]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:25.026]         }
[10:33:25.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:25.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:25.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:25.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:25.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:25.026]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:25.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:25.026]             base::names(...future.oldOptions))
[10:33:25.026]     }
[10:33:25.026]     if (FALSE) {
[10:33:25.026]     }
[10:33:25.026]     else {
[10:33:25.026]         if (TRUE) {
[10:33:25.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:25.026]                 open = "w")
[10:33:25.026]         }
[10:33:25.026]         else {
[10:33:25.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:25.026]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:25.026]         }
[10:33:25.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:25.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:25.026]             base::sink(type = "output", split = FALSE)
[10:33:25.026]             base::close(...future.stdout)
[10:33:25.026]         }, add = TRUE)
[10:33:25.026]     }
[10:33:25.026]     ...future.frame <- base::sys.nframe()
[10:33:25.026]     ...future.conditions <- base::list()
[10:33:25.026]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:25.026]     if (FALSE) {
[10:33:25.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:25.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:25.026]     }
[10:33:25.026]     ...future.result <- base::tryCatch({
[10:33:25.026]         base::withCallingHandlers({
[10:33:25.026]             ...future.value <- base::withVisible(base::local({
[10:33:25.026]                 withCallingHandlers({
[10:33:25.026]                   {
[10:33:25.026]                     ii
[10:33:25.026]                   }
[10:33:25.026]                 }, immediateCondition = function(cond) {
[10:33:25.026]                   save_rds <- function (object, pathname, ...) 
[10:33:25.026]                   {
[10:33:25.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:25.026]                     if (file_test("-f", pathname_tmp)) {
[10:33:25.026]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:25.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.026]                         fi_tmp[["mtime"]])
[10:33:25.026]                     }
[10:33:25.026]                     tryCatch({
[10:33:25.026]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:25.026]                     }, error = function(ex) {
[10:33:25.026]                       msg <- conditionMessage(ex)
[10:33:25.026]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:25.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.026]                         fi_tmp[["mtime"]], msg)
[10:33:25.026]                       ex$message <- msg
[10:33:25.026]                       stop(ex)
[10:33:25.026]                     })
[10:33:25.026]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:25.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:25.026]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:25.026]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.026]                       fi <- file.info(pathname)
[10:33:25.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:25.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:25.026]                         fi[["size"]], fi[["mtime"]])
[10:33:25.026]                       stop(msg)
[10:33:25.026]                     }
[10:33:25.026]                     invisible(pathname)
[10:33:25.026]                   }
[10:33:25.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:25.026]                     rootPath = tempdir()) 
[10:33:25.026]                   {
[10:33:25.026]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:25.026]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:25.026]                       tmpdir = path, fileext = ".rds")
[10:33:25.026]                     save_rds(obj, file)
[10:33:25.026]                   }
[10:33:25.026]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:25.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.026]                   {
[10:33:25.026]                     inherits <- base::inherits
[10:33:25.026]                     invokeRestart <- base::invokeRestart
[10:33:25.026]                     is.null <- base::is.null
[10:33:25.026]                     muffled <- FALSE
[10:33:25.026]                     if (inherits(cond, "message")) {
[10:33:25.026]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:25.026]                       if (muffled) 
[10:33:25.026]                         invokeRestart("muffleMessage")
[10:33:25.026]                     }
[10:33:25.026]                     else if (inherits(cond, "warning")) {
[10:33:25.026]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:25.026]                       if (muffled) 
[10:33:25.026]                         invokeRestart("muffleWarning")
[10:33:25.026]                     }
[10:33:25.026]                     else if (inherits(cond, "condition")) {
[10:33:25.026]                       if (!is.null(pattern)) {
[10:33:25.026]                         computeRestarts <- base::computeRestarts
[10:33:25.026]                         grepl <- base::grepl
[10:33:25.026]                         restarts <- computeRestarts(cond)
[10:33:25.026]                         for (restart in restarts) {
[10:33:25.026]                           name <- restart$name
[10:33:25.026]                           if (is.null(name)) 
[10:33:25.026]                             next
[10:33:25.026]                           if (!grepl(pattern, name)) 
[10:33:25.026]                             next
[10:33:25.026]                           invokeRestart(restart)
[10:33:25.026]                           muffled <- TRUE
[10:33:25.026]                           break
[10:33:25.026]                         }
[10:33:25.026]                       }
[10:33:25.026]                     }
[10:33:25.026]                     invisible(muffled)
[10:33:25.026]                   }
[10:33:25.026]                   muffleCondition(cond)
[10:33:25.026]                 })
[10:33:25.026]             }))
[10:33:25.026]             future::FutureResult(value = ...future.value$value, 
[10:33:25.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.026]                   ...future.rng), globalenv = if (FALSE) 
[10:33:25.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:25.026]                     ...future.globalenv.names))
[10:33:25.026]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:25.026]         }, condition = base::local({
[10:33:25.026]             c <- base::c
[10:33:25.026]             inherits <- base::inherits
[10:33:25.026]             invokeRestart <- base::invokeRestart
[10:33:25.026]             length <- base::length
[10:33:25.026]             list <- base::list
[10:33:25.026]             seq.int <- base::seq.int
[10:33:25.026]             signalCondition <- base::signalCondition
[10:33:25.026]             sys.calls <- base::sys.calls
[10:33:25.026]             `[[` <- base::`[[`
[10:33:25.026]             `+` <- base::`+`
[10:33:25.026]             `<<-` <- base::`<<-`
[10:33:25.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:25.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:25.026]                   3L)]
[10:33:25.026]             }
[10:33:25.026]             function(cond) {
[10:33:25.026]                 is_error <- inherits(cond, "error")
[10:33:25.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:25.026]                   NULL)
[10:33:25.026]                 if (is_error) {
[10:33:25.026]                   sessionInformation <- function() {
[10:33:25.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:25.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:25.026]                       search = base::search(), system = base::Sys.info())
[10:33:25.026]                   }
[10:33:25.026]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:25.026]                     cond$call), session = sessionInformation(), 
[10:33:25.026]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:25.026]                   signalCondition(cond)
[10:33:25.026]                 }
[10:33:25.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:25.026]                 "immediateCondition"))) {
[10:33:25.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:25.026]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:25.026]                   if (TRUE && !signal) {
[10:33:25.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.026]                     {
[10:33:25.026]                       inherits <- base::inherits
[10:33:25.026]                       invokeRestart <- base::invokeRestart
[10:33:25.026]                       is.null <- base::is.null
[10:33:25.026]                       muffled <- FALSE
[10:33:25.026]                       if (inherits(cond, "message")) {
[10:33:25.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.026]                         if (muffled) 
[10:33:25.026]                           invokeRestart("muffleMessage")
[10:33:25.026]                       }
[10:33:25.026]                       else if (inherits(cond, "warning")) {
[10:33:25.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.026]                         if (muffled) 
[10:33:25.026]                           invokeRestart("muffleWarning")
[10:33:25.026]                       }
[10:33:25.026]                       else if (inherits(cond, "condition")) {
[10:33:25.026]                         if (!is.null(pattern)) {
[10:33:25.026]                           computeRestarts <- base::computeRestarts
[10:33:25.026]                           grepl <- base::grepl
[10:33:25.026]                           restarts <- computeRestarts(cond)
[10:33:25.026]                           for (restart in restarts) {
[10:33:25.026]                             name <- restart$name
[10:33:25.026]                             if (is.null(name)) 
[10:33:25.026]                               next
[10:33:25.026]                             if (!grepl(pattern, name)) 
[10:33:25.026]                               next
[10:33:25.026]                             invokeRestart(restart)
[10:33:25.026]                             muffled <- TRUE
[10:33:25.026]                             break
[10:33:25.026]                           }
[10:33:25.026]                         }
[10:33:25.026]                       }
[10:33:25.026]                       invisible(muffled)
[10:33:25.026]                     }
[10:33:25.026]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.026]                   }
[10:33:25.026]                 }
[10:33:25.026]                 else {
[10:33:25.026]                   if (TRUE) {
[10:33:25.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.026]                     {
[10:33:25.026]                       inherits <- base::inherits
[10:33:25.026]                       invokeRestart <- base::invokeRestart
[10:33:25.026]                       is.null <- base::is.null
[10:33:25.026]                       muffled <- FALSE
[10:33:25.026]                       if (inherits(cond, "message")) {
[10:33:25.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.026]                         if (muffled) 
[10:33:25.026]                           invokeRestart("muffleMessage")
[10:33:25.026]                       }
[10:33:25.026]                       else if (inherits(cond, "warning")) {
[10:33:25.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.026]                         if (muffled) 
[10:33:25.026]                           invokeRestart("muffleWarning")
[10:33:25.026]                       }
[10:33:25.026]                       else if (inherits(cond, "condition")) {
[10:33:25.026]                         if (!is.null(pattern)) {
[10:33:25.026]                           computeRestarts <- base::computeRestarts
[10:33:25.026]                           grepl <- base::grepl
[10:33:25.026]                           restarts <- computeRestarts(cond)
[10:33:25.026]                           for (restart in restarts) {
[10:33:25.026]                             name <- restart$name
[10:33:25.026]                             if (is.null(name)) 
[10:33:25.026]                               next
[10:33:25.026]                             if (!grepl(pattern, name)) 
[10:33:25.026]                               next
[10:33:25.026]                             invokeRestart(restart)
[10:33:25.026]                             muffled <- TRUE
[10:33:25.026]                             break
[10:33:25.026]                           }
[10:33:25.026]                         }
[10:33:25.026]                       }
[10:33:25.026]                       invisible(muffled)
[10:33:25.026]                     }
[10:33:25.026]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.026]                   }
[10:33:25.026]                 }
[10:33:25.026]             }
[10:33:25.026]         }))
[10:33:25.026]     }, error = function(ex) {
[10:33:25.026]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:25.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.026]                 ...future.rng), started = ...future.startTime, 
[10:33:25.026]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:25.026]             version = "1.8"), class = "FutureResult")
[10:33:25.026]     }, finally = {
[10:33:25.026]         if (!identical(...future.workdir, getwd())) 
[10:33:25.026]             setwd(...future.workdir)
[10:33:25.026]         {
[10:33:25.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:25.026]                 ...future.oldOptions$nwarnings <- NULL
[10:33:25.026]             }
[10:33:25.026]             base::options(...future.oldOptions)
[10:33:25.026]             if (.Platform$OS.type == "windows") {
[10:33:25.026]                 old_names <- names(...future.oldEnvVars)
[10:33:25.026]                 envs <- base::Sys.getenv()
[10:33:25.026]                 names <- names(envs)
[10:33:25.026]                 common <- intersect(names, old_names)
[10:33:25.026]                 added <- setdiff(names, old_names)
[10:33:25.026]                 removed <- setdiff(old_names, names)
[10:33:25.026]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:25.026]                   envs[common]]
[10:33:25.026]                 NAMES <- toupper(changed)
[10:33:25.026]                 args <- list()
[10:33:25.026]                 for (kk in seq_along(NAMES)) {
[10:33:25.026]                   name <- changed[[kk]]
[10:33:25.026]                   NAME <- NAMES[[kk]]
[10:33:25.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.026]                     next
[10:33:25.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.026]                 }
[10:33:25.026]                 NAMES <- toupper(added)
[10:33:25.026]                 for (kk in seq_along(NAMES)) {
[10:33:25.026]                   name <- added[[kk]]
[10:33:25.026]                   NAME <- NAMES[[kk]]
[10:33:25.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.026]                     next
[10:33:25.026]                   args[[name]] <- ""
[10:33:25.026]                 }
[10:33:25.026]                 NAMES <- toupper(removed)
[10:33:25.026]                 for (kk in seq_along(NAMES)) {
[10:33:25.026]                   name <- removed[[kk]]
[10:33:25.026]                   NAME <- NAMES[[kk]]
[10:33:25.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.026]                     next
[10:33:25.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.026]                 }
[10:33:25.026]                 if (length(args) > 0) 
[10:33:25.026]                   base::do.call(base::Sys.setenv, args = args)
[10:33:25.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:25.026]             }
[10:33:25.026]             else {
[10:33:25.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:25.026]             }
[10:33:25.026]             {
[10:33:25.026]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:25.026]                   0L) {
[10:33:25.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:25.026]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:25.026]                   base::options(opts)
[10:33:25.026]                 }
[10:33:25.026]                 {
[10:33:25.026]                   {
[10:33:25.026]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:25.026]                     NULL
[10:33:25.026]                   }
[10:33:25.026]                   options(future.plan = NULL)
[10:33:25.026]                   if (is.na(NA_character_)) 
[10:33:25.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:25.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:25.026]                     .init = FALSE)
[10:33:25.026]                 }
[10:33:25.026]             }
[10:33:25.026]         }
[10:33:25.026]     })
[10:33:25.026]     if (TRUE) {
[10:33:25.026]         base::sink(type = "output", split = FALSE)
[10:33:25.026]         if (TRUE) {
[10:33:25.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:25.026]         }
[10:33:25.026]         else {
[10:33:25.026]             ...future.result["stdout"] <- base::list(NULL)
[10:33:25.026]         }
[10:33:25.026]         base::close(...future.stdout)
[10:33:25.026]         ...future.stdout <- NULL
[10:33:25.026]     }
[10:33:25.026]     ...future.result$conditions <- ...future.conditions
[10:33:25.026]     ...future.result$finished <- base::Sys.time()
[10:33:25.026]     ...future.result
[10:33:25.026] }
[10:33:25.029] assign_globals() ...
[10:33:25.029] List of 1
[10:33:25.029]  $ ii: int 4
[10:33:25.029]  - attr(*, "where")=List of 1
[10:33:25.029]   ..$ ii:<environment: R_EmptyEnv> 
[10:33:25.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:25.029]  - attr(*, "resolved")= logi FALSE
[10:33:25.029]  - attr(*, "total_size")= num 56
[10:33:25.033] - copied ‘ii’ to environment
[10:33:25.033] assign_globals() ... done
[10:33:25.033] requestCore(): workers = 2
[10:33:25.034] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:25.044] result() for MulticoreFuture ...
[10:33:25.045] result() for MulticoreFuture ...
[10:33:25.045] result() for MulticoreFuture ... done
[10:33:25.045] result() for MulticoreFuture ... done
[10:33:25.046] result() for MulticoreFuture ...
[10:33:25.046] result() for MulticoreFuture ... done
[10:33:25.048] MulticoreFuture started
 - Resolving 4 multicore futures
[10:33:25.049] result() for MulticoreFuture ...
[10:33:25.049] result() for MulticoreFuture ... done
[10:33:25.049] plan(): Setting new future strategy stack:
[10:33:25.050] result() for MulticoreFuture ...
[10:33:25.050] result() for MulticoreFuture ... done
[10:33:25.050] result() for MulticoreFuture ...
[10:33:25.050] result() for MulticoreFuture ... done
[10:33:25.050] List of future strategies:
[10:33:25.050] 1. sequential:
[10:33:25.050]    - args: function (..., envir = parent.frame())
[10:33:25.050]    - tweaked: FALSE
[10:33:25.050]    - call: NULL
[10:33:25.051] result() for MulticoreFuture ...
[10:33:25.051] result() for MulticoreFuture ... done
[10:33:25.051] plan(): nbrOfWorkers() = 1
[10:33:25.051] result() for MulticoreFuture ...
[10:33:25.052] result() for MulticoreFuture ...
[10:33:25.053] result() for MulticoreFuture ... done
[10:33:25.053] result() for MulticoreFuture ... done
[10:33:25.053] result() for MulticoreFuture ...
[10:33:25.053] result() for MulticoreFuture ... done
[10:33:25.054] plan(): Setting new future strategy stack:
[10:33:25.054] result() for MulticoreFuture ...
[10:33:25.054] List of future strategies:
[10:33:25.054] 1. multicore:
[10:33:25.054]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:25.054]    - tweaked: FALSE
[10:33:25.054]    - call: plan(multicore)
[10:33:25.059] plan(): nbrOfWorkers() = 2
[10:33:25.059] result() for MulticoreFuture ...
[10:33:25.060] result() for MulticoreFuture ... done
[10:33:25.060] result() for MulticoreFuture ... done
[10:33:25.060] result() for MulticoreFuture ...
[10:33:25.060] result() for MulticoreFuture ... done
*** multicore(..., globals = TRUE) and errors
[10:33:25.065] getGlobalsAndPackages() ...
[10:33:25.065] Searching for globals...
[10:33:25.066] - globals found: [2] ‘{’, ‘stop’
[10:33:25.069] Searching for globals ... DONE
[10:33:25.070] Resolving globals: FALSE
[10:33:25.070] 
[10:33:25.070] 
[10:33:25.070] getGlobalsAndPackages() ... DONE
[10:33:25.071] Packages needed by the future expression (n = 0): <none>
[10:33:25.071] Packages needed by future strategies (n = 0): <none>
[10:33:25.072] {
[10:33:25.072]     {
[10:33:25.072]         {
[10:33:25.072]             ...future.startTime <- base::Sys.time()
[10:33:25.072]             {
[10:33:25.072]                 {
[10:33:25.072]                   {
[10:33:25.072]                     {
[10:33:25.072]                       base::local({
[10:33:25.072]                         has_future <- base::requireNamespace("future", 
[10:33:25.072]                           quietly = TRUE)
[10:33:25.072]                         if (has_future) {
[10:33:25.072]                           ns <- base::getNamespace("future")
[10:33:25.072]                           version <- ns[[".package"]][["version"]]
[10:33:25.072]                           if (is.null(version)) 
[10:33:25.072]                             version <- utils::packageVersion("future")
[10:33:25.072]                         }
[10:33:25.072]                         else {
[10:33:25.072]                           version <- NULL
[10:33:25.072]                         }
[10:33:25.072]                         if (!has_future || version < "1.8.0") {
[10:33:25.072]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:25.072]                             "", base::R.version$version.string), 
[10:33:25.072]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:25.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:25.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:25.072]                               "release", "version")], collapse = " "), 
[10:33:25.072]                             hostname = base::Sys.info()[["nodename"]])
[10:33:25.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:25.072]                             info)
[10:33:25.072]                           info <- base::paste(info, collapse = "; ")
[10:33:25.072]                           if (!has_future) {
[10:33:25.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:25.072]                               info)
[10:33:25.072]                           }
[10:33:25.072]                           else {
[10:33:25.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:25.072]                               info, version)
[10:33:25.072]                           }
[10:33:25.072]                           base::stop(msg)
[10:33:25.072]                         }
[10:33:25.072]                       })
[10:33:25.072]                     }
[10:33:25.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:25.072]                     base::options(mc.cores = 1L)
[10:33:25.072]                   }
[10:33:25.072]                   ...future.strategy.old <- future::plan("list")
[10:33:25.072]                   options(future.plan = NULL)
[10:33:25.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:25.072]                 }
[10:33:25.072]                 ...future.workdir <- getwd()
[10:33:25.072]             }
[10:33:25.072]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:25.072]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:25.072]         }
[10:33:25.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:25.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:25.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:25.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:25.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:25.072]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:25.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:25.072]             base::names(...future.oldOptions))
[10:33:25.072]     }
[10:33:25.072]     if (FALSE) {
[10:33:25.072]     }
[10:33:25.072]     else {
[10:33:25.072]         if (TRUE) {
[10:33:25.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:25.072]                 open = "w")
[10:33:25.072]         }
[10:33:25.072]         else {
[10:33:25.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:25.072]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:25.072]         }
[10:33:25.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:25.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:25.072]             base::sink(type = "output", split = FALSE)
[10:33:25.072]             base::close(...future.stdout)
[10:33:25.072]         }, add = TRUE)
[10:33:25.072]     }
[10:33:25.072]     ...future.frame <- base::sys.nframe()
[10:33:25.072]     ...future.conditions <- base::list()
[10:33:25.072]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:25.072]     if (FALSE) {
[10:33:25.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:25.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:25.072]     }
[10:33:25.072]     ...future.result <- base::tryCatch({
[10:33:25.072]         base::withCallingHandlers({
[10:33:25.072]             ...future.value <- base::withVisible(base::local({
[10:33:25.072]                 withCallingHandlers({
[10:33:25.072]                   {
[10:33:25.072]                     stop("Whoops!")
[10:33:25.072]                     1
[10:33:25.072]                   }
[10:33:25.072]                 }, immediateCondition = function(cond) {
[10:33:25.072]                   save_rds <- function (object, pathname, ...) 
[10:33:25.072]                   {
[10:33:25.072]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:25.072]                     if (file_test("-f", pathname_tmp)) {
[10:33:25.072]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.072]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:25.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.072]                         fi_tmp[["mtime"]])
[10:33:25.072]                     }
[10:33:25.072]                     tryCatch({
[10:33:25.072]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:25.072]                     }, error = function(ex) {
[10:33:25.072]                       msg <- conditionMessage(ex)
[10:33:25.072]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.072]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:25.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.072]                         fi_tmp[["mtime"]], msg)
[10:33:25.072]                       ex$message <- msg
[10:33:25.072]                       stop(ex)
[10:33:25.072]                     })
[10:33:25.072]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:25.072]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:25.072]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:25.072]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.072]                       fi <- file.info(pathname)
[10:33:25.072]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:25.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.072]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:25.072]                         fi[["size"]], fi[["mtime"]])
[10:33:25.072]                       stop(msg)
[10:33:25.072]                     }
[10:33:25.072]                     invisible(pathname)
[10:33:25.072]                   }
[10:33:25.072]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:25.072]                     rootPath = tempdir()) 
[10:33:25.072]                   {
[10:33:25.072]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:25.072]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:25.072]                       tmpdir = path, fileext = ".rds")
[10:33:25.072]                     save_rds(obj, file)
[10:33:25.072]                   }
[10:33:25.072]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:25.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.072]                   {
[10:33:25.072]                     inherits <- base::inherits
[10:33:25.072]                     invokeRestart <- base::invokeRestart
[10:33:25.072]                     is.null <- base::is.null
[10:33:25.072]                     muffled <- FALSE
[10:33:25.072]                     if (inherits(cond, "message")) {
[10:33:25.072]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:25.072]                       if (muffled) 
[10:33:25.072]                         invokeRestart("muffleMessage")
[10:33:25.072]                     }
[10:33:25.072]                     else if (inherits(cond, "warning")) {
[10:33:25.072]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:25.072]                       if (muffled) 
[10:33:25.072]                         invokeRestart("muffleWarning")
[10:33:25.072]                     }
[10:33:25.072]                     else if (inherits(cond, "condition")) {
[10:33:25.072]                       if (!is.null(pattern)) {
[10:33:25.072]                         computeRestarts <- base::computeRestarts
[10:33:25.072]                         grepl <- base::grepl
[10:33:25.072]                         restarts <- computeRestarts(cond)
[10:33:25.072]                         for (restart in restarts) {
[10:33:25.072]                           name <- restart$name
[10:33:25.072]                           if (is.null(name)) 
[10:33:25.072]                             next
[10:33:25.072]                           if (!grepl(pattern, name)) 
[10:33:25.072]                             next
[10:33:25.072]                           invokeRestart(restart)
[10:33:25.072]                           muffled <- TRUE
[10:33:25.072]                           break
[10:33:25.072]                         }
[10:33:25.072]                       }
[10:33:25.072]                     }
[10:33:25.072]                     invisible(muffled)
[10:33:25.072]                   }
[10:33:25.072]                   muffleCondition(cond)
[10:33:25.072]                 })
[10:33:25.072]             }))
[10:33:25.072]             future::FutureResult(value = ...future.value$value, 
[10:33:25.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.072]                   ...future.rng), globalenv = if (FALSE) 
[10:33:25.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:25.072]                     ...future.globalenv.names))
[10:33:25.072]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:25.072]         }, condition = base::local({
[10:33:25.072]             c <- base::c
[10:33:25.072]             inherits <- base::inherits
[10:33:25.072]             invokeRestart <- base::invokeRestart
[10:33:25.072]             length <- base::length
[10:33:25.072]             list <- base::list
[10:33:25.072]             seq.int <- base::seq.int
[10:33:25.072]             signalCondition <- base::signalCondition
[10:33:25.072]             sys.calls <- base::sys.calls
[10:33:25.072]             `[[` <- base::`[[`
[10:33:25.072]             `+` <- base::`+`
[10:33:25.072]             `<<-` <- base::`<<-`
[10:33:25.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:25.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:25.072]                   3L)]
[10:33:25.072]             }
[10:33:25.072]             function(cond) {
[10:33:25.072]                 is_error <- inherits(cond, "error")
[10:33:25.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:25.072]                   NULL)
[10:33:25.072]                 if (is_error) {
[10:33:25.072]                   sessionInformation <- function() {
[10:33:25.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:25.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:25.072]                       search = base::search(), system = base::Sys.info())
[10:33:25.072]                   }
[10:33:25.072]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:25.072]                     cond$call), session = sessionInformation(), 
[10:33:25.072]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:25.072]                   signalCondition(cond)
[10:33:25.072]                 }
[10:33:25.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:25.072]                 "immediateCondition"))) {
[10:33:25.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:25.072]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:25.072]                   if (TRUE && !signal) {
[10:33:25.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.072]                     {
[10:33:25.072]                       inherits <- base::inherits
[10:33:25.072]                       invokeRestart <- base::invokeRestart
[10:33:25.072]                       is.null <- base::is.null
[10:33:25.072]                       muffled <- FALSE
[10:33:25.072]                       if (inherits(cond, "message")) {
[10:33:25.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.072]                         if (muffled) 
[10:33:25.072]                           invokeRestart("muffleMessage")
[10:33:25.072]                       }
[10:33:25.072]                       else if (inherits(cond, "warning")) {
[10:33:25.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.072]                         if (muffled) 
[10:33:25.072]                           invokeRestart("muffleWarning")
[10:33:25.072]                       }
[10:33:25.072]                       else if (inherits(cond, "condition")) {
[10:33:25.072]                         if (!is.null(pattern)) {
[10:33:25.072]                           computeRestarts <- base::computeRestarts
[10:33:25.072]                           grepl <- base::grepl
[10:33:25.072]                           restarts <- computeRestarts(cond)
[10:33:25.072]                           for (restart in restarts) {
[10:33:25.072]                             name <- restart$name
[10:33:25.072]                             if (is.null(name)) 
[10:33:25.072]                               next
[10:33:25.072]                             if (!grepl(pattern, name)) 
[10:33:25.072]                               next
[10:33:25.072]                             invokeRestart(restart)
[10:33:25.072]                             muffled <- TRUE
[10:33:25.072]                             break
[10:33:25.072]                           }
[10:33:25.072]                         }
[10:33:25.072]                       }
[10:33:25.072]                       invisible(muffled)
[10:33:25.072]                     }
[10:33:25.072]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.072]                   }
[10:33:25.072]                 }
[10:33:25.072]                 else {
[10:33:25.072]                   if (TRUE) {
[10:33:25.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.072]                     {
[10:33:25.072]                       inherits <- base::inherits
[10:33:25.072]                       invokeRestart <- base::invokeRestart
[10:33:25.072]                       is.null <- base::is.null
[10:33:25.072]                       muffled <- FALSE
[10:33:25.072]                       if (inherits(cond, "message")) {
[10:33:25.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.072]                         if (muffled) 
[10:33:25.072]                           invokeRestart("muffleMessage")
[10:33:25.072]                       }
[10:33:25.072]                       else if (inherits(cond, "warning")) {
[10:33:25.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.072]                         if (muffled) 
[10:33:25.072]                           invokeRestart("muffleWarning")
[10:33:25.072]                       }
[10:33:25.072]                       else if (inherits(cond, "condition")) {
[10:33:25.072]                         if (!is.null(pattern)) {
[10:33:25.072]                           computeRestarts <- base::computeRestarts
[10:33:25.072]                           grepl <- base::grepl
[10:33:25.072]                           restarts <- computeRestarts(cond)
[10:33:25.072]                           for (restart in restarts) {
[10:33:25.072]                             name <- restart$name
[10:33:25.072]                             if (is.null(name)) 
[10:33:25.072]                               next
[10:33:25.072]                             if (!grepl(pattern, name)) 
[10:33:25.072]                               next
[10:33:25.072]                             invokeRestart(restart)
[10:33:25.072]                             muffled <- TRUE
[10:33:25.072]                             break
[10:33:25.072]                           }
[10:33:25.072]                         }
[10:33:25.072]                       }
[10:33:25.072]                       invisible(muffled)
[10:33:25.072]                     }
[10:33:25.072]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.072]                   }
[10:33:25.072]                 }
[10:33:25.072]             }
[10:33:25.072]         }))
[10:33:25.072]     }, error = function(ex) {
[10:33:25.072]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:25.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.072]                 ...future.rng), started = ...future.startTime, 
[10:33:25.072]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:25.072]             version = "1.8"), class = "FutureResult")
[10:33:25.072]     }, finally = {
[10:33:25.072]         if (!identical(...future.workdir, getwd())) 
[10:33:25.072]             setwd(...future.workdir)
[10:33:25.072]         {
[10:33:25.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:25.072]                 ...future.oldOptions$nwarnings <- NULL
[10:33:25.072]             }
[10:33:25.072]             base::options(...future.oldOptions)
[10:33:25.072]             if (.Platform$OS.type == "windows") {
[10:33:25.072]                 old_names <- names(...future.oldEnvVars)
[10:33:25.072]                 envs <- base::Sys.getenv()
[10:33:25.072]                 names <- names(envs)
[10:33:25.072]                 common <- intersect(names, old_names)
[10:33:25.072]                 added <- setdiff(names, old_names)
[10:33:25.072]                 removed <- setdiff(old_names, names)
[10:33:25.072]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:25.072]                   envs[common]]
[10:33:25.072]                 NAMES <- toupper(changed)
[10:33:25.072]                 args <- list()
[10:33:25.072]                 for (kk in seq_along(NAMES)) {
[10:33:25.072]                   name <- changed[[kk]]
[10:33:25.072]                   NAME <- NAMES[[kk]]
[10:33:25.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.072]                     next
[10:33:25.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.072]                 }
[10:33:25.072]                 NAMES <- toupper(added)
[10:33:25.072]                 for (kk in seq_along(NAMES)) {
[10:33:25.072]                   name <- added[[kk]]
[10:33:25.072]                   NAME <- NAMES[[kk]]
[10:33:25.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.072]                     next
[10:33:25.072]                   args[[name]] <- ""
[10:33:25.072]                 }
[10:33:25.072]                 NAMES <- toupper(removed)
[10:33:25.072]                 for (kk in seq_along(NAMES)) {
[10:33:25.072]                   name <- removed[[kk]]
[10:33:25.072]                   NAME <- NAMES[[kk]]
[10:33:25.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.072]                     next
[10:33:25.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.072]                 }
[10:33:25.072]                 if (length(args) > 0) 
[10:33:25.072]                   base::do.call(base::Sys.setenv, args = args)
[10:33:25.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:25.072]             }
[10:33:25.072]             else {
[10:33:25.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:25.072]             }
[10:33:25.072]             {
[10:33:25.072]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:25.072]                   0L) {
[10:33:25.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:25.072]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:25.072]                   base::options(opts)
[10:33:25.072]                 }
[10:33:25.072]                 {
[10:33:25.072]                   {
[10:33:25.072]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:25.072]                     NULL
[10:33:25.072]                   }
[10:33:25.072]                   options(future.plan = NULL)
[10:33:25.072]                   if (is.na(NA_character_)) 
[10:33:25.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:25.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:25.072]                     .init = FALSE)
[10:33:25.072]                 }
[10:33:25.072]             }
[10:33:25.072]         }
[10:33:25.072]     })
[10:33:25.072]     if (TRUE) {
[10:33:25.072]         base::sink(type = "output", split = FALSE)
[10:33:25.072]         if (TRUE) {
[10:33:25.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:25.072]         }
[10:33:25.072]         else {
[10:33:25.072]             ...future.result["stdout"] <- base::list(NULL)
[10:33:25.072]         }
[10:33:25.072]         base::close(...future.stdout)
[10:33:25.072]         ...future.stdout <- NULL
[10:33:25.072]     }
[10:33:25.072]     ...future.result$conditions <- ...future.conditions
[10:33:25.072]     ...future.result$finished <- base::Sys.time()
[10:33:25.072]     ...future.result
[10:33:25.072] }
[10:33:25.074] requestCore(): workers = 2
[10:33:25.076] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:33:25.078] plan(): Setting new future strategy stack:
[10:33:25.078] List of future strategies:
[10:33:25.078] 1. sequential:
[10:33:25.078]    - args: function (..., envir = parent.frame())
[10:33:25.078]    - tweaked: FALSE
[10:33:25.078]    - call: NULL
[10:33:25.079] plan(): nbrOfWorkers() = 1
[10:33:25.081] plan(): Setting new future strategy stack:
[10:33:25.081] List of future strategies:
[10:33:25.081] 1. multicore:
[10:33:25.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:25.081]    - tweaked: FALSE
[10:33:25.081]    - call: plan(multicore)
[10:33:25.086] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:25.088] result() for MulticoreFuture ...
[10:33:25.091] result() for MulticoreFuture ...
[10:33:25.091] result() for MulticoreFuture ... done
[10:33:25.092] signalConditions() ...
[10:33:25.092]  - include = ‘immediateCondition’
[10:33:25.092]  - exclude = 
[10:33:25.092]  - resignal = FALSE
[10:33:25.092]  - Number of conditions: 1
[10:33:25.092] signalConditions() ... done
[10:33:25.092] result() for MulticoreFuture ... done
[10:33:25.092] result() for MulticoreFuture ...
[10:33:25.093] result() for MulticoreFuture ... done
[10:33:25.093] signalConditions() ...
[10:33:25.093]  - include = ‘immediateCondition’
[10:33:25.093]  - exclude = 
[10:33:25.093]  - resignal = FALSE
[10:33:25.093]  - Number of conditions: 1
[10:33:25.093] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:33:25.094] result() for MulticoreFuture ...
[10:33:25.094] result() for MulticoreFuture ... done
[10:33:25.094] result() for MulticoreFuture ...
[10:33:25.095] result() for MulticoreFuture ... done
[10:33:25.095] signalConditions() ...
[10:33:25.095]  - include = ‘immediateCondition’
[10:33:25.095]  - exclude = 
[10:33:25.095]  - resignal = FALSE
[10:33:25.095]  - Number of conditions: 1
[10:33:25.095] signalConditions() ... done
[10:33:25.095] Future state: ‘finished’
[10:33:25.095] result() for MulticoreFuture ...
[10:33:25.096] result() for MulticoreFuture ... done
[10:33:25.096] signalConditions() ...
[10:33:25.096]  - include = ‘condition’
[10:33:25.096]  - exclude = ‘immediateCondition’
[10:33:25.096]  - resignal = TRUE
[10:33:25.096]  - Number of conditions: 1
[10:33:25.096]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:25.097] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:33:25.098] result() for MulticoreFuture ...
[10:33:25.098] result() for MulticoreFuture ... done
[10:33:25.098] result() for MulticoreFuture ...
[10:33:25.098] result() for MulticoreFuture ... done
[10:33:25.098] signalConditions() ...
[10:33:25.098]  - include = ‘immediateCondition’
[10:33:25.098]  - exclude = 
[10:33:25.098]  - resignal = FALSE
[10:33:25.098]  - Number of conditions: 1
[10:33:25.099] signalConditions() ... done
[10:33:25.099] Future state: ‘finished’
[10:33:25.099] result() for MulticoreFuture ...
[10:33:25.099] result() for MulticoreFuture ... done
[10:33:25.099] signalConditions() ...
[10:33:25.099]  - include = ‘condition’
[10:33:25.099]  - exclude = ‘immediateCondition’
[10:33:25.099]  - resignal = TRUE
[10:33:25.100]  - Number of conditions: 1
[10:33:25.100]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:33:25.100] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:33:25.105] getGlobalsAndPackages() ...
[10:33:25.105] 
[10:33:25.105] - globals: [0] <none>
[10:33:25.105] getGlobalsAndPackages() ... DONE
[10:33:25.106] Packages needed by the future expression (n = 0): <none>
[10:33:25.106] Packages needed by future strategies (n = 0): <none>
[10:33:25.107] {
[10:33:25.107]     {
[10:33:25.107]         {
[10:33:25.107]             ...future.startTime <- base::Sys.time()
[10:33:25.107]             {
[10:33:25.107]                 {
[10:33:25.107]                   {
[10:33:25.107]                     {
[10:33:25.107]                       base::local({
[10:33:25.107]                         has_future <- base::requireNamespace("future", 
[10:33:25.107]                           quietly = TRUE)
[10:33:25.107]                         if (has_future) {
[10:33:25.107]                           ns <- base::getNamespace("future")
[10:33:25.107]                           version <- ns[[".package"]][["version"]]
[10:33:25.107]                           if (is.null(version)) 
[10:33:25.107]                             version <- utils::packageVersion("future")
[10:33:25.107]                         }
[10:33:25.107]                         else {
[10:33:25.107]                           version <- NULL
[10:33:25.107]                         }
[10:33:25.107]                         if (!has_future || version < "1.8.0") {
[10:33:25.107]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:25.107]                             "", base::R.version$version.string), 
[10:33:25.107]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:25.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:25.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:25.107]                               "release", "version")], collapse = " "), 
[10:33:25.107]                             hostname = base::Sys.info()[["nodename"]])
[10:33:25.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:25.107]                             info)
[10:33:25.107]                           info <- base::paste(info, collapse = "; ")
[10:33:25.107]                           if (!has_future) {
[10:33:25.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:25.107]                               info)
[10:33:25.107]                           }
[10:33:25.107]                           else {
[10:33:25.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:25.107]                               info, version)
[10:33:25.107]                           }
[10:33:25.107]                           base::stop(msg)
[10:33:25.107]                         }
[10:33:25.107]                       })
[10:33:25.107]                     }
[10:33:25.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:25.107]                     base::options(mc.cores = 1L)
[10:33:25.107]                   }
[10:33:25.107]                   ...future.strategy.old <- future::plan("list")
[10:33:25.107]                   options(future.plan = NULL)
[10:33:25.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:25.107]                 }
[10:33:25.107]                 ...future.workdir <- getwd()
[10:33:25.107]             }
[10:33:25.107]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:25.107]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:25.107]         }
[10:33:25.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:25.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:25.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:25.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:25.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:25.107]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:25.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:25.107]             base::names(...future.oldOptions))
[10:33:25.107]     }
[10:33:25.107]     if (FALSE) {
[10:33:25.107]     }
[10:33:25.107]     else {
[10:33:25.107]         if (TRUE) {
[10:33:25.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:25.107]                 open = "w")
[10:33:25.107]         }
[10:33:25.107]         else {
[10:33:25.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:25.107]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:25.107]         }
[10:33:25.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:25.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:25.107]             base::sink(type = "output", split = FALSE)
[10:33:25.107]             base::close(...future.stdout)
[10:33:25.107]         }, add = TRUE)
[10:33:25.107]     }
[10:33:25.107]     ...future.frame <- base::sys.nframe()
[10:33:25.107]     ...future.conditions <- base::list()
[10:33:25.107]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:25.107]     if (FALSE) {
[10:33:25.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:25.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:25.107]     }
[10:33:25.107]     ...future.result <- base::tryCatch({
[10:33:25.107]         base::withCallingHandlers({
[10:33:25.107]             ...future.value <- base::withVisible(base::local({
[10:33:25.107]                 withCallingHandlers({
[10:33:25.107]                   {
[10:33:25.107]                     stop(structure(list(message = "boom"), class = c("MyError", 
[10:33:25.107]                       "error", "condition")))
[10:33:25.107]                   }
[10:33:25.107]                 }, immediateCondition = function(cond) {
[10:33:25.107]                   save_rds <- function (object, pathname, ...) 
[10:33:25.107]                   {
[10:33:25.107]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:25.107]                     if (file_test("-f", pathname_tmp)) {
[10:33:25.107]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.107]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:25.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.107]                         fi_tmp[["mtime"]])
[10:33:25.107]                     }
[10:33:25.107]                     tryCatch({
[10:33:25.107]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:25.107]                     }, error = function(ex) {
[10:33:25.107]                       msg <- conditionMessage(ex)
[10:33:25.107]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.107]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:25.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.107]                         fi_tmp[["mtime"]], msg)
[10:33:25.107]                       ex$message <- msg
[10:33:25.107]                       stop(ex)
[10:33:25.107]                     })
[10:33:25.107]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:25.107]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:25.107]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:25.107]                       fi_tmp <- file.info(pathname_tmp)
[10:33:25.107]                       fi <- file.info(pathname)
[10:33:25.107]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:25.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:25.107]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:25.107]                         fi[["size"]], fi[["mtime"]])
[10:33:25.107]                       stop(msg)
[10:33:25.107]                     }
[10:33:25.107]                     invisible(pathname)
[10:33:25.107]                   }
[10:33:25.107]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:25.107]                     rootPath = tempdir()) 
[10:33:25.107]                   {
[10:33:25.107]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:25.107]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:25.107]                       tmpdir = path, fileext = ".rds")
[10:33:25.107]                     save_rds(obj, file)
[10:33:25.107]                   }
[10:33:25.107]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1MnQPo/.future/immediateConditions")
[10:33:25.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.107]                   {
[10:33:25.107]                     inherits <- base::inherits
[10:33:25.107]                     invokeRestart <- base::invokeRestart
[10:33:25.107]                     is.null <- base::is.null
[10:33:25.107]                     muffled <- FALSE
[10:33:25.107]                     if (inherits(cond, "message")) {
[10:33:25.107]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:25.107]                       if (muffled) 
[10:33:25.107]                         invokeRestart("muffleMessage")
[10:33:25.107]                     }
[10:33:25.107]                     else if (inherits(cond, "warning")) {
[10:33:25.107]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:25.107]                       if (muffled) 
[10:33:25.107]                         invokeRestart("muffleWarning")
[10:33:25.107]                     }
[10:33:25.107]                     else if (inherits(cond, "condition")) {
[10:33:25.107]                       if (!is.null(pattern)) {
[10:33:25.107]                         computeRestarts <- base::computeRestarts
[10:33:25.107]                         grepl <- base::grepl
[10:33:25.107]                         restarts <- computeRestarts(cond)
[10:33:25.107]                         for (restart in restarts) {
[10:33:25.107]                           name <- restart$name
[10:33:25.107]                           if (is.null(name)) 
[10:33:25.107]                             next
[10:33:25.107]                           if (!grepl(pattern, name)) 
[10:33:25.107]                             next
[10:33:25.107]                           invokeRestart(restart)
[10:33:25.107]                           muffled <- TRUE
[10:33:25.107]                           break
[10:33:25.107]                         }
[10:33:25.107]                       }
[10:33:25.107]                     }
[10:33:25.107]                     invisible(muffled)
[10:33:25.107]                   }
[10:33:25.107]                   muffleCondition(cond)
[10:33:25.107]                 })
[10:33:25.107]             }))
[10:33:25.107]             future::FutureResult(value = ...future.value$value, 
[10:33:25.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.107]                   ...future.rng), globalenv = if (FALSE) 
[10:33:25.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:25.107]                     ...future.globalenv.names))
[10:33:25.107]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:25.107]         }, condition = base::local({
[10:33:25.107]             c <- base::c
[10:33:25.107]             inherits <- base::inherits
[10:33:25.107]             invokeRestart <- base::invokeRestart
[10:33:25.107]             length <- base::length
[10:33:25.107]             list <- base::list
[10:33:25.107]             seq.int <- base::seq.int
[10:33:25.107]             signalCondition <- base::signalCondition
[10:33:25.107]             sys.calls <- base::sys.calls
[10:33:25.107]             `[[` <- base::`[[`
[10:33:25.107]             `+` <- base::`+`
[10:33:25.107]             `<<-` <- base::`<<-`
[10:33:25.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:25.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:25.107]                   3L)]
[10:33:25.107]             }
[10:33:25.107]             function(cond) {
[10:33:25.107]                 is_error <- inherits(cond, "error")
[10:33:25.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:25.107]                   NULL)
[10:33:25.107]                 if (is_error) {
[10:33:25.107]                   sessionInformation <- function() {
[10:33:25.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:25.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:25.107]                       search = base::search(), system = base::Sys.info())
[10:33:25.107]                   }
[10:33:25.107]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:25.107]                     cond$call), session = sessionInformation(), 
[10:33:25.107]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:25.107]                   signalCondition(cond)
[10:33:25.107]                 }
[10:33:25.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:25.107]                 "immediateCondition"))) {
[10:33:25.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:25.107]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:25.107]                   if (TRUE && !signal) {
[10:33:25.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.107]                     {
[10:33:25.107]                       inherits <- base::inherits
[10:33:25.107]                       invokeRestart <- base::invokeRestart
[10:33:25.107]                       is.null <- base::is.null
[10:33:25.107]                       muffled <- FALSE
[10:33:25.107]                       if (inherits(cond, "message")) {
[10:33:25.107]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.107]                         if (muffled) 
[10:33:25.107]                           invokeRestart("muffleMessage")
[10:33:25.107]                       }
[10:33:25.107]                       else if (inherits(cond, "warning")) {
[10:33:25.107]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.107]                         if (muffled) 
[10:33:25.107]                           invokeRestart("muffleWarning")
[10:33:25.107]                       }
[10:33:25.107]                       else if (inherits(cond, "condition")) {
[10:33:25.107]                         if (!is.null(pattern)) {
[10:33:25.107]                           computeRestarts <- base::computeRestarts
[10:33:25.107]                           grepl <- base::grepl
[10:33:25.107]                           restarts <- computeRestarts(cond)
[10:33:25.107]                           for (restart in restarts) {
[10:33:25.107]                             name <- restart$name
[10:33:25.107]                             if (is.null(name)) 
[10:33:25.107]                               next
[10:33:25.107]                             if (!grepl(pattern, name)) 
[10:33:25.107]                               next
[10:33:25.107]                             invokeRestart(restart)
[10:33:25.107]                             muffled <- TRUE
[10:33:25.107]                             break
[10:33:25.107]                           }
[10:33:25.107]                         }
[10:33:25.107]                       }
[10:33:25.107]                       invisible(muffled)
[10:33:25.107]                     }
[10:33:25.107]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.107]                   }
[10:33:25.107]                 }
[10:33:25.107]                 else {
[10:33:25.107]                   if (TRUE) {
[10:33:25.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.107]                     {
[10:33:25.107]                       inherits <- base::inherits
[10:33:25.107]                       invokeRestart <- base::invokeRestart
[10:33:25.107]                       is.null <- base::is.null
[10:33:25.107]                       muffled <- FALSE
[10:33:25.107]                       if (inherits(cond, "message")) {
[10:33:25.107]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.107]                         if (muffled) 
[10:33:25.107]                           invokeRestart("muffleMessage")
[10:33:25.107]                       }
[10:33:25.107]                       else if (inherits(cond, "warning")) {
[10:33:25.107]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.107]                         if (muffled) 
[10:33:25.107]                           invokeRestart("muffleWarning")
[10:33:25.107]                       }
[10:33:25.107]                       else if (inherits(cond, "condition")) {
[10:33:25.107]                         if (!is.null(pattern)) {
[10:33:25.107]                           computeRestarts <- base::computeRestarts
[10:33:25.107]                           grepl <- base::grepl
[10:33:25.107]                           restarts <- computeRestarts(cond)
[10:33:25.107]                           for (restart in restarts) {
[10:33:25.107]                             name <- restart$name
[10:33:25.107]                             if (is.null(name)) 
[10:33:25.107]                               next
[10:33:25.107]                             if (!grepl(pattern, name)) 
[10:33:25.107]                               next
[10:33:25.107]                             invokeRestart(restart)
[10:33:25.107]                             muffled <- TRUE
[10:33:25.107]                             break
[10:33:25.107]                           }
[10:33:25.107]                         }
[10:33:25.107]                       }
[10:33:25.107]                       invisible(muffled)
[10:33:25.107]                     }
[10:33:25.107]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.107]                   }
[10:33:25.107]                 }
[10:33:25.107]             }
[10:33:25.107]         }))
[10:33:25.107]     }, error = function(ex) {
[10:33:25.107]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:25.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.107]                 ...future.rng), started = ...future.startTime, 
[10:33:25.107]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:25.107]             version = "1.8"), class = "FutureResult")
[10:33:25.107]     }, finally = {
[10:33:25.107]         if (!identical(...future.workdir, getwd())) 
[10:33:25.107]             setwd(...future.workdir)
[10:33:25.107]         {
[10:33:25.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:25.107]                 ...future.oldOptions$nwarnings <- NULL
[10:33:25.107]             }
[10:33:25.107]             base::options(...future.oldOptions)
[10:33:25.107]             if (.Platform$OS.type == "windows") {
[10:33:25.107]                 old_names <- names(...future.oldEnvVars)
[10:33:25.107]                 envs <- base::Sys.getenv()
[10:33:25.107]                 names <- names(envs)
[10:33:25.107]                 common <- intersect(names, old_names)
[10:33:25.107]                 added <- setdiff(names, old_names)
[10:33:25.107]                 removed <- setdiff(old_names, names)
[10:33:25.107]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:25.107]                   envs[common]]
[10:33:25.107]                 NAMES <- toupper(changed)
[10:33:25.107]                 args <- list()
[10:33:25.107]                 for (kk in seq_along(NAMES)) {
[10:33:25.107]                   name <- changed[[kk]]
[10:33:25.107]                   NAME <- NAMES[[kk]]
[10:33:25.107]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.107]                     next
[10:33:25.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.107]                 }
[10:33:25.107]                 NAMES <- toupper(added)
[10:33:25.107]                 for (kk in seq_along(NAMES)) {
[10:33:25.107]                   name <- added[[kk]]
[10:33:25.107]                   NAME <- NAMES[[kk]]
[10:33:25.107]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.107]                     next
[10:33:25.107]                   args[[name]] <- ""
[10:33:25.107]                 }
[10:33:25.107]                 NAMES <- toupper(removed)
[10:33:25.107]                 for (kk in seq_along(NAMES)) {
[10:33:25.107]                   name <- removed[[kk]]
[10:33:25.107]                   NAME <- NAMES[[kk]]
[10:33:25.107]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.107]                     next
[10:33:25.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.107]                 }
[10:33:25.107]                 if (length(args) > 0) 
[10:33:25.107]                   base::do.call(base::Sys.setenv, args = args)
[10:33:25.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:25.107]             }
[10:33:25.107]             else {
[10:33:25.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:25.107]             }
[10:33:25.107]             {
[10:33:25.107]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:25.107]                   0L) {
[10:33:25.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:25.107]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:25.107]                   base::options(opts)
[10:33:25.107]                 }
[10:33:25.107]                 {
[10:33:25.107]                   {
[10:33:25.107]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:25.107]                     NULL
[10:33:25.107]                   }
[10:33:25.107]                   options(future.plan = NULL)
[10:33:25.107]                   if (is.na(NA_character_)) 
[10:33:25.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:25.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:25.107]                     .init = FALSE)
[10:33:25.107]                 }
[10:33:25.107]             }
[10:33:25.107]         }
[10:33:25.107]     })
[10:33:25.107]     if (TRUE) {
[10:33:25.107]         base::sink(type = "output", split = FALSE)
[10:33:25.107]         if (TRUE) {
[10:33:25.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:25.107]         }
[10:33:25.107]         else {
[10:33:25.107]             ...future.result["stdout"] <- base::list(NULL)
[10:33:25.107]         }
[10:33:25.107]         base::close(...future.stdout)
[10:33:25.107]         ...future.stdout <- NULL
[10:33:25.107]     }
[10:33:25.107]     ...future.result$conditions <- ...future.conditions
[10:33:25.107]     ...future.result$finished <- base::Sys.time()
[10:33:25.107]     ...future.result
[10:33:25.107] }
[10:33:25.109] requestCore(): workers = 2
[10:33:25.111] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:33:25.112] plan(): Setting new future strategy stack:
[10:33:25.112] List of future strategies:
[10:33:25.112] 1. sequential:
[10:33:25.112]    - args: function (..., envir = parent.frame())
[10:33:25.112]    - tweaked: FALSE
[10:33:25.112]    - call: NULL
[10:33:25.113] plan(): nbrOfWorkers() = 1
[10:33:25.115] plan(): Setting new future strategy stack:
[10:33:25.115] List of future strategies:
[10:33:25.115] 1. multicore:
[10:33:25.115]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:25.115]    - tweaked: FALSE
[10:33:25.115]    - call: plan(multicore)
[10:33:25.121] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: ae651797-625e-7e3e-90f7-8384aaf17c31
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:25.123] result() for MulticoreFuture ...
[10:33:25.125] result() for MulticoreFuture ...
[10:33:25.125] result() for MulticoreFuture ... done
[10:33:25.125] signalConditions() ...
[10:33:25.125]  - include = ‘immediateCondition’
[10:33:25.125]  - exclude = 
[10:33:25.125]  - resignal = FALSE
[10:33:25.126]  - Number of conditions: 1
[10:33:25.126] signalConditions() ... done
[10:33:25.126] result() for MulticoreFuture ... done
[10:33:25.126] result() for MulticoreFuture ...
[10:33:25.126] result() for MulticoreFuture ... done
[10:33:25.126] signalConditions() ...
[10:33:25.126]  - include = ‘immediateCondition’
[10:33:25.126]  - exclude = 
[10:33:25.126]  - resignal = FALSE
[10:33:25.127]  - Number of conditions: 1
[10:33:25.127] signalConditions() ... done
<MyError: boom>
[10:33:25.127] result() for MulticoreFuture ...
[10:33:25.127] result() for MulticoreFuture ... done
[10:33:25.127] result() for MulticoreFuture ...
[10:33:25.127] result() for MulticoreFuture ... done
[10:33:25.127] signalConditions() ...
[10:33:25.128]  - include = ‘immediateCondition’
[10:33:25.128]  - exclude = 
[10:33:25.128]  - resignal = FALSE
[10:33:25.128]  - Number of conditions: 1
[10:33:25.128] signalConditions() ... done
[10:33:25.128] Future state: ‘finished’
[10:33:25.128] result() for MulticoreFuture ...
[10:33:25.128] result() for MulticoreFuture ... done
[10:33:25.128] signalConditions() ...
[10:33:25.128]  - include = ‘condition’
[10:33:25.129]  - exclude = ‘immediateCondition’
[10:33:25.129]  - resignal = TRUE
[10:33:25.129]  - Number of conditions: 1
[10:33:25.129]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:33:25.129] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[10:33:25.129] getGlobalsAndPackages() ...
[10:33:25.130] Searching for globals...
[10:33:25.131] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:33:25.131] Searching for globals ... DONE
[10:33:25.131] Resolving globals: FALSE
[10:33:25.132] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:25.136] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[10:33:25.136] - globals: [2] ‘a’, ‘b’
[10:33:25.136] 
[10:33:25.136] getGlobalsAndPackages() ... DONE
[10:33:25.137] Packages needed by the future expression (n = 0): <none>
[10:33:25.137] Packages needed by future strategies (n = 0): <none>
[10:33:25.138] {
[10:33:25.138]     {
[10:33:25.138]         {
[10:33:25.138]             ...future.startTime <- base::Sys.time()
[10:33:25.138]             {
[10:33:25.138]                 {
[10:33:25.138]                   {
[10:33:25.138]                     base::local({
[10:33:25.138]                       has_future <- base::requireNamespace("future", 
[10:33:25.138]                         quietly = TRUE)
[10:33:25.138]                       if (has_future) {
[10:33:25.138]                         ns <- base::getNamespace("future")
[10:33:25.138]                         version <- ns[[".package"]][["version"]]
[10:33:25.138]                         if (is.null(version)) 
[10:33:25.138]                           version <- utils::packageVersion("future")
[10:33:25.138]                       }
[10:33:25.138]                       else {
[10:33:25.138]                         version <- NULL
[10:33:25.138]                       }
[10:33:25.138]                       if (!has_future || version < "1.8.0") {
[10:33:25.138]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:25.138]                           "", base::R.version$version.string), 
[10:33:25.138]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:25.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:25.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:25.138]                             "release", "version")], collapse = " "), 
[10:33:25.138]                           hostname = base::Sys.info()[["nodename"]])
[10:33:25.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:25.138]                           info)
[10:33:25.138]                         info <- base::paste(info, collapse = "; ")
[10:33:25.138]                         if (!has_future) {
[10:33:25.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:25.138]                             info)
[10:33:25.138]                         }
[10:33:25.138]                         else {
[10:33:25.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:25.138]                             info, version)
[10:33:25.138]                         }
[10:33:25.138]                         base::stop(msg)
[10:33:25.138]                       }
[10:33:25.138]                     })
[10:33:25.138]                   }
[10:33:25.138]                   ...future.strategy.old <- future::plan("list")
[10:33:25.138]                   options(future.plan = NULL)
[10:33:25.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:25.138]                 }
[10:33:25.138]                 ...future.workdir <- getwd()
[10:33:25.138]             }
[10:33:25.138]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:25.138]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:25.138]         }
[10:33:25.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:25.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:25.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:25.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:25.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:25.138]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:25.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:25.138]             base::names(...future.oldOptions))
[10:33:25.138]     }
[10:33:25.138]     if (FALSE) {
[10:33:25.138]     }
[10:33:25.138]     else {
[10:33:25.138]         if (TRUE) {
[10:33:25.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:25.138]                 open = "w")
[10:33:25.138]         }
[10:33:25.138]         else {
[10:33:25.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:25.138]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:25.138]         }
[10:33:25.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:25.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:25.138]             base::sink(type = "output", split = FALSE)
[10:33:25.138]             base::close(...future.stdout)
[10:33:25.138]         }, add = TRUE)
[10:33:25.138]     }
[10:33:25.138]     ...future.frame <- base::sys.nframe()
[10:33:25.138]     ...future.conditions <- base::list()
[10:33:25.138]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:25.138]     if (FALSE) {
[10:33:25.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:25.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:25.138]     }
[10:33:25.138]     ...future.result <- base::tryCatch({
[10:33:25.138]         base::withCallingHandlers({
[10:33:25.138]             ...future.value <- base::withVisible(base::local({
[10:33:25.138]                 a * b
[10:33:25.138]             }))
[10:33:25.138]             future::FutureResult(value = ...future.value$value, 
[10:33:25.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.138]                   ...future.rng), globalenv = if (FALSE) 
[10:33:25.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:25.138]                     ...future.globalenv.names))
[10:33:25.138]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:25.138]         }, condition = base::local({
[10:33:25.138]             c <- base::c
[10:33:25.138]             inherits <- base::inherits
[10:33:25.138]             invokeRestart <- base::invokeRestart
[10:33:25.138]             length <- base::length
[10:33:25.138]             list <- base::list
[10:33:25.138]             seq.int <- base::seq.int
[10:33:25.138]             signalCondition <- base::signalCondition
[10:33:25.138]             sys.calls <- base::sys.calls
[10:33:25.138]             `[[` <- base::`[[`
[10:33:25.138]             `+` <- base::`+`
[10:33:25.138]             `<<-` <- base::`<<-`
[10:33:25.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:25.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:25.138]                   3L)]
[10:33:25.138]             }
[10:33:25.138]             function(cond) {
[10:33:25.138]                 is_error <- inherits(cond, "error")
[10:33:25.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:25.138]                   NULL)
[10:33:25.138]                 if (is_error) {
[10:33:25.138]                   sessionInformation <- function() {
[10:33:25.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:25.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:25.138]                       search = base::search(), system = base::Sys.info())
[10:33:25.138]                   }
[10:33:25.138]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:25.138]                     cond$call), session = sessionInformation(), 
[10:33:25.138]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:25.138]                   signalCondition(cond)
[10:33:25.138]                 }
[10:33:25.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:25.138]                 "immediateCondition"))) {
[10:33:25.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:25.138]                   ...future.conditions[[length(...future.conditions) + 
[10:33:25.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:25.138]                   if (TRUE && !signal) {
[10:33:25.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.138]                     {
[10:33:25.138]                       inherits <- base::inherits
[10:33:25.138]                       invokeRestart <- base::invokeRestart
[10:33:25.138]                       is.null <- base::is.null
[10:33:25.138]                       muffled <- FALSE
[10:33:25.138]                       if (inherits(cond, "message")) {
[10:33:25.138]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.138]                         if (muffled) 
[10:33:25.138]                           invokeRestart("muffleMessage")
[10:33:25.138]                       }
[10:33:25.138]                       else if (inherits(cond, "warning")) {
[10:33:25.138]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.138]                         if (muffled) 
[10:33:25.138]                           invokeRestart("muffleWarning")
[10:33:25.138]                       }
[10:33:25.138]                       else if (inherits(cond, "condition")) {
[10:33:25.138]                         if (!is.null(pattern)) {
[10:33:25.138]                           computeRestarts <- base::computeRestarts
[10:33:25.138]                           grepl <- base::grepl
[10:33:25.138]                           restarts <- computeRestarts(cond)
[10:33:25.138]                           for (restart in restarts) {
[10:33:25.138]                             name <- restart$name
[10:33:25.138]                             if (is.null(name)) 
[10:33:25.138]                               next
[10:33:25.138]                             if (!grepl(pattern, name)) 
[10:33:25.138]                               next
[10:33:25.138]                             invokeRestart(restart)
[10:33:25.138]                             muffled <- TRUE
[10:33:25.138]                             break
[10:33:25.138]                           }
[10:33:25.138]                         }
[10:33:25.138]                       }
[10:33:25.138]                       invisible(muffled)
[10:33:25.138]                     }
[10:33:25.138]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.138]                   }
[10:33:25.138]                 }
[10:33:25.138]                 else {
[10:33:25.138]                   if (TRUE) {
[10:33:25.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:25.138]                     {
[10:33:25.138]                       inherits <- base::inherits
[10:33:25.138]                       invokeRestart <- base::invokeRestart
[10:33:25.138]                       is.null <- base::is.null
[10:33:25.138]                       muffled <- FALSE
[10:33:25.138]                       if (inherits(cond, "message")) {
[10:33:25.138]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:25.138]                         if (muffled) 
[10:33:25.138]                           invokeRestart("muffleMessage")
[10:33:25.138]                       }
[10:33:25.138]                       else if (inherits(cond, "warning")) {
[10:33:25.138]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:25.138]                         if (muffled) 
[10:33:25.138]                           invokeRestart("muffleWarning")
[10:33:25.138]                       }
[10:33:25.138]                       else if (inherits(cond, "condition")) {
[10:33:25.138]                         if (!is.null(pattern)) {
[10:33:25.138]                           computeRestarts <- base::computeRestarts
[10:33:25.138]                           grepl <- base::grepl
[10:33:25.138]                           restarts <- computeRestarts(cond)
[10:33:25.138]                           for (restart in restarts) {
[10:33:25.138]                             name <- restart$name
[10:33:25.138]                             if (is.null(name)) 
[10:33:25.138]                               next
[10:33:25.138]                             if (!grepl(pattern, name)) 
[10:33:25.138]                               next
[10:33:25.138]                             invokeRestart(restart)
[10:33:25.138]                             muffled <- TRUE
[10:33:25.138]                             break
[10:33:25.138]                           }
[10:33:25.138]                         }
[10:33:25.138]                       }
[10:33:25.138]                       invisible(muffled)
[10:33:25.138]                     }
[10:33:25.138]                     muffleCondition(cond, pattern = "^muffle")
[10:33:25.138]                   }
[10:33:25.138]                 }
[10:33:25.138]             }
[10:33:25.138]         }))
[10:33:25.138]     }, error = function(ex) {
[10:33:25.138]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:25.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:25.138]                 ...future.rng), started = ...future.startTime, 
[10:33:25.138]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:25.138]             version = "1.8"), class = "FutureResult")
[10:33:25.138]     }, finally = {
[10:33:25.138]         if (!identical(...future.workdir, getwd())) 
[10:33:25.138]             setwd(...future.workdir)
[10:33:25.138]         {
[10:33:25.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:25.138]                 ...future.oldOptions$nwarnings <- NULL
[10:33:25.138]             }
[10:33:25.138]             base::options(...future.oldOptions)
[10:33:25.138]             if (.Platform$OS.type == "windows") {
[10:33:25.138]                 old_names <- names(...future.oldEnvVars)
[10:33:25.138]                 envs <- base::Sys.getenv()
[10:33:25.138]                 names <- names(envs)
[10:33:25.138]                 common <- intersect(names, old_names)
[10:33:25.138]                 added <- setdiff(names, old_names)
[10:33:25.138]                 removed <- setdiff(old_names, names)
[10:33:25.138]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:25.138]                   envs[common]]
[10:33:25.138]                 NAMES <- toupper(changed)
[10:33:25.138]                 args <- list()
[10:33:25.138]                 for (kk in seq_along(NAMES)) {
[10:33:25.138]                   name <- changed[[kk]]
[10:33:25.138]                   NAME <- NAMES[[kk]]
[10:33:25.138]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.138]                     next
[10:33:25.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.138]                 }
[10:33:25.138]                 NAMES <- toupper(added)
[10:33:25.138]                 for (kk in seq_along(NAMES)) {
[10:33:25.138]                   name <- added[[kk]]
[10:33:25.138]                   NAME <- NAMES[[kk]]
[10:33:25.138]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.138]                     next
[10:33:25.138]                   args[[name]] <- ""
[10:33:25.138]                 }
[10:33:25.138]                 NAMES <- toupper(removed)
[10:33:25.138]                 for (kk in seq_along(NAMES)) {
[10:33:25.138]                   name <- removed[[kk]]
[10:33:25.138]                   NAME <- NAMES[[kk]]
[10:33:25.138]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:25.138]                     next
[10:33:25.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:25.138]                 }
[10:33:25.138]                 if (length(args) > 0) 
[10:33:25.138]                   base::do.call(base::Sys.setenv, args = args)
[10:33:25.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:25.138]             }
[10:33:25.138]             else {
[10:33:25.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:25.138]             }
[10:33:25.138]             {
[10:33:25.138]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:25.138]                   0L) {
[10:33:25.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:25.138]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:25.138]                   base::options(opts)
[10:33:25.138]                 }
[10:33:25.138]                 {
[10:33:25.138]                   {
[10:33:25.138]                     NULL
[10:33:25.138]                     RNGkind("Mersenne-Twister")
[10:33:25.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:25.138]                       inherits = FALSE)
[10:33:25.138]                   }
[10:33:25.138]                   options(future.plan = NULL)
[10:33:25.138]                   if (is.na(NA_character_)) 
[10:33:25.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:25.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:25.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:25.138]                     .init = FALSE)
[10:33:25.138]                 }
[10:33:25.138]             }
[10:33:25.138]         }
[10:33:25.138]     })
[10:33:25.138]     if (TRUE) {
[10:33:25.138]         base::sink(type = "output", split = FALSE)
[10:33:25.138]         if (TRUE) {
[10:33:25.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:25.138]         }
[10:33:25.138]         else {
[10:33:25.138]             ...future.result["stdout"] <- base::list(NULL)
[10:33:25.138]         }
[10:33:25.138]         base::close(...future.stdout)
[10:33:25.138]         ...future.stdout <- NULL
[10:33:25.138]     }
[10:33:25.138]     ...future.result$conditions <- ...future.conditions
[10:33:25.138]     ...future.result$finished <- base::Sys.time()
[10:33:25.138]     ...future.result
[10:33:25.138] }
[10:33:25.140] assign_globals() ...
[10:33:25.140] List of 2
[10:33:25.140]  $ a: num 2
[10:33:25.140]  $ b: num 3
[10:33:25.140]  - attr(*, "where")=List of 2
[10:33:25.140]   ..$ a:<environment: R_EmptyEnv> 
[10:33:25.140]   ..$ b:<environment: R_EmptyEnv> 
[10:33:25.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:25.140]  - attr(*, "resolved")= logi FALSE
[10:33:25.140]  - attr(*, "total_size")= num 112
[10:33:25.143] - copied ‘a’ to environment
[10:33:25.143] - copied ‘b’ to environment
[10:33:25.143] assign_globals() ... done
[10:33:25.144] plan(): Setting new future strategy stack:
[10:33:25.144] List of future strategies:
[10:33:25.144] 1. sequential:
[10:33:25.144]    - args: function (..., envir = parent.frame())
[10:33:25.144]    - tweaked: FALSE
[10:33:25.144]    - call: NULL
[10:33:25.144] plan(): nbrOfWorkers() = 1
[10:33:25.145] plan(): Setting new future strategy stack:
[10:33:25.145] List of future strategies:
[10:33:25.145] 1. multicore:
[10:33:25.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:25.145]    - tweaked: FALSE
[10:33:25.145]    - call: plan(multicore)
[10:33:25.149] plan(): nbrOfWorkers() = 2
[10:33:25.149] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[10:33:25.150] plan(): Setting new future strategy stack:
[10:33:25.151] List of future strategies:
[10:33:25.151] 1. FutureStrategy:
[10:33:25.151]    - args: function (..., envir = parent.frame())
[10:33:25.151]    - tweaked: FALSE
[10:33:25.151]    - call: future::plan(oplan)
[10:33:25.151] plan(): nbrOfWorkers() = 1
> 
