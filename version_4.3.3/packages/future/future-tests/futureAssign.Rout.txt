
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:20:34.852] plan(): Setting new future strategy stack:
[16:20:34.853] List of future strategies:
[16:20:34.853] 1. sequential:
[16:20:34.853]    - args: function (..., envir = parent.frame())
[16:20:34.853]    - tweaked: FALSE
[16:20:34.853]    - call: future::plan("sequential")
[16:20:34.866] plan(): nbrOfWorkers() = 1
> 
> message("*** futureAssign() ...")
*** futureAssign() ...
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ...")
*** futureAssign() - sequential w/ lazy evaluation ...
> 
> delayedAssign("a", {
+   cat("Delayed assignment evaluated\n")
+   1
+ })
> 
> futureAssign("b", {
+   cat("Future assignment evaluated\n")
+   2
+ }, lazy = TRUE)
[16:20:34.877] getGlobalsAndPackages() ...
[16:20:34.877] Searching for globals...
[16:20:34.883] - globals found: [2] ‘{’, ‘cat’
[16:20:34.884] Searching for globals ... DONE
[16:20:34.884] Resolving globals: FALSE
[16:20:34.884] 
[16:20:34.884] 
[16:20:34.885] getGlobalsAndPackages() ... DONE
> 
> ## Because "lazy future" is used, the expression/value
> ## for 'b' will not be resolved at the point.  For other
> ## types of futures, it may already have been resolved
> cat(sprintf("b = %s\n", b))
[16:20:34.886] run() for ‘Future’ ...
[16:20:34.886] - state: ‘created’
[16:20:34.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.886] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.886]   - Field: ‘label’
[16:20:34.887]   - Field: ‘local’
[16:20:34.887]   - Field: ‘owner’
[16:20:34.887]   - Field: ‘envir’
[16:20:34.887]   - Field: ‘packages’
[16:20:34.887]   - Field: ‘gc’
[16:20:34.887]   - Field: ‘conditions’
[16:20:34.887]   - Field: ‘expr’
[16:20:34.887]   - Field: ‘uuid’
[16:20:34.887]   - Field: ‘seed’
[16:20:34.887]   - Field: ‘version’
[16:20:34.887]   - Field: ‘result’
[16:20:34.888]   - Field: ‘asynchronous’
[16:20:34.888]   - Field: ‘calls’
[16:20:34.888]   - Field: ‘globals’
[16:20:34.888]   - Field: ‘stdout’
[16:20:34.888]   - Field: ‘earlySignal’
[16:20:34.888]   - Field: ‘lazy’
[16:20:34.888]   - Field: ‘state’
[16:20:34.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.888] - Launch lazy future ...
[16:20:34.889] Packages needed by the future expression (n = 0): <none>
[16:20:34.889] Packages needed by future strategies (n = 0): <none>
[16:20:34.890] {
[16:20:34.890]     {
[16:20:34.890]         {
[16:20:34.890]             ...future.startTime <- base::Sys.time()
[16:20:34.890]             {
[16:20:34.890]                 {
[16:20:34.890]                   {
[16:20:34.890]                     base::local({
[16:20:34.890]                       has_future <- base::requireNamespace("future", 
[16:20:34.890]                         quietly = TRUE)
[16:20:34.890]                       if (has_future) {
[16:20:34.890]                         ns <- base::getNamespace("future")
[16:20:34.890]                         version <- ns[[".package"]][["version"]]
[16:20:34.890]                         if (is.null(version)) 
[16:20:34.890]                           version <- utils::packageVersion("future")
[16:20:34.890]                       }
[16:20:34.890]                       else {
[16:20:34.890]                         version <- NULL
[16:20:34.890]                       }
[16:20:34.890]                       if (!has_future || version < "1.8.0") {
[16:20:34.890]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.890]                           "", base::R.version$version.string), 
[16:20:34.890]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.890]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.890]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.890]                             "release", "version")], collapse = " "), 
[16:20:34.890]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.890]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.890]                           info)
[16:20:34.890]                         info <- base::paste(info, collapse = "; ")
[16:20:34.890]                         if (!has_future) {
[16:20:34.890]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.890]                             info)
[16:20:34.890]                         }
[16:20:34.890]                         else {
[16:20:34.890]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.890]                             info, version)
[16:20:34.890]                         }
[16:20:34.890]                         base::stop(msg)
[16:20:34.890]                       }
[16:20:34.890]                     })
[16:20:34.890]                   }
[16:20:34.890]                   ...future.strategy.old <- future::plan("list")
[16:20:34.890]                   options(future.plan = NULL)
[16:20:34.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.890]                 }
[16:20:34.890]                 ...future.workdir <- getwd()
[16:20:34.890]             }
[16:20:34.890]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.890]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.890]         }
[16:20:34.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.890]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.890]             base::names(...future.oldOptions))
[16:20:34.890]     }
[16:20:34.890]     if (FALSE) {
[16:20:34.890]     }
[16:20:34.890]     else {
[16:20:34.890]         if (TRUE) {
[16:20:34.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.890]                 open = "w")
[16:20:34.890]         }
[16:20:34.890]         else {
[16:20:34.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.890]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.890]         }
[16:20:34.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.890]             base::sink(type = "output", split = FALSE)
[16:20:34.890]             base::close(...future.stdout)
[16:20:34.890]         }, add = TRUE)
[16:20:34.890]     }
[16:20:34.890]     ...future.frame <- base::sys.nframe()
[16:20:34.890]     ...future.conditions <- base::list()
[16:20:34.890]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.890]     if (FALSE) {
[16:20:34.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.890]     }
[16:20:34.890]     ...future.result <- base::tryCatch({
[16:20:34.890]         base::withCallingHandlers({
[16:20:34.890]             ...future.value <- base::withVisible(base::local({
[16:20:34.890]                 cat("Future assignment evaluated\n")
[16:20:34.890]                 2
[16:20:34.890]             }))
[16:20:34.890]             future::FutureResult(value = ...future.value$value, 
[16:20:34.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.890]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.890]                     ...future.globalenv.names))
[16:20:34.890]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.890]         }, condition = base::local({
[16:20:34.890]             c <- base::c
[16:20:34.890]             inherits <- base::inherits
[16:20:34.890]             invokeRestart <- base::invokeRestart
[16:20:34.890]             length <- base::length
[16:20:34.890]             list <- base::list
[16:20:34.890]             seq.int <- base::seq.int
[16:20:34.890]             signalCondition <- base::signalCondition
[16:20:34.890]             sys.calls <- base::sys.calls
[16:20:34.890]             `[[` <- base::`[[`
[16:20:34.890]             `+` <- base::`+`
[16:20:34.890]             `<<-` <- base::`<<-`
[16:20:34.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.890]                   3L)]
[16:20:34.890]             }
[16:20:34.890]             function(cond) {
[16:20:34.890]                 is_error <- inherits(cond, "error")
[16:20:34.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.890]                   NULL)
[16:20:34.890]                 if (is_error) {
[16:20:34.890]                   sessionInformation <- function() {
[16:20:34.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.890]                       search = base::search(), system = base::Sys.info())
[16:20:34.890]                   }
[16:20:34.890]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.890]                     cond$call), session = sessionInformation(), 
[16:20:34.890]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.890]                   signalCondition(cond)
[16:20:34.890]                 }
[16:20:34.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.890]                 "immediateCondition"))) {
[16:20:34.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.890]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.890]                   if (TRUE && !signal) {
[16:20:34.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.890]                     {
[16:20:34.890]                       inherits <- base::inherits
[16:20:34.890]                       invokeRestart <- base::invokeRestart
[16:20:34.890]                       is.null <- base::is.null
[16:20:34.890]                       muffled <- FALSE
[16:20:34.890]                       if (inherits(cond, "message")) {
[16:20:34.890]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.890]                         if (muffled) 
[16:20:34.890]                           invokeRestart("muffleMessage")
[16:20:34.890]                       }
[16:20:34.890]                       else if (inherits(cond, "warning")) {
[16:20:34.890]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.890]                         if (muffled) 
[16:20:34.890]                           invokeRestart("muffleWarning")
[16:20:34.890]                       }
[16:20:34.890]                       else if (inherits(cond, "condition")) {
[16:20:34.890]                         if (!is.null(pattern)) {
[16:20:34.890]                           computeRestarts <- base::computeRestarts
[16:20:34.890]                           grepl <- base::grepl
[16:20:34.890]                           restarts <- computeRestarts(cond)
[16:20:34.890]                           for (restart in restarts) {
[16:20:34.890]                             name <- restart$name
[16:20:34.890]                             if (is.null(name)) 
[16:20:34.890]                               next
[16:20:34.890]                             if (!grepl(pattern, name)) 
[16:20:34.890]                               next
[16:20:34.890]                             invokeRestart(restart)
[16:20:34.890]                             muffled <- TRUE
[16:20:34.890]                             break
[16:20:34.890]                           }
[16:20:34.890]                         }
[16:20:34.890]                       }
[16:20:34.890]                       invisible(muffled)
[16:20:34.890]                     }
[16:20:34.890]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.890]                   }
[16:20:34.890]                 }
[16:20:34.890]                 else {
[16:20:34.890]                   if (TRUE) {
[16:20:34.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.890]                     {
[16:20:34.890]                       inherits <- base::inherits
[16:20:34.890]                       invokeRestart <- base::invokeRestart
[16:20:34.890]                       is.null <- base::is.null
[16:20:34.890]                       muffled <- FALSE
[16:20:34.890]                       if (inherits(cond, "message")) {
[16:20:34.890]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.890]                         if (muffled) 
[16:20:34.890]                           invokeRestart("muffleMessage")
[16:20:34.890]                       }
[16:20:34.890]                       else if (inherits(cond, "warning")) {
[16:20:34.890]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.890]                         if (muffled) 
[16:20:34.890]                           invokeRestart("muffleWarning")
[16:20:34.890]                       }
[16:20:34.890]                       else if (inherits(cond, "condition")) {
[16:20:34.890]                         if (!is.null(pattern)) {
[16:20:34.890]                           computeRestarts <- base::computeRestarts
[16:20:34.890]                           grepl <- base::grepl
[16:20:34.890]                           restarts <- computeRestarts(cond)
[16:20:34.890]                           for (restart in restarts) {
[16:20:34.890]                             name <- restart$name
[16:20:34.890]                             if (is.null(name)) 
[16:20:34.890]                               next
[16:20:34.890]                             if (!grepl(pattern, name)) 
[16:20:34.890]                               next
[16:20:34.890]                             invokeRestart(restart)
[16:20:34.890]                             muffled <- TRUE
[16:20:34.890]                             break
[16:20:34.890]                           }
[16:20:34.890]                         }
[16:20:34.890]                       }
[16:20:34.890]                       invisible(muffled)
[16:20:34.890]                     }
[16:20:34.890]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.890]                   }
[16:20:34.890]                 }
[16:20:34.890]             }
[16:20:34.890]         }))
[16:20:34.890]     }, error = function(ex) {
[16:20:34.890]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.890]                 ...future.rng), started = ...future.startTime, 
[16:20:34.890]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.890]             version = "1.8"), class = "FutureResult")
[16:20:34.890]     }, finally = {
[16:20:34.890]         if (!identical(...future.workdir, getwd())) 
[16:20:34.890]             setwd(...future.workdir)
[16:20:34.890]         {
[16:20:34.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.890]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.890]             }
[16:20:34.890]             base::options(...future.oldOptions)
[16:20:34.890]             if (.Platform$OS.type == "windows") {
[16:20:34.890]                 old_names <- names(...future.oldEnvVars)
[16:20:34.890]                 envs <- base::Sys.getenv()
[16:20:34.890]                 names <- names(envs)
[16:20:34.890]                 common <- intersect(names, old_names)
[16:20:34.890]                 added <- setdiff(names, old_names)
[16:20:34.890]                 removed <- setdiff(old_names, names)
[16:20:34.890]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.890]                   envs[common]]
[16:20:34.890]                 NAMES <- toupper(changed)
[16:20:34.890]                 args <- list()
[16:20:34.890]                 for (kk in seq_along(NAMES)) {
[16:20:34.890]                   name <- changed[[kk]]
[16:20:34.890]                   NAME <- NAMES[[kk]]
[16:20:34.890]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.890]                     next
[16:20:34.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.890]                 }
[16:20:34.890]                 NAMES <- toupper(added)
[16:20:34.890]                 for (kk in seq_along(NAMES)) {
[16:20:34.890]                   name <- added[[kk]]
[16:20:34.890]                   NAME <- NAMES[[kk]]
[16:20:34.890]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.890]                     next
[16:20:34.890]                   args[[name]] <- ""
[16:20:34.890]                 }
[16:20:34.890]                 NAMES <- toupper(removed)
[16:20:34.890]                 for (kk in seq_along(NAMES)) {
[16:20:34.890]                   name <- removed[[kk]]
[16:20:34.890]                   NAME <- NAMES[[kk]]
[16:20:34.890]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.890]                     next
[16:20:34.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.890]                 }
[16:20:34.890]                 if (length(args) > 0) 
[16:20:34.890]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.890]             }
[16:20:34.890]             else {
[16:20:34.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.890]             }
[16:20:34.890]             {
[16:20:34.890]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.890]                   0L) {
[16:20:34.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.890]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.890]                   base::options(opts)
[16:20:34.890]                 }
[16:20:34.890]                 {
[16:20:34.890]                   {
[16:20:34.890]                     NULL
[16:20:34.890]                     RNGkind("Mersenne-Twister")
[16:20:34.890]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.890]                       inherits = FALSE)
[16:20:34.890]                   }
[16:20:34.890]                   options(future.plan = NULL)
[16:20:34.890]                   if (is.na(NA_character_)) 
[16:20:34.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.890]                     .init = FALSE)
[16:20:34.890]                 }
[16:20:34.890]             }
[16:20:34.890]         }
[16:20:34.890]     })
[16:20:34.890]     if (TRUE) {
[16:20:34.890]         base::sink(type = "output", split = FALSE)
[16:20:34.890]         if (TRUE) {
[16:20:34.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.890]         }
[16:20:34.890]         else {
[16:20:34.890]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.890]         }
[16:20:34.890]         base::close(...future.stdout)
[16:20:34.890]         ...future.stdout <- NULL
[16:20:34.890]     }
[16:20:34.890]     ...future.result$conditions <- ...future.conditions
[16:20:34.890]     ...future.result$finished <- base::Sys.time()
[16:20:34.890]     ...future.result
[16:20:34.890] }
[16:20:34.892] plan(): Setting new future strategy stack:
[16:20:34.892] List of future strategies:
[16:20:34.892] 1. sequential:
[16:20:34.892]    - args: function (..., envir = parent.frame())
[16:20:34.892]    - tweaked: FALSE
[16:20:34.892]    - call: NULL
[16:20:34.892] plan(): nbrOfWorkers() = 1
[16:20:34.893] plan(): Setting new future strategy stack:
[16:20:34.894] List of future strategies:
[16:20:34.894] 1. sequential:
[16:20:34.894]    - args: function (..., envir = parent.frame())
[16:20:34.894]    - tweaked: FALSE
[16:20:34.894]    - call: future::plan("sequential")
[16:20:34.894] plan(): nbrOfWorkers() = 1
[16:20:34.894] SequentialFuture started (and completed)
[16:20:34.895] - Launch lazy future ... done
[16:20:34.895] run() for ‘SequentialFuture’ ... done
Future assignment evaluated
b = 2
> 
> ## The expression/value of 'a' is resolved at this point,
> ## because a delayed assignment (promise) was used.
> cat(sprintf("a = %s\n", a))
Delayed assignment evaluated
a = 1
> 
> stopifnot(identical(a, 1))
> stopifnot(identical(b, 2))
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ... DONE")
*** futureAssign() - sequential w/ lazy evaluation ... DONE
> 
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ...")
*** futureAssign() - lazy = TRUE / FALSE ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** futureAssign() with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     ## Potential task name clashes
+     u <- new.env()
+     v <- new.env()
+     futureAssign("a", { 2 }, assign.env = u)
+     futureAssign("a", { 4 }, assign.env = v)
+     
+     cat(sprintf("u$a = %s\n", u$a))
+     cat(sprintf("v$a = %s\n", v$a))
+     
+     stopifnot(identical(u$a, 2))
+     stopifnot(identical(v$a, 4))
+     
+     
+     ## Global variables
+     a <- 1
+     futureAssign("b", { 2 * a })
+     a <- 2
+     stopifnot(b == 2)
+ 
+     ## Explicit lazy evaluation
+     for (lazy in c(FALSE, TRUE)) {
+       a <- 1
+       f <- futureAssign("b", { 2 * a }, lazy = lazy)
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+       
+       ## Set 'lazy' via disposable option
+       options(future.disposable = list(lazy = lazy))
+       a <- 1
+       f <- futureAssign("b", { 2 * a })
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+     }
+ 
+     message(sprintf("*** futureAssign() with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** futureAssign() with ‘sequential’ futures ...
[16:20:34.919] plan(): Setting new future strategy stack:
[16:20:34.919] List of future strategies:
[16:20:34.919] 1. sequential:
[16:20:34.919]    - args: function (..., envir = parent.frame())
[16:20:34.919]    - tweaked: FALSE
[16:20:34.919]    - call: plan(strategy)
[16:20:34.930] plan(): nbrOfWorkers() = 1
[16:20:34.931] getGlobalsAndPackages() ...
[16:20:34.931] Searching for globals...
[16:20:34.931] - globals found: [1] ‘{’
[16:20:34.931] Searching for globals ... DONE
[16:20:34.931] Resolving globals: FALSE
[16:20:34.932] 
[16:20:34.932] 
[16:20:34.932] getGlobalsAndPackages() ... DONE
[16:20:34.932] run() for ‘Future’ ...
[16:20:34.932] - state: ‘created’
[16:20:34.932] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.933]   - Field: ‘label’
[16:20:34.933]   - Field: ‘local’
[16:20:34.933]   - Field: ‘owner’
[16:20:34.933]   - Field: ‘envir’
[16:20:34.933]   - Field: ‘packages’
[16:20:34.933]   - Field: ‘gc’
[16:20:34.933]   - Field: ‘conditions’
[16:20:34.933]   - Field: ‘expr’
[16:20:34.933]   - Field: ‘uuid’
[16:20:34.933]   - Field: ‘seed’
[16:20:34.934]   - Field: ‘version’
[16:20:34.934]   - Field: ‘result’
[16:20:34.934]   - Field: ‘asynchronous’
[16:20:34.934]   - Field: ‘calls’
[16:20:34.934]   - Field: ‘globals’
[16:20:34.934]   - Field: ‘stdout’
[16:20:34.934]   - Field: ‘earlySignal’
[16:20:34.934]   - Field: ‘lazy’
[16:20:34.934]   - Field: ‘state’
[16:20:34.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.934] - Launch lazy future ...
[16:20:34.935] Packages needed by the future expression (n = 0): <none>
[16:20:34.935] Packages needed by future strategies (n = 0): <none>
[16:20:34.935] {
[16:20:34.935]     {
[16:20:34.935]         {
[16:20:34.935]             ...future.startTime <- base::Sys.time()
[16:20:34.935]             {
[16:20:34.935]                 {
[16:20:34.935]                   {
[16:20:34.935]                     base::local({
[16:20:34.935]                       has_future <- base::requireNamespace("future", 
[16:20:34.935]                         quietly = TRUE)
[16:20:34.935]                       if (has_future) {
[16:20:34.935]                         ns <- base::getNamespace("future")
[16:20:34.935]                         version <- ns[[".package"]][["version"]]
[16:20:34.935]                         if (is.null(version)) 
[16:20:34.935]                           version <- utils::packageVersion("future")
[16:20:34.935]                       }
[16:20:34.935]                       else {
[16:20:34.935]                         version <- NULL
[16:20:34.935]                       }
[16:20:34.935]                       if (!has_future || version < "1.8.0") {
[16:20:34.935]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.935]                           "", base::R.version$version.string), 
[16:20:34.935]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.935]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.935]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.935]                             "release", "version")], collapse = " "), 
[16:20:34.935]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.935]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.935]                           info)
[16:20:34.935]                         info <- base::paste(info, collapse = "; ")
[16:20:34.935]                         if (!has_future) {
[16:20:34.935]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.935]                             info)
[16:20:34.935]                         }
[16:20:34.935]                         else {
[16:20:34.935]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.935]                             info, version)
[16:20:34.935]                         }
[16:20:34.935]                         base::stop(msg)
[16:20:34.935]                       }
[16:20:34.935]                     })
[16:20:34.935]                   }
[16:20:34.935]                   ...future.strategy.old <- future::plan("list")
[16:20:34.935]                   options(future.plan = NULL)
[16:20:34.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.935]                 }
[16:20:34.935]                 ...future.workdir <- getwd()
[16:20:34.935]             }
[16:20:34.935]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.935]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.935]         }
[16:20:34.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.935]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.935]             base::names(...future.oldOptions))
[16:20:34.935]     }
[16:20:34.935]     if (FALSE) {
[16:20:34.935]     }
[16:20:34.935]     else {
[16:20:34.935]         if (TRUE) {
[16:20:34.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.935]                 open = "w")
[16:20:34.935]         }
[16:20:34.935]         else {
[16:20:34.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.935]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.935]         }
[16:20:34.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.935]             base::sink(type = "output", split = FALSE)
[16:20:34.935]             base::close(...future.stdout)
[16:20:34.935]         }, add = TRUE)
[16:20:34.935]     }
[16:20:34.935]     ...future.frame <- base::sys.nframe()
[16:20:34.935]     ...future.conditions <- base::list()
[16:20:34.935]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.935]     if (FALSE) {
[16:20:34.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.935]     }
[16:20:34.935]     ...future.result <- base::tryCatch({
[16:20:34.935]         base::withCallingHandlers({
[16:20:34.935]             ...future.value <- base::withVisible(base::local({
[16:20:34.935]                 2
[16:20:34.935]             }))
[16:20:34.935]             future::FutureResult(value = ...future.value$value, 
[16:20:34.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.935]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.935]                     ...future.globalenv.names))
[16:20:34.935]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.935]         }, condition = base::local({
[16:20:34.935]             c <- base::c
[16:20:34.935]             inherits <- base::inherits
[16:20:34.935]             invokeRestart <- base::invokeRestart
[16:20:34.935]             length <- base::length
[16:20:34.935]             list <- base::list
[16:20:34.935]             seq.int <- base::seq.int
[16:20:34.935]             signalCondition <- base::signalCondition
[16:20:34.935]             sys.calls <- base::sys.calls
[16:20:34.935]             `[[` <- base::`[[`
[16:20:34.935]             `+` <- base::`+`
[16:20:34.935]             `<<-` <- base::`<<-`
[16:20:34.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.935]                   3L)]
[16:20:34.935]             }
[16:20:34.935]             function(cond) {
[16:20:34.935]                 is_error <- inherits(cond, "error")
[16:20:34.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.935]                   NULL)
[16:20:34.935]                 if (is_error) {
[16:20:34.935]                   sessionInformation <- function() {
[16:20:34.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.935]                       search = base::search(), system = base::Sys.info())
[16:20:34.935]                   }
[16:20:34.935]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.935]                     cond$call), session = sessionInformation(), 
[16:20:34.935]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.935]                   signalCondition(cond)
[16:20:34.935]                 }
[16:20:34.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.935]                 "immediateCondition"))) {
[16:20:34.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.935]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.935]                   if (TRUE && !signal) {
[16:20:34.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.935]                     {
[16:20:34.935]                       inherits <- base::inherits
[16:20:34.935]                       invokeRestart <- base::invokeRestart
[16:20:34.935]                       is.null <- base::is.null
[16:20:34.935]                       muffled <- FALSE
[16:20:34.935]                       if (inherits(cond, "message")) {
[16:20:34.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.935]                         if (muffled) 
[16:20:34.935]                           invokeRestart("muffleMessage")
[16:20:34.935]                       }
[16:20:34.935]                       else if (inherits(cond, "warning")) {
[16:20:34.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.935]                         if (muffled) 
[16:20:34.935]                           invokeRestart("muffleWarning")
[16:20:34.935]                       }
[16:20:34.935]                       else if (inherits(cond, "condition")) {
[16:20:34.935]                         if (!is.null(pattern)) {
[16:20:34.935]                           computeRestarts <- base::computeRestarts
[16:20:34.935]                           grepl <- base::grepl
[16:20:34.935]                           restarts <- computeRestarts(cond)
[16:20:34.935]                           for (restart in restarts) {
[16:20:34.935]                             name <- restart$name
[16:20:34.935]                             if (is.null(name)) 
[16:20:34.935]                               next
[16:20:34.935]                             if (!grepl(pattern, name)) 
[16:20:34.935]                               next
[16:20:34.935]                             invokeRestart(restart)
[16:20:34.935]                             muffled <- TRUE
[16:20:34.935]                             break
[16:20:34.935]                           }
[16:20:34.935]                         }
[16:20:34.935]                       }
[16:20:34.935]                       invisible(muffled)
[16:20:34.935]                     }
[16:20:34.935]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.935]                   }
[16:20:34.935]                 }
[16:20:34.935]                 else {
[16:20:34.935]                   if (TRUE) {
[16:20:34.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.935]                     {
[16:20:34.935]                       inherits <- base::inherits
[16:20:34.935]                       invokeRestart <- base::invokeRestart
[16:20:34.935]                       is.null <- base::is.null
[16:20:34.935]                       muffled <- FALSE
[16:20:34.935]                       if (inherits(cond, "message")) {
[16:20:34.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.935]                         if (muffled) 
[16:20:34.935]                           invokeRestart("muffleMessage")
[16:20:34.935]                       }
[16:20:34.935]                       else if (inherits(cond, "warning")) {
[16:20:34.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.935]                         if (muffled) 
[16:20:34.935]                           invokeRestart("muffleWarning")
[16:20:34.935]                       }
[16:20:34.935]                       else if (inherits(cond, "condition")) {
[16:20:34.935]                         if (!is.null(pattern)) {
[16:20:34.935]                           computeRestarts <- base::computeRestarts
[16:20:34.935]                           grepl <- base::grepl
[16:20:34.935]                           restarts <- computeRestarts(cond)
[16:20:34.935]                           for (restart in restarts) {
[16:20:34.935]                             name <- restart$name
[16:20:34.935]                             if (is.null(name)) 
[16:20:34.935]                               next
[16:20:34.935]                             if (!grepl(pattern, name)) 
[16:20:34.935]                               next
[16:20:34.935]                             invokeRestart(restart)
[16:20:34.935]                             muffled <- TRUE
[16:20:34.935]                             break
[16:20:34.935]                           }
[16:20:34.935]                         }
[16:20:34.935]                       }
[16:20:34.935]                       invisible(muffled)
[16:20:34.935]                     }
[16:20:34.935]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.935]                   }
[16:20:34.935]                 }
[16:20:34.935]             }
[16:20:34.935]         }))
[16:20:34.935]     }, error = function(ex) {
[16:20:34.935]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.935]                 ...future.rng), started = ...future.startTime, 
[16:20:34.935]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.935]             version = "1.8"), class = "FutureResult")
[16:20:34.935]     }, finally = {
[16:20:34.935]         if (!identical(...future.workdir, getwd())) 
[16:20:34.935]             setwd(...future.workdir)
[16:20:34.935]         {
[16:20:34.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.935]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.935]             }
[16:20:34.935]             base::options(...future.oldOptions)
[16:20:34.935]             if (.Platform$OS.type == "windows") {
[16:20:34.935]                 old_names <- names(...future.oldEnvVars)
[16:20:34.935]                 envs <- base::Sys.getenv()
[16:20:34.935]                 names <- names(envs)
[16:20:34.935]                 common <- intersect(names, old_names)
[16:20:34.935]                 added <- setdiff(names, old_names)
[16:20:34.935]                 removed <- setdiff(old_names, names)
[16:20:34.935]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.935]                   envs[common]]
[16:20:34.935]                 NAMES <- toupper(changed)
[16:20:34.935]                 args <- list()
[16:20:34.935]                 for (kk in seq_along(NAMES)) {
[16:20:34.935]                   name <- changed[[kk]]
[16:20:34.935]                   NAME <- NAMES[[kk]]
[16:20:34.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.935]                     next
[16:20:34.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.935]                 }
[16:20:34.935]                 NAMES <- toupper(added)
[16:20:34.935]                 for (kk in seq_along(NAMES)) {
[16:20:34.935]                   name <- added[[kk]]
[16:20:34.935]                   NAME <- NAMES[[kk]]
[16:20:34.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.935]                     next
[16:20:34.935]                   args[[name]] <- ""
[16:20:34.935]                 }
[16:20:34.935]                 NAMES <- toupper(removed)
[16:20:34.935]                 for (kk in seq_along(NAMES)) {
[16:20:34.935]                   name <- removed[[kk]]
[16:20:34.935]                   NAME <- NAMES[[kk]]
[16:20:34.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.935]                     next
[16:20:34.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.935]                 }
[16:20:34.935]                 if (length(args) > 0) 
[16:20:34.935]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.935]             }
[16:20:34.935]             else {
[16:20:34.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.935]             }
[16:20:34.935]             {
[16:20:34.935]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.935]                   0L) {
[16:20:34.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.935]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.935]                   base::options(opts)
[16:20:34.935]                 }
[16:20:34.935]                 {
[16:20:34.935]                   {
[16:20:34.935]                     NULL
[16:20:34.935]                     RNGkind("Mersenne-Twister")
[16:20:34.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.935]                       inherits = FALSE)
[16:20:34.935]                   }
[16:20:34.935]                   options(future.plan = NULL)
[16:20:34.935]                   if (is.na(NA_character_)) 
[16:20:34.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.935]                     .init = FALSE)
[16:20:34.935]                 }
[16:20:34.935]             }
[16:20:34.935]         }
[16:20:34.935]     })
[16:20:34.935]     if (TRUE) {
[16:20:34.935]         base::sink(type = "output", split = FALSE)
[16:20:34.935]         if (TRUE) {
[16:20:34.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.935]         }
[16:20:34.935]         else {
[16:20:34.935]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.935]         }
[16:20:34.935]         base::close(...future.stdout)
[16:20:34.935]         ...future.stdout <- NULL
[16:20:34.935]     }
[16:20:34.935]     ...future.result$conditions <- ...future.conditions
[16:20:34.935]     ...future.result$finished <- base::Sys.time()
[16:20:34.935]     ...future.result
[16:20:34.935] }
[16:20:34.937] plan(): Setting new future strategy stack:
[16:20:34.937] List of future strategies:
[16:20:34.937] 1. sequential:
[16:20:34.937]    - args: function (..., envir = parent.frame())
[16:20:34.937]    - tweaked: FALSE
[16:20:34.937]    - call: NULL
[16:20:34.937] plan(): nbrOfWorkers() = 1
[16:20:34.938] plan(): Setting new future strategy stack:
[16:20:34.938] List of future strategies:
[16:20:34.938] 1. sequential:
[16:20:34.938]    - args: function (..., envir = parent.frame())
[16:20:34.938]    - tweaked: FALSE
[16:20:34.938]    - call: plan(strategy)
[16:20:34.938] plan(): nbrOfWorkers() = 1
[16:20:34.938] SequentialFuture started (and completed)
[16:20:34.938] - Launch lazy future ... done
[16:20:34.939] run() for ‘SequentialFuture’ ... done
[16:20:34.939] getGlobalsAndPackages() ...
[16:20:34.939] Searching for globals...
[16:20:34.939] - globals found: [1] ‘{’
[16:20:34.939] Searching for globals ... DONE
[16:20:34.940] Resolving globals: FALSE
[16:20:34.940] 
[16:20:34.940] 
[16:20:34.940] getGlobalsAndPackages() ... DONE
[16:20:34.940] run() for ‘Future’ ...
[16:20:34.940] - state: ‘created’
[16:20:34.940] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.941]   - Field: ‘label’
[16:20:34.941]   - Field: ‘local’
[16:20:34.941]   - Field: ‘owner’
[16:20:34.941]   - Field: ‘envir’
[16:20:34.941]   - Field: ‘packages’
[16:20:34.941]   - Field: ‘gc’
[16:20:34.941]   - Field: ‘conditions’
[16:20:34.941]   - Field: ‘expr’
[16:20:34.941]   - Field: ‘uuid’
[16:20:34.942]   - Field: ‘seed’
[16:20:34.942]   - Field: ‘version’
[16:20:34.942]   - Field: ‘result’
[16:20:34.942]   - Field: ‘asynchronous’
[16:20:34.942]   - Field: ‘calls’
[16:20:34.942]   - Field: ‘globals’
[16:20:34.942]   - Field: ‘stdout’
[16:20:34.942]   - Field: ‘earlySignal’
[16:20:34.942]   - Field: ‘lazy’
[16:20:34.942]   - Field: ‘state’
[16:20:34.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.943] - Launch lazy future ...
[16:20:34.943] Packages needed by the future expression (n = 0): <none>
[16:20:34.943] Packages needed by future strategies (n = 0): <none>
[16:20:34.943] {
[16:20:34.943]     {
[16:20:34.943]         {
[16:20:34.943]             ...future.startTime <- base::Sys.time()
[16:20:34.943]             {
[16:20:34.943]                 {
[16:20:34.943]                   {
[16:20:34.943]                     base::local({
[16:20:34.943]                       has_future <- base::requireNamespace("future", 
[16:20:34.943]                         quietly = TRUE)
[16:20:34.943]                       if (has_future) {
[16:20:34.943]                         ns <- base::getNamespace("future")
[16:20:34.943]                         version <- ns[[".package"]][["version"]]
[16:20:34.943]                         if (is.null(version)) 
[16:20:34.943]                           version <- utils::packageVersion("future")
[16:20:34.943]                       }
[16:20:34.943]                       else {
[16:20:34.943]                         version <- NULL
[16:20:34.943]                       }
[16:20:34.943]                       if (!has_future || version < "1.8.0") {
[16:20:34.943]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.943]                           "", base::R.version$version.string), 
[16:20:34.943]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.943]                             "release", "version")], collapse = " "), 
[16:20:34.943]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.943]                           info)
[16:20:34.943]                         info <- base::paste(info, collapse = "; ")
[16:20:34.943]                         if (!has_future) {
[16:20:34.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.943]                             info)
[16:20:34.943]                         }
[16:20:34.943]                         else {
[16:20:34.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.943]                             info, version)
[16:20:34.943]                         }
[16:20:34.943]                         base::stop(msg)
[16:20:34.943]                       }
[16:20:34.943]                     })
[16:20:34.943]                   }
[16:20:34.943]                   ...future.strategy.old <- future::plan("list")
[16:20:34.943]                   options(future.plan = NULL)
[16:20:34.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.943]                 }
[16:20:34.943]                 ...future.workdir <- getwd()
[16:20:34.943]             }
[16:20:34.943]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.943]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.943]         }
[16:20:34.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.943]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.943]             base::names(...future.oldOptions))
[16:20:34.943]     }
[16:20:34.943]     if (FALSE) {
[16:20:34.943]     }
[16:20:34.943]     else {
[16:20:34.943]         if (TRUE) {
[16:20:34.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.943]                 open = "w")
[16:20:34.943]         }
[16:20:34.943]         else {
[16:20:34.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.943]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.943]         }
[16:20:34.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.943]             base::sink(type = "output", split = FALSE)
[16:20:34.943]             base::close(...future.stdout)
[16:20:34.943]         }, add = TRUE)
[16:20:34.943]     }
[16:20:34.943]     ...future.frame <- base::sys.nframe()
[16:20:34.943]     ...future.conditions <- base::list()
[16:20:34.943]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.943]     if (FALSE) {
[16:20:34.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.943]     }
[16:20:34.943]     ...future.result <- base::tryCatch({
[16:20:34.943]         base::withCallingHandlers({
[16:20:34.943]             ...future.value <- base::withVisible(base::local({
[16:20:34.943]                 4
[16:20:34.943]             }))
[16:20:34.943]             future::FutureResult(value = ...future.value$value, 
[16:20:34.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.943]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.943]                     ...future.globalenv.names))
[16:20:34.943]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.943]         }, condition = base::local({
[16:20:34.943]             c <- base::c
[16:20:34.943]             inherits <- base::inherits
[16:20:34.943]             invokeRestart <- base::invokeRestart
[16:20:34.943]             length <- base::length
[16:20:34.943]             list <- base::list
[16:20:34.943]             seq.int <- base::seq.int
[16:20:34.943]             signalCondition <- base::signalCondition
[16:20:34.943]             sys.calls <- base::sys.calls
[16:20:34.943]             `[[` <- base::`[[`
[16:20:34.943]             `+` <- base::`+`
[16:20:34.943]             `<<-` <- base::`<<-`
[16:20:34.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.943]                   3L)]
[16:20:34.943]             }
[16:20:34.943]             function(cond) {
[16:20:34.943]                 is_error <- inherits(cond, "error")
[16:20:34.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.943]                   NULL)
[16:20:34.943]                 if (is_error) {
[16:20:34.943]                   sessionInformation <- function() {
[16:20:34.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.943]                       search = base::search(), system = base::Sys.info())
[16:20:34.943]                   }
[16:20:34.943]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.943]                     cond$call), session = sessionInformation(), 
[16:20:34.943]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.943]                   signalCondition(cond)
[16:20:34.943]                 }
[16:20:34.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.943]                 "immediateCondition"))) {
[16:20:34.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.943]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.943]                   if (TRUE && !signal) {
[16:20:34.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.943]                     {
[16:20:34.943]                       inherits <- base::inherits
[16:20:34.943]                       invokeRestart <- base::invokeRestart
[16:20:34.943]                       is.null <- base::is.null
[16:20:34.943]                       muffled <- FALSE
[16:20:34.943]                       if (inherits(cond, "message")) {
[16:20:34.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.943]                         if (muffled) 
[16:20:34.943]                           invokeRestart("muffleMessage")
[16:20:34.943]                       }
[16:20:34.943]                       else if (inherits(cond, "warning")) {
[16:20:34.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.943]                         if (muffled) 
[16:20:34.943]                           invokeRestart("muffleWarning")
[16:20:34.943]                       }
[16:20:34.943]                       else if (inherits(cond, "condition")) {
[16:20:34.943]                         if (!is.null(pattern)) {
[16:20:34.943]                           computeRestarts <- base::computeRestarts
[16:20:34.943]                           grepl <- base::grepl
[16:20:34.943]                           restarts <- computeRestarts(cond)
[16:20:34.943]                           for (restart in restarts) {
[16:20:34.943]                             name <- restart$name
[16:20:34.943]                             if (is.null(name)) 
[16:20:34.943]                               next
[16:20:34.943]                             if (!grepl(pattern, name)) 
[16:20:34.943]                               next
[16:20:34.943]                             invokeRestart(restart)
[16:20:34.943]                             muffled <- TRUE
[16:20:34.943]                             break
[16:20:34.943]                           }
[16:20:34.943]                         }
[16:20:34.943]                       }
[16:20:34.943]                       invisible(muffled)
[16:20:34.943]                     }
[16:20:34.943]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.943]                   }
[16:20:34.943]                 }
[16:20:34.943]                 else {
[16:20:34.943]                   if (TRUE) {
[16:20:34.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.943]                     {
[16:20:34.943]                       inherits <- base::inherits
[16:20:34.943]                       invokeRestart <- base::invokeRestart
[16:20:34.943]                       is.null <- base::is.null
[16:20:34.943]                       muffled <- FALSE
[16:20:34.943]                       if (inherits(cond, "message")) {
[16:20:34.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.943]                         if (muffled) 
[16:20:34.943]                           invokeRestart("muffleMessage")
[16:20:34.943]                       }
[16:20:34.943]                       else if (inherits(cond, "warning")) {
[16:20:34.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.943]                         if (muffled) 
[16:20:34.943]                           invokeRestart("muffleWarning")
[16:20:34.943]                       }
[16:20:34.943]                       else if (inherits(cond, "condition")) {
[16:20:34.943]                         if (!is.null(pattern)) {
[16:20:34.943]                           computeRestarts <- base::computeRestarts
[16:20:34.943]                           grepl <- base::grepl
[16:20:34.943]                           restarts <- computeRestarts(cond)
[16:20:34.943]                           for (restart in restarts) {
[16:20:34.943]                             name <- restart$name
[16:20:34.943]                             if (is.null(name)) 
[16:20:34.943]                               next
[16:20:34.943]                             if (!grepl(pattern, name)) 
[16:20:34.943]                               next
[16:20:34.943]                             invokeRestart(restart)
[16:20:34.943]                             muffled <- TRUE
[16:20:34.943]                             break
[16:20:34.943]                           }
[16:20:34.943]                         }
[16:20:34.943]                       }
[16:20:34.943]                       invisible(muffled)
[16:20:34.943]                     }
[16:20:34.943]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.943]                   }
[16:20:34.943]                 }
[16:20:34.943]             }
[16:20:34.943]         }))
[16:20:34.943]     }, error = function(ex) {
[16:20:34.943]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.943]                 ...future.rng), started = ...future.startTime, 
[16:20:34.943]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.943]             version = "1.8"), class = "FutureResult")
[16:20:34.943]     }, finally = {
[16:20:34.943]         if (!identical(...future.workdir, getwd())) 
[16:20:34.943]             setwd(...future.workdir)
[16:20:34.943]         {
[16:20:34.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.943]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.943]             }
[16:20:34.943]             base::options(...future.oldOptions)
[16:20:34.943]             if (.Platform$OS.type == "windows") {
[16:20:34.943]                 old_names <- names(...future.oldEnvVars)
[16:20:34.943]                 envs <- base::Sys.getenv()
[16:20:34.943]                 names <- names(envs)
[16:20:34.943]                 common <- intersect(names, old_names)
[16:20:34.943]                 added <- setdiff(names, old_names)
[16:20:34.943]                 removed <- setdiff(old_names, names)
[16:20:34.943]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.943]                   envs[common]]
[16:20:34.943]                 NAMES <- toupper(changed)
[16:20:34.943]                 args <- list()
[16:20:34.943]                 for (kk in seq_along(NAMES)) {
[16:20:34.943]                   name <- changed[[kk]]
[16:20:34.943]                   NAME <- NAMES[[kk]]
[16:20:34.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.943]                     next
[16:20:34.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.943]                 }
[16:20:34.943]                 NAMES <- toupper(added)
[16:20:34.943]                 for (kk in seq_along(NAMES)) {
[16:20:34.943]                   name <- added[[kk]]
[16:20:34.943]                   NAME <- NAMES[[kk]]
[16:20:34.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.943]                     next
[16:20:34.943]                   args[[name]] <- ""
[16:20:34.943]                 }
[16:20:34.943]                 NAMES <- toupper(removed)
[16:20:34.943]                 for (kk in seq_along(NAMES)) {
[16:20:34.943]                   name <- removed[[kk]]
[16:20:34.943]                   NAME <- NAMES[[kk]]
[16:20:34.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.943]                     next
[16:20:34.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.943]                 }
[16:20:34.943]                 if (length(args) > 0) 
[16:20:34.943]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.943]             }
[16:20:34.943]             else {
[16:20:34.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.943]             }
[16:20:34.943]             {
[16:20:34.943]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.943]                   0L) {
[16:20:34.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.943]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.943]                   base::options(opts)
[16:20:34.943]                 }
[16:20:34.943]                 {
[16:20:34.943]                   {
[16:20:34.943]                     NULL
[16:20:34.943]                     RNGkind("Mersenne-Twister")
[16:20:34.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.943]                       inherits = FALSE)
[16:20:34.943]                   }
[16:20:34.943]                   options(future.plan = NULL)
[16:20:34.943]                   if (is.na(NA_character_)) 
[16:20:34.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.943]                     .init = FALSE)
[16:20:34.943]                 }
[16:20:34.943]             }
[16:20:34.943]         }
[16:20:34.943]     })
[16:20:34.943]     if (TRUE) {
[16:20:34.943]         base::sink(type = "output", split = FALSE)
[16:20:34.943]         if (TRUE) {
[16:20:34.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.943]         }
[16:20:34.943]         else {
[16:20:34.943]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.943]         }
[16:20:34.943]         base::close(...future.stdout)
[16:20:34.943]         ...future.stdout <- NULL
[16:20:34.943]     }
[16:20:34.943]     ...future.result$conditions <- ...future.conditions
[16:20:34.943]     ...future.result$finished <- base::Sys.time()
[16:20:34.943]     ...future.result
[16:20:34.943] }
[16:20:34.945] plan(): Setting new future strategy stack:
[16:20:34.945] List of future strategies:
[16:20:34.945] 1. sequential:
[16:20:34.945]    - args: function (..., envir = parent.frame())
[16:20:34.945]    - tweaked: FALSE
[16:20:34.945]    - call: NULL
[16:20:34.945] plan(): nbrOfWorkers() = 1
[16:20:34.946] plan(): Setting new future strategy stack:
[16:20:34.946] List of future strategies:
[16:20:34.946] 1. sequential:
[16:20:34.946]    - args: function (..., envir = parent.frame())
[16:20:34.946]    - tweaked: FALSE
[16:20:34.946]    - call: plan(strategy)
[16:20:34.946] plan(): nbrOfWorkers() = 1
[16:20:34.946] SequentialFuture started (and completed)
[16:20:34.947] - Launch lazy future ... done
[16:20:34.947] run() for ‘SequentialFuture’ ... done
u$a = 2
v$a = 4
[16:20:34.947] getGlobalsAndPackages() ...
[16:20:34.947] Searching for globals...
[16:20:34.948] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:34.948] Searching for globals ... DONE
[16:20:34.948] Resolving globals: FALSE
[16:20:34.949] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.949] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:34.949] - globals: [1] ‘a’
[16:20:34.949] 
[16:20:34.949] getGlobalsAndPackages() ... DONE
[16:20:34.950] run() for ‘Future’ ...
[16:20:34.950] - state: ‘created’
[16:20:34.950] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.950] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.950]   - Field: ‘label’
[16:20:34.951]   - Field: ‘local’
[16:20:34.951]   - Field: ‘owner’
[16:20:34.951]   - Field: ‘envir’
[16:20:34.951]   - Field: ‘packages’
[16:20:34.951]   - Field: ‘gc’
[16:20:34.951]   - Field: ‘conditions’
[16:20:34.951]   - Field: ‘expr’
[16:20:34.951]   - Field: ‘uuid’
[16:20:34.951]   - Field: ‘seed’
[16:20:34.951]   - Field: ‘version’
[16:20:34.951]   - Field: ‘result’
[16:20:34.951]   - Field: ‘asynchronous’
[16:20:34.952]   - Field: ‘calls’
[16:20:34.952]   - Field: ‘globals’
[16:20:34.952]   - Field: ‘stdout’
[16:20:34.952]   - Field: ‘earlySignal’
[16:20:34.952]   - Field: ‘lazy’
[16:20:34.952]   - Field: ‘state’
[16:20:34.952] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.952] - Launch lazy future ...
[16:20:34.952] Packages needed by the future expression (n = 0): <none>
[16:20:34.952] Packages needed by future strategies (n = 0): <none>
[16:20:34.953] {
[16:20:34.953]     {
[16:20:34.953]         {
[16:20:34.953]             ...future.startTime <- base::Sys.time()
[16:20:34.953]             {
[16:20:34.953]                 {
[16:20:34.953]                   {
[16:20:34.953]                     base::local({
[16:20:34.953]                       has_future <- base::requireNamespace("future", 
[16:20:34.953]                         quietly = TRUE)
[16:20:34.953]                       if (has_future) {
[16:20:34.953]                         ns <- base::getNamespace("future")
[16:20:34.953]                         version <- ns[[".package"]][["version"]]
[16:20:34.953]                         if (is.null(version)) 
[16:20:34.953]                           version <- utils::packageVersion("future")
[16:20:34.953]                       }
[16:20:34.953]                       else {
[16:20:34.953]                         version <- NULL
[16:20:34.953]                       }
[16:20:34.953]                       if (!has_future || version < "1.8.0") {
[16:20:34.953]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.953]                           "", base::R.version$version.string), 
[16:20:34.953]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.953]                             "release", "version")], collapse = " "), 
[16:20:34.953]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.953]                           info)
[16:20:34.953]                         info <- base::paste(info, collapse = "; ")
[16:20:34.953]                         if (!has_future) {
[16:20:34.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.953]                             info)
[16:20:34.953]                         }
[16:20:34.953]                         else {
[16:20:34.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.953]                             info, version)
[16:20:34.953]                         }
[16:20:34.953]                         base::stop(msg)
[16:20:34.953]                       }
[16:20:34.953]                     })
[16:20:34.953]                   }
[16:20:34.953]                   ...future.strategy.old <- future::plan("list")
[16:20:34.953]                   options(future.plan = NULL)
[16:20:34.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.953]                 }
[16:20:34.953]                 ...future.workdir <- getwd()
[16:20:34.953]             }
[16:20:34.953]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.953]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.953]         }
[16:20:34.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.953]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.953]             base::names(...future.oldOptions))
[16:20:34.953]     }
[16:20:34.953]     if (FALSE) {
[16:20:34.953]     }
[16:20:34.953]     else {
[16:20:34.953]         if (TRUE) {
[16:20:34.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.953]                 open = "w")
[16:20:34.953]         }
[16:20:34.953]         else {
[16:20:34.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.953]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.953]         }
[16:20:34.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.953]             base::sink(type = "output", split = FALSE)
[16:20:34.953]             base::close(...future.stdout)
[16:20:34.953]         }, add = TRUE)
[16:20:34.953]     }
[16:20:34.953]     ...future.frame <- base::sys.nframe()
[16:20:34.953]     ...future.conditions <- base::list()
[16:20:34.953]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.953]     if (FALSE) {
[16:20:34.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.953]     }
[16:20:34.953]     ...future.result <- base::tryCatch({
[16:20:34.953]         base::withCallingHandlers({
[16:20:34.953]             ...future.value <- base::withVisible(base::local({
[16:20:34.953]                 2 * a
[16:20:34.953]             }))
[16:20:34.953]             future::FutureResult(value = ...future.value$value, 
[16:20:34.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.953]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.953]                     ...future.globalenv.names))
[16:20:34.953]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.953]         }, condition = base::local({
[16:20:34.953]             c <- base::c
[16:20:34.953]             inherits <- base::inherits
[16:20:34.953]             invokeRestart <- base::invokeRestart
[16:20:34.953]             length <- base::length
[16:20:34.953]             list <- base::list
[16:20:34.953]             seq.int <- base::seq.int
[16:20:34.953]             signalCondition <- base::signalCondition
[16:20:34.953]             sys.calls <- base::sys.calls
[16:20:34.953]             `[[` <- base::`[[`
[16:20:34.953]             `+` <- base::`+`
[16:20:34.953]             `<<-` <- base::`<<-`
[16:20:34.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.953]                   3L)]
[16:20:34.953]             }
[16:20:34.953]             function(cond) {
[16:20:34.953]                 is_error <- inherits(cond, "error")
[16:20:34.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.953]                   NULL)
[16:20:34.953]                 if (is_error) {
[16:20:34.953]                   sessionInformation <- function() {
[16:20:34.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.953]                       search = base::search(), system = base::Sys.info())
[16:20:34.953]                   }
[16:20:34.953]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.953]                     cond$call), session = sessionInformation(), 
[16:20:34.953]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.953]                   signalCondition(cond)
[16:20:34.953]                 }
[16:20:34.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.953]                 "immediateCondition"))) {
[16:20:34.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.953]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.953]                   if (TRUE && !signal) {
[16:20:34.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.953]                     {
[16:20:34.953]                       inherits <- base::inherits
[16:20:34.953]                       invokeRestart <- base::invokeRestart
[16:20:34.953]                       is.null <- base::is.null
[16:20:34.953]                       muffled <- FALSE
[16:20:34.953]                       if (inherits(cond, "message")) {
[16:20:34.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.953]                         if (muffled) 
[16:20:34.953]                           invokeRestart("muffleMessage")
[16:20:34.953]                       }
[16:20:34.953]                       else if (inherits(cond, "warning")) {
[16:20:34.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.953]                         if (muffled) 
[16:20:34.953]                           invokeRestart("muffleWarning")
[16:20:34.953]                       }
[16:20:34.953]                       else if (inherits(cond, "condition")) {
[16:20:34.953]                         if (!is.null(pattern)) {
[16:20:34.953]                           computeRestarts <- base::computeRestarts
[16:20:34.953]                           grepl <- base::grepl
[16:20:34.953]                           restarts <- computeRestarts(cond)
[16:20:34.953]                           for (restart in restarts) {
[16:20:34.953]                             name <- restart$name
[16:20:34.953]                             if (is.null(name)) 
[16:20:34.953]                               next
[16:20:34.953]                             if (!grepl(pattern, name)) 
[16:20:34.953]                               next
[16:20:34.953]                             invokeRestart(restart)
[16:20:34.953]                             muffled <- TRUE
[16:20:34.953]                             break
[16:20:34.953]                           }
[16:20:34.953]                         }
[16:20:34.953]                       }
[16:20:34.953]                       invisible(muffled)
[16:20:34.953]                     }
[16:20:34.953]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.953]                   }
[16:20:34.953]                 }
[16:20:34.953]                 else {
[16:20:34.953]                   if (TRUE) {
[16:20:34.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.953]                     {
[16:20:34.953]                       inherits <- base::inherits
[16:20:34.953]                       invokeRestart <- base::invokeRestart
[16:20:34.953]                       is.null <- base::is.null
[16:20:34.953]                       muffled <- FALSE
[16:20:34.953]                       if (inherits(cond, "message")) {
[16:20:34.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.953]                         if (muffled) 
[16:20:34.953]                           invokeRestart("muffleMessage")
[16:20:34.953]                       }
[16:20:34.953]                       else if (inherits(cond, "warning")) {
[16:20:34.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.953]                         if (muffled) 
[16:20:34.953]                           invokeRestart("muffleWarning")
[16:20:34.953]                       }
[16:20:34.953]                       else if (inherits(cond, "condition")) {
[16:20:34.953]                         if (!is.null(pattern)) {
[16:20:34.953]                           computeRestarts <- base::computeRestarts
[16:20:34.953]                           grepl <- base::grepl
[16:20:34.953]                           restarts <- computeRestarts(cond)
[16:20:34.953]                           for (restart in restarts) {
[16:20:34.953]                             name <- restart$name
[16:20:34.953]                             if (is.null(name)) 
[16:20:34.953]                               next
[16:20:34.953]                             if (!grepl(pattern, name)) 
[16:20:34.953]                               next
[16:20:34.953]                             invokeRestart(restart)
[16:20:34.953]                             muffled <- TRUE
[16:20:34.953]                             break
[16:20:34.953]                           }
[16:20:34.953]                         }
[16:20:34.953]                       }
[16:20:34.953]                       invisible(muffled)
[16:20:34.953]                     }
[16:20:34.953]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.953]                   }
[16:20:34.953]                 }
[16:20:34.953]             }
[16:20:34.953]         }))
[16:20:34.953]     }, error = function(ex) {
[16:20:34.953]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.953]                 ...future.rng), started = ...future.startTime, 
[16:20:34.953]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.953]             version = "1.8"), class = "FutureResult")
[16:20:34.953]     }, finally = {
[16:20:34.953]         if (!identical(...future.workdir, getwd())) 
[16:20:34.953]             setwd(...future.workdir)
[16:20:34.953]         {
[16:20:34.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.953]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.953]             }
[16:20:34.953]             base::options(...future.oldOptions)
[16:20:34.953]             if (.Platform$OS.type == "windows") {
[16:20:34.953]                 old_names <- names(...future.oldEnvVars)
[16:20:34.953]                 envs <- base::Sys.getenv()
[16:20:34.953]                 names <- names(envs)
[16:20:34.953]                 common <- intersect(names, old_names)
[16:20:34.953]                 added <- setdiff(names, old_names)
[16:20:34.953]                 removed <- setdiff(old_names, names)
[16:20:34.953]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.953]                   envs[common]]
[16:20:34.953]                 NAMES <- toupper(changed)
[16:20:34.953]                 args <- list()
[16:20:34.953]                 for (kk in seq_along(NAMES)) {
[16:20:34.953]                   name <- changed[[kk]]
[16:20:34.953]                   NAME <- NAMES[[kk]]
[16:20:34.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.953]                     next
[16:20:34.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.953]                 }
[16:20:34.953]                 NAMES <- toupper(added)
[16:20:34.953]                 for (kk in seq_along(NAMES)) {
[16:20:34.953]                   name <- added[[kk]]
[16:20:34.953]                   NAME <- NAMES[[kk]]
[16:20:34.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.953]                     next
[16:20:34.953]                   args[[name]] <- ""
[16:20:34.953]                 }
[16:20:34.953]                 NAMES <- toupper(removed)
[16:20:34.953]                 for (kk in seq_along(NAMES)) {
[16:20:34.953]                   name <- removed[[kk]]
[16:20:34.953]                   NAME <- NAMES[[kk]]
[16:20:34.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.953]                     next
[16:20:34.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.953]                 }
[16:20:34.953]                 if (length(args) > 0) 
[16:20:34.953]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.953]             }
[16:20:34.953]             else {
[16:20:34.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.953]             }
[16:20:34.953]             {
[16:20:34.953]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.953]                   0L) {
[16:20:34.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.953]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.953]                   base::options(opts)
[16:20:34.953]                 }
[16:20:34.953]                 {
[16:20:34.953]                   {
[16:20:34.953]                     NULL
[16:20:34.953]                     RNGkind("Mersenne-Twister")
[16:20:34.953]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.953]                       inherits = FALSE)
[16:20:34.953]                   }
[16:20:34.953]                   options(future.plan = NULL)
[16:20:34.953]                   if (is.na(NA_character_)) 
[16:20:34.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.953]                     .init = FALSE)
[16:20:34.953]                 }
[16:20:34.953]             }
[16:20:34.953]         }
[16:20:34.953]     })
[16:20:34.953]     if (TRUE) {
[16:20:34.953]         base::sink(type = "output", split = FALSE)
[16:20:34.953]         if (TRUE) {
[16:20:34.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.953]         }
[16:20:34.953]         else {
[16:20:34.953]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.953]         }
[16:20:34.953]         base::close(...future.stdout)
[16:20:34.953]         ...future.stdout <- NULL
[16:20:34.953]     }
[16:20:34.953]     ...future.result$conditions <- ...future.conditions
[16:20:34.953]     ...future.result$finished <- base::Sys.time()
[16:20:34.953]     ...future.result
[16:20:34.953] }
[16:20:34.954] assign_globals() ...
[16:20:34.955] List of 1
[16:20:34.955]  $ a: num 1
[16:20:34.955]  - attr(*, "where")=List of 1
[16:20:34.955]   ..$ a:<environment: R_EmptyEnv> 
[16:20:34.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:34.955]  - attr(*, "resolved")= logi FALSE
[16:20:34.955]  - attr(*, "total_size")= num 56
[16:20:34.955]  - attr(*, "already-done")= logi TRUE
[16:20:34.961] - copied ‘a’ to environment
[16:20:34.961] assign_globals() ... done
[16:20:34.961] plan(): Setting new future strategy stack:
[16:20:34.961] List of future strategies:
[16:20:34.961] 1. sequential:
[16:20:34.961]    - args: function (..., envir = parent.frame())
[16:20:34.961]    - tweaked: FALSE
[16:20:34.961]    - call: NULL
[16:20:34.961] plan(): nbrOfWorkers() = 1
[16:20:34.962] plan(): Setting new future strategy stack:
[16:20:34.962] List of future strategies:
[16:20:34.962] 1. sequential:
[16:20:34.962]    - args: function (..., envir = parent.frame())
[16:20:34.962]    - tweaked: FALSE
[16:20:34.962]    - call: plan(strategy)
[16:20:34.962] plan(): nbrOfWorkers() = 1
[16:20:34.963] SequentialFuture started (and completed)
[16:20:34.963] - Launch lazy future ... done
[16:20:34.963] run() for ‘SequentialFuture’ ... done
[16:20:34.963] getGlobalsAndPackages() ...
[16:20:34.963] Searching for globals...
[16:20:34.964] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:34.964] Searching for globals ... DONE
[16:20:34.964] Resolving globals: FALSE
[16:20:34.964] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.965] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:34.965] - globals: [1] ‘a’
[16:20:34.965] 
[16:20:34.965] getGlobalsAndPackages() ... DONE
[16:20:34.965] run() for ‘Future’ ...
[16:20:34.965] - state: ‘created’
[16:20:34.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.966]   - Field: ‘label’
[16:20:34.966]   - Field: ‘local’
[16:20:34.966]   - Field: ‘owner’
[16:20:34.966]   - Field: ‘envir’
[16:20:34.966]   - Field: ‘packages’
[16:20:34.966]   - Field: ‘gc’
[16:20:34.966]   - Field: ‘conditions’
[16:20:34.966]   - Field: ‘expr’
[16:20:34.967]   - Field: ‘uuid’
[16:20:34.967]   - Field: ‘seed’
[16:20:34.967]   - Field: ‘version’
[16:20:34.967]   - Field: ‘result’
[16:20:34.967]   - Field: ‘asynchronous’
[16:20:34.967]   - Field: ‘calls’
[16:20:34.967]   - Field: ‘globals’
[16:20:34.967]   - Field: ‘stdout’
[16:20:34.967]   - Field: ‘earlySignal’
[16:20:34.967]   - Field: ‘lazy’
[16:20:34.967]   - Field: ‘state’
[16:20:34.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.968] - Launch lazy future ...
[16:20:34.968] Packages needed by the future expression (n = 0): <none>
[16:20:34.968] Packages needed by future strategies (n = 0): <none>
[16:20:34.968] {
[16:20:34.968]     {
[16:20:34.968]         {
[16:20:34.968]             ...future.startTime <- base::Sys.time()
[16:20:34.968]             {
[16:20:34.968]                 {
[16:20:34.968]                   {
[16:20:34.968]                     base::local({
[16:20:34.968]                       has_future <- base::requireNamespace("future", 
[16:20:34.968]                         quietly = TRUE)
[16:20:34.968]                       if (has_future) {
[16:20:34.968]                         ns <- base::getNamespace("future")
[16:20:34.968]                         version <- ns[[".package"]][["version"]]
[16:20:34.968]                         if (is.null(version)) 
[16:20:34.968]                           version <- utils::packageVersion("future")
[16:20:34.968]                       }
[16:20:34.968]                       else {
[16:20:34.968]                         version <- NULL
[16:20:34.968]                       }
[16:20:34.968]                       if (!has_future || version < "1.8.0") {
[16:20:34.968]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.968]                           "", base::R.version$version.string), 
[16:20:34.968]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.968]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.968]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.968]                             "release", "version")], collapse = " "), 
[16:20:34.968]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.968]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.968]                           info)
[16:20:34.968]                         info <- base::paste(info, collapse = "; ")
[16:20:34.968]                         if (!has_future) {
[16:20:34.968]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.968]                             info)
[16:20:34.968]                         }
[16:20:34.968]                         else {
[16:20:34.968]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.968]                             info, version)
[16:20:34.968]                         }
[16:20:34.968]                         base::stop(msg)
[16:20:34.968]                       }
[16:20:34.968]                     })
[16:20:34.968]                   }
[16:20:34.968]                   ...future.strategy.old <- future::plan("list")
[16:20:34.968]                   options(future.plan = NULL)
[16:20:34.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.968]                 }
[16:20:34.968]                 ...future.workdir <- getwd()
[16:20:34.968]             }
[16:20:34.968]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.968]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.968]         }
[16:20:34.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.968]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.968]             base::names(...future.oldOptions))
[16:20:34.968]     }
[16:20:34.968]     if (FALSE) {
[16:20:34.968]     }
[16:20:34.968]     else {
[16:20:34.968]         if (TRUE) {
[16:20:34.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.968]                 open = "w")
[16:20:34.968]         }
[16:20:34.968]         else {
[16:20:34.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.968]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.968]         }
[16:20:34.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.968]             base::sink(type = "output", split = FALSE)
[16:20:34.968]             base::close(...future.stdout)
[16:20:34.968]         }, add = TRUE)
[16:20:34.968]     }
[16:20:34.968]     ...future.frame <- base::sys.nframe()
[16:20:34.968]     ...future.conditions <- base::list()
[16:20:34.968]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.968]     if (FALSE) {
[16:20:34.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.968]     }
[16:20:34.968]     ...future.result <- base::tryCatch({
[16:20:34.968]         base::withCallingHandlers({
[16:20:34.968]             ...future.value <- base::withVisible(base::local({
[16:20:34.968]                 2 * a
[16:20:34.968]             }))
[16:20:34.968]             future::FutureResult(value = ...future.value$value, 
[16:20:34.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.968]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.968]                     ...future.globalenv.names))
[16:20:34.968]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.968]         }, condition = base::local({
[16:20:34.968]             c <- base::c
[16:20:34.968]             inherits <- base::inherits
[16:20:34.968]             invokeRestart <- base::invokeRestart
[16:20:34.968]             length <- base::length
[16:20:34.968]             list <- base::list
[16:20:34.968]             seq.int <- base::seq.int
[16:20:34.968]             signalCondition <- base::signalCondition
[16:20:34.968]             sys.calls <- base::sys.calls
[16:20:34.968]             `[[` <- base::`[[`
[16:20:34.968]             `+` <- base::`+`
[16:20:34.968]             `<<-` <- base::`<<-`
[16:20:34.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.968]                   3L)]
[16:20:34.968]             }
[16:20:34.968]             function(cond) {
[16:20:34.968]                 is_error <- inherits(cond, "error")
[16:20:34.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.968]                   NULL)
[16:20:34.968]                 if (is_error) {
[16:20:34.968]                   sessionInformation <- function() {
[16:20:34.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.968]                       search = base::search(), system = base::Sys.info())
[16:20:34.968]                   }
[16:20:34.968]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.968]                     cond$call), session = sessionInformation(), 
[16:20:34.968]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.968]                   signalCondition(cond)
[16:20:34.968]                 }
[16:20:34.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.968]                 "immediateCondition"))) {
[16:20:34.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.968]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.968]                   if (TRUE && !signal) {
[16:20:34.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.968]                     {
[16:20:34.968]                       inherits <- base::inherits
[16:20:34.968]                       invokeRestart <- base::invokeRestart
[16:20:34.968]                       is.null <- base::is.null
[16:20:34.968]                       muffled <- FALSE
[16:20:34.968]                       if (inherits(cond, "message")) {
[16:20:34.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.968]                         if (muffled) 
[16:20:34.968]                           invokeRestart("muffleMessage")
[16:20:34.968]                       }
[16:20:34.968]                       else if (inherits(cond, "warning")) {
[16:20:34.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.968]                         if (muffled) 
[16:20:34.968]                           invokeRestart("muffleWarning")
[16:20:34.968]                       }
[16:20:34.968]                       else if (inherits(cond, "condition")) {
[16:20:34.968]                         if (!is.null(pattern)) {
[16:20:34.968]                           computeRestarts <- base::computeRestarts
[16:20:34.968]                           grepl <- base::grepl
[16:20:34.968]                           restarts <- computeRestarts(cond)
[16:20:34.968]                           for (restart in restarts) {
[16:20:34.968]                             name <- restart$name
[16:20:34.968]                             if (is.null(name)) 
[16:20:34.968]                               next
[16:20:34.968]                             if (!grepl(pattern, name)) 
[16:20:34.968]                               next
[16:20:34.968]                             invokeRestart(restart)
[16:20:34.968]                             muffled <- TRUE
[16:20:34.968]                             break
[16:20:34.968]                           }
[16:20:34.968]                         }
[16:20:34.968]                       }
[16:20:34.968]                       invisible(muffled)
[16:20:34.968]                     }
[16:20:34.968]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.968]                   }
[16:20:34.968]                 }
[16:20:34.968]                 else {
[16:20:34.968]                   if (TRUE) {
[16:20:34.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.968]                     {
[16:20:34.968]                       inherits <- base::inherits
[16:20:34.968]                       invokeRestart <- base::invokeRestart
[16:20:34.968]                       is.null <- base::is.null
[16:20:34.968]                       muffled <- FALSE
[16:20:34.968]                       if (inherits(cond, "message")) {
[16:20:34.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.968]                         if (muffled) 
[16:20:34.968]                           invokeRestart("muffleMessage")
[16:20:34.968]                       }
[16:20:34.968]                       else if (inherits(cond, "warning")) {
[16:20:34.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.968]                         if (muffled) 
[16:20:34.968]                           invokeRestart("muffleWarning")
[16:20:34.968]                       }
[16:20:34.968]                       else if (inherits(cond, "condition")) {
[16:20:34.968]                         if (!is.null(pattern)) {
[16:20:34.968]                           computeRestarts <- base::computeRestarts
[16:20:34.968]                           grepl <- base::grepl
[16:20:34.968]                           restarts <- computeRestarts(cond)
[16:20:34.968]                           for (restart in restarts) {
[16:20:34.968]                             name <- restart$name
[16:20:34.968]                             if (is.null(name)) 
[16:20:34.968]                               next
[16:20:34.968]                             if (!grepl(pattern, name)) 
[16:20:34.968]                               next
[16:20:34.968]                             invokeRestart(restart)
[16:20:34.968]                             muffled <- TRUE
[16:20:34.968]                             break
[16:20:34.968]                           }
[16:20:34.968]                         }
[16:20:34.968]                       }
[16:20:34.968]                       invisible(muffled)
[16:20:34.968]                     }
[16:20:34.968]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.968]                   }
[16:20:34.968]                 }
[16:20:34.968]             }
[16:20:34.968]         }))
[16:20:34.968]     }, error = function(ex) {
[16:20:34.968]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.968]                 ...future.rng), started = ...future.startTime, 
[16:20:34.968]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.968]             version = "1.8"), class = "FutureResult")
[16:20:34.968]     }, finally = {
[16:20:34.968]         if (!identical(...future.workdir, getwd())) 
[16:20:34.968]             setwd(...future.workdir)
[16:20:34.968]         {
[16:20:34.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.968]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.968]             }
[16:20:34.968]             base::options(...future.oldOptions)
[16:20:34.968]             if (.Platform$OS.type == "windows") {
[16:20:34.968]                 old_names <- names(...future.oldEnvVars)
[16:20:34.968]                 envs <- base::Sys.getenv()
[16:20:34.968]                 names <- names(envs)
[16:20:34.968]                 common <- intersect(names, old_names)
[16:20:34.968]                 added <- setdiff(names, old_names)
[16:20:34.968]                 removed <- setdiff(old_names, names)
[16:20:34.968]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.968]                   envs[common]]
[16:20:34.968]                 NAMES <- toupper(changed)
[16:20:34.968]                 args <- list()
[16:20:34.968]                 for (kk in seq_along(NAMES)) {
[16:20:34.968]                   name <- changed[[kk]]
[16:20:34.968]                   NAME <- NAMES[[kk]]
[16:20:34.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.968]                     next
[16:20:34.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.968]                 }
[16:20:34.968]                 NAMES <- toupper(added)
[16:20:34.968]                 for (kk in seq_along(NAMES)) {
[16:20:34.968]                   name <- added[[kk]]
[16:20:34.968]                   NAME <- NAMES[[kk]]
[16:20:34.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.968]                     next
[16:20:34.968]                   args[[name]] <- ""
[16:20:34.968]                 }
[16:20:34.968]                 NAMES <- toupper(removed)
[16:20:34.968]                 for (kk in seq_along(NAMES)) {
[16:20:34.968]                   name <- removed[[kk]]
[16:20:34.968]                   NAME <- NAMES[[kk]]
[16:20:34.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.968]                     next
[16:20:34.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.968]                 }
[16:20:34.968]                 if (length(args) > 0) 
[16:20:34.968]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.968]             }
[16:20:34.968]             else {
[16:20:34.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.968]             }
[16:20:34.968]             {
[16:20:34.968]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.968]                   0L) {
[16:20:34.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.968]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.968]                   base::options(opts)
[16:20:34.968]                 }
[16:20:34.968]                 {
[16:20:34.968]                   {
[16:20:34.968]                     NULL
[16:20:34.968]                     RNGkind("Mersenne-Twister")
[16:20:34.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.968]                       inherits = FALSE)
[16:20:34.968]                   }
[16:20:34.968]                   options(future.plan = NULL)
[16:20:34.968]                   if (is.na(NA_character_)) 
[16:20:34.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.968]                     .init = FALSE)
[16:20:34.968]                 }
[16:20:34.968]             }
[16:20:34.968]         }
[16:20:34.968]     })
[16:20:34.968]     if (TRUE) {
[16:20:34.968]         base::sink(type = "output", split = FALSE)
[16:20:34.968]         if (TRUE) {
[16:20:34.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.968]         }
[16:20:34.968]         else {
[16:20:34.968]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.968]         }
[16:20:34.968]         base::close(...future.stdout)
[16:20:34.968]         ...future.stdout <- NULL
[16:20:34.968]     }
[16:20:34.968]     ...future.result$conditions <- ...future.conditions
[16:20:34.968]     ...future.result$finished <- base::Sys.time()
[16:20:34.968]     ...future.result
[16:20:34.968] }
[16:20:34.970] assign_globals() ...
[16:20:34.970] List of 1
[16:20:34.970]  $ a: num 1
[16:20:34.970]  - attr(*, "where")=List of 1
[16:20:34.970]   ..$ a:<environment: R_EmptyEnv> 
[16:20:34.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:34.970]  - attr(*, "resolved")= logi FALSE
[16:20:34.970]  - attr(*, "total_size")= num 56
[16:20:34.970]  - attr(*, "already-done")= logi TRUE
[16:20:34.972] - copied ‘a’ to environment
[16:20:34.972] assign_globals() ... done
[16:20:34.972] plan(): Setting new future strategy stack:
[16:20:34.973] List of future strategies:
[16:20:34.973] 1. sequential:
[16:20:34.973]    - args: function (..., envir = parent.frame())
[16:20:34.973]    - tweaked: FALSE
[16:20:34.973]    - call: NULL
[16:20:34.973] plan(): nbrOfWorkers() = 1
[16:20:34.974] plan(): Setting new future strategy stack:
[16:20:34.974] List of future strategies:
[16:20:34.974] 1. sequential:
[16:20:34.974]    - args: function (..., envir = parent.frame())
[16:20:34.974]    - tweaked: FALSE
[16:20:34.974]    - call: plan(strategy)
[16:20:34.974] plan(): nbrOfWorkers() = 1
[16:20:34.974] SequentialFuture started (and completed)
[16:20:34.974] - Launch lazy future ... done
[16:20:34.974] run() for ‘SequentialFuture’ ... done
[16:20:34.975] getGlobalsAndPackages() ...
[16:20:34.975] Searching for globals...
[16:20:34.975] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:34.975] Searching for globals ... DONE
[16:20:34.976] Resolving globals: FALSE
[16:20:34.976] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.976] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:34.976] - globals: [1] ‘a’
[16:20:34.976] 
[16:20:34.977] getGlobalsAndPackages() ... DONE
[16:20:34.977] run() for ‘Future’ ...
[16:20:34.977] - state: ‘created’
[16:20:34.977] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.977]   - Field: ‘label’
[16:20:34.977]   - Field: ‘local’
[16:20:34.978]   - Field: ‘owner’
[16:20:34.978]   - Field: ‘envir’
[16:20:34.978]   - Field: ‘packages’
[16:20:34.978]   - Field: ‘gc’
[16:20:34.978]   - Field: ‘conditions’
[16:20:34.978]   - Field: ‘expr’
[16:20:34.978]   - Field: ‘uuid’
[16:20:34.978]   - Field: ‘seed’
[16:20:34.978]   - Field: ‘version’
[16:20:34.978]   - Field: ‘result’
[16:20:34.978]   - Field: ‘asynchronous’
[16:20:34.979]   - Field: ‘calls’
[16:20:34.979]   - Field: ‘globals’
[16:20:34.979]   - Field: ‘stdout’
[16:20:34.979]   - Field: ‘earlySignal’
[16:20:34.979]   - Field: ‘lazy’
[16:20:34.979]   - Field: ‘state’
[16:20:34.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.979] - Launch lazy future ...
[16:20:34.979] Packages needed by the future expression (n = 0): <none>
[16:20:34.979] Packages needed by future strategies (n = 0): <none>
[16:20:34.980] {
[16:20:34.980]     {
[16:20:34.980]         {
[16:20:34.980]             ...future.startTime <- base::Sys.time()
[16:20:34.980]             {
[16:20:34.980]                 {
[16:20:34.980]                   {
[16:20:34.980]                     base::local({
[16:20:34.980]                       has_future <- base::requireNamespace("future", 
[16:20:34.980]                         quietly = TRUE)
[16:20:34.980]                       if (has_future) {
[16:20:34.980]                         ns <- base::getNamespace("future")
[16:20:34.980]                         version <- ns[[".package"]][["version"]]
[16:20:34.980]                         if (is.null(version)) 
[16:20:34.980]                           version <- utils::packageVersion("future")
[16:20:34.980]                       }
[16:20:34.980]                       else {
[16:20:34.980]                         version <- NULL
[16:20:34.980]                       }
[16:20:34.980]                       if (!has_future || version < "1.8.0") {
[16:20:34.980]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.980]                           "", base::R.version$version.string), 
[16:20:34.980]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.980]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.980]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.980]                             "release", "version")], collapse = " "), 
[16:20:34.980]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.980]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.980]                           info)
[16:20:34.980]                         info <- base::paste(info, collapse = "; ")
[16:20:34.980]                         if (!has_future) {
[16:20:34.980]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.980]                             info)
[16:20:34.980]                         }
[16:20:34.980]                         else {
[16:20:34.980]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.980]                             info, version)
[16:20:34.980]                         }
[16:20:34.980]                         base::stop(msg)
[16:20:34.980]                       }
[16:20:34.980]                     })
[16:20:34.980]                   }
[16:20:34.980]                   ...future.strategy.old <- future::plan("list")
[16:20:34.980]                   options(future.plan = NULL)
[16:20:34.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.980]                 }
[16:20:34.980]                 ...future.workdir <- getwd()
[16:20:34.980]             }
[16:20:34.980]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.980]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.980]         }
[16:20:34.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.980]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.980]             base::names(...future.oldOptions))
[16:20:34.980]     }
[16:20:34.980]     if (FALSE) {
[16:20:34.980]     }
[16:20:34.980]     else {
[16:20:34.980]         if (TRUE) {
[16:20:34.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.980]                 open = "w")
[16:20:34.980]         }
[16:20:34.980]         else {
[16:20:34.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.980]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.980]         }
[16:20:34.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.980]             base::sink(type = "output", split = FALSE)
[16:20:34.980]             base::close(...future.stdout)
[16:20:34.980]         }, add = TRUE)
[16:20:34.980]     }
[16:20:34.980]     ...future.frame <- base::sys.nframe()
[16:20:34.980]     ...future.conditions <- base::list()
[16:20:34.980]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.980]     if (FALSE) {
[16:20:34.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.980]     }
[16:20:34.980]     ...future.result <- base::tryCatch({
[16:20:34.980]         base::withCallingHandlers({
[16:20:34.980]             ...future.value <- base::withVisible(base::local({
[16:20:34.980]                 2 * a
[16:20:34.980]             }))
[16:20:34.980]             future::FutureResult(value = ...future.value$value, 
[16:20:34.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.980]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.980]                     ...future.globalenv.names))
[16:20:34.980]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.980]         }, condition = base::local({
[16:20:34.980]             c <- base::c
[16:20:34.980]             inherits <- base::inherits
[16:20:34.980]             invokeRestart <- base::invokeRestart
[16:20:34.980]             length <- base::length
[16:20:34.980]             list <- base::list
[16:20:34.980]             seq.int <- base::seq.int
[16:20:34.980]             signalCondition <- base::signalCondition
[16:20:34.980]             sys.calls <- base::sys.calls
[16:20:34.980]             `[[` <- base::`[[`
[16:20:34.980]             `+` <- base::`+`
[16:20:34.980]             `<<-` <- base::`<<-`
[16:20:34.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.980]                   3L)]
[16:20:34.980]             }
[16:20:34.980]             function(cond) {
[16:20:34.980]                 is_error <- inherits(cond, "error")
[16:20:34.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.980]                   NULL)
[16:20:34.980]                 if (is_error) {
[16:20:34.980]                   sessionInformation <- function() {
[16:20:34.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.980]                       search = base::search(), system = base::Sys.info())
[16:20:34.980]                   }
[16:20:34.980]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.980]                     cond$call), session = sessionInformation(), 
[16:20:34.980]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.980]                   signalCondition(cond)
[16:20:34.980]                 }
[16:20:34.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.980]                 "immediateCondition"))) {
[16:20:34.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.980]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.980]                   if (TRUE && !signal) {
[16:20:34.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.980]                     {
[16:20:34.980]                       inherits <- base::inherits
[16:20:34.980]                       invokeRestart <- base::invokeRestart
[16:20:34.980]                       is.null <- base::is.null
[16:20:34.980]                       muffled <- FALSE
[16:20:34.980]                       if (inherits(cond, "message")) {
[16:20:34.980]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.980]                         if (muffled) 
[16:20:34.980]                           invokeRestart("muffleMessage")
[16:20:34.980]                       }
[16:20:34.980]                       else if (inherits(cond, "warning")) {
[16:20:34.980]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.980]                         if (muffled) 
[16:20:34.980]                           invokeRestart("muffleWarning")
[16:20:34.980]                       }
[16:20:34.980]                       else if (inherits(cond, "condition")) {
[16:20:34.980]                         if (!is.null(pattern)) {
[16:20:34.980]                           computeRestarts <- base::computeRestarts
[16:20:34.980]                           grepl <- base::grepl
[16:20:34.980]                           restarts <- computeRestarts(cond)
[16:20:34.980]                           for (restart in restarts) {
[16:20:34.980]                             name <- restart$name
[16:20:34.980]                             if (is.null(name)) 
[16:20:34.980]                               next
[16:20:34.980]                             if (!grepl(pattern, name)) 
[16:20:34.980]                               next
[16:20:34.980]                             invokeRestart(restart)
[16:20:34.980]                             muffled <- TRUE
[16:20:34.980]                             break
[16:20:34.980]                           }
[16:20:34.980]                         }
[16:20:34.980]                       }
[16:20:34.980]                       invisible(muffled)
[16:20:34.980]                     }
[16:20:34.980]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.980]                   }
[16:20:34.980]                 }
[16:20:34.980]                 else {
[16:20:34.980]                   if (TRUE) {
[16:20:34.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.980]                     {
[16:20:34.980]                       inherits <- base::inherits
[16:20:34.980]                       invokeRestart <- base::invokeRestart
[16:20:34.980]                       is.null <- base::is.null
[16:20:34.980]                       muffled <- FALSE
[16:20:34.980]                       if (inherits(cond, "message")) {
[16:20:34.980]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.980]                         if (muffled) 
[16:20:34.980]                           invokeRestart("muffleMessage")
[16:20:34.980]                       }
[16:20:34.980]                       else if (inherits(cond, "warning")) {
[16:20:34.980]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.980]                         if (muffled) 
[16:20:34.980]                           invokeRestart("muffleWarning")
[16:20:34.980]                       }
[16:20:34.980]                       else if (inherits(cond, "condition")) {
[16:20:34.980]                         if (!is.null(pattern)) {
[16:20:34.980]                           computeRestarts <- base::computeRestarts
[16:20:34.980]                           grepl <- base::grepl
[16:20:34.980]                           restarts <- computeRestarts(cond)
[16:20:34.980]                           for (restart in restarts) {
[16:20:34.980]                             name <- restart$name
[16:20:34.980]                             if (is.null(name)) 
[16:20:34.980]                               next
[16:20:34.980]                             if (!grepl(pattern, name)) 
[16:20:34.980]                               next
[16:20:34.980]                             invokeRestart(restart)
[16:20:34.980]                             muffled <- TRUE
[16:20:34.980]                             break
[16:20:34.980]                           }
[16:20:34.980]                         }
[16:20:34.980]                       }
[16:20:34.980]                       invisible(muffled)
[16:20:34.980]                     }
[16:20:34.980]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.980]                   }
[16:20:34.980]                 }
[16:20:34.980]             }
[16:20:34.980]         }))
[16:20:34.980]     }, error = function(ex) {
[16:20:34.980]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.980]                 ...future.rng), started = ...future.startTime, 
[16:20:34.980]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.980]             version = "1.8"), class = "FutureResult")
[16:20:34.980]     }, finally = {
[16:20:34.980]         if (!identical(...future.workdir, getwd())) 
[16:20:34.980]             setwd(...future.workdir)
[16:20:34.980]         {
[16:20:34.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.980]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.980]             }
[16:20:34.980]             base::options(...future.oldOptions)
[16:20:34.980]             if (.Platform$OS.type == "windows") {
[16:20:34.980]                 old_names <- names(...future.oldEnvVars)
[16:20:34.980]                 envs <- base::Sys.getenv()
[16:20:34.980]                 names <- names(envs)
[16:20:34.980]                 common <- intersect(names, old_names)
[16:20:34.980]                 added <- setdiff(names, old_names)
[16:20:34.980]                 removed <- setdiff(old_names, names)
[16:20:34.980]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.980]                   envs[common]]
[16:20:34.980]                 NAMES <- toupper(changed)
[16:20:34.980]                 args <- list()
[16:20:34.980]                 for (kk in seq_along(NAMES)) {
[16:20:34.980]                   name <- changed[[kk]]
[16:20:34.980]                   NAME <- NAMES[[kk]]
[16:20:34.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.980]                     next
[16:20:34.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.980]                 }
[16:20:34.980]                 NAMES <- toupper(added)
[16:20:34.980]                 for (kk in seq_along(NAMES)) {
[16:20:34.980]                   name <- added[[kk]]
[16:20:34.980]                   NAME <- NAMES[[kk]]
[16:20:34.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.980]                     next
[16:20:34.980]                   args[[name]] <- ""
[16:20:34.980]                 }
[16:20:34.980]                 NAMES <- toupper(removed)
[16:20:34.980]                 for (kk in seq_along(NAMES)) {
[16:20:34.980]                   name <- removed[[kk]]
[16:20:34.980]                   NAME <- NAMES[[kk]]
[16:20:34.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.980]                     next
[16:20:34.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.980]                 }
[16:20:34.980]                 if (length(args) > 0) 
[16:20:34.980]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.980]             }
[16:20:34.980]             else {
[16:20:34.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.980]             }
[16:20:34.980]             {
[16:20:34.980]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.980]                   0L) {
[16:20:34.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.980]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.980]                   base::options(opts)
[16:20:34.980]                 }
[16:20:34.980]                 {
[16:20:34.980]                   {
[16:20:34.980]                     NULL
[16:20:34.980]                     RNGkind("Mersenne-Twister")
[16:20:34.980]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.980]                       inherits = FALSE)
[16:20:34.980]                   }
[16:20:34.980]                   options(future.plan = NULL)
[16:20:34.980]                   if (is.na(NA_character_)) 
[16:20:34.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.980]                     .init = FALSE)
[16:20:34.980]                 }
[16:20:34.980]             }
[16:20:34.980]         }
[16:20:34.980]     })
[16:20:34.980]     if (TRUE) {
[16:20:34.980]         base::sink(type = "output", split = FALSE)
[16:20:34.980]         if (TRUE) {
[16:20:34.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.980]         }
[16:20:34.980]         else {
[16:20:34.980]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.980]         }
[16:20:34.980]         base::close(...future.stdout)
[16:20:34.980]         ...future.stdout <- NULL
[16:20:34.980]     }
[16:20:34.980]     ...future.result$conditions <- ...future.conditions
[16:20:34.980]     ...future.result$finished <- base::Sys.time()
[16:20:34.980]     ...future.result
[16:20:34.980] }
[16:20:34.981] assign_globals() ...
[16:20:34.981] List of 1
[16:20:34.981]  $ a: num 1
[16:20:34.981]  - attr(*, "where")=List of 1
[16:20:34.981]   ..$ a:<environment: R_EmptyEnv> 
[16:20:34.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:34.981]  - attr(*, "resolved")= logi FALSE
[16:20:34.981]  - attr(*, "total_size")= num 56
[16:20:34.981]  - attr(*, "already-done")= logi TRUE
[16:20:34.984] - copied ‘a’ to environment
[16:20:34.984] assign_globals() ... done
[16:20:34.984] plan(): Setting new future strategy stack:
[16:20:34.984] List of future strategies:
[16:20:34.984] 1. sequential:
[16:20:34.984]    - args: function (..., envir = parent.frame())
[16:20:34.984]    - tweaked: FALSE
[16:20:34.984]    - call: NULL
[16:20:34.984] plan(): nbrOfWorkers() = 1
[16:20:34.985] plan(): Setting new future strategy stack:
[16:20:34.986] List of future strategies:
[16:20:34.986] 1. sequential:
[16:20:34.986]    - args: function (..., envir = parent.frame())
[16:20:34.986]    - tweaked: FALSE
[16:20:34.986]    - call: plan(strategy)
[16:20:34.987] plan(): nbrOfWorkers() = 1
[16:20:34.987] SequentialFuture started (and completed)
[16:20:34.987] - Launch lazy future ... done
[16:20:34.987] run() for ‘SequentialFuture’ ... done
[16:20:34.987] getGlobalsAndPackages() ...
[16:20:34.987] Searching for globals...
[16:20:34.988] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:34.988] Searching for globals ... DONE
[16:20:34.988] Resolving globals: FALSE
[16:20:34.989] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:34.989] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:34.989] - globals: [1] ‘a’
[16:20:34.989] 
[16:20:34.989] getGlobalsAndPackages() ... DONE
[16:20:34.990] run() for ‘Future’ ...
[16:20:34.990] - state: ‘created’
[16:20:34.990] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:34.990] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:34.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:34.990]   - Field: ‘label’
[16:20:34.990]   - Field: ‘local’
[16:20:34.990]   - Field: ‘owner’
[16:20:34.990]   - Field: ‘envir’
[16:20:34.991]   - Field: ‘packages’
[16:20:34.991]   - Field: ‘gc’
[16:20:34.991]   - Field: ‘conditions’
[16:20:34.991]   - Field: ‘expr’
[16:20:34.991]   - Field: ‘uuid’
[16:20:34.991]   - Field: ‘seed’
[16:20:34.991]   - Field: ‘version’
[16:20:34.991]   - Field: ‘result’
[16:20:34.991]   - Field: ‘asynchronous’
[16:20:34.991]   - Field: ‘calls’
[16:20:34.991]   - Field: ‘globals’
[16:20:34.991]   - Field: ‘stdout’
[16:20:34.992]   - Field: ‘earlySignal’
[16:20:34.992]   - Field: ‘lazy’
[16:20:34.992]   - Field: ‘state’
[16:20:34.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:34.992] - Launch lazy future ...
[16:20:34.992] Packages needed by the future expression (n = 0): <none>
[16:20:34.992] Packages needed by future strategies (n = 0): <none>
[16:20:34.993] {
[16:20:34.993]     {
[16:20:34.993]         {
[16:20:34.993]             ...future.startTime <- base::Sys.time()
[16:20:34.993]             {
[16:20:34.993]                 {
[16:20:34.993]                   {
[16:20:34.993]                     base::local({
[16:20:34.993]                       has_future <- base::requireNamespace("future", 
[16:20:34.993]                         quietly = TRUE)
[16:20:34.993]                       if (has_future) {
[16:20:34.993]                         ns <- base::getNamespace("future")
[16:20:34.993]                         version <- ns[[".package"]][["version"]]
[16:20:34.993]                         if (is.null(version)) 
[16:20:34.993]                           version <- utils::packageVersion("future")
[16:20:34.993]                       }
[16:20:34.993]                       else {
[16:20:34.993]                         version <- NULL
[16:20:34.993]                       }
[16:20:34.993]                       if (!has_future || version < "1.8.0") {
[16:20:34.993]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:34.993]                           "", base::R.version$version.string), 
[16:20:34.993]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:34.993]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:34.993]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:34.993]                             "release", "version")], collapse = " "), 
[16:20:34.993]                           hostname = base::Sys.info()[["nodename"]])
[16:20:34.993]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:34.993]                           info)
[16:20:34.993]                         info <- base::paste(info, collapse = "; ")
[16:20:34.993]                         if (!has_future) {
[16:20:34.993]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:34.993]                             info)
[16:20:34.993]                         }
[16:20:34.993]                         else {
[16:20:34.993]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:34.993]                             info, version)
[16:20:34.993]                         }
[16:20:34.993]                         base::stop(msg)
[16:20:34.993]                       }
[16:20:34.993]                     })
[16:20:34.993]                   }
[16:20:34.993]                   ...future.strategy.old <- future::plan("list")
[16:20:34.993]                   options(future.plan = NULL)
[16:20:34.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:34.993]                 }
[16:20:34.993]                 ...future.workdir <- getwd()
[16:20:34.993]             }
[16:20:34.993]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:34.993]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:34.993]         }
[16:20:34.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:34.993]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:34.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:34.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:34.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:34.993]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:34.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:34.993]             base::names(...future.oldOptions))
[16:20:34.993]     }
[16:20:34.993]     if (FALSE) {
[16:20:34.993]     }
[16:20:34.993]     else {
[16:20:34.993]         if (TRUE) {
[16:20:34.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:34.993]                 open = "w")
[16:20:34.993]         }
[16:20:34.993]         else {
[16:20:34.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:34.993]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:34.993]         }
[16:20:34.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:34.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:34.993]             base::sink(type = "output", split = FALSE)
[16:20:34.993]             base::close(...future.stdout)
[16:20:34.993]         }, add = TRUE)
[16:20:34.993]     }
[16:20:34.993]     ...future.frame <- base::sys.nframe()
[16:20:34.993]     ...future.conditions <- base::list()
[16:20:34.993]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:34.993]     if (FALSE) {
[16:20:34.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:34.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:34.993]     }
[16:20:34.993]     ...future.result <- base::tryCatch({
[16:20:34.993]         base::withCallingHandlers({
[16:20:34.993]             ...future.value <- base::withVisible(base::local({
[16:20:34.993]                 2 * a
[16:20:34.993]             }))
[16:20:34.993]             future::FutureResult(value = ...future.value$value, 
[16:20:34.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.993]                   ...future.rng), globalenv = if (FALSE) 
[16:20:34.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:34.993]                     ...future.globalenv.names))
[16:20:34.993]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:34.993]         }, condition = base::local({
[16:20:34.993]             c <- base::c
[16:20:34.993]             inherits <- base::inherits
[16:20:34.993]             invokeRestart <- base::invokeRestart
[16:20:34.993]             length <- base::length
[16:20:34.993]             list <- base::list
[16:20:34.993]             seq.int <- base::seq.int
[16:20:34.993]             signalCondition <- base::signalCondition
[16:20:34.993]             sys.calls <- base::sys.calls
[16:20:34.993]             `[[` <- base::`[[`
[16:20:34.993]             `+` <- base::`+`
[16:20:34.993]             `<<-` <- base::`<<-`
[16:20:34.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:34.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:34.993]                   3L)]
[16:20:34.993]             }
[16:20:34.993]             function(cond) {
[16:20:34.993]                 is_error <- inherits(cond, "error")
[16:20:34.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:34.993]                   NULL)
[16:20:34.993]                 if (is_error) {
[16:20:34.993]                   sessionInformation <- function() {
[16:20:34.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:34.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:34.993]                       search = base::search(), system = base::Sys.info())
[16:20:34.993]                   }
[16:20:34.993]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:34.993]                     cond$call), session = sessionInformation(), 
[16:20:34.993]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:34.993]                   signalCondition(cond)
[16:20:34.993]                 }
[16:20:34.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:34.993]                 "immediateCondition"))) {
[16:20:34.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:34.993]                   ...future.conditions[[length(...future.conditions) + 
[16:20:34.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:34.993]                   if (TRUE && !signal) {
[16:20:34.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.993]                     {
[16:20:34.993]                       inherits <- base::inherits
[16:20:34.993]                       invokeRestart <- base::invokeRestart
[16:20:34.993]                       is.null <- base::is.null
[16:20:34.993]                       muffled <- FALSE
[16:20:34.993]                       if (inherits(cond, "message")) {
[16:20:34.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.993]                         if (muffled) 
[16:20:34.993]                           invokeRestart("muffleMessage")
[16:20:34.993]                       }
[16:20:34.993]                       else if (inherits(cond, "warning")) {
[16:20:34.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.993]                         if (muffled) 
[16:20:34.993]                           invokeRestart("muffleWarning")
[16:20:34.993]                       }
[16:20:34.993]                       else if (inherits(cond, "condition")) {
[16:20:34.993]                         if (!is.null(pattern)) {
[16:20:34.993]                           computeRestarts <- base::computeRestarts
[16:20:34.993]                           grepl <- base::grepl
[16:20:34.993]                           restarts <- computeRestarts(cond)
[16:20:34.993]                           for (restart in restarts) {
[16:20:34.993]                             name <- restart$name
[16:20:34.993]                             if (is.null(name)) 
[16:20:34.993]                               next
[16:20:34.993]                             if (!grepl(pattern, name)) 
[16:20:34.993]                               next
[16:20:34.993]                             invokeRestart(restart)
[16:20:34.993]                             muffled <- TRUE
[16:20:34.993]                             break
[16:20:34.993]                           }
[16:20:34.993]                         }
[16:20:34.993]                       }
[16:20:34.993]                       invisible(muffled)
[16:20:34.993]                     }
[16:20:34.993]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.993]                   }
[16:20:34.993]                 }
[16:20:34.993]                 else {
[16:20:34.993]                   if (TRUE) {
[16:20:34.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:34.993]                     {
[16:20:34.993]                       inherits <- base::inherits
[16:20:34.993]                       invokeRestart <- base::invokeRestart
[16:20:34.993]                       is.null <- base::is.null
[16:20:34.993]                       muffled <- FALSE
[16:20:34.993]                       if (inherits(cond, "message")) {
[16:20:34.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:34.993]                         if (muffled) 
[16:20:34.993]                           invokeRestart("muffleMessage")
[16:20:34.993]                       }
[16:20:34.993]                       else if (inherits(cond, "warning")) {
[16:20:34.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:34.993]                         if (muffled) 
[16:20:34.993]                           invokeRestart("muffleWarning")
[16:20:34.993]                       }
[16:20:34.993]                       else if (inherits(cond, "condition")) {
[16:20:34.993]                         if (!is.null(pattern)) {
[16:20:34.993]                           computeRestarts <- base::computeRestarts
[16:20:34.993]                           grepl <- base::grepl
[16:20:34.993]                           restarts <- computeRestarts(cond)
[16:20:34.993]                           for (restart in restarts) {
[16:20:34.993]                             name <- restart$name
[16:20:34.993]                             if (is.null(name)) 
[16:20:34.993]                               next
[16:20:34.993]                             if (!grepl(pattern, name)) 
[16:20:34.993]                               next
[16:20:34.993]                             invokeRestart(restart)
[16:20:34.993]                             muffled <- TRUE
[16:20:34.993]                             break
[16:20:34.993]                           }
[16:20:34.993]                         }
[16:20:34.993]                       }
[16:20:34.993]                       invisible(muffled)
[16:20:34.993]                     }
[16:20:34.993]                     muffleCondition(cond, pattern = "^muffle")
[16:20:34.993]                   }
[16:20:34.993]                 }
[16:20:34.993]             }
[16:20:34.993]         }))
[16:20:34.993]     }, error = function(ex) {
[16:20:34.993]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:34.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:34.993]                 ...future.rng), started = ...future.startTime, 
[16:20:34.993]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:34.993]             version = "1.8"), class = "FutureResult")
[16:20:34.993]     }, finally = {
[16:20:34.993]         if (!identical(...future.workdir, getwd())) 
[16:20:34.993]             setwd(...future.workdir)
[16:20:34.993]         {
[16:20:34.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:34.993]                 ...future.oldOptions$nwarnings <- NULL
[16:20:34.993]             }
[16:20:34.993]             base::options(...future.oldOptions)
[16:20:34.993]             if (.Platform$OS.type == "windows") {
[16:20:34.993]                 old_names <- names(...future.oldEnvVars)
[16:20:34.993]                 envs <- base::Sys.getenv()
[16:20:34.993]                 names <- names(envs)
[16:20:34.993]                 common <- intersect(names, old_names)
[16:20:34.993]                 added <- setdiff(names, old_names)
[16:20:34.993]                 removed <- setdiff(old_names, names)
[16:20:34.993]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:34.993]                   envs[common]]
[16:20:34.993]                 NAMES <- toupper(changed)
[16:20:34.993]                 args <- list()
[16:20:34.993]                 for (kk in seq_along(NAMES)) {
[16:20:34.993]                   name <- changed[[kk]]
[16:20:34.993]                   NAME <- NAMES[[kk]]
[16:20:34.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.993]                     next
[16:20:34.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.993]                 }
[16:20:34.993]                 NAMES <- toupper(added)
[16:20:34.993]                 for (kk in seq_along(NAMES)) {
[16:20:34.993]                   name <- added[[kk]]
[16:20:34.993]                   NAME <- NAMES[[kk]]
[16:20:34.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.993]                     next
[16:20:34.993]                   args[[name]] <- ""
[16:20:34.993]                 }
[16:20:34.993]                 NAMES <- toupper(removed)
[16:20:34.993]                 for (kk in seq_along(NAMES)) {
[16:20:34.993]                   name <- removed[[kk]]
[16:20:34.993]                   NAME <- NAMES[[kk]]
[16:20:34.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:34.993]                     next
[16:20:34.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:34.993]                 }
[16:20:34.993]                 if (length(args) > 0) 
[16:20:34.993]                   base::do.call(base::Sys.setenv, args = args)
[16:20:34.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:34.993]             }
[16:20:34.993]             else {
[16:20:34.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:34.993]             }
[16:20:34.993]             {
[16:20:34.993]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:34.993]                   0L) {
[16:20:34.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:34.993]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:34.993]                   base::options(opts)
[16:20:34.993]                 }
[16:20:34.993]                 {
[16:20:34.993]                   {
[16:20:34.993]                     NULL
[16:20:34.993]                     RNGkind("Mersenne-Twister")
[16:20:34.993]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:34.993]                       inherits = FALSE)
[16:20:34.993]                   }
[16:20:34.993]                   options(future.plan = NULL)
[16:20:34.993]                   if (is.na(NA_character_)) 
[16:20:34.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:34.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:34.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:34.993]                     .init = FALSE)
[16:20:34.993]                 }
[16:20:34.993]             }
[16:20:34.993]         }
[16:20:34.993]     })
[16:20:34.993]     if (TRUE) {
[16:20:34.993]         base::sink(type = "output", split = FALSE)
[16:20:34.993]         if (TRUE) {
[16:20:34.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:34.993]         }
[16:20:34.993]         else {
[16:20:34.993]             ...future.result["stdout"] <- base::list(NULL)
[16:20:34.993]         }
[16:20:34.993]         base::close(...future.stdout)
[16:20:34.993]         ...future.stdout <- NULL
[16:20:34.993]     }
[16:20:34.993]     ...future.result$conditions <- ...future.conditions
[16:20:34.993]     ...future.result$finished <- base::Sys.time()
[16:20:34.993]     ...future.result
[16:20:34.993] }
[16:20:34.994] assign_globals() ...
[16:20:34.994] List of 1
[16:20:34.994]  $ a: num 1
[16:20:34.994]  - attr(*, "where")=List of 1
[16:20:34.994]   ..$ a:<environment: R_EmptyEnv> 
[16:20:34.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:34.994]  - attr(*, "resolved")= logi FALSE
[16:20:34.994]  - attr(*, "total_size")= num 56
[16:20:34.994]  - attr(*, "already-done")= logi TRUE
[16:20:34.996] - copied ‘a’ to environment
[16:20:34.997] assign_globals() ... done
[16:20:34.997] plan(): Setting new future strategy stack:
[16:20:34.997] List of future strategies:
[16:20:34.997] 1. sequential:
[16:20:34.997]    - args: function (..., envir = parent.frame())
[16:20:34.997]    - tweaked: FALSE
[16:20:34.997]    - call: NULL
[16:20:34.997] plan(): nbrOfWorkers() = 1
[16:20:34.998] plan(): Setting new future strategy stack:
[16:20:34.998] List of future strategies:
[16:20:34.998] 1. sequential:
[16:20:34.998]    - args: function (..., envir = parent.frame())
[16:20:34.998]    - tweaked: FALSE
[16:20:34.998]    - call: plan(strategy)
[16:20:34.998] plan(): nbrOfWorkers() = 1
[16:20:34.998] SequentialFuture started (and completed)
[16:20:34.999] - Launch lazy future ... done
[16:20:34.999] run() for ‘SequentialFuture’ ... done
[16:20:34.999] getGlobalsAndPackages() ...
[16:20:34.999] Searching for globals...
[16:20:35.000] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:35.000] Searching for globals ... DONE
[16:20:35.000] Resolving globals: FALSE
[16:20:35.000] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:35.001] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:35.001] - globals: [1] ‘a’
[16:20:35.001] 
[16:20:35.001] getGlobalsAndPackages() ... DONE
[16:20:35.001] run() for ‘Future’ ...
[16:20:35.001] - state: ‘created’
[16:20:35.001] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:20:35.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:20:35.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:20:35.002]   - Field: ‘label’
[16:20:35.002]   - Field: ‘local’
[16:20:35.002]   - Field: ‘owner’
[16:20:35.002]   - Field: ‘envir’
[16:20:35.002]   - Field: ‘packages’
[16:20:35.002]   - Field: ‘gc’
[16:20:35.002]   - Field: ‘conditions’
[16:20:35.002]   - Field: ‘expr’
[16:20:35.002]   - Field: ‘uuid’
[16:20:35.002]   - Field: ‘seed’
[16:20:35.003]   - Field: ‘version’
[16:20:35.003]   - Field: ‘result’
[16:20:35.003]   - Field: ‘asynchronous’
[16:20:35.003]   - Field: ‘calls’
[16:20:35.003]   - Field: ‘globals’
[16:20:35.003]   - Field: ‘stdout’
[16:20:35.003]   - Field: ‘earlySignal’
[16:20:35.003]   - Field: ‘lazy’
[16:20:35.003]   - Field: ‘state’
[16:20:35.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:20:35.003] - Launch lazy future ...
[16:20:35.004] Packages needed by the future expression (n = 0): <none>
[16:20:35.004] Packages needed by future strategies (n = 0): <none>
[16:20:35.004] {
[16:20:35.004]     {
[16:20:35.004]         {
[16:20:35.004]             ...future.startTime <- base::Sys.time()
[16:20:35.004]             {
[16:20:35.004]                 {
[16:20:35.004]                   {
[16:20:35.004]                     base::local({
[16:20:35.004]                       has_future <- base::requireNamespace("future", 
[16:20:35.004]                         quietly = TRUE)
[16:20:35.004]                       if (has_future) {
[16:20:35.004]                         ns <- base::getNamespace("future")
[16:20:35.004]                         version <- ns[[".package"]][["version"]]
[16:20:35.004]                         if (is.null(version)) 
[16:20:35.004]                           version <- utils::packageVersion("future")
[16:20:35.004]                       }
[16:20:35.004]                       else {
[16:20:35.004]                         version <- NULL
[16:20:35.004]                       }
[16:20:35.004]                       if (!has_future || version < "1.8.0") {
[16:20:35.004]                         info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.004]                           "", base::R.version$version.string), 
[16:20:35.004]                           platform = base::sprintf("%s (%s-bit)", 
[16:20:35.004]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.004]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.004]                             "release", "version")], collapse = " "), 
[16:20:35.004]                           hostname = base::Sys.info()[["nodename"]])
[16:20:35.004]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.004]                           info)
[16:20:35.004]                         info <- base::paste(info, collapse = "; ")
[16:20:35.004]                         if (!has_future) {
[16:20:35.004]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.004]                             info)
[16:20:35.004]                         }
[16:20:35.004]                         else {
[16:20:35.004]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.004]                             info, version)
[16:20:35.004]                         }
[16:20:35.004]                         base::stop(msg)
[16:20:35.004]                       }
[16:20:35.004]                     })
[16:20:35.004]                   }
[16:20:35.004]                   ...future.strategy.old <- future::plan("list")
[16:20:35.004]                   options(future.plan = NULL)
[16:20:35.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.004]                 }
[16:20:35.004]                 ...future.workdir <- getwd()
[16:20:35.004]             }
[16:20:35.004]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.004]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.004]         }
[16:20:35.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.004]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.004]             base::names(...future.oldOptions))
[16:20:35.004]     }
[16:20:35.004]     if (FALSE) {
[16:20:35.004]     }
[16:20:35.004]     else {
[16:20:35.004]         if (TRUE) {
[16:20:35.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.004]                 open = "w")
[16:20:35.004]         }
[16:20:35.004]         else {
[16:20:35.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.004]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.004]         }
[16:20:35.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.004]             base::sink(type = "output", split = FALSE)
[16:20:35.004]             base::close(...future.stdout)
[16:20:35.004]         }, add = TRUE)
[16:20:35.004]     }
[16:20:35.004]     ...future.frame <- base::sys.nframe()
[16:20:35.004]     ...future.conditions <- base::list()
[16:20:35.004]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.004]     if (FALSE) {
[16:20:35.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.004]     }
[16:20:35.004]     ...future.result <- base::tryCatch({
[16:20:35.004]         base::withCallingHandlers({
[16:20:35.004]             ...future.value <- base::withVisible(base::local({
[16:20:35.004]                 2 * a
[16:20:35.004]             }))
[16:20:35.004]             future::FutureResult(value = ...future.value$value, 
[16:20:35.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.004]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.004]                     ...future.globalenv.names))
[16:20:35.004]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.004]         }, condition = base::local({
[16:20:35.004]             c <- base::c
[16:20:35.004]             inherits <- base::inherits
[16:20:35.004]             invokeRestart <- base::invokeRestart
[16:20:35.004]             length <- base::length
[16:20:35.004]             list <- base::list
[16:20:35.004]             seq.int <- base::seq.int
[16:20:35.004]             signalCondition <- base::signalCondition
[16:20:35.004]             sys.calls <- base::sys.calls
[16:20:35.004]             `[[` <- base::`[[`
[16:20:35.004]             `+` <- base::`+`
[16:20:35.004]             `<<-` <- base::`<<-`
[16:20:35.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.004]                   3L)]
[16:20:35.004]             }
[16:20:35.004]             function(cond) {
[16:20:35.004]                 is_error <- inherits(cond, "error")
[16:20:35.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.004]                   NULL)
[16:20:35.004]                 if (is_error) {
[16:20:35.004]                   sessionInformation <- function() {
[16:20:35.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.004]                       search = base::search(), system = base::Sys.info())
[16:20:35.004]                   }
[16:20:35.004]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.004]                     cond$call), session = sessionInformation(), 
[16:20:35.004]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.004]                   signalCondition(cond)
[16:20:35.004]                 }
[16:20:35.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.004]                 "immediateCondition"))) {
[16:20:35.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.004]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.004]                   if (TRUE && !signal) {
[16:20:35.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.004]                     {
[16:20:35.004]                       inherits <- base::inherits
[16:20:35.004]                       invokeRestart <- base::invokeRestart
[16:20:35.004]                       is.null <- base::is.null
[16:20:35.004]                       muffled <- FALSE
[16:20:35.004]                       if (inherits(cond, "message")) {
[16:20:35.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.004]                         if (muffled) 
[16:20:35.004]                           invokeRestart("muffleMessage")
[16:20:35.004]                       }
[16:20:35.004]                       else if (inherits(cond, "warning")) {
[16:20:35.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.004]                         if (muffled) 
[16:20:35.004]                           invokeRestart("muffleWarning")
[16:20:35.004]                       }
[16:20:35.004]                       else if (inherits(cond, "condition")) {
[16:20:35.004]                         if (!is.null(pattern)) {
[16:20:35.004]                           computeRestarts <- base::computeRestarts
[16:20:35.004]                           grepl <- base::grepl
[16:20:35.004]                           restarts <- computeRestarts(cond)
[16:20:35.004]                           for (restart in restarts) {
[16:20:35.004]                             name <- restart$name
[16:20:35.004]                             if (is.null(name)) 
[16:20:35.004]                               next
[16:20:35.004]                             if (!grepl(pattern, name)) 
[16:20:35.004]                               next
[16:20:35.004]                             invokeRestart(restart)
[16:20:35.004]                             muffled <- TRUE
[16:20:35.004]                             break
[16:20:35.004]                           }
[16:20:35.004]                         }
[16:20:35.004]                       }
[16:20:35.004]                       invisible(muffled)
[16:20:35.004]                     }
[16:20:35.004]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.004]                   }
[16:20:35.004]                 }
[16:20:35.004]                 else {
[16:20:35.004]                   if (TRUE) {
[16:20:35.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.004]                     {
[16:20:35.004]                       inherits <- base::inherits
[16:20:35.004]                       invokeRestart <- base::invokeRestart
[16:20:35.004]                       is.null <- base::is.null
[16:20:35.004]                       muffled <- FALSE
[16:20:35.004]                       if (inherits(cond, "message")) {
[16:20:35.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.004]                         if (muffled) 
[16:20:35.004]                           invokeRestart("muffleMessage")
[16:20:35.004]                       }
[16:20:35.004]                       else if (inherits(cond, "warning")) {
[16:20:35.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.004]                         if (muffled) 
[16:20:35.004]                           invokeRestart("muffleWarning")
[16:20:35.004]                       }
[16:20:35.004]                       else if (inherits(cond, "condition")) {
[16:20:35.004]                         if (!is.null(pattern)) {
[16:20:35.004]                           computeRestarts <- base::computeRestarts
[16:20:35.004]                           grepl <- base::grepl
[16:20:35.004]                           restarts <- computeRestarts(cond)
[16:20:35.004]                           for (restart in restarts) {
[16:20:35.004]                             name <- restart$name
[16:20:35.004]                             if (is.null(name)) 
[16:20:35.004]                               next
[16:20:35.004]                             if (!grepl(pattern, name)) 
[16:20:35.004]                               next
[16:20:35.004]                             invokeRestart(restart)
[16:20:35.004]                             muffled <- TRUE
[16:20:35.004]                             break
[16:20:35.004]                           }
[16:20:35.004]                         }
[16:20:35.004]                       }
[16:20:35.004]                       invisible(muffled)
[16:20:35.004]                     }
[16:20:35.004]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.004]                   }
[16:20:35.004]                 }
[16:20:35.004]             }
[16:20:35.004]         }))
[16:20:35.004]     }, error = function(ex) {
[16:20:35.004]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.004]                 ...future.rng), started = ...future.startTime, 
[16:20:35.004]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.004]             version = "1.8"), class = "FutureResult")
[16:20:35.004]     }, finally = {
[16:20:35.004]         if (!identical(...future.workdir, getwd())) 
[16:20:35.004]             setwd(...future.workdir)
[16:20:35.004]         {
[16:20:35.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.004]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.004]             }
[16:20:35.004]             base::options(...future.oldOptions)
[16:20:35.004]             if (.Platform$OS.type == "windows") {
[16:20:35.004]                 old_names <- names(...future.oldEnvVars)
[16:20:35.004]                 envs <- base::Sys.getenv()
[16:20:35.004]                 names <- names(envs)
[16:20:35.004]                 common <- intersect(names, old_names)
[16:20:35.004]                 added <- setdiff(names, old_names)
[16:20:35.004]                 removed <- setdiff(old_names, names)
[16:20:35.004]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.004]                   envs[common]]
[16:20:35.004]                 NAMES <- toupper(changed)
[16:20:35.004]                 args <- list()
[16:20:35.004]                 for (kk in seq_along(NAMES)) {
[16:20:35.004]                   name <- changed[[kk]]
[16:20:35.004]                   NAME <- NAMES[[kk]]
[16:20:35.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.004]                     next
[16:20:35.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.004]                 }
[16:20:35.004]                 NAMES <- toupper(added)
[16:20:35.004]                 for (kk in seq_along(NAMES)) {
[16:20:35.004]                   name <- added[[kk]]
[16:20:35.004]                   NAME <- NAMES[[kk]]
[16:20:35.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.004]                     next
[16:20:35.004]                   args[[name]] <- ""
[16:20:35.004]                 }
[16:20:35.004]                 NAMES <- toupper(removed)
[16:20:35.004]                 for (kk in seq_along(NAMES)) {
[16:20:35.004]                   name <- removed[[kk]]
[16:20:35.004]                   NAME <- NAMES[[kk]]
[16:20:35.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.004]                     next
[16:20:35.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.004]                 }
[16:20:35.004]                 if (length(args) > 0) 
[16:20:35.004]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.004]             }
[16:20:35.004]             else {
[16:20:35.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.004]             }
[16:20:35.004]             {
[16:20:35.004]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.004]                   0L) {
[16:20:35.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.004]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.004]                   base::options(opts)
[16:20:35.004]                 }
[16:20:35.004]                 {
[16:20:35.004]                   {
[16:20:35.004]                     NULL
[16:20:35.004]                     RNGkind("Mersenne-Twister")
[16:20:35.004]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:20:35.004]                       inherits = FALSE)
[16:20:35.004]                   }
[16:20:35.004]                   options(future.plan = NULL)
[16:20:35.004]                   if (is.na(NA_character_)) 
[16:20:35.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.004]                     .init = FALSE)
[16:20:35.004]                 }
[16:20:35.004]             }
[16:20:35.004]         }
[16:20:35.004]     })
[16:20:35.004]     if (TRUE) {
[16:20:35.004]         base::sink(type = "output", split = FALSE)
[16:20:35.004]         if (TRUE) {
[16:20:35.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.004]         }
[16:20:35.004]         else {
[16:20:35.004]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.004]         }
[16:20:35.004]         base::close(...future.stdout)
[16:20:35.004]         ...future.stdout <- NULL
[16:20:35.004]     }
[16:20:35.004]     ...future.result$conditions <- ...future.conditions
[16:20:35.004]     ...future.result$finished <- base::Sys.time()
[16:20:35.004]     ...future.result
[16:20:35.004] }
[16:20:35.006] assign_globals() ...
[16:20:35.006] List of 1
[16:20:35.006]  $ a: num 1
[16:20:35.006]  - attr(*, "where")=List of 1
[16:20:35.006]   ..$ a:<environment: R_EmptyEnv> 
[16:20:35.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:35.006]  - attr(*, "resolved")= logi FALSE
[16:20:35.006]  - attr(*, "total_size")= num 56
[16:20:35.006]  - attr(*, "already-done")= logi TRUE
[16:20:35.008] - copied ‘a’ to environment
[16:20:35.008] assign_globals() ... done
[16:20:35.008] plan(): Setting new future strategy stack:
[16:20:35.008] List of future strategies:
[16:20:35.008] 1. sequential:
[16:20:35.008]    - args: function (..., envir = parent.frame())
[16:20:35.008]    - tweaked: FALSE
[16:20:35.008]    - call: NULL
[16:20:35.009] plan(): nbrOfWorkers() = 1
[16:20:35.009] plan(): Setting new future strategy stack:
[16:20:35.010] List of future strategies:
[16:20:35.010] 1. sequential:
[16:20:35.010]    - args: function (..., envir = parent.frame())
[16:20:35.010]    - tweaked: FALSE
[16:20:35.010]    - call: plan(strategy)
[16:20:35.010] plan(): nbrOfWorkers() = 1
[16:20:35.010] SequentialFuture started (and completed)
[16:20:35.010] - Launch lazy future ... done
[16:20:35.010] run() for ‘SequentialFuture’ ... done
*** futureAssign() with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** futureAssign() with ‘multicore’ futures ...
[16:20:35.016] plan(): Setting new future strategy stack:
[16:20:35.016] List of future strategies:
[16:20:35.016] 1. multicore:
[16:20:35.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.016]    - tweaked: FALSE
[16:20:35.016]    - call: plan(strategy)
[16:20:35.020] plan(): nbrOfWorkers() = 2
[16:20:35.020] getGlobalsAndPackages() ...
[16:20:35.020] Searching for globals...
[16:20:35.021] - globals found: [1] ‘{’
[16:20:35.021] Searching for globals ... DONE
[16:20:35.021] Resolving globals: FALSE
[16:20:35.022] 
[16:20:35.022] 
[16:20:35.022] getGlobalsAndPackages() ... DONE
[16:20:35.022] run() for ‘Future’ ...
[16:20:35.022] - state: ‘created’
[16:20:35.022] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.026] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.026]   - Field: ‘label’
[16:20:35.026]   - Field: ‘local’
[16:20:35.026]   - Field: ‘owner’
[16:20:35.026]   - Field: ‘envir’
[16:20:35.026]   - Field: ‘workers’
[16:20:35.026]   - Field: ‘packages’
[16:20:35.027]   - Field: ‘gc’
[16:20:35.027]   - Field: ‘job’
[16:20:35.027]   - Field: ‘conditions’
[16:20:35.027]   - Field: ‘expr’
[16:20:35.027]   - Field: ‘uuid’
[16:20:35.027]   - Field: ‘seed’
[16:20:35.027]   - Field: ‘version’
[16:20:35.027]   - Field: ‘result’
[16:20:35.027]   - Field: ‘asynchronous’
[16:20:35.027]   - Field: ‘calls’
[16:20:35.027]   - Field: ‘globals’
[16:20:35.028]   - Field: ‘stdout’
[16:20:35.028]   - Field: ‘earlySignal’
[16:20:35.028]   - Field: ‘lazy’
[16:20:35.028]   - Field: ‘state’
[16:20:35.028] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.028] - Launch lazy future ...
[16:20:35.029] Packages needed by the future expression (n = 0): <none>
[16:20:35.029] Packages needed by future strategies (n = 0): <none>
[16:20:35.029] {
[16:20:35.029]     {
[16:20:35.029]         {
[16:20:35.029]             ...future.startTime <- base::Sys.time()
[16:20:35.029]             {
[16:20:35.029]                 {
[16:20:35.029]                   {
[16:20:35.029]                     {
[16:20:35.029]                       base::local({
[16:20:35.029]                         has_future <- base::requireNamespace("future", 
[16:20:35.029]                           quietly = TRUE)
[16:20:35.029]                         if (has_future) {
[16:20:35.029]                           ns <- base::getNamespace("future")
[16:20:35.029]                           version <- ns[[".package"]][["version"]]
[16:20:35.029]                           if (is.null(version)) 
[16:20:35.029]                             version <- utils::packageVersion("future")
[16:20:35.029]                         }
[16:20:35.029]                         else {
[16:20:35.029]                           version <- NULL
[16:20:35.029]                         }
[16:20:35.029]                         if (!has_future || version < "1.8.0") {
[16:20:35.029]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.029]                             "", base::R.version$version.string), 
[16:20:35.029]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.029]                               "release", "version")], collapse = " "), 
[16:20:35.029]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.029]                             info)
[16:20:35.029]                           info <- base::paste(info, collapse = "; ")
[16:20:35.029]                           if (!has_future) {
[16:20:35.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.029]                               info)
[16:20:35.029]                           }
[16:20:35.029]                           else {
[16:20:35.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.029]                               info, version)
[16:20:35.029]                           }
[16:20:35.029]                           base::stop(msg)
[16:20:35.029]                         }
[16:20:35.029]                       })
[16:20:35.029]                     }
[16:20:35.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.029]                     base::options(mc.cores = 1L)
[16:20:35.029]                   }
[16:20:35.029]                   ...future.strategy.old <- future::plan("list")
[16:20:35.029]                   options(future.plan = NULL)
[16:20:35.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.029]                 }
[16:20:35.029]                 ...future.workdir <- getwd()
[16:20:35.029]             }
[16:20:35.029]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.029]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.029]         }
[16:20:35.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.029]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.029]             base::names(...future.oldOptions))
[16:20:35.029]     }
[16:20:35.029]     if (FALSE) {
[16:20:35.029]     }
[16:20:35.029]     else {
[16:20:35.029]         if (TRUE) {
[16:20:35.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.029]                 open = "w")
[16:20:35.029]         }
[16:20:35.029]         else {
[16:20:35.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.029]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.029]         }
[16:20:35.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.029]             base::sink(type = "output", split = FALSE)
[16:20:35.029]             base::close(...future.stdout)
[16:20:35.029]         }, add = TRUE)
[16:20:35.029]     }
[16:20:35.029]     ...future.frame <- base::sys.nframe()
[16:20:35.029]     ...future.conditions <- base::list()
[16:20:35.029]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.029]     if (FALSE) {
[16:20:35.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.029]     }
[16:20:35.029]     ...future.result <- base::tryCatch({
[16:20:35.029]         base::withCallingHandlers({
[16:20:35.029]             ...future.value <- base::withVisible(base::local({
[16:20:35.029]                 withCallingHandlers({
[16:20:35.029]                   {
[16:20:35.029]                     2
[16:20:35.029]                   }
[16:20:35.029]                 }, immediateCondition = function(cond) {
[16:20:35.029]                   save_rds <- function (object, pathname, ...) 
[16:20:35.029]                   {
[16:20:35.029]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.029]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.029]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.029]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.029]                         fi_tmp[["mtime"]])
[16:20:35.029]                     }
[16:20:35.029]                     tryCatch({
[16:20:35.029]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.029]                     }, error = function(ex) {
[16:20:35.029]                       msg <- conditionMessage(ex)
[16:20:35.029]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.029]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.029]                         fi_tmp[["mtime"]], msg)
[16:20:35.029]                       ex$message <- msg
[16:20:35.029]                       stop(ex)
[16:20:35.029]                     })
[16:20:35.029]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.029]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.029]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.029]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.029]                       fi <- file.info(pathname)
[16:20:35.029]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.029]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.029]                         fi[["size"]], fi[["mtime"]])
[16:20:35.029]                       stop(msg)
[16:20:35.029]                     }
[16:20:35.029]                     invisible(pathname)
[16:20:35.029]                   }
[16:20:35.029]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.029]                     rootPath = tempdir()) 
[16:20:35.029]                   {
[16:20:35.029]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.029]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.029]                       tmpdir = path, fileext = ".rds")
[16:20:35.029]                     save_rds(obj, file)
[16:20:35.029]                   }
[16:20:35.029]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.029]                   {
[16:20:35.029]                     inherits <- base::inherits
[16:20:35.029]                     invokeRestart <- base::invokeRestart
[16:20:35.029]                     is.null <- base::is.null
[16:20:35.029]                     muffled <- FALSE
[16:20:35.029]                     if (inherits(cond, "message")) {
[16:20:35.029]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.029]                       if (muffled) 
[16:20:35.029]                         invokeRestart("muffleMessage")
[16:20:35.029]                     }
[16:20:35.029]                     else if (inherits(cond, "warning")) {
[16:20:35.029]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.029]                       if (muffled) 
[16:20:35.029]                         invokeRestart("muffleWarning")
[16:20:35.029]                     }
[16:20:35.029]                     else if (inherits(cond, "condition")) {
[16:20:35.029]                       if (!is.null(pattern)) {
[16:20:35.029]                         computeRestarts <- base::computeRestarts
[16:20:35.029]                         grepl <- base::grepl
[16:20:35.029]                         restarts <- computeRestarts(cond)
[16:20:35.029]                         for (restart in restarts) {
[16:20:35.029]                           name <- restart$name
[16:20:35.029]                           if (is.null(name)) 
[16:20:35.029]                             next
[16:20:35.029]                           if (!grepl(pattern, name)) 
[16:20:35.029]                             next
[16:20:35.029]                           invokeRestart(restart)
[16:20:35.029]                           muffled <- TRUE
[16:20:35.029]                           break
[16:20:35.029]                         }
[16:20:35.029]                       }
[16:20:35.029]                     }
[16:20:35.029]                     invisible(muffled)
[16:20:35.029]                   }
[16:20:35.029]                   muffleCondition(cond)
[16:20:35.029]                 })
[16:20:35.029]             }))
[16:20:35.029]             future::FutureResult(value = ...future.value$value, 
[16:20:35.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.029]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.029]                     ...future.globalenv.names))
[16:20:35.029]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.029]         }, condition = base::local({
[16:20:35.029]             c <- base::c
[16:20:35.029]             inherits <- base::inherits
[16:20:35.029]             invokeRestart <- base::invokeRestart
[16:20:35.029]             length <- base::length
[16:20:35.029]             list <- base::list
[16:20:35.029]             seq.int <- base::seq.int
[16:20:35.029]             signalCondition <- base::signalCondition
[16:20:35.029]             sys.calls <- base::sys.calls
[16:20:35.029]             `[[` <- base::`[[`
[16:20:35.029]             `+` <- base::`+`
[16:20:35.029]             `<<-` <- base::`<<-`
[16:20:35.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.029]                   3L)]
[16:20:35.029]             }
[16:20:35.029]             function(cond) {
[16:20:35.029]                 is_error <- inherits(cond, "error")
[16:20:35.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.029]                   NULL)
[16:20:35.029]                 if (is_error) {
[16:20:35.029]                   sessionInformation <- function() {
[16:20:35.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.029]                       search = base::search(), system = base::Sys.info())
[16:20:35.029]                   }
[16:20:35.029]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.029]                     cond$call), session = sessionInformation(), 
[16:20:35.029]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.029]                   signalCondition(cond)
[16:20:35.029]                 }
[16:20:35.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.029]                 "immediateCondition"))) {
[16:20:35.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.029]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.029]                   if (TRUE && !signal) {
[16:20:35.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.029]                     {
[16:20:35.029]                       inherits <- base::inherits
[16:20:35.029]                       invokeRestart <- base::invokeRestart
[16:20:35.029]                       is.null <- base::is.null
[16:20:35.029]                       muffled <- FALSE
[16:20:35.029]                       if (inherits(cond, "message")) {
[16:20:35.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.029]                         if (muffled) 
[16:20:35.029]                           invokeRestart("muffleMessage")
[16:20:35.029]                       }
[16:20:35.029]                       else if (inherits(cond, "warning")) {
[16:20:35.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.029]                         if (muffled) 
[16:20:35.029]                           invokeRestart("muffleWarning")
[16:20:35.029]                       }
[16:20:35.029]                       else if (inherits(cond, "condition")) {
[16:20:35.029]                         if (!is.null(pattern)) {
[16:20:35.029]                           computeRestarts <- base::computeRestarts
[16:20:35.029]                           grepl <- base::grepl
[16:20:35.029]                           restarts <- computeRestarts(cond)
[16:20:35.029]                           for (restart in restarts) {
[16:20:35.029]                             name <- restart$name
[16:20:35.029]                             if (is.null(name)) 
[16:20:35.029]                               next
[16:20:35.029]                             if (!grepl(pattern, name)) 
[16:20:35.029]                               next
[16:20:35.029]                             invokeRestart(restart)
[16:20:35.029]                             muffled <- TRUE
[16:20:35.029]                             break
[16:20:35.029]                           }
[16:20:35.029]                         }
[16:20:35.029]                       }
[16:20:35.029]                       invisible(muffled)
[16:20:35.029]                     }
[16:20:35.029]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.029]                   }
[16:20:35.029]                 }
[16:20:35.029]                 else {
[16:20:35.029]                   if (TRUE) {
[16:20:35.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.029]                     {
[16:20:35.029]                       inherits <- base::inherits
[16:20:35.029]                       invokeRestart <- base::invokeRestart
[16:20:35.029]                       is.null <- base::is.null
[16:20:35.029]                       muffled <- FALSE
[16:20:35.029]                       if (inherits(cond, "message")) {
[16:20:35.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.029]                         if (muffled) 
[16:20:35.029]                           invokeRestart("muffleMessage")
[16:20:35.029]                       }
[16:20:35.029]                       else if (inherits(cond, "warning")) {
[16:20:35.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.029]                         if (muffled) 
[16:20:35.029]                           invokeRestart("muffleWarning")
[16:20:35.029]                       }
[16:20:35.029]                       else if (inherits(cond, "condition")) {
[16:20:35.029]                         if (!is.null(pattern)) {
[16:20:35.029]                           computeRestarts <- base::computeRestarts
[16:20:35.029]                           grepl <- base::grepl
[16:20:35.029]                           restarts <- computeRestarts(cond)
[16:20:35.029]                           for (restart in restarts) {
[16:20:35.029]                             name <- restart$name
[16:20:35.029]                             if (is.null(name)) 
[16:20:35.029]                               next
[16:20:35.029]                             if (!grepl(pattern, name)) 
[16:20:35.029]                               next
[16:20:35.029]                             invokeRestart(restart)
[16:20:35.029]                             muffled <- TRUE
[16:20:35.029]                             break
[16:20:35.029]                           }
[16:20:35.029]                         }
[16:20:35.029]                       }
[16:20:35.029]                       invisible(muffled)
[16:20:35.029]                     }
[16:20:35.029]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.029]                   }
[16:20:35.029]                 }
[16:20:35.029]             }
[16:20:35.029]         }))
[16:20:35.029]     }, error = function(ex) {
[16:20:35.029]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.029]                 ...future.rng), started = ...future.startTime, 
[16:20:35.029]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.029]             version = "1.8"), class = "FutureResult")
[16:20:35.029]     }, finally = {
[16:20:35.029]         if (!identical(...future.workdir, getwd())) 
[16:20:35.029]             setwd(...future.workdir)
[16:20:35.029]         {
[16:20:35.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.029]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.029]             }
[16:20:35.029]             base::options(...future.oldOptions)
[16:20:35.029]             if (.Platform$OS.type == "windows") {
[16:20:35.029]                 old_names <- names(...future.oldEnvVars)
[16:20:35.029]                 envs <- base::Sys.getenv()
[16:20:35.029]                 names <- names(envs)
[16:20:35.029]                 common <- intersect(names, old_names)
[16:20:35.029]                 added <- setdiff(names, old_names)
[16:20:35.029]                 removed <- setdiff(old_names, names)
[16:20:35.029]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.029]                   envs[common]]
[16:20:35.029]                 NAMES <- toupper(changed)
[16:20:35.029]                 args <- list()
[16:20:35.029]                 for (kk in seq_along(NAMES)) {
[16:20:35.029]                   name <- changed[[kk]]
[16:20:35.029]                   NAME <- NAMES[[kk]]
[16:20:35.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.029]                     next
[16:20:35.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.029]                 }
[16:20:35.029]                 NAMES <- toupper(added)
[16:20:35.029]                 for (kk in seq_along(NAMES)) {
[16:20:35.029]                   name <- added[[kk]]
[16:20:35.029]                   NAME <- NAMES[[kk]]
[16:20:35.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.029]                     next
[16:20:35.029]                   args[[name]] <- ""
[16:20:35.029]                 }
[16:20:35.029]                 NAMES <- toupper(removed)
[16:20:35.029]                 for (kk in seq_along(NAMES)) {
[16:20:35.029]                   name <- removed[[kk]]
[16:20:35.029]                   NAME <- NAMES[[kk]]
[16:20:35.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.029]                     next
[16:20:35.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.029]                 }
[16:20:35.029]                 if (length(args) > 0) 
[16:20:35.029]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.029]             }
[16:20:35.029]             else {
[16:20:35.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.029]             }
[16:20:35.029]             {
[16:20:35.029]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.029]                   0L) {
[16:20:35.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.029]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.029]                   base::options(opts)
[16:20:35.029]                 }
[16:20:35.029]                 {
[16:20:35.029]                   {
[16:20:35.029]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.029]                     NULL
[16:20:35.029]                   }
[16:20:35.029]                   options(future.plan = NULL)
[16:20:35.029]                   if (is.na(NA_character_)) 
[16:20:35.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.029]                     .init = FALSE)
[16:20:35.029]                 }
[16:20:35.029]             }
[16:20:35.029]         }
[16:20:35.029]     })
[16:20:35.029]     if (TRUE) {
[16:20:35.029]         base::sink(type = "output", split = FALSE)
[16:20:35.029]         if (TRUE) {
[16:20:35.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.029]         }
[16:20:35.029]         else {
[16:20:35.029]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.029]         }
[16:20:35.029]         base::close(...future.stdout)
[16:20:35.029]         ...future.stdout <- NULL
[16:20:35.029]     }
[16:20:35.029]     ...future.result$conditions <- ...future.conditions
[16:20:35.029]     ...future.result$finished <- base::Sys.time()
[16:20:35.029]     ...future.result
[16:20:35.029] }
[16:20:35.032] requestCore(): workers = 2
[16:20:35.035] MulticoreFuture started
[16:20:35.035] - Launch lazy future ... done
[16:20:35.035] run() for ‘MulticoreFuture’ ... done
[16:20:35.035] plan(): Setting new future strategy stack:
[16:20:35.036] getGlobalsAndPackages() ...
[16:20:35.036] Searching for globals...
[16:20:35.036] List of future strategies:
[16:20:35.036] 1. sequential:
[16:20:35.036]    - args: function (..., envir = parent.frame())
[16:20:35.036]    - tweaked: FALSE
[16:20:35.036]    - call: NULL
[16:20:35.036] plan(): nbrOfWorkers() = 1
[16:20:35.038] - globals found: [1] ‘{’
[16:20:35.038] Searching for globals ... DONE
[16:20:35.038] Resolving globals: FALSE
[16:20:35.038] plan(): Setting new future strategy stack:
[16:20:35.038] List of future strategies:
[16:20:35.038] 1. multicore:
[16:20:35.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.038]    - tweaked: FALSE
[16:20:35.038]    - call: plan(strategy)
[16:20:35.039] 
[16:20:35.039] 
[16:20:35.039] getGlobalsAndPackages() ... DONE
[16:20:35.040] run() for ‘Future’ ...
[16:20:35.040] - state: ‘created’
[16:20:35.040] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.043] plan(): nbrOfWorkers() = 2
[16:20:35.045] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.045]   - Field: ‘label’
[16:20:35.045]   - Field: ‘local’
[16:20:35.045]   - Field: ‘owner’
[16:20:35.046]   - Field: ‘envir’
[16:20:35.046]   - Field: ‘workers’
[16:20:35.046]   - Field: ‘packages’
[16:20:35.046]   - Field: ‘gc’
[16:20:35.046]   - Field: ‘job’
[16:20:35.046]   - Field: ‘conditions’
[16:20:35.046]   - Field: ‘expr’
[16:20:35.047]   - Field: ‘uuid’
[16:20:35.047]   - Field: ‘seed’
[16:20:35.047]   - Field: ‘version’
[16:20:35.047]   - Field: ‘result’
[16:20:35.047]   - Field: ‘asynchronous’
[16:20:35.047]   - Field: ‘calls’
[16:20:35.047]   - Field: ‘globals’
[16:20:35.048]   - Field: ‘stdout’
[16:20:35.048]   - Field: ‘earlySignal’
[16:20:35.048]   - Field: ‘lazy’
[16:20:35.048]   - Field: ‘state’
[16:20:35.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.048] - Launch lazy future ...
[16:20:35.049] Packages needed by the future expression (n = 0): <none>
[16:20:35.049] Packages needed by future strategies (n = 0): <none>
[16:20:35.050] {
[16:20:35.050]     {
[16:20:35.050]         {
[16:20:35.050]             ...future.startTime <- base::Sys.time()
[16:20:35.050]             {
[16:20:35.050]                 {
[16:20:35.050]                   {
[16:20:35.050]                     {
[16:20:35.050]                       base::local({
[16:20:35.050]                         has_future <- base::requireNamespace("future", 
[16:20:35.050]                           quietly = TRUE)
[16:20:35.050]                         if (has_future) {
[16:20:35.050]                           ns <- base::getNamespace("future")
[16:20:35.050]                           version <- ns[[".package"]][["version"]]
[16:20:35.050]                           if (is.null(version)) 
[16:20:35.050]                             version <- utils::packageVersion("future")
[16:20:35.050]                         }
[16:20:35.050]                         else {
[16:20:35.050]                           version <- NULL
[16:20:35.050]                         }
[16:20:35.050]                         if (!has_future || version < "1.8.0") {
[16:20:35.050]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.050]                             "", base::R.version$version.string), 
[16:20:35.050]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.050]                               "release", "version")], collapse = " "), 
[16:20:35.050]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.050]                             info)
[16:20:35.050]                           info <- base::paste(info, collapse = "; ")
[16:20:35.050]                           if (!has_future) {
[16:20:35.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.050]                               info)
[16:20:35.050]                           }
[16:20:35.050]                           else {
[16:20:35.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.050]                               info, version)
[16:20:35.050]                           }
[16:20:35.050]                           base::stop(msg)
[16:20:35.050]                         }
[16:20:35.050]                       })
[16:20:35.050]                     }
[16:20:35.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.050]                     base::options(mc.cores = 1L)
[16:20:35.050]                   }
[16:20:35.050]                   ...future.strategy.old <- future::plan("list")
[16:20:35.050]                   options(future.plan = NULL)
[16:20:35.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.050]                 }
[16:20:35.050]                 ...future.workdir <- getwd()
[16:20:35.050]             }
[16:20:35.050]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.050]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.050]         }
[16:20:35.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.050]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.050]             base::names(...future.oldOptions))
[16:20:35.050]     }
[16:20:35.050]     if (FALSE) {
[16:20:35.050]     }
[16:20:35.050]     else {
[16:20:35.050]         if (TRUE) {
[16:20:35.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.050]                 open = "w")
[16:20:35.050]         }
[16:20:35.050]         else {
[16:20:35.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.050]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.050]         }
[16:20:35.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.050]             base::sink(type = "output", split = FALSE)
[16:20:35.050]             base::close(...future.stdout)
[16:20:35.050]         }, add = TRUE)
[16:20:35.050]     }
[16:20:35.050]     ...future.frame <- base::sys.nframe()
[16:20:35.050]     ...future.conditions <- base::list()
[16:20:35.050]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.050]     if (FALSE) {
[16:20:35.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.050]     }
[16:20:35.050]     ...future.result <- base::tryCatch({
[16:20:35.050]         base::withCallingHandlers({
[16:20:35.050]             ...future.value <- base::withVisible(base::local({
[16:20:35.050]                 withCallingHandlers({
[16:20:35.050]                   {
[16:20:35.050]                     4
[16:20:35.050]                   }
[16:20:35.050]                 }, immediateCondition = function(cond) {
[16:20:35.050]                   save_rds <- function (object, pathname, ...) 
[16:20:35.050]                   {
[16:20:35.050]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.050]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.050]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.050]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.050]                         fi_tmp[["mtime"]])
[16:20:35.050]                     }
[16:20:35.050]                     tryCatch({
[16:20:35.050]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.050]                     }, error = function(ex) {
[16:20:35.050]                       msg <- conditionMessage(ex)
[16:20:35.050]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.050]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.050]                         fi_tmp[["mtime"]], msg)
[16:20:35.050]                       ex$message <- msg
[16:20:35.050]                       stop(ex)
[16:20:35.050]                     })
[16:20:35.050]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.050]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.050]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.050]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.050]                       fi <- file.info(pathname)
[16:20:35.050]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.050]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.050]                         fi[["size"]], fi[["mtime"]])
[16:20:35.050]                       stop(msg)
[16:20:35.050]                     }
[16:20:35.050]                     invisible(pathname)
[16:20:35.050]                   }
[16:20:35.050]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.050]                     rootPath = tempdir()) 
[16:20:35.050]                   {
[16:20:35.050]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.050]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.050]                       tmpdir = path, fileext = ".rds")
[16:20:35.050]                     save_rds(obj, file)
[16:20:35.050]                   }
[16:20:35.050]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.050]                   {
[16:20:35.050]                     inherits <- base::inherits
[16:20:35.050]                     invokeRestart <- base::invokeRestart
[16:20:35.050]                     is.null <- base::is.null
[16:20:35.050]                     muffled <- FALSE
[16:20:35.050]                     if (inherits(cond, "message")) {
[16:20:35.050]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.050]                       if (muffled) 
[16:20:35.050]                         invokeRestart("muffleMessage")
[16:20:35.050]                     }
[16:20:35.050]                     else if (inherits(cond, "warning")) {
[16:20:35.050]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.050]                       if (muffled) 
[16:20:35.050]                         invokeRestart("muffleWarning")
[16:20:35.050]                     }
[16:20:35.050]                     else if (inherits(cond, "condition")) {
[16:20:35.050]                       if (!is.null(pattern)) {
[16:20:35.050]                         computeRestarts <- base::computeRestarts
[16:20:35.050]                         grepl <- base::grepl
[16:20:35.050]                         restarts <- computeRestarts(cond)
[16:20:35.050]                         for (restart in restarts) {
[16:20:35.050]                           name <- restart$name
[16:20:35.050]                           if (is.null(name)) 
[16:20:35.050]                             next
[16:20:35.050]                           if (!grepl(pattern, name)) 
[16:20:35.050]                             next
[16:20:35.050]                           invokeRestart(restart)
[16:20:35.050]                           muffled <- TRUE
[16:20:35.050]                           break
[16:20:35.050]                         }
[16:20:35.050]                       }
[16:20:35.050]                     }
[16:20:35.050]                     invisible(muffled)
[16:20:35.050]                   }
[16:20:35.050]                   muffleCondition(cond)
[16:20:35.050]                 })
[16:20:35.050]             }))
[16:20:35.050]             future::FutureResult(value = ...future.value$value, 
[16:20:35.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.050]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.050]                     ...future.globalenv.names))
[16:20:35.050]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.050]         }, condition = base::local({
[16:20:35.050]             c <- base::c
[16:20:35.050]             inherits <- base::inherits
[16:20:35.050]             invokeRestart <- base::invokeRestart
[16:20:35.050]             length <- base::length
[16:20:35.050]             list <- base::list
[16:20:35.050]             seq.int <- base::seq.int
[16:20:35.050]             signalCondition <- base::signalCondition
[16:20:35.050]             sys.calls <- base::sys.calls
[16:20:35.050]             `[[` <- base::`[[`
[16:20:35.050]             `+` <- base::`+`
[16:20:35.050]             `<<-` <- base::`<<-`
[16:20:35.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.050]                   3L)]
[16:20:35.050]             }
[16:20:35.050]             function(cond) {
[16:20:35.050]                 is_error <- inherits(cond, "error")
[16:20:35.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.050]                   NULL)
[16:20:35.050]                 if (is_error) {
[16:20:35.050]                   sessionInformation <- function() {
[16:20:35.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.050]                       search = base::search(), system = base::Sys.info())
[16:20:35.050]                   }
[16:20:35.050]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.050]                     cond$call), session = sessionInformation(), 
[16:20:35.050]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.050]                   signalCondition(cond)
[16:20:35.050]                 }
[16:20:35.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.050]                 "immediateCondition"))) {
[16:20:35.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.050]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.050]                   if (TRUE && !signal) {
[16:20:35.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.050]                     {
[16:20:35.050]                       inherits <- base::inherits
[16:20:35.050]                       invokeRestart <- base::invokeRestart
[16:20:35.050]                       is.null <- base::is.null
[16:20:35.050]                       muffled <- FALSE
[16:20:35.050]                       if (inherits(cond, "message")) {
[16:20:35.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.050]                         if (muffled) 
[16:20:35.050]                           invokeRestart("muffleMessage")
[16:20:35.050]                       }
[16:20:35.050]                       else if (inherits(cond, "warning")) {
[16:20:35.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.050]                         if (muffled) 
[16:20:35.050]                           invokeRestart("muffleWarning")
[16:20:35.050]                       }
[16:20:35.050]                       else if (inherits(cond, "condition")) {
[16:20:35.050]                         if (!is.null(pattern)) {
[16:20:35.050]                           computeRestarts <- base::computeRestarts
[16:20:35.050]                           grepl <- base::grepl
[16:20:35.050]                           restarts <- computeRestarts(cond)
[16:20:35.050]                           for (restart in restarts) {
[16:20:35.050]                             name <- restart$name
[16:20:35.050]                             if (is.null(name)) 
[16:20:35.050]                               next
[16:20:35.050]                             if (!grepl(pattern, name)) 
[16:20:35.050]                               next
[16:20:35.050]                             invokeRestart(restart)
[16:20:35.050]                             muffled <- TRUE
[16:20:35.050]                             break
[16:20:35.050]                           }
[16:20:35.050]                         }
[16:20:35.050]                       }
[16:20:35.050]                       invisible(muffled)
[16:20:35.050]                     }
[16:20:35.050]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.050]                   }
[16:20:35.050]                 }
[16:20:35.050]                 else {
[16:20:35.050]                   if (TRUE) {
[16:20:35.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.050]                     {
[16:20:35.050]                       inherits <- base::inherits
[16:20:35.050]                       invokeRestart <- base::invokeRestart
[16:20:35.050]                       is.null <- base::is.null
[16:20:35.050]                       muffled <- FALSE
[16:20:35.050]                       if (inherits(cond, "message")) {
[16:20:35.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.050]                         if (muffled) 
[16:20:35.050]                           invokeRestart("muffleMessage")
[16:20:35.050]                       }
[16:20:35.050]                       else if (inherits(cond, "warning")) {
[16:20:35.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.050]                         if (muffled) 
[16:20:35.050]                           invokeRestart("muffleWarning")
[16:20:35.050]                       }
[16:20:35.050]                       else if (inherits(cond, "condition")) {
[16:20:35.050]                         if (!is.null(pattern)) {
[16:20:35.050]                           computeRestarts <- base::computeRestarts
[16:20:35.050]                           grepl <- base::grepl
[16:20:35.050]                           restarts <- computeRestarts(cond)
[16:20:35.050]                           for (restart in restarts) {
[16:20:35.050]                             name <- restart$name
[16:20:35.050]                             if (is.null(name)) 
[16:20:35.050]                               next
[16:20:35.050]                             if (!grepl(pattern, name)) 
[16:20:35.050]                               next
[16:20:35.050]                             invokeRestart(restart)
[16:20:35.050]                             muffled <- TRUE
[16:20:35.050]                             break
[16:20:35.050]                           }
[16:20:35.050]                         }
[16:20:35.050]                       }
[16:20:35.050]                       invisible(muffled)
[16:20:35.050]                     }
[16:20:35.050]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.050]                   }
[16:20:35.050]                 }
[16:20:35.050]             }
[16:20:35.050]         }))
[16:20:35.050]     }, error = function(ex) {
[16:20:35.050]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.050]                 ...future.rng), started = ...future.startTime, 
[16:20:35.050]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.050]             version = "1.8"), class = "FutureResult")
[16:20:35.050]     }, finally = {
[16:20:35.050]         if (!identical(...future.workdir, getwd())) 
[16:20:35.050]             setwd(...future.workdir)
[16:20:35.050]         {
[16:20:35.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.050]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.050]             }
[16:20:35.050]             base::options(...future.oldOptions)
[16:20:35.050]             if (.Platform$OS.type == "windows") {
[16:20:35.050]                 old_names <- names(...future.oldEnvVars)
[16:20:35.050]                 envs <- base::Sys.getenv()
[16:20:35.050]                 names <- names(envs)
[16:20:35.050]                 common <- intersect(names, old_names)
[16:20:35.050]                 added <- setdiff(names, old_names)
[16:20:35.050]                 removed <- setdiff(old_names, names)
[16:20:35.050]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.050]                   envs[common]]
[16:20:35.050]                 NAMES <- toupper(changed)
[16:20:35.050]                 args <- list()
[16:20:35.050]                 for (kk in seq_along(NAMES)) {
[16:20:35.050]                   name <- changed[[kk]]
[16:20:35.050]                   NAME <- NAMES[[kk]]
[16:20:35.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.050]                     next
[16:20:35.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.050]                 }
[16:20:35.050]                 NAMES <- toupper(added)
[16:20:35.050]                 for (kk in seq_along(NAMES)) {
[16:20:35.050]                   name <- added[[kk]]
[16:20:35.050]                   NAME <- NAMES[[kk]]
[16:20:35.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.050]                     next
[16:20:35.050]                   args[[name]] <- ""
[16:20:35.050]                 }
[16:20:35.050]                 NAMES <- toupper(removed)
[16:20:35.050]                 for (kk in seq_along(NAMES)) {
[16:20:35.050]                   name <- removed[[kk]]
[16:20:35.050]                   NAME <- NAMES[[kk]]
[16:20:35.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.050]                     next
[16:20:35.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.050]                 }
[16:20:35.050]                 if (length(args) > 0) 
[16:20:35.050]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.050]             }
[16:20:35.050]             else {
[16:20:35.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.050]             }
[16:20:35.050]             {
[16:20:35.050]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.050]                   0L) {
[16:20:35.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.050]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.050]                   base::options(opts)
[16:20:35.050]                 }
[16:20:35.050]                 {
[16:20:35.050]                   {
[16:20:35.050]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.050]                     NULL
[16:20:35.050]                   }
[16:20:35.050]                   options(future.plan = NULL)
[16:20:35.050]                   if (is.na(NA_character_)) 
[16:20:35.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.050]                     .init = FALSE)
[16:20:35.050]                 }
[16:20:35.050]             }
[16:20:35.050]         }
[16:20:35.050]     })
[16:20:35.050]     if (TRUE) {
[16:20:35.050]         base::sink(type = "output", split = FALSE)
[16:20:35.050]         if (TRUE) {
[16:20:35.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.050]         }
[16:20:35.050]         else {
[16:20:35.050]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.050]         }
[16:20:35.050]         base::close(...future.stdout)
[16:20:35.050]         ...future.stdout <- NULL
[16:20:35.050]     }
[16:20:35.050]     ...future.result$conditions <- ...future.conditions
[16:20:35.050]     ...future.result$finished <- base::Sys.time()
[16:20:35.050]     ...future.result
[16:20:35.050] }
[16:20:35.053] requestCore(): workers = 2
[16:20:35.059] MulticoreFuture started
[16:20:35.059] - Launch lazy future ... done
[16:20:35.059] run() for ‘MulticoreFuture’ ... done
[16:20:35.060] plan(): Setting new future strategy stack:
[16:20:35.060] result() for MulticoreFuture ...
[16:20:35.060] List of future strategies:
[16:20:35.060] 1. sequential:
[16:20:35.060]    - args: function (..., envir = parent.frame())
[16:20:35.060]    - tweaked: FALSE
[16:20:35.060]    - call: NULL
[16:20:35.061] plan(): nbrOfWorkers() = 1
[16:20:35.063] result() for MulticoreFuture ...
[16:20:35.063] result() for MulticoreFuture ... done
[16:20:35.063] result() for MulticoreFuture ... done
[16:20:35.063] plan(): Setting new future strategy stack:
[16:20:35.063] List of future strategies:
[16:20:35.063] 1. multicore:
[16:20:35.063]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.063]    - tweaked: FALSE
[16:20:35.063]    - call: plan(strategy)
[16:20:35.063] result() for MulticoreFuture ...
[16:20:35.068] result() for MulticoreFuture ... done
u$a = 2
[16:20:35.069] result() for MulticoreFuture ...
[16:20:35.072] plan(): nbrOfWorkers() = 2
[16:20:35.073] result() for MulticoreFuture ...
[16:20:35.073] result() for MulticoreFuture ... done
[16:20:35.073] result() for MulticoreFuture ... done
[16:20:35.073] result() for MulticoreFuture ...
[16:20:35.074] result() for MulticoreFuture ... done
v$a = 4
[16:20:35.074] getGlobalsAndPackages() ...
[16:20:35.074] Searching for globals...
[16:20:35.076] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:35.076] Searching for globals ... DONE
[16:20:35.076] Resolving globals: FALSE
[16:20:35.077] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:35.077] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:35.077] - globals: [1] ‘a’
[16:20:35.077] 
[16:20:35.077] getGlobalsAndPackages() ... DONE
[16:20:35.078] run() for ‘Future’ ...
[16:20:35.078] - state: ‘created’
[16:20:35.078] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.082] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.082] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.082]   - Field: ‘label’
[16:20:35.082]   - Field: ‘local’
[16:20:35.083]   - Field: ‘owner’
[16:20:35.083]   - Field: ‘envir’
[16:20:35.083]   - Field: ‘workers’
[16:20:35.083]   - Field: ‘packages’
[16:20:35.083]   - Field: ‘gc’
[16:20:35.083]   - Field: ‘job’
[16:20:35.083]   - Field: ‘conditions’
[16:20:35.083]   - Field: ‘expr’
[16:20:35.083]   - Field: ‘uuid’
[16:20:35.084]   - Field: ‘seed’
[16:20:35.084]   - Field: ‘version’
[16:20:35.084]   - Field: ‘result’
[16:20:35.084]   - Field: ‘asynchronous’
[16:20:35.084]   - Field: ‘calls’
[16:20:35.084]   - Field: ‘globals’
[16:20:35.084]   - Field: ‘stdout’
[16:20:35.084]   - Field: ‘earlySignal’
[16:20:35.085]   - Field: ‘lazy’
[16:20:35.085]   - Field: ‘state’
[16:20:35.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.085] - Launch lazy future ...
[16:20:35.085] Packages needed by the future expression (n = 0): <none>
[16:20:35.085] Packages needed by future strategies (n = 0): <none>
[16:20:35.086] {
[16:20:35.086]     {
[16:20:35.086]         {
[16:20:35.086]             ...future.startTime <- base::Sys.time()
[16:20:35.086]             {
[16:20:35.086]                 {
[16:20:35.086]                   {
[16:20:35.086]                     {
[16:20:35.086]                       base::local({
[16:20:35.086]                         has_future <- base::requireNamespace("future", 
[16:20:35.086]                           quietly = TRUE)
[16:20:35.086]                         if (has_future) {
[16:20:35.086]                           ns <- base::getNamespace("future")
[16:20:35.086]                           version <- ns[[".package"]][["version"]]
[16:20:35.086]                           if (is.null(version)) 
[16:20:35.086]                             version <- utils::packageVersion("future")
[16:20:35.086]                         }
[16:20:35.086]                         else {
[16:20:35.086]                           version <- NULL
[16:20:35.086]                         }
[16:20:35.086]                         if (!has_future || version < "1.8.0") {
[16:20:35.086]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.086]                             "", base::R.version$version.string), 
[16:20:35.086]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.086]                               "release", "version")], collapse = " "), 
[16:20:35.086]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.086]                             info)
[16:20:35.086]                           info <- base::paste(info, collapse = "; ")
[16:20:35.086]                           if (!has_future) {
[16:20:35.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.086]                               info)
[16:20:35.086]                           }
[16:20:35.086]                           else {
[16:20:35.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.086]                               info, version)
[16:20:35.086]                           }
[16:20:35.086]                           base::stop(msg)
[16:20:35.086]                         }
[16:20:35.086]                       })
[16:20:35.086]                     }
[16:20:35.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.086]                     base::options(mc.cores = 1L)
[16:20:35.086]                   }
[16:20:35.086]                   ...future.strategy.old <- future::plan("list")
[16:20:35.086]                   options(future.plan = NULL)
[16:20:35.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.086]                 }
[16:20:35.086]                 ...future.workdir <- getwd()
[16:20:35.086]             }
[16:20:35.086]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.086]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.086]         }
[16:20:35.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.086]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.086]             base::names(...future.oldOptions))
[16:20:35.086]     }
[16:20:35.086]     if (FALSE) {
[16:20:35.086]     }
[16:20:35.086]     else {
[16:20:35.086]         if (TRUE) {
[16:20:35.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.086]                 open = "w")
[16:20:35.086]         }
[16:20:35.086]         else {
[16:20:35.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.086]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.086]         }
[16:20:35.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.086]             base::sink(type = "output", split = FALSE)
[16:20:35.086]             base::close(...future.stdout)
[16:20:35.086]         }, add = TRUE)
[16:20:35.086]     }
[16:20:35.086]     ...future.frame <- base::sys.nframe()
[16:20:35.086]     ...future.conditions <- base::list()
[16:20:35.086]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.086]     if (FALSE) {
[16:20:35.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.086]     }
[16:20:35.086]     ...future.result <- base::tryCatch({
[16:20:35.086]         base::withCallingHandlers({
[16:20:35.086]             ...future.value <- base::withVisible(base::local({
[16:20:35.086]                 withCallingHandlers({
[16:20:35.086]                   {
[16:20:35.086]                     2 * a
[16:20:35.086]                   }
[16:20:35.086]                 }, immediateCondition = function(cond) {
[16:20:35.086]                   save_rds <- function (object, pathname, ...) 
[16:20:35.086]                   {
[16:20:35.086]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.086]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.086]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.086]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.086]                         fi_tmp[["mtime"]])
[16:20:35.086]                     }
[16:20:35.086]                     tryCatch({
[16:20:35.086]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.086]                     }, error = function(ex) {
[16:20:35.086]                       msg <- conditionMessage(ex)
[16:20:35.086]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.086]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.086]                         fi_tmp[["mtime"]], msg)
[16:20:35.086]                       ex$message <- msg
[16:20:35.086]                       stop(ex)
[16:20:35.086]                     })
[16:20:35.086]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.086]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.086]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.086]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.086]                       fi <- file.info(pathname)
[16:20:35.086]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.086]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.086]                         fi[["size"]], fi[["mtime"]])
[16:20:35.086]                       stop(msg)
[16:20:35.086]                     }
[16:20:35.086]                     invisible(pathname)
[16:20:35.086]                   }
[16:20:35.086]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.086]                     rootPath = tempdir()) 
[16:20:35.086]                   {
[16:20:35.086]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.086]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.086]                       tmpdir = path, fileext = ".rds")
[16:20:35.086]                     save_rds(obj, file)
[16:20:35.086]                   }
[16:20:35.086]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.086]                   {
[16:20:35.086]                     inherits <- base::inherits
[16:20:35.086]                     invokeRestart <- base::invokeRestart
[16:20:35.086]                     is.null <- base::is.null
[16:20:35.086]                     muffled <- FALSE
[16:20:35.086]                     if (inherits(cond, "message")) {
[16:20:35.086]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.086]                       if (muffled) 
[16:20:35.086]                         invokeRestart("muffleMessage")
[16:20:35.086]                     }
[16:20:35.086]                     else if (inherits(cond, "warning")) {
[16:20:35.086]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.086]                       if (muffled) 
[16:20:35.086]                         invokeRestart("muffleWarning")
[16:20:35.086]                     }
[16:20:35.086]                     else if (inherits(cond, "condition")) {
[16:20:35.086]                       if (!is.null(pattern)) {
[16:20:35.086]                         computeRestarts <- base::computeRestarts
[16:20:35.086]                         grepl <- base::grepl
[16:20:35.086]                         restarts <- computeRestarts(cond)
[16:20:35.086]                         for (restart in restarts) {
[16:20:35.086]                           name <- restart$name
[16:20:35.086]                           if (is.null(name)) 
[16:20:35.086]                             next
[16:20:35.086]                           if (!grepl(pattern, name)) 
[16:20:35.086]                             next
[16:20:35.086]                           invokeRestart(restart)
[16:20:35.086]                           muffled <- TRUE
[16:20:35.086]                           break
[16:20:35.086]                         }
[16:20:35.086]                       }
[16:20:35.086]                     }
[16:20:35.086]                     invisible(muffled)
[16:20:35.086]                   }
[16:20:35.086]                   muffleCondition(cond)
[16:20:35.086]                 })
[16:20:35.086]             }))
[16:20:35.086]             future::FutureResult(value = ...future.value$value, 
[16:20:35.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.086]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.086]                     ...future.globalenv.names))
[16:20:35.086]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.086]         }, condition = base::local({
[16:20:35.086]             c <- base::c
[16:20:35.086]             inherits <- base::inherits
[16:20:35.086]             invokeRestart <- base::invokeRestart
[16:20:35.086]             length <- base::length
[16:20:35.086]             list <- base::list
[16:20:35.086]             seq.int <- base::seq.int
[16:20:35.086]             signalCondition <- base::signalCondition
[16:20:35.086]             sys.calls <- base::sys.calls
[16:20:35.086]             `[[` <- base::`[[`
[16:20:35.086]             `+` <- base::`+`
[16:20:35.086]             `<<-` <- base::`<<-`
[16:20:35.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.086]                   3L)]
[16:20:35.086]             }
[16:20:35.086]             function(cond) {
[16:20:35.086]                 is_error <- inherits(cond, "error")
[16:20:35.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.086]                   NULL)
[16:20:35.086]                 if (is_error) {
[16:20:35.086]                   sessionInformation <- function() {
[16:20:35.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.086]                       search = base::search(), system = base::Sys.info())
[16:20:35.086]                   }
[16:20:35.086]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.086]                     cond$call), session = sessionInformation(), 
[16:20:35.086]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.086]                   signalCondition(cond)
[16:20:35.086]                 }
[16:20:35.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.086]                 "immediateCondition"))) {
[16:20:35.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.086]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.086]                   if (TRUE && !signal) {
[16:20:35.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.086]                     {
[16:20:35.086]                       inherits <- base::inherits
[16:20:35.086]                       invokeRestart <- base::invokeRestart
[16:20:35.086]                       is.null <- base::is.null
[16:20:35.086]                       muffled <- FALSE
[16:20:35.086]                       if (inherits(cond, "message")) {
[16:20:35.086]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.086]                         if (muffled) 
[16:20:35.086]                           invokeRestart("muffleMessage")
[16:20:35.086]                       }
[16:20:35.086]                       else if (inherits(cond, "warning")) {
[16:20:35.086]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.086]                         if (muffled) 
[16:20:35.086]                           invokeRestart("muffleWarning")
[16:20:35.086]                       }
[16:20:35.086]                       else if (inherits(cond, "condition")) {
[16:20:35.086]                         if (!is.null(pattern)) {
[16:20:35.086]                           computeRestarts <- base::computeRestarts
[16:20:35.086]                           grepl <- base::grepl
[16:20:35.086]                           restarts <- computeRestarts(cond)
[16:20:35.086]                           for (restart in restarts) {
[16:20:35.086]                             name <- restart$name
[16:20:35.086]                             if (is.null(name)) 
[16:20:35.086]                               next
[16:20:35.086]                             if (!grepl(pattern, name)) 
[16:20:35.086]                               next
[16:20:35.086]                             invokeRestart(restart)
[16:20:35.086]                             muffled <- TRUE
[16:20:35.086]                             break
[16:20:35.086]                           }
[16:20:35.086]                         }
[16:20:35.086]                       }
[16:20:35.086]                       invisible(muffled)
[16:20:35.086]                     }
[16:20:35.086]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.086]                   }
[16:20:35.086]                 }
[16:20:35.086]                 else {
[16:20:35.086]                   if (TRUE) {
[16:20:35.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.086]                     {
[16:20:35.086]                       inherits <- base::inherits
[16:20:35.086]                       invokeRestart <- base::invokeRestart
[16:20:35.086]                       is.null <- base::is.null
[16:20:35.086]                       muffled <- FALSE
[16:20:35.086]                       if (inherits(cond, "message")) {
[16:20:35.086]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.086]                         if (muffled) 
[16:20:35.086]                           invokeRestart("muffleMessage")
[16:20:35.086]                       }
[16:20:35.086]                       else if (inherits(cond, "warning")) {
[16:20:35.086]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.086]                         if (muffled) 
[16:20:35.086]                           invokeRestart("muffleWarning")
[16:20:35.086]                       }
[16:20:35.086]                       else if (inherits(cond, "condition")) {
[16:20:35.086]                         if (!is.null(pattern)) {
[16:20:35.086]                           computeRestarts <- base::computeRestarts
[16:20:35.086]                           grepl <- base::grepl
[16:20:35.086]                           restarts <- computeRestarts(cond)
[16:20:35.086]                           for (restart in restarts) {
[16:20:35.086]                             name <- restart$name
[16:20:35.086]                             if (is.null(name)) 
[16:20:35.086]                               next
[16:20:35.086]                             if (!grepl(pattern, name)) 
[16:20:35.086]                               next
[16:20:35.086]                             invokeRestart(restart)
[16:20:35.086]                             muffled <- TRUE
[16:20:35.086]                             break
[16:20:35.086]                           }
[16:20:35.086]                         }
[16:20:35.086]                       }
[16:20:35.086]                       invisible(muffled)
[16:20:35.086]                     }
[16:20:35.086]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.086]                   }
[16:20:35.086]                 }
[16:20:35.086]             }
[16:20:35.086]         }))
[16:20:35.086]     }, error = function(ex) {
[16:20:35.086]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.086]                 ...future.rng), started = ...future.startTime, 
[16:20:35.086]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.086]             version = "1.8"), class = "FutureResult")
[16:20:35.086]     }, finally = {
[16:20:35.086]         if (!identical(...future.workdir, getwd())) 
[16:20:35.086]             setwd(...future.workdir)
[16:20:35.086]         {
[16:20:35.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.086]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.086]             }
[16:20:35.086]             base::options(...future.oldOptions)
[16:20:35.086]             if (.Platform$OS.type == "windows") {
[16:20:35.086]                 old_names <- names(...future.oldEnvVars)
[16:20:35.086]                 envs <- base::Sys.getenv()
[16:20:35.086]                 names <- names(envs)
[16:20:35.086]                 common <- intersect(names, old_names)
[16:20:35.086]                 added <- setdiff(names, old_names)
[16:20:35.086]                 removed <- setdiff(old_names, names)
[16:20:35.086]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.086]                   envs[common]]
[16:20:35.086]                 NAMES <- toupper(changed)
[16:20:35.086]                 args <- list()
[16:20:35.086]                 for (kk in seq_along(NAMES)) {
[16:20:35.086]                   name <- changed[[kk]]
[16:20:35.086]                   NAME <- NAMES[[kk]]
[16:20:35.086]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.086]                     next
[16:20:35.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.086]                 }
[16:20:35.086]                 NAMES <- toupper(added)
[16:20:35.086]                 for (kk in seq_along(NAMES)) {
[16:20:35.086]                   name <- added[[kk]]
[16:20:35.086]                   NAME <- NAMES[[kk]]
[16:20:35.086]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.086]                     next
[16:20:35.086]                   args[[name]] <- ""
[16:20:35.086]                 }
[16:20:35.086]                 NAMES <- toupper(removed)
[16:20:35.086]                 for (kk in seq_along(NAMES)) {
[16:20:35.086]                   name <- removed[[kk]]
[16:20:35.086]                   NAME <- NAMES[[kk]]
[16:20:35.086]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.086]                     next
[16:20:35.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.086]                 }
[16:20:35.086]                 if (length(args) > 0) 
[16:20:35.086]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.086]             }
[16:20:35.086]             else {
[16:20:35.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.086]             }
[16:20:35.086]             {
[16:20:35.086]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.086]                   0L) {
[16:20:35.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.086]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.086]                   base::options(opts)
[16:20:35.086]                 }
[16:20:35.086]                 {
[16:20:35.086]                   {
[16:20:35.086]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.086]                     NULL
[16:20:35.086]                   }
[16:20:35.086]                   options(future.plan = NULL)
[16:20:35.086]                   if (is.na(NA_character_)) 
[16:20:35.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.086]                     .init = FALSE)
[16:20:35.086]                 }
[16:20:35.086]             }
[16:20:35.086]         }
[16:20:35.086]     })
[16:20:35.086]     if (TRUE) {
[16:20:35.086]         base::sink(type = "output", split = FALSE)
[16:20:35.086]         if (TRUE) {
[16:20:35.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.086]         }
[16:20:35.086]         else {
[16:20:35.086]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.086]         }
[16:20:35.086]         base::close(...future.stdout)
[16:20:35.086]         ...future.stdout <- NULL
[16:20:35.086]     }
[16:20:35.086]     ...future.result$conditions <- ...future.conditions
[16:20:35.086]     ...future.result$finished <- base::Sys.time()
[16:20:35.086]     ...future.result
[16:20:35.086] }
[16:20:35.088] assign_globals() ...
[16:20:35.088] List of 1
[16:20:35.088]  $ a: num 1
[16:20:35.088]  - attr(*, "where")=List of 1
[16:20:35.088]   ..$ a:<environment: R_EmptyEnv> 
[16:20:35.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:35.088]  - attr(*, "resolved")= logi FALSE
[16:20:35.088]  - attr(*, "total_size")= num 56
[16:20:35.088]  - attr(*, "already-done")= logi TRUE
[16:20:35.091] - copied ‘a’ to environment
[16:20:35.091] assign_globals() ... done
[16:20:35.091] requestCore(): workers = 2
[16:20:35.093] MulticoreFuture started
[16:20:35.094] - Launch lazy future ... done
[16:20:35.094] run() for ‘MulticoreFuture’ ... done
[16:20:35.094] result() for MulticoreFuture ...
[16:20:35.094] plan(): Setting new future strategy stack:
[16:20:35.095] List of future strategies:
[16:20:35.095] 1. sequential:
[16:20:35.095]    - args: function (..., envir = parent.frame())
[16:20:35.095]    - tweaked: FALSE
[16:20:35.095]    - call: NULL
[16:20:35.095] plan(): nbrOfWorkers() = 1
[16:20:35.097] plan(): Setting new future strategy stack:
[16:20:35.098] List of future strategies:
[16:20:35.098] 1. multicore:
[16:20:35.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.098]    - tweaked: FALSE
[16:20:35.098]    - call: plan(strategy)
[16:20:35.103] plan(): nbrOfWorkers() = 2
[16:20:35.103] result() for MulticoreFuture ...
[16:20:35.104] result() for MulticoreFuture ... done
[16:20:35.104] result() for MulticoreFuture ... done
[16:20:35.104] result() for MulticoreFuture ...
[16:20:35.104] result() for MulticoreFuture ... done
[16:20:35.104] getGlobalsAndPackages() ...
[16:20:35.105] Searching for globals...
[16:20:35.106] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:35.106] Searching for globals ... DONE
[16:20:35.106] Resolving globals: FALSE
[16:20:35.107] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:35.107] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:35.107] - globals: [1] ‘a’
[16:20:35.107] 
[16:20:35.107] getGlobalsAndPackages() ... DONE
[16:20:35.108] run() for ‘Future’ ...
[16:20:35.108] - state: ‘created’
[16:20:35.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.112]   - Field: ‘label’
[16:20:35.113]   - Field: ‘local’
[16:20:35.113]   - Field: ‘owner’
[16:20:35.113]   - Field: ‘envir’
[16:20:35.113]   - Field: ‘workers’
[16:20:35.113]   - Field: ‘packages’
[16:20:35.113]   - Field: ‘gc’
[16:20:35.113]   - Field: ‘job’
[16:20:35.113]   - Field: ‘conditions’
[16:20:35.114]   - Field: ‘expr’
[16:20:35.114]   - Field: ‘uuid’
[16:20:35.114]   - Field: ‘seed’
[16:20:35.114]   - Field: ‘version’
[16:20:35.114]   - Field: ‘result’
[16:20:35.114]   - Field: ‘asynchronous’
[16:20:35.114]   - Field: ‘calls’
[16:20:35.114]   - Field: ‘globals’
[16:20:35.114]   - Field: ‘stdout’
[16:20:35.115]   - Field: ‘earlySignal’
[16:20:35.115]   - Field: ‘lazy’
[16:20:35.115]   - Field: ‘state’
[16:20:35.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.115] - Launch lazy future ...
[16:20:35.115] Packages needed by the future expression (n = 0): <none>
[16:20:35.115] Packages needed by future strategies (n = 0): <none>
[16:20:35.116] {
[16:20:35.116]     {
[16:20:35.116]         {
[16:20:35.116]             ...future.startTime <- base::Sys.time()
[16:20:35.116]             {
[16:20:35.116]                 {
[16:20:35.116]                   {
[16:20:35.116]                     {
[16:20:35.116]                       base::local({
[16:20:35.116]                         has_future <- base::requireNamespace("future", 
[16:20:35.116]                           quietly = TRUE)
[16:20:35.116]                         if (has_future) {
[16:20:35.116]                           ns <- base::getNamespace("future")
[16:20:35.116]                           version <- ns[[".package"]][["version"]]
[16:20:35.116]                           if (is.null(version)) 
[16:20:35.116]                             version <- utils::packageVersion("future")
[16:20:35.116]                         }
[16:20:35.116]                         else {
[16:20:35.116]                           version <- NULL
[16:20:35.116]                         }
[16:20:35.116]                         if (!has_future || version < "1.8.0") {
[16:20:35.116]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.116]                             "", base::R.version$version.string), 
[16:20:35.116]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.116]                               "release", "version")], collapse = " "), 
[16:20:35.116]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.116]                             info)
[16:20:35.116]                           info <- base::paste(info, collapse = "; ")
[16:20:35.116]                           if (!has_future) {
[16:20:35.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.116]                               info)
[16:20:35.116]                           }
[16:20:35.116]                           else {
[16:20:35.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.116]                               info, version)
[16:20:35.116]                           }
[16:20:35.116]                           base::stop(msg)
[16:20:35.116]                         }
[16:20:35.116]                       })
[16:20:35.116]                     }
[16:20:35.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.116]                     base::options(mc.cores = 1L)
[16:20:35.116]                   }
[16:20:35.116]                   ...future.strategy.old <- future::plan("list")
[16:20:35.116]                   options(future.plan = NULL)
[16:20:35.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.116]                 }
[16:20:35.116]                 ...future.workdir <- getwd()
[16:20:35.116]             }
[16:20:35.116]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.116]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.116]         }
[16:20:35.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.116]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.116]             base::names(...future.oldOptions))
[16:20:35.116]     }
[16:20:35.116]     if (FALSE) {
[16:20:35.116]     }
[16:20:35.116]     else {
[16:20:35.116]         if (TRUE) {
[16:20:35.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.116]                 open = "w")
[16:20:35.116]         }
[16:20:35.116]         else {
[16:20:35.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.116]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.116]         }
[16:20:35.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.116]             base::sink(type = "output", split = FALSE)
[16:20:35.116]             base::close(...future.stdout)
[16:20:35.116]         }, add = TRUE)
[16:20:35.116]     }
[16:20:35.116]     ...future.frame <- base::sys.nframe()
[16:20:35.116]     ...future.conditions <- base::list()
[16:20:35.116]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.116]     if (FALSE) {
[16:20:35.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.116]     }
[16:20:35.116]     ...future.result <- base::tryCatch({
[16:20:35.116]         base::withCallingHandlers({
[16:20:35.116]             ...future.value <- base::withVisible(base::local({
[16:20:35.116]                 withCallingHandlers({
[16:20:35.116]                   {
[16:20:35.116]                     2 * a
[16:20:35.116]                   }
[16:20:35.116]                 }, immediateCondition = function(cond) {
[16:20:35.116]                   save_rds <- function (object, pathname, ...) 
[16:20:35.116]                   {
[16:20:35.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.116]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.116]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.116]                         fi_tmp[["mtime"]])
[16:20:35.116]                     }
[16:20:35.116]                     tryCatch({
[16:20:35.116]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.116]                     }, error = function(ex) {
[16:20:35.116]                       msg <- conditionMessage(ex)
[16:20:35.116]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.116]                         fi_tmp[["mtime"]], msg)
[16:20:35.116]                       ex$message <- msg
[16:20:35.116]                       stop(ex)
[16:20:35.116]                     })
[16:20:35.116]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.116]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.116]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.116]                       fi <- file.info(pathname)
[16:20:35.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.116]                         fi[["size"]], fi[["mtime"]])
[16:20:35.116]                       stop(msg)
[16:20:35.116]                     }
[16:20:35.116]                     invisible(pathname)
[16:20:35.116]                   }
[16:20:35.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.116]                     rootPath = tempdir()) 
[16:20:35.116]                   {
[16:20:35.116]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.116]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.116]                       tmpdir = path, fileext = ".rds")
[16:20:35.116]                     save_rds(obj, file)
[16:20:35.116]                   }
[16:20:35.116]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.116]                   {
[16:20:35.116]                     inherits <- base::inherits
[16:20:35.116]                     invokeRestart <- base::invokeRestart
[16:20:35.116]                     is.null <- base::is.null
[16:20:35.116]                     muffled <- FALSE
[16:20:35.116]                     if (inherits(cond, "message")) {
[16:20:35.116]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.116]                       if (muffled) 
[16:20:35.116]                         invokeRestart("muffleMessage")
[16:20:35.116]                     }
[16:20:35.116]                     else if (inherits(cond, "warning")) {
[16:20:35.116]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.116]                       if (muffled) 
[16:20:35.116]                         invokeRestart("muffleWarning")
[16:20:35.116]                     }
[16:20:35.116]                     else if (inherits(cond, "condition")) {
[16:20:35.116]                       if (!is.null(pattern)) {
[16:20:35.116]                         computeRestarts <- base::computeRestarts
[16:20:35.116]                         grepl <- base::grepl
[16:20:35.116]                         restarts <- computeRestarts(cond)
[16:20:35.116]                         for (restart in restarts) {
[16:20:35.116]                           name <- restart$name
[16:20:35.116]                           if (is.null(name)) 
[16:20:35.116]                             next
[16:20:35.116]                           if (!grepl(pattern, name)) 
[16:20:35.116]                             next
[16:20:35.116]                           invokeRestart(restart)
[16:20:35.116]                           muffled <- TRUE
[16:20:35.116]                           break
[16:20:35.116]                         }
[16:20:35.116]                       }
[16:20:35.116]                     }
[16:20:35.116]                     invisible(muffled)
[16:20:35.116]                   }
[16:20:35.116]                   muffleCondition(cond)
[16:20:35.116]                 })
[16:20:35.116]             }))
[16:20:35.116]             future::FutureResult(value = ...future.value$value, 
[16:20:35.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.116]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.116]                     ...future.globalenv.names))
[16:20:35.116]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.116]         }, condition = base::local({
[16:20:35.116]             c <- base::c
[16:20:35.116]             inherits <- base::inherits
[16:20:35.116]             invokeRestart <- base::invokeRestart
[16:20:35.116]             length <- base::length
[16:20:35.116]             list <- base::list
[16:20:35.116]             seq.int <- base::seq.int
[16:20:35.116]             signalCondition <- base::signalCondition
[16:20:35.116]             sys.calls <- base::sys.calls
[16:20:35.116]             `[[` <- base::`[[`
[16:20:35.116]             `+` <- base::`+`
[16:20:35.116]             `<<-` <- base::`<<-`
[16:20:35.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.116]                   3L)]
[16:20:35.116]             }
[16:20:35.116]             function(cond) {
[16:20:35.116]                 is_error <- inherits(cond, "error")
[16:20:35.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.116]                   NULL)
[16:20:35.116]                 if (is_error) {
[16:20:35.116]                   sessionInformation <- function() {
[16:20:35.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.116]                       search = base::search(), system = base::Sys.info())
[16:20:35.116]                   }
[16:20:35.116]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.116]                     cond$call), session = sessionInformation(), 
[16:20:35.116]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.116]                   signalCondition(cond)
[16:20:35.116]                 }
[16:20:35.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.116]                 "immediateCondition"))) {
[16:20:35.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.116]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.116]                   if (TRUE && !signal) {
[16:20:35.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.116]                     {
[16:20:35.116]                       inherits <- base::inherits
[16:20:35.116]                       invokeRestart <- base::invokeRestart
[16:20:35.116]                       is.null <- base::is.null
[16:20:35.116]                       muffled <- FALSE
[16:20:35.116]                       if (inherits(cond, "message")) {
[16:20:35.116]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.116]                         if (muffled) 
[16:20:35.116]                           invokeRestart("muffleMessage")
[16:20:35.116]                       }
[16:20:35.116]                       else if (inherits(cond, "warning")) {
[16:20:35.116]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.116]                         if (muffled) 
[16:20:35.116]                           invokeRestart("muffleWarning")
[16:20:35.116]                       }
[16:20:35.116]                       else if (inherits(cond, "condition")) {
[16:20:35.116]                         if (!is.null(pattern)) {
[16:20:35.116]                           computeRestarts <- base::computeRestarts
[16:20:35.116]                           grepl <- base::grepl
[16:20:35.116]                           restarts <- computeRestarts(cond)
[16:20:35.116]                           for (restart in restarts) {
[16:20:35.116]                             name <- restart$name
[16:20:35.116]                             if (is.null(name)) 
[16:20:35.116]                               next
[16:20:35.116]                             if (!grepl(pattern, name)) 
[16:20:35.116]                               next
[16:20:35.116]                             invokeRestart(restart)
[16:20:35.116]                             muffled <- TRUE
[16:20:35.116]                             break
[16:20:35.116]                           }
[16:20:35.116]                         }
[16:20:35.116]                       }
[16:20:35.116]                       invisible(muffled)
[16:20:35.116]                     }
[16:20:35.116]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.116]                   }
[16:20:35.116]                 }
[16:20:35.116]                 else {
[16:20:35.116]                   if (TRUE) {
[16:20:35.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.116]                     {
[16:20:35.116]                       inherits <- base::inherits
[16:20:35.116]                       invokeRestart <- base::invokeRestart
[16:20:35.116]                       is.null <- base::is.null
[16:20:35.116]                       muffled <- FALSE
[16:20:35.116]                       if (inherits(cond, "message")) {
[16:20:35.116]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.116]                         if (muffled) 
[16:20:35.116]                           invokeRestart("muffleMessage")
[16:20:35.116]                       }
[16:20:35.116]                       else if (inherits(cond, "warning")) {
[16:20:35.116]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.116]                         if (muffled) 
[16:20:35.116]                           invokeRestart("muffleWarning")
[16:20:35.116]                       }
[16:20:35.116]                       else if (inherits(cond, "condition")) {
[16:20:35.116]                         if (!is.null(pattern)) {
[16:20:35.116]                           computeRestarts <- base::computeRestarts
[16:20:35.116]                           grepl <- base::grepl
[16:20:35.116]                           restarts <- computeRestarts(cond)
[16:20:35.116]                           for (restart in restarts) {
[16:20:35.116]                             name <- restart$name
[16:20:35.116]                             if (is.null(name)) 
[16:20:35.116]                               next
[16:20:35.116]                             if (!grepl(pattern, name)) 
[16:20:35.116]                               next
[16:20:35.116]                             invokeRestart(restart)
[16:20:35.116]                             muffled <- TRUE
[16:20:35.116]                             break
[16:20:35.116]                           }
[16:20:35.116]                         }
[16:20:35.116]                       }
[16:20:35.116]                       invisible(muffled)
[16:20:35.116]                     }
[16:20:35.116]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.116]                   }
[16:20:35.116]                 }
[16:20:35.116]             }
[16:20:35.116]         }))
[16:20:35.116]     }, error = function(ex) {
[16:20:35.116]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.116]                 ...future.rng), started = ...future.startTime, 
[16:20:35.116]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.116]             version = "1.8"), class = "FutureResult")
[16:20:35.116]     }, finally = {
[16:20:35.116]         if (!identical(...future.workdir, getwd())) 
[16:20:35.116]             setwd(...future.workdir)
[16:20:35.116]         {
[16:20:35.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.116]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.116]             }
[16:20:35.116]             base::options(...future.oldOptions)
[16:20:35.116]             if (.Platform$OS.type == "windows") {
[16:20:35.116]                 old_names <- names(...future.oldEnvVars)
[16:20:35.116]                 envs <- base::Sys.getenv()
[16:20:35.116]                 names <- names(envs)
[16:20:35.116]                 common <- intersect(names, old_names)
[16:20:35.116]                 added <- setdiff(names, old_names)
[16:20:35.116]                 removed <- setdiff(old_names, names)
[16:20:35.116]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.116]                   envs[common]]
[16:20:35.116]                 NAMES <- toupper(changed)
[16:20:35.116]                 args <- list()
[16:20:35.116]                 for (kk in seq_along(NAMES)) {
[16:20:35.116]                   name <- changed[[kk]]
[16:20:35.116]                   NAME <- NAMES[[kk]]
[16:20:35.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.116]                     next
[16:20:35.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.116]                 }
[16:20:35.116]                 NAMES <- toupper(added)
[16:20:35.116]                 for (kk in seq_along(NAMES)) {
[16:20:35.116]                   name <- added[[kk]]
[16:20:35.116]                   NAME <- NAMES[[kk]]
[16:20:35.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.116]                     next
[16:20:35.116]                   args[[name]] <- ""
[16:20:35.116]                 }
[16:20:35.116]                 NAMES <- toupper(removed)
[16:20:35.116]                 for (kk in seq_along(NAMES)) {
[16:20:35.116]                   name <- removed[[kk]]
[16:20:35.116]                   NAME <- NAMES[[kk]]
[16:20:35.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.116]                     next
[16:20:35.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.116]                 }
[16:20:35.116]                 if (length(args) > 0) 
[16:20:35.116]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.116]             }
[16:20:35.116]             else {
[16:20:35.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.116]             }
[16:20:35.116]             {
[16:20:35.116]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.116]                   0L) {
[16:20:35.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.116]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.116]                   base::options(opts)
[16:20:35.116]                 }
[16:20:35.116]                 {
[16:20:35.116]                   {
[16:20:35.116]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.116]                     NULL
[16:20:35.116]                   }
[16:20:35.116]                   options(future.plan = NULL)
[16:20:35.116]                   if (is.na(NA_character_)) 
[16:20:35.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.116]                     .init = FALSE)
[16:20:35.116]                 }
[16:20:35.116]             }
[16:20:35.116]         }
[16:20:35.116]     })
[16:20:35.116]     if (TRUE) {
[16:20:35.116]         base::sink(type = "output", split = FALSE)
[16:20:35.116]         if (TRUE) {
[16:20:35.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.116]         }
[16:20:35.116]         else {
[16:20:35.116]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.116]         }
[16:20:35.116]         base::close(...future.stdout)
[16:20:35.116]         ...future.stdout <- NULL
[16:20:35.116]     }
[16:20:35.116]     ...future.result$conditions <- ...future.conditions
[16:20:35.116]     ...future.result$finished <- base::Sys.time()
[16:20:35.116]     ...future.result
[16:20:35.116] }
[16:20:35.119] assign_globals() ...
[16:20:35.119] List of 1
[16:20:35.119]  $ a: num 1
[16:20:35.119]  - attr(*, "where")=List of 1
[16:20:35.119]   ..$ a:<environment: R_EmptyEnv> 
[16:20:35.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:35.119]  - attr(*, "resolved")= logi FALSE
[16:20:35.119]  - attr(*, "total_size")= num 56
[16:20:35.119]  - attr(*, "already-done")= logi TRUE
[16:20:35.122] - copied ‘a’ to environment
[16:20:35.122] assign_globals() ... done
[16:20:35.122] requestCore(): workers = 2
[16:20:35.124] MulticoreFuture started
[16:20:35.124] - Launch lazy future ... done
[16:20:35.124] run() for ‘MulticoreFuture’ ... done
[16:20:35.125] result() for MulticoreFuture ...
[16:20:35.125] plan(): Setting new future strategy stack:
[16:20:35.125] List of future strategies:
[16:20:35.125] 1. sequential:
[16:20:35.125]    - args: function (..., envir = parent.frame())
[16:20:35.125]    - tweaked: FALSE
[16:20:35.125]    - call: NULL
[16:20:35.126] plan(): nbrOfWorkers() = 1
[16:20:35.132] plan(): Setting new future strategy stack:
[16:20:35.132] List of future strategies:
[16:20:35.132] 1. multicore:
[16:20:35.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.132]    - tweaked: FALSE
[16:20:35.132]    - call: plan(strategy)
[16:20:35.138] plan(): nbrOfWorkers() = 2
[16:20:35.142] result() for MulticoreFuture ...
[16:20:35.142] result() for MulticoreFuture ... done
[16:20:35.142] result() for MulticoreFuture ... done
[16:20:35.142] result() for MulticoreFuture ...
[16:20:35.142] result() for MulticoreFuture ... done
[16:20:35.142] getGlobalsAndPackages() ...
[16:20:35.143] Searching for globals...
[16:20:35.144] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:35.144] Searching for globals ... DONE
[16:20:35.144] Resolving globals: FALSE
[16:20:35.145] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:35.145] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:35.146] - globals: [1] ‘a’
[16:20:35.146] 
[16:20:35.146] getGlobalsAndPackages() ... DONE
[16:20:35.146] run() for ‘Future’ ...
[16:20:35.146] - state: ‘created’
[16:20:35.146] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.151]   - Field: ‘label’
[16:20:35.151]   - Field: ‘local’
[16:20:35.151]   - Field: ‘owner’
[16:20:35.151]   - Field: ‘envir’
[16:20:35.151]   - Field: ‘workers’
[16:20:35.151]   - Field: ‘packages’
[16:20:35.151]   - Field: ‘gc’
[16:20:35.152]   - Field: ‘job’
[16:20:35.152]   - Field: ‘conditions’
[16:20:35.152]   - Field: ‘expr’
[16:20:35.152]   - Field: ‘uuid’
[16:20:35.152]   - Field: ‘seed’
[16:20:35.152]   - Field: ‘version’
[16:20:35.152]   - Field: ‘result’
[16:20:35.152]   - Field: ‘asynchronous’
[16:20:35.152]   - Field: ‘calls’
[16:20:35.153]   - Field: ‘globals’
[16:20:35.153]   - Field: ‘stdout’
[16:20:35.153]   - Field: ‘earlySignal’
[16:20:35.153]   - Field: ‘lazy’
[16:20:35.153]   - Field: ‘state’
[16:20:35.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.153] - Launch lazy future ...
[16:20:35.154] Packages needed by the future expression (n = 0): <none>
[16:20:35.154] Packages needed by future strategies (n = 0): <none>
[16:20:35.154] {
[16:20:35.154]     {
[16:20:35.154]         {
[16:20:35.154]             ...future.startTime <- base::Sys.time()
[16:20:35.154]             {
[16:20:35.154]                 {
[16:20:35.154]                   {
[16:20:35.154]                     {
[16:20:35.154]                       base::local({
[16:20:35.154]                         has_future <- base::requireNamespace("future", 
[16:20:35.154]                           quietly = TRUE)
[16:20:35.154]                         if (has_future) {
[16:20:35.154]                           ns <- base::getNamespace("future")
[16:20:35.154]                           version <- ns[[".package"]][["version"]]
[16:20:35.154]                           if (is.null(version)) 
[16:20:35.154]                             version <- utils::packageVersion("future")
[16:20:35.154]                         }
[16:20:35.154]                         else {
[16:20:35.154]                           version <- NULL
[16:20:35.154]                         }
[16:20:35.154]                         if (!has_future || version < "1.8.0") {
[16:20:35.154]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.154]                             "", base::R.version$version.string), 
[16:20:35.154]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.154]                               "release", "version")], collapse = " "), 
[16:20:35.154]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.154]                             info)
[16:20:35.154]                           info <- base::paste(info, collapse = "; ")
[16:20:35.154]                           if (!has_future) {
[16:20:35.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.154]                               info)
[16:20:35.154]                           }
[16:20:35.154]                           else {
[16:20:35.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.154]                               info, version)
[16:20:35.154]                           }
[16:20:35.154]                           base::stop(msg)
[16:20:35.154]                         }
[16:20:35.154]                       })
[16:20:35.154]                     }
[16:20:35.154]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.154]                     base::options(mc.cores = 1L)
[16:20:35.154]                   }
[16:20:35.154]                   ...future.strategy.old <- future::plan("list")
[16:20:35.154]                   options(future.plan = NULL)
[16:20:35.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.154]                 }
[16:20:35.154]                 ...future.workdir <- getwd()
[16:20:35.154]             }
[16:20:35.154]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.154]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.154]         }
[16:20:35.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.154]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.154]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.154]             base::names(...future.oldOptions))
[16:20:35.154]     }
[16:20:35.154]     if (FALSE) {
[16:20:35.154]     }
[16:20:35.154]     else {
[16:20:35.154]         if (TRUE) {
[16:20:35.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.154]                 open = "w")
[16:20:35.154]         }
[16:20:35.154]         else {
[16:20:35.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.154]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.154]         }
[16:20:35.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.154]             base::sink(type = "output", split = FALSE)
[16:20:35.154]             base::close(...future.stdout)
[16:20:35.154]         }, add = TRUE)
[16:20:35.154]     }
[16:20:35.154]     ...future.frame <- base::sys.nframe()
[16:20:35.154]     ...future.conditions <- base::list()
[16:20:35.154]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.154]     if (FALSE) {
[16:20:35.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.154]     }
[16:20:35.154]     ...future.result <- base::tryCatch({
[16:20:35.154]         base::withCallingHandlers({
[16:20:35.154]             ...future.value <- base::withVisible(base::local({
[16:20:35.154]                 withCallingHandlers({
[16:20:35.154]                   {
[16:20:35.154]                     2 * a
[16:20:35.154]                   }
[16:20:35.154]                 }, immediateCondition = function(cond) {
[16:20:35.154]                   save_rds <- function (object, pathname, ...) 
[16:20:35.154]                   {
[16:20:35.154]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.154]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.154]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.154]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.154]                         fi_tmp[["mtime"]])
[16:20:35.154]                     }
[16:20:35.154]                     tryCatch({
[16:20:35.154]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.154]                     }, error = function(ex) {
[16:20:35.154]                       msg <- conditionMessage(ex)
[16:20:35.154]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.154]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.154]                         fi_tmp[["mtime"]], msg)
[16:20:35.154]                       ex$message <- msg
[16:20:35.154]                       stop(ex)
[16:20:35.154]                     })
[16:20:35.154]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.154]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.154]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.154]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.154]                       fi <- file.info(pathname)
[16:20:35.154]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.154]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.154]                         fi[["size"]], fi[["mtime"]])
[16:20:35.154]                       stop(msg)
[16:20:35.154]                     }
[16:20:35.154]                     invisible(pathname)
[16:20:35.154]                   }
[16:20:35.154]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.154]                     rootPath = tempdir()) 
[16:20:35.154]                   {
[16:20:35.154]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.154]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.154]                       tmpdir = path, fileext = ".rds")
[16:20:35.154]                     save_rds(obj, file)
[16:20:35.154]                   }
[16:20:35.154]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.154]                   {
[16:20:35.154]                     inherits <- base::inherits
[16:20:35.154]                     invokeRestart <- base::invokeRestart
[16:20:35.154]                     is.null <- base::is.null
[16:20:35.154]                     muffled <- FALSE
[16:20:35.154]                     if (inherits(cond, "message")) {
[16:20:35.154]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.154]                       if (muffled) 
[16:20:35.154]                         invokeRestart("muffleMessage")
[16:20:35.154]                     }
[16:20:35.154]                     else if (inherits(cond, "warning")) {
[16:20:35.154]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.154]                       if (muffled) 
[16:20:35.154]                         invokeRestart("muffleWarning")
[16:20:35.154]                     }
[16:20:35.154]                     else if (inherits(cond, "condition")) {
[16:20:35.154]                       if (!is.null(pattern)) {
[16:20:35.154]                         computeRestarts <- base::computeRestarts
[16:20:35.154]                         grepl <- base::grepl
[16:20:35.154]                         restarts <- computeRestarts(cond)
[16:20:35.154]                         for (restart in restarts) {
[16:20:35.154]                           name <- restart$name
[16:20:35.154]                           if (is.null(name)) 
[16:20:35.154]                             next
[16:20:35.154]                           if (!grepl(pattern, name)) 
[16:20:35.154]                             next
[16:20:35.154]                           invokeRestart(restart)
[16:20:35.154]                           muffled <- TRUE
[16:20:35.154]                           break
[16:20:35.154]                         }
[16:20:35.154]                       }
[16:20:35.154]                     }
[16:20:35.154]                     invisible(muffled)
[16:20:35.154]                   }
[16:20:35.154]                   muffleCondition(cond)
[16:20:35.154]                 })
[16:20:35.154]             }))
[16:20:35.154]             future::FutureResult(value = ...future.value$value, 
[16:20:35.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.154]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.154]                     ...future.globalenv.names))
[16:20:35.154]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.154]         }, condition = base::local({
[16:20:35.154]             c <- base::c
[16:20:35.154]             inherits <- base::inherits
[16:20:35.154]             invokeRestart <- base::invokeRestart
[16:20:35.154]             length <- base::length
[16:20:35.154]             list <- base::list
[16:20:35.154]             seq.int <- base::seq.int
[16:20:35.154]             signalCondition <- base::signalCondition
[16:20:35.154]             sys.calls <- base::sys.calls
[16:20:35.154]             `[[` <- base::`[[`
[16:20:35.154]             `+` <- base::`+`
[16:20:35.154]             `<<-` <- base::`<<-`
[16:20:35.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.154]                   3L)]
[16:20:35.154]             }
[16:20:35.154]             function(cond) {
[16:20:35.154]                 is_error <- inherits(cond, "error")
[16:20:35.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.154]                   NULL)
[16:20:35.154]                 if (is_error) {
[16:20:35.154]                   sessionInformation <- function() {
[16:20:35.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.154]                       search = base::search(), system = base::Sys.info())
[16:20:35.154]                   }
[16:20:35.154]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.154]                     cond$call), session = sessionInformation(), 
[16:20:35.154]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.154]                   signalCondition(cond)
[16:20:35.154]                 }
[16:20:35.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.154]                 "immediateCondition"))) {
[16:20:35.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.154]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.154]                   if (TRUE && !signal) {
[16:20:35.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.154]                     {
[16:20:35.154]                       inherits <- base::inherits
[16:20:35.154]                       invokeRestart <- base::invokeRestart
[16:20:35.154]                       is.null <- base::is.null
[16:20:35.154]                       muffled <- FALSE
[16:20:35.154]                       if (inherits(cond, "message")) {
[16:20:35.154]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.154]                         if (muffled) 
[16:20:35.154]                           invokeRestart("muffleMessage")
[16:20:35.154]                       }
[16:20:35.154]                       else if (inherits(cond, "warning")) {
[16:20:35.154]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.154]                         if (muffled) 
[16:20:35.154]                           invokeRestart("muffleWarning")
[16:20:35.154]                       }
[16:20:35.154]                       else if (inherits(cond, "condition")) {
[16:20:35.154]                         if (!is.null(pattern)) {
[16:20:35.154]                           computeRestarts <- base::computeRestarts
[16:20:35.154]                           grepl <- base::grepl
[16:20:35.154]                           restarts <- computeRestarts(cond)
[16:20:35.154]                           for (restart in restarts) {
[16:20:35.154]                             name <- restart$name
[16:20:35.154]                             if (is.null(name)) 
[16:20:35.154]                               next
[16:20:35.154]                             if (!grepl(pattern, name)) 
[16:20:35.154]                               next
[16:20:35.154]                             invokeRestart(restart)
[16:20:35.154]                             muffled <- TRUE
[16:20:35.154]                             break
[16:20:35.154]                           }
[16:20:35.154]                         }
[16:20:35.154]                       }
[16:20:35.154]                       invisible(muffled)
[16:20:35.154]                     }
[16:20:35.154]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.154]                   }
[16:20:35.154]                 }
[16:20:35.154]                 else {
[16:20:35.154]                   if (TRUE) {
[16:20:35.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.154]                     {
[16:20:35.154]                       inherits <- base::inherits
[16:20:35.154]                       invokeRestart <- base::invokeRestart
[16:20:35.154]                       is.null <- base::is.null
[16:20:35.154]                       muffled <- FALSE
[16:20:35.154]                       if (inherits(cond, "message")) {
[16:20:35.154]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.154]                         if (muffled) 
[16:20:35.154]                           invokeRestart("muffleMessage")
[16:20:35.154]                       }
[16:20:35.154]                       else if (inherits(cond, "warning")) {
[16:20:35.154]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.154]                         if (muffled) 
[16:20:35.154]                           invokeRestart("muffleWarning")
[16:20:35.154]                       }
[16:20:35.154]                       else if (inherits(cond, "condition")) {
[16:20:35.154]                         if (!is.null(pattern)) {
[16:20:35.154]                           computeRestarts <- base::computeRestarts
[16:20:35.154]                           grepl <- base::grepl
[16:20:35.154]                           restarts <- computeRestarts(cond)
[16:20:35.154]                           for (restart in restarts) {
[16:20:35.154]                             name <- restart$name
[16:20:35.154]                             if (is.null(name)) 
[16:20:35.154]                               next
[16:20:35.154]                             if (!grepl(pattern, name)) 
[16:20:35.154]                               next
[16:20:35.154]                             invokeRestart(restart)
[16:20:35.154]                             muffled <- TRUE
[16:20:35.154]                             break
[16:20:35.154]                           }
[16:20:35.154]                         }
[16:20:35.154]                       }
[16:20:35.154]                       invisible(muffled)
[16:20:35.154]                     }
[16:20:35.154]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.154]                   }
[16:20:35.154]                 }
[16:20:35.154]             }
[16:20:35.154]         }))
[16:20:35.154]     }, error = function(ex) {
[16:20:35.154]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.154]                 ...future.rng), started = ...future.startTime, 
[16:20:35.154]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.154]             version = "1.8"), class = "FutureResult")
[16:20:35.154]     }, finally = {
[16:20:35.154]         if (!identical(...future.workdir, getwd())) 
[16:20:35.154]             setwd(...future.workdir)
[16:20:35.154]         {
[16:20:35.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.154]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.154]             }
[16:20:35.154]             base::options(...future.oldOptions)
[16:20:35.154]             if (.Platform$OS.type == "windows") {
[16:20:35.154]                 old_names <- names(...future.oldEnvVars)
[16:20:35.154]                 envs <- base::Sys.getenv()
[16:20:35.154]                 names <- names(envs)
[16:20:35.154]                 common <- intersect(names, old_names)
[16:20:35.154]                 added <- setdiff(names, old_names)
[16:20:35.154]                 removed <- setdiff(old_names, names)
[16:20:35.154]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.154]                   envs[common]]
[16:20:35.154]                 NAMES <- toupper(changed)
[16:20:35.154]                 args <- list()
[16:20:35.154]                 for (kk in seq_along(NAMES)) {
[16:20:35.154]                   name <- changed[[kk]]
[16:20:35.154]                   NAME <- NAMES[[kk]]
[16:20:35.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.154]                     next
[16:20:35.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.154]                 }
[16:20:35.154]                 NAMES <- toupper(added)
[16:20:35.154]                 for (kk in seq_along(NAMES)) {
[16:20:35.154]                   name <- added[[kk]]
[16:20:35.154]                   NAME <- NAMES[[kk]]
[16:20:35.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.154]                     next
[16:20:35.154]                   args[[name]] <- ""
[16:20:35.154]                 }
[16:20:35.154]                 NAMES <- toupper(removed)
[16:20:35.154]                 for (kk in seq_along(NAMES)) {
[16:20:35.154]                   name <- removed[[kk]]
[16:20:35.154]                   NAME <- NAMES[[kk]]
[16:20:35.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.154]                     next
[16:20:35.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.154]                 }
[16:20:35.154]                 if (length(args) > 0) 
[16:20:35.154]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.154]             }
[16:20:35.154]             else {
[16:20:35.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.154]             }
[16:20:35.154]             {
[16:20:35.154]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.154]                   0L) {
[16:20:35.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.154]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.154]                   base::options(opts)
[16:20:35.154]                 }
[16:20:35.154]                 {
[16:20:35.154]                   {
[16:20:35.154]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.154]                     NULL
[16:20:35.154]                   }
[16:20:35.154]                   options(future.plan = NULL)
[16:20:35.154]                   if (is.na(NA_character_)) 
[16:20:35.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.154]                     .init = FALSE)
[16:20:35.154]                 }
[16:20:35.154]             }
[16:20:35.154]         }
[16:20:35.154]     })
[16:20:35.154]     if (TRUE) {
[16:20:35.154]         base::sink(type = "output", split = FALSE)
[16:20:35.154]         if (TRUE) {
[16:20:35.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.154]         }
[16:20:35.154]         else {
[16:20:35.154]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.154]         }
[16:20:35.154]         base::close(...future.stdout)
[16:20:35.154]         ...future.stdout <- NULL
[16:20:35.154]     }
[16:20:35.154]     ...future.result$conditions <- ...future.conditions
[16:20:35.154]     ...future.result$finished <- base::Sys.time()
[16:20:35.154]     ...future.result
[16:20:35.154] }
[16:20:35.156] assign_globals() ...
[16:20:35.157] List of 1
[16:20:35.157]  $ a: num 1
[16:20:35.157]  - attr(*, "where")=List of 1
[16:20:35.157]   ..$ a:<environment: R_EmptyEnv> 
[16:20:35.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:35.157]  - attr(*, "resolved")= logi FALSE
[16:20:35.157]  - attr(*, "total_size")= num 56
[16:20:35.157]  - attr(*, "already-done")= logi TRUE
[16:20:35.159] - copied ‘a’ to environment
[16:20:35.160] assign_globals() ... done
[16:20:35.160] requestCore(): workers = 2
[16:20:35.161] MulticoreFuture started
[16:20:35.162] - Launch lazy future ... done
[16:20:35.162] run() for ‘MulticoreFuture’ ... done
[16:20:35.162] result() for MulticoreFuture ...
[16:20:35.163] plan(): Setting new future strategy stack:
[16:20:35.163] List of future strategies:
[16:20:35.163] 1. sequential:
[16:20:35.163]    - args: function (..., envir = parent.frame())
[16:20:35.163]    - tweaked: FALSE
[16:20:35.163]    - call: NULL
[16:20:35.164] plan(): nbrOfWorkers() = 1
[16:20:35.166] plan(): Setting new future strategy stack:
[16:20:35.166] List of future strategies:
[16:20:35.166] 1. multicore:
[16:20:35.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.166]    - tweaked: FALSE
[16:20:35.166]    - call: plan(strategy)
[16:20:35.171] plan(): nbrOfWorkers() = 2
[16:20:35.172] result() for MulticoreFuture ...
[16:20:35.172] result() for MulticoreFuture ... done
[16:20:35.172] result() for MulticoreFuture ... done
[16:20:35.172] result() for MulticoreFuture ...
[16:20:35.172] result() for MulticoreFuture ... done
[16:20:35.173] getGlobalsAndPackages() ...
[16:20:35.173] Searching for globals...
[16:20:35.174] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:35.174] Searching for globals ... DONE
[16:20:35.174] Resolving globals: FALSE
[16:20:35.175] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:35.175] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:35.175] - globals: [1] ‘a’
[16:20:35.175] 
[16:20:35.176] getGlobalsAndPackages() ... DONE
[16:20:35.176] run() for ‘Future’ ...
[16:20:35.176] - state: ‘created’
[16:20:35.176] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.180]   - Field: ‘label’
[16:20:35.181]   - Field: ‘local’
[16:20:35.181]   - Field: ‘owner’
[16:20:35.181]   - Field: ‘envir’
[16:20:35.181]   - Field: ‘workers’
[16:20:35.181]   - Field: ‘packages’
[16:20:35.181]   - Field: ‘gc’
[16:20:35.181]   - Field: ‘job’
[16:20:35.181]   - Field: ‘conditions’
[16:20:35.181]   - Field: ‘expr’
[16:20:35.182]   - Field: ‘uuid’
[16:20:35.182]   - Field: ‘seed’
[16:20:35.182]   - Field: ‘version’
[16:20:35.182]   - Field: ‘result’
[16:20:35.182]   - Field: ‘asynchronous’
[16:20:35.182]   - Field: ‘calls’
[16:20:35.182]   - Field: ‘globals’
[16:20:35.182]   - Field: ‘stdout’
[16:20:35.182]   - Field: ‘earlySignal’
[16:20:35.183]   - Field: ‘lazy’
[16:20:35.183]   - Field: ‘state’
[16:20:35.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.183] - Launch lazy future ...
[16:20:35.183] Packages needed by the future expression (n = 0): <none>
[16:20:35.183] Packages needed by future strategies (n = 0): <none>
[16:20:35.184] {
[16:20:35.184]     {
[16:20:35.184]         {
[16:20:35.184]             ...future.startTime <- base::Sys.time()
[16:20:35.184]             {
[16:20:35.184]                 {
[16:20:35.184]                   {
[16:20:35.184]                     {
[16:20:35.184]                       base::local({
[16:20:35.184]                         has_future <- base::requireNamespace("future", 
[16:20:35.184]                           quietly = TRUE)
[16:20:35.184]                         if (has_future) {
[16:20:35.184]                           ns <- base::getNamespace("future")
[16:20:35.184]                           version <- ns[[".package"]][["version"]]
[16:20:35.184]                           if (is.null(version)) 
[16:20:35.184]                             version <- utils::packageVersion("future")
[16:20:35.184]                         }
[16:20:35.184]                         else {
[16:20:35.184]                           version <- NULL
[16:20:35.184]                         }
[16:20:35.184]                         if (!has_future || version < "1.8.0") {
[16:20:35.184]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.184]                             "", base::R.version$version.string), 
[16:20:35.184]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.184]                               "release", "version")], collapse = " "), 
[16:20:35.184]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.184]                             info)
[16:20:35.184]                           info <- base::paste(info, collapse = "; ")
[16:20:35.184]                           if (!has_future) {
[16:20:35.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.184]                               info)
[16:20:35.184]                           }
[16:20:35.184]                           else {
[16:20:35.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.184]                               info, version)
[16:20:35.184]                           }
[16:20:35.184]                           base::stop(msg)
[16:20:35.184]                         }
[16:20:35.184]                       })
[16:20:35.184]                     }
[16:20:35.184]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.184]                     base::options(mc.cores = 1L)
[16:20:35.184]                   }
[16:20:35.184]                   ...future.strategy.old <- future::plan("list")
[16:20:35.184]                   options(future.plan = NULL)
[16:20:35.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.184]                 }
[16:20:35.184]                 ...future.workdir <- getwd()
[16:20:35.184]             }
[16:20:35.184]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.184]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.184]         }
[16:20:35.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.184]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.184]             base::names(...future.oldOptions))
[16:20:35.184]     }
[16:20:35.184]     if (FALSE) {
[16:20:35.184]     }
[16:20:35.184]     else {
[16:20:35.184]         if (TRUE) {
[16:20:35.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.184]                 open = "w")
[16:20:35.184]         }
[16:20:35.184]         else {
[16:20:35.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.184]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.184]         }
[16:20:35.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.184]             base::sink(type = "output", split = FALSE)
[16:20:35.184]             base::close(...future.stdout)
[16:20:35.184]         }, add = TRUE)
[16:20:35.184]     }
[16:20:35.184]     ...future.frame <- base::sys.nframe()
[16:20:35.184]     ...future.conditions <- base::list()
[16:20:35.184]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.184]     if (FALSE) {
[16:20:35.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.184]     }
[16:20:35.184]     ...future.result <- base::tryCatch({
[16:20:35.184]         base::withCallingHandlers({
[16:20:35.184]             ...future.value <- base::withVisible(base::local({
[16:20:35.184]                 withCallingHandlers({
[16:20:35.184]                   {
[16:20:35.184]                     2 * a
[16:20:35.184]                   }
[16:20:35.184]                 }, immediateCondition = function(cond) {
[16:20:35.184]                   save_rds <- function (object, pathname, ...) 
[16:20:35.184]                   {
[16:20:35.184]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.184]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.184]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.184]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.184]                         fi_tmp[["mtime"]])
[16:20:35.184]                     }
[16:20:35.184]                     tryCatch({
[16:20:35.184]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.184]                     }, error = function(ex) {
[16:20:35.184]                       msg <- conditionMessage(ex)
[16:20:35.184]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.184]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.184]                         fi_tmp[["mtime"]], msg)
[16:20:35.184]                       ex$message <- msg
[16:20:35.184]                       stop(ex)
[16:20:35.184]                     })
[16:20:35.184]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.184]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.184]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.184]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.184]                       fi <- file.info(pathname)
[16:20:35.184]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.184]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.184]                         fi[["size"]], fi[["mtime"]])
[16:20:35.184]                       stop(msg)
[16:20:35.184]                     }
[16:20:35.184]                     invisible(pathname)
[16:20:35.184]                   }
[16:20:35.184]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.184]                     rootPath = tempdir()) 
[16:20:35.184]                   {
[16:20:35.184]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.184]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.184]                       tmpdir = path, fileext = ".rds")
[16:20:35.184]                     save_rds(obj, file)
[16:20:35.184]                   }
[16:20:35.184]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.184]                   {
[16:20:35.184]                     inherits <- base::inherits
[16:20:35.184]                     invokeRestart <- base::invokeRestart
[16:20:35.184]                     is.null <- base::is.null
[16:20:35.184]                     muffled <- FALSE
[16:20:35.184]                     if (inherits(cond, "message")) {
[16:20:35.184]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.184]                       if (muffled) 
[16:20:35.184]                         invokeRestart("muffleMessage")
[16:20:35.184]                     }
[16:20:35.184]                     else if (inherits(cond, "warning")) {
[16:20:35.184]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.184]                       if (muffled) 
[16:20:35.184]                         invokeRestart("muffleWarning")
[16:20:35.184]                     }
[16:20:35.184]                     else if (inherits(cond, "condition")) {
[16:20:35.184]                       if (!is.null(pattern)) {
[16:20:35.184]                         computeRestarts <- base::computeRestarts
[16:20:35.184]                         grepl <- base::grepl
[16:20:35.184]                         restarts <- computeRestarts(cond)
[16:20:35.184]                         for (restart in restarts) {
[16:20:35.184]                           name <- restart$name
[16:20:35.184]                           if (is.null(name)) 
[16:20:35.184]                             next
[16:20:35.184]                           if (!grepl(pattern, name)) 
[16:20:35.184]                             next
[16:20:35.184]                           invokeRestart(restart)
[16:20:35.184]                           muffled <- TRUE
[16:20:35.184]                           break
[16:20:35.184]                         }
[16:20:35.184]                       }
[16:20:35.184]                     }
[16:20:35.184]                     invisible(muffled)
[16:20:35.184]                   }
[16:20:35.184]                   muffleCondition(cond)
[16:20:35.184]                 })
[16:20:35.184]             }))
[16:20:35.184]             future::FutureResult(value = ...future.value$value, 
[16:20:35.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.184]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.184]                     ...future.globalenv.names))
[16:20:35.184]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.184]         }, condition = base::local({
[16:20:35.184]             c <- base::c
[16:20:35.184]             inherits <- base::inherits
[16:20:35.184]             invokeRestart <- base::invokeRestart
[16:20:35.184]             length <- base::length
[16:20:35.184]             list <- base::list
[16:20:35.184]             seq.int <- base::seq.int
[16:20:35.184]             signalCondition <- base::signalCondition
[16:20:35.184]             sys.calls <- base::sys.calls
[16:20:35.184]             `[[` <- base::`[[`
[16:20:35.184]             `+` <- base::`+`
[16:20:35.184]             `<<-` <- base::`<<-`
[16:20:35.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.184]                   3L)]
[16:20:35.184]             }
[16:20:35.184]             function(cond) {
[16:20:35.184]                 is_error <- inherits(cond, "error")
[16:20:35.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.184]                   NULL)
[16:20:35.184]                 if (is_error) {
[16:20:35.184]                   sessionInformation <- function() {
[16:20:35.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.184]                       search = base::search(), system = base::Sys.info())
[16:20:35.184]                   }
[16:20:35.184]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.184]                     cond$call), session = sessionInformation(), 
[16:20:35.184]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.184]                   signalCondition(cond)
[16:20:35.184]                 }
[16:20:35.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.184]                 "immediateCondition"))) {
[16:20:35.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.184]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.184]                   if (TRUE && !signal) {
[16:20:35.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.184]                     {
[16:20:35.184]                       inherits <- base::inherits
[16:20:35.184]                       invokeRestart <- base::invokeRestart
[16:20:35.184]                       is.null <- base::is.null
[16:20:35.184]                       muffled <- FALSE
[16:20:35.184]                       if (inherits(cond, "message")) {
[16:20:35.184]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.184]                         if (muffled) 
[16:20:35.184]                           invokeRestart("muffleMessage")
[16:20:35.184]                       }
[16:20:35.184]                       else if (inherits(cond, "warning")) {
[16:20:35.184]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.184]                         if (muffled) 
[16:20:35.184]                           invokeRestart("muffleWarning")
[16:20:35.184]                       }
[16:20:35.184]                       else if (inherits(cond, "condition")) {
[16:20:35.184]                         if (!is.null(pattern)) {
[16:20:35.184]                           computeRestarts <- base::computeRestarts
[16:20:35.184]                           grepl <- base::grepl
[16:20:35.184]                           restarts <- computeRestarts(cond)
[16:20:35.184]                           for (restart in restarts) {
[16:20:35.184]                             name <- restart$name
[16:20:35.184]                             if (is.null(name)) 
[16:20:35.184]                               next
[16:20:35.184]                             if (!grepl(pattern, name)) 
[16:20:35.184]                               next
[16:20:35.184]                             invokeRestart(restart)
[16:20:35.184]                             muffled <- TRUE
[16:20:35.184]                             break
[16:20:35.184]                           }
[16:20:35.184]                         }
[16:20:35.184]                       }
[16:20:35.184]                       invisible(muffled)
[16:20:35.184]                     }
[16:20:35.184]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.184]                   }
[16:20:35.184]                 }
[16:20:35.184]                 else {
[16:20:35.184]                   if (TRUE) {
[16:20:35.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.184]                     {
[16:20:35.184]                       inherits <- base::inherits
[16:20:35.184]                       invokeRestart <- base::invokeRestart
[16:20:35.184]                       is.null <- base::is.null
[16:20:35.184]                       muffled <- FALSE
[16:20:35.184]                       if (inherits(cond, "message")) {
[16:20:35.184]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.184]                         if (muffled) 
[16:20:35.184]                           invokeRestart("muffleMessage")
[16:20:35.184]                       }
[16:20:35.184]                       else if (inherits(cond, "warning")) {
[16:20:35.184]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.184]                         if (muffled) 
[16:20:35.184]                           invokeRestart("muffleWarning")
[16:20:35.184]                       }
[16:20:35.184]                       else if (inherits(cond, "condition")) {
[16:20:35.184]                         if (!is.null(pattern)) {
[16:20:35.184]                           computeRestarts <- base::computeRestarts
[16:20:35.184]                           grepl <- base::grepl
[16:20:35.184]                           restarts <- computeRestarts(cond)
[16:20:35.184]                           for (restart in restarts) {
[16:20:35.184]                             name <- restart$name
[16:20:35.184]                             if (is.null(name)) 
[16:20:35.184]                               next
[16:20:35.184]                             if (!grepl(pattern, name)) 
[16:20:35.184]                               next
[16:20:35.184]                             invokeRestart(restart)
[16:20:35.184]                             muffled <- TRUE
[16:20:35.184]                             break
[16:20:35.184]                           }
[16:20:35.184]                         }
[16:20:35.184]                       }
[16:20:35.184]                       invisible(muffled)
[16:20:35.184]                     }
[16:20:35.184]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.184]                   }
[16:20:35.184]                 }
[16:20:35.184]             }
[16:20:35.184]         }))
[16:20:35.184]     }, error = function(ex) {
[16:20:35.184]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.184]                 ...future.rng), started = ...future.startTime, 
[16:20:35.184]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.184]             version = "1.8"), class = "FutureResult")
[16:20:35.184]     }, finally = {
[16:20:35.184]         if (!identical(...future.workdir, getwd())) 
[16:20:35.184]             setwd(...future.workdir)
[16:20:35.184]         {
[16:20:35.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.184]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.184]             }
[16:20:35.184]             base::options(...future.oldOptions)
[16:20:35.184]             if (.Platform$OS.type == "windows") {
[16:20:35.184]                 old_names <- names(...future.oldEnvVars)
[16:20:35.184]                 envs <- base::Sys.getenv()
[16:20:35.184]                 names <- names(envs)
[16:20:35.184]                 common <- intersect(names, old_names)
[16:20:35.184]                 added <- setdiff(names, old_names)
[16:20:35.184]                 removed <- setdiff(old_names, names)
[16:20:35.184]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.184]                   envs[common]]
[16:20:35.184]                 NAMES <- toupper(changed)
[16:20:35.184]                 args <- list()
[16:20:35.184]                 for (kk in seq_along(NAMES)) {
[16:20:35.184]                   name <- changed[[kk]]
[16:20:35.184]                   NAME <- NAMES[[kk]]
[16:20:35.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.184]                     next
[16:20:35.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.184]                 }
[16:20:35.184]                 NAMES <- toupper(added)
[16:20:35.184]                 for (kk in seq_along(NAMES)) {
[16:20:35.184]                   name <- added[[kk]]
[16:20:35.184]                   NAME <- NAMES[[kk]]
[16:20:35.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.184]                     next
[16:20:35.184]                   args[[name]] <- ""
[16:20:35.184]                 }
[16:20:35.184]                 NAMES <- toupper(removed)
[16:20:35.184]                 for (kk in seq_along(NAMES)) {
[16:20:35.184]                   name <- removed[[kk]]
[16:20:35.184]                   NAME <- NAMES[[kk]]
[16:20:35.184]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.184]                     next
[16:20:35.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.184]                 }
[16:20:35.184]                 if (length(args) > 0) 
[16:20:35.184]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.184]             }
[16:20:35.184]             else {
[16:20:35.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.184]             }
[16:20:35.184]             {
[16:20:35.184]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.184]                   0L) {
[16:20:35.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.184]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.184]                   base::options(opts)
[16:20:35.184]                 }
[16:20:35.184]                 {
[16:20:35.184]                   {
[16:20:35.184]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.184]                     NULL
[16:20:35.184]                   }
[16:20:35.184]                   options(future.plan = NULL)
[16:20:35.184]                   if (is.na(NA_character_)) 
[16:20:35.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.184]                     .init = FALSE)
[16:20:35.184]                 }
[16:20:35.184]             }
[16:20:35.184]         }
[16:20:35.184]     })
[16:20:35.184]     if (TRUE) {
[16:20:35.184]         base::sink(type = "output", split = FALSE)
[16:20:35.184]         if (TRUE) {
[16:20:35.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.184]         }
[16:20:35.184]         else {
[16:20:35.184]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.184]         }
[16:20:35.184]         base::close(...future.stdout)
[16:20:35.184]         ...future.stdout <- NULL
[16:20:35.184]     }
[16:20:35.184]     ...future.result$conditions <- ...future.conditions
[16:20:35.184]     ...future.result$finished <- base::Sys.time()
[16:20:35.184]     ...future.result
[16:20:35.184] }
[16:20:35.186] assign_globals() ...
[16:20:35.186] List of 1
[16:20:35.186]  $ a: num 1
[16:20:35.186]  - attr(*, "where")=List of 1
[16:20:35.186]   ..$ a:<environment: R_EmptyEnv> 
[16:20:35.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:35.186]  - attr(*, "resolved")= logi FALSE
[16:20:35.186]  - attr(*, "total_size")= num 56
[16:20:35.186]  - attr(*, "already-done")= logi TRUE
[16:20:35.190] - copied ‘a’ to environment
[16:20:35.190] assign_globals() ... done
[16:20:35.190] requestCore(): workers = 2
[16:20:35.191] MulticoreFuture started
[16:20:35.192] - Launch lazy future ... done
[16:20:35.192] run() for ‘MulticoreFuture’ ... done
[16:20:35.192] result() for MulticoreFuture ...
[16:20:35.193] plan(): Setting new future strategy stack:
[16:20:35.193] List of future strategies:
[16:20:35.193] 1. sequential:
[16:20:35.193]    - args: function (..., envir = parent.frame())
[16:20:35.193]    - tweaked: FALSE
[16:20:35.193]    - call: NULL
[16:20:35.194] plan(): nbrOfWorkers() = 1
[16:20:35.200] plan(): Setting new future strategy stack:
[16:20:35.200] List of future strategies:
[16:20:35.200] 1. multicore:
[16:20:35.200]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.200]    - tweaked: FALSE
[16:20:35.200]    - call: plan(strategy)
[16:20:35.205] plan(): nbrOfWorkers() = 2
[16:20:35.206] result() for MulticoreFuture ...
[16:20:35.206] result() for MulticoreFuture ... done
[16:20:35.206] result() for MulticoreFuture ... done
[16:20:35.209] result() for MulticoreFuture ...
[16:20:35.209] result() for MulticoreFuture ... done
[16:20:35.210] getGlobalsAndPackages() ...
[16:20:35.210] Searching for globals...
[16:20:35.211] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:35.211] Searching for globals ... DONE
[16:20:35.211] Resolving globals: FALSE
[16:20:35.212] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:35.213] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:35.213] - globals: [1] ‘a’
[16:20:35.213] 
[16:20:35.213] getGlobalsAndPackages() ... DONE
[16:20:35.213] run() for ‘Future’ ...
[16:20:35.213] - state: ‘created’
[16:20:35.214] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:20:35.218]   - Field: ‘label’
[16:20:35.218]   - Field: ‘local’
[16:20:35.218]   - Field: ‘owner’
[16:20:35.218]   - Field: ‘envir’
[16:20:35.218]   - Field: ‘workers’
[16:20:35.219]   - Field: ‘packages’
[16:20:35.219]   - Field: ‘gc’
[16:20:35.219]   - Field: ‘job’
[16:20:35.219]   - Field: ‘conditions’
[16:20:35.219]   - Field: ‘expr’
[16:20:35.219]   - Field: ‘uuid’
[16:20:35.219]   - Field: ‘seed’
[16:20:35.219]   - Field: ‘version’
[16:20:35.219]   - Field: ‘result’
[16:20:35.220]   - Field: ‘asynchronous’
[16:20:35.220]   - Field: ‘calls’
[16:20:35.220]   - Field: ‘globals’
[16:20:35.220]   - Field: ‘stdout’
[16:20:35.220]   - Field: ‘earlySignal’
[16:20:35.220]   - Field: ‘lazy’
[16:20:35.220]   - Field: ‘state’
[16:20:35.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:20:35.221] - Launch lazy future ...
[16:20:35.221] Packages needed by the future expression (n = 0): <none>
[16:20:35.221] Packages needed by future strategies (n = 0): <none>
[16:20:35.222] {
[16:20:35.222]     {
[16:20:35.222]         {
[16:20:35.222]             ...future.startTime <- base::Sys.time()
[16:20:35.222]             {
[16:20:35.222]                 {
[16:20:35.222]                   {
[16:20:35.222]                     {
[16:20:35.222]                       base::local({
[16:20:35.222]                         has_future <- base::requireNamespace("future", 
[16:20:35.222]                           quietly = TRUE)
[16:20:35.222]                         if (has_future) {
[16:20:35.222]                           ns <- base::getNamespace("future")
[16:20:35.222]                           version <- ns[[".package"]][["version"]]
[16:20:35.222]                           if (is.null(version)) 
[16:20:35.222]                             version <- utils::packageVersion("future")
[16:20:35.222]                         }
[16:20:35.222]                         else {
[16:20:35.222]                           version <- NULL
[16:20:35.222]                         }
[16:20:35.222]                         if (!has_future || version < "1.8.0") {
[16:20:35.222]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.222]                             "", base::R.version$version.string), 
[16:20:35.222]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.222]                               "release", "version")], collapse = " "), 
[16:20:35.222]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.222]                             info)
[16:20:35.222]                           info <- base::paste(info, collapse = "; ")
[16:20:35.222]                           if (!has_future) {
[16:20:35.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.222]                               info)
[16:20:35.222]                           }
[16:20:35.222]                           else {
[16:20:35.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.222]                               info, version)
[16:20:35.222]                           }
[16:20:35.222]                           base::stop(msg)
[16:20:35.222]                         }
[16:20:35.222]                       })
[16:20:35.222]                     }
[16:20:35.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.222]                     base::options(mc.cores = 1L)
[16:20:35.222]                   }
[16:20:35.222]                   ...future.strategy.old <- future::plan("list")
[16:20:35.222]                   options(future.plan = NULL)
[16:20:35.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.222]                 }
[16:20:35.222]                 ...future.workdir <- getwd()
[16:20:35.222]             }
[16:20:35.222]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.222]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.222]         }
[16:20:35.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.222]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.222]             base::names(...future.oldOptions))
[16:20:35.222]     }
[16:20:35.222]     if (FALSE) {
[16:20:35.222]     }
[16:20:35.222]     else {
[16:20:35.222]         if (TRUE) {
[16:20:35.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.222]                 open = "w")
[16:20:35.222]         }
[16:20:35.222]         else {
[16:20:35.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.222]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.222]         }
[16:20:35.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.222]             base::sink(type = "output", split = FALSE)
[16:20:35.222]             base::close(...future.stdout)
[16:20:35.222]         }, add = TRUE)
[16:20:35.222]     }
[16:20:35.222]     ...future.frame <- base::sys.nframe()
[16:20:35.222]     ...future.conditions <- base::list()
[16:20:35.222]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.222]     if (FALSE) {
[16:20:35.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.222]     }
[16:20:35.222]     ...future.result <- base::tryCatch({
[16:20:35.222]         base::withCallingHandlers({
[16:20:35.222]             ...future.value <- base::withVisible(base::local({
[16:20:35.222]                 withCallingHandlers({
[16:20:35.222]                   {
[16:20:35.222]                     2 * a
[16:20:35.222]                   }
[16:20:35.222]                 }, immediateCondition = function(cond) {
[16:20:35.222]                   save_rds <- function (object, pathname, ...) 
[16:20:35.222]                   {
[16:20:35.222]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:20:35.222]                     if (file_test("-f", pathname_tmp)) {
[16:20:35.222]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.222]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:20:35.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.222]                         fi_tmp[["mtime"]])
[16:20:35.222]                     }
[16:20:35.222]                     tryCatch({
[16:20:35.222]                       saveRDS(object, file = pathname_tmp, ...)
[16:20:35.222]                     }, error = function(ex) {
[16:20:35.222]                       msg <- conditionMessage(ex)
[16:20:35.222]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.222]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:20:35.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.222]                         fi_tmp[["mtime"]], msg)
[16:20:35.222]                       ex$message <- msg
[16:20:35.222]                       stop(ex)
[16:20:35.222]                     })
[16:20:35.222]                     stopifnot(file_test("-f", pathname_tmp))
[16:20:35.222]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:20:35.222]                     if (!res || file_test("-f", pathname_tmp)) {
[16:20:35.222]                       fi_tmp <- file.info(pathname_tmp)
[16:20:35.222]                       fi <- file.info(pathname)
[16:20:35.222]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:20:35.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:20:35.222]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:20:35.222]                         fi[["size"]], fi[["mtime"]])
[16:20:35.222]                       stop(msg)
[16:20:35.222]                     }
[16:20:35.222]                     invisible(pathname)
[16:20:35.222]                   }
[16:20:35.222]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:20:35.222]                     rootPath = tempdir()) 
[16:20:35.222]                   {
[16:20:35.222]                     obj <- list(time = Sys.time(), condition = cond)
[16:20:35.222]                     file <- tempfile(pattern = class(cond)[1], 
[16:20:35.222]                       tmpdir = path, fileext = ".rds")
[16:20:35.222]                     save_rds(obj, file)
[16:20:35.222]                   }
[16:20:35.222]                   saveImmediateCondition(cond, path = "/tmp/Rtmpdoikad/.future/immediateConditions")
[16:20:35.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.222]                   {
[16:20:35.222]                     inherits <- base::inherits
[16:20:35.222]                     invokeRestart <- base::invokeRestart
[16:20:35.222]                     is.null <- base::is.null
[16:20:35.222]                     muffled <- FALSE
[16:20:35.222]                     if (inherits(cond, "message")) {
[16:20:35.222]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.222]                       if (muffled) 
[16:20:35.222]                         invokeRestart("muffleMessage")
[16:20:35.222]                     }
[16:20:35.222]                     else if (inherits(cond, "warning")) {
[16:20:35.222]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.222]                       if (muffled) 
[16:20:35.222]                         invokeRestart("muffleWarning")
[16:20:35.222]                     }
[16:20:35.222]                     else if (inherits(cond, "condition")) {
[16:20:35.222]                       if (!is.null(pattern)) {
[16:20:35.222]                         computeRestarts <- base::computeRestarts
[16:20:35.222]                         grepl <- base::grepl
[16:20:35.222]                         restarts <- computeRestarts(cond)
[16:20:35.222]                         for (restart in restarts) {
[16:20:35.222]                           name <- restart$name
[16:20:35.222]                           if (is.null(name)) 
[16:20:35.222]                             next
[16:20:35.222]                           if (!grepl(pattern, name)) 
[16:20:35.222]                             next
[16:20:35.222]                           invokeRestart(restart)
[16:20:35.222]                           muffled <- TRUE
[16:20:35.222]                           break
[16:20:35.222]                         }
[16:20:35.222]                       }
[16:20:35.222]                     }
[16:20:35.222]                     invisible(muffled)
[16:20:35.222]                   }
[16:20:35.222]                   muffleCondition(cond)
[16:20:35.222]                 })
[16:20:35.222]             }))
[16:20:35.222]             future::FutureResult(value = ...future.value$value, 
[16:20:35.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.222]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.222]                     ...future.globalenv.names))
[16:20:35.222]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.222]         }, condition = base::local({
[16:20:35.222]             c <- base::c
[16:20:35.222]             inherits <- base::inherits
[16:20:35.222]             invokeRestart <- base::invokeRestart
[16:20:35.222]             length <- base::length
[16:20:35.222]             list <- base::list
[16:20:35.222]             seq.int <- base::seq.int
[16:20:35.222]             signalCondition <- base::signalCondition
[16:20:35.222]             sys.calls <- base::sys.calls
[16:20:35.222]             `[[` <- base::`[[`
[16:20:35.222]             `+` <- base::`+`
[16:20:35.222]             `<<-` <- base::`<<-`
[16:20:35.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.222]                   3L)]
[16:20:35.222]             }
[16:20:35.222]             function(cond) {
[16:20:35.222]                 is_error <- inherits(cond, "error")
[16:20:35.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.222]                   NULL)
[16:20:35.222]                 if (is_error) {
[16:20:35.222]                   sessionInformation <- function() {
[16:20:35.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.222]                       search = base::search(), system = base::Sys.info())
[16:20:35.222]                   }
[16:20:35.222]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.222]                     cond$call), session = sessionInformation(), 
[16:20:35.222]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.222]                   signalCondition(cond)
[16:20:35.222]                 }
[16:20:35.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.222]                 "immediateCondition"))) {
[16:20:35.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.222]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.222]                   if (TRUE && !signal) {
[16:20:35.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.222]                     {
[16:20:35.222]                       inherits <- base::inherits
[16:20:35.222]                       invokeRestart <- base::invokeRestart
[16:20:35.222]                       is.null <- base::is.null
[16:20:35.222]                       muffled <- FALSE
[16:20:35.222]                       if (inherits(cond, "message")) {
[16:20:35.222]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.222]                         if (muffled) 
[16:20:35.222]                           invokeRestart("muffleMessage")
[16:20:35.222]                       }
[16:20:35.222]                       else if (inherits(cond, "warning")) {
[16:20:35.222]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.222]                         if (muffled) 
[16:20:35.222]                           invokeRestart("muffleWarning")
[16:20:35.222]                       }
[16:20:35.222]                       else if (inherits(cond, "condition")) {
[16:20:35.222]                         if (!is.null(pattern)) {
[16:20:35.222]                           computeRestarts <- base::computeRestarts
[16:20:35.222]                           grepl <- base::grepl
[16:20:35.222]                           restarts <- computeRestarts(cond)
[16:20:35.222]                           for (restart in restarts) {
[16:20:35.222]                             name <- restart$name
[16:20:35.222]                             if (is.null(name)) 
[16:20:35.222]                               next
[16:20:35.222]                             if (!grepl(pattern, name)) 
[16:20:35.222]                               next
[16:20:35.222]                             invokeRestart(restart)
[16:20:35.222]                             muffled <- TRUE
[16:20:35.222]                             break
[16:20:35.222]                           }
[16:20:35.222]                         }
[16:20:35.222]                       }
[16:20:35.222]                       invisible(muffled)
[16:20:35.222]                     }
[16:20:35.222]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.222]                   }
[16:20:35.222]                 }
[16:20:35.222]                 else {
[16:20:35.222]                   if (TRUE) {
[16:20:35.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.222]                     {
[16:20:35.222]                       inherits <- base::inherits
[16:20:35.222]                       invokeRestart <- base::invokeRestart
[16:20:35.222]                       is.null <- base::is.null
[16:20:35.222]                       muffled <- FALSE
[16:20:35.222]                       if (inherits(cond, "message")) {
[16:20:35.222]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.222]                         if (muffled) 
[16:20:35.222]                           invokeRestart("muffleMessage")
[16:20:35.222]                       }
[16:20:35.222]                       else if (inherits(cond, "warning")) {
[16:20:35.222]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.222]                         if (muffled) 
[16:20:35.222]                           invokeRestart("muffleWarning")
[16:20:35.222]                       }
[16:20:35.222]                       else if (inherits(cond, "condition")) {
[16:20:35.222]                         if (!is.null(pattern)) {
[16:20:35.222]                           computeRestarts <- base::computeRestarts
[16:20:35.222]                           grepl <- base::grepl
[16:20:35.222]                           restarts <- computeRestarts(cond)
[16:20:35.222]                           for (restart in restarts) {
[16:20:35.222]                             name <- restart$name
[16:20:35.222]                             if (is.null(name)) 
[16:20:35.222]                               next
[16:20:35.222]                             if (!grepl(pattern, name)) 
[16:20:35.222]                               next
[16:20:35.222]                             invokeRestart(restart)
[16:20:35.222]                             muffled <- TRUE
[16:20:35.222]                             break
[16:20:35.222]                           }
[16:20:35.222]                         }
[16:20:35.222]                       }
[16:20:35.222]                       invisible(muffled)
[16:20:35.222]                     }
[16:20:35.222]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.222]                   }
[16:20:35.222]                 }
[16:20:35.222]             }
[16:20:35.222]         }))
[16:20:35.222]     }, error = function(ex) {
[16:20:35.222]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.222]                 ...future.rng), started = ...future.startTime, 
[16:20:35.222]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.222]             version = "1.8"), class = "FutureResult")
[16:20:35.222]     }, finally = {
[16:20:35.222]         if (!identical(...future.workdir, getwd())) 
[16:20:35.222]             setwd(...future.workdir)
[16:20:35.222]         {
[16:20:35.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.222]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.222]             }
[16:20:35.222]             base::options(...future.oldOptions)
[16:20:35.222]             if (.Platform$OS.type == "windows") {
[16:20:35.222]                 old_names <- names(...future.oldEnvVars)
[16:20:35.222]                 envs <- base::Sys.getenv()
[16:20:35.222]                 names <- names(envs)
[16:20:35.222]                 common <- intersect(names, old_names)
[16:20:35.222]                 added <- setdiff(names, old_names)
[16:20:35.222]                 removed <- setdiff(old_names, names)
[16:20:35.222]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.222]                   envs[common]]
[16:20:35.222]                 NAMES <- toupper(changed)
[16:20:35.222]                 args <- list()
[16:20:35.222]                 for (kk in seq_along(NAMES)) {
[16:20:35.222]                   name <- changed[[kk]]
[16:20:35.222]                   NAME <- NAMES[[kk]]
[16:20:35.222]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.222]                     next
[16:20:35.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.222]                 }
[16:20:35.222]                 NAMES <- toupper(added)
[16:20:35.222]                 for (kk in seq_along(NAMES)) {
[16:20:35.222]                   name <- added[[kk]]
[16:20:35.222]                   NAME <- NAMES[[kk]]
[16:20:35.222]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.222]                     next
[16:20:35.222]                   args[[name]] <- ""
[16:20:35.222]                 }
[16:20:35.222]                 NAMES <- toupper(removed)
[16:20:35.222]                 for (kk in seq_along(NAMES)) {
[16:20:35.222]                   name <- removed[[kk]]
[16:20:35.222]                   NAME <- NAMES[[kk]]
[16:20:35.222]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.222]                     next
[16:20:35.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.222]                 }
[16:20:35.222]                 if (length(args) > 0) 
[16:20:35.222]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.222]             }
[16:20:35.222]             else {
[16:20:35.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.222]             }
[16:20:35.222]             {
[16:20:35.222]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.222]                   0L) {
[16:20:35.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.222]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.222]                   base::options(opts)
[16:20:35.222]                 }
[16:20:35.222]                 {
[16:20:35.222]                   {
[16:20:35.222]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.222]                     NULL
[16:20:35.222]                   }
[16:20:35.222]                   options(future.plan = NULL)
[16:20:35.222]                   if (is.na(NA_character_)) 
[16:20:35.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.222]                     .init = FALSE)
[16:20:35.222]                 }
[16:20:35.222]             }
[16:20:35.222]         }
[16:20:35.222]     })
[16:20:35.222]     if (TRUE) {
[16:20:35.222]         base::sink(type = "output", split = FALSE)
[16:20:35.222]         if (TRUE) {
[16:20:35.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.222]         }
[16:20:35.222]         else {
[16:20:35.222]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.222]         }
[16:20:35.222]         base::close(...future.stdout)
[16:20:35.222]         ...future.stdout <- NULL
[16:20:35.222]     }
[16:20:35.222]     ...future.result$conditions <- ...future.conditions
[16:20:35.222]     ...future.result$finished <- base::Sys.time()
[16:20:35.222]     ...future.result
[16:20:35.222] }
[16:20:35.224] assign_globals() ...
[16:20:35.224] List of 1
[16:20:35.224]  $ a: num 1
[16:20:35.224]  - attr(*, "where")=List of 1
[16:20:35.224]   ..$ a:<environment: R_EmptyEnv> 
[16:20:35.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:20:35.224]  - attr(*, "resolved")= logi FALSE
[16:20:35.224]  - attr(*, "total_size")= num 56
[16:20:35.224]  - attr(*, "already-done")= logi TRUE
[16:20:35.227] - copied ‘a’ to environment
[16:20:35.227] assign_globals() ... done
[16:20:35.227] requestCore(): workers = 2
[16:20:35.229] MulticoreFuture started
[16:20:35.229] - Launch lazy future ... done
[16:20:35.229] run() for ‘MulticoreFuture’ ... done
[16:20:35.230] result() for MulticoreFuture ...
[16:20:35.230] plan(): Setting new future strategy stack:
[16:20:35.230] List of future strategies:
[16:20:35.230] 1. sequential:
[16:20:35.230]    - args: function (..., envir = parent.frame())
[16:20:35.230]    - tweaked: FALSE
[16:20:35.230]    - call: NULL
[16:20:35.231] plan(): nbrOfWorkers() = 1
[16:20:35.233] plan(): Setting new future strategy stack:
[16:20:35.233] List of future strategies:
[16:20:35.233] 1. multicore:
[16:20:35.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:20:35.233]    - tweaked: FALSE
[16:20:35.233]    - call: plan(strategy)
[16:20:35.238] plan(): nbrOfWorkers() = 2
[16:20:35.239] result() for MulticoreFuture ...
[16:20:35.239] result() for MulticoreFuture ... done
[16:20:35.240] result() for MulticoreFuture ... done
[16:20:35.240] result() for MulticoreFuture ...
[16:20:35.240] result() for MulticoreFuture ... done
*** futureAssign() with ‘multicore’ futures ... DONE
*** futureAssign() with ‘multisession’ futures ...
[16:20:35.241] plan(): Setting new future strategy stack:
[16:20:35.241] List of future strategies:
[16:20:35.241] 1. multisession:
[16:20:35.241]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:35.241]    - tweaked: FALSE
[16:20:35.241]    - call: plan(strategy)
[16:20:35.241] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:20:35.241] multisession:
[16:20:35.241] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:20:35.241] - tweaked: FALSE
[16:20:35.241] - call: plan(strategy)
[16:20:35.248] getGlobalsAndPackages() ...
[16:20:35.248] Not searching for globals
[16:20:35.249] - globals: [0] <none>
[16:20:35.249] getGlobalsAndPackages() ... DONE
[16:20:35.249] [local output] makeClusterPSOCK() ...
[16:20:35.294] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:20:35.296] [local output] Base port: 11373
[16:20:35.296] [local output] Getting setup options for 2 cluster nodes ...
[16:20:35.296] [local output]  - Node 1 of 2 ...
[16:20:35.296] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:35.297] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpdoikad/worker.rank=1.parallelly.parent=80841.13bc952aca4a8.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpdoikad/worker.rank=1.parallelly.parent=80841.13bc952aca4a8.pid")'’
[16:20:35.484] - Possible to infer worker's PID: TRUE
[16:20:35.484] [local output] Rscript port: 11373

[16:20:35.485] [local output]  - Node 2 of 2 ...
[16:20:35.485] [local output] localMachine=TRUE => revtunnel=FALSE

[16:20:35.486] [local output] Rscript port: 11373

[16:20:35.486] [local output] Getting setup options for 2 cluster nodes ... done
[16:20:35.486] [local output]  - Parallel setup requested for some PSOCK nodes
[16:20:35.487] [local output] Setting up PSOCK nodes in parallel
[16:20:35.487] List of 36
[16:20:35.487]  $ worker          : chr "localhost"
[16:20:35.487]   ..- attr(*, "localhost")= logi TRUE
[16:20:35.487]  $ master          : chr "localhost"
[16:20:35.487]  $ port            : int 11373
[16:20:35.487]  $ connectTimeout  : num 120
[16:20:35.487]  $ timeout         : num 2592000
[16:20:35.487]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:20:35.487]  $ homogeneous     : logi TRUE
[16:20:35.487]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:20:35.487]  $ rscript_envs    : NULL
[16:20:35.487]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:35.487]  $ rscript_startup : NULL
[16:20:35.487]  $ rscript_sh      : chr "sh"
[16:20:35.487]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:35.487]  $ methods         : logi TRUE
[16:20:35.487]  $ socketOptions   : chr "no-delay"
[16:20:35.487]  $ useXDR          : logi FALSE
[16:20:35.487]  $ outfile         : chr "/dev/null"
[16:20:35.487]  $ renice          : int NA
[16:20:35.487]  $ rshcmd          : NULL
[16:20:35.487]  $ user            : chr(0) 
[16:20:35.487]  $ revtunnel       : logi FALSE
[16:20:35.487]  $ rshlogfile      : NULL
[16:20:35.487]  $ rshopts         : chr(0) 
[16:20:35.487]  $ rank            : int 1
[16:20:35.487]  $ manual          : logi FALSE
[16:20:35.487]  $ dryrun          : logi FALSE
[16:20:35.487]  $ quiet           : logi FALSE
[16:20:35.487]  $ setup_strategy  : chr "parallel"
[16:20:35.487]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:35.487]  $ pidfile         : chr "/tmp/Rtmpdoikad/worker.rank=1.parallelly.parent=80841.13bc952aca4a8.pid"
[16:20:35.487]  $ rshcmd_label    : NULL
[16:20:35.487]  $ rsh_call        : NULL
[16:20:35.487]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:20:35.487]  $ localMachine    : logi TRUE
[16:20:35.487]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:20:35.487]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:20:35.487]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:20:35.487]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:20:35.487]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:20:35.487]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:20:35.487]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:20:35.487]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:20:35.487]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:20:35.487]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:20:35.487]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:20:35.487]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:20:35.487]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:20:35.487]  $ arguments       :List of 28
[16:20:35.487]   ..$ worker          : chr "localhost"
[16:20:35.487]   ..$ master          : NULL
[16:20:35.487]   ..$ port            : int 11373
[16:20:35.487]   ..$ connectTimeout  : num 120
[16:20:35.487]   ..$ timeout         : num 2592000
[16:20:35.487]   ..$ rscript         : NULL
[16:20:35.487]   ..$ homogeneous     : NULL
[16:20:35.487]   ..$ rscript_args    : NULL
[16:20:35.487]   ..$ rscript_envs    : NULL
[16:20:35.487]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:20:35.487]   ..$ rscript_startup : NULL
[16:20:35.487]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:20:35.487]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:20:35.487]   ..$ methods         : logi TRUE
[16:20:35.487]   ..$ socketOptions   : chr "no-delay"
[16:20:35.487]   ..$ useXDR          : logi FALSE
[16:20:35.487]   ..$ outfile         : chr "/dev/null"
[16:20:35.487]   ..$ renice          : int NA
[16:20:35.487]   ..$ rshcmd          : NULL
[16:20:35.487]   ..$ user            : NULL
[16:20:35.487]   ..$ revtunnel       : logi NA
[16:20:35.487]   ..$ rshlogfile      : NULL
[16:20:35.487]   ..$ rshopts         : NULL
[16:20:35.487]   ..$ rank            : int 1
[16:20:35.487]   ..$ manual          : logi FALSE
[16:20:35.487]   ..$ dryrun          : logi FALSE
[16:20:35.487]   ..$ quiet           : logi FALSE
[16:20:35.487]   ..$ setup_strategy  : chr "parallel"
[16:20:35.487]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:20:35.504] [local output] System call to launch all workers:
[16:20:35.504] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpdoikad/worker.rank=1.parallelly.parent=80841.13bc952aca4a8.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11373 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:20:35.504] [local output] Starting PSOCK main server
[16:20:35.509] [local output] Workers launched
[16:20:35.510] [local output] Waiting for workers to connect back
[16:20:35.510]  - [local output] 0 workers out of 2 ready
[16:20:35.754]  - [local output] 0 workers out of 2 ready
[16:20:35.755]  - [local output] 1 workers out of 2 ready
[16:20:35.761]  - [local output] 1 workers out of 2 ready
[16:20:35.761]  - [local output] 2 workers out of 2 ready
[16:20:35.761] [local output] Launching of workers completed
[16:20:35.762] [local output] Collecting session information from workers
[16:20:35.762] [local output]  - Worker #1 of 2
[16:20:35.763] [local output]  - Worker #2 of 2
[16:20:35.763] [local output] makeClusterPSOCK() ... done
[16:20:35.774] Packages needed by the future expression (n = 0): <none>
[16:20:35.774] Packages needed by future strategies (n = 0): <none>
[16:20:35.775] {
[16:20:35.775]     {
[16:20:35.775]         {
[16:20:35.775]             ...future.startTime <- base::Sys.time()
[16:20:35.775]             {
[16:20:35.775]                 {
[16:20:35.775]                   {
[16:20:35.775]                     {
[16:20:35.775]                       base::local({
[16:20:35.775]                         has_future <- base::requireNamespace("future", 
[16:20:35.775]                           quietly = TRUE)
[16:20:35.775]                         if (has_future) {
[16:20:35.775]                           ns <- base::getNamespace("future")
[16:20:35.775]                           version <- ns[[".package"]][["version"]]
[16:20:35.775]                           if (is.null(version)) 
[16:20:35.775]                             version <- utils::packageVersion("future")
[16:20:35.775]                         }
[16:20:35.775]                         else {
[16:20:35.775]                           version <- NULL
[16:20:35.775]                         }
[16:20:35.775]                         if (!has_future || version < "1.8.0") {
[16:20:35.775]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.775]                             "", base::R.version$version.string), 
[16:20:35.775]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.775]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.775]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.775]                               "release", "version")], collapse = " "), 
[16:20:35.775]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.775]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.775]                             info)
[16:20:35.775]                           info <- base::paste(info, collapse = "; ")
[16:20:35.775]                           if (!has_future) {
[16:20:35.775]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.775]                               info)
[16:20:35.775]                           }
[16:20:35.775]                           else {
[16:20:35.775]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.775]                               info, version)
[16:20:35.775]                           }
[16:20:35.775]                           base::stop(msg)
[16:20:35.775]                         }
[16:20:35.775]                       })
[16:20:35.775]                     }
[16:20:35.775]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.775]                     base::options(mc.cores = 1L)
[16:20:35.775]                   }
[16:20:35.775]                   ...future.strategy.old <- future::plan("list")
[16:20:35.775]                   options(future.plan = NULL)
[16:20:35.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.775]                 }
[16:20:35.775]                 ...future.workdir <- getwd()
[16:20:35.775]             }
[16:20:35.775]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.775]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.775]         }
[16:20:35.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.775]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.775]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.775]             base::names(...future.oldOptions))
[16:20:35.775]     }
[16:20:35.775]     if (FALSE) {
[16:20:35.775]     }
[16:20:35.775]     else {
[16:20:35.775]         if (TRUE) {
[16:20:35.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.775]                 open = "w")
[16:20:35.775]         }
[16:20:35.775]         else {
[16:20:35.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.775]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.775]         }
[16:20:35.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.775]             base::sink(type = "output", split = FALSE)
[16:20:35.775]             base::close(...future.stdout)
[16:20:35.775]         }, add = TRUE)
[16:20:35.775]     }
[16:20:35.775]     ...future.frame <- base::sys.nframe()
[16:20:35.775]     ...future.conditions <- base::list()
[16:20:35.775]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.775]     if (FALSE) {
[16:20:35.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.775]     }
[16:20:35.775]     ...future.result <- base::tryCatch({
[16:20:35.775]         base::withCallingHandlers({
[16:20:35.775]             ...future.value <- base::withVisible(base::local({
[16:20:35.775]                 ...future.makeSendCondition <- base::local({
[16:20:35.775]                   sendCondition <- NULL
[16:20:35.775]                   function(frame = 1L) {
[16:20:35.775]                     if (is.function(sendCondition)) 
[16:20:35.775]                       return(sendCondition)
[16:20:35.775]                     ns <- getNamespace("parallel")
[16:20:35.775]                     if (exists("sendData", mode = "function", 
[16:20:35.775]                       envir = ns)) {
[16:20:35.775]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:35.775]                         envir = ns)
[16:20:35.775]                       envir <- sys.frame(frame)
[16:20:35.775]                       master <- NULL
[16:20:35.775]                       while (!identical(envir, .GlobalEnv) && 
[16:20:35.775]                         !identical(envir, emptyenv())) {
[16:20:35.775]                         if (exists("master", mode = "list", envir = envir, 
[16:20:35.775]                           inherits = FALSE)) {
[16:20:35.775]                           master <- get("master", mode = "list", 
[16:20:35.775]                             envir = envir, inherits = FALSE)
[16:20:35.775]                           if (inherits(master, c("SOCKnode", 
[16:20:35.775]                             "SOCK0node"))) {
[16:20:35.775]                             sendCondition <<- function(cond) {
[16:20:35.775]                               data <- list(type = "VALUE", value = cond, 
[16:20:35.775]                                 success = TRUE)
[16:20:35.775]                               parallel_sendData(master, data)
[16:20:35.775]                             }
[16:20:35.775]                             return(sendCondition)
[16:20:35.775]                           }
[16:20:35.775]                         }
[16:20:35.775]                         frame <- frame + 1L
[16:20:35.775]                         envir <- sys.frame(frame)
[16:20:35.775]                       }
[16:20:35.775]                     }
[16:20:35.775]                     sendCondition <<- function(cond) NULL
[16:20:35.775]                   }
[16:20:35.775]                 })
[16:20:35.775]                 withCallingHandlers({
[16:20:35.775]                   NA
[16:20:35.775]                 }, immediateCondition = function(cond) {
[16:20:35.775]                   sendCondition <- ...future.makeSendCondition()
[16:20:35.775]                   sendCondition(cond)
[16:20:35.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.775]                   {
[16:20:35.775]                     inherits <- base::inherits
[16:20:35.775]                     invokeRestart <- base::invokeRestart
[16:20:35.775]                     is.null <- base::is.null
[16:20:35.775]                     muffled <- FALSE
[16:20:35.775]                     if (inherits(cond, "message")) {
[16:20:35.775]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.775]                       if (muffled) 
[16:20:35.775]                         invokeRestart("muffleMessage")
[16:20:35.775]                     }
[16:20:35.775]                     else if (inherits(cond, "warning")) {
[16:20:35.775]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.775]                       if (muffled) 
[16:20:35.775]                         invokeRestart("muffleWarning")
[16:20:35.775]                     }
[16:20:35.775]                     else if (inherits(cond, "condition")) {
[16:20:35.775]                       if (!is.null(pattern)) {
[16:20:35.775]                         computeRestarts <- base::computeRestarts
[16:20:35.775]                         grepl <- base::grepl
[16:20:35.775]                         restarts <- computeRestarts(cond)
[16:20:35.775]                         for (restart in restarts) {
[16:20:35.775]                           name <- restart$name
[16:20:35.775]                           if (is.null(name)) 
[16:20:35.775]                             next
[16:20:35.775]                           if (!grepl(pattern, name)) 
[16:20:35.775]                             next
[16:20:35.775]                           invokeRestart(restart)
[16:20:35.775]                           muffled <- TRUE
[16:20:35.775]                           break
[16:20:35.775]                         }
[16:20:35.775]                       }
[16:20:35.775]                     }
[16:20:35.775]                     invisible(muffled)
[16:20:35.775]                   }
[16:20:35.775]                   muffleCondition(cond)
[16:20:35.775]                 })
[16:20:35.775]             }))
[16:20:35.775]             future::FutureResult(value = ...future.value$value, 
[16:20:35.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.775]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.775]                     ...future.globalenv.names))
[16:20:35.775]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.775]         }, condition = base::local({
[16:20:35.775]             c <- base::c
[16:20:35.775]             inherits <- base::inherits
[16:20:35.775]             invokeRestart <- base::invokeRestart
[16:20:35.775]             length <- base::length
[16:20:35.775]             list <- base::list
[16:20:35.775]             seq.int <- base::seq.int
[16:20:35.775]             signalCondition <- base::signalCondition
[16:20:35.775]             sys.calls <- base::sys.calls
[16:20:35.775]             `[[` <- base::`[[`
[16:20:35.775]             `+` <- base::`+`
[16:20:35.775]             `<<-` <- base::`<<-`
[16:20:35.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.775]                   3L)]
[16:20:35.775]             }
[16:20:35.775]             function(cond) {
[16:20:35.775]                 is_error <- inherits(cond, "error")
[16:20:35.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.775]                   NULL)
[16:20:35.775]                 if (is_error) {
[16:20:35.775]                   sessionInformation <- function() {
[16:20:35.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.775]                       search = base::search(), system = base::Sys.info())
[16:20:35.775]                   }
[16:20:35.775]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.775]                     cond$call), session = sessionInformation(), 
[16:20:35.775]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.775]                   signalCondition(cond)
[16:20:35.775]                 }
[16:20:35.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.775]                 "immediateCondition"))) {
[16:20:35.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.775]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.775]                   if (TRUE && !signal) {
[16:20:35.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.775]                     {
[16:20:35.775]                       inherits <- base::inherits
[16:20:35.775]                       invokeRestart <- base::invokeRestart
[16:20:35.775]                       is.null <- base::is.null
[16:20:35.775]                       muffled <- FALSE
[16:20:35.775]                       if (inherits(cond, "message")) {
[16:20:35.775]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.775]                         if (muffled) 
[16:20:35.775]                           invokeRestart("muffleMessage")
[16:20:35.775]                       }
[16:20:35.775]                       else if (inherits(cond, "warning")) {
[16:20:35.775]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.775]                         if (muffled) 
[16:20:35.775]                           invokeRestart("muffleWarning")
[16:20:35.775]                       }
[16:20:35.775]                       else if (inherits(cond, "condition")) {
[16:20:35.775]                         if (!is.null(pattern)) {
[16:20:35.775]                           computeRestarts <- base::computeRestarts
[16:20:35.775]                           grepl <- base::grepl
[16:20:35.775]                           restarts <- computeRestarts(cond)
[16:20:35.775]                           for (restart in restarts) {
[16:20:35.775]                             name <- restart$name
[16:20:35.775]                             if (is.null(name)) 
[16:20:35.775]                               next
[16:20:35.775]                             if (!grepl(pattern, name)) 
[16:20:35.775]                               next
[16:20:35.775]                             invokeRestart(restart)
[16:20:35.775]                             muffled <- TRUE
[16:20:35.775]                             break
[16:20:35.775]                           }
[16:20:35.775]                         }
[16:20:35.775]                       }
[16:20:35.775]                       invisible(muffled)
[16:20:35.775]                     }
[16:20:35.775]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.775]                   }
[16:20:35.775]                 }
[16:20:35.775]                 else {
[16:20:35.775]                   if (TRUE) {
[16:20:35.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.775]                     {
[16:20:35.775]                       inherits <- base::inherits
[16:20:35.775]                       invokeRestart <- base::invokeRestart
[16:20:35.775]                       is.null <- base::is.null
[16:20:35.775]                       muffled <- FALSE
[16:20:35.775]                       if (inherits(cond, "message")) {
[16:20:35.775]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.775]                         if (muffled) 
[16:20:35.775]                           invokeRestart("muffleMessage")
[16:20:35.775]                       }
[16:20:35.775]                       else if (inherits(cond, "warning")) {
[16:20:35.775]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.775]                         if (muffled) 
[16:20:35.775]                           invokeRestart("muffleWarning")
[16:20:35.775]                       }
[16:20:35.775]                       else if (inherits(cond, "condition")) {
[16:20:35.775]                         if (!is.null(pattern)) {
[16:20:35.775]                           computeRestarts <- base::computeRestarts
[16:20:35.775]                           grepl <- base::grepl
[16:20:35.775]                           restarts <- computeRestarts(cond)
[16:20:35.775]                           for (restart in restarts) {
[16:20:35.775]                             name <- restart$name
[16:20:35.775]                             if (is.null(name)) 
[16:20:35.775]                               next
[16:20:35.775]                             if (!grepl(pattern, name)) 
[16:20:35.775]                               next
[16:20:35.775]                             invokeRestart(restart)
[16:20:35.775]                             muffled <- TRUE
[16:20:35.775]                             break
[16:20:35.775]                           }
[16:20:35.775]                         }
[16:20:35.775]                       }
[16:20:35.775]                       invisible(muffled)
[16:20:35.775]                     }
[16:20:35.775]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.775]                   }
[16:20:35.775]                 }
[16:20:35.775]             }
[16:20:35.775]         }))
[16:20:35.775]     }, error = function(ex) {
[16:20:35.775]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.775]                 ...future.rng), started = ...future.startTime, 
[16:20:35.775]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.775]             version = "1.8"), class = "FutureResult")
[16:20:35.775]     }, finally = {
[16:20:35.775]         if (!identical(...future.workdir, getwd())) 
[16:20:35.775]             setwd(...future.workdir)
[16:20:35.775]         {
[16:20:35.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.775]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.775]             }
[16:20:35.775]             base::options(...future.oldOptions)
[16:20:35.775]             if (.Platform$OS.type == "windows") {
[16:20:35.775]                 old_names <- names(...future.oldEnvVars)
[16:20:35.775]                 envs <- base::Sys.getenv()
[16:20:35.775]                 names <- names(envs)
[16:20:35.775]                 common <- intersect(names, old_names)
[16:20:35.775]                 added <- setdiff(names, old_names)
[16:20:35.775]                 removed <- setdiff(old_names, names)
[16:20:35.775]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.775]                   envs[common]]
[16:20:35.775]                 NAMES <- toupper(changed)
[16:20:35.775]                 args <- list()
[16:20:35.775]                 for (kk in seq_along(NAMES)) {
[16:20:35.775]                   name <- changed[[kk]]
[16:20:35.775]                   NAME <- NAMES[[kk]]
[16:20:35.775]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.775]                     next
[16:20:35.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.775]                 }
[16:20:35.775]                 NAMES <- toupper(added)
[16:20:35.775]                 for (kk in seq_along(NAMES)) {
[16:20:35.775]                   name <- added[[kk]]
[16:20:35.775]                   NAME <- NAMES[[kk]]
[16:20:35.775]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.775]                     next
[16:20:35.775]                   args[[name]] <- ""
[16:20:35.775]                 }
[16:20:35.775]                 NAMES <- toupper(removed)
[16:20:35.775]                 for (kk in seq_along(NAMES)) {
[16:20:35.775]                   name <- removed[[kk]]
[16:20:35.775]                   NAME <- NAMES[[kk]]
[16:20:35.775]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.775]                     next
[16:20:35.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.775]                 }
[16:20:35.775]                 if (length(args) > 0) 
[16:20:35.775]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.775]             }
[16:20:35.775]             else {
[16:20:35.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.775]             }
[16:20:35.775]             {
[16:20:35.775]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.775]                   0L) {
[16:20:35.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.775]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.775]                   base::options(opts)
[16:20:35.775]                 }
[16:20:35.775]                 {
[16:20:35.775]                   {
[16:20:35.775]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.775]                     NULL
[16:20:35.775]                   }
[16:20:35.775]                   options(future.plan = NULL)
[16:20:35.775]                   if (is.na(NA_character_)) 
[16:20:35.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.775]                     .init = FALSE)
[16:20:35.775]                 }
[16:20:35.775]             }
[16:20:35.775]         }
[16:20:35.775]     })
[16:20:35.775]     if (TRUE) {
[16:20:35.775]         base::sink(type = "output", split = FALSE)
[16:20:35.775]         if (TRUE) {
[16:20:35.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.775]         }
[16:20:35.775]         else {
[16:20:35.775]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.775]         }
[16:20:35.775]         base::close(...future.stdout)
[16:20:35.775]         ...future.stdout <- NULL
[16:20:35.775]     }
[16:20:35.775]     ...future.result$conditions <- ...future.conditions
[16:20:35.775]     ...future.result$finished <- base::Sys.time()
[16:20:35.775]     ...future.result
[16:20:35.775] }
[16:20:35.829] MultisessionFuture started
[16:20:35.829] result() for ClusterFuture ...
[16:20:35.830] receiveMessageFromWorker() for ClusterFuture ...
[16:20:35.830] - Validating connection of MultisessionFuture
[16:20:35.863] - received message: FutureResult
[16:20:35.863] - Received FutureResult
[16:20:35.863] - Erased future from FutureRegistry
[16:20:35.863] result() for ClusterFuture ...
[16:20:35.863] - result already collected: FutureResult
[16:20:35.863] result() for ClusterFuture ... done
[16:20:35.864] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:35.864] result() for ClusterFuture ... done
[16:20:35.864] result() for ClusterFuture ...
[16:20:35.864] - result already collected: FutureResult
[16:20:35.864] result() for ClusterFuture ... done
[16:20:35.864] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:20:35.868] plan(): nbrOfWorkers() = 2
[16:20:35.869] getGlobalsAndPackages() ...
[16:20:35.869] Searching for globals...
[16:20:35.870] - globals found: [1] ‘{’
[16:20:35.870] Searching for globals ... DONE
[16:20:35.870] Resolving globals: FALSE
[16:20:35.871] 
[16:20:35.871] 
[16:20:35.871] getGlobalsAndPackages() ... DONE
[16:20:35.871] run() for ‘Future’ ...
[16:20:35.871] - state: ‘created’
[16:20:35.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:35.886]   - Field: ‘node’
[16:20:35.886]   - Field: ‘label’
[16:20:35.886]   - Field: ‘local’
[16:20:35.886]   - Field: ‘owner’
[16:20:35.886]   - Field: ‘envir’
[16:20:35.886]   - Field: ‘workers’
[16:20:35.886]   - Field: ‘packages’
[16:20:35.887]   - Field: ‘gc’
[16:20:35.887]   - Field: ‘conditions’
[16:20:35.887]   - Field: ‘persistent’
[16:20:35.887]   - Field: ‘expr’
[16:20:35.887]   - Field: ‘uuid’
[16:20:35.887]   - Field: ‘seed’
[16:20:35.887]   - Field: ‘version’
[16:20:35.887]   - Field: ‘result’
[16:20:35.887]   - Field: ‘asynchronous’
[16:20:35.888]   - Field: ‘calls’
[16:20:35.888]   - Field: ‘globals’
[16:20:35.888]   - Field: ‘stdout’
[16:20:35.888]   - Field: ‘earlySignal’
[16:20:35.888]   - Field: ‘lazy’
[16:20:35.888]   - Field: ‘state’
[16:20:35.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:35.888] - Launch lazy future ...
[16:20:35.889] Packages needed by the future expression (n = 0): <none>
[16:20:35.889] Packages needed by future strategies (n = 0): <none>
[16:20:35.889] {
[16:20:35.889]     {
[16:20:35.889]         {
[16:20:35.889]             ...future.startTime <- base::Sys.time()
[16:20:35.889]             {
[16:20:35.889]                 {
[16:20:35.889]                   {
[16:20:35.889]                     {
[16:20:35.889]                       base::local({
[16:20:35.889]                         has_future <- base::requireNamespace("future", 
[16:20:35.889]                           quietly = TRUE)
[16:20:35.889]                         if (has_future) {
[16:20:35.889]                           ns <- base::getNamespace("future")
[16:20:35.889]                           version <- ns[[".package"]][["version"]]
[16:20:35.889]                           if (is.null(version)) 
[16:20:35.889]                             version <- utils::packageVersion("future")
[16:20:35.889]                         }
[16:20:35.889]                         else {
[16:20:35.889]                           version <- NULL
[16:20:35.889]                         }
[16:20:35.889]                         if (!has_future || version < "1.8.0") {
[16:20:35.889]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.889]                             "", base::R.version$version.string), 
[16:20:35.889]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.889]                               "release", "version")], collapse = " "), 
[16:20:35.889]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.889]                             info)
[16:20:35.889]                           info <- base::paste(info, collapse = "; ")
[16:20:35.889]                           if (!has_future) {
[16:20:35.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.889]                               info)
[16:20:35.889]                           }
[16:20:35.889]                           else {
[16:20:35.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.889]                               info, version)
[16:20:35.889]                           }
[16:20:35.889]                           base::stop(msg)
[16:20:35.889]                         }
[16:20:35.889]                       })
[16:20:35.889]                     }
[16:20:35.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.889]                     base::options(mc.cores = 1L)
[16:20:35.889]                   }
[16:20:35.889]                   ...future.strategy.old <- future::plan("list")
[16:20:35.889]                   options(future.plan = NULL)
[16:20:35.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.889]                 }
[16:20:35.889]                 ...future.workdir <- getwd()
[16:20:35.889]             }
[16:20:35.889]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.889]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.889]         }
[16:20:35.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.889]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.889]             base::names(...future.oldOptions))
[16:20:35.889]     }
[16:20:35.889]     if (FALSE) {
[16:20:35.889]     }
[16:20:35.889]     else {
[16:20:35.889]         if (TRUE) {
[16:20:35.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.889]                 open = "w")
[16:20:35.889]         }
[16:20:35.889]         else {
[16:20:35.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.889]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.889]         }
[16:20:35.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.889]             base::sink(type = "output", split = FALSE)
[16:20:35.889]             base::close(...future.stdout)
[16:20:35.889]         }, add = TRUE)
[16:20:35.889]     }
[16:20:35.889]     ...future.frame <- base::sys.nframe()
[16:20:35.889]     ...future.conditions <- base::list()
[16:20:35.889]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.889]     if (FALSE) {
[16:20:35.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.889]     }
[16:20:35.889]     ...future.result <- base::tryCatch({
[16:20:35.889]         base::withCallingHandlers({
[16:20:35.889]             ...future.value <- base::withVisible(base::local({
[16:20:35.889]                 ...future.makeSendCondition <- base::local({
[16:20:35.889]                   sendCondition <- NULL
[16:20:35.889]                   function(frame = 1L) {
[16:20:35.889]                     if (is.function(sendCondition)) 
[16:20:35.889]                       return(sendCondition)
[16:20:35.889]                     ns <- getNamespace("parallel")
[16:20:35.889]                     if (exists("sendData", mode = "function", 
[16:20:35.889]                       envir = ns)) {
[16:20:35.889]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:35.889]                         envir = ns)
[16:20:35.889]                       envir <- sys.frame(frame)
[16:20:35.889]                       master <- NULL
[16:20:35.889]                       while (!identical(envir, .GlobalEnv) && 
[16:20:35.889]                         !identical(envir, emptyenv())) {
[16:20:35.889]                         if (exists("master", mode = "list", envir = envir, 
[16:20:35.889]                           inherits = FALSE)) {
[16:20:35.889]                           master <- get("master", mode = "list", 
[16:20:35.889]                             envir = envir, inherits = FALSE)
[16:20:35.889]                           if (inherits(master, c("SOCKnode", 
[16:20:35.889]                             "SOCK0node"))) {
[16:20:35.889]                             sendCondition <<- function(cond) {
[16:20:35.889]                               data <- list(type = "VALUE", value = cond, 
[16:20:35.889]                                 success = TRUE)
[16:20:35.889]                               parallel_sendData(master, data)
[16:20:35.889]                             }
[16:20:35.889]                             return(sendCondition)
[16:20:35.889]                           }
[16:20:35.889]                         }
[16:20:35.889]                         frame <- frame + 1L
[16:20:35.889]                         envir <- sys.frame(frame)
[16:20:35.889]                       }
[16:20:35.889]                     }
[16:20:35.889]                     sendCondition <<- function(cond) NULL
[16:20:35.889]                   }
[16:20:35.889]                 })
[16:20:35.889]                 withCallingHandlers({
[16:20:35.889]                   {
[16:20:35.889]                     2
[16:20:35.889]                   }
[16:20:35.889]                 }, immediateCondition = function(cond) {
[16:20:35.889]                   sendCondition <- ...future.makeSendCondition()
[16:20:35.889]                   sendCondition(cond)
[16:20:35.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.889]                   {
[16:20:35.889]                     inherits <- base::inherits
[16:20:35.889]                     invokeRestart <- base::invokeRestart
[16:20:35.889]                     is.null <- base::is.null
[16:20:35.889]                     muffled <- FALSE
[16:20:35.889]                     if (inherits(cond, "message")) {
[16:20:35.889]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.889]                       if (muffled) 
[16:20:35.889]                         invokeRestart("muffleMessage")
[16:20:35.889]                     }
[16:20:35.889]                     else if (inherits(cond, "warning")) {
[16:20:35.889]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.889]                       if (muffled) 
[16:20:35.889]                         invokeRestart("muffleWarning")
[16:20:35.889]                     }
[16:20:35.889]                     else if (inherits(cond, "condition")) {
[16:20:35.889]                       if (!is.null(pattern)) {
[16:20:35.889]                         computeRestarts <- base::computeRestarts
[16:20:35.889]                         grepl <- base::grepl
[16:20:35.889]                         restarts <- computeRestarts(cond)
[16:20:35.889]                         for (restart in restarts) {
[16:20:35.889]                           name <- restart$name
[16:20:35.889]                           if (is.null(name)) 
[16:20:35.889]                             next
[16:20:35.889]                           if (!grepl(pattern, name)) 
[16:20:35.889]                             next
[16:20:35.889]                           invokeRestart(restart)
[16:20:35.889]                           muffled <- TRUE
[16:20:35.889]                           break
[16:20:35.889]                         }
[16:20:35.889]                       }
[16:20:35.889]                     }
[16:20:35.889]                     invisible(muffled)
[16:20:35.889]                   }
[16:20:35.889]                   muffleCondition(cond)
[16:20:35.889]                 })
[16:20:35.889]             }))
[16:20:35.889]             future::FutureResult(value = ...future.value$value, 
[16:20:35.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.889]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.889]                     ...future.globalenv.names))
[16:20:35.889]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.889]         }, condition = base::local({
[16:20:35.889]             c <- base::c
[16:20:35.889]             inherits <- base::inherits
[16:20:35.889]             invokeRestart <- base::invokeRestart
[16:20:35.889]             length <- base::length
[16:20:35.889]             list <- base::list
[16:20:35.889]             seq.int <- base::seq.int
[16:20:35.889]             signalCondition <- base::signalCondition
[16:20:35.889]             sys.calls <- base::sys.calls
[16:20:35.889]             `[[` <- base::`[[`
[16:20:35.889]             `+` <- base::`+`
[16:20:35.889]             `<<-` <- base::`<<-`
[16:20:35.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.889]                   3L)]
[16:20:35.889]             }
[16:20:35.889]             function(cond) {
[16:20:35.889]                 is_error <- inherits(cond, "error")
[16:20:35.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.889]                   NULL)
[16:20:35.889]                 if (is_error) {
[16:20:35.889]                   sessionInformation <- function() {
[16:20:35.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.889]                       search = base::search(), system = base::Sys.info())
[16:20:35.889]                   }
[16:20:35.889]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.889]                     cond$call), session = sessionInformation(), 
[16:20:35.889]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.889]                   signalCondition(cond)
[16:20:35.889]                 }
[16:20:35.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.889]                 "immediateCondition"))) {
[16:20:35.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.889]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.889]                   if (TRUE && !signal) {
[16:20:35.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.889]                     {
[16:20:35.889]                       inherits <- base::inherits
[16:20:35.889]                       invokeRestart <- base::invokeRestart
[16:20:35.889]                       is.null <- base::is.null
[16:20:35.889]                       muffled <- FALSE
[16:20:35.889]                       if (inherits(cond, "message")) {
[16:20:35.889]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.889]                         if (muffled) 
[16:20:35.889]                           invokeRestart("muffleMessage")
[16:20:35.889]                       }
[16:20:35.889]                       else if (inherits(cond, "warning")) {
[16:20:35.889]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.889]                         if (muffled) 
[16:20:35.889]                           invokeRestart("muffleWarning")
[16:20:35.889]                       }
[16:20:35.889]                       else if (inherits(cond, "condition")) {
[16:20:35.889]                         if (!is.null(pattern)) {
[16:20:35.889]                           computeRestarts <- base::computeRestarts
[16:20:35.889]                           grepl <- base::grepl
[16:20:35.889]                           restarts <- computeRestarts(cond)
[16:20:35.889]                           for (restart in restarts) {
[16:20:35.889]                             name <- restart$name
[16:20:35.889]                             if (is.null(name)) 
[16:20:35.889]                               next
[16:20:35.889]                             if (!grepl(pattern, name)) 
[16:20:35.889]                               next
[16:20:35.889]                             invokeRestart(restart)
[16:20:35.889]                             muffled <- TRUE
[16:20:35.889]                             break
[16:20:35.889]                           }
[16:20:35.889]                         }
[16:20:35.889]                       }
[16:20:35.889]                       invisible(muffled)
[16:20:35.889]                     }
[16:20:35.889]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.889]                   }
[16:20:35.889]                 }
[16:20:35.889]                 else {
[16:20:35.889]                   if (TRUE) {
[16:20:35.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.889]                     {
[16:20:35.889]                       inherits <- base::inherits
[16:20:35.889]                       invokeRestart <- base::invokeRestart
[16:20:35.889]                       is.null <- base::is.null
[16:20:35.889]                       muffled <- FALSE
[16:20:35.889]                       if (inherits(cond, "message")) {
[16:20:35.889]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.889]                         if (muffled) 
[16:20:35.889]                           invokeRestart("muffleMessage")
[16:20:35.889]                       }
[16:20:35.889]                       else if (inherits(cond, "warning")) {
[16:20:35.889]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.889]                         if (muffled) 
[16:20:35.889]                           invokeRestart("muffleWarning")
[16:20:35.889]                       }
[16:20:35.889]                       else if (inherits(cond, "condition")) {
[16:20:35.889]                         if (!is.null(pattern)) {
[16:20:35.889]                           computeRestarts <- base::computeRestarts
[16:20:35.889]                           grepl <- base::grepl
[16:20:35.889]                           restarts <- computeRestarts(cond)
[16:20:35.889]                           for (restart in restarts) {
[16:20:35.889]                             name <- restart$name
[16:20:35.889]                             if (is.null(name)) 
[16:20:35.889]                               next
[16:20:35.889]                             if (!grepl(pattern, name)) 
[16:20:35.889]                               next
[16:20:35.889]                             invokeRestart(restart)
[16:20:35.889]                             muffled <- TRUE
[16:20:35.889]                             break
[16:20:35.889]                           }
[16:20:35.889]                         }
[16:20:35.889]                       }
[16:20:35.889]                       invisible(muffled)
[16:20:35.889]                     }
[16:20:35.889]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.889]                   }
[16:20:35.889]                 }
[16:20:35.889]             }
[16:20:35.889]         }))
[16:20:35.889]     }, error = function(ex) {
[16:20:35.889]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.889]                 ...future.rng), started = ...future.startTime, 
[16:20:35.889]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.889]             version = "1.8"), class = "FutureResult")
[16:20:35.889]     }, finally = {
[16:20:35.889]         if (!identical(...future.workdir, getwd())) 
[16:20:35.889]             setwd(...future.workdir)
[16:20:35.889]         {
[16:20:35.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.889]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.889]             }
[16:20:35.889]             base::options(...future.oldOptions)
[16:20:35.889]             if (.Platform$OS.type == "windows") {
[16:20:35.889]                 old_names <- names(...future.oldEnvVars)
[16:20:35.889]                 envs <- base::Sys.getenv()
[16:20:35.889]                 names <- names(envs)
[16:20:35.889]                 common <- intersect(names, old_names)
[16:20:35.889]                 added <- setdiff(names, old_names)
[16:20:35.889]                 removed <- setdiff(old_names, names)
[16:20:35.889]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.889]                   envs[common]]
[16:20:35.889]                 NAMES <- toupper(changed)
[16:20:35.889]                 args <- list()
[16:20:35.889]                 for (kk in seq_along(NAMES)) {
[16:20:35.889]                   name <- changed[[kk]]
[16:20:35.889]                   NAME <- NAMES[[kk]]
[16:20:35.889]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.889]                     next
[16:20:35.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.889]                 }
[16:20:35.889]                 NAMES <- toupper(added)
[16:20:35.889]                 for (kk in seq_along(NAMES)) {
[16:20:35.889]                   name <- added[[kk]]
[16:20:35.889]                   NAME <- NAMES[[kk]]
[16:20:35.889]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.889]                     next
[16:20:35.889]                   args[[name]] <- ""
[16:20:35.889]                 }
[16:20:35.889]                 NAMES <- toupper(removed)
[16:20:35.889]                 for (kk in seq_along(NAMES)) {
[16:20:35.889]                   name <- removed[[kk]]
[16:20:35.889]                   NAME <- NAMES[[kk]]
[16:20:35.889]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.889]                     next
[16:20:35.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.889]                 }
[16:20:35.889]                 if (length(args) > 0) 
[16:20:35.889]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.889]             }
[16:20:35.889]             else {
[16:20:35.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.889]             }
[16:20:35.889]             {
[16:20:35.889]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.889]                   0L) {
[16:20:35.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.889]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.889]                   base::options(opts)
[16:20:35.889]                 }
[16:20:35.889]                 {
[16:20:35.889]                   {
[16:20:35.889]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.889]                     NULL
[16:20:35.889]                   }
[16:20:35.889]                   options(future.plan = NULL)
[16:20:35.889]                   if (is.na(NA_character_)) 
[16:20:35.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.889]                     .init = FALSE)
[16:20:35.889]                 }
[16:20:35.889]             }
[16:20:35.889]         }
[16:20:35.889]     })
[16:20:35.889]     if (TRUE) {
[16:20:35.889]         base::sink(type = "output", split = FALSE)
[16:20:35.889]         if (TRUE) {
[16:20:35.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.889]         }
[16:20:35.889]         else {
[16:20:35.889]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.889]         }
[16:20:35.889]         base::close(...future.stdout)
[16:20:35.889]         ...future.stdout <- NULL
[16:20:35.889]     }
[16:20:35.889]     ...future.result$conditions <- ...future.conditions
[16:20:35.889]     ...future.result$finished <- base::Sys.time()
[16:20:35.889]     ...future.result
[16:20:35.889] }
[16:20:35.893] MultisessionFuture started
[16:20:35.893] - Launch lazy future ... done
[16:20:35.893] run() for ‘MultisessionFuture’ ... done
[16:20:35.893] getGlobalsAndPackages() ...
[16:20:35.893] Searching for globals...
[16:20:35.894] - globals found: [1] ‘{’
[16:20:35.894] Searching for globals ... DONE
[16:20:35.894] Resolving globals: FALSE
[16:20:35.895] 
[16:20:35.895] 
[16:20:35.895] getGlobalsAndPackages() ... DONE
[16:20:35.895] run() for ‘Future’ ...
[16:20:35.895] - state: ‘created’
[16:20:35.895] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:35.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:35.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:35.910]   - Field: ‘node’
[16:20:35.910]   - Field: ‘label’
[16:20:35.910]   - Field: ‘local’
[16:20:35.910]   - Field: ‘owner’
[16:20:35.910]   - Field: ‘envir’
[16:20:35.910]   - Field: ‘workers’
[16:20:35.910]   - Field: ‘packages’
[16:20:35.910]   - Field: ‘gc’
[16:20:35.911]   - Field: ‘conditions’
[16:20:35.911]   - Field: ‘persistent’
[16:20:35.911]   - Field: ‘expr’
[16:20:35.911]   - Field: ‘uuid’
[16:20:35.911]   - Field: ‘seed’
[16:20:35.911]   - Field: ‘version’
[16:20:35.911]   - Field: ‘result’
[16:20:35.911]   - Field: ‘asynchronous’
[16:20:35.911]   - Field: ‘calls’
[16:20:35.912]   - Field: ‘globals’
[16:20:35.912]   - Field: ‘stdout’
[16:20:35.912]   - Field: ‘earlySignal’
[16:20:35.912]   - Field: ‘lazy’
[16:20:35.912]   - Field: ‘state’
[16:20:35.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:35.912] - Launch lazy future ...
[16:20:35.913] Packages needed by the future expression (n = 0): <none>
[16:20:35.913] Packages needed by future strategies (n = 0): <none>
[16:20:35.913] {
[16:20:35.913]     {
[16:20:35.913]         {
[16:20:35.913]             ...future.startTime <- base::Sys.time()
[16:20:35.913]             {
[16:20:35.913]                 {
[16:20:35.913]                   {
[16:20:35.913]                     {
[16:20:35.913]                       base::local({
[16:20:35.913]                         has_future <- base::requireNamespace("future", 
[16:20:35.913]                           quietly = TRUE)
[16:20:35.913]                         if (has_future) {
[16:20:35.913]                           ns <- base::getNamespace("future")
[16:20:35.913]                           version <- ns[[".package"]][["version"]]
[16:20:35.913]                           if (is.null(version)) 
[16:20:35.913]                             version <- utils::packageVersion("future")
[16:20:35.913]                         }
[16:20:35.913]                         else {
[16:20:35.913]                           version <- NULL
[16:20:35.913]                         }
[16:20:35.913]                         if (!has_future || version < "1.8.0") {
[16:20:35.913]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:35.913]                             "", base::R.version$version.string), 
[16:20:35.913]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:35.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:35.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:35.913]                               "release", "version")], collapse = " "), 
[16:20:35.913]                             hostname = base::Sys.info()[["nodename"]])
[16:20:35.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:35.913]                             info)
[16:20:35.913]                           info <- base::paste(info, collapse = "; ")
[16:20:35.913]                           if (!has_future) {
[16:20:35.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:35.913]                               info)
[16:20:35.913]                           }
[16:20:35.913]                           else {
[16:20:35.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:35.913]                               info, version)
[16:20:35.913]                           }
[16:20:35.913]                           base::stop(msg)
[16:20:35.913]                         }
[16:20:35.913]                       })
[16:20:35.913]                     }
[16:20:35.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:35.913]                     base::options(mc.cores = 1L)
[16:20:35.913]                   }
[16:20:35.913]                   ...future.strategy.old <- future::plan("list")
[16:20:35.913]                   options(future.plan = NULL)
[16:20:35.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:35.913]                 }
[16:20:35.913]                 ...future.workdir <- getwd()
[16:20:35.913]             }
[16:20:35.913]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:35.913]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:35.913]         }
[16:20:35.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:35.913]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:35.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:35.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:35.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:35.913]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:35.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:35.913]             base::names(...future.oldOptions))
[16:20:35.913]     }
[16:20:35.913]     if (FALSE) {
[16:20:35.913]     }
[16:20:35.913]     else {
[16:20:35.913]         if (TRUE) {
[16:20:35.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:35.913]                 open = "w")
[16:20:35.913]         }
[16:20:35.913]         else {
[16:20:35.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:35.913]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:35.913]         }
[16:20:35.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:35.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:35.913]             base::sink(type = "output", split = FALSE)
[16:20:35.913]             base::close(...future.stdout)
[16:20:35.913]         }, add = TRUE)
[16:20:35.913]     }
[16:20:35.913]     ...future.frame <- base::sys.nframe()
[16:20:35.913]     ...future.conditions <- base::list()
[16:20:35.913]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:35.913]     if (FALSE) {
[16:20:35.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:35.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:35.913]     }
[16:20:35.913]     ...future.result <- base::tryCatch({
[16:20:35.913]         base::withCallingHandlers({
[16:20:35.913]             ...future.value <- base::withVisible(base::local({
[16:20:35.913]                 ...future.makeSendCondition <- base::local({
[16:20:35.913]                   sendCondition <- NULL
[16:20:35.913]                   function(frame = 1L) {
[16:20:35.913]                     if (is.function(sendCondition)) 
[16:20:35.913]                       return(sendCondition)
[16:20:35.913]                     ns <- getNamespace("parallel")
[16:20:35.913]                     if (exists("sendData", mode = "function", 
[16:20:35.913]                       envir = ns)) {
[16:20:35.913]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:35.913]                         envir = ns)
[16:20:35.913]                       envir <- sys.frame(frame)
[16:20:35.913]                       master <- NULL
[16:20:35.913]                       while (!identical(envir, .GlobalEnv) && 
[16:20:35.913]                         !identical(envir, emptyenv())) {
[16:20:35.913]                         if (exists("master", mode = "list", envir = envir, 
[16:20:35.913]                           inherits = FALSE)) {
[16:20:35.913]                           master <- get("master", mode = "list", 
[16:20:35.913]                             envir = envir, inherits = FALSE)
[16:20:35.913]                           if (inherits(master, c("SOCKnode", 
[16:20:35.913]                             "SOCK0node"))) {
[16:20:35.913]                             sendCondition <<- function(cond) {
[16:20:35.913]                               data <- list(type = "VALUE", value = cond, 
[16:20:35.913]                                 success = TRUE)
[16:20:35.913]                               parallel_sendData(master, data)
[16:20:35.913]                             }
[16:20:35.913]                             return(sendCondition)
[16:20:35.913]                           }
[16:20:35.913]                         }
[16:20:35.913]                         frame <- frame + 1L
[16:20:35.913]                         envir <- sys.frame(frame)
[16:20:35.913]                       }
[16:20:35.913]                     }
[16:20:35.913]                     sendCondition <<- function(cond) NULL
[16:20:35.913]                   }
[16:20:35.913]                 })
[16:20:35.913]                 withCallingHandlers({
[16:20:35.913]                   {
[16:20:35.913]                     4
[16:20:35.913]                   }
[16:20:35.913]                 }, immediateCondition = function(cond) {
[16:20:35.913]                   sendCondition <- ...future.makeSendCondition()
[16:20:35.913]                   sendCondition(cond)
[16:20:35.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.913]                   {
[16:20:35.913]                     inherits <- base::inherits
[16:20:35.913]                     invokeRestart <- base::invokeRestart
[16:20:35.913]                     is.null <- base::is.null
[16:20:35.913]                     muffled <- FALSE
[16:20:35.913]                     if (inherits(cond, "message")) {
[16:20:35.913]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:35.913]                       if (muffled) 
[16:20:35.913]                         invokeRestart("muffleMessage")
[16:20:35.913]                     }
[16:20:35.913]                     else if (inherits(cond, "warning")) {
[16:20:35.913]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:35.913]                       if (muffled) 
[16:20:35.913]                         invokeRestart("muffleWarning")
[16:20:35.913]                     }
[16:20:35.913]                     else if (inherits(cond, "condition")) {
[16:20:35.913]                       if (!is.null(pattern)) {
[16:20:35.913]                         computeRestarts <- base::computeRestarts
[16:20:35.913]                         grepl <- base::grepl
[16:20:35.913]                         restarts <- computeRestarts(cond)
[16:20:35.913]                         for (restart in restarts) {
[16:20:35.913]                           name <- restart$name
[16:20:35.913]                           if (is.null(name)) 
[16:20:35.913]                             next
[16:20:35.913]                           if (!grepl(pattern, name)) 
[16:20:35.913]                             next
[16:20:35.913]                           invokeRestart(restart)
[16:20:35.913]                           muffled <- TRUE
[16:20:35.913]                           break
[16:20:35.913]                         }
[16:20:35.913]                       }
[16:20:35.913]                     }
[16:20:35.913]                     invisible(muffled)
[16:20:35.913]                   }
[16:20:35.913]                   muffleCondition(cond)
[16:20:35.913]                 })
[16:20:35.913]             }))
[16:20:35.913]             future::FutureResult(value = ...future.value$value, 
[16:20:35.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.913]                   ...future.rng), globalenv = if (FALSE) 
[16:20:35.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:35.913]                     ...future.globalenv.names))
[16:20:35.913]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:35.913]         }, condition = base::local({
[16:20:35.913]             c <- base::c
[16:20:35.913]             inherits <- base::inherits
[16:20:35.913]             invokeRestart <- base::invokeRestart
[16:20:35.913]             length <- base::length
[16:20:35.913]             list <- base::list
[16:20:35.913]             seq.int <- base::seq.int
[16:20:35.913]             signalCondition <- base::signalCondition
[16:20:35.913]             sys.calls <- base::sys.calls
[16:20:35.913]             `[[` <- base::`[[`
[16:20:35.913]             `+` <- base::`+`
[16:20:35.913]             `<<-` <- base::`<<-`
[16:20:35.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:35.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:35.913]                   3L)]
[16:20:35.913]             }
[16:20:35.913]             function(cond) {
[16:20:35.913]                 is_error <- inherits(cond, "error")
[16:20:35.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:35.913]                   NULL)
[16:20:35.913]                 if (is_error) {
[16:20:35.913]                   sessionInformation <- function() {
[16:20:35.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:35.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:35.913]                       search = base::search(), system = base::Sys.info())
[16:20:35.913]                   }
[16:20:35.913]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:35.913]                     cond$call), session = sessionInformation(), 
[16:20:35.913]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:35.913]                   signalCondition(cond)
[16:20:35.913]                 }
[16:20:35.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:35.913]                 "immediateCondition"))) {
[16:20:35.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:35.913]                   ...future.conditions[[length(...future.conditions) + 
[16:20:35.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:35.913]                   if (TRUE && !signal) {
[16:20:35.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.913]                     {
[16:20:35.913]                       inherits <- base::inherits
[16:20:35.913]                       invokeRestart <- base::invokeRestart
[16:20:35.913]                       is.null <- base::is.null
[16:20:35.913]                       muffled <- FALSE
[16:20:35.913]                       if (inherits(cond, "message")) {
[16:20:35.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.913]                         if (muffled) 
[16:20:35.913]                           invokeRestart("muffleMessage")
[16:20:35.913]                       }
[16:20:35.913]                       else if (inherits(cond, "warning")) {
[16:20:35.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.913]                         if (muffled) 
[16:20:35.913]                           invokeRestart("muffleWarning")
[16:20:35.913]                       }
[16:20:35.913]                       else if (inherits(cond, "condition")) {
[16:20:35.913]                         if (!is.null(pattern)) {
[16:20:35.913]                           computeRestarts <- base::computeRestarts
[16:20:35.913]                           grepl <- base::grepl
[16:20:35.913]                           restarts <- computeRestarts(cond)
[16:20:35.913]                           for (restart in restarts) {
[16:20:35.913]                             name <- restart$name
[16:20:35.913]                             if (is.null(name)) 
[16:20:35.913]                               next
[16:20:35.913]                             if (!grepl(pattern, name)) 
[16:20:35.913]                               next
[16:20:35.913]                             invokeRestart(restart)
[16:20:35.913]                             muffled <- TRUE
[16:20:35.913]                             break
[16:20:35.913]                           }
[16:20:35.913]                         }
[16:20:35.913]                       }
[16:20:35.913]                       invisible(muffled)
[16:20:35.913]                     }
[16:20:35.913]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.913]                   }
[16:20:35.913]                 }
[16:20:35.913]                 else {
[16:20:35.913]                   if (TRUE) {
[16:20:35.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:35.913]                     {
[16:20:35.913]                       inherits <- base::inherits
[16:20:35.913]                       invokeRestart <- base::invokeRestart
[16:20:35.913]                       is.null <- base::is.null
[16:20:35.913]                       muffled <- FALSE
[16:20:35.913]                       if (inherits(cond, "message")) {
[16:20:35.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:35.913]                         if (muffled) 
[16:20:35.913]                           invokeRestart("muffleMessage")
[16:20:35.913]                       }
[16:20:35.913]                       else if (inherits(cond, "warning")) {
[16:20:35.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:35.913]                         if (muffled) 
[16:20:35.913]                           invokeRestart("muffleWarning")
[16:20:35.913]                       }
[16:20:35.913]                       else if (inherits(cond, "condition")) {
[16:20:35.913]                         if (!is.null(pattern)) {
[16:20:35.913]                           computeRestarts <- base::computeRestarts
[16:20:35.913]                           grepl <- base::grepl
[16:20:35.913]                           restarts <- computeRestarts(cond)
[16:20:35.913]                           for (restart in restarts) {
[16:20:35.913]                             name <- restart$name
[16:20:35.913]                             if (is.null(name)) 
[16:20:35.913]                               next
[16:20:35.913]                             if (!grepl(pattern, name)) 
[16:20:35.913]                               next
[16:20:35.913]                             invokeRestart(restart)
[16:20:35.913]                             muffled <- TRUE
[16:20:35.913]                             break
[16:20:35.913]                           }
[16:20:35.913]                         }
[16:20:35.913]                       }
[16:20:35.913]                       invisible(muffled)
[16:20:35.913]                     }
[16:20:35.913]                     muffleCondition(cond, pattern = "^muffle")
[16:20:35.913]                   }
[16:20:35.913]                 }
[16:20:35.913]             }
[16:20:35.913]         }))
[16:20:35.913]     }, error = function(ex) {
[16:20:35.913]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:35.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:35.913]                 ...future.rng), started = ...future.startTime, 
[16:20:35.913]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:35.913]             version = "1.8"), class = "FutureResult")
[16:20:35.913]     }, finally = {
[16:20:35.913]         if (!identical(...future.workdir, getwd())) 
[16:20:35.913]             setwd(...future.workdir)
[16:20:35.913]         {
[16:20:35.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:35.913]                 ...future.oldOptions$nwarnings <- NULL
[16:20:35.913]             }
[16:20:35.913]             base::options(...future.oldOptions)
[16:20:35.913]             if (.Platform$OS.type == "windows") {
[16:20:35.913]                 old_names <- names(...future.oldEnvVars)
[16:20:35.913]                 envs <- base::Sys.getenv()
[16:20:35.913]                 names <- names(envs)
[16:20:35.913]                 common <- intersect(names, old_names)
[16:20:35.913]                 added <- setdiff(names, old_names)
[16:20:35.913]                 removed <- setdiff(old_names, names)
[16:20:35.913]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:35.913]                   envs[common]]
[16:20:35.913]                 NAMES <- toupper(changed)
[16:20:35.913]                 args <- list()
[16:20:35.913]                 for (kk in seq_along(NAMES)) {
[16:20:35.913]                   name <- changed[[kk]]
[16:20:35.913]                   NAME <- NAMES[[kk]]
[16:20:35.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.913]                     next
[16:20:35.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.913]                 }
[16:20:35.913]                 NAMES <- toupper(added)
[16:20:35.913]                 for (kk in seq_along(NAMES)) {
[16:20:35.913]                   name <- added[[kk]]
[16:20:35.913]                   NAME <- NAMES[[kk]]
[16:20:35.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.913]                     next
[16:20:35.913]                   args[[name]] <- ""
[16:20:35.913]                 }
[16:20:35.913]                 NAMES <- toupper(removed)
[16:20:35.913]                 for (kk in seq_along(NAMES)) {
[16:20:35.913]                   name <- removed[[kk]]
[16:20:35.913]                   NAME <- NAMES[[kk]]
[16:20:35.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:35.913]                     next
[16:20:35.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:35.913]                 }
[16:20:35.913]                 if (length(args) > 0) 
[16:20:35.913]                   base::do.call(base::Sys.setenv, args = args)
[16:20:35.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:35.913]             }
[16:20:35.913]             else {
[16:20:35.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:35.913]             }
[16:20:35.913]             {
[16:20:35.913]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:35.913]                   0L) {
[16:20:35.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:35.913]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:35.913]                   base::options(opts)
[16:20:35.913]                 }
[16:20:35.913]                 {
[16:20:35.913]                   {
[16:20:35.913]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:35.913]                     NULL
[16:20:35.913]                   }
[16:20:35.913]                   options(future.plan = NULL)
[16:20:35.913]                   if (is.na(NA_character_)) 
[16:20:35.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:35.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:35.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:35.913]                     .init = FALSE)
[16:20:35.913]                 }
[16:20:35.913]             }
[16:20:35.913]         }
[16:20:35.913]     })
[16:20:35.913]     if (TRUE) {
[16:20:35.913]         base::sink(type = "output", split = FALSE)
[16:20:35.913]         if (TRUE) {
[16:20:35.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:35.913]         }
[16:20:35.913]         else {
[16:20:35.913]             ...future.result["stdout"] <- base::list(NULL)
[16:20:35.913]         }
[16:20:35.913]         base::close(...future.stdout)
[16:20:35.913]         ...future.stdout <- NULL
[16:20:35.913]     }
[16:20:35.913]     ...future.result$conditions <- ...future.conditions
[16:20:35.913]     ...future.result$finished <- base::Sys.time()
[16:20:35.913]     ...future.result
[16:20:35.913] }
[16:20:35.967] MultisessionFuture started
[16:20:35.967] - Launch lazy future ... done
[16:20:35.967] run() for ‘MultisessionFuture’ ... done
[16:20:35.968] result() for ClusterFuture ...
[16:20:35.968] receiveMessageFromWorker() for ClusterFuture ...
[16:20:35.968] - Validating connection of MultisessionFuture
[16:20:35.968] - received message: FutureResult
[16:20:35.969] - Received FutureResult
[16:20:35.969] - Erased future from FutureRegistry
[16:20:35.969] result() for ClusterFuture ...
[16:20:35.969] - result already collected: FutureResult
[16:20:35.969] result() for ClusterFuture ... done
[16:20:35.969] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:35.970] result() for ClusterFuture ... done
[16:20:35.970] result() for ClusterFuture ...
[16:20:35.970] - result already collected: FutureResult
[16:20:35.970] result() for ClusterFuture ... done
u$a = 2
[16:20:35.971] result() for ClusterFuture ...
[16:20:35.971] receiveMessageFromWorker() for ClusterFuture ...
[16:20:35.971] - Validating connection of MultisessionFuture
[16:20:36.002] - received message: FutureResult
[16:20:36.002] - Received FutureResult
[16:20:36.002] - Erased future from FutureRegistry
[16:20:36.002] result() for ClusterFuture ...
[16:20:36.003] - result already collected: FutureResult
[16:20:36.003] result() for ClusterFuture ... done
[16:20:36.003] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:36.003] result() for ClusterFuture ... done
[16:20:36.003] result() for ClusterFuture ...
[16:20:36.003] - result already collected: FutureResult
[16:20:36.003] result() for ClusterFuture ... done
v$a = 4
[16:20:36.004] getGlobalsAndPackages() ...
[16:20:36.004] Searching for globals...
[16:20:36.005] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:36.005] Searching for globals ... DONE
[16:20:36.005] Resolving globals: FALSE
[16:20:36.006] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:36.006] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:36.006] - globals: [1] ‘a’
[16:20:36.006] 
[16:20:36.006] getGlobalsAndPackages() ... DONE
[16:20:36.007] run() for ‘Future’ ...
[16:20:36.007] - state: ‘created’
[16:20:36.007] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:36.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:36.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:36.022]   - Field: ‘node’
[16:20:36.022]   - Field: ‘label’
[16:20:36.023]   - Field: ‘local’
[16:20:36.023]   - Field: ‘owner’
[16:20:36.023]   - Field: ‘envir’
[16:20:36.023]   - Field: ‘workers’
[16:20:36.023]   - Field: ‘packages’
[16:20:36.023]   - Field: ‘gc’
[16:20:36.023]   - Field: ‘conditions’
[16:20:36.023]   - Field: ‘persistent’
[16:20:36.023]   - Field: ‘expr’
[16:20:36.024]   - Field: ‘uuid’
[16:20:36.024]   - Field: ‘seed’
[16:20:36.024]   - Field: ‘version’
[16:20:36.024]   - Field: ‘result’
[16:20:36.024]   - Field: ‘asynchronous’
[16:20:36.024]   - Field: ‘calls’
[16:20:36.024]   - Field: ‘globals’
[16:20:36.024]   - Field: ‘stdout’
[16:20:36.024]   - Field: ‘earlySignal’
[16:20:36.025]   - Field: ‘lazy’
[16:20:36.025]   - Field: ‘state’
[16:20:36.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:36.025] - Launch lazy future ...
[16:20:36.025] Packages needed by the future expression (n = 0): <none>
[16:20:36.025] Packages needed by future strategies (n = 0): <none>
[16:20:36.026] {
[16:20:36.026]     {
[16:20:36.026]         {
[16:20:36.026]             ...future.startTime <- base::Sys.time()
[16:20:36.026]             {
[16:20:36.026]                 {
[16:20:36.026]                   {
[16:20:36.026]                     {
[16:20:36.026]                       base::local({
[16:20:36.026]                         has_future <- base::requireNamespace("future", 
[16:20:36.026]                           quietly = TRUE)
[16:20:36.026]                         if (has_future) {
[16:20:36.026]                           ns <- base::getNamespace("future")
[16:20:36.026]                           version <- ns[[".package"]][["version"]]
[16:20:36.026]                           if (is.null(version)) 
[16:20:36.026]                             version <- utils::packageVersion("future")
[16:20:36.026]                         }
[16:20:36.026]                         else {
[16:20:36.026]                           version <- NULL
[16:20:36.026]                         }
[16:20:36.026]                         if (!has_future || version < "1.8.0") {
[16:20:36.026]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:36.026]                             "", base::R.version$version.string), 
[16:20:36.026]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:36.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:36.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:36.026]                               "release", "version")], collapse = " "), 
[16:20:36.026]                             hostname = base::Sys.info()[["nodename"]])
[16:20:36.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:36.026]                             info)
[16:20:36.026]                           info <- base::paste(info, collapse = "; ")
[16:20:36.026]                           if (!has_future) {
[16:20:36.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:36.026]                               info)
[16:20:36.026]                           }
[16:20:36.026]                           else {
[16:20:36.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:36.026]                               info, version)
[16:20:36.026]                           }
[16:20:36.026]                           base::stop(msg)
[16:20:36.026]                         }
[16:20:36.026]                       })
[16:20:36.026]                     }
[16:20:36.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:36.026]                     base::options(mc.cores = 1L)
[16:20:36.026]                   }
[16:20:36.026]                   ...future.strategy.old <- future::plan("list")
[16:20:36.026]                   options(future.plan = NULL)
[16:20:36.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:36.026]                 }
[16:20:36.026]                 ...future.workdir <- getwd()
[16:20:36.026]             }
[16:20:36.026]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:36.026]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:36.026]         }
[16:20:36.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:36.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:36.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:36.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:36.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:36.026]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:36.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:36.026]             base::names(...future.oldOptions))
[16:20:36.026]     }
[16:20:36.026]     if (FALSE) {
[16:20:36.026]     }
[16:20:36.026]     else {
[16:20:36.026]         if (TRUE) {
[16:20:36.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:36.026]                 open = "w")
[16:20:36.026]         }
[16:20:36.026]         else {
[16:20:36.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:36.026]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:36.026]         }
[16:20:36.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:36.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:36.026]             base::sink(type = "output", split = FALSE)
[16:20:36.026]             base::close(...future.stdout)
[16:20:36.026]         }, add = TRUE)
[16:20:36.026]     }
[16:20:36.026]     ...future.frame <- base::sys.nframe()
[16:20:36.026]     ...future.conditions <- base::list()
[16:20:36.026]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:36.026]     if (FALSE) {
[16:20:36.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:36.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:36.026]     }
[16:20:36.026]     ...future.result <- base::tryCatch({
[16:20:36.026]         base::withCallingHandlers({
[16:20:36.026]             ...future.value <- base::withVisible(base::local({
[16:20:36.026]                 ...future.makeSendCondition <- base::local({
[16:20:36.026]                   sendCondition <- NULL
[16:20:36.026]                   function(frame = 1L) {
[16:20:36.026]                     if (is.function(sendCondition)) 
[16:20:36.026]                       return(sendCondition)
[16:20:36.026]                     ns <- getNamespace("parallel")
[16:20:36.026]                     if (exists("sendData", mode = "function", 
[16:20:36.026]                       envir = ns)) {
[16:20:36.026]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:36.026]                         envir = ns)
[16:20:36.026]                       envir <- sys.frame(frame)
[16:20:36.026]                       master <- NULL
[16:20:36.026]                       while (!identical(envir, .GlobalEnv) && 
[16:20:36.026]                         !identical(envir, emptyenv())) {
[16:20:36.026]                         if (exists("master", mode = "list", envir = envir, 
[16:20:36.026]                           inherits = FALSE)) {
[16:20:36.026]                           master <- get("master", mode = "list", 
[16:20:36.026]                             envir = envir, inherits = FALSE)
[16:20:36.026]                           if (inherits(master, c("SOCKnode", 
[16:20:36.026]                             "SOCK0node"))) {
[16:20:36.026]                             sendCondition <<- function(cond) {
[16:20:36.026]                               data <- list(type = "VALUE", value = cond, 
[16:20:36.026]                                 success = TRUE)
[16:20:36.026]                               parallel_sendData(master, data)
[16:20:36.026]                             }
[16:20:36.026]                             return(sendCondition)
[16:20:36.026]                           }
[16:20:36.026]                         }
[16:20:36.026]                         frame <- frame + 1L
[16:20:36.026]                         envir <- sys.frame(frame)
[16:20:36.026]                       }
[16:20:36.026]                     }
[16:20:36.026]                     sendCondition <<- function(cond) NULL
[16:20:36.026]                   }
[16:20:36.026]                 })
[16:20:36.026]                 withCallingHandlers({
[16:20:36.026]                   {
[16:20:36.026]                     2 * a
[16:20:36.026]                   }
[16:20:36.026]                 }, immediateCondition = function(cond) {
[16:20:36.026]                   sendCondition <- ...future.makeSendCondition()
[16:20:36.026]                   sendCondition(cond)
[16:20:36.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.026]                   {
[16:20:36.026]                     inherits <- base::inherits
[16:20:36.026]                     invokeRestart <- base::invokeRestart
[16:20:36.026]                     is.null <- base::is.null
[16:20:36.026]                     muffled <- FALSE
[16:20:36.026]                     if (inherits(cond, "message")) {
[16:20:36.026]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:36.026]                       if (muffled) 
[16:20:36.026]                         invokeRestart("muffleMessage")
[16:20:36.026]                     }
[16:20:36.026]                     else if (inherits(cond, "warning")) {
[16:20:36.026]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:36.026]                       if (muffled) 
[16:20:36.026]                         invokeRestart("muffleWarning")
[16:20:36.026]                     }
[16:20:36.026]                     else if (inherits(cond, "condition")) {
[16:20:36.026]                       if (!is.null(pattern)) {
[16:20:36.026]                         computeRestarts <- base::computeRestarts
[16:20:36.026]                         grepl <- base::grepl
[16:20:36.026]                         restarts <- computeRestarts(cond)
[16:20:36.026]                         for (restart in restarts) {
[16:20:36.026]                           name <- restart$name
[16:20:36.026]                           if (is.null(name)) 
[16:20:36.026]                             next
[16:20:36.026]                           if (!grepl(pattern, name)) 
[16:20:36.026]                             next
[16:20:36.026]                           invokeRestart(restart)
[16:20:36.026]                           muffled <- TRUE
[16:20:36.026]                           break
[16:20:36.026]                         }
[16:20:36.026]                       }
[16:20:36.026]                     }
[16:20:36.026]                     invisible(muffled)
[16:20:36.026]                   }
[16:20:36.026]                   muffleCondition(cond)
[16:20:36.026]                 })
[16:20:36.026]             }))
[16:20:36.026]             future::FutureResult(value = ...future.value$value, 
[16:20:36.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.026]                   ...future.rng), globalenv = if (FALSE) 
[16:20:36.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:36.026]                     ...future.globalenv.names))
[16:20:36.026]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:36.026]         }, condition = base::local({
[16:20:36.026]             c <- base::c
[16:20:36.026]             inherits <- base::inherits
[16:20:36.026]             invokeRestart <- base::invokeRestart
[16:20:36.026]             length <- base::length
[16:20:36.026]             list <- base::list
[16:20:36.026]             seq.int <- base::seq.int
[16:20:36.026]             signalCondition <- base::signalCondition
[16:20:36.026]             sys.calls <- base::sys.calls
[16:20:36.026]             `[[` <- base::`[[`
[16:20:36.026]             `+` <- base::`+`
[16:20:36.026]             `<<-` <- base::`<<-`
[16:20:36.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:36.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:36.026]                   3L)]
[16:20:36.026]             }
[16:20:36.026]             function(cond) {
[16:20:36.026]                 is_error <- inherits(cond, "error")
[16:20:36.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:36.026]                   NULL)
[16:20:36.026]                 if (is_error) {
[16:20:36.026]                   sessionInformation <- function() {
[16:20:36.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:36.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:36.026]                       search = base::search(), system = base::Sys.info())
[16:20:36.026]                   }
[16:20:36.026]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:36.026]                     cond$call), session = sessionInformation(), 
[16:20:36.026]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:36.026]                   signalCondition(cond)
[16:20:36.026]                 }
[16:20:36.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:36.026]                 "immediateCondition"))) {
[16:20:36.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:36.026]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:36.026]                   if (TRUE && !signal) {
[16:20:36.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.026]                     {
[16:20:36.026]                       inherits <- base::inherits
[16:20:36.026]                       invokeRestart <- base::invokeRestart
[16:20:36.026]                       is.null <- base::is.null
[16:20:36.026]                       muffled <- FALSE
[16:20:36.026]                       if (inherits(cond, "message")) {
[16:20:36.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.026]                         if (muffled) 
[16:20:36.026]                           invokeRestart("muffleMessage")
[16:20:36.026]                       }
[16:20:36.026]                       else if (inherits(cond, "warning")) {
[16:20:36.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.026]                         if (muffled) 
[16:20:36.026]                           invokeRestart("muffleWarning")
[16:20:36.026]                       }
[16:20:36.026]                       else if (inherits(cond, "condition")) {
[16:20:36.026]                         if (!is.null(pattern)) {
[16:20:36.026]                           computeRestarts <- base::computeRestarts
[16:20:36.026]                           grepl <- base::grepl
[16:20:36.026]                           restarts <- computeRestarts(cond)
[16:20:36.026]                           for (restart in restarts) {
[16:20:36.026]                             name <- restart$name
[16:20:36.026]                             if (is.null(name)) 
[16:20:36.026]                               next
[16:20:36.026]                             if (!grepl(pattern, name)) 
[16:20:36.026]                               next
[16:20:36.026]                             invokeRestart(restart)
[16:20:36.026]                             muffled <- TRUE
[16:20:36.026]                             break
[16:20:36.026]                           }
[16:20:36.026]                         }
[16:20:36.026]                       }
[16:20:36.026]                       invisible(muffled)
[16:20:36.026]                     }
[16:20:36.026]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.026]                   }
[16:20:36.026]                 }
[16:20:36.026]                 else {
[16:20:36.026]                   if (TRUE) {
[16:20:36.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.026]                     {
[16:20:36.026]                       inherits <- base::inherits
[16:20:36.026]                       invokeRestart <- base::invokeRestart
[16:20:36.026]                       is.null <- base::is.null
[16:20:36.026]                       muffled <- FALSE
[16:20:36.026]                       if (inherits(cond, "message")) {
[16:20:36.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.026]                         if (muffled) 
[16:20:36.026]                           invokeRestart("muffleMessage")
[16:20:36.026]                       }
[16:20:36.026]                       else if (inherits(cond, "warning")) {
[16:20:36.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.026]                         if (muffled) 
[16:20:36.026]                           invokeRestart("muffleWarning")
[16:20:36.026]                       }
[16:20:36.026]                       else if (inherits(cond, "condition")) {
[16:20:36.026]                         if (!is.null(pattern)) {
[16:20:36.026]                           computeRestarts <- base::computeRestarts
[16:20:36.026]                           grepl <- base::grepl
[16:20:36.026]                           restarts <- computeRestarts(cond)
[16:20:36.026]                           for (restart in restarts) {
[16:20:36.026]                             name <- restart$name
[16:20:36.026]                             if (is.null(name)) 
[16:20:36.026]                               next
[16:20:36.026]                             if (!grepl(pattern, name)) 
[16:20:36.026]                               next
[16:20:36.026]                             invokeRestart(restart)
[16:20:36.026]                             muffled <- TRUE
[16:20:36.026]                             break
[16:20:36.026]                           }
[16:20:36.026]                         }
[16:20:36.026]                       }
[16:20:36.026]                       invisible(muffled)
[16:20:36.026]                     }
[16:20:36.026]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.026]                   }
[16:20:36.026]                 }
[16:20:36.026]             }
[16:20:36.026]         }))
[16:20:36.026]     }, error = function(ex) {
[16:20:36.026]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:36.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.026]                 ...future.rng), started = ...future.startTime, 
[16:20:36.026]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:36.026]             version = "1.8"), class = "FutureResult")
[16:20:36.026]     }, finally = {
[16:20:36.026]         if (!identical(...future.workdir, getwd())) 
[16:20:36.026]             setwd(...future.workdir)
[16:20:36.026]         {
[16:20:36.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:36.026]                 ...future.oldOptions$nwarnings <- NULL
[16:20:36.026]             }
[16:20:36.026]             base::options(...future.oldOptions)
[16:20:36.026]             if (.Platform$OS.type == "windows") {
[16:20:36.026]                 old_names <- names(...future.oldEnvVars)
[16:20:36.026]                 envs <- base::Sys.getenv()
[16:20:36.026]                 names <- names(envs)
[16:20:36.026]                 common <- intersect(names, old_names)
[16:20:36.026]                 added <- setdiff(names, old_names)
[16:20:36.026]                 removed <- setdiff(old_names, names)
[16:20:36.026]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:36.026]                   envs[common]]
[16:20:36.026]                 NAMES <- toupper(changed)
[16:20:36.026]                 args <- list()
[16:20:36.026]                 for (kk in seq_along(NAMES)) {
[16:20:36.026]                   name <- changed[[kk]]
[16:20:36.026]                   NAME <- NAMES[[kk]]
[16:20:36.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.026]                     next
[16:20:36.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.026]                 }
[16:20:36.026]                 NAMES <- toupper(added)
[16:20:36.026]                 for (kk in seq_along(NAMES)) {
[16:20:36.026]                   name <- added[[kk]]
[16:20:36.026]                   NAME <- NAMES[[kk]]
[16:20:36.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.026]                     next
[16:20:36.026]                   args[[name]] <- ""
[16:20:36.026]                 }
[16:20:36.026]                 NAMES <- toupper(removed)
[16:20:36.026]                 for (kk in seq_along(NAMES)) {
[16:20:36.026]                   name <- removed[[kk]]
[16:20:36.026]                   NAME <- NAMES[[kk]]
[16:20:36.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.026]                     next
[16:20:36.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.026]                 }
[16:20:36.026]                 if (length(args) > 0) 
[16:20:36.026]                   base::do.call(base::Sys.setenv, args = args)
[16:20:36.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:36.026]             }
[16:20:36.026]             else {
[16:20:36.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:36.026]             }
[16:20:36.026]             {
[16:20:36.026]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:36.026]                   0L) {
[16:20:36.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:36.026]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:36.026]                   base::options(opts)
[16:20:36.026]                 }
[16:20:36.026]                 {
[16:20:36.026]                   {
[16:20:36.026]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:36.026]                     NULL
[16:20:36.026]                   }
[16:20:36.026]                   options(future.plan = NULL)
[16:20:36.026]                   if (is.na(NA_character_)) 
[16:20:36.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:36.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:36.026]                     .init = FALSE)
[16:20:36.026]                 }
[16:20:36.026]             }
[16:20:36.026]         }
[16:20:36.026]     })
[16:20:36.026]     if (TRUE) {
[16:20:36.026]         base::sink(type = "output", split = FALSE)
[16:20:36.026]         if (TRUE) {
[16:20:36.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:36.026]         }
[16:20:36.026]         else {
[16:20:36.026]             ...future.result["stdout"] <- base::list(NULL)
[16:20:36.026]         }
[16:20:36.026]         base::close(...future.stdout)
[16:20:36.026]         ...future.stdout <- NULL
[16:20:36.026]     }
[16:20:36.026]     ...future.result$conditions <- ...future.conditions
[16:20:36.026]     ...future.result$finished <- base::Sys.time()
[16:20:36.026]     ...future.result
[16:20:36.026] }
[16:20:36.029] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:36.029] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:36.030] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:36.030] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:36.030] MultisessionFuture started
[16:20:36.030] - Launch lazy future ... done
[16:20:36.031] run() for ‘MultisessionFuture’ ... done
[16:20:36.031] result() for ClusterFuture ...
[16:20:36.031] receiveMessageFromWorker() for ClusterFuture ...
[16:20:36.031] - Validating connection of MultisessionFuture
[16:20:36.032] - received message: FutureResult
[16:20:36.032] - Received FutureResult
[16:20:36.032] - Erased future from FutureRegistry
[16:20:36.032] result() for ClusterFuture ...
[16:20:36.033] - result already collected: FutureResult
[16:20:36.033] result() for ClusterFuture ... done
[16:20:36.033] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:36.033] result() for ClusterFuture ... done
[16:20:36.033] result() for ClusterFuture ...
[16:20:36.033] - result already collected: FutureResult
[16:20:36.033] result() for ClusterFuture ... done
[16:20:36.033] getGlobalsAndPackages() ...
[16:20:36.034] Searching for globals...
[16:20:36.035] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:36.035] Searching for globals ... DONE
[16:20:36.035] Resolving globals: FALSE
[16:20:36.035] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:36.036] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:36.036] - globals: [1] ‘a’
[16:20:36.036] 
[16:20:36.036] getGlobalsAndPackages() ... DONE
[16:20:36.036] run() for ‘Future’ ...
[16:20:36.036] - state: ‘created’
[16:20:36.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:36.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:36.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:36.052]   - Field: ‘node’
[16:20:36.053]   - Field: ‘label’
[16:20:36.053]   - Field: ‘local’
[16:20:36.053]   - Field: ‘owner’
[16:20:36.053]   - Field: ‘envir’
[16:20:36.053]   - Field: ‘workers’
[16:20:36.053]   - Field: ‘packages’
[16:20:36.053]   - Field: ‘gc’
[16:20:36.053]   - Field: ‘conditions’
[16:20:36.053]   - Field: ‘persistent’
[16:20:36.053]   - Field: ‘expr’
[16:20:36.053]   - Field: ‘uuid’
[16:20:36.053]   - Field: ‘seed’
[16:20:36.054]   - Field: ‘version’
[16:20:36.054]   - Field: ‘result’
[16:20:36.054]   - Field: ‘asynchronous’
[16:20:36.054]   - Field: ‘calls’
[16:20:36.054]   - Field: ‘globals’
[16:20:36.054]   - Field: ‘stdout’
[16:20:36.054]   - Field: ‘earlySignal’
[16:20:36.054]   - Field: ‘lazy’
[16:20:36.054]   - Field: ‘state’
[16:20:36.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:36.054] - Launch lazy future ...
[16:20:36.055] Packages needed by the future expression (n = 0): <none>
[16:20:36.055] Packages needed by future strategies (n = 0): <none>
[16:20:36.055] {
[16:20:36.055]     {
[16:20:36.055]         {
[16:20:36.055]             ...future.startTime <- base::Sys.time()
[16:20:36.055]             {
[16:20:36.055]                 {
[16:20:36.055]                   {
[16:20:36.055]                     {
[16:20:36.055]                       base::local({
[16:20:36.055]                         has_future <- base::requireNamespace("future", 
[16:20:36.055]                           quietly = TRUE)
[16:20:36.055]                         if (has_future) {
[16:20:36.055]                           ns <- base::getNamespace("future")
[16:20:36.055]                           version <- ns[[".package"]][["version"]]
[16:20:36.055]                           if (is.null(version)) 
[16:20:36.055]                             version <- utils::packageVersion("future")
[16:20:36.055]                         }
[16:20:36.055]                         else {
[16:20:36.055]                           version <- NULL
[16:20:36.055]                         }
[16:20:36.055]                         if (!has_future || version < "1.8.0") {
[16:20:36.055]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:36.055]                             "", base::R.version$version.string), 
[16:20:36.055]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:36.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:36.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:36.055]                               "release", "version")], collapse = " "), 
[16:20:36.055]                             hostname = base::Sys.info()[["nodename"]])
[16:20:36.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:36.055]                             info)
[16:20:36.055]                           info <- base::paste(info, collapse = "; ")
[16:20:36.055]                           if (!has_future) {
[16:20:36.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:36.055]                               info)
[16:20:36.055]                           }
[16:20:36.055]                           else {
[16:20:36.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:36.055]                               info, version)
[16:20:36.055]                           }
[16:20:36.055]                           base::stop(msg)
[16:20:36.055]                         }
[16:20:36.055]                       })
[16:20:36.055]                     }
[16:20:36.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:36.055]                     base::options(mc.cores = 1L)
[16:20:36.055]                   }
[16:20:36.055]                   ...future.strategy.old <- future::plan("list")
[16:20:36.055]                   options(future.plan = NULL)
[16:20:36.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:36.055]                 }
[16:20:36.055]                 ...future.workdir <- getwd()
[16:20:36.055]             }
[16:20:36.055]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:36.055]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:36.055]         }
[16:20:36.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:36.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:36.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:36.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:36.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:36.055]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:36.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:36.055]             base::names(...future.oldOptions))
[16:20:36.055]     }
[16:20:36.055]     if (FALSE) {
[16:20:36.055]     }
[16:20:36.055]     else {
[16:20:36.055]         if (TRUE) {
[16:20:36.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:36.055]                 open = "w")
[16:20:36.055]         }
[16:20:36.055]         else {
[16:20:36.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:36.055]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:36.055]         }
[16:20:36.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:36.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:36.055]             base::sink(type = "output", split = FALSE)
[16:20:36.055]             base::close(...future.stdout)
[16:20:36.055]         }, add = TRUE)
[16:20:36.055]     }
[16:20:36.055]     ...future.frame <- base::sys.nframe()
[16:20:36.055]     ...future.conditions <- base::list()
[16:20:36.055]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:36.055]     if (FALSE) {
[16:20:36.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:36.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:36.055]     }
[16:20:36.055]     ...future.result <- base::tryCatch({
[16:20:36.055]         base::withCallingHandlers({
[16:20:36.055]             ...future.value <- base::withVisible(base::local({
[16:20:36.055]                 ...future.makeSendCondition <- base::local({
[16:20:36.055]                   sendCondition <- NULL
[16:20:36.055]                   function(frame = 1L) {
[16:20:36.055]                     if (is.function(sendCondition)) 
[16:20:36.055]                       return(sendCondition)
[16:20:36.055]                     ns <- getNamespace("parallel")
[16:20:36.055]                     if (exists("sendData", mode = "function", 
[16:20:36.055]                       envir = ns)) {
[16:20:36.055]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:36.055]                         envir = ns)
[16:20:36.055]                       envir <- sys.frame(frame)
[16:20:36.055]                       master <- NULL
[16:20:36.055]                       while (!identical(envir, .GlobalEnv) && 
[16:20:36.055]                         !identical(envir, emptyenv())) {
[16:20:36.055]                         if (exists("master", mode = "list", envir = envir, 
[16:20:36.055]                           inherits = FALSE)) {
[16:20:36.055]                           master <- get("master", mode = "list", 
[16:20:36.055]                             envir = envir, inherits = FALSE)
[16:20:36.055]                           if (inherits(master, c("SOCKnode", 
[16:20:36.055]                             "SOCK0node"))) {
[16:20:36.055]                             sendCondition <<- function(cond) {
[16:20:36.055]                               data <- list(type = "VALUE", value = cond, 
[16:20:36.055]                                 success = TRUE)
[16:20:36.055]                               parallel_sendData(master, data)
[16:20:36.055]                             }
[16:20:36.055]                             return(sendCondition)
[16:20:36.055]                           }
[16:20:36.055]                         }
[16:20:36.055]                         frame <- frame + 1L
[16:20:36.055]                         envir <- sys.frame(frame)
[16:20:36.055]                       }
[16:20:36.055]                     }
[16:20:36.055]                     sendCondition <<- function(cond) NULL
[16:20:36.055]                   }
[16:20:36.055]                 })
[16:20:36.055]                 withCallingHandlers({
[16:20:36.055]                   {
[16:20:36.055]                     2 * a
[16:20:36.055]                   }
[16:20:36.055]                 }, immediateCondition = function(cond) {
[16:20:36.055]                   sendCondition <- ...future.makeSendCondition()
[16:20:36.055]                   sendCondition(cond)
[16:20:36.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.055]                   {
[16:20:36.055]                     inherits <- base::inherits
[16:20:36.055]                     invokeRestart <- base::invokeRestart
[16:20:36.055]                     is.null <- base::is.null
[16:20:36.055]                     muffled <- FALSE
[16:20:36.055]                     if (inherits(cond, "message")) {
[16:20:36.055]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:36.055]                       if (muffled) 
[16:20:36.055]                         invokeRestart("muffleMessage")
[16:20:36.055]                     }
[16:20:36.055]                     else if (inherits(cond, "warning")) {
[16:20:36.055]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:36.055]                       if (muffled) 
[16:20:36.055]                         invokeRestart("muffleWarning")
[16:20:36.055]                     }
[16:20:36.055]                     else if (inherits(cond, "condition")) {
[16:20:36.055]                       if (!is.null(pattern)) {
[16:20:36.055]                         computeRestarts <- base::computeRestarts
[16:20:36.055]                         grepl <- base::grepl
[16:20:36.055]                         restarts <- computeRestarts(cond)
[16:20:36.055]                         for (restart in restarts) {
[16:20:36.055]                           name <- restart$name
[16:20:36.055]                           if (is.null(name)) 
[16:20:36.055]                             next
[16:20:36.055]                           if (!grepl(pattern, name)) 
[16:20:36.055]                             next
[16:20:36.055]                           invokeRestart(restart)
[16:20:36.055]                           muffled <- TRUE
[16:20:36.055]                           break
[16:20:36.055]                         }
[16:20:36.055]                       }
[16:20:36.055]                     }
[16:20:36.055]                     invisible(muffled)
[16:20:36.055]                   }
[16:20:36.055]                   muffleCondition(cond)
[16:20:36.055]                 })
[16:20:36.055]             }))
[16:20:36.055]             future::FutureResult(value = ...future.value$value, 
[16:20:36.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.055]                   ...future.rng), globalenv = if (FALSE) 
[16:20:36.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:36.055]                     ...future.globalenv.names))
[16:20:36.055]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:36.055]         }, condition = base::local({
[16:20:36.055]             c <- base::c
[16:20:36.055]             inherits <- base::inherits
[16:20:36.055]             invokeRestart <- base::invokeRestart
[16:20:36.055]             length <- base::length
[16:20:36.055]             list <- base::list
[16:20:36.055]             seq.int <- base::seq.int
[16:20:36.055]             signalCondition <- base::signalCondition
[16:20:36.055]             sys.calls <- base::sys.calls
[16:20:36.055]             `[[` <- base::`[[`
[16:20:36.055]             `+` <- base::`+`
[16:20:36.055]             `<<-` <- base::`<<-`
[16:20:36.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:36.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:36.055]                   3L)]
[16:20:36.055]             }
[16:20:36.055]             function(cond) {
[16:20:36.055]                 is_error <- inherits(cond, "error")
[16:20:36.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:36.055]                   NULL)
[16:20:36.055]                 if (is_error) {
[16:20:36.055]                   sessionInformation <- function() {
[16:20:36.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:36.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:36.055]                       search = base::search(), system = base::Sys.info())
[16:20:36.055]                   }
[16:20:36.055]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:36.055]                     cond$call), session = sessionInformation(), 
[16:20:36.055]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:36.055]                   signalCondition(cond)
[16:20:36.055]                 }
[16:20:36.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:36.055]                 "immediateCondition"))) {
[16:20:36.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:36.055]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:36.055]                   if (TRUE && !signal) {
[16:20:36.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.055]                     {
[16:20:36.055]                       inherits <- base::inherits
[16:20:36.055]                       invokeRestart <- base::invokeRestart
[16:20:36.055]                       is.null <- base::is.null
[16:20:36.055]                       muffled <- FALSE
[16:20:36.055]                       if (inherits(cond, "message")) {
[16:20:36.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.055]                         if (muffled) 
[16:20:36.055]                           invokeRestart("muffleMessage")
[16:20:36.055]                       }
[16:20:36.055]                       else if (inherits(cond, "warning")) {
[16:20:36.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.055]                         if (muffled) 
[16:20:36.055]                           invokeRestart("muffleWarning")
[16:20:36.055]                       }
[16:20:36.055]                       else if (inherits(cond, "condition")) {
[16:20:36.055]                         if (!is.null(pattern)) {
[16:20:36.055]                           computeRestarts <- base::computeRestarts
[16:20:36.055]                           grepl <- base::grepl
[16:20:36.055]                           restarts <- computeRestarts(cond)
[16:20:36.055]                           for (restart in restarts) {
[16:20:36.055]                             name <- restart$name
[16:20:36.055]                             if (is.null(name)) 
[16:20:36.055]                               next
[16:20:36.055]                             if (!grepl(pattern, name)) 
[16:20:36.055]                               next
[16:20:36.055]                             invokeRestart(restart)
[16:20:36.055]                             muffled <- TRUE
[16:20:36.055]                             break
[16:20:36.055]                           }
[16:20:36.055]                         }
[16:20:36.055]                       }
[16:20:36.055]                       invisible(muffled)
[16:20:36.055]                     }
[16:20:36.055]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.055]                   }
[16:20:36.055]                 }
[16:20:36.055]                 else {
[16:20:36.055]                   if (TRUE) {
[16:20:36.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.055]                     {
[16:20:36.055]                       inherits <- base::inherits
[16:20:36.055]                       invokeRestart <- base::invokeRestart
[16:20:36.055]                       is.null <- base::is.null
[16:20:36.055]                       muffled <- FALSE
[16:20:36.055]                       if (inherits(cond, "message")) {
[16:20:36.055]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.055]                         if (muffled) 
[16:20:36.055]                           invokeRestart("muffleMessage")
[16:20:36.055]                       }
[16:20:36.055]                       else if (inherits(cond, "warning")) {
[16:20:36.055]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.055]                         if (muffled) 
[16:20:36.055]                           invokeRestart("muffleWarning")
[16:20:36.055]                       }
[16:20:36.055]                       else if (inherits(cond, "condition")) {
[16:20:36.055]                         if (!is.null(pattern)) {
[16:20:36.055]                           computeRestarts <- base::computeRestarts
[16:20:36.055]                           grepl <- base::grepl
[16:20:36.055]                           restarts <- computeRestarts(cond)
[16:20:36.055]                           for (restart in restarts) {
[16:20:36.055]                             name <- restart$name
[16:20:36.055]                             if (is.null(name)) 
[16:20:36.055]                               next
[16:20:36.055]                             if (!grepl(pattern, name)) 
[16:20:36.055]                               next
[16:20:36.055]                             invokeRestart(restart)
[16:20:36.055]                             muffled <- TRUE
[16:20:36.055]                             break
[16:20:36.055]                           }
[16:20:36.055]                         }
[16:20:36.055]                       }
[16:20:36.055]                       invisible(muffled)
[16:20:36.055]                     }
[16:20:36.055]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.055]                   }
[16:20:36.055]                 }
[16:20:36.055]             }
[16:20:36.055]         }))
[16:20:36.055]     }, error = function(ex) {
[16:20:36.055]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:36.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.055]                 ...future.rng), started = ...future.startTime, 
[16:20:36.055]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:36.055]             version = "1.8"), class = "FutureResult")
[16:20:36.055]     }, finally = {
[16:20:36.055]         if (!identical(...future.workdir, getwd())) 
[16:20:36.055]             setwd(...future.workdir)
[16:20:36.055]         {
[16:20:36.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:36.055]                 ...future.oldOptions$nwarnings <- NULL
[16:20:36.055]             }
[16:20:36.055]             base::options(...future.oldOptions)
[16:20:36.055]             if (.Platform$OS.type == "windows") {
[16:20:36.055]                 old_names <- names(...future.oldEnvVars)
[16:20:36.055]                 envs <- base::Sys.getenv()
[16:20:36.055]                 names <- names(envs)
[16:20:36.055]                 common <- intersect(names, old_names)
[16:20:36.055]                 added <- setdiff(names, old_names)
[16:20:36.055]                 removed <- setdiff(old_names, names)
[16:20:36.055]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:36.055]                   envs[common]]
[16:20:36.055]                 NAMES <- toupper(changed)
[16:20:36.055]                 args <- list()
[16:20:36.055]                 for (kk in seq_along(NAMES)) {
[16:20:36.055]                   name <- changed[[kk]]
[16:20:36.055]                   NAME <- NAMES[[kk]]
[16:20:36.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.055]                     next
[16:20:36.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.055]                 }
[16:20:36.055]                 NAMES <- toupper(added)
[16:20:36.055]                 for (kk in seq_along(NAMES)) {
[16:20:36.055]                   name <- added[[kk]]
[16:20:36.055]                   NAME <- NAMES[[kk]]
[16:20:36.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.055]                     next
[16:20:36.055]                   args[[name]] <- ""
[16:20:36.055]                 }
[16:20:36.055]                 NAMES <- toupper(removed)
[16:20:36.055]                 for (kk in seq_along(NAMES)) {
[16:20:36.055]                   name <- removed[[kk]]
[16:20:36.055]                   NAME <- NAMES[[kk]]
[16:20:36.055]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.055]                     next
[16:20:36.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.055]                 }
[16:20:36.055]                 if (length(args) > 0) 
[16:20:36.055]                   base::do.call(base::Sys.setenv, args = args)
[16:20:36.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:36.055]             }
[16:20:36.055]             else {
[16:20:36.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:36.055]             }
[16:20:36.055]             {
[16:20:36.055]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:36.055]                   0L) {
[16:20:36.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:36.055]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:36.055]                   base::options(opts)
[16:20:36.055]                 }
[16:20:36.055]                 {
[16:20:36.055]                   {
[16:20:36.055]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:36.055]                     NULL
[16:20:36.055]                   }
[16:20:36.055]                   options(future.plan = NULL)
[16:20:36.055]                   if (is.na(NA_character_)) 
[16:20:36.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:36.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:36.055]                     .init = FALSE)
[16:20:36.055]                 }
[16:20:36.055]             }
[16:20:36.055]         }
[16:20:36.055]     })
[16:20:36.055]     if (TRUE) {
[16:20:36.055]         base::sink(type = "output", split = FALSE)
[16:20:36.055]         if (TRUE) {
[16:20:36.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:36.055]         }
[16:20:36.055]         else {
[16:20:36.055]             ...future.result["stdout"] <- base::list(NULL)
[16:20:36.055]         }
[16:20:36.055]         base::close(...future.stdout)
[16:20:36.055]         ...future.stdout <- NULL
[16:20:36.055]     }
[16:20:36.055]     ...future.result$conditions <- ...future.conditions
[16:20:36.055]     ...future.result$finished <- base::Sys.time()
[16:20:36.055]     ...future.result
[16:20:36.055] }
[16:20:36.058] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:36.058] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:36.058] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:36.058] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:36.059] MultisessionFuture started
[16:20:36.059] - Launch lazy future ... done
[16:20:36.059] run() for ‘MultisessionFuture’ ... done
[16:20:36.059] result() for ClusterFuture ...
[16:20:36.059] receiveMessageFromWorker() for ClusterFuture ...
[16:20:36.059] - Validating connection of MultisessionFuture
[16:20:36.060] - received message: FutureResult
[16:20:36.060] - Received FutureResult
[16:20:36.060] - Erased future from FutureRegistry
[16:20:36.060] result() for ClusterFuture ...
[16:20:36.061] - result already collected: FutureResult
[16:20:36.061] result() for ClusterFuture ... done
[16:20:36.061] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:36.061] result() for ClusterFuture ... done
[16:20:36.061] result() for ClusterFuture ...
[16:20:36.061] - result already collected: FutureResult
[16:20:36.061] result() for ClusterFuture ... done
[16:20:36.061] getGlobalsAndPackages() ...
[16:20:36.061] Searching for globals...
[16:20:36.062] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:36.062] Searching for globals ... DONE
[16:20:36.062] Resolving globals: FALSE
[16:20:36.063] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:36.063] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:36.063] - globals: [1] ‘a’
[16:20:36.063] 
[16:20:36.063] getGlobalsAndPackages() ... DONE
[16:20:36.063] run() for ‘Future’ ...
[16:20:36.064] - state: ‘created’
[16:20:36.064] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:36.077] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:36.077] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:36.077]   - Field: ‘node’
[16:20:36.077]   - Field: ‘label’
[16:20:36.078]   - Field: ‘local’
[16:20:36.078]   - Field: ‘owner’
[16:20:36.078]   - Field: ‘envir’
[16:20:36.078]   - Field: ‘workers’
[16:20:36.078]   - Field: ‘packages’
[16:20:36.078]   - Field: ‘gc’
[16:20:36.078]   - Field: ‘conditions’
[16:20:36.078]   - Field: ‘persistent’
[16:20:36.078]   - Field: ‘expr’
[16:20:36.078]   - Field: ‘uuid’
[16:20:36.078]   - Field: ‘seed’
[16:20:36.079]   - Field: ‘version’
[16:20:36.079]   - Field: ‘result’
[16:20:36.079]   - Field: ‘asynchronous’
[16:20:36.079]   - Field: ‘calls’
[16:20:36.079]   - Field: ‘globals’
[16:20:36.079]   - Field: ‘stdout’
[16:20:36.079]   - Field: ‘earlySignal’
[16:20:36.079]   - Field: ‘lazy’
[16:20:36.079]   - Field: ‘state’
[16:20:36.079] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:36.079] - Launch lazy future ...
[16:20:36.080] Packages needed by the future expression (n = 0): <none>
[16:20:36.080] Packages needed by future strategies (n = 0): <none>
[16:20:36.080] {
[16:20:36.080]     {
[16:20:36.080]         {
[16:20:36.080]             ...future.startTime <- base::Sys.time()
[16:20:36.080]             {
[16:20:36.080]                 {
[16:20:36.080]                   {
[16:20:36.080]                     {
[16:20:36.080]                       base::local({
[16:20:36.080]                         has_future <- base::requireNamespace("future", 
[16:20:36.080]                           quietly = TRUE)
[16:20:36.080]                         if (has_future) {
[16:20:36.080]                           ns <- base::getNamespace("future")
[16:20:36.080]                           version <- ns[[".package"]][["version"]]
[16:20:36.080]                           if (is.null(version)) 
[16:20:36.080]                             version <- utils::packageVersion("future")
[16:20:36.080]                         }
[16:20:36.080]                         else {
[16:20:36.080]                           version <- NULL
[16:20:36.080]                         }
[16:20:36.080]                         if (!has_future || version < "1.8.0") {
[16:20:36.080]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:36.080]                             "", base::R.version$version.string), 
[16:20:36.080]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:36.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:36.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:36.080]                               "release", "version")], collapse = " "), 
[16:20:36.080]                             hostname = base::Sys.info()[["nodename"]])
[16:20:36.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:36.080]                             info)
[16:20:36.080]                           info <- base::paste(info, collapse = "; ")
[16:20:36.080]                           if (!has_future) {
[16:20:36.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:36.080]                               info)
[16:20:36.080]                           }
[16:20:36.080]                           else {
[16:20:36.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:36.080]                               info, version)
[16:20:36.080]                           }
[16:20:36.080]                           base::stop(msg)
[16:20:36.080]                         }
[16:20:36.080]                       })
[16:20:36.080]                     }
[16:20:36.080]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:36.080]                     base::options(mc.cores = 1L)
[16:20:36.080]                   }
[16:20:36.080]                   ...future.strategy.old <- future::plan("list")
[16:20:36.080]                   options(future.plan = NULL)
[16:20:36.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:36.080]                 }
[16:20:36.080]                 ...future.workdir <- getwd()
[16:20:36.080]             }
[16:20:36.080]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:36.080]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:36.080]         }
[16:20:36.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:36.080]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:36.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:36.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:36.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:36.080]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:36.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:36.080]             base::names(...future.oldOptions))
[16:20:36.080]     }
[16:20:36.080]     if (FALSE) {
[16:20:36.080]     }
[16:20:36.080]     else {
[16:20:36.080]         if (TRUE) {
[16:20:36.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:36.080]                 open = "w")
[16:20:36.080]         }
[16:20:36.080]         else {
[16:20:36.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:36.080]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:36.080]         }
[16:20:36.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:36.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:36.080]             base::sink(type = "output", split = FALSE)
[16:20:36.080]             base::close(...future.stdout)
[16:20:36.080]         }, add = TRUE)
[16:20:36.080]     }
[16:20:36.080]     ...future.frame <- base::sys.nframe()
[16:20:36.080]     ...future.conditions <- base::list()
[16:20:36.080]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:36.080]     if (FALSE) {
[16:20:36.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:36.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:36.080]     }
[16:20:36.080]     ...future.result <- base::tryCatch({
[16:20:36.080]         base::withCallingHandlers({
[16:20:36.080]             ...future.value <- base::withVisible(base::local({
[16:20:36.080]                 ...future.makeSendCondition <- base::local({
[16:20:36.080]                   sendCondition <- NULL
[16:20:36.080]                   function(frame = 1L) {
[16:20:36.080]                     if (is.function(sendCondition)) 
[16:20:36.080]                       return(sendCondition)
[16:20:36.080]                     ns <- getNamespace("parallel")
[16:20:36.080]                     if (exists("sendData", mode = "function", 
[16:20:36.080]                       envir = ns)) {
[16:20:36.080]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:36.080]                         envir = ns)
[16:20:36.080]                       envir <- sys.frame(frame)
[16:20:36.080]                       master <- NULL
[16:20:36.080]                       while (!identical(envir, .GlobalEnv) && 
[16:20:36.080]                         !identical(envir, emptyenv())) {
[16:20:36.080]                         if (exists("master", mode = "list", envir = envir, 
[16:20:36.080]                           inherits = FALSE)) {
[16:20:36.080]                           master <- get("master", mode = "list", 
[16:20:36.080]                             envir = envir, inherits = FALSE)
[16:20:36.080]                           if (inherits(master, c("SOCKnode", 
[16:20:36.080]                             "SOCK0node"))) {
[16:20:36.080]                             sendCondition <<- function(cond) {
[16:20:36.080]                               data <- list(type = "VALUE", value = cond, 
[16:20:36.080]                                 success = TRUE)
[16:20:36.080]                               parallel_sendData(master, data)
[16:20:36.080]                             }
[16:20:36.080]                             return(sendCondition)
[16:20:36.080]                           }
[16:20:36.080]                         }
[16:20:36.080]                         frame <- frame + 1L
[16:20:36.080]                         envir <- sys.frame(frame)
[16:20:36.080]                       }
[16:20:36.080]                     }
[16:20:36.080]                     sendCondition <<- function(cond) NULL
[16:20:36.080]                   }
[16:20:36.080]                 })
[16:20:36.080]                 withCallingHandlers({
[16:20:36.080]                   {
[16:20:36.080]                     2 * a
[16:20:36.080]                   }
[16:20:36.080]                 }, immediateCondition = function(cond) {
[16:20:36.080]                   sendCondition <- ...future.makeSendCondition()
[16:20:36.080]                   sendCondition(cond)
[16:20:36.080]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.080]                   {
[16:20:36.080]                     inherits <- base::inherits
[16:20:36.080]                     invokeRestart <- base::invokeRestart
[16:20:36.080]                     is.null <- base::is.null
[16:20:36.080]                     muffled <- FALSE
[16:20:36.080]                     if (inherits(cond, "message")) {
[16:20:36.080]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:36.080]                       if (muffled) 
[16:20:36.080]                         invokeRestart("muffleMessage")
[16:20:36.080]                     }
[16:20:36.080]                     else if (inherits(cond, "warning")) {
[16:20:36.080]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:36.080]                       if (muffled) 
[16:20:36.080]                         invokeRestart("muffleWarning")
[16:20:36.080]                     }
[16:20:36.080]                     else if (inherits(cond, "condition")) {
[16:20:36.080]                       if (!is.null(pattern)) {
[16:20:36.080]                         computeRestarts <- base::computeRestarts
[16:20:36.080]                         grepl <- base::grepl
[16:20:36.080]                         restarts <- computeRestarts(cond)
[16:20:36.080]                         for (restart in restarts) {
[16:20:36.080]                           name <- restart$name
[16:20:36.080]                           if (is.null(name)) 
[16:20:36.080]                             next
[16:20:36.080]                           if (!grepl(pattern, name)) 
[16:20:36.080]                             next
[16:20:36.080]                           invokeRestart(restart)
[16:20:36.080]                           muffled <- TRUE
[16:20:36.080]                           break
[16:20:36.080]                         }
[16:20:36.080]                       }
[16:20:36.080]                     }
[16:20:36.080]                     invisible(muffled)
[16:20:36.080]                   }
[16:20:36.080]                   muffleCondition(cond)
[16:20:36.080]                 })
[16:20:36.080]             }))
[16:20:36.080]             future::FutureResult(value = ...future.value$value, 
[16:20:36.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.080]                   ...future.rng), globalenv = if (FALSE) 
[16:20:36.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:36.080]                     ...future.globalenv.names))
[16:20:36.080]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:36.080]         }, condition = base::local({
[16:20:36.080]             c <- base::c
[16:20:36.080]             inherits <- base::inherits
[16:20:36.080]             invokeRestart <- base::invokeRestart
[16:20:36.080]             length <- base::length
[16:20:36.080]             list <- base::list
[16:20:36.080]             seq.int <- base::seq.int
[16:20:36.080]             signalCondition <- base::signalCondition
[16:20:36.080]             sys.calls <- base::sys.calls
[16:20:36.080]             `[[` <- base::`[[`
[16:20:36.080]             `+` <- base::`+`
[16:20:36.080]             `<<-` <- base::`<<-`
[16:20:36.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:36.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:36.080]                   3L)]
[16:20:36.080]             }
[16:20:36.080]             function(cond) {
[16:20:36.080]                 is_error <- inherits(cond, "error")
[16:20:36.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:36.080]                   NULL)
[16:20:36.080]                 if (is_error) {
[16:20:36.080]                   sessionInformation <- function() {
[16:20:36.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:36.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:36.080]                       search = base::search(), system = base::Sys.info())
[16:20:36.080]                   }
[16:20:36.080]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:36.080]                     cond$call), session = sessionInformation(), 
[16:20:36.080]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:36.080]                   signalCondition(cond)
[16:20:36.080]                 }
[16:20:36.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:36.080]                 "immediateCondition"))) {
[16:20:36.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:36.080]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:36.080]                   if (TRUE && !signal) {
[16:20:36.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.080]                     {
[16:20:36.080]                       inherits <- base::inherits
[16:20:36.080]                       invokeRestart <- base::invokeRestart
[16:20:36.080]                       is.null <- base::is.null
[16:20:36.080]                       muffled <- FALSE
[16:20:36.080]                       if (inherits(cond, "message")) {
[16:20:36.080]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.080]                         if (muffled) 
[16:20:36.080]                           invokeRestart("muffleMessage")
[16:20:36.080]                       }
[16:20:36.080]                       else if (inherits(cond, "warning")) {
[16:20:36.080]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.080]                         if (muffled) 
[16:20:36.080]                           invokeRestart("muffleWarning")
[16:20:36.080]                       }
[16:20:36.080]                       else if (inherits(cond, "condition")) {
[16:20:36.080]                         if (!is.null(pattern)) {
[16:20:36.080]                           computeRestarts <- base::computeRestarts
[16:20:36.080]                           grepl <- base::grepl
[16:20:36.080]                           restarts <- computeRestarts(cond)
[16:20:36.080]                           for (restart in restarts) {
[16:20:36.080]                             name <- restart$name
[16:20:36.080]                             if (is.null(name)) 
[16:20:36.080]                               next
[16:20:36.080]                             if (!grepl(pattern, name)) 
[16:20:36.080]                               next
[16:20:36.080]                             invokeRestart(restart)
[16:20:36.080]                             muffled <- TRUE
[16:20:36.080]                             break
[16:20:36.080]                           }
[16:20:36.080]                         }
[16:20:36.080]                       }
[16:20:36.080]                       invisible(muffled)
[16:20:36.080]                     }
[16:20:36.080]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.080]                   }
[16:20:36.080]                 }
[16:20:36.080]                 else {
[16:20:36.080]                   if (TRUE) {
[16:20:36.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.080]                     {
[16:20:36.080]                       inherits <- base::inherits
[16:20:36.080]                       invokeRestart <- base::invokeRestart
[16:20:36.080]                       is.null <- base::is.null
[16:20:36.080]                       muffled <- FALSE
[16:20:36.080]                       if (inherits(cond, "message")) {
[16:20:36.080]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.080]                         if (muffled) 
[16:20:36.080]                           invokeRestart("muffleMessage")
[16:20:36.080]                       }
[16:20:36.080]                       else if (inherits(cond, "warning")) {
[16:20:36.080]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.080]                         if (muffled) 
[16:20:36.080]                           invokeRestart("muffleWarning")
[16:20:36.080]                       }
[16:20:36.080]                       else if (inherits(cond, "condition")) {
[16:20:36.080]                         if (!is.null(pattern)) {
[16:20:36.080]                           computeRestarts <- base::computeRestarts
[16:20:36.080]                           grepl <- base::grepl
[16:20:36.080]                           restarts <- computeRestarts(cond)
[16:20:36.080]                           for (restart in restarts) {
[16:20:36.080]                             name <- restart$name
[16:20:36.080]                             if (is.null(name)) 
[16:20:36.080]                               next
[16:20:36.080]                             if (!grepl(pattern, name)) 
[16:20:36.080]                               next
[16:20:36.080]                             invokeRestart(restart)
[16:20:36.080]                             muffled <- TRUE
[16:20:36.080]                             break
[16:20:36.080]                           }
[16:20:36.080]                         }
[16:20:36.080]                       }
[16:20:36.080]                       invisible(muffled)
[16:20:36.080]                     }
[16:20:36.080]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.080]                   }
[16:20:36.080]                 }
[16:20:36.080]             }
[16:20:36.080]         }))
[16:20:36.080]     }, error = function(ex) {
[16:20:36.080]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:36.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.080]                 ...future.rng), started = ...future.startTime, 
[16:20:36.080]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:36.080]             version = "1.8"), class = "FutureResult")
[16:20:36.080]     }, finally = {
[16:20:36.080]         if (!identical(...future.workdir, getwd())) 
[16:20:36.080]             setwd(...future.workdir)
[16:20:36.080]         {
[16:20:36.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:36.080]                 ...future.oldOptions$nwarnings <- NULL
[16:20:36.080]             }
[16:20:36.080]             base::options(...future.oldOptions)
[16:20:36.080]             if (.Platform$OS.type == "windows") {
[16:20:36.080]                 old_names <- names(...future.oldEnvVars)
[16:20:36.080]                 envs <- base::Sys.getenv()
[16:20:36.080]                 names <- names(envs)
[16:20:36.080]                 common <- intersect(names, old_names)
[16:20:36.080]                 added <- setdiff(names, old_names)
[16:20:36.080]                 removed <- setdiff(old_names, names)
[16:20:36.080]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:36.080]                   envs[common]]
[16:20:36.080]                 NAMES <- toupper(changed)
[16:20:36.080]                 args <- list()
[16:20:36.080]                 for (kk in seq_along(NAMES)) {
[16:20:36.080]                   name <- changed[[kk]]
[16:20:36.080]                   NAME <- NAMES[[kk]]
[16:20:36.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.080]                     next
[16:20:36.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.080]                 }
[16:20:36.080]                 NAMES <- toupper(added)
[16:20:36.080]                 for (kk in seq_along(NAMES)) {
[16:20:36.080]                   name <- added[[kk]]
[16:20:36.080]                   NAME <- NAMES[[kk]]
[16:20:36.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.080]                     next
[16:20:36.080]                   args[[name]] <- ""
[16:20:36.080]                 }
[16:20:36.080]                 NAMES <- toupper(removed)
[16:20:36.080]                 for (kk in seq_along(NAMES)) {
[16:20:36.080]                   name <- removed[[kk]]
[16:20:36.080]                   NAME <- NAMES[[kk]]
[16:20:36.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.080]                     next
[16:20:36.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.080]                 }
[16:20:36.080]                 if (length(args) > 0) 
[16:20:36.080]                   base::do.call(base::Sys.setenv, args = args)
[16:20:36.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:36.080]             }
[16:20:36.080]             else {
[16:20:36.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:36.080]             }
[16:20:36.080]             {
[16:20:36.080]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:36.080]                   0L) {
[16:20:36.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:36.080]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:36.080]                   base::options(opts)
[16:20:36.080]                 }
[16:20:36.080]                 {
[16:20:36.080]                   {
[16:20:36.080]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:36.080]                     NULL
[16:20:36.080]                   }
[16:20:36.080]                   options(future.plan = NULL)
[16:20:36.080]                   if (is.na(NA_character_)) 
[16:20:36.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:36.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:36.080]                     .init = FALSE)
[16:20:36.080]                 }
[16:20:36.080]             }
[16:20:36.080]         }
[16:20:36.080]     })
[16:20:36.080]     if (TRUE) {
[16:20:36.080]         base::sink(type = "output", split = FALSE)
[16:20:36.080]         if (TRUE) {
[16:20:36.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:36.080]         }
[16:20:36.080]         else {
[16:20:36.080]             ...future.result["stdout"] <- base::list(NULL)
[16:20:36.080]         }
[16:20:36.080]         base::close(...future.stdout)
[16:20:36.080]         ...future.stdout <- NULL
[16:20:36.080]     }
[16:20:36.080]     ...future.result$conditions <- ...future.conditions
[16:20:36.080]     ...future.result$finished <- base::Sys.time()
[16:20:36.080]     ...future.result
[16:20:36.080] }
[16:20:36.083] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:36.083] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:36.083] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:36.083] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:36.084] MultisessionFuture started
[16:20:36.084] - Launch lazy future ... done
[16:20:36.084] run() for ‘MultisessionFuture’ ... done
[16:20:36.084] result() for ClusterFuture ...
[16:20:36.084] receiveMessageFromWorker() for ClusterFuture ...
[16:20:36.084] - Validating connection of MultisessionFuture
[16:20:36.085] - received message: FutureResult
[16:20:36.085] - Received FutureResult
[16:20:36.085] - Erased future from FutureRegistry
[16:20:36.086] result() for ClusterFuture ...
[16:20:36.086] - result already collected: FutureResult
[16:20:36.086] result() for ClusterFuture ... done
[16:20:36.086] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:36.086] result() for ClusterFuture ... done
[16:20:36.086] result() for ClusterFuture ...
[16:20:36.086] - result already collected: FutureResult
[16:20:36.086] result() for ClusterFuture ... done
[16:20:36.086] getGlobalsAndPackages() ...
[16:20:36.086] Searching for globals...
[16:20:36.087] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:36.087] Searching for globals ... DONE
[16:20:36.087] Resolving globals: FALSE
[16:20:36.088] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:36.088] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:36.088] - globals: [1] ‘a’
[16:20:36.088] 
[16:20:36.088] getGlobalsAndPackages() ... DONE
[16:20:36.089] run() for ‘Future’ ...
[16:20:36.089] - state: ‘created’
[16:20:36.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:36.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:36.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:36.103]   - Field: ‘node’
[16:20:36.103]   - Field: ‘label’
[16:20:36.103]   - Field: ‘local’
[16:20:36.103]   - Field: ‘owner’
[16:20:36.104]   - Field: ‘envir’
[16:20:36.104]   - Field: ‘workers’
[16:20:36.104]   - Field: ‘packages’
[16:20:36.104]   - Field: ‘gc’
[16:20:36.104]   - Field: ‘conditions’
[16:20:36.104]   - Field: ‘persistent’
[16:20:36.104]   - Field: ‘expr’
[16:20:36.104]   - Field: ‘uuid’
[16:20:36.104]   - Field: ‘seed’
[16:20:36.104]   - Field: ‘version’
[16:20:36.104]   - Field: ‘result’
[16:20:36.105]   - Field: ‘asynchronous’
[16:20:36.105]   - Field: ‘calls’
[16:20:36.105]   - Field: ‘globals’
[16:20:36.105]   - Field: ‘stdout’
[16:20:36.105]   - Field: ‘earlySignal’
[16:20:36.105]   - Field: ‘lazy’
[16:20:36.105]   - Field: ‘state’
[16:20:36.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:36.105] - Launch lazy future ...
[16:20:36.106] Packages needed by the future expression (n = 0): <none>
[16:20:36.106] Packages needed by future strategies (n = 0): <none>
[16:20:36.106] {
[16:20:36.106]     {
[16:20:36.106]         {
[16:20:36.106]             ...future.startTime <- base::Sys.time()
[16:20:36.106]             {
[16:20:36.106]                 {
[16:20:36.106]                   {
[16:20:36.106]                     {
[16:20:36.106]                       base::local({
[16:20:36.106]                         has_future <- base::requireNamespace("future", 
[16:20:36.106]                           quietly = TRUE)
[16:20:36.106]                         if (has_future) {
[16:20:36.106]                           ns <- base::getNamespace("future")
[16:20:36.106]                           version <- ns[[".package"]][["version"]]
[16:20:36.106]                           if (is.null(version)) 
[16:20:36.106]                             version <- utils::packageVersion("future")
[16:20:36.106]                         }
[16:20:36.106]                         else {
[16:20:36.106]                           version <- NULL
[16:20:36.106]                         }
[16:20:36.106]                         if (!has_future || version < "1.8.0") {
[16:20:36.106]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:36.106]                             "", base::R.version$version.string), 
[16:20:36.106]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:36.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:36.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:36.106]                               "release", "version")], collapse = " "), 
[16:20:36.106]                             hostname = base::Sys.info()[["nodename"]])
[16:20:36.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:36.106]                             info)
[16:20:36.106]                           info <- base::paste(info, collapse = "; ")
[16:20:36.106]                           if (!has_future) {
[16:20:36.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:36.106]                               info)
[16:20:36.106]                           }
[16:20:36.106]                           else {
[16:20:36.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:36.106]                               info, version)
[16:20:36.106]                           }
[16:20:36.106]                           base::stop(msg)
[16:20:36.106]                         }
[16:20:36.106]                       })
[16:20:36.106]                     }
[16:20:36.106]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:36.106]                     base::options(mc.cores = 1L)
[16:20:36.106]                   }
[16:20:36.106]                   ...future.strategy.old <- future::plan("list")
[16:20:36.106]                   options(future.plan = NULL)
[16:20:36.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:36.106]                 }
[16:20:36.106]                 ...future.workdir <- getwd()
[16:20:36.106]             }
[16:20:36.106]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:36.106]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:36.106]         }
[16:20:36.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:36.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:36.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:36.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:36.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:36.106]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:36.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:36.106]             base::names(...future.oldOptions))
[16:20:36.106]     }
[16:20:36.106]     if (FALSE) {
[16:20:36.106]     }
[16:20:36.106]     else {
[16:20:36.106]         if (TRUE) {
[16:20:36.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:36.106]                 open = "w")
[16:20:36.106]         }
[16:20:36.106]         else {
[16:20:36.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:36.106]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:36.106]         }
[16:20:36.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:36.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:36.106]             base::sink(type = "output", split = FALSE)
[16:20:36.106]             base::close(...future.stdout)
[16:20:36.106]         }, add = TRUE)
[16:20:36.106]     }
[16:20:36.106]     ...future.frame <- base::sys.nframe()
[16:20:36.106]     ...future.conditions <- base::list()
[16:20:36.106]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:36.106]     if (FALSE) {
[16:20:36.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:36.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:36.106]     }
[16:20:36.106]     ...future.result <- base::tryCatch({
[16:20:36.106]         base::withCallingHandlers({
[16:20:36.106]             ...future.value <- base::withVisible(base::local({
[16:20:36.106]                 ...future.makeSendCondition <- base::local({
[16:20:36.106]                   sendCondition <- NULL
[16:20:36.106]                   function(frame = 1L) {
[16:20:36.106]                     if (is.function(sendCondition)) 
[16:20:36.106]                       return(sendCondition)
[16:20:36.106]                     ns <- getNamespace("parallel")
[16:20:36.106]                     if (exists("sendData", mode = "function", 
[16:20:36.106]                       envir = ns)) {
[16:20:36.106]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:36.106]                         envir = ns)
[16:20:36.106]                       envir <- sys.frame(frame)
[16:20:36.106]                       master <- NULL
[16:20:36.106]                       while (!identical(envir, .GlobalEnv) && 
[16:20:36.106]                         !identical(envir, emptyenv())) {
[16:20:36.106]                         if (exists("master", mode = "list", envir = envir, 
[16:20:36.106]                           inherits = FALSE)) {
[16:20:36.106]                           master <- get("master", mode = "list", 
[16:20:36.106]                             envir = envir, inherits = FALSE)
[16:20:36.106]                           if (inherits(master, c("SOCKnode", 
[16:20:36.106]                             "SOCK0node"))) {
[16:20:36.106]                             sendCondition <<- function(cond) {
[16:20:36.106]                               data <- list(type = "VALUE", value = cond, 
[16:20:36.106]                                 success = TRUE)
[16:20:36.106]                               parallel_sendData(master, data)
[16:20:36.106]                             }
[16:20:36.106]                             return(sendCondition)
[16:20:36.106]                           }
[16:20:36.106]                         }
[16:20:36.106]                         frame <- frame + 1L
[16:20:36.106]                         envir <- sys.frame(frame)
[16:20:36.106]                       }
[16:20:36.106]                     }
[16:20:36.106]                     sendCondition <<- function(cond) NULL
[16:20:36.106]                   }
[16:20:36.106]                 })
[16:20:36.106]                 withCallingHandlers({
[16:20:36.106]                   {
[16:20:36.106]                     2 * a
[16:20:36.106]                   }
[16:20:36.106]                 }, immediateCondition = function(cond) {
[16:20:36.106]                   sendCondition <- ...future.makeSendCondition()
[16:20:36.106]                   sendCondition(cond)
[16:20:36.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.106]                   {
[16:20:36.106]                     inherits <- base::inherits
[16:20:36.106]                     invokeRestart <- base::invokeRestart
[16:20:36.106]                     is.null <- base::is.null
[16:20:36.106]                     muffled <- FALSE
[16:20:36.106]                     if (inherits(cond, "message")) {
[16:20:36.106]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:36.106]                       if (muffled) 
[16:20:36.106]                         invokeRestart("muffleMessage")
[16:20:36.106]                     }
[16:20:36.106]                     else if (inherits(cond, "warning")) {
[16:20:36.106]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:36.106]                       if (muffled) 
[16:20:36.106]                         invokeRestart("muffleWarning")
[16:20:36.106]                     }
[16:20:36.106]                     else if (inherits(cond, "condition")) {
[16:20:36.106]                       if (!is.null(pattern)) {
[16:20:36.106]                         computeRestarts <- base::computeRestarts
[16:20:36.106]                         grepl <- base::grepl
[16:20:36.106]                         restarts <- computeRestarts(cond)
[16:20:36.106]                         for (restart in restarts) {
[16:20:36.106]                           name <- restart$name
[16:20:36.106]                           if (is.null(name)) 
[16:20:36.106]                             next
[16:20:36.106]                           if (!grepl(pattern, name)) 
[16:20:36.106]                             next
[16:20:36.106]                           invokeRestart(restart)
[16:20:36.106]                           muffled <- TRUE
[16:20:36.106]                           break
[16:20:36.106]                         }
[16:20:36.106]                       }
[16:20:36.106]                     }
[16:20:36.106]                     invisible(muffled)
[16:20:36.106]                   }
[16:20:36.106]                   muffleCondition(cond)
[16:20:36.106]                 })
[16:20:36.106]             }))
[16:20:36.106]             future::FutureResult(value = ...future.value$value, 
[16:20:36.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.106]                   ...future.rng), globalenv = if (FALSE) 
[16:20:36.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:36.106]                     ...future.globalenv.names))
[16:20:36.106]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:36.106]         }, condition = base::local({
[16:20:36.106]             c <- base::c
[16:20:36.106]             inherits <- base::inherits
[16:20:36.106]             invokeRestart <- base::invokeRestart
[16:20:36.106]             length <- base::length
[16:20:36.106]             list <- base::list
[16:20:36.106]             seq.int <- base::seq.int
[16:20:36.106]             signalCondition <- base::signalCondition
[16:20:36.106]             sys.calls <- base::sys.calls
[16:20:36.106]             `[[` <- base::`[[`
[16:20:36.106]             `+` <- base::`+`
[16:20:36.106]             `<<-` <- base::`<<-`
[16:20:36.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:36.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:36.106]                   3L)]
[16:20:36.106]             }
[16:20:36.106]             function(cond) {
[16:20:36.106]                 is_error <- inherits(cond, "error")
[16:20:36.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:36.106]                   NULL)
[16:20:36.106]                 if (is_error) {
[16:20:36.106]                   sessionInformation <- function() {
[16:20:36.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:36.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:36.106]                       search = base::search(), system = base::Sys.info())
[16:20:36.106]                   }
[16:20:36.106]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:36.106]                     cond$call), session = sessionInformation(), 
[16:20:36.106]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:36.106]                   signalCondition(cond)
[16:20:36.106]                 }
[16:20:36.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:36.106]                 "immediateCondition"))) {
[16:20:36.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:36.106]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:36.106]                   if (TRUE && !signal) {
[16:20:36.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.106]                     {
[16:20:36.106]                       inherits <- base::inherits
[16:20:36.106]                       invokeRestart <- base::invokeRestart
[16:20:36.106]                       is.null <- base::is.null
[16:20:36.106]                       muffled <- FALSE
[16:20:36.106]                       if (inherits(cond, "message")) {
[16:20:36.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.106]                         if (muffled) 
[16:20:36.106]                           invokeRestart("muffleMessage")
[16:20:36.106]                       }
[16:20:36.106]                       else if (inherits(cond, "warning")) {
[16:20:36.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.106]                         if (muffled) 
[16:20:36.106]                           invokeRestart("muffleWarning")
[16:20:36.106]                       }
[16:20:36.106]                       else if (inherits(cond, "condition")) {
[16:20:36.106]                         if (!is.null(pattern)) {
[16:20:36.106]                           computeRestarts <- base::computeRestarts
[16:20:36.106]                           grepl <- base::grepl
[16:20:36.106]                           restarts <- computeRestarts(cond)
[16:20:36.106]                           for (restart in restarts) {
[16:20:36.106]                             name <- restart$name
[16:20:36.106]                             if (is.null(name)) 
[16:20:36.106]                               next
[16:20:36.106]                             if (!grepl(pattern, name)) 
[16:20:36.106]                               next
[16:20:36.106]                             invokeRestart(restart)
[16:20:36.106]                             muffled <- TRUE
[16:20:36.106]                             break
[16:20:36.106]                           }
[16:20:36.106]                         }
[16:20:36.106]                       }
[16:20:36.106]                       invisible(muffled)
[16:20:36.106]                     }
[16:20:36.106]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.106]                   }
[16:20:36.106]                 }
[16:20:36.106]                 else {
[16:20:36.106]                   if (TRUE) {
[16:20:36.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.106]                     {
[16:20:36.106]                       inherits <- base::inherits
[16:20:36.106]                       invokeRestart <- base::invokeRestart
[16:20:36.106]                       is.null <- base::is.null
[16:20:36.106]                       muffled <- FALSE
[16:20:36.106]                       if (inherits(cond, "message")) {
[16:20:36.106]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.106]                         if (muffled) 
[16:20:36.106]                           invokeRestart("muffleMessage")
[16:20:36.106]                       }
[16:20:36.106]                       else if (inherits(cond, "warning")) {
[16:20:36.106]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.106]                         if (muffled) 
[16:20:36.106]                           invokeRestart("muffleWarning")
[16:20:36.106]                       }
[16:20:36.106]                       else if (inherits(cond, "condition")) {
[16:20:36.106]                         if (!is.null(pattern)) {
[16:20:36.106]                           computeRestarts <- base::computeRestarts
[16:20:36.106]                           grepl <- base::grepl
[16:20:36.106]                           restarts <- computeRestarts(cond)
[16:20:36.106]                           for (restart in restarts) {
[16:20:36.106]                             name <- restart$name
[16:20:36.106]                             if (is.null(name)) 
[16:20:36.106]                               next
[16:20:36.106]                             if (!grepl(pattern, name)) 
[16:20:36.106]                               next
[16:20:36.106]                             invokeRestart(restart)
[16:20:36.106]                             muffled <- TRUE
[16:20:36.106]                             break
[16:20:36.106]                           }
[16:20:36.106]                         }
[16:20:36.106]                       }
[16:20:36.106]                       invisible(muffled)
[16:20:36.106]                     }
[16:20:36.106]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.106]                   }
[16:20:36.106]                 }
[16:20:36.106]             }
[16:20:36.106]         }))
[16:20:36.106]     }, error = function(ex) {
[16:20:36.106]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:36.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.106]                 ...future.rng), started = ...future.startTime, 
[16:20:36.106]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:36.106]             version = "1.8"), class = "FutureResult")
[16:20:36.106]     }, finally = {
[16:20:36.106]         if (!identical(...future.workdir, getwd())) 
[16:20:36.106]             setwd(...future.workdir)
[16:20:36.106]         {
[16:20:36.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:36.106]                 ...future.oldOptions$nwarnings <- NULL
[16:20:36.106]             }
[16:20:36.106]             base::options(...future.oldOptions)
[16:20:36.106]             if (.Platform$OS.type == "windows") {
[16:20:36.106]                 old_names <- names(...future.oldEnvVars)
[16:20:36.106]                 envs <- base::Sys.getenv()
[16:20:36.106]                 names <- names(envs)
[16:20:36.106]                 common <- intersect(names, old_names)
[16:20:36.106]                 added <- setdiff(names, old_names)
[16:20:36.106]                 removed <- setdiff(old_names, names)
[16:20:36.106]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:36.106]                   envs[common]]
[16:20:36.106]                 NAMES <- toupper(changed)
[16:20:36.106]                 args <- list()
[16:20:36.106]                 for (kk in seq_along(NAMES)) {
[16:20:36.106]                   name <- changed[[kk]]
[16:20:36.106]                   NAME <- NAMES[[kk]]
[16:20:36.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.106]                     next
[16:20:36.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.106]                 }
[16:20:36.106]                 NAMES <- toupper(added)
[16:20:36.106]                 for (kk in seq_along(NAMES)) {
[16:20:36.106]                   name <- added[[kk]]
[16:20:36.106]                   NAME <- NAMES[[kk]]
[16:20:36.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.106]                     next
[16:20:36.106]                   args[[name]] <- ""
[16:20:36.106]                 }
[16:20:36.106]                 NAMES <- toupper(removed)
[16:20:36.106]                 for (kk in seq_along(NAMES)) {
[16:20:36.106]                   name <- removed[[kk]]
[16:20:36.106]                   NAME <- NAMES[[kk]]
[16:20:36.106]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.106]                     next
[16:20:36.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.106]                 }
[16:20:36.106]                 if (length(args) > 0) 
[16:20:36.106]                   base::do.call(base::Sys.setenv, args = args)
[16:20:36.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:36.106]             }
[16:20:36.106]             else {
[16:20:36.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:36.106]             }
[16:20:36.106]             {
[16:20:36.106]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:36.106]                   0L) {
[16:20:36.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:36.106]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:36.106]                   base::options(opts)
[16:20:36.106]                 }
[16:20:36.106]                 {
[16:20:36.106]                   {
[16:20:36.106]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:36.106]                     NULL
[16:20:36.106]                   }
[16:20:36.106]                   options(future.plan = NULL)
[16:20:36.106]                   if (is.na(NA_character_)) 
[16:20:36.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:36.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:36.106]                     .init = FALSE)
[16:20:36.106]                 }
[16:20:36.106]             }
[16:20:36.106]         }
[16:20:36.106]     })
[16:20:36.106]     if (TRUE) {
[16:20:36.106]         base::sink(type = "output", split = FALSE)
[16:20:36.106]         if (TRUE) {
[16:20:36.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:36.106]         }
[16:20:36.106]         else {
[16:20:36.106]             ...future.result["stdout"] <- base::list(NULL)
[16:20:36.106]         }
[16:20:36.106]         base::close(...future.stdout)
[16:20:36.106]         ...future.stdout <- NULL
[16:20:36.106]     }
[16:20:36.106]     ...future.result$conditions <- ...future.conditions
[16:20:36.106]     ...future.result$finished <- base::Sys.time()
[16:20:36.106]     ...future.result
[16:20:36.106] }
[16:20:36.108] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:36.109] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:36.109] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:36.109] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:36.109] MultisessionFuture started
[16:20:36.110] - Launch lazy future ... done
[16:20:36.110] run() for ‘MultisessionFuture’ ... done
[16:20:36.110] result() for ClusterFuture ...
[16:20:36.110] receiveMessageFromWorker() for ClusterFuture ...
[16:20:36.110] - Validating connection of MultisessionFuture
[16:20:36.111] - received message: FutureResult
[16:20:36.111] - Received FutureResult
[16:20:36.111] - Erased future from FutureRegistry
[16:20:36.111] result() for ClusterFuture ...
[16:20:36.111] - result already collected: FutureResult
[16:20:36.111] result() for ClusterFuture ... done
[16:20:36.111] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:36.112] result() for ClusterFuture ... done
[16:20:36.112] result() for ClusterFuture ...
[16:20:36.112] - result already collected: FutureResult
[16:20:36.112] result() for ClusterFuture ... done
[16:20:36.112] getGlobalsAndPackages() ...
[16:20:36.112] Searching for globals...
[16:20:36.113] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:20:36.113] Searching for globals ... DONE
[16:20:36.113] Resolving globals: FALSE
[16:20:36.113] The total size of the 1 globals is 56 bytes (56 bytes)
[16:20:36.114] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:20:36.114] - globals: [1] ‘a’
[16:20:36.114] 
[16:20:36.114] getGlobalsAndPackages() ... DONE
[16:20:36.114] run() for ‘Future’ ...
[16:20:36.114] - state: ‘created’
[16:20:36.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:20:36.128] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:20:36.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:20:36.128]   - Field: ‘node’
[16:20:36.128]   - Field: ‘label’
[16:20:36.128]   - Field: ‘local’
[16:20:36.128]   - Field: ‘owner’
[16:20:36.128]   - Field: ‘envir’
[16:20:36.129]   - Field: ‘workers’
[16:20:36.129]   - Field: ‘packages’
[16:20:36.129]   - Field: ‘gc’
[16:20:36.129]   - Field: ‘conditions’
[16:20:36.129]   - Field: ‘persistent’
[16:20:36.129]   - Field: ‘expr’
[16:20:36.129]   - Field: ‘uuid’
[16:20:36.129]   - Field: ‘seed’
[16:20:36.129]   - Field: ‘version’
[16:20:36.129]   - Field: ‘result’
[16:20:36.129]   - Field: ‘asynchronous’
[16:20:36.130]   - Field: ‘calls’
[16:20:36.130]   - Field: ‘globals’
[16:20:36.130]   - Field: ‘stdout’
[16:20:36.130]   - Field: ‘earlySignal’
[16:20:36.130]   - Field: ‘lazy’
[16:20:36.130]   - Field: ‘state’
[16:20:36.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:20:36.130] - Launch lazy future ...
[16:20:36.130] Packages needed by the future expression (n = 0): <none>
[16:20:36.131] Packages needed by future strategies (n = 0): <none>
[16:20:36.131] {
[16:20:36.131]     {
[16:20:36.131]         {
[16:20:36.131]             ...future.startTime <- base::Sys.time()
[16:20:36.131]             {
[16:20:36.131]                 {
[16:20:36.131]                   {
[16:20:36.131]                     {
[16:20:36.131]                       base::local({
[16:20:36.131]                         has_future <- base::requireNamespace("future", 
[16:20:36.131]                           quietly = TRUE)
[16:20:36.131]                         if (has_future) {
[16:20:36.131]                           ns <- base::getNamespace("future")
[16:20:36.131]                           version <- ns[[".package"]][["version"]]
[16:20:36.131]                           if (is.null(version)) 
[16:20:36.131]                             version <- utils::packageVersion("future")
[16:20:36.131]                         }
[16:20:36.131]                         else {
[16:20:36.131]                           version <- NULL
[16:20:36.131]                         }
[16:20:36.131]                         if (!has_future || version < "1.8.0") {
[16:20:36.131]                           info <- base::c(r_version = base::gsub("R version ", 
[16:20:36.131]                             "", base::R.version$version.string), 
[16:20:36.131]                             platform = base::sprintf("%s (%s-bit)", 
[16:20:36.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:20:36.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:20:36.131]                               "release", "version")], collapse = " "), 
[16:20:36.131]                             hostname = base::Sys.info()[["nodename"]])
[16:20:36.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:20:36.131]                             info)
[16:20:36.131]                           info <- base::paste(info, collapse = "; ")
[16:20:36.131]                           if (!has_future) {
[16:20:36.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:20:36.131]                               info)
[16:20:36.131]                           }
[16:20:36.131]                           else {
[16:20:36.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:20:36.131]                               info, version)
[16:20:36.131]                           }
[16:20:36.131]                           base::stop(msg)
[16:20:36.131]                         }
[16:20:36.131]                       })
[16:20:36.131]                     }
[16:20:36.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:20:36.131]                     base::options(mc.cores = 1L)
[16:20:36.131]                   }
[16:20:36.131]                   ...future.strategy.old <- future::plan("list")
[16:20:36.131]                   options(future.plan = NULL)
[16:20:36.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:20:36.131]                 }
[16:20:36.131]                 ...future.workdir <- getwd()
[16:20:36.131]             }
[16:20:36.131]             ...future.oldOptions <- base::as.list(base::.Options)
[16:20:36.131]             ...future.oldEnvVars <- base::Sys.getenv()
[16:20:36.131]         }
[16:20:36.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:20:36.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:20:36.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:20:36.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:20:36.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:20:36.131]             future.stdout.windows.reencode = NULL, width = 80L)
[16:20:36.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:20:36.131]             base::names(...future.oldOptions))
[16:20:36.131]     }
[16:20:36.131]     if (FALSE) {
[16:20:36.131]     }
[16:20:36.131]     else {
[16:20:36.131]         if (TRUE) {
[16:20:36.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:20:36.131]                 open = "w")
[16:20:36.131]         }
[16:20:36.131]         else {
[16:20:36.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:20:36.131]                 windows = "NUL", "/dev/null"), open = "w")
[16:20:36.131]         }
[16:20:36.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:20:36.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:20:36.131]             base::sink(type = "output", split = FALSE)
[16:20:36.131]             base::close(...future.stdout)
[16:20:36.131]         }, add = TRUE)
[16:20:36.131]     }
[16:20:36.131]     ...future.frame <- base::sys.nframe()
[16:20:36.131]     ...future.conditions <- base::list()
[16:20:36.131]     ...future.rng <- base::globalenv()$.Random.seed
[16:20:36.131]     if (FALSE) {
[16:20:36.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:20:36.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:20:36.131]     }
[16:20:36.131]     ...future.result <- base::tryCatch({
[16:20:36.131]         base::withCallingHandlers({
[16:20:36.131]             ...future.value <- base::withVisible(base::local({
[16:20:36.131]                 ...future.makeSendCondition <- base::local({
[16:20:36.131]                   sendCondition <- NULL
[16:20:36.131]                   function(frame = 1L) {
[16:20:36.131]                     if (is.function(sendCondition)) 
[16:20:36.131]                       return(sendCondition)
[16:20:36.131]                     ns <- getNamespace("parallel")
[16:20:36.131]                     if (exists("sendData", mode = "function", 
[16:20:36.131]                       envir = ns)) {
[16:20:36.131]                       parallel_sendData <- get("sendData", mode = "function", 
[16:20:36.131]                         envir = ns)
[16:20:36.131]                       envir <- sys.frame(frame)
[16:20:36.131]                       master <- NULL
[16:20:36.131]                       while (!identical(envir, .GlobalEnv) && 
[16:20:36.131]                         !identical(envir, emptyenv())) {
[16:20:36.131]                         if (exists("master", mode = "list", envir = envir, 
[16:20:36.131]                           inherits = FALSE)) {
[16:20:36.131]                           master <- get("master", mode = "list", 
[16:20:36.131]                             envir = envir, inherits = FALSE)
[16:20:36.131]                           if (inherits(master, c("SOCKnode", 
[16:20:36.131]                             "SOCK0node"))) {
[16:20:36.131]                             sendCondition <<- function(cond) {
[16:20:36.131]                               data <- list(type = "VALUE", value = cond, 
[16:20:36.131]                                 success = TRUE)
[16:20:36.131]                               parallel_sendData(master, data)
[16:20:36.131]                             }
[16:20:36.131]                             return(sendCondition)
[16:20:36.131]                           }
[16:20:36.131]                         }
[16:20:36.131]                         frame <- frame + 1L
[16:20:36.131]                         envir <- sys.frame(frame)
[16:20:36.131]                       }
[16:20:36.131]                     }
[16:20:36.131]                     sendCondition <<- function(cond) NULL
[16:20:36.131]                   }
[16:20:36.131]                 })
[16:20:36.131]                 withCallingHandlers({
[16:20:36.131]                   {
[16:20:36.131]                     2 * a
[16:20:36.131]                   }
[16:20:36.131]                 }, immediateCondition = function(cond) {
[16:20:36.131]                   sendCondition <- ...future.makeSendCondition()
[16:20:36.131]                   sendCondition(cond)
[16:20:36.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.131]                   {
[16:20:36.131]                     inherits <- base::inherits
[16:20:36.131]                     invokeRestart <- base::invokeRestart
[16:20:36.131]                     is.null <- base::is.null
[16:20:36.131]                     muffled <- FALSE
[16:20:36.131]                     if (inherits(cond, "message")) {
[16:20:36.131]                       muffled <- grepl(pattern, "muffleMessage")
[16:20:36.131]                       if (muffled) 
[16:20:36.131]                         invokeRestart("muffleMessage")
[16:20:36.131]                     }
[16:20:36.131]                     else if (inherits(cond, "warning")) {
[16:20:36.131]                       muffled <- grepl(pattern, "muffleWarning")
[16:20:36.131]                       if (muffled) 
[16:20:36.131]                         invokeRestart("muffleWarning")
[16:20:36.131]                     }
[16:20:36.131]                     else if (inherits(cond, "condition")) {
[16:20:36.131]                       if (!is.null(pattern)) {
[16:20:36.131]                         computeRestarts <- base::computeRestarts
[16:20:36.131]                         grepl <- base::grepl
[16:20:36.131]                         restarts <- computeRestarts(cond)
[16:20:36.131]                         for (restart in restarts) {
[16:20:36.131]                           name <- restart$name
[16:20:36.131]                           if (is.null(name)) 
[16:20:36.131]                             next
[16:20:36.131]                           if (!grepl(pattern, name)) 
[16:20:36.131]                             next
[16:20:36.131]                           invokeRestart(restart)
[16:20:36.131]                           muffled <- TRUE
[16:20:36.131]                           break
[16:20:36.131]                         }
[16:20:36.131]                       }
[16:20:36.131]                     }
[16:20:36.131]                     invisible(muffled)
[16:20:36.131]                   }
[16:20:36.131]                   muffleCondition(cond)
[16:20:36.131]                 })
[16:20:36.131]             }))
[16:20:36.131]             future::FutureResult(value = ...future.value$value, 
[16:20:36.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.131]                   ...future.rng), globalenv = if (FALSE) 
[16:20:36.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:20:36.131]                     ...future.globalenv.names))
[16:20:36.131]                 else NULL, started = ...future.startTime, version = "1.8")
[16:20:36.131]         }, condition = base::local({
[16:20:36.131]             c <- base::c
[16:20:36.131]             inherits <- base::inherits
[16:20:36.131]             invokeRestart <- base::invokeRestart
[16:20:36.131]             length <- base::length
[16:20:36.131]             list <- base::list
[16:20:36.131]             seq.int <- base::seq.int
[16:20:36.131]             signalCondition <- base::signalCondition
[16:20:36.131]             sys.calls <- base::sys.calls
[16:20:36.131]             `[[` <- base::`[[`
[16:20:36.131]             `+` <- base::`+`
[16:20:36.131]             `<<-` <- base::`<<-`
[16:20:36.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:20:36.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:20:36.131]                   3L)]
[16:20:36.131]             }
[16:20:36.131]             function(cond) {
[16:20:36.131]                 is_error <- inherits(cond, "error")
[16:20:36.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:20:36.131]                   NULL)
[16:20:36.131]                 if (is_error) {
[16:20:36.131]                   sessionInformation <- function() {
[16:20:36.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:20:36.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:20:36.131]                       search = base::search(), system = base::Sys.info())
[16:20:36.131]                   }
[16:20:36.131]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:20:36.131]                     cond$call), session = sessionInformation(), 
[16:20:36.131]                     timestamp = base::Sys.time(), signaled = 0L)
[16:20:36.131]                   signalCondition(cond)
[16:20:36.131]                 }
[16:20:36.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:20:36.131]                 "immediateCondition"))) {
[16:20:36.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:20:36.131]                   ...future.conditions[[length(...future.conditions) + 
[16:20:36.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:20:36.131]                   if (TRUE && !signal) {
[16:20:36.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.131]                     {
[16:20:36.131]                       inherits <- base::inherits
[16:20:36.131]                       invokeRestart <- base::invokeRestart
[16:20:36.131]                       is.null <- base::is.null
[16:20:36.131]                       muffled <- FALSE
[16:20:36.131]                       if (inherits(cond, "message")) {
[16:20:36.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.131]                         if (muffled) 
[16:20:36.131]                           invokeRestart("muffleMessage")
[16:20:36.131]                       }
[16:20:36.131]                       else if (inherits(cond, "warning")) {
[16:20:36.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.131]                         if (muffled) 
[16:20:36.131]                           invokeRestart("muffleWarning")
[16:20:36.131]                       }
[16:20:36.131]                       else if (inherits(cond, "condition")) {
[16:20:36.131]                         if (!is.null(pattern)) {
[16:20:36.131]                           computeRestarts <- base::computeRestarts
[16:20:36.131]                           grepl <- base::grepl
[16:20:36.131]                           restarts <- computeRestarts(cond)
[16:20:36.131]                           for (restart in restarts) {
[16:20:36.131]                             name <- restart$name
[16:20:36.131]                             if (is.null(name)) 
[16:20:36.131]                               next
[16:20:36.131]                             if (!grepl(pattern, name)) 
[16:20:36.131]                               next
[16:20:36.131]                             invokeRestart(restart)
[16:20:36.131]                             muffled <- TRUE
[16:20:36.131]                             break
[16:20:36.131]                           }
[16:20:36.131]                         }
[16:20:36.131]                       }
[16:20:36.131]                       invisible(muffled)
[16:20:36.131]                     }
[16:20:36.131]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.131]                   }
[16:20:36.131]                 }
[16:20:36.131]                 else {
[16:20:36.131]                   if (TRUE) {
[16:20:36.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:20:36.131]                     {
[16:20:36.131]                       inherits <- base::inherits
[16:20:36.131]                       invokeRestart <- base::invokeRestart
[16:20:36.131]                       is.null <- base::is.null
[16:20:36.131]                       muffled <- FALSE
[16:20:36.131]                       if (inherits(cond, "message")) {
[16:20:36.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:20:36.131]                         if (muffled) 
[16:20:36.131]                           invokeRestart("muffleMessage")
[16:20:36.131]                       }
[16:20:36.131]                       else if (inherits(cond, "warning")) {
[16:20:36.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:20:36.131]                         if (muffled) 
[16:20:36.131]                           invokeRestart("muffleWarning")
[16:20:36.131]                       }
[16:20:36.131]                       else if (inherits(cond, "condition")) {
[16:20:36.131]                         if (!is.null(pattern)) {
[16:20:36.131]                           computeRestarts <- base::computeRestarts
[16:20:36.131]                           grepl <- base::grepl
[16:20:36.131]                           restarts <- computeRestarts(cond)
[16:20:36.131]                           for (restart in restarts) {
[16:20:36.131]                             name <- restart$name
[16:20:36.131]                             if (is.null(name)) 
[16:20:36.131]                               next
[16:20:36.131]                             if (!grepl(pattern, name)) 
[16:20:36.131]                               next
[16:20:36.131]                             invokeRestart(restart)
[16:20:36.131]                             muffled <- TRUE
[16:20:36.131]                             break
[16:20:36.131]                           }
[16:20:36.131]                         }
[16:20:36.131]                       }
[16:20:36.131]                       invisible(muffled)
[16:20:36.131]                     }
[16:20:36.131]                     muffleCondition(cond, pattern = "^muffle")
[16:20:36.131]                   }
[16:20:36.131]                 }
[16:20:36.131]             }
[16:20:36.131]         }))
[16:20:36.131]     }, error = function(ex) {
[16:20:36.131]         base::structure(base::list(value = NULL, visible = NULL, 
[16:20:36.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:20:36.131]                 ...future.rng), started = ...future.startTime, 
[16:20:36.131]             finished = Sys.time(), session_uuid = NA_character_, 
[16:20:36.131]             version = "1.8"), class = "FutureResult")
[16:20:36.131]     }, finally = {
[16:20:36.131]         if (!identical(...future.workdir, getwd())) 
[16:20:36.131]             setwd(...future.workdir)
[16:20:36.131]         {
[16:20:36.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:20:36.131]                 ...future.oldOptions$nwarnings <- NULL
[16:20:36.131]             }
[16:20:36.131]             base::options(...future.oldOptions)
[16:20:36.131]             if (.Platform$OS.type == "windows") {
[16:20:36.131]                 old_names <- names(...future.oldEnvVars)
[16:20:36.131]                 envs <- base::Sys.getenv()
[16:20:36.131]                 names <- names(envs)
[16:20:36.131]                 common <- intersect(names, old_names)
[16:20:36.131]                 added <- setdiff(names, old_names)
[16:20:36.131]                 removed <- setdiff(old_names, names)
[16:20:36.131]                 changed <- common[...future.oldEnvVars[common] != 
[16:20:36.131]                   envs[common]]
[16:20:36.131]                 NAMES <- toupper(changed)
[16:20:36.131]                 args <- list()
[16:20:36.131]                 for (kk in seq_along(NAMES)) {
[16:20:36.131]                   name <- changed[[kk]]
[16:20:36.131]                   NAME <- NAMES[[kk]]
[16:20:36.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.131]                     next
[16:20:36.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.131]                 }
[16:20:36.131]                 NAMES <- toupper(added)
[16:20:36.131]                 for (kk in seq_along(NAMES)) {
[16:20:36.131]                   name <- added[[kk]]
[16:20:36.131]                   NAME <- NAMES[[kk]]
[16:20:36.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.131]                     next
[16:20:36.131]                   args[[name]] <- ""
[16:20:36.131]                 }
[16:20:36.131]                 NAMES <- toupper(removed)
[16:20:36.131]                 for (kk in seq_along(NAMES)) {
[16:20:36.131]                   name <- removed[[kk]]
[16:20:36.131]                   NAME <- NAMES[[kk]]
[16:20:36.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:20:36.131]                     next
[16:20:36.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:20:36.131]                 }
[16:20:36.131]                 if (length(args) > 0) 
[16:20:36.131]                   base::do.call(base::Sys.setenv, args = args)
[16:20:36.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:20:36.131]             }
[16:20:36.131]             else {
[16:20:36.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:20:36.131]             }
[16:20:36.131]             {
[16:20:36.131]                 if (base::length(...future.futureOptionsAdded) > 
[16:20:36.131]                   0L) {
[16:20:36.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:20:36.131]                   base::names(opts) <- ...future.futureOptionsAdded
[16:20:36.131]                   base::options(opts)
[16:20:36.131]                 }
[16:20:36.131]                 {
[16:20:36.131]                   {
[16:20:36.131]                     base::options(mc.cores = ...future.mc.cores.old)
[16:20:36.131]                     NULL
[16:20:36.131]                   }
[16:20:36.131]                   options(future.plan = NULL)
[16:20:36.131]                   if (is.na(NA_character_)) 
[16:20:36.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:20:36.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:20:36.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:20:36.131]                     .init = FALSE)
[16:20:36.131]                 }
[16:20:36.131]             }
[16:20:36.131]         }
[16:20:36.131]     })
[16:20:36.131]     if (TRUE) {
[16:20:36.131]         base::sink(type = "output", split = FALSE)
[16:20:36.131]         if (TRUE) {
[16:20:36.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:20:36.131]         }
[16:20:36.131]         else {
[16:20:36.131]             ...future.result["stdout"] <- base::list(NULL)
[16:20:36.131]         }
[16:20:36.131]         base::close(...future.stdout)
[16:20:36.131]         ...future.stdout <- NULL
[16:20:36.131]     }
[16:20:36.131]     ...future.result$conditions <- ...future.conditions
[16:20:36.131]     ...future.result$finished <- base::Sys.time()
[16:20:36.131]     ...future.result
[16:20:36.131] }
[16:20:36.133] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:20:36.133] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:20:36.134] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:20:36.134] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:20:36.134] MultisessionFuture started
[16:20:36.134] - Launch lazy future ... done
[16:20:36.135] run() for ‘MultisessionFuture’ ... done
[16:20:36.135] result() for ClusterFuture ...
[16:20:36.135] receiveMessageFromWorker() for ClusterFuture ...
[16:20:36.135] - Validating connection of MultisessionFuture
[16:20:36.136] - received message: FutureResult
[16:20:36.136] - Received FutureResult
[16:20:36.136] - Erased future from FutureRegistry
[16:20:36.136] result() for ClusterFuture ...
[16:20:36.136] - result already collected: FutureResult
[16:20:36.136] result() for ClusterFuture ... done
[16:20:36.136] receiveMessageFromWorker() for ClusterFuture ... done
[16:20:36.136] result() for ClusterFuture ... done
[16:20:36.136] result() for ClusterFuture ...
[16:20:36.137] - result already collected: FutureResult
[16:20:36.137] result() for ClusterFuture ... done
*** futureAssign() with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ... DONE")
*** futureAssign() - lazy = TRUE / FALSE ... DONE
> 
> message("*** futureAssign() ... DONE")
*** futureAssign() ... DONE
> 
> source("incl/end.R")
[16:20:36.137] plan(): Setting new future strategy stack:
[16:20:36.138] List of future strategies:
[16:20:36.138] 1. FutureStrategy:
[16:20:36.138]    - args: function (..., envir = parent.frame())
[16:20:36.138]    - tweaked: FALSE
[16:20:36.138]    - call: future::plan(oplan)
[16:20:36.138] plan(): nbrOfWorkers() = 1
> 
