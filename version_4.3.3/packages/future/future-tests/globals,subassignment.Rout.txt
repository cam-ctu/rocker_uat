
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:33:07.635] plan(): Setting new future strategy stack:
[10:33:07.636] List of future strategies:
[10:33:07.636] 1. sequential:
[10:33:07.636]    - args: function (..., envir = parent.frame())
[10:33:07.636]    - tweaked: FALSE
[10:33:07.636]    - call: future::plan("sequential")
[10:33:07.650] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[10:33:07.717] plan(): Setting new future strategy stack:
[10:33:07.717] List of future strategies:
[10:33:07.717] 1. sequential:
[10:33:07.717]    - args: function (..., envir = parent.frame())
[10:33:07.717]    - tweaked: FALSE
[10:33:07.717]    - call: plan(strategy)
[10:33:07.728] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.729] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.729] Searching for globals...
[10:33:07.736] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.737] Searching for globals ... DONE
[10:33:07.737] Resolving globals: TRUE
[10:33:07.737] Resolving any globals that are futures ...
[10:33:07.737] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.737] Resolving any globals that are futures ... DONE
[10:33:07.738] Resolving futures part of globals (recursively) ...
[10:33:07.738] resolve() on list ...
[10:33:07.739]  recursive: 99
[10:33:07.739]  length: 1
[10:33:07.739]  elements: ‘x’
[10:33:07.739]  length: 0 (resolved future 1)
[10:33:07.739] resolve() on list ... DONE
[10:33:07.739] - globals: [1] ‘x’
[10:33:07.739] Resolving futures part of globals (recursively) ... DONE
[10:33:07.740] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.740] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.740] - globals: [1] ‘x’
[10:33:07.741] 
[10:33:07.741] getGlobalsAndPackages() ... DONE
[10:33:07.741] run() for ‘Future’ ...
[10:33:07.742] - state: ‘created’
[10:33:07.742] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.742] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.742] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.742]   - Field: ‘label’
[10:33:07.742]   - Field: ‘local’
[10:33:07.743]   - Field: ‘owner’
[10:33:07.743]   - Field: ‘envir’
[10:33:07.743]   - Field: ‘packages’
[10:33:07.743]   - Field: ‘gc’
[10:33:07.743]   - Field: ‘conditions’
[10:33:07.743]   - Field: ‘expr’
[10:33:07.743]   - Field: ‘uuid’
[10:33:07.743]   - Field: ‘seed’
[10:33:07.743]   - Field: ‘version’
[10:33:07.743]   - Field: ‘result’
[10:33:07.743]   - Field: ‘asynchronous’
[10:33:07.744]   - Field: ‘calls’
[10:33:07.744]   - Field: ‘globals’
[10:33:07.744]   - Field: ‘stdout’
[10:33:07.744]   - Field: ‘earlySignal’
[10:33:07.744]   - Field: ‘lazy’
[10:33:07.744]   - Field: ‘state’
[10:33:07.744] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.744] - Launch lazy future ...
[10:33:07.747] Packages needed by the future expression (n = 0): <none>
[10:33:07.747] Packages needed by future strategies (n = 0): <none>
[10:33:07.748] {
[10:33:07.748]     {
[10:33:07.748]         {
[10:33:07.748]             ...future.startTime <- base::Sys.time()
[10:33:07.748]             {
[10:33:07.748]                 {
[10:33:07.748]                   {
[10:33:07.748]                     base::local({
[10:33:07.748]                       has_future <- base::requireNamespace("future", 
[10:33:07.748]                         quietly = TRUE)
[10:33:07.748]                       if (has_future) {
[10:33:07.748]                         ns <- base::getNamespace("future")
[10:33:07.748]                         version <- ns[[".package"]][["version"]]
[10:33:07.748]                         if (is.null(version)) 
[10:33:07.748]                           version <- utils::packageVersion("future")
[10:33:07.748]                       }
[10:33:07.748]                       else {
[10:33:07.748]                         version <- NULL
[10:33:07.748]                       }
[10:33:07.748]                       if (!has_future || version < "1.8.0") {
[10:33:07.748]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.748]                           "", base::R.version$version.string), 
[10:33:07.748]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.748]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.748]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.748]                             "release", "version")], collapse = " "), 
[10:33:07.748]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.748]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.748]                           info)
[10:33:07.748]                         info <- base::paste(info, collapse = "; ")
[10:33:07.748]                         if (!has_future) {
[10:33:07.748]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.748]                             info)
[10:33:07.748]                         }
[10:33:07.748]                         else {
[10:33:07.748]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.748]                             info, version)
[10:33:07.748]                         }
[10:33:07.748]                         base::stop(msg)
[10:33:07.748]                       }
[10:33:07.748]                     })
[10:33:07.748]                   }
[10:33:07.748]                   ...future.strategy.old <- future::plan("list")
[10:33:07.748]                   options(future.plan = NULL)
[10:33:07.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.748]                 }
[10:33:07.748]                 ...future.workdir <- getwd()
[10:33:07.748]             }
[10:33:07.748]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.748]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.748]         }
[10:33:07.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.748]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.748]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.748]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.748]             base::names(...future.oldOptions))
[10:33:07.748]     }
[10:33:07.748]     if (FALSE) {
[10:33:07.748]     }
[10:33:07.748]     else {
[10:33:07.748]         if (TRUE) {
[10:33:07.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.748]                 open = "w")
[10:33:07.748]         }
[10:33:07.748]         else {
[10:33:07.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.748]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.748]         }
[10:33:07.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.748]             base::sink(type = "output", split = FALSE)
[10:33:07.748]             base::close(...future.stdout)
[10:33:07.748]         }, add = TRUE)
[10:33:07.748]     }
[10:33:07.748]     ...future.frame <- base::sys.nframe()
[10:33:07.748]     ...future.conditions <- base::list()
[10:33:07.748]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.748]     if (FALSE) {
[10:33:07.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.748]     }
[10:33:07.748]     ...future.result <- base::tryCatch({
[10:33:07.748]         base::withCallingHandlers({
[10:33:07.748]             ...future.value <- base::withVisible(base::local({
[10:33:07.748]                 x$a <- 1
[10:33:07.748]                 x
[10:33:07.748]             }))
[10:33:07.748]             future::FutureResult(value = ...future.value$value, 
[10:33:07.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.748]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.748]                     ...future.globalenv.names))
[10:33:07.748]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.748]         }, condition = base::local({
[10:33:07.748]             c <- base::c
[10:33:07.748]             inherits <- base::inherits
[10:33:07.748]             invokeRestart <- base::invokeRestart
[10:33:07.748]             length <- base::length
[10:33:07.748]             list <- base::list
[10:33:07.748]             seq.int <- base::seq.int
[10:33:07.748]             signalCondition <- base::signalCondition
[10:33:07.748]             sys.calls <- base::sys.calls
[10:33:07.748]             `[[` <- base::`[[`
[10:33:07.748]             `+` <- base::`+`
[10:33:07.748]             `<<-` <- base::`<<-`
[10:33:07.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.748]                   3L)]
[10:33:07.748]             }
[10:33:07.748]             function(cond) {
[10:33:07.748]                 is_error <- inherits(cond, "error")
[10:33:07.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.748]                   NULL)
[10:33:07.748]                 if (is_error) {
[10:33:07.748]                   sessionInformation <- function() {
[10:33:07.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.748]                       search = base::search(), system = base::Sys.info())
[10:33:07.748]                   }
[10:33:07.748]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.748]                     cond$call), session = sessionInformation(), 
[10:33:07.748]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.748]                   signalCondition(cond)
[10:33:07.748]                 }
[10:33:07.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.748]                 "immediateCondition"))) {
[10:33:07.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.748]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.748]                   if (TRUE && !signal) {
[10:33:07.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.748]                     {
[10:33:07.748]                       inherits <- base::inherits
[10:33:07.748]                       invokeRestart <- base::invokeRestart
[10:33:07.748]                       is.null <- base::is.null
[10:33:07.748]                       muffled <- FALSE
[10:33:07.748]                       if (inherits(cond, "message")) {
[10:33:07.748]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.748]                         if (muffled) 
[10:33:07.748]                           invokeRestart("muffleMessage")
[10:33:07.748]                       }
[10:33:07.748]                       else if (inherits(cond, "warning")) {
[10:33:07.748]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.748]                         if (muffled) 
[10:33:07.748]                           invokeRestart("muffleWarning")
[10:33:07.748]                       }
[10:33:07.748]                       else if (inherits(cond, "condition")) {
[10:33:07.748]                         if (!is.null(pattern)) {
[10:33:07.748]                           computeRestarts <- base::computeRestarts
[10:33:07.748]                           grepl <- base::grepl
[10:33:07.748]                           restarts <- computeRestarts(cond)
[10:33:07.748]                           for (restart in restarts) {
[10:33:07.748]                             name <- restart$name
[10:33:07.748]                             if (is.null(name)) 
[10:33:07.748]                               next
[10:33:07.748]                             if (!grepl(pattern, name)) 
[10:33:07.748]                               next
[10:33:07.748]                             invokeRestart(restart)
[10:33:07.748]                             muffled <- TRUE
[10:33:07.748]                             break
[10:33:07.748]                           }
[10:33:07.748]                         }
[10:33:07.748]                       }
[10:33:07.748]                       invisible(muffled)
[10:33:07.748]                     }
[10:33:07.748]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.748]                   }
[10:33:07.748]                 }
[10:33:07.748]                 else {
[10:33:07.748]                   if (TRUE) {
[10:33:07.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.748]                     {
[10:33:07.748]                       inherits <- base::inherits
[10:33:07.748]                       invokeRestart <- base::invokeRestart
[10:33:07.748]                       is.null <- base::is.null
[10:33:07.748]                       muffled <- FALSE
[10:33:07.748]                       if (inherits(cond, "message")) {
[10:33:07.748]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.748]                         if (muffled) 
[10:33:07.748]                           invokeRestart("muffleMessage")
[10:33:07.748]                       }
[10:33:07.748]                       else if (inherits(cond, "warning")) {
[10:33:07.748]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.748]                         if (muffled) 
[10:33:07.748]                           invokeRestart("muffleWarning")
[10:33:07.748]                       }
[10:33:07.748]                       else if (inherits(cond, "condition")) {
[10:33:07.748]                         if (!is.null(pattern)) {
[10:33:07.748]                           computeRestarts <- base::computeRestarts
[10:33:07.748]                           grepl <- base::grepl
[10:33:07.748]                           restarts <- computeRestarts(cond)
[10:33:07.748]                           for (restart in restarts) {
[10:33:07.748]                             name <- restart$name
[10:33:07.748]                             if (is.null(name)) 
[10:33:07.748]                               next
[10:33:07.748]                             if (!grepl(pattern, name)) 
[10:33:07.748]                               next
[10:33:07.748]                             invokeRestart(restart)
[10:33:07.748]                             muffled <- TRUE
[10:33:07.748]                             break
[10:33:07.748]                           }
[10:33:07.748]                         }
[10:33:07.748]                       }
[10:33:07.748]                       invisible(muffled)
[10:33:07.748]                     }
[10:33:07.748]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.748]                   }
[10:33:07.748]                 }
[10:33:07.748]             }
[10:33:07.748]         }))
[10:33:07.748]     }, error = function(ex) {
[10:33:07.748]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.748]                 ...future.rng), started = ...future.startTime, 
[10:33:07.748]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.748]             version = "1.8"), class = "FutureResult")
[10:33:07.748]     }, finally = {
[10:33:07.748]         if (!identical(...future.workdir, getwd())) 
[10:33:07.748]             setwd(...future.workdir)
[10:33:07.748]         {
[10:33:07.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.748]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.748]             }
[10:33:07.748]             base::options(...future.oldOptions)
[10:33:07.748]             if (.Platform$OS.type == "windows") {
[10:33:07.748]                 old_names <- names(...future.oldEnvVars)
[10:33:07.748]                 envs <- base::Sys.getenv()
[10:33:07.748]                 names <- names(envs)
[10:33:07.748]                 common <- intersect(names, old_names)
[10:33:07.748]                 added <- setdiff(names, old_names)
[10:33:07.748]                 removed <- setdiff(old_names, names)
[10:33:07.748]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.748]                   envs[common]]
[10:33:07.748]                 NAMES <- toupper(changed)
[10:33:07.748]                 args <- list()
[10:33:07.748]                 for (kk in seq_along(NAMES)) {
[10:33:07.748]                   name <- changed[[kk]]
[10:33:07.748]                   NAME <- NAMES[[kk]]
[10:33:07.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.748]                     next
[10:33:07.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.748]                 }
[10:33:07.748]                 NAMES <- toupper(added)
[10:33:07.748]                 for (kk in seq_along(NAMES)) {
[10:33:07.748]                   name <- added[[kk]]
[10:33:07.748]                   NAME <- NAMES[[kk]]
[10:33:07.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.748]                     next
[10:33:07.748]                   args[[name]] <- ""
[10:33:07.748]                 }
[10:33:07.748]                 NAMES <- toupper(removed)
[10:33:07.748]                 for (kk in seq_along(NAMES)) {
[10:33:07.748]                   name <- removed[[kk]]
[10:33:07.748]                   NAME <- NAMES[[kk]]
[10:33:07.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.748]                     next
[10:33:07.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.748]                 }
[10:33:07.748]                 if (length(args) > 0) 
[10:33:07.748]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.748]             }
[10:33:07.748]             else {
[10:33:07.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.748]             }
[10:33:07.748]             {
[10:33:07.748]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.748]                   0L) {
[10:33:07.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.748]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.748]                   base::options(opts)
[10:33:07.748]                 }
[10:33:07.748]                 {
[10:33:07.748]                   {
[10:33:07.748]                     NULL
[10:33:07.748]                     RNGkind("Mersenne-Twister")
[10:33:07.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.748]                       inherits = FALSE)
[10:33:07.748]                   }
[10:33:07.748]                   options(future.plan = NULL)
[10:33:07.748]                   if (is.na(NA_character_)) 
[10:33:07.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.748]                     .init = FALSE)
[10:33:07.748]                 }
[10:33:07.748]             }
[10:33:07.748]         }
[10:33:07.748]     })
[10:33:07.748]     if (TRUE) {
[10:33:07.748]         base::sink(type = "output", split = FALSE)
[10:33:07.748]         if (TRUE) {
[10:33:07.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.748]         }
[10:33:07.748]         else {
[10:33:07.748]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.748]         }
[10:33:07.748]         base::close(...future.stdout)
[10:33:07.748]         ...future.stdout <- NULL
[10:33:07.748]     }
[10:33:07.748]     ...future.result$conditions <- ...future.conditions
[10:33:07.748]     ...future.result$finished <- base::Sys.time()
[10:33:07.748]     ...future.result
[10:33:07.748] }
[10:33:07.750] assign_globals() ...
[10:33:07.750] List of 1
[10:33:07.750]  $ x: list()
[10:33:07.750]  - attr(*, "where")=List of 1
[10:33:07.750]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.750]  - attr(*, "resolved")= logi TRUE
[10:33:07.750]  - attr(*, "total_size")= num 0
[10:33:07.750]  - attr(*, "already-done")= logi TRUE
[10:33:07.753] - copied ‘x’ to environment
[10:33:07.753] assign_globals() ... done
[10:33:07.753] plan(): Setting new future strategy stack:
[10:33:07.754] List of future strategies:
[10:33:07.754] 1. sequential:
[10:33:07.754]    - args: function (..., envir = parent.frame())
[10:33:07.754]    - tweaked: FALSE
[10:33:07.754]    - call: NULL
[10:33:07.754] plan(): nbrOfWorkers() = 1
[10:33:07.755] plan(): Setting new future strategy stack:
[10:33:07.755] List of future strategies:
[10:33:07.755] 1. sequential:
[10:33:07.755]    - args: function (..., envir = parent.frame())
[10:33:07.755]    - tweaked: FALSE
[10:33:07.755]    - call: plan(strategy)
[10:33:07.756] plan(): nbrOfWorkers() = 1
[10:33:07.756] SequentialFuture started (and completed)
[10:33:07.756] - Launch lazy future ... done
[10:33:07.756] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.757] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.757] Searching for globals...
[10:33:07.759] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.759] Searching for globals ... DONE
[10:33:07.759] Resolving globals: TRUE
[10:33:07.760] Resolving any globals that are futures ...
[10:33:07.760] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.760] Resolving any globals that are futures ... DONE
[10:33:07.760] Resolving futures part of globals (recursively) ...
[10:33:07.760] resolve() on list ...
[10:33:07.760]  recursive: 99
[10:33:07.760]  length: 1
[10:33:07.761]  elements: ‘x’
[10:33:07.761]  length: 0 (resolved future 1)
[10:33:07.761] resolve() on list ... DONE
[10:33:07.761] - globals: [1] ‘x’
[10:33:07.761] Resolving futures part of globals (recursively) ... DONE
[10:33:07.761] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.761] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.762] - globals: [1] ‘x’
[10:33:07.762] 
[10:33:07.762] getGlobalsAndPackages() ... DONE
[10:33:07.762] run() for ‘Future’ ...
[10:33:07.762] - state: ‘created’
[10:33:07.762] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.763] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.763]   - Field: ‘label’
[10:33:07.763]   - Field: ‘local’
[10:33:07.763]   - Field: ‘owner’
[10:33:07.763]   - Field: ‘envir’
[10:33:07.763]   - Field: ‘packages’
[10:33:07.763]   - Field: ‘gc’
[10:33:07.763]   - Field: ‘conditions’
[10:33:07.763]   - Field: ‘expr’
[10:33:07.764]   - Field: ‘uuid’
[10:33:07.764]   - Field: ‘seed’
[10:33:07.764]   - Field: ‘version’
[10:33:07.764]   - Field: ‘result’
[10:33:07.764]   - Field: ‘asynchronous’
[10:33:07.764]   - Field: ‘calls’
[10:33:07.764]   - Field: ‘globals’
[10:33:07.764]   - Field: ‘stdout’
[10:33:07.764]   - Field: ‘earlySignal’
[10:33:07.764]   - Field: ‘lazy’
[10:33:07.764]   - Field: ‘state’
[10:33:07.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.765] - Launch lazy future ...
[10:33:07.765] Packages needed by the future expression (n = 0): <none>
[10:33:07.765] Packages needed by future strategies (n = 0): <none>
[10:33:07.765] {
[10:33:07.765]     {
[10:33:07.765]         {
[10:33:07.765]             ...future.startTime <- base::Sys.time()
[10:33:07.765]             {
[10:33:07.765]                 {
[10:33:07.765]                   {
[10:33:07.765]                     base::local({
[10:33:07.765]                       has_future <- base::requireNamespace("future", 
[10:33:07.765]                         quietly = TRUE)
[10:33:07.765]                       if (has_future) {
[10:33:07.765]                         ns <- base::getNamespace("future")
[10:33:07.765]                         version <- ns[[".package"]][["version"]]
[10:33:07.765]                         if (is.null(version)) 
[10:33:07.765]                           version <- utils::packageVersion("future")
[10:33:07.765]                       }
[10:33:07.765]                       else {
[10:33:07.765]                         version <- NULL
[10:33:07.765]                       }
[10:33:07.765]                       if (!has_future || version < "1.8.0") {
[10:33:07.765]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.765]                           "", base::R.version$version.string), 
[10:33:07.765]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.765]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.765]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.765]                             "release", "version")], collapse = " "), 
[10:33:07.765]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.765]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.765]                           info)
[10:33:07.765]                         info <- base::paste(info, collapse = "; ")
[10:33:07.765]                         if (!has_future) {
[10:33:07.765]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.765]                             info)
[10:33:07.765]                         }
[10:33:07.765]                         else {
[10:33:07.765]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.765]                             info, version)
[10:33:07.765]                         }
[10:33:07.765]                         base::stop(msg)
[10:33:07.765]                       }
[10:33:07.765]                     })
[10:33:07.765]                   }
[10:33:07.765]                   ...future.strategy.old <- future::plan("list")
[10:33:07.765]                   options(future.plan = NULL)
[10:33:07.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.765]                 }
[10:33:07.765]                 ...future.workdir <- getwd()
[10:33:07.765]             }
[10:33:07.765]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.765]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.765]         }
[10:33:07.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.765]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.765]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.765]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.765]             base::names(...future.oldOptions))
[10:33:07.765]     }
[10:33:07.765]     if (FALSE) {
[10:33:07.765]     }
[10:33:07.765]     else {
[10:33:07.765]         if (TRUE) {
[10:33:07.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.765]                 open = "w")
[10:33:07.765]         }
[10:33:07.765]         else {
[10:33:07.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.765]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.765]         }
[10:33:07.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.765]             base::sink(type = "output", split = FALSE)
[10:33:07.765]             base::close(...future.stdout)
[10:33:07.765]         }, add = TRUE)
[10:33:07.765]     }
[10:33:07.765]     ...future.frame <- base::sys.nframe()
[10:33:07.765]     ...future.conditions <- base::list()
[10:33:07.765]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.765]     if (FALSE) {
[10:33:07.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.765]     }
[10:33:07.765]     ...future.result <- base::tryCatch({
[10:33:07.765]         base::withCallingHandlers({
[10:33:07.765]             ...future.value <- base::withVisible(base::local({
[10:33:07.765]                 x$a <- 1
[10:33:07.765]                 x
[10:33:07.765]             }))
[10:33:07.765]             future::FutureResult(value = ...future.value$value, 
[10:33:07.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.765]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.765]                     ...future.globalenv.names))
[10:33:07.765]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.765]         }, condition = base::local({
[10:33:07.765]             c <- base::c
[10:33:07.765]             inherits <- base::inherits
[10:33:07.765]             invokeRestart <- base::invokeRestart
[10:33:07.765]             length <- base::length
[10:33:07.765]             list <- base::list
[10:33:07.765]             seq.int <- base::seq.int
[10:33:07.765]             signalCondition <- base::signalCondition
[10:33:07.765]             sys.calls <- base::sys.calls
[10:33:07.765]             `[[` <- base::`[[`
[10:33:07.765]             `+` <- base::`+`
[10:33:07.765]             `<<-` <- base::`<<-`
[10:33:07.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.765]                   3L)]
[10:33:07.765]             }
[10:33:07.765]             function(cond) {
[10:33:07.765]                 is_error <- inherits(cond, "error")
[10:33:07.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.765]                   NULL)
[10:33:07.765]                 if (is_error) {
[10:33:07.765]                   sessionInformation <- function() {
[10:33:07.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.765]                       search = base::search(), system = base::Sys.info())
[10:33:07.765]                   }
[10:33:07.765]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.765]                     cond$call), session = sessionInformation(), 
[10:33:07.765]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.765]                   signalCondition(cond)
[10:33:07.765]                 }
[10:33:07.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.765]                 "immediateCondition"))) {
[10:33:07.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.765]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.765]                   if (TRUE && !signal) {
[10:33:07.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.765]                     {
[10:33:07.765]                       inherits <- base::inherits
[10:33:07.765]                       invokeRestart <- base::invokeRestart
[10:33:07.765]                       is.null <- base::is.null
[10:33:07.765]                       muffled <- FALSE
[10:33:07.765]                       if (inherits(cond, "message")) {
[10:33:07.765]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.765]                         if (muffled) 
[10:33:07.765]                           invokeRestart("muffleMessage")
[10:33:07.765]                       }
[10:33:07.765]                       else if (inherits(cond, "warning")) {
[10:33:07.765]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.765]                         if (muffled) 
[10:33:07.765]                           invokeRestart("muffleWarning")
[10:33:07.765]                       }
[10:33:07.765]                       else if (inherits(cond, "condition")) {
[10:33:07.765]                         if (!is.null(pattern)) {
[10:33:07.765]                           computeRestarts <- base::computeRestarts
[10:33:07.765]                           grepl <- base::grepl
[10:33:07.765]                           restarts <- computeRestarts(cond)
[10:33:07.765]                           for (restart in restarts) {
[10:33:07.765]                             name <- restart$name
[10:33:07.765]                             if (is.null(name)) 
[10:33:07.765]                               next
[10:33:07.765]                             if (!grepl(pattern, name)) 
[10:33:07.765]                               next
[10:33:07.765]                             invokeRestart(restart)
[10:33:07.765]                             muffled <- TRUE
[10:33:07.765]                             break
[10:33:07.765]                           }
[10:33:07.765]                         }
[10:33:07.765]                       }
[10:33:07.765]                       invisible(muffled)
[10:33:07.765]                     }
[10:33:07.765]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.765]                   }
[10:33:07.765]                 }
[10:33:07.765]                 else {
[10:33:07.765]                   if (TRUE) {
[10:33:07.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.765]                     {
[10:33:07.765]                       inherits <- base::inherits
[10:33:07.765]                       invokeRestart <- base::invokeRestart
[10:33:07.765]                       is.null <- base::is.null
[10:33:07.765]                       muffled <- FALSE
[10:33:07.765]                       if (inherits(cond, "message")) {
[10:33:07.765]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.765]                         if (muffled) 
[10:33:07.765]                           invokeRestart("muffleMessage")
[10:33:07.765]                       }
[10:33:07.765]                       else if (inherits(cond, "warning")) {
[10:33:07.765]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.765]                         if (muffled) 
[10:33:07.765]                           invokeRestart("muffleWarning")
[10:33:07.765]                       }
[10:33:07.765]                       else if (inherits(cond, "condition")) {
[10:33:07.765]                         if (!is.null(pattern)) {
[10:33:07.765]                           computeRestarts <- base::computeRestarts
[10:33:07.765]                           grepl <- base::grepl
[10:33:07.765]                           restarts <- computeRestarts(cond)
[10:33:07.765]                           for (restart in restarts) {
[10:33:07.765]                             name <- restart$name
[10:33:07.765]                             if (is.null(name)) 
[10:33:07.765]                               next
[10:33:07.765]                             if (!grepl(pattern, name)) 
[10:33:07.765]                               next
[10:33:07.765]                             invokeRestart(restart)
[10:33:07.765]                             muffled <- TRUE
[10:33:07.765]                             break
[10:33:07.765]                           }
[10:33:07.765]                         }
[10:33:07.765]                       }
[10:33:07.765]                       invisible(muffled)
[10:33:07.765]                     }
[10:33:07.765]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.765]                   }
[10:33:07.765]                 }
[10:33:07.765]             }
[10:33:07.765]         }))
[10:33:07.765]     }, error = function(ex) {
[10:33:07.765]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.765]                 ...future.rng), started = ...future.startTime, 
[10:33:07.765]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.765]             version = "1.8"), class = "FutureResult")
[10:33:07.765]     }, finally = {
[10:33:07.765]         if (!identical(...future.workdir, getwd())) 
[10:33:07.765]             setwd(...future.workdir)
[10:33:07.765]         {
[10:33:07.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.765]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.765]             }
[10:33:07.765]             base::options(...future.oldOptions)
[10:33:07.765]             if (.Platform$OS.type == "windows") {
[10:33:07.765]                 old_names <- names(...future.oldEnvVars)
[10:33:07.765]                 envs <- base::Sys.getenv()
[10:33:07.765]                 names <- names(envs)
[10:33:07.765]                 common <- intersect(names, old_names)
[10:33:07.765]                 added <- setdiff(names, old_names)
[10:33:07.765]                 removed <- setdiff(old_names, names)
[10:33:07.765]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.765]                   envs[common]]
[10:33:07.765]                 NAMES <- toupper(changed)
[10:33:07.765]                 args <- list()
[10:33:07.765]                 for (kk in seq_along(NAMES)) {
[10:33:07.765]                   name <- changed[[kk]]
[10:33:07.765]                   NAME <- NAMES[[kk]]
[10:33:07.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.765]                     next
[10:33:07.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.765]                 }
[10:33:07.765]                 NAMES <- toupper(added)
[10:33:07.765]                 for (kk in seq_along(NAMES)) {
[10:33:07.765]                   name <- added[[kk]]
[10:33:07.765]                   NAME <- NAMES[[kk]]
[10:33:07.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.765]                     next
[10:33:07.765]                   args[[name]] <- ""
[10:33:07.765]                 }
[10:33:07.765]                 NAMES <- toupper(removed)
[10:33:07.765]                 for (kk in seq_along(NAMES)) {
[10:33:07.765]                   name <- removed[[kk]]
[10:33:07.765]                   NAME <- NAMES[[kk]]
[10:33:07.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.765]                     next
[10:33:07.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.765]                 }
[10:33:07.765]                 if (length(args) > 0) 
[10:33:07.765]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.765]             }
[10:33:07.765]             else {
[10:33:07.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.765]             }
[10:33:07.765]             {
[10:33:07.765]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.765]                   0L) {
[10:33:07.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.765]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.765]                   base::options(opts)
[10:33:07.765]                 }
[10:33:07.765]                 {
[10:33:07.765]                   {
[10:33:07.765]                     NULL
[10:33:07.765]                     RNGkind("Mersenne-Twister")
[10:33:07.765]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.765]                       inherits = FALSE)
[10:33:07.765]                   }
[10:33:07.765]                   options(future.plan = NULL)
[10:33:07.765]                   if (is.na(NA_character_)) 
[10:33:07.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.765]                     .init = FALSE)
[10:33:07.765]                 }
[10:33:07.765]             }
[10:33:07.765]         }
[10:33:07.765]     })
[10:33:07.765]     if (TRUE) {
[10:33:07.765]         base::sink(type = "output", split = FALSE)
[10:33:07.765]         if (TRUE) {
[10:33:07.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.765]         }
[10:33:07.765]         else {
[10:33:07.765]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.765]         }
[10:33:07.765]         base::close(...future.stdout)
[10:33:07.765]         ...future.stdout <- NULL
[10:33:07.765]     }
[10:33:07.765]     ...future.result$conditions <- ...future.conditions
[10:33:07.765]     ...future.result$finished <- base::Sys.time()
[10:33:07.765]     ...future.result
[10:33:07.765] }
[10:33:07.767] assign_globals() ...
[10:33:07.767] List of 1
[10:33:07.767]  $ x: list()
[10:33:07.767]  - attr(*, "where")=List of 1
[10:33:07.767]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.767]  - attr(*, "resolved")= logi TRUE
[10:33:07.767]  - attr(*, "total_size")= num 0
[10:33:07.767]  - attr(*, "already-done")= logi TRUE
[10:33:07.770] - copied ‘x’ to environment
[10:33:07.770] assign_globals() ... done
[10:33:07.770] plan(): Setting new future strategy stack:
[10:33:07.770] List of future strategies:
[10:33:07.770] 1. sequential:
[10:33:07.770]    - args: function (..., envir = parent.frame())
[10:33:07.770]    - tweaked: FALSE
[10:33:07.770]    - call: NULL
[10:33:07.770] plan(): nbrOfWorkers() = 1
[10:33:07.771] plan(): Setting new future strategy stack:
[10:33:07.771] List of future strategies:
[10:33:07.771] 1. sequential:
[10:33:07.771]    - args: function (..., envir = parent.frame())
[10:33:07.771]    - tweaked: FALSE
[10:33:07.771]    - call: plan(strategy)
[10:33:07.772] plan(): nbrOfWorkers() = 1
[10:33:07.772] SequentialFuture started (and completed)
[10:33:07.772] - Launch lazy future ... done
[10:33:07.772] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.773] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.774] Searching for globals...
[10:33:07.775] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.775] Searching for globals ... DONE
[10:33:07.776] Resolving globals: TRUE
[10:33:07.776] Resolving any globals that are futures ...
[10:33:07.776] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.776] Resolving any globals that are futures ... DONE
[10:33:07.776] Resolving futures part of globals (recursively) ...
[10:33:07.776] resolve() on list ...
[10:33:07.777]  recursive: 99
[10:33:07.777]  length: 1
[10:33:07.777]  elements: ‘x’
[10:33:07.777]  length: 0 (resolved future 1)
[10:33:07.777] resolve() on list ... DONE
[10:33:07.777] - globals: [1] ‘x’
[10:33:07.777] Resolving futures part of globals (recursively) ... DONE
[10:33:07.777] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.780] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.780] - globals: [1] ‘x’
[10:33:07.780] 
[10:33:07.780] getGlobalsAndPackages() ... DONE
[10:33:07.780] run() for ‘Future’ ...
[10:33:07.780] - state: ‘created’
[10:33:07.781] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.781] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.781] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.781]   - Field: ‘label’
[10:33:07.781]   - Field: ‘local’
[10:33:07.781]   - Field: ‘owner’
[10:33:07.781]   - Field: ‘envir’
[10:33:07.781]   - Field: ‘packages’
[10:33:07.782]   - Field: ‘gc’
[10:33:07.782]   - Field: ‘conditions’
[10:33:07.782]   - Field: ‘expr’
[10:33:07.782]   - Field: ‘uuid’
[10:33:07.782]   - Field: ‘seed’
[10:33:07.782]   - Field: ‘version’
[10:33:07.782]   - Field: ‘result’
[10:33:07.782]   - Field: ‘asynchronous’
[10:33:07.782]   - Field: ‘calls’
[10:33:07.782]   - Field: ‘globals’
[10:33:07.782]   - Field: ‘stdout’
[10:33:07.783]   - Field: ‘earlySignal’
[10:33:07.783]   - Field: ‘lazy’
[10:33:07.783]   - Field: ‘state’
[10:33:07.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.783] - Launch lazy future ...
[10:33:07.783] Packages needed by the future expression (n = 0): <none>
[10:33:07.783] Packages needed by future strategies (n = 0): <none>
[10:33:07.784] {
[10:33:07.784]     {
[10:33:07.784]         {
[10:33:07.784]             ...future.startTime <- base::Sys.time()
[10:33:07.784]             {
[10:33:07.784]                 {
[10:33:07.784]                   {
[10:33:07.784]                     base::local({
[10:33:07.784]                       has_future <- base::requireNamespace("future", 
[10:33:07.784]                         quietly = TRUE)
[10:33:07.784]                       if (has_future) {
[10:33:07.784]                         ns <- base::getNamespace("future")
[10:33:07.784]                         version <- ns[[".package"]][["version"]]
[10:33:07.784]                         if (is.null(version)) 
[10:33:07.784]                           version <- utils::packageVersion("future")
[10:33:07.784]                       }
[10:33:07.784]                       else {
[10:33:07.784]                         version <- NULL
[10:33:07.784]                       }
[10:33:07.784]                       if (!has_future || version < "1.8.0") {
[10:33:07.784]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.784]                           "", base::R.version$version.string), 
[10:33:07.784]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.784]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.784]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.784]                             "release", "version")], collapse = " "), 
[10:33:07.784]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.784]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.784]                           info)
[10:33:07.784]                         info <- base::paste(info, collapse = "; ")
[10:33:07.784]                         if (!has_future) {
[10:33:07.784]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.784]                             info)
[10:33:07.784]                         }
[10:33:07.784]                         else {
[10:33:07.784]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.784]                             info, version)
[10:33:07.784]                         }
[10:33:07.784]                         base::stop(msg)
[10:33:07.784]                       }
[10:33:07.784]                     })
[10:33:07.784]                   }
[10:33:07.784]                   ...future.strategy.old <- future::plan("list")
[10:33:07.784]                   options(future.plan = NULL)
[10:33:07.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.784]                 }
[10:33:07.784]                 ...future.workdir <- getwd()
[10:33:07.784]             }
[10:33:07.784]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.784]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.784]         }
[10:33:07.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.784]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.784]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.784]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.784]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.784]             base::names(...future.oldOptions))
[10:33:07.784]     }
[10:33:07.784]     if (FALSE) {
[10:33:07.784]     }
[10:33:07.784]     else {
[10:33:07.784]         if (TRUE) {
[10:33:07.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.784]                 open = "w")
[10:33:07.784]         }
[10:33:07.784]         else {
[10:33:07.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.784]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.784]         }
[10:33:07.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.784]             base::sink(type = "output", split = FALSE)
[10:33:07.784]             base::close(...future.stdout)
[10:33:07.784]         }, add = TRUE)
[10:33:07.784]     }
[10:33:07.784]     ...future.frame <- base::sys.nframe()
[10:33:07.784]     ...future.conditions <- base::list()
[10:33:07.784]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.784]     if (FALSE) {
[10:33:07.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.784]     }
[10:33:07.784]     ...future.result <- base::tryCatch({
[10:33:07.784]         base::withCallingHandlers({
[10:33:07.784]             ...future.value <- base::withVisible(base::local({
[10:33:07.784]                 x$a <- 1
[10:33:07.784]                 x
[10:33:07.784]             }))
[10:33:07.784]             future::FutureResult(value = ...future.value$value, 
[10:33:07.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.784]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.784]                     ...future.globalenv.names))
[10:33:07.784]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.784]         }, condition = base::local({
[10:33:07.784]             c <- base::c
[10:33:07.784]             inherits <- base::inherits
[10:33:07.784]             invokeRestart <- base::invokeRestart
[10:33:07.784]             length <- base::length
[10:33:07.784]             list <- base::list
[10:33:07.784]             seq.int <- base::seq.int
[10:33:07.784]             signalCondition <- base::signalCondition
[10:33:07.784]             sys.calls <- base::sys.calls
[10:33:07.784]             `[[` <- base::`[[`
[10:33:07.784]             `+` <- base::`+`
[10:33:07.784]             `<<-` <- base::`<<-`
[10:33:07.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.784]                   3L)]
[10:33:07.784]             }
[10:33:07.784]             function(cond) {
[10:33:07.784]                 is_error <- inherits(cond, "error")
[10:33:07.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.784]                   NULL)
[10:33:07.784]                 if (is_error) {
[10:33:07.784]                   sessionInformation <- function() {
[10:33:07.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.784]                       search = base::search(), system = base::Sys.info())
[10:33:07.784]                   }
[10:33:07.784]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.784]                     cond$call), session = sessionInformation(), 
[10:33:07.784]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.784]                   signalCondition(cond)
[10:33:07.784]                 }
[10:33:07.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.784]                 "immediateCondition"))) {
[10:33:07.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.784]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.784]                   if (TRUE && !signal) {
[10:33:07.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.784]                     {
[10:33:07.784]                       inherits <- base::inherits
[10:33:07.784]                       invokeRestart <- base::invokeRestart
[10:33:07.784]                       is.null <- base::is.null
[10:33:07.784]                       muffled <- FALSE
[10:33:07.784]                       if (inherits(cond, "message")) {
[10:33:07.784]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.784]                         if (muffled) 
[10:33:07.784]                           invokeRestart("muffleMessage")
[10:33:07.784]                       }
[10:33:07.784]                       else if (inherits(cond, "warning")) {
[10:33:07.784]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.784]                         if (muffled) 
[10:33:07.784]                           invokeRestart("muffleWarning")
[10:33:07.784]                       }
[10:33:07.784]                       else if (inherits(cond, "condition")) {
[10:33:07.784]                         if (!is.null(pattern)) {
[10:33:07.784]                           computeRestarts <- base::computeRestarts
[10:33:07.784]                           grepl <- base::grepl
[10:33:07.784]                           restarts <- computeRestarts(cond)
[10:33:07.784]                           for (restart in restarts) {
[10:33:07.784]                             name <- restart$name
[10:33:07.784]                             if (is.null(name)) 
[10:33:07.784]                               next
[10:33:07.784]                             if (!grepl(pattern, name)) 
[10:33:07.784]                               next
[10:33:07.784]                             invokeRestart(restart)
[10:33:07.784]                             muffled <- TRUE
[10:33:07.784]                             break
[10:33:07.784]                           }
[10:33:07.784]                         }
[10:33:07.784]                       }
[10:33:07.784]                       invisible(muffled)
[10:33:07.784]                     }
[10:33:07.784]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.784]                   }
[10:33:07.784]                 }
[10:33:07.784]                 else {
[10:33:07.784]                   if (TRUE) {
[10:33:07.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.784]                     {
[10:33:07.784]                       inherits <- base::inherits
[10:33:07.784]                       invokeRestart <- base::invokeRestart
[10:33:07.784]                       is.null <- base::is.null
[10:33:07.784]                       muffled <- FALSE
[10:33:07.784]                       if (inherits(cond, "message")) {
[10:33:07.784]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.784]                         if (muffled) 
[10:33:07.784]                           invokeRestart("muffleMessage")
[10:33:07.784]                       }
[10:33:07.784]                       else if (inherits(cond, "warning")) {
[10:33:07.784]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.784]                         if (muffled) 
[10:33:07.784]                           invokeRestart("muffleWarning")
[10:33:07.784]                       }
[10:33:07.784]                       else if (inherits(cond, "condition")) {
[10:33:07.784]                         if (!is.null(pattern)) {
[10:33:07.784]                           computeRestarts <- base::computeRestarts
[10:33:07.784]                           grepl <- base::grepl
[10:33:07.784]                           restarts <- computeRestarts(cond)
[10:33:07.784]                           for (restart in restarts) {
[10:33:07.784]                             name <- restart$name
[10:33:07.784]                             if (is.null(name)) 
[10:33:07.784]                               next
[10:33:07.784]                             if (!grepl(pattern, name)) 
[10:33:07.784]                               next
[10:33:07.784]                             invokeRestart(restart)
[10:33:07.784]                             muffled <- TRUE
[10:33:07.784]                             break
[10:33:07.784]                           }
[10:33:07.784]                         }
[10:33:07.784]                       }
[10:33:07.784]                       invisible(muffled)
[10:33:07.784]                     }
[10:33:07.784]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.784]                   }
[10:33:07.784]                 }
[10:33:07.784]             }
[10:33:07.784]         }))
[10:33:07.784]     }, error = function(ex) {
[10:33:07.784]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.784]                 ...future.rng), started = ...future.startTime, 
[10:33:07.784]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.784]             version = "1.8"), class = "FutureResult")
[10:33:07.784]     }, finally = {
[10:33:07.784]         if (!identical(...future.workdir, getwd())) 
[10:33:07.784]             setwd(...future.workdir)
[10:33:07.784]         {
[10:33:07.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.784]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.784]             }
[10:33:07.784]             base::options(...future.oldOptions)
[10:33:07.784]             if (.Platform$OS.type == "windows") {
[10:33:07.784]                 old_names <- names(...future.oldEnvVars)
[10:33:07.784]                 envs <- base::Sys.getenv()
[10:33:07.784]                 names <- names(envs)
[10:33:07.784]                 common <- intersect(names, old_names)
[10:33:07.784]                 added <- setdiff(names, old_names)
[10:33:07.784]                 removed <- setdiff(old_names, names)
[10:33:07.784]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.784]                   envs[common]]
[10:33:07.784]                 NAMES <- toupper(changed)
[10:33:07.784]                 args <- list()
[10:33:07.784]                 for (kk in seq_along(NAMES)) {
[10:33:07.784]                   name <- changed[[kk]]
[10:33:07.784]                   NAME <- NAMES[[kk]]
[10:33:07.784]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.784]                     next
[10:33:07.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.784]                 }
[10:33:07.784]                 NAMES <- toupper(added)
[10:33:07.784]                 for (kk in seq_along(NAMES)) {
[10:33:07.784]                   name <- added[[kk]]
[10:33:07.784]                   NAME <- NAMES[[kk]]
[10:33:07.784]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.784]                     next
[10:33:07.784]                   args[[name]] <- ""
[10:33:07.784]                 }
[10:33:07.784]                 NAMES <- toupper(removed)
[10:33:07.784]                 for (kk in seq_along(NAMES)) {
[10:33:07.784]                   name <- removed[[kk]]
[10:33:07.784]                   NAME <- NAMES[[kk]]
[10:33:07.784]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.784]                     next
[10:33:07.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.784]                 }
[10:33:07.784]                 if (length(args) > 0) 
[10:33:07.784]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.784]             }
[10:33:07.784]             else {
[10:33:07.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.784]             }
[10:33:07.784]             {
[10:33:07.784]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.784]                   0L) {
[10:33:07.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.784]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.784]                   base::options(opts)
[10:33:07.784]                 }
[10:33:07.784]                 {
[10:33:07.784]                   {
[10:33:07.784]                     NULL
[10:33:07.784]                     RNGkind("Mersenne-Twister")
[10:33:07.784]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.784]                       inherits = FALSE)
[10:33:07.784]                   }
[10:33:07.784]                   options(future.plan = NULL)
[10:33:07.784]                   if (is.na(NA_character_)) 
[10:33:07.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.784]                     .init = FALSE)
[10:33:07.784]                 }
[10:33:07.784]             }
[10:33:07.784]         }
[10:33:07.784]     })
[10:33:07.784]     if (TRUE) {
[10:33:07.784]         base::sink(type = "output", split = FALSE)
[10:33:07.784]         if (TRUE) {
[10:33:07.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.784]         }
[10:33:07.784]         else {
[10:33:07.784]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.784]         }
[10:33:07.784]         base::close(...future.stdout)
[10:33:07.784]         ...future.stdout <- NULL
[10:33:07.784]     }
[10:33:07.784]     ...future.result$conditions <- ...future.conditions
[10:33:07.784]     ...future.result$finished <- base::Sys.time()
[10:33:07.784]     ...future.result
[10:33:07.784] }
[10:33:07.785] assign_globals() ...
[10:33:07.785] List of 1
[10:33:07.785]  $ x: list()
[10:33:07.785]  - attr(*, "where")=List of 1
[10:33:07.785]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.785]  - attr(*, "resolved")= logi TRUE
[10:33:07.785]  - attr(*, "total_size")= num 0
[10:33:07.785]  - attr(*, "already-done")= logi TRUE
[10:33:07.788] - copied ‘x’ to environment
[10:33:07.788] assign_globals() ... done
[10:33:07.788] plan(): Setting new future strategy stack:
[10:33:07.788] List of future strategies:
[10:33:07.788] 1. sequential:
[10:33:07.788]    - args: function (..., envir = parent.frame())
[10:33:07.788]    - tweaked: FALSE
[10:33:07.788]    - call: NULL
[10:33:07.789] plan(): nbrOfWorkers() = 1
[10:33:07.789] plan(): Setting new future strategy stack:
[10:33:07.789] List of future strategies:
[10:33:07.789] 1. sequential:
[10:33:07.789]    - args: function (..., envir = parent.frame())
[10:33:07.789]    - tweaked: FALSE
[10:33:07.789]    - call: plan(strategy)
[10:33:07.790] plan(): nbrOfWorkers() = 1
[10:33:07.790] SequentialFuture started (and completed)
[10:33:07.790] - Launch lazy future ... done
[10:33:07.790] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.791] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.791] Searching for globals...
[10:33:07.793] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.793] Searching for globals ... DONE
[10:33:07.793] Resolving globals: TRUE
[10:33:07.793] Resolving any globals that are futures ...
[10:33:07.793] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.793] Resolving any globals that are futures ... DONE
[10:33:07.793] Resolving futures part of globals (recursively) ...
[10:33:07.794] resolve() on list ...
[10:33:07.794]  recursive: 99
[10:33:07.794]  length: 1
[10:33:07.794]  elements: ‘x’
[10:33:07.794]  length: 0 (resolved future 1)
[10:33:07.794] resolve() on list ... DONE
[10:33:07.794] - globals: [1] ‘x’
[10:33:07.794] Resolving futures part of globals (recursively) ... DONE
[10:33:07.794] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.795] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.795] - globals: [1] ‘x’
[10:33:07.795] 
[10:33:07.795] getGlobalsAndPackages() ... DONE
[10:33:07.795] run() for ‘Future’ ...
[10:33:07.795] - state: ‘created’
[10:33:07.796] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.796] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.796]   - Field: ‘label’
[10:33:07.796]   - Field: ‘local’
[10:33:07.796]   - Field: ‘owner’
[10:33:07.796]   - Field: ‘envir’
[10:33:07.796]   - Field: ‘packages’
[10:33:07.797]   - Field: ‘gc’
[10:33:07.797]   - Field: ‘conditions’
[10:33:07.797]   - Field: ‘expr’
[10:33:07.797]   - Field: ‘uuid’
[10:33:07.797]   - Field: ‘seed’
[10:33:07.797]   - Field: ‘version’
[10:33:07.797]   - Field: ‘result’
[10:33:07.797]   - Field: ‘asynchronous’
[10:33:07.797]   - Field: ‘calls’
[10:33:07.797]   - Field: ‘globals’
[10:33:07.797]   - Field: ‘stdout’
[10:33:07.798]   - Field: ‘earlySignal’
[10:33:07.798]   - Field: ‘lazy’
[10:33:07.798]   - Field: ‘state’
[10:33:07.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.798] - Launch lazy future ...
[10:33:07.798] Packages needed by the future expression (n = 0): <none>
[10:33:07.798] Packages needed by future strategies (n = 0): <none>
[10:33:07.799] {
[10:33:07.799]     {
[10:33:07.799]         {
[10:33:07.799]             ...future.startTime <- base::Sys.time()
[10:33:07.799]             {
[10:33:07.799]                 {
[10:33:07.799]                   {
[10:33:07.799]                     base::local({
[10:33:07.799]                       has_future <- base::requireNamespace("future", 
[10:33:07.799]                         quietly = TRUE)
[10:33:07.799]                       if (has_future) {
[10:33:07.799]                         ns <- base::getNamespace("future")
[10:33:07.799]                         version <- ns[[".package"]][["version"]]
[10:33:07.799]                         if (is.null(version)) 
[10:33:07.799]                           version <- utils::packageVersion("future")
[10:33:07.799]                       }
[10:33:07.799]                       else {
[10:33:07.799]                         version <- NULL
[10:33:07.799]                       }
[10:33:07.799]                       if (!has_future || version < "1.8.0") {
[10:33:07.799]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.799]                           "", base::R.version$version.string), 
[10:33:07.799]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.799]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.799]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.799]                             "release", "version")], collapse = " "), 
[10:33:07.799]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.799]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.799]                           info)
[10:33:07.799]                         info <- base::paste(info, collapse = "; ")
[10:33:07.799]                         if (!has_future) {
[10:33:07.799]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.799]                             info)
[10:33:07.799]                         }
[10:33:07.799]                         else {
[10:33:07.799]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.799]                             info, version)
[10:33:07.799]                         }
[10:33:07.799]                         base::stop(msg)
[10:33:07.799]                       }
[10:33:07.799]                     })
[10:33:07.799]                   }
[10:33:07.799]                   ...future.strategy.old <- future::plan("list")
[10:33:07.799]                   options(future.plan = NULL)
[10:33:07.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.799]                 }
[10:33:07.799]                 ...future.workdir <- getwd()
[10:33:07.799]             }
[10:33:07.799]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.799]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.799]         }
[10:33:07.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.799]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.799]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.799]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.799]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.799]             base::names(...future.oldOptions))
[10:33:07.799]     }
[10:33:07.799]     if (FALSE) {
[10:33:07.799]     }
[10:33:07.799]     else {
[10:33:07.799]         if (TRUE) {
[10:33:07.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.799]                 open = "w")
[10:33:07.799]         }
[10:33:07.799]         else {
[10:33:07.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.799]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.799]         }
[10:33:07.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.799]             base::sink(type = "output", split = FALSE)
[10:33:07.799]             base::close(...future.stdout)
[10:33:07.799]         }, add = TRUE)
[10:33:07.799]     }
[10:33:07.799]     ...future.frame <- base::sys.nframe()
[10:33:07.799]     ...future.conditions <- base::list()
[10:33:07.799]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.799]     if (FALSE) {
[10:33:07.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.799]     }
[10:33:07.799]     ...future.result <- base::tryCatch({
[10:33:07.799]         base::withCallingHandlers({
[10:33:07.799]             ...future.value <- base::withVisible(base::local({
[10:33:07.799]                 x$a <- 1
[10:33:07.799]                 x
[10:33:07.799]             }))
[10:33:07.799]             future::FutureResult(value = ...future.value$value, 
[10:33:07.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.799]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.799]                     ...future.globalenv.names))
[10:33:07.799]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.799]         }, condition = base::local({
[10:33:07.799]             c <- base::c
[10:33:07.799]             inherits <- base::inherits
[10:33:07.799]             invokeRestart <- base::invokeRestart
[10:33:07.799]             length <- base::length
[10:33:07.799]             list <- base::list
[10:33:07.799]             seq.int <- base::seq.int
[10:33:07.799]             signalCondition <- base::signalCondition
[10:33:07.799]             sys.calls <- base::sys.calls
[10:33:07.799]             `[[` <- base::`[[`
[10:33:07.799]             `+` <- base::`+`
[10:33:07.799]             `<<-` <- base::`<<-`
[10:33:07.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.799]                   3L)]
[10:33:07.799]             }
[10:33:07.799]             function(cond) {
[10:33:07.799]                 is_error <- inherits(cond, "error")
[10:33:07.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.799]                   NULL)
[10:33:07.799]                 if (is_error) {
[10:33:07.799]                   sessionInformation <- function() {
[10:33:07.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.799]                       search = base::search(), system = base::Sys.info())
[10:33:07.799]                   }
[10:33:07.799]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.799]                     cond$call), session = sessionInformation(), 
[10:33:07.799]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.799]                   signalCondition(cond)
[10:33:07.799]                 }
[10:33:07.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.799]                 "immediateCondition"))) {
[10:33:07.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.799]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.799]                   if (TRUE && !signal) {
[10:33:07.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.799]                     {
[10:33:07.799]                       inherits <- base::inherits
[10:33:07.799]                       invokeRestart <- base::invokeRestart
[10:33:07.799]                       is.null <- base::is.null
[10:33:07.799]                       muffled <- FALSE
[10:33:07.799]                       if (inherits(cond, "message")) {
[10:33:07.799]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.799]                         if (muffled) 
[10:33:07.799]                           invokeRestart("muffleMessage")
[10:33:07.799]                       }
[10:33:07.799]                       else if (inherits(cond, "warning")) {
[10:33:07.799]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.799]                         if (muffled) 
[10:33:07.799]                           invokeRestart("muffleWarning")
[10:33:07.799]                       }
[10:33:07.799]                       else if (inherits(cond, "condition")) {
[10:33:07.799]                         if (!is.null(pattern)) {
[10:33:07.799]                           computeRestarts <- base::computeRestarts
[10:33:07.799]                           grepl <- base::grepl
[10:33:07.799]                           restarts <- computeRestarts(cond)
[10:33:07.799]                           for (restart in restarts) {
[10:33:07.799]                             name <- restart$name
[10:33:07.799]                             if (is.null(name)) 
[10:33:07.799]                               next
[10:33:07.799]                             if (!grepl(pattern, name)) 
[10:33:07.799]                               next
[10:33:07.799]                             invokeRestart(restart)
[10:33:07.799]                             muffled <- TRUE
[10:33:07.799]                             break
[10:33:07.799]                           }
[10:33:07.799]                         }
[10:33:07.799]                       }
[10:33:07.799]                       invisible(muffled)
[10:33:07.799]                     }
[10:33:07.799]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.799]                   }
[10:33:07.799]                 }
[10:33:07.799]                 else {
[10:33:07.799]                   if (TRUE) {
[10:33:07.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.799]                     {
[10:33:07.799]                       inherits <- base::inherits
[10:33:07.799]                       invokeRestart <- base::invokeRestart
[10:33:07.799]                       is.null <- base::is.null
[10:33:07.799]                       muffled <- FALSE
[10:33:07.799]                       if (inherits(cond, "message")) {
[10:33:07.799]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.799]                         if (muffled) 
[10:33:07.799]                           invokeRestart("muffleMessage")
[10:33:07.799]                       }
[10:33:07.799]                       else if (inherits(cond, "warning")) {
[10:33:07.799]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.799]                         if (muffled) 
[10:33:07.799]                           invokeRestart("muffleWarning")
[10:33:07.799]                       }
[10:33:07.799]                       else if (inherits(cond, "condition")) {
[10:33:07.799]                         if (!is.null(pattern)) {
[10:33:07.799]                           computeRestarts <- base::computeRestarts
[10:33:07.799]                           grepl <- base::grepl
[10:33:07.799]                           restarts <- computeRestarts(cond)
[10:33:07.799]                           for (restart in restarts) {
[10:33:07.799]                             name <- restart$name
[10:33:07.799]                             if (is.null(name)) 
[10:33:07.799]                               next
[10:33:07.799]                             if (!grepl(pattern, name)) 
[10:33:07.799]                               next
[10:33:07.799]                             invokeRestart(restart)
[10:33:07.799]                             muffled <- TRUE
[10:33:07.799]                             break
[10:33:07.799]                           }
[10:33:07.799]                         }
[10:33:07.799]                       }
[10:33:07.799]                       invisible(muffled)
[10:33:07.799]                     }
[10:33:07.799]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.799]                   }
[10:33:07.799]                 }
[10:33:07.799]             }
[10:33:07.799]         }))
[10:33:07.799]     }, error = function(ex) {
[10:33:07.799]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.799]                 ...future.rng), started = ...future.startTime, 
[10:33:07.799]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.799]             version = "1.8"), class = "FutureResult")
[10:33:07.799]     }, finally = {
[10:33:07.799]         if (!identical(...future.workdir, getwd())) 
[10:33:07.799]             setwd(...future.workdir)
[10:33:07.799]         {
[10:33:07.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.799]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.799]             }
[10:33:07.799]             base::options(...future.oldOptions)
[10:33:07.799]             if (.Platform$OS.type == "windows") {
[10:33:07.799]                 old_names <- names(...future.oldEnvVars)
[10:33:07.799]                 envs <- base::Sys.getenv()
[10:33:07.799]                 names <- names(envs)
[10:33:07.799]                 common <- intersect(names, old_names)
[10:33:07.799]                 added <- setdiff(names, old_names)
[10:33:07.799]                 removed <- setdiff(old_names, names)
[10:33:07.799]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.799]                   envs[common]]
[10:33:07.799]                 NAMES <- toupper(changed)
[10:33:07.799]                 args <- list()
[10:33:07.799]                 for (kk in seq_along(NAMES)) {
[10:33:07.799]                   name <- changed[[kk]]
[10:33:07.799]                   NAME <- NAMES[[kk]]
[10:33:07.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.799]                     next
[10:33:07.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.799]                 }
[10:33:07.799]                 NAMES <- toupper(added)
[10:33:07.799]                 for (kk in seq_along(NAMES)) {
[10:33:07.799]                   name <- added[[kk]]
[10:33:07.799]                   NAME <- NAMES[[kk]]
[10:33:07.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.799]                     next
[10:33:07.799]                   args[[name]] <- ""
[10:33:07.799]                 }
[10:33:07.799]                 NAMES <- toupper(removed)
[10:33:07.799]                 for (kk in seq_along(NAMES)) {
[10:33:07.799]                   name <- removed[[kk]]
[10:33:07.799]                   NAME <- NAMES[[kk]]
[10:33:07.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.799]                     next
[10:33:07.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.799]                 }
[10:33:07.799]                 if (length(args) > 0) 
[10:33:07.799]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.799]             }
[10:33:07.799]             else {
[10:33:07.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.799]             }
[10:33:07.799]             {
[10:33:07.799]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.799]                   0L) {
[10:33:07.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.799]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.799]                   base::options(opts)
[10:33:07.799]                 }
[10:33:07.799]                 {
[10:33:07.799]                   {
[10:33:07.799]                     NULL
[10:33:07.799]                     RNGkind("Mersenne-Twister")
[10:33:07.799]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.799]                       inherits = FALSE)
[10:33:07.799]                   }
[10:33:07.799]                   options(future.plan = NULL)
[10:33:07.799]                   if (is.na(NA_character_)) 
[10:33:07.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.799]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.799]                     .init = FALSE)
[10:33:07.799]                 }
[10:33:07.799]             }
[10:33:07.799]         }
[10:33:07.799]     })
[10:33:07.799]     if (TRUE) {
[10:33:07.799]         base::sink(type = "output", split = FALSE)
[10:33:07.799]         if (TRUE) {
[10:33:07.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.799]         }
[10:33:07.799]         else {
[10:33:07.799]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.799]         }
[10:33:07.799]         base::close(...future.stdout)
[10:33:07.799]         ...future.stdout <- NULL
[10:33:07.799]     }
[10:33:07.799]     ...future.result$conditions <- ...future.conditions
[10:33:07.799]     ...future.result$finished <- base::Sys.time()
[10:33:07.799]     ...future.result
[10:33:07.799] }
[10:33:07.800] assign_globals() ...
[10:33:07.800] List of 1
[10:33:07.800]  $ x: list()
[10:33:07.800]  - attr(*, "where")=List of 1
[10:33:07.800]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.800]  - attr(*, "resolved")= logi TRUE
[10:33:07.800]  - attr(*, "total_size")= num 0
[10:33:07.800]  - attr(*, "already-done")= logi TRUE
[10:33:07.803] - copied ‘x’ to environment
[10:33:07.803] assign_globals() ... done
[10:33:07.803] plan(): Setting new future strategy stack:
[10:33:07.803] List of future strategies:
[10:33:07.803] 1. sequential:
[10:33:07.803]    - args: function (..., envir = parent.frame())
[10:33:07.803]    - tweaked: FALSE
[10:33:07.803]    - call: NULL
[10:33:07.803] plan(): nbrOfWorkers() = 1
[10:33:07.804] plan(): Setting new future strategy stack:
[10:33:07.804] List of future strategies:
[10:33:07.804] 1. sequential:
[10:33:07.804]    - args: function (..., envir = parent.frame())
[10:33:07.804]    - tweaked: FALSE
[10:33:07.804]    - call: plan(strategy)
[10:33:07.805] plan(): nbrOfWorkers() = 1
[10:33:07.805] SequentialFuture started (and completed)
[10:33:07.805] - Launch lazy future ... done
[10:33:07.805] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.805] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.806] Searching for globals...
[10:33:07.809] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:33:07.810] Searching for globals ... DONE
[10:33:07.810] Resolving globals: TRUE
[10:33:07.810] Resolving any globals that are futures ...
[10:33:07.810] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:33:07.810] Resolving any globals that are futures ... DONE
[10:33:07.810] 
[10:33:07.810] 
[10:33:07.811] getGlobalsAndPackages() ... DONE
[10:33:07.811] run() for ‘Future’ ...
[10:33:07.811] - state: ‘created’
[10:33:07.811] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.811] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.811]   - Field: ‘label’
[10:33:07.812]   - Field: ‘local’
[10:33:07.812]   - Field: ‘owner’
[10:33:07.812]   - Field: ‘envir’
[10:33:07.812]   - Field: ‘packages’
[10:33:07.812]   - Field: ‘gc’
[10:33:07.812]   - Field: ‘conditions’
[10:33:07.812]   - Field: ‘expr’
[10:33:07.812]   - Field: ‘uuid’
[10:33:07.812]   - Field: ‘seed’
[10:33:07.812]   - Field: ‘version’
[10:33:07.812]   - Field: ‘result’
[10:33:07.813]   - Field: ‘asynchronous’
[10:33:07.813]   - Field: ‘calls’
[10:33:07.813]   - Field: ‘globals’
[10:33:07.813]   - Field: ‘stdout’
[10:33:07.813]   - Field: ‘earlySignal’
[10:33:07.813]   - Field: ‘lazy’
[10:33:07.813]   - Field: ‘state’
[10:33:07.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.813] - Launch lazy future ...
[10:33:07.813] Packages needed by the future expression (n = 0): <none>
[10:33:07.814] Packages needed by future strategies (n = 0): <none>
[10:33:07.814] {
[10:33:07.814]     {
[10:33:07.814]         {
[10:33:07.814]             ...future.startTime <- base::Sys.time()
[10:33:07.814]             {
[10:33:07.814]                 {
[10:33:07.814]                   {
[10:33:07.814]                     base::local({
[10:33:07.814]                       has_future <- base::requireNamespace("future", 
[10:33:07.814]                         quietly = TRUE)
[10:33:07.814]                       if (has_future) {
[10:33:07.814]                         ns <- base::getNamespace("future")
[10:33:07.814]                         version <- ns[[".package"]][["version"]]
[10:33:07.814]                         if (is.null(version)) 
[10:33:07.814]                           version <- utils::packageVersion("future")
[10:33:07.814]                       }
[10:33:07.814]                       else {
[10:33:07.814]                         version <- NULL
[10:33:07.814]                       }
[10:33:07.814]                       if (!has_future || version < "1.8.0") {
[10:33:07.814]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.814]                           "", base::R.version$version.string), 
[10:33:07.814]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.814]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.814]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.814]                             "release", "version")], collapse = " "), 
[10:33:07.814]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.814]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.814]                           info)
[10:33:07.814]                         info <- base::paste(info, collapse = "; ")
[10:33:07.814]                         if (!has_future) {
[10:33:07.814]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.814]                             info)
[10:33:07.814]                         }
[10:33:07.814]                         else {
[10:33:07.814]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.814]                             info, version)
[10:33:07.814]                         }
[10:33:07.814]                         base::stop(msg)
[10:33:07.814]                       }
[10:33:07.814]                     })
[10:33:07.814]                   }
[10:33:07.814]                   ...future.strategy.old <- future::plan("list")
[10:33:07.814]                   options(future.plan = NULL)
[10:33:07.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.814]                 }
[10:33:07.814]                 ...future.workdir <- getwd()
[10:33:07.814]             }
[10:33:07.814]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.814]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.814]         }
[10:33:07.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.814]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.814]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.814]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.814]             base::names(...future.oldOptions))
[10:33:07.814]     }
[10:33:07.814]     if (FALSE) {
[10:33:07.814]     }
[10:33:07.814]     else {
[10:33:07.814]         if (TRUE) {
[10:33:07.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.814]                 open = "w")
[10:33:07.814]         }
[10:33:07.814]         else {
[10:33:07.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.814]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.814]         }
[10:33:07.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.814]             base::sink(type = "output", split = FALSE)
[10:33:07.814]             base::close(...future.stdout)
[10:33:07.814]         }, add = TRUE)
[10:33:07.814]     }
[10:33:07.814]     ...future.frame <- base::sys.nframe()
[10:33:07.814]     ...future.conditions <- base::list()
[10:33:07.814]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.814]     if (FALSE) {
[10:33:07.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.814]     }
[10:33:07.814]     ...future.result <- base::tryCatch({
[10:33:07.814]         base::withCallingHandlers({
[10:33:07.814]             ...future.value <- base::withVisible(base::local({
[10:33:07.814]                 x <- list(b = 2)
[10:33:07.814]                 x$a <- 1
[10:33:07.814]                 x
[10:33:07.814]             }))
[10:33:07.814]             future::FutureResult(value = ...future.value$value, 
[10:33:07.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.814]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.814]                     ...future.globalenv.names))
[10:33:07.814]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.814]         }, condition = base::local({
[10:33:07.814]             c <- base::c
[10:33:07.814]             inherits <- base::inherits
[10:33:07.814]             invokeRestart <- base::invokeRestart
[10:33:07.814]             length <- base::length
[10:33:07.814]             list <- base::list
[10:33:07.814]             seq.int <- base::seq.int
[10:33:07.814]             signalCondition <- base::signalCondition
[10:33:07.814]             sys.calls <- base::sys.calls
[10:33:07.814]             `[[` <- base::`[[`
[10:33:07.814]             `+` <- base::`+`
[10:33:07.814]             `<<-` <- base::`<<-`
[10:33:07.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.814]                   3L)]
[10:33:07.814]             }
[10:33:07.814]             function(cond) {
[10:33:07.814]                 is_error <- inherits(cond, "error")
[10:33:07.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.814]                   NULL)
[10:33:07.814]                 if (is_error) {
[10:33:07.814]                   sessionInformation <- function() {
[10:33:07.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.814]                       search = base::search(), system = base::Sys.info())
[10:33:07.814]                   }
[10:33:07.814]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.814]                     cond$call), session = sessionInformation(), 
[10:33:07.814]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.814]                   signalCondition(cond)
[10:33:07.814]                 }
[10:33:07.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.814]                 "immediateCondition"))) {
[10:33:07.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.814]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.814]                   if (TRUE && !signal) {
[10:33:07.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.814]                     {
[10:33:07.814]                       inherits <- base::inherits
[10:33:07.814]                       invokeRestart <- base::invokeRestart
[10:33:07.814]                       is.null <- base::is.null
[10:33:07.814]                       muffled <- FALSE
[10:33:07.814]                       if (inherits(cond, "message")) {
[10:33:07.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.814]                         if (muffled) 
[10:33:07.814]                           invokeRestart("muffleMessage")
[10:33:07.814]                       }
[10:33:07.814]                       else if (inherits(cond, "warning")) {
[10:33:07.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.814]                         if (muffled) 
[10:33:07.814]                           invokeRestart("muffleWarning")
[10:33:07.814]                       }
[10:33:07.814]                       else if (inherits(cond, "condition")) {
[10:33:07.814]                         if (!is.null(pattern)) {
[10:33:07.814]                           computeRestarts <- base::computeRestarts
[10:33:07.814]                           grepl <- base::grepl
[10:33:07.814]                           restarts <- computeRestarts(cond)
[10:33:07.814]                           for (restart in restarts) {
[10:33:07.814]                             name <- restart$name
[10:33:07.814]                             if (is.null(name)) 
[10:33:07.814]                               next
[10:33:07.814]                             if (!grepl(pattern, name)) 
[10:33:07.814]                               next
[10:33:07.814]                             invokeRestart(restart)
[10:33:07.814]                             muffled <- TRUE
[10:33:07.814]                             break
[10:33:07.814]                           }
[10:33:07.814]                         }
[10:33:07.814]                       }
[10:33:07.814]                       invisible(muffled)
[10:33:07.814]                     }
[10:33:07.814]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.814]                   }
[10:33:07.814]                 }
[10:33:07.814]                 else {
[10:33:07.814]                   if (TRUE) {
[10:33:07.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.814]                     {
[10:33:07.814]                       inherits <- base::inherits
[10:33:07.814]                       invokeRestart <- base::invokeRestart
[10:33:07.814]                       is.null <- base::is.null
[10:33:07.814]                       muffled <- FALSE
[10:33:07.814]                       if (inherits(cond, "message")) {
[10:33:07.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.814]                         if (muffled) 
[10:33:07.814]                           invokeRestart("muffleMessage")
[10:33:07.814]                       }
[10:33:07.814]                       else if (inherits(cond, "warning")) {
[10:33:07.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.814]                         if (muffled) 
[10:33:07.814]                           invokeRestart("muffleWarning")
[10:33:07.814]                       }
[10:33:07.814]                       else if (inherits(cond, "condition")) {
[10:33:07.814]                         if (!is.null(pattern)) {
[10:33:07.814]                           computeRestarts <- base::computeRestarts
[10:33:07.814]                           grepl <- base::grepl
[10:33:07.814]                           restarts <- computeRestarts(cond)
[10:33:07.814]                           for (restart in restarts) {
[10:33:07.814]                             name <- restart$name
[10:33:07.814]                             if (is.null(name)) 
[10:33:07.814]                               next
[10:33:07.814]                             if (!grepl(pattern, name)) 
[10:33:07.814]                               next
[10:33:07.814]                             invokeRestart(restart)
[10:33:07.814]                             muffled <- TRUE
[10:33:07.814]                             break
[10:33:07.814]                           }
[10:33:07.814]                         }
[10:33:07.814]                       }
[10:33:07.814]                       invisible(muffled)
[10:33:07.814]                     }
[10:33:07.814]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.814]                   }
[10:33:07.814]                 }
[10:33:07.814]             }
[10:33:07.814]         }))
[10:33:07.814]     }, error = function(ex) {
[10:33:07.814]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.814]                 ...future.rng), started = ...future.startTime, 
[10:33:07.814]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.814]             version = "1.8"), class = "FutureResult")
[10:33:07.814]     }, finally = {
[10:33:07.814]         if (!identical(...future.workdir, getwd())) 
[10:33:07.814]             setwd(...future.workdir)
[10:33:07.814]         {
[10:33:07.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.814]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.814]             }
[10:33:07.814]             base::options(...future.oldOptions)
[10:33:07.814]             if (.Platform$OS.type == "windows") {
[10:33:07.814]                 old_names <- names(...future.oldEnvVars)
[10:33:07.814]                 envs <- base::Sys.getenv()
[10:33:07.814]                 names <- names(envs)
[10:33:07.814]                 common <- intersect(names, old_names)
[10:33:07.814]                 added <- setdiff(names, old_names)
[10:33:07.814]                 removed <- setdiff(old_names, names)
[10:33:07.814]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.814]                   envs[common]]
[10:33:07.814]                 NAMES <- toupper(changed)
[10:33:07.814]                 args <- list()
[10:33:07.814]                 for (kk in seq_along(NAMES)) {
[10:33:07.814]                   name <- changed[[kk]]
[10:33:07.814]                   NAME <- NAMES[[kk]]
[10:33:07.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.814]                     next
[10:33:07.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.814]                 }
[10:33:07.814]                 NAMES <- toupper(added)
[10:33:07.814]                 for (kk in seq_along(NAMES)) {
[10:33:07.814]                   name <- added[[kk]]
[10:33:07.814]                   NAME <- NAMES[[kk]]
[10:33:07.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.814]                     next
[10:33:07.814]                   args[[name]] <- ""
[10:33:07.814]                 }
[10:33:07.814]                 NAMES <- toupper(removed)
[10:33:07.814]                 for (kk in seq_along(NAMES)) {
[10:33:07.814]                   name <- removed[[kk]]
[10:33:07.814]                   NAME <- NAMES[[kk]]
[10:33:07.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.814]                     next
[10:33:07.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.814]                 }
[10:33:07.814]                 if (length(args) > 0) 
[10:33:07.814]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.814]             }
[10:33:07.814]             else {
[10:33:07.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.814]             }
[10:33:07.814]             {
[10:33:07.814]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.814]                   0L) {
[10:33:07.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.814]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.814]                   base::options(opts)
[10:33:07.814]                 }
[10:33:07.814]                 {
[10:33:07.814]                   {
[10:33:07.814]                     NULL
[10:33:07.814]                     RNGkind("Mersenne-Twister")
[10:33:07.814]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.814]                       inherits = FALSE)
[10:33:07.814]                   }
[10:33:07.814]                   options(future.plan = NULL)
[10:33:07.814]                   if (is.na(NA_character_)) 
[10:33:07.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.814]                     .init = FALSE)
[10:33:07.814]                 }
[10:33:07.814]             }
[10:33:07.814]         }
[10:33:07.814]     })
[10:33:07.814]     if (TRUE) {
[10:33:07.814]         base::sink(type = "output", split = FALSE)
[10:33:07.814]         if (TRUE) {
[10:33:07.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.814]         }
[10:33:07.814]         else {
[10:33:07.814]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.814]         }
[10:33:07.814]         base::close(...future.stdout)
[10:33:07.814]         ...future.stdout <- NULL
[10:33:07.814]     }
[10:33:07.814]     ...future.result$conditions <- ...future.conditions
[10:33:07.814]     ...future.result$finished <- base::Sys.time()
[10:33:07.814]     ...future.result
[10:33:07.814] }
[10:33:07.816] plan(): Setting new future strategy stack:
[10:33:07.816] List of future strategies:
[10:33:07.816] 1. sequential:
[10:33:07.816]    - args: function (..., envir = parent.frame())
[10:33:07.816]    - tweaked: FALSE
[10:33:07.816]    - call: NULL
[10:33:07.816] plan(): nbrOfWorkers() = 1
[10:33:07.817] plan(): Setting new future strategy stack:
[10:33:07.817] List of future strategies:
[10:33:07.817] 1. sequential:
[10:33:07.817]    - args: function (..., envir = parent.frame())
[10:33:07.817]    - tweaked: FALSE
[10:33:07.817]    - call: plan(strategy)
[10:33:07.817] plan(): nbrOfWorkers() = 1
[10:33:07.818] SequentialFuture started (and completed)
[10:33:07.818] - Launch lazy future ... done
[10:33:07.818] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.818] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.818] Searching for globals...
[10:33:07.820] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:07.820] Searching for globals ... DONE
[10:33:07.820] Resolving globals: TRUE
[10:33:07.820] Resolving any globals that are futures ...
[10:33:07.821] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:07.821] Resolving any globals that are futures ... DONE
[10:33:07.821] Resolving futures part of globals (recursively) ...
[10:33:07.821] resolve() on list ...
[10:33:07.821]  recursive: 99
[10:33:07.821]  length: 1
[10:33:07.822]  elements: ‘x’
[10:33:07.822]  length: 0 (resolved future 1)
[10:33:07.822] resolve() on list ... DONE
[10:33:07.822] - globals: [1] ‘x’
[10:33:07.822] Resolving futures part of globals (recursively) ... DONE
[10:33:07.822] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.822] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.823] - globals: [1] ‘x’
[10:33:07.823] 
[10:33:07.823] getGlobalsAndPackages() ... DONE
[10:33:07.823] run() for ‘Future’ ...
[10:33:07.823] - state: ‘created’
[10:33:07.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.823] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.824]   - Field: ‘label’
[10:33:07.824]   - Field: ‘local’
[10:33:07.824]   - Field: ‘owner’
[10:33:07.824]   - Field: ‘envir’
[10:33:07.824]   - Field: ‘packages’
[10:33:07.824]   - Field: ‘gc’
[10:33:07.824]   - Field: ‘conditions’
[10:33:07.824]   - Field: ‘expr’
[10:33:07.824]   - Field: ‘uuid’
[10:33:07.824]   - Field: ‘seed’
[10:33:07.825]   - Field: ‘version’
[10:33:07.825]   - Field: ‘result’
[10:33:07.825]   - Field: ‘asynchronous’
[10:33:07.825]   - Field: ‘calls’
[10:33:07.825]   - Field: ‘globals’
[10:33:07.825]   - Field: ‘stdout’
[10:33:07.825]   - Field: ‘earlySignal’
[10:33:07.825]   - Field: ‘lazy’
[10:33:07.825]   - Field: ‘state’
[10:33:07.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.826] - Launch lazy future ...
[10:33:07.826] Packages needed by the future expression (n = 0): <none>
[10:33:07.826] Packages needed by future strategies (n = 0): <none>
[10:33:07.826] {
[10:33:07.826]     {
[10:33:07.826]         {
[10:33:07.826]             ...future.startTime <- base::Sys.time()
[10:33:07.826]             {
[10:33:07.826]                 {
[10:33:07.826]                   {
[10:33:07.826]                     base::local({
[10:33:07.826]                       has_future <- base::requireNamespace("future", 
[10:33:07.826]                         quietly = TRUE)
[10:33:07.826]                       if (has_future) {
[10:33:07.826]                         ns <- base::getNamespace("future")
[10:33:07.826]                         version <- ns[[".package"]][["version"]]
[10:33:07.826]                         if (is.null(version)) 
[10:33:07.826]                           version <- utils::packageVersion("future")
[10:33:07.826]                       }
[10:33:07.826]                       else {
[10:33:07.826]                         version <- NULL
[10:33:07.826]                       }
[10:33:07.826]                       if (!has_future || version < "1.8.0") {
[10:33:07.826]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.826]                           "", base::R.version$version.string), 
[10:33:07.826]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.826]                             "release", "version")], collapse = " "), 
[10:33:07.826]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.826]                           info)
[10:33:07.826]                         info <- base::paste(info, collapse = "; ")
[10:33:07.826]                         if (!has_future) {
[10:33:07.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.826]                             info)
[10:33:07.826]                         }
[10:33:07.826]                         else {
[10:33:07.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.826]                             info, version)
[10:33:07.826]                         }
[10:33:07.826]                         base::stop(msg)
[10:33:07.826]                       }
[10:33:07.826]                     })
[10:33:07.826]                   }
[10:33:07.826]                   ...future.strategy.old <- future::plan("list")
[10:33:07.826]                   options(future.plan = NULL)
[10:33:07.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.826]                 }
[10:33:07.826]                 ...future.workdir <- getwd()
[10:33:07.826]             }
[10:33:07.826]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.826]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.826]         }
[10:33:07.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.826]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.826]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.826]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.826]             base::names(...future.oldOptions))
[10:33:07.826]     }
[10:33:07.826]     if (FALSE) {
[10:33:07.826]     }
[10:33:07.826]     else {
[10:33:07.826]         if (TRUE) {
[10:33:07.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.826]                 open = "w")
[10:33:07.826]         }
[10:33:07.826]         else {
[10:33:07.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.826]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.826]         }
[10:33:07.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.826]             base::sink(type = "output", split = FALSE)
[10:33:07.826]             base::close(...future.stdout)
[10:33:07.826]         }, add = TRUE)
[10:33:07.826]     }
[10:33:07.826]     ...future.frame <- base::sys.nframe()
[10:33:07.826]     ...future.conditions <- base::list()
[10:33:07.826]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.826]     if (FALSE) {
[10:33:07.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.826]     }
[10:33:07.826]     ...future.result <- base::tryCatch({
[10:33:07.826]         base::withCallingHandlers({
[10:33:07.826]             ...future.value <- base::withVisible(base::local({
[10:33:07.826]                 x[["a"]] <- 1
[10:33:07.826]                 x
[10:33:07.826]             }))
[10:33:07.826]             future::FutureResult(value = ...future.value$value, 
[10:33:07.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.826]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.826]                     ...future.globalenv.names))
[10:33:07.826]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.826]         }, condition = base::local({
[10:33:07.826]             c <- base::c
[10:33:07.826]             inherits <- base::inherits
[10:33:07.826]             invokeRestart <- base::invokeRestart
[10:33:07.826]             length <- base::length
[10:33:07.826]             list <- base::list
[10:33:07.826]             seq.int <- base::seq.int
[10:33:07.826]             signalCondition <- base::signalCondition
[10:33:07.826]             sys.calls <- base::sys.calls
[10:33:07.826]             `[[` <- base::`[[`
[10:33:07.826]             `+` <- base::`+`
[10:33:07.826]             `<<-` <- base::`<<-`
[10:33:07.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.826]                   3L)]
[10:33:07.826]             }
[10:33:07.826]             function(cond) {
[10:33:07.826]                 is_error <- inherits(cond, "error")
[10:33:07.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.826]                   NULL)
[10:33:07.826]                 if (is_error) {
[10:33:07.826]                   sessionInformation <- function() {
[10:33:07.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.826]                       search = base::search(), system = base::Sys.info())
[10:33:07.826]                   }
[10:33:07.826]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.826]                     cond$call), session = sessionInformation(), 
[10:33:07.826]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.826]                   signalCondition(cond)
[10:33:07.826]                 }
[10:33:07.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.826]                 "immediateCondition"))) {
[10:33:07.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.826]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.826]                   if (TRUE && !signal) {
[10:33:07.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.826]                     {
[10:33:07.826]                       inherits <- base::inherits
[10:33:07.826]                       invokeRestart <- base::invokeRestart
[10:33:07.826]                       is.null <- base::is.null
[10:33:07.826]                       muffled <- FALSE
[10:33:07.826]                       if (inherits(cond, "message")) {
[10:33:07.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.826]                         if (muffled) 
[10:33:07.826]                           invokeRestart("muffleMessage")
[10:33:07.826]                       }
[10:33:07.826]                       else if (inherits(cond, "warning")) {
[10:33:07.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.826]                         if (muffled) 
[10:33:07.826]                           invokeRestart("muffleWarning")
[10:33:07.826]                       }
[10:33:07.826]                       else if (inherits(cond, "condition")) {
[10:33:07.826]                         if (!is.null(pattern)) {
[10:33:07.826]                           computeRestarts <- base::computeRestarts
[10:33:07.826]                           grepl <- base::grepl
[10:33:07.826]                           restarts <- computeRestarts(cond)
[10:33:07.826]                           for (restart in restarts) {
[10:33:07.826]                             name <- restart$name
[10:33:07.826]                             if (is.null(name)) 
[10:33:07.826]                               next
[10:33:07.826]                             if (!grepl(pattern, name)) 
[10:33:07.826]                               next
[10:33:07.826]                             invokeRestart(restart)
[10:33:07.826]                             muffled <- TRUE
[10:33:07.826]                             break
[10:33:07.826]                           }
[10:33:07.826]                         }
[10:33:07.826]                       }
[10:33:07.826]                       invisible(muffled)
[10:33:07.826]                     }
[10:33:07.826]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.826]                   }
[10:33:07.826]                 }
[10:33:07.826]                 else {
[10:33:07.826]                   if (TRUE) {
[10:33:07.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.826]                     {
[10:33:07.826]                       inherits <- base::inherits
[10:33:07.826]                       invokeRestart <- base::invokeRestart
[10:33:07.826]                       is.null <- base::is.null
[10:33:07.826]                       muffled <- FALSE
[10:33:07.826]                       if (inherits(cond, "message")) {
[10:33:07.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.826]                         if (muffled) 
[10:33:07.826]                           invokeRestart("muffleMessage")
[10:33:07.826]                       }
[10:33:07.826]                       else if (inherits(cond, "warning")) {
[10:33:07.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.826]                         if (muffled) 
[10:33:07.826]                           invokeRestart("muffleWarning")
[10:33:07.826]                       }
[10:33:07.826]                       else if (inherits(cond, "condition")) {
[10:33:07.826]                         if (!is.null(pattern)) {
[10:33:07.826]                           computeRestarts <- base::computeRestarts
[10:33:07.826]                           grepl <- base::grepl
[10:33:07.826]                           restarts <- computeRestarts(cond)
[10:33:07.826]                           for (restart in restarts) {
[10:33:07.826]                             name <- restart$name
[10:33:07.826]                             if (is.null(name)) 
[10:33:07.826]                               next
[10:33:07.826]                             if (!grepl(pattern, name)) 
[10:33:07.826]                               next
[10:33:07.826]                             invokeRestart(restart)
[10:33:07.826]                             muffled <- TRUE
[10:33:07.826]                             break
[10:33:07.826]                           }
[10:33:07.826]                         }
[10:33:07.826]                       }
[10:33:07.826]                       invisible(muffled)
[10:33:07.826]                     }
[10:33:07.826]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.826]                   }
[10:33:07.826]                 }
[10:33:07.826]             }
[10:33:07.826]         }))
[10:33:07.826]     }, error = function(ex) {
[10:33:07.826]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.826]                 ...future.rng), started = ...future.startTime, 
[10:33:07.826]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.826]             version = "1.8"), class = "FutureResult")
[10:33:07.826]     }, finally = {
[10:33:07.826]         if (!identical(...future.workdir, getwd())) 
[10:33:07.826]             setwd(...future.workdir)
[10:33:07.826]         {
[10:33:07.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.826]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.826]             }
[10:33:07.826]             base::options(...future.oldOptions)
[10:33:07.826]             if (.Platform$OS.type == "windows") {
[10:33:07.826]                 old_names <- names(...future.oldEnvVars)
[10:33:07.826]                 envs <- base::Sys.getenv()
[10:33:07.826]                 names <- names(envs)
[10:33:07.826]                 common <- intersect(names, old_names)
[10:33:07.826]                 added <- setdiff(names, old_names)
[10:33:07.826]                 removed <- setdiff(old_names, names)
[10:33:07.826]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.826]                   envs[common]]
[10:33:07.826]                 NAMES <- toupper(changed)
[10:33:07.826]                 args <- list()
[10:33:07.826]                 for (kk in seq_along(NAMES)) {
[10:33:07.826]                   name <- changed[[kk]]
[10:33:07.826]                   NAME <- NAMES[[kk]]
[10:33:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.826]                     next
[10:33:07.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.826]                 }
[10:33:07.826]                 NAMES <- toupper(added)
[10:33:07.826]                 for (kk in seq_along(NAMES)) {
[10:33:07.826]                   name <- added[[kk]]
[10:33:07.826]                   NAME <- NAMES[[kk]]
[10:33:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.826]                     next
[10:33:07.826]                   args[[name]] <- ""
[10:33:07.826]                 }
[10:33:07.826]                 NAMES <- toupper(removed)
[10:33:07.826]                 for (kk in seq_along(NAMES)) {
[10:33:07.826]                   name <- removed[[kk]]
[10:33:07.826]                   NAME <- NAMES[[kk]]
[10:33:07.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.826]                     next
[10:33:07.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.826]                 }
[10:33:07.826]                 if (length(args) > 0) 
[10:33:07.826]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.826]             }
[10:33:07.826]             else {
[10:33:07.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.826]             }
[10:33:07.826]             {
[10:33:07.826]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.826]                   0L) {
[10:33:07.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.826]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.826]                   base::options(opts)
[10:33:07.826]                 }
[10:33:07.826]                 {
[10:33:07.826]                   {
[10:33:07.826]                     NULL
[10:33:07.826]                     RNGkind("Mersenne-Twister")
[10:33:07.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.826]                       inherits = FALSE)
[10:33:07.826]                   }
[10:33:07.826]                   options(future.plan = NULL)
[10:33:07.826]                   if (is.na(NA_character_)) 
[10:33:07.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.826]                     .init = FALSE)
[10:33:07.826]                 }
[10:33:07.826]             }
[10:33:07.826]         }
[10:33:07.826]     })
[10:33:07.826]     if (TRUE) {
[10:33:07.826]         base::sink(type = "output", split = FALSE)
[10:33:07.826]         if (TRUE) {
[10:33:07.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.826]         }
[10:33:07.826]         else {
[10:33:07.826]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.826]         }
[10:33:07.826]         base::close(...future.stdout)
[10:33:07.826]         ...future.stdout <- NULL
[10:33:07.826]     }
[10:33:07.826]     ...future.result$conditions <- ...future.conditions
[10:33:07.826]     ...future.result$finished <- base::Sys.time()
[10:33:07.826]     ...future.result
[10:33:07.826] }
[10:33:07.828] assign_globals() ...
[10:33:07.828] List of 1
[10:33:07.828]  $ x: list()
[10:33:07.828]  - attr(*, "where")=List of 1
[10:33:07.828]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.828]  - attr(*, "resolved")= logi TRUE
[10:33:07.828]  - attr(*, "total_size")= num 0
[10:33:07.828]  - attr(*, "already-done")= logi TRUE
[10:33:07.830] - copied ‘x’ to environment
[10:33:07.830] assign_globals() ... done
[10:33:07.830] plan(): Setting new future strategy stack:
[10:33:07.830] List of future strategies:
[10:33:07.830] 1. sequential:
[10:33:07.830]    - args: function (..., envir = parent.frame())
[10:33:07.830]    - tweaked: FALSE
[10:33:07.830]    - call: NULL
[10:33:07.831] plan(): nbrOfWorkers() = 1
[10:33:07.832] plan(): Setting new future strategy stack:
[10:33:07.832] List of future strategies:
[10:33:07.832] 1. sequential:
[10:33:07.832]    - args: function (..., envir = parent.frame())
[10:33:07.832]    - tweaked: FALSE
[10:33:07.832]    - call: plan(strategy)
[10:33:07.832] plan(): nbrOfWorkers() = 1
[10:33:07.832] SequentialFuture started (and completed)
[10:33:07.832] - Launch lazy future ... done
[10:33:07.832] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.833] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.833] Searching for globals...
[10:33:07.836] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:07.836] Searching for globals ... DONE
[10:33:07.836] Resolving globals: TRUE
[10:33:07.836] Resolving any globals that are futures ...
[10:33:07.836] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:07.837] Resolving any globals that are futures ... DONE
[10:33:07.837] Resolving futures part of globals (recursively) ...
[10:33:07.837] resolve() on list ...
[10:33:07.837]  recursive: 99
[10:33:07.837]  length: 1
[10:33:07.837]  elements: ‘x’
[10:33:07.838]  length: 0 (resolved future 1)
[10:33:07.838] resolve() on list ... DONE
[10:33:07.838] - globals: [1] ‘x’
[10:33:07.838] Resolving futures part of globals (recursively) ... DONE
[10:33:07.838] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.838] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.838] - globals: [1] ‘x’
[10:33:07.838] 
[10:33:07.839] getGlobalsAndPackages() ... DONE
[10:33:07.839] run() for ‘Future’ ...
[10:33:07.839] - state: ‘created’
[10:33:07.839] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.840]   - Field: ‘label’
[10:33:07.840]   - Field: ‘local’
[10:33:07.840]   - Field: ‘owner’
[10:33:07.840]   - Field: ‘envir’
[10:33:07.840]   - Field: ‘packages’
[10:33:07.840]   - Field: ‘gc’
[10:33:07.840]   - Field: ‘conditions’
[10:33:07.840]   - Field: ‘expr’
[10:33:07.840]   - Field: ‘uuid’
[10:33:07.840]   - Field: ‘seed’
[10:33:07.840]   - Field: ‘version’
[10:33:07.840]   - Field: ‘result’
[10:33:07.841]   - Field: ‘asynchronous’
[10:33:07.841]   - Field: ‘calls’
[10:33:07.841]   - Field: ‘globals’
[10:33:07.841]   - Field: ‘stdout’
[10:33:07.841]   - Field: ‘earlySignal’
[10:33:07.841]   - Field: ‘lazy’
[10:33:07.841]   - Field: ‘state’
[10:33:07.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.841] - Launch lazy future ...
[10:33:07.841] Packages needed by the future expression (n = 0): <none>
[10:33:07.842] Packages needed by future strategies (n = 0): <none>
[10:33:07.842] {
[10:33:07.842]     {
[10:33:07.842]         {
[10:33:07.842]             ...future.startTime <- base::Sys.time()
[10:33:07.842]             {
[10:33:07.842]                 {
[10:33:07.842]                   {
[10:33:07.842]                     base::local({
[10:33:07.842]                       has_future <- base::requireNamespace("future", 
[10:33:07.842]                         quietly = TRUE)
[10:33:07.842]                       if (has_future) {
[10:33:07.842]                         ns <- base::getNamespace("future")
[10:33:07.842]                         version <- ns[[".package"]][["version"]]
[10:33:07.842]                         if (is.null(version)) 
[10:33:07.842]                           version <- utils::packageVersion("future")
[10:33:07.842]                       }
[10:33:07.842]                       else {
[10:33:07.842]                         version <- NULL
[10:33:07.842]                       }
[10:33:07.842]                       if (!has_future || version < "1.8.0") {
[10:33:07.842]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.842]                           "", base::R.version$version.string), 
[10:33:07.842]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.842]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.842]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.842]                             "release", "version")], collapse = " "), 
[10:33:07.842]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.842]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.842]                           info)
[10:33:07.842]                         info <- base::paste(info, collapse = "; ")
[10:33:07.842]                         if (!has_future) {
[10:33:07.842]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.842]                             info)
[10:33:07.842]                         }
[10:33:07.842]                         else {
[10:33:07.842]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.842]                             info, version)
[10:33:07.842]                         }
[10:33:07.842]                         base::stop(msg)
[10:33:07.842]                       }
[10:33:07.842]                     })
[10:33:07.842]                   }
[10:33:07.842]                   ...future.strategy.old <- future::plan("list")
[10:33:07.842]                   options(future.plan = NULL)
[10:33:07.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.842]                 }
[10:33:07.842]                 ...future.workdir <- getwd()
[10:33:07.842]             }
[10:33:07.842]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.842]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.842]         }
[10:33:07.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.842]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.842]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.842]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.842]             base::names(...future.oldOptions))
[10:33:07.842]     }
[10:33:07.842]     if (FALSE) {
[10:33:07.842]     }
[10:33:07.842]     else {
[10:33:07.842]         if (TRUE) {
[10:33:07.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.842]                 open = "w")
[10:33:07.842]         }
[10:33:07.842]         else {
[10:33:07.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.842]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.842]         }
[10:33:07.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.842]             base::sink(type = "output", split = FALSE)
[10:33:07.842]             base::close(...future.stdout)
[10:33:07.842]         }, add = TRUE)
[10:33:07.842]     }
[10:33:07.842]     ...future.frame <- base::sys.nframe()
[10:33:07.842]     ...future.conditions <- base::list()
[10:33:07.842]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.842]     if (FALSE) {
[10:33:07.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.842]     }
[10:33:07.842]     ...future.result <- base::tryCatch({
[10:33:07.842]         base::withCallingHandlers({
[10:33:07.842]             ...future.value <- base::withVisible(base::local({
[10:33:07.842]                 x[["a"]] <- 1
[10:33:07.842]                 x
[10:33:07.842]             }))
[10:33:07.842]             future::FutureResult(value = ...future.value$value, 
[10:33:07.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.842]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.842]                     ...future.globalenv.names))
[10:33:07.842]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.842]         }, condition = base::local({
[10:33:07.842]             c <- base::c
[10:33:07.842]             inherits <- base::inherits
[10:33:07.842]             invokeRestart <- base::invokeRestart
[10:33:07.842]             length <- base::length
[10:33:07.842]             list <- base::list
[10:33:07.842]             seq.int <- base::seq.int
[10:33:07.842]             signalCondition <- base::signalCondition
[10:33:07.842]             sys.calls <- base::sys.calls
[10:33:07.842]             `[[` <- base::`[[`
[10:33:07.842]             `+` <- base::`+`
[10:33:07.842]             `<<-` <- base::`<<-`
[10:33:07.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.842]                   3L)]
[10:33:07.842]             }
[10:33:07.842]             function(cond) {
[10:33:07.842]                 is_error <- inherits(cond, "error")
[10:33:07.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.842]                   NULL)
[10:33:07.842]                 if (is_error) {
[10:33:07.842]                   sessionInformation <- function() {
[10:33:07.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.842]                       search = base::search(), system = base::Sys.info())
[10:33:07.842]                   }
[10:33:07.842]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.842]                     cond$call), session = sessionInformation(), 
[10:33:07.842]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.842]                   signalCondition(cond)
[10:33:07.842]                 }
[10:33:07.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.842]                 "immediateCondition"))) {
[10:33:07.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.842]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.842]                   if (TRUE && !signal) {
[10:33:07.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.842]                     {
[10:33:07.842]                       inherits <- base::inherits
[10:33:07.842]                       invokeRestart <- base::invokeRestart
[10:33:07.842]                       is.null <- base::is.null
[10:33:07.842]                       muffled <- FALSE
[10:33:07.842]                       if (inherits(cond, "message")) {
[10:33:07.842]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.842]                         if (muffled) 
[10:33:07.842]                           invokeRestart("muffleMessage")
[10:33:07.842]                       }
[10:33:07.842]                       else if (inherits(cond, "warning")) {
[10:33:07.842]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.842]                         if (muffled) 
[10:33:07.842]                           invokeRestart("muffleWarning")
[10:33:07.842]                       }
[10:33:07.842]                       else if (inherits(cond, "condition")) {
[10:33:07.842]                         if (!is.null(pattern)) {
[10:33:07.842]                           computeRestarts <- base::computeRestarts
[10:33:07.842]                           grepl <- base::grepl
[10:33:07.842]                           restarts <- computeRestarts(cond)
[10:33:07.842]                           for (restart in restarts) {
[10:33:07.842]                             name <- restart$name
[10:33:07.842]                             if (is.null(name)) 
[10:33:07.842]                               next
[10:33:07.842]                             if (!grepl(pattern, name)) 
[10:33:07.842]                               next
[10:33:07.842]                             invokeRestart(restart)
[10:33:07.842]                             muffled <- TRUE
[10:33:07.842]                             break
[10:33:07.842]                           }
[10:33:07.842]                         }
[10:33:07.842]                       }
[10:33:07.842]                       invisible(muffled)
[10:33:07.842]                     }
[10:33:07.842]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.842]                   }
[10:33:07.842]                 }
[10:33:07.842]                 else {
[10:33:07.842]                   if (TRUE) {
[10:33:07.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.842]                     {
[10:33:07.842]                       inherits <- base::inherits
[10:33:07.842]                       invokeRestart <- base::invokeRestart
[10:33:07.842]                       is.null <- base::is.null
[10:33:07.842]                       muffled <- FALSE
[10:33:07.842]                       if (inherits(cond, "message")) {
[10:33:07.842]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.842]                         if (muffled) 
[10:33:07.842]                           invokeRestart("muffleMessage")
[10:33:07.842]                       }
[10:33:07.842]                       else if (inherits(cond, "warning")) {
[10:33:07.842]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.842]                         if (muffled) 
[10:33:07.842]                           invokeRestart("muffleWarning")
[10:33:07.842]                       }
[10:33:07.842]                       else if (inherits(cond, "condition")) {
[10:33:07.842]                         if (!is.null(pattern)) {
[10:33:07.842]                           computeRestarts <- base::computeRestarts
[10:33:07.842]                           grepl <- base::grepl
[10:33:07.842]                           restarts <- computeRestarts(cond)
[10:33:07.842]                           for (restart in restarts) {
[10:33:07.842]                             name <- restart$name
[10:33:07.842]                             if (is.null(name)) 
[10:33:07.842]                               next
[10:33:07.842]                             if (!grepl(pattern, name)) 
[10:33:07.842]                               next
[10:33:07.842]                             invokeRestart(restart)
[10:33:07.842]                             muffled <- TRUE
[10:33:07.842]                             break
[10:33:07.842]                           }
[10:33:07.842]                         }
[10:33:07.842]                       }
[10:33:07.842]                       invisible(muffled)
[10:33:07.842]                     }
[10:33:07.842]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.842]                   }
[10:33:07.842]                 }
[10:33:07.842]             }
[10:33:07.842]         }))
[10:33:07.842]     }, error = function(ex) {
[10:33:07.842]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.842]                 ...future.rng), started = ...future.startTime, 
[10:33:07.842]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.842]             version = "1.8"), class = "FutureResult")
[10:33:07.842]     }, finally = {
[10:33:07.842]         if (!identical(...future.workdir, getwd())) 
[10:33:07.842]             setwd(...future.workdir)
[10:33:07.842]         {
[10:33:07.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.842]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.842]             }
[10:33:07.842]             base::options(...future.oldOptions)
[10:33:07.842]             if (.Platform$OS.type == "windows") {
[10:33:07.842]                 old_names <- names(...future.oldEnvVars)
[10:33:07.842]                 envs <- base::Sys.getenv()
[10:33:07.842]                 names <- names(envs)
[10:33:07.842]                 common <- intersect(names, old_names)
[10:33:07.842]                 added <- setdiff(names, old_names)
[10:33:07.842]                 removed <- setdiff(old_names, names)
[10:33:07.842]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.842]                   envs[common]]
[10:33:07.842]                 NAMES <- toupper(changed)
[10:33:07.842]                 args <- list()
[10:33:07.842]                 for (kk in seq_along(NAMES)) {
[10:33:07.842]                   name <- changed[[kk]]
[10:33:07.842]                   NAME <- NAMES[[kk]]
[10:33:07.842]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.842]                     next
[10:33:07.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.842]                 }
[10:33:07.842]                 NAMES <- toupper(added)
[10:33:07.842]                 for (kk in seq_along(NAMES)) {
[10:33:07.842]                   name <- added[[kk]]
[10:33:07.842]                   NAME <- NAMES[[kk]]
[10:33:07.842]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.842]                     next
[10:33:07.842]                   args[[name]] <- ""
[10:33:07.842]                 }
[10:33:07.842]                 NAMES <- toupper(removed)
[10:33:07.842]                 for (kk in seq_along(NAMES)) {
[10:33:07.842]                   name <- removed[[kk]]
[10:33:07.842]                   NAME <- NAMES[[kk]]
[10:33:07.842]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.842]                     next
[10:33:07.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.842]                 }
[10:33:07.842]                 if (length(args) > 0) 
[10:33:07.842]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.842]             }
[10:33:07.842]             else {
[10:33:07.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.842]             }
[10:33:07.842]             {
[10:33:07.842]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.842]                   0L) {
[10:33:07.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.842]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.842]                   base::options(opts)
[10:33:07.842]                 }
[10:33:07.842]                 {
[10:33:07.842]                   {
[10:33:07.842]                     NULL
[10:33:07.842]                     RNGkind("Mersenne-Twister")
[10:33:07.842]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.842]                       inherits = FALSE)
[10:33:07.842]                   }
[10:33:07.842]                   options(future.plan = NULL)
[10:33:07.842]                   if (is.na(NA_character_)) 
[10:33:07.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.842]                     .init = FALSE)
[10:33:07.842]                 }
[10:33:07.842]             }
[10:33:07.842]         }
[10:33:07.842]     })
[10:33:07.842]     if (TRUE) {
[10:33:07.842]         base::sink(type = "output", split = FALSE)
[10:33:07.842]         if (TRUE) {
[10:33:07.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.842]         }
[10:33:07.842]         else {
[10:33:07.842]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.842]         }
[10:33:07.842]         base::close(...future.stdout)
[10:33:07.842]         ...future.stdout <- NULL
[10:33:07.842]     }
[10:33:07.842]     ...future.result$conditions <- ...future.conditions
[10:33:07.842]     ...future.result$finished <- base::Sys.time()
[10:33:07.842]     ...future.result
[10:33:07.842] }
[10:33:07.844] assign_globals() ...
[10:33:07.844] List of 1
[10:33:07.844]  $ x: list()
[10:33:07.844]  - attr(*, "where")=List of 1
[10:33:07.844]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.844]  - attr(*, "resolved")= logi TRUE
[10:33:07.844]  - attr(*, "total_size")= num 0
[10:33:07.844]  - attr(*, "already-done")= logi TRUE
[10:33:07.846] - copied ‘x’ to environment
[10:33:07.846] assign_globals() ... done
[10:33:07.846] plan(): Setting new future strategy stack:
[10:33:07.846] List of future strategies:
[10:33:07.846] 1. sequential:
[10:33:07.846]    - args: function (..., envir = parent.frame())
[10:33:07.846]    - tweaked: FALSE
[10:33:07.846]    - call: NULL
[10:33:07.847] plan(): nbrOfWorkers() = 1
[10:33:07.847] plan(): Setting new future strategy stack:
[10:33:07.847] List of future strategies:
[10:33:07.847] 1. sequential:
[10:33:07.847]    - args: function (..., envir = parent.frame())
[10:33:07.847]    - tweaked: FALSE
[10:33:07.847]    - call: plan(strategy)
[10:33:07.848] plan(): nbrOfWorkers() = 1
[10:33:07.848] SequentialFuture started (and completed)
[10:33:07.848] - Launch lazy future ... done
[10:33:07.848] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.849] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.849] Searching for globals...
[10:33:07.850] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:07.851] Searching for globals ... DONE
[10:33:07.851] Resolving globals: TRUE
[10:33:07.851] Resolving any globals that are futures ...
[10:33:07.851] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:07.851] Resolving any globals that are futures ... DONE
[10:33:07.851] Resolving futures part of globals (recursively) ...
[10:33:07.852] resolve() on list ...
[10:33:07.852]  recursive: 99
[10:33:07.852]  length: 1
[10:33:07.852]  elements: ‘x’
[10:33:07.852]  length: 0 (resolved future 1)
[10:33:07.852] resolve() on list ... DONE
[10:33:07.852] - globals: [1] ‘x’
[10:33:07.852] Resolving futures part of globals (recursively) ... DONE
[10:33:07.852] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.853] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.853] - globals: [1] ‘x’
[10:33:07.853] 
[10:33:07.853] getGlobalsAndPackages() ... DONE
[10:33:07.853] run() for ‘Future’ ...
[10:33:07.853] - state: ‘created’
[10:33:07.853] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.854] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.854]   - Field: ‘label’
[10:33:07.854]   - Field: ‘local’
[10:33:07.854]   - Field: ‘owner’
[10:33:07.854]   - Field: ‘envir’
[10:33:07.854]   - Field: ‘packages’
[10:33:07.854]   - Field: ‘gc’
[10:33:07.855]   - Field: ‘conditions’
[10:33:07.855]   - Field: ‘expr’
[10:33:07.855]   - Field: ‘uuid’
[10:33:07.855]   - Field: ‘seed’
[10:33:07.855]   - Field: ‘version’
[10:33:07.855]   - Field: ‘result’
[10:33:07.855]   - Field: ‘asynchronous’
[10:33:07.855]   - Field: ‘calls’
[10:33:07.855]   - Field: ‘globals’
[10:33:07.855]   - Field: ‘stdout’
[10:33:07.855]   - Field: ‘earlySignal’
[10:33:07.856]   - Field: ‘lazy’
[10:33:07.856]   - Field: ‘state’
[10:33:07.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.856] - Launch lazy future ...
[10:33:07.856] Packages needed by the future expression (n = 0): <none>
[10:33:07.856] Packages needed by future strategies (n = 0): <none>
[10:33:07.856] {
[10:33:07.856]     {
[10:33:07.856]         {
[10:33:07.856]             ...future.startTime <- base::Sys.time()
[10:33:07.856]             {
[10:33:07.856]                 {
[10:33:07.856]                   {
[10:33:07.856]                     base::local({
[10:33:07.856]                       has_future <- base::requireNamespace("future", 
[10:33:07.856]                         quietly = TRUE)
[10:33:07.856]                       if (has_future) {
[10:33:07.856]                         ns <- base::getNamespace("future")
[10:33:07.856]                         version <- ns[[".package"]][["version"]]
[10:33:07.856]                         if (is.null(version)) 
[10:33:07.856]                           version <- utils::packageVersion("future")
[10:33:07.856]                       }
[10:33:07.856]                       else {
[10:33:07.856]                         version <- NULL
[10:33:07.856]                       }
[10:33:07.856]                       if (!has_future || version < "1.8.0") {
[10:33:07.856]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.856]                           "", base::R.version$version.string), 
[10:33:07.856]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.856]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.856]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.856]                             "release", "version")], collapse = " "), 
[10:33:07.856]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.856]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.856]                           info)
[10:33:07.856]                         info <- base::paste(info, collapse = "; ")
[10:33:07.856]                         if (!has_future) {
[10:33:07.856]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.856]                             info)
[10:33:07.856]                         }
[10:33:07.856]                         else {
[10:33:07.856]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.856]                             info, version)
[10:33:07.856]                         }
[10:33:07.856]                         base::stop(msg)
[10:33:07.856]                       }
[10:33:07.856]                     })
[10:33:07.856]                   }
[10:33:07.856]                   ...future.strategy.old <- future::plan("list")
[10:33:07.856]                   options(future.plan = NULL)
[10:33:07.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.856]                 }
[10:33:07.856]                 ...future.workdir <- getwd()
[10:33:07.856]             }
[10:33:07.856]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.856]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.856]         }
[10:33:07.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.856]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.856]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.856]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.856]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.856]             base::names(...future.oldOptions))
[10:33:07.856]     }
[10:33:07.856]     if (FALSE) {
[10:33:07.856]     }
[10:33:07.856]     else {
[10:33:07.856]         if (TRUE) {
[10:33:07.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.856]                 open = "w")
[10:33:07.856]         }
[10:33:07.856]         else {
[10:33:07.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.856]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.856]         }
[10:33:07.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.856]             base::sink(type = "output", split = FALSE)
[10:33:07.856]             base::close(...future.stdout)
[10:33:07.856]         }, add = TRUE)
[10:33:07.856]     }
[10:33:07.856]     ...future.frame <- base::sys.nframe()
[10:33:07.856]     ...future.conditions <- base::list()
[10:33:07.856]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.856]     if (FALSE) {
[10:33:07.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.856]     }
[10:33:07.856]     ...future.result <- base::tryCatch({
[10:33:07.856]         base::withCallingHandlers({
[10:33:07.856]             ...future.value <- base::withVisible(base::local({
[10:33:07.856]                 x[["a"]] <- 1
[10:33:07.856]                 x
[10:33:07.856]             }))
[10:33:07.856]             future::FutureResult(value = ...future.value$value, 
[10:33:07.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.856]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.856]                     ...future.globalenv.names))
[10:33:07.856]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.856]         }, condition = base::local({
[10:33:07.856]             c <- base::c
[10:33:07.856]             inherits <- base::inherits
[10:33:07.856]             invokeRestart <- base::invokeRestart
[10:33:07.856]             length <- base::length
[10:33:07.856]             list <- base::list
[10:33:07.856]             seq.int <- base::seq.int
[10:33:07.856]             signalCondition <- base::signalCondition
[10:33:07.856]             sys.calls <- base::sys.calls
[10:33:07.856]             `[[` <- base::`[[`
[10:33:07.856]             `+` <- base::`+`
[10:33:07.856]             `<<-` <- base::`<<-`
[10:33:07.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.856]                   3L)]
[10:33:07.856]             }
[10:33:07.856]             function(cond) {
[10:33:07.856]                 is_error <- inherits(cond, "error")
[10:33:07.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.856]                   NULL)
[10:33:07.856]                 if (is_error) {
[10:33:07.856]                   sessionInformation <- function() {
[10:33:07.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.856]                       search = base::search(), system = base::Sys.info())
[10:33:07.856]                   }
[10:33:07.856]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.856]                     cond$call), session = sessionInformation(), 
[10:33:07.856]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.856]                   signalCondition(cond)
[10:33:07.856]                 }
[10:33:07.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.856]                 "immediateCondition"))) {
[10:33:07.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.856]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.856]                   if (TRUE && !signal) {
[10:33:07.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.856]                     {
[10:33:07.856]                       inherits <- base::inherits
[10:33:07.856]                       invokeRestart <- base::invokeRestart
[10:33:07.856]                       is.null <- base::is.null
[10:33:07.856]                       muffled <- FALSE
[10:33:07.856]                       if (inherits(cond, "message")) {
[10:33:07.856]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.856]                         if (muffled) 
[10:33:07.856]                           invokeRestart("muffleMessage")
[10:33:07.856]                       }
[10:33:07.856]                       else if (inherits(cond, "warning")) {
[10:33:07.856]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.856]                         if (muffled) 
[10:33:07.856]                           invokeRestart("muffleWarning")
[10:33:07.856]                       }
[10:33:07.856]                       else if (inherits(cond, "condition")) {
[10:33:07.856]                         if (!is.null(pattern)) {
[10:33:07.856]                           computeRestarts <- base::computeRestarts
[10:33:07.856]                           grepl <- base::grepl
[10:33:07.856]                           restarts <- computeRestarts(cond)
[10:33:07.856]                           for (restart in restarts) {
[10:33:07.856]                             name <- restart$name
[10:33:07.856]                             if (is.null(name)) 
[10:33:07.856]                               next
[10:33:07.856]                             if (!grepl(pattern, name)) 
[10:33:07.856]                               next
[10:33:07.856]                             invokeRestart(restart)
[10:33:07.856]                             muffled <- TRUE
[10:33:07.856]                             break
[10:33:07.856]                           }
[10:33:07.856]                         }
[10:33:07.856]                       }
[10:33:07.856]                       invisible(muffled)
[10:33:07.856]                     }
[10:33:07.856]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.856]                   }
[10:33:07.856]                 }
[10:33:07.856]                 else {
[10:33:07.856]                   if (TRUE) {
[10:33:07.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.856]                     {
[10:33:07.856]                       inherits <- base::inherits
[10:33:07.856]                       invokeRestart <- base::invokeRestart
[10:33:07.856]                       is.null <- base::is.null
[10:33:07.856]                       muffled <- FALSE
[10:33:07.856]                       if (inherits(cond, "message")) {
[10:33:07.856]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.856]                         if (muffled) 
[10:33:07.856]                           invokeRestart("muffleMessage")
[10:33:07.856]                       }
[10:33:07.856]                       else if (inherits(cond, "warning")) {
[10:33:07.856]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.856]                         if (muffled) 
[10:33:07.856]                           invokeRestart("muffleWarning")
[10:33:07.856]                       }
[10:33:07.856]                       else if (inherits(cond, "condition")) {
[10:33:07.856]                         if (!is.null(pattern)) {
[10:33:07.856]                           computeRestarts <- base::computeRestarts
[10:33:07.856]                           grepl <- base::grepl
[10:33:07.856]                           restarts <- computeRestarts(cond)
[10:33:07.856]                           for (restart in restarts) {
[10:33:07.856]                             name <- restart$name
[10:33:07.856]                             if (is.null(name)) 
[10:33:07.856]                               next
[10:33:07.856]                             if (!grepl(pattern, name)) 
[10:33:07.856]                               next
[10:33:07.856]                             invokeRestart(restart)
[10:33:07.856]                             muffled <- TRUE
[10:33:07.856]                             break
[10:33:07.856]                           }
[10:33:07.856]                         }
[10:33:07.856]                       }
[10:33:07.856]                       invisible(muffled)
[10:33:07.856]                     }
[10:33:07.856]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.856]                   }
[10:33:07.856]                 }
[10:33:07.856]             }
[10:33:07.856]         }))
[10:33:07.856]     }, error = function(ex) {
[10:33:07.856]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.856]                 ...future.rng), started = ...future.startTime, 
[10:33:07.856]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.856]             version = "1.8"), class = "FutureResult")
[10:33:07.856]     }, finally = {
[10:33:07.856]         if (!identical(...future.workdir, getwd())) 
[10:33:07.856]             setwd(...future.workdir)
[10:33:07.856]         {
[10:33:07.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.856]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.856]             }
[10:33:07.856]             base::options(...future.oldOptions)
[10:33:07.856]             if (.Platform$OS.type == "windows") {
[10:33:07.856]                 old_names <- names(...future.oldEnvVars)
[10:33:07.856]                 envs <- base::Sys.getenv()
[10:33:07.856]                 names <- names(envs)
[10:33:07.856]                 common <- intersect(names, old_names)
[10:33:07.856]                 added <- setdiff(names, old_names)
[10:33:07.856]                 removed <- setdiff(old_names, names)
[10:33:07.856]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.856]                   envs[common]]
[10:33:07.856]                 NAMES <- toupper(changed)
[10:33:07.856]                 args <- list()
[10:33:07.856]                 for (kk in seq_along(NAMES)) {
[10:33:07.856]                   name <- changed[[kk]]
[10:33:07.856]                   NAME <- NAMES[[kk]]
[10:33:07.856]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.856]                     next
[10:33:07.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.856]                 }
[10:33:07.856]                 NAMES <- toupper(added)
[10:33:07.856]                 for (kk in seq_along(NAMES)) {
[10:33:07.856]                   name <- added[[kk]]
[10:33:07.856]                   NAME <- NAMES[[kk]]
[10:33:07.856]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.856]                     next
[10:33:07.856]                   args[[name]] <- ""
[10:33:07.856]                 }
[10:33:07.856]                 NAMES <- toupper(removed)
[10:33:07.856]                 for (kk in seq_along(NAMES)) {
[10:33:07.856]                   name <- removed[[kk]]
[10:33:07.856]                   NAME <- NAMES[[kk]]
[10:33:07.856]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.856]                     next
[10:33:07.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.856]                 }
[10:33:07.856]                 if (length(args) > 0) 
[10:33:07.856]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.856]             }
[10:33:07.856]             else {
[10:33:07.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.856]             }
[10:33:07.856]             {
[10:33:07.856]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.856]                   0L) {
[10:33:07.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.856]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.856]                   base::options(opts)
[10:33:07.856]                 }
[10:33:07.856]                 {
[10:33:07.856]                   {
[10:33:07.856]                     NULL
[10:33:07.856]                     RNGkind("Mersenne-Twister")
[10:33:07.856]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.856]                       inherits = FALSE)
[10:33:07.856]                   }
[10:33:07.856]                   options(future.plan = NULL)
[10:33:07.856]                   if (is.na(NA_character_)) 
[10:33:07.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.856]                     .init = FALSE)
[10:33:07.856]                 }
[10:33:07.856]             }
[10:33:07.856]         }
[10:33:07.856]     })
[10:33:07.856]     if (TRUE) {
[10:33:07.856]         base::sink(type = "output", split = FALSE)
[10:33:07.856]         if (TRUE) {
[10:33:07.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.856]         }
[10:33:07.856]         else {
[10:33:07.856]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.856]         }
[10:33:07.856]         base::close(...future.stdout)
[10:33:07.856]         ...future.stdout <- NULL
[10:33:07.856]     }
[10:33:07.856]     ...future.result$conditions <- ...future.conditions
[10:33:07.856]     ...future.result$finished <- base::Sys.time()
[10:33:07.856]     ...future.result
[10:33:07.856] }
[10:33:07.858] assign_globals() ...
[10:33:07.858] List of 1
[10:33:07.858]  $ x: list()
[10:33:07.858]  - attr(*, "where")=List of 1
[10:33:07.858]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.858]  - attr(*, "resolved")= logi TRUE
[10:33:07.858]  - attr(*, "total_size")= num 0
[10:33:07.858]  - attr(*, "already-done")= logi TRUE
[10:33:07.862] - copied ‘x’ to environment
[10:33:07.862] assign_globals() ... done
[10:33:07.863] plan(): Setting new future strategy stack:
[10:33:07.863] List of future strategies:
[10:33:07.863] 1. sequential:
[10:33:07.863]    - args: function (..., envir = parent.frame())
[10:33:07.863]    - tweaked: FALSE
[10:33:07.863]    - call: NULL
[10:33:07.863] plan(): nbrOfWorkers() = 1
[10:33:07.864] plan(): Setting new future strategy stack:
[10:33:07.864] List of future strategies:
[10:33:07.864] 1. sequential:
[10:33:07.864]    - args: function (..., envir = parent.frame())
[10:33:07.864]    - tweaked: FALSE
[10:33:07.864]    - call: plan(strategy)
[10:33:07.864] plan(): nbrOfWorkers() = 1
[10:33:07.864] SequentialFuture started (and completed)
[10:33:07.864] - Launch lazy future ... done
[10:33:07.865] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.865] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.865] Searching for globals...
[10:33:07.867] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:07.867] Searching for globals ... DONE
[10:33:07.867] Resolving globals: TRUE
[10:33:07.867] Resolving any globals that are futures ...
[10:33:07.868] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:07.868] Resolving any globals that are futures ... DONE
[10:33:07.868] Resolving futures part of globals (recursively) ...
[10:33:07.868] resolve() on list ...
[10:33:07.868]  recursive: 99
[10:33:07.868]  length: 1
[10:33:07.869]  elements: ‘x’
[10:33:07.869]  length: 0 (resolved future 1)
[10:33:07.869] resolve() on list ... DONE
[10:33:07.869] - globals: [1] ‘x’
[10:33:07.869] Resolving futures part of globals (recursively) ... DONE
[10:33:07.869] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.869] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.870] - globals: [1] ‘x’
[10:33:07.870] 
[10:33:07.870] getGlobalsAndPackages() ... DONE
[10:33:07.870] run() for ‘Future’ ...
[10:33:07.870] - state: ‘created’
[10:33:07.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.870] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.871]   - Field: ‘label’
[10:33:07.871]   - Field: ‘local’
[10:33:07.871]   - Field: ‘owner’
[10:33:07.871]   - Field: ‘envir’
[10:33:07.871]   - Field: ‘packages’
[10:33:07.871]   - Field: ‘gc’
[10:33:07.871]   - Field: ‘conditions’
[10:33:07.871]   - Field: ‘expr’
[10:33:07.871]   - Field: ‘uuid’
[10:33:07.871]   - Field: ‘seed’
[10:33:07.872]   - Field: ‘version’
[10:33:07.872]   - Field: ‘result’
[10:33:07.872]   - Field: ‘asynchronous’
[10:33:07.872]   - Field: ‘calls’
[10:33:07.872]   - Field: ‘globals’
[10:33:07.872]   - Field: ‘stdout’
[10:33:07.872]   - Field: ‘earlySignal’
[10:33:07.872]   - Field: ‘lazy’
[10:33:07.872]   - Field: ‘state’
[10:33:07.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.872] - Launch lazy future ...
[10:33:07.873] Packages needed by the future expression (n = 0): <none>
[10:33:07.873] Packages needed by future strategies (n = 0): <none>
[10:33:07.873] {
[10:33:07.873]     {
[10:33:07.873]         {
[10:33:07.873]             ...future.startTime <- base::Sys.time()
[10:33:07.873]             {
[10:33:07.873]                 {
[10:33:07.873]                   {
[10:33:07.873]                     base::local({
[10:33:07.873]                       has_future <- base::requireNamespace("future", 
[10:33:07.873]                         quietly = TRUE)
[10:33:07.873]                       if (has_future) {
[10:33:07.873]                         ns <- base::getNamespace("future")
[10:33:07.873]                         version <- ns[[".package"]][["version"]]
[10:33:07.873]                         if (is.null(version)) 
[10:33:07.873]                           version <- utils::packageVersion("future")
[10:33:07.873]                       }
[10:33:07.873]                       else {
[10:33:07.873]                         version <- NULL
[10:33:07.873]                       }
[10:33:07.873]                       if (!has_future || version < "1.8.0") {
[10:33:07.873]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.873]                           "", base::R.version$version.string), 
[10:33:07.873]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.873]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.873]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.873]                             "release", "version")], collapse = " "), 
[10:33:07.873]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.873]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.873]                           info)
[10:33:07.873]                         info <- base::paste(info, collapse = "; ")
[10:33:07.873]                         if (!has_future) {
[10:33:07.873]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.873]                             info)
[10:33:07.873]                         }
[10:33:07.873]                         else {
[10:33:07.873]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.873]                             info, version)
[10:33:07.873]                         }
[10:33:07.873]                         base::stop(msg)
[10:33:07.873]                       }
[10:33:07.873]                     })
[10:33:07.873]                   }
[10:33:07.873]                   ...future.strategy.old <- future::plan("list")
[10:33:07.873]                   options(future.plan = NULL)
[10:33:07.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.873]                 }
[10:33:07.873]                 ...future.workdir <- getwd()
[10:33:07.873]             }
[10:33:07.873]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.873]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.873]         }
[10:33:07.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.873]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.873]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.873]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.873]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.873]             base::names(...future.oldOptions))
[10:33:07.873]     }
[10:33:07.873]     if (FALSE) {
[10:33:07.873]     }
[10:33:07.873]     else {
[10:33:07.873]         if (TRUE) {
[10:33:07.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.873]                 open = "w")
[10:33:07.873]         }
[10:33:07.873]         else {
[10:33:07.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.873]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.873]         }
[10:33:07.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.873]             base::sink(type = "output", split = FALSE)
[10:33:07.873]             base::close(...future.stdout)
[10:33:07.873]         }, add = TRUE)
[10:33:07.873]     }
[10:33:07.873]     ...future.frame <- base::sys.nframe()
[10:33:07.873]     ...future.conditions <- base::list()
[10:33:07.873]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.873]     if (FALSE) {
[10:33:07.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.873]     }
[10:33:07.873]     ...future.result <- base::tryCatch({
[10:33:07.873]         base::withCallingHandlers({
[10:33:07.873]             ...future.value <- base::withVisible(base::local({
[10:33:07.873]                 x["a"] <- list(1)
[10:33:07.873]                 x
[10:33:07.873]             }))
[10:33:07.873]             future::FutureResult(value = ...future.value$value, 
[10:33:07.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.873]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.873]                     ...future.globalenv.names))
[10:33:07.873]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.873]         }, condition = base::local({
[10:33:07.873]             c <- base::c
[10:33:07.873]             inherits <- base::inherits
[10:33:07.873]             invokeRestart <- base::invokeRestart
[10:33:07.873]             length <- base::length
[10:33:07.873]             list <- base::list
[10:33:07.873]             seq.int <- base::seq.int
[10:33:07.873]             signalCondition <- base::signalCondition
[10:33:07.873]             sys.calls <- base::sys.calls
[10:33:07.873]             `[[` <- base::`[[`
[10:33:07.873]             `+` <- base::`+`
[10:33:07.873]             `<<-` <- base::`<<-`
[10:33:07.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.873]                   3L)]
[10:33:07.873]             }
[10:33:07.873]             function(cond) {
[10:33:07.873]                 is_error <- inherits(cond, "error")
[10:33:07.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.873]                   NULL)
[10:33:07.873]                 if (is_error) {
[10:33:07.873]                   sessionInformation <- function() {
[10:33:07.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.873]                       search = base::search(), system = base::Sys.info())
[10:33:07.873]                   }
[10:33:07.873]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.873]                     cond$call), session = sessionInformation(), 
[10:33:07.873]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.873]                   signalCondition(cond)
[10:33:07.873]                 }
[10:33:07.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.873]                 "immediateCondition"))) {
[10:33:07.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.873]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.873]                   if (TRUE && !signal) {
[10:33:07.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.873]                     {
[10:33:07.873]                       inherits <- base::inherits
[10:33:07.873]                       invokeRestart <- base::invokeRestart
[10:33:07.873]                       is.null <- base::is.null
[10:33:07.873]                       muffled <- FALSE
[10:33:07.873]                       if (inherits(cond, "message")) {
[10:33:07.873]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.873]                         if (muffled) 
[10:33:07.873]                           invokeRestart("muffleMessage")
[10:33:07.873]                       }
[10:33:07.873]                       else if (inherits(cond, "warning")) {
[10:33:07.873]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.873]                         if (muffled) 
[10:33:07.873]                           invokeRestart("muffleWarning")
[10:33:07.873]                       }
[10:33:07.873]                       else if (inherits(cond, "condition")) {
[10:33:07.873]                         if (!is.null(pattern)) {
[10:33:07.873]                           computeRestarts <- base::computeRestarts
[10:33:07.873]                           grepl <- base::grepl
[10:33:07.873]                           restarts <- computeRestarts(cond)
[10:33:07.873]                           for (restart in restarts) {
[10:33:07.873]                             name <- restart$name
[10:33:07.873]                             if (is.null(name)) 
[10:33:07.873]                               next
[10:33:07.873]                             if (!grepl(pattern, name)) 
[10:33:07.873]                               next
[10:33:07.873]                             invokeRestart(restart)
[10:33:07.873]                             muffled <- TRUE
[10:33:07.873]                             break
[10:33:07.873]                           }
[10:33:07.873]                         }
[10:33:07.873]                       }
[10:33:07.873]                       invisible(muffled)
[10:33:07.873]                     }
[10:33:07.873]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.873]                   }
[10:33:07.873]                 }
[10:33:07.873]                 else {
[10:33:07.873]                   if (TRUE) {
[10:33:07.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.873]                     {
[10:33:07.873]                       inherits <- base::inherits
[10:33:07.873]                       invokeRestart <- base::invokeRestart
[10:33:07.873]                       is.null <- base::is.null
[10:33:07.873]                       muffled <- FALSE
[10:33:07.873]                       if (inherits(cond, "message")) {
[10:33:07.873]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.873]                         if (muffled) 
[10:33:07.873]                           invokeRestart("muffleMessage")
[10:33:07.873]                       }
[10:33:07.873]                       else if (inherits(cond, "warning")) {
[10:33:07.873]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.873]                         if (muffled) 
[10:33:07.873]                           invokeRestart("muffleWarning")
[10:33:07.873]                       }
[10:33:07.873]                       else if (inherits(cond, "condition")) {
[10:33:07.873]                         if (!is.null(pattern)) {
[10:33:07.873]                           computeRestarts <- base::computeRestarts
[10:33:07.873]                           grepl <- base::grepl
[10:33:07.873]                           restarts <- computeRestarts(cond)
[10:33:07.873]                           for (restart in restarts) {
[10:33:07.873]                             name <- restart$name
[10:33:07.873]                             if (is.null(name)) 
[10:33:07.873]                               next
[10:33:07.873]                             if (!grepl(pattern, name)) 
[10:33:07.873]                               next
[10:33:07.873]                             invokeRestart(restart)
[10:33:07.873]                             muffled <- TRUE
[10:33:07.873]                             break
[10:33:07.873]                           }
[10:33:07.873]                         }
[10:33:07.873]                       }
[10:33:07.873]                       invisible(muffled)
[10:33:07.873]                     }
[10:33:07.873]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.873]                   }
[10:33:07.873]                 }
[10:33:07.873]             }
[10:33:07.873]         }))
[10:33:07.873]     }, error = function(ex) {
[10:33:07.873]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.873]                 ...future.rng), started = ...future.startTime, 
[10:33:07.873]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.873]             version = "1.8"), class = "FutureResult")
[10:33:07.873]     }, finally = {
[10:33:07.873]         if (!identical(...future.workdir, getwd())) 
[10:33:07.873]             setwd(...future.workdir)
[10:33:07.873]         {
[10:33:07.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.873]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.873]             }
[10:33:07.873]             base::options(...future.oldOptions)
[10:33:07.873]             if (.Platform$OS.type == "windows") {
[10:33:07.873]                 old_names <- names(...future.oldEnvVars)
[10:33:07.873]                 envs <- base::Sys.getenv()
[10:33:07.873]                 names <- names(envs)
[10:33:07.873]                 common <- intersect(names, old_names)
[10:33:07.873]                 added <- setdiff(names, old_names)
[10:33:07.873]                 removed <- setdiff(old_names, names)
[10:33:07.873]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.873]                   envs[common]]
[10:33:07.873]                 NAMES <- toupper(changed)
[10:33:07.873]                 args <- list()
[10:33:07.873]                 for (kk in seq_along(NAMES)) {
[10:33:07.873]                   name <- changed[[kk]]
[10:33:07.873]                   NAME <- NAMES[[kk]]
[10:33:07.873]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.873]                     next
[10:33:07.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.873]                 }
[10:33:07.873]                 NAMES <- toupper(added)
[10:33:07.873]                 for (kk in seq_along(NAMES)) {
[10:33:07.873]                   name <- added[[kk]]
[10:33:07.873]                   NAME <- NAMES[[kk]]
[10:33:07.873]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.873]                     next
[10:33:07.873]                   args[[name]] <- ""
[10:33:07.873]                 }
[10:33:07.873]                 NAMES <- toupper(removed)
[10:33:07.873]                 for (kk in seq_along(NAMES)) {
[10:33:07.873]                   name <- removed[[kk]]
[10:33:07.873]                   NAME <- NAMES[[kk]]
[10:33:07.873]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.873]                     next
[10:33:07.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.873]                 }
[10:33:07.873]                 if (length(args) > 0) 
[10:33:07.873]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.873]             }
[10:33:07.873]             else {
[10:33:07.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.873]             }
[10:33:07.873]             {
[10:33:07.873]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.873]                   0L) {
[10:33:07.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.873]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.873]                   base::options(opts)
[10:33:07.873]                 }
[10:33:07.873]                 {
[10:33:07.873]                   {
[10:33:07.873]                     NULL
[10:33:07.873]                     RNGkind("Mersenne-Twister")
[10:33:07.873]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.873]                       inherits = FALSE)
[10:33:07.873]                   }
[10:33:07.873]                   options(future.plan = NULL)
[10:33:07.873]                   if (is.na(NA_character_)) 
[10:33:07.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.873]                     .init = FALSE)
[10:33:07.873]                 }
[10:33:07.873]             }
[10:33:07.873]         }
[10:33:07.873]     })
[10:33:07.873]     if (TRUE) {
[10:33:07.873]         base::sink(type = "output", split = FALSE)
[10:33:07.873]         if (TRUE) {
[10:33:07.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.873]         }
[10:33:07.873]         else {
[10:33:07.873]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.873]         }
[10:33:07.873]         base::close(...future.stdout)
[10:33:07.873]         ...future.stdout <- NULL
[10:33:07.873]     }
[10:33:07.873]     ...future.result$conditions <- ...future.conditions
[10:33:07.873]     ...future.result$finished <- base::Sys.time()
[10:33:07.873]     ...future.result
[10:33:07.873] }
[10:33:07.875] assign_globals() ...
[10:33:07.875] List of 1
[10:33:07.875]  $ x: list()
[10:33:07.875]  - attr(*, "where")=List of 1
[10:33:07.875]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.875]  - attr(*, "resolved")= logi TRUE
[10:33:07.875]  - attr(*, "total_size")= num 0
[10:33:07.875]  - attr(*, "already-done")= logi TRUE
[10:33:07.877] - copied ‘x’ to environment
[10:33:07.877] assign_globals() ... done
[10:33:07.877] plan(): Setting new future strategy stack:
[10:33:07.877] List of future strategies:
[10:33:07.877] 1. sequential:
[10:33:07.877]    - args: function (..., envir = parent.frame())
[10:33:07.877]    - tweaked: FALSE
[10:33:07.877]    - call: NULL
[10:33:07.878] plan(): nbrOfWorkers() = 1
[10:33:07.878] plan(): Setting new future strategy stack:
[10:33:07.879] List of future strategies:
[10:33:07.879] 1. sequential:
[10:33:07.879]    - args: function (..., envir = parent.frame())
[10:33:07.879]    - tweaked: FALSE
[10:33:07.879]    - call: plan(strategy)
[10:33:07.879] plan(): nbrOfWorkers() = 1
[10:33:07.879] SequentialFuture started (and completed)
[10:33:07.879] - Launch lazy future ... done
[10:33:07.879] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.880] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.880] Searching for globals...
[10:33:07.882] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:07.882] Searching for globals ... DONE
[10:33:07.882] Resolving globals: TRUE
[10:33:07.882] Resolving any globals that are futures ...
[10:33:07.882] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:07.882] Resolving any globals that are futures ... DONE
[10:33:07.883] Resolving futures part of globals (recursively) ...
[10:33:07.883] resolve() on list ...
[10:33:07.883]  recursive: 99
[10:33:07.883]  length: 1
[10:33:07.883]  elements: ‘x’
[10:33:07.883]  length: 0 (resolved future 1)
[10:33:07.883] resolve() on list ... DONE
[10:33:07.883] - globals: [1] ‘x’
[10:33:07.883] Resolving futures part of globals (recursively) ... DONE
[10:33:07.884] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.884] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.884] - globals: [1] ‘x’
[10:33:07.884] 
[10:33:07.884] getGlobalsAndPackages() ... DONE
[10:33:07.884] run() for ‘Future’ ...
[10:33:07.885] - state: ‘created’
[10:33:07.885] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.885] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.885]   - Field: ‘label’
[10:33:07.885]   - Field: ‘local’
[10:33:07.885]   - Field: ‘owner’
[10:33:07.885]   - Field: ‘envir’
[10:33:07.886]   - Field: ‘packages’
[10:33:07.887]   - Field: ‘gc’
[10:33:07.887]   - Field: ‘conditions’
[10:33:07.887]   - Field: ‘expr’
[10:33:07.887]   - Field: ‘uuid’
[10:33:07.887]   - Field: ‘seed’
[10:33:07.888]   - Field: ‘version’
[10:33:07.888]   - Field: ‘result’
[10:33:07.888]   - Field: ‘asynchronous’
[10:33:07.888]   - Field: ‘calls’
[10:33:07.888]   - Field: ‘globals’
[10:33:07.888]   - Field: ‘stdout’
[10:33:07.888]   - Field: ‘earlySignal’
[10:33:07.888]   - Field: ‘lazy’
[10:33:07.888]   - Field: ‘state’
[10:33:07.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.888] - Launch lazy future ...
[10:33:07.889] Packages needed by the future expression (n = 0): <none>
[10:33:07.889] Packages needed by future strategies (n = 0): <none>
[10:33:07.889] {
[10:33:07.889]     {
[10:33:07.889]         {
[10:33:07.889]             ...future.startTime <- base::Sys.time()
[10:33:07.889]             {
[10:33:07.889]                 {
[10:33:07.889]                   {
[10:33:07.889]                     base::local({
[10:33:07.889]                       has_future <- base::requireNamespace("future", 
[10:33:07.889]                         quietly = TRUE)
[10:33:07.889]                       if (has_future) {
[10:33:07.889]                         ns <- base::getNamespace("future")
[10:33:07.889]                         version <- ns[[".package"]][["version"]]
[10:33:07.889]                         if (is.null(version)) 
[10:33:07.889]                           version <- utils::packageVersion("future")
[10:33:07.889]                       }
[10:33:07.889]                       else {
[10:33:07.889]                         version <- NULL
[10:33:07.889]                       }
[10:33:07.889]                       if (!has_future || version < "1.8.0") {
[10:33:07.889]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.889]                           "", base::R.version$version.string), 
[10:33:07.889]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.889]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.889]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.889]                             "release", "version")], collapse = " "), 
[10:33:07.889]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.889]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.889]                           info)
[10:33:07.889]                         info <- base::paste(info, collapse = "; ")
[10:33:07.889]                         if (!has_future) {
[10:33:07.889]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.889]                             info)
[10:33:07.889]                         }
[10:33:07.889]                         else {
[10:33:07.889]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.889]                             info, version)
[10:33:07.889]                         }
[10:33:07.889]                         base::stop(msg)
[10:33:07.889]                       }
[10:33:07.889]                     })
[10:33:07.889]                   }
[10:33:07.889]                   ...future.strategy.old <- future::plan("list")
[10:33:07.889]                   options(future.plan = NULL)
[10:33:07.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.889]                 }
[10:33:07.889]                 ...future.workdir <- getwd()
[10:33:07.889]             }
[10:33:07.889]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.889]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.889]         }
[10:33:07.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.889]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.889]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.889]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.889]             base::names(...future.oldOptions))
[10:33:07.889]     }
[10:33:07.889]     if (FALSE) {
[10:33:07.889]     }
[10:33:07.889]     else {
[10:33:07.889]         if (TRUE) {
[10:33:07.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.889]                 open = "w")
[10:33:07.889]         }
[10:33:07.889]         else {
[10:33:07.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.889]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.889]         }
[10:33:07.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.889]             base::sink(type = "output", split = FALSE)
[10:33:07.889]             base::close(...future.stdout)
[10:33:07.889]         }, add = TRUE)
[10:33:07.889]     }
[10:33:07.889]     ...future.frame <- base::sys.nframe()
[10:33:07.889]     ...future.conditions <- base::list()
[10:33:07.889]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.889]     if (FALSE) {
[10:33:07.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.889]     }
[10:33:07.889]     ...future.result <- base::tryCatch({
[10:33:07.889]         base::withCallingHandlers({
[10:33:07.889]             ...future.value <- base::withVisible(base::local({
[10:33:07.889]                 x["a"] <- list(1)
[10:33:07.889]                 x
[10:33:07.889]             }))
[10:33:07.889]             future::FutureResult(value = ...future.value$value, 
[10:33:07.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.889]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.889]                     ...future.globalenv.names))
[10:33:07.889]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.889]         }, condition = base::local({
[10:33:07.889]             c <- base::c
[10:33:07.889]             inherits <- base::inherits
[10:33:07.889]             invokeRestart <- base::invokeRestart
[10:33:07.889]             length <- base::length
[10:33:07.889]             list <- base::list
[10:33:07.889]             seq.int <- base::seq.int
[10:33:07.889]             signalCondition <- base::signalCondition
[10:33:07.889]             sys.calls <- base::sys.calls
[10:33:07.889]             `[[` <- base::`[[`
[10:33:07.889]             `+` <- base::`+`
[10:33:07.889]             `<<-` <- base::`<<-`
[10:33:07.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.889]                   3L)]
[10:33:07.889]             }
[10:33:07.889]             function(cond) {
[10:33:07.889]                 is_error <- inherits(cond, "error")
[10:33:07.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.889]                   NULL)
[10:33:07.889]                 if (is_error) {
[10:33:07.889]                   sessionInformation <- function() {
[10:33:07.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.889]                       search = base::search(), system = base::Sys.info())
[10:33:07.889]                   }
[10:33:07.889]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.889]                     cond$call), session = sessionInformation(), 
[10:33:07.889]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.889]                   signalCondition(cond)
[10:33:07.889]                 }
[10:33:07.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.889]                 "immediateCondition"))) {
[10:33:07.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.889]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.889]                   if (TRUE && !signal) {
[10:33:07.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.889]                     {
[10:33:07.889]                       inherits <- base::inherits
[10:33:07.889]                       invokeRestart <- base::invokeRestart
[10:33:07.889]                       is.null <- base::is.null
[10:33:07.889]                       muffled <- FALSE
[10:33:07.889]                       if (inherits(cond, "message")) {
[10:33:07.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.889]                         if (muffled) 
[10:33:07.889]                           invokeRestart("muffleMessage")
[10:33:07.889]                       }
[10:33:07.889]                       else if (inherits(cond, "warning")) {
[10:33:07.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.889]                         if (muffled) 
[10:33:07.889]                           invokeRestart("muffleWarning")
[10:33:07.889]                       }
[10:33:07.889]                       else if (inherits(cond, "condition")) {
[10:33:07.889]                         if (!is.null(pattern)) {
[10:33:07.889]                           computeRestarts <- base::computeRestarts
[10:33:07.889]                           grepl <- base::grepl
[10:33:07.889]                           restarts <- computeRestarts(cond)
[10:33:07.889]                           for (restart in restarts) {
[10:33:07.889]                             name <- restart$name
[10:33:07.889]                             if (is.null(name)) 
[10:33:07.889]                               next
[10:33:07.889]                             if (!grepl(pattern, name)) 
[10:33:07.889]                               next
[10:33:07.889]                             invokeRestart(restart)
[10:33:07.889]                             muffled <- TRUE
[10:33:07.889]                             break
[10:33:07.889]                           }
[10:33:07.889]                         }
[10:33:07.889]                       }
[10:33:07.889]                       invisible(muffled)
[10:33:07.889]                     }
[10:33:07.889]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.889]                   }
[10:33:07.889]                 }
[10:33:07.889]                 else {
[10:33:07.889]                   if (TRUE) {
[10:33:07.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.889]                     {
[10:33:07.889]                       inherits <- base::inherits
[10:33:07.889]                       invokeRestart <- base::invokeRestart
[10:33:07.889]                       is.null <- base::is.null
[10:33:07.889]                       muffled <- FALSE
[10:33:07.889]                       if (inherits(cond, "message")) {
[10:33:07.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.889]                         if (muffled) 
[10:33:07.889]                           invokeRestart("muffleMessage")
[10:33:07.889]                       }
[10:33:07.889]                       else if (inherits(cond, "warning")) {
[10:33:07.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.889]                         if (muffled) 
[10:33:07.889]                           invokeRestart("muffleWarning")
[10:33:07.889]                       }
[10:33:07.889]                       else if (inherits(cond, "condition")) {
[10:33:07.889]                         if (!is.null(pattern)) {
[10:33:07.889]                           computeRestarts <- base::computeRestarts
[10:33:07.889]                           grepl <- base::grepl
[10:33:07.889]                           restarts <- computeRestarts(cond)
[10:33:07.889]                           for (restart in restarts) {
[10:33:07.889]                             name <- restart$name
[10:33:07.889]                             if (is.null(name)) 
[10:33:07.889]                               next
[10:33:07.889]                             if (!grepl(pattern, name)) 
[10:33:07.889]                               next
[10:33:07.889]                             invokeRestart(restart)
[10:33:07.889]                             muffled <- TRUE
[10:33:07.889]                             break
[10:33:07.889]                           }
[10:33:07.889]                         }
[10:33:07.889]                       }
[10:33:07.889]                       invisible(muffled)
[10:33:07.889]                     }
[10:33:07.889]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.889]                   }
[10:33:07.889]                 }
[10:33:07.889]             }
[10:33:07.889]         }))
[10:33:07.889]     }, error = function(ex) {
[10:33:07.889]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.889]                 ...future.rng), started = ...future.startTime, 
[10:33:07.889]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.889]             version = "1.8"), class = "FutureResult")
[10:33:07.889]     }, finally = {
[10:33:07.889]         if (!identical(...future.workdir, getwd())) 
[10:33:07.889]             setwd(...future.workdir)
[10:33:07.889]         {
[10:33:07.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.889]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.889]             }
[10:33:07.889]             base::options(...future.oldOptions)
[10:33:07.889]             if (.Platform$OS.type == "windows") {
[10:33:07.889]                 old_names <- names(...future.oldEnvVars)
[10:33:07.889]                 envs <- base::Sys.getenv()
[10:33:07.889]                 names <- names(envs)
[10:33:07.889]                 common <- intersect(names, old_names)
[10:33:07.889]                 added <- setdiff(names, old_names)
[10:33:07.889]                 removed <- setdiff(old_names, names)
[10:33:07.889]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.889]                   envs[common]]
[10:33:07.889]                 NAMES <- toupper(changed)
[10:33:07.889]                 args <- list()
[10:33:07.889]                 for (kk in seq_along(NAMES)) {
[10:33:07.889]                   name <- changed[[kk]]
[10:33:07.889]                   NAME <- NAMES[[kk]]
[10:33:07.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.889]                     next
[10:33:07.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.889]                 }
[10:33:07.889]                 NAMES <- toupper(added)
[10:33:07.889]                 for (kk in seq_along(NAMES)) {
[10:33:07.889]                   name <- added[[kk]]
[10:33:07.889]                   NAME <- NAMES[[kk]]
[10:33:07.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.889]                     next
[10:33:07.889]                   args[[name]] <- ""
[10:33:07.889]                 }
[10:33:07.889]                 NAMES <- toupper(removed)
[10:33:07.889]                 for (kk in seq_along(NAMES)) {
[10:33:07.889]                   name <- removed[[kk]]
[10:33:07.889]                   NAME <- NAMES[[kk]]
[10:33:07.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.889]                     next
[10:33:07.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.889]                 }
[10:33:07.889]                 if (length(args) > 0) 
[10:33:07.889]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.889]             }
[10:33:07.889]             else {
[10:33:07.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.889]             }
[10:33:07.889]             {
[10:33:07.889]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.889]                   0L) {
[10:33:07.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.889]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.889]                   base::options(opts)
[10:33:07.889]                 }
[10:33:07.889]                 {
[10:33:07.889]                   {
[10:33:07.889]                     NULL
[10:33:07.889]                     RNGkind("Mersenne-Twister")
[10:33:07.889]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.889]                       inherits = FALSE)
[10:33:07.889]                   }
[10:33:07.889]                   options(future.plan = NULL)
[10:33:07.889]                   if (is.na(NA_character_)) 
[10:33:07.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.889]                     .init = FALSE)
[10:33:07.889]                 }
[10:33:07.889]             }
[10:33:07.889]         }
[10:33:07.889]     })
[10:33:07.889]     if (TRUE) {
[10:33:07.889]         base::sink(type = "output", split = FALSE)
[10:33:07.889]         if (TRUE) {
[10:33:07.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.889]         }
[10:33:07.889]         else {
[10:33:07.889]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.889]         }
[10:33:07.889]         base::close(...future.stdout)
[10:33:07.889]         ...future.stdout <- NULL
[10:33:07.889]     }
[10:33:07.889]     ...future.result$conditions <- ...future.conditions
[10:33:07.889]     ...future.result$finished <- base::Sys.time()
[10:33:07.889]     ...future.result
[10:33:07.889] }
[10:33:07.891] assign_globals() ...
[10:33:07.891] List of 1
[10:33:07.891]  $ x: list()
[10:33:07.891]  - attr(*, "where")=List of 1
[10:33:07.891]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.891]  - attr(*, "resolved")= logi TRUE
[10:33:07.891]  - attr(*, "total_size")= num 0
[10:33:07.891]  - attr(*, "already-done")= logi TRUE
[10:33:07.893] - copied ‘x’ to environment
[10:33:07.893] assign_globals() ... done
[10:33:07.893] plan(): Setting new future strategy stack:
[10:33:07.894] List of future strategies:
[10:33:07.894] 1. sequential:
[10:33:07.894]    - args: function (..., envir = parent.frame())
[10:33:07.894]    - tweaked: FALSE
[10:33:07.894]    - call: NULL
[10:33:07.894] plan(): nbrOfWorkers() = 1
[10:33:07.895] plan(): Setting new future strategy stack:
[10:33:07.895] List of future strategies:
[10:33:07.895] 1. sequential:
[10:33:07.895]    - args: function (..., envir = parent.frame())
[10:33:07.895]    - tweaked: FALSE
[10:33:07.895]    - call: plan(strategy)
[10:33:07.895] plan(): nbrOfWorkers() = 1
[10:33:07.895] SequentialFuture started (and completed)
[10:33:07.895] - Launch lazy future ... done
[10:33:07.895] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.896] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.896] Searching for globals...
[10:33:07.898] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:07.898] Searching for globals ... DONE
[10:33:07.898] Resolving globals: TRUE
[10:33:07.898] Resolving any globals that are futures ...
[10:33:07.898] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:07.898] Resolving any globals that are futures ... DONE
[10:33:07.899] Resolving futures part of globals (recursively) ...
[10:33:07.899] resolve() on list ...
[10:33:07.899]  recursive: 99
[10:33:07.899]  length: 1
[10:33:07.899]  elements: ‘x’
[10:33:07.899]  length: 0 (resolved future 1)
[10:33:07.899] resolve() on list ... DONE
[10:33:07.900] - globals: [1] ‘x’
[10:33:07.900] Resolving futures part of globals (recursively) ... DONE
[10:33:07.900] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.900] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.900] - globals: [1] ‘x’
[10:33:07.900] 
[10:33:07.900] getGlobalsAndPackages() ... DONE
[10:33:07.901] run() for ‘Future’ ...
[10:33:07.901] - state: ‘created’
[10:33:07.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.901]   - Field: ‘label’
[10:33:07.901]   - Field: ‘local’
[10:33:07.901]   - Field: ‘owner’
[10:33:07.902]   - Field: ‘envir’
[10:33:07.902]   - Field: ‘packages’
[10:33:07.902]   - Field: ‘gc’
[10:33:07.902]   - Field: ‘conditions’
[10:33:07.902]   - Field: ‘expr’
[10:33:07.902]   - Field: ‘uuid’
[10:33:07.902]   - Field: ‘seed’
[10:33:07.902]   - Field: ‘version’
[10:33:07.902]   - Field: ‘result’
[10:33:07.902]   - Field: ‘asynchronous’
[10:33:07.903]   - Field: ‘calls’
[10:33:07.903]   - Field: ‘globals’
[10:33:07.903]   - Field: ‘stdout’
[10:33:07.903]   - Field: ‘earlySignal’
[10:33:07.903]   - Field: ‘lazy’
[10:33:07.903]   - Field: ‘state’
[10:33:07.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.903] - Launch lazy future ...
[10:33:07.903] Packages needed by the future expression (n = 0): <none>
[10:33:07.903] Packages needed by future strategies (n = 0): <none>
[10:33:07.904] {
[10:33:07.904]     {
[10:33:07.904]         {
[10:33:07.904]             ...future.startTime <- base::Sys.time()
[10:33:07.904]             {
[10:33:07.904]                 {
[10:33:07.904]                   {
[10:33:07.904]                     base::local({
[10:33:07.904]                       has_future <- base::requireNamespace("future", 
[10:33:07.904]                         quietly = TRUE)
[10:33:07.904]                       if (has_future) {
[10:33:07.904]                         ns <- base::getNamespace("future")
[10:33:07.904]                         version <- ns[[".package"]][["version"]]
[10:33:07.904]                         if (is.null(version)) 
[10:33:07.904]                           version <- utils::packageVersion("future")
[10:33:07.904]                       }
[10:33:07.904]                       else {
[10:33:07.904]                         version <- NULL
[10:33:07.904]                       }
[10:33:07.904]                       if (!has_future || version < "1.8.0") {
[10:33:07.904]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.904]                           "", base::R.version$version.string), 
[10:33:07.904]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.904]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.904]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.904]                             "release", "version")], collapse = " "), 
[10:33:07.904]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.904]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.904]                           info)
[10:33:07.904]                         info <- base::paste(info, collapse = "; ")
[10:33:07.904]                         if (!has_future) {
[10:33:07.904]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.904]                             info)
[10:33:07.904]                         }
[10:33:07.904]                         else {
[10:33:07.904]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.904]                             info, version)
[10:33:07.904]                         }
[10:33:07.904]                         base::stop(msg)
[10:33:07.904]                       }
[10:33:07.904]                     })
[10:33:07.904]                   }
[10:33:07.904]                   ...future.strategy.old <- future::plan("list")
[10:33:07.904]                   options(future.plan = NULL)
[10:33:07.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.904]                 }
[10:33:07.904]                 ...future.workdir <- getwd()
[10:33:07.904]             }
[10:33:07.904]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.904]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.904]         }
[10:33:07.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.904]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.904]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.904]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.904]             base::names(...future.oldOptions))
[10:33:07.904]     }
[10:33:07.904]     if (FALSE) {
[10:33:07.904]     }
[10:33:07.904]     else {
[10:33:07.904]         if (TRUE) {
[10:33:07.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.904]                 open = "w")
[10:33:07.904]         }
[10:33:07.904]         else {
[10:33:07.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.904]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.904]         }
[10:33:07.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.904]             base::sink(type = "output", split = FALSE)
[10:33:07.904]             base::close(...future.stdout)
[10:33:07.904]         }, add = TRUE)
[10:33:07.904]     }
[10:33:07.904]     ...future.frame <- base::sys.nframe()
[10:33:07.904]     ...future.conditions <- base::list()
[10:33:07.904]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.904]     if (FALSE) {
[10:33:07.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.904]     }
[10:33:07.904]     ...future.result <- base::tryCatch({
[10:33:07.904]         base::withCallingHandlers({
[10:33:07.904]             ...future.value <- base::withVisible(base::local({
[10:33:07.904]                 x["a"] <- list(1)
[10:33:07.904]                 x
[10:33:07.904]             }))
[10:33:07.904]             future::FutureResult(value = ...future.value$value, 
[10:33:07.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.904]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.904]                     ...future.globalenv.names))
[10:33:07.904]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.904]         }, condition = base::local({
[10:33:07.904]             c <- base::c
[10:33:07.904]             inherits <- base::inherits
[10:33:07.904]             invokeRestart <- base::invokeRestart
[10:33:07.904]             length <- base::length
[10:33:07.904]             list <- base::list
[10:33:07.904]             seq.int <- base::seq.int
[10:33:07.904]             signalCondition <- base::signalCondition
[10:33:07.904]             sys.calls <- base::sys.calls
[10:33:07.904]             `[[` <- base::`[[`
[10:33:07.904]             `+` <- base::`+`
[10:33:07.904]             `<<-` <- base::`<<-`
[10:33:07.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.904]                   3L)]
[10:33:07.904]             }
[10:33:07.904]             function(cond) {
[10:33:07.904]                 is_error <- inherits(cond, "error")
[10:33:07.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.904]                   NULL)
[10:33:07.904]                 if (is_error) {
[10:33:07.904]                   sessionInformation <- function() {
[10:33:07.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.904]                       search = base::search(), system = base::Sys.info())
[10:33:07.904]                   }
[10:33:07.904]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.904]                     cond$call), session = sessionInformation(), 
[10:33:07.904]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.904]                   signalCondition(cond)
[10:33:07.904]                 }
[10:33:07.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.904]                 "immediateCondition"))) {
[10:33:07.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.904]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.904]                   if (TRUE && !signal) {
[10:33:07.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.904]                     {
[10:33:07.904]                       inherits <- base::inherits
[10:33:07.904]                       invokeRestart <- base::invokeRestart
[10:33:07.904]                       is.null <- base::is.null
[10:33:07.904]                       muffled <- FALSE
[10:33:07.904]                       if (inherits(cond, "message")) {
[10:33:07.904]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.904]                         if (muffled) 
[10:33:07.904]                           invokeRestart("muffleMessage")
[10:33:07.904]                       }
[10:33:07.904]                       else if (inherits(cond, "warning")) {
[10:33:07.904]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.904]                         if (muffled) 
[10:33:07.904]                           invokeRestart("muffleWarning")
[10:33:07.904]                       }
[10:33:07.904]                       else if (inherits(cond, "condition")) {
[10:33:07.904]                         if (!is.null(pattern)) {
[10:33:07.904]                           computeRestarts <- base::computeRestarts
[10:33:07.904]                           grepl <- base::grepl
[10:33:07.904]                           restarts <- computeRestarts(cond)
[10:33:07.904]                           for (restart in restarts) {
[10:33:07.904]                             name <- restart$name
[10:33:07.904]                             if (is.null(name)) 
[10:33:07.904]                               next
[10:33:07.904]                             if (!grepl(pattern, name)) 
[10:33:07.904]                               next
[10:33:07.904]                             invokeRestart(restart)
[10:33:07.904]                             muffled <- TRUE
[10:33:07.904]                             break
[10:33:07.904]                           }
[10:33:07.904]                         }
[10:33:07.904]                       }
[10:33:07.904]                       invisible(muffled)
[10:33:07.904]                     }
[10:33:07.904]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.904]                   }
[10:33:07.904]                 }
[10:33:07.904]                 else {
[10:33:07.904]                   if (TRUE) {
[10:33:07.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.904]                     {
[10:33:07.904]                       inherits <- base::inherits
[10:33:07.904]                       invokeRestart <- base::invokeRestart
[10:33:07.904]                       is.null <- base::is.null
[10:33:07.904]                       muffled <- FALSE
[10:33:07.904]                       if (inherits(cond, "message")) {
[10:33:07.904]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.904]                         if (muffled) 
[10:33:07.904]                           invokeRestart("muffleMessage")
[10:33:07.904]                       }
[10:33:07.904]                       else if (inherits(cond, "warning")) {
[10:33:07.904]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.904]                         if (muffled) 
[10:33:07.904]                           invokeRestart("muffleWarning")
[10:33:07.904]                       }
[10:33:07.904]                       else if (inherits(cond, "condition")) {
[10:33:07.904]                         if (!is.null(pattern)) {
[10:33:07.904]                           computeRestarts <- base::computeRestarts
[10:33:07.904]                           grepl <- base::grepl
[10:33:07.904]                           restarts <- computeRestarts(cond)
[10:33:07.904]                           for (restart in restarts) {
[10:33:07.904]                             name <- restart$name
[10:33:07.904]                             if (is.null(name)) 
[10:33:07.904]                               next
[10:33:07.904]                             if (!grepl(pattern, name)) 
[10:33:07.904]                               next
[10:33:07.904]                             invokeRestart(restart)
[10:33:07.904]                             muffled <- TRUE
[10:33:07.904]                             break
[10:33:07.904]                           }
[10:33:07.904]                         }
[10:33:07.904]                       }
[10:33:07.904]                       invisible(muffled)
[10:33:07.904]                     }
[10:33:07.904]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.904]                   }
[10:33:07.904]                 }
[10:33:07.904]             }
[10:33:07.904]         }))
[10:33:07.904]     }, error = function(ex) {
[10:33:07.904]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.904]                 ...future.rng), started = ...future.startTime, 
[10:33:07.904]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.904]             version = "1.8"), class = "FutureResult")
[10:33:07.904]     }, finally = {
[10:33:07.904]         if (!identical(...future.workdir, getwd())) 
[10:33:07.904]             setwd(...future.workdir)
[10:33:07.904]         {
[10:33:07.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.904]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.904]             }
[10:33:07.904]             base::options(...future.oldOptions)
[10:33:07.904]             if (.Platform$OS.type == "windows") {
[10:33:07.904]                 old_names <- names(...future.oldEnvVars)
[10:33:07.904]                 envs <- base::Sys.getenv()
[10:33:07.904]                 names <- names(envs)
[10:33:07.904]                 common <- intersect(names, old_names)
[10:33:07.904]                 added <- setdiff(names, old_names)
[10:33:07.904]                 removed <- setdiff(old_names, names)
[10:33:07.904]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.904]                   envs[common]]
[10:33:07.904]                 NAMES <- toupper(changed)
[10:33:07.904]                 args <- list()
[10:33:07.904]                 for (kk in seq_along(NAMES)) {
[10:33:07.904]                   name <- changed[[kk]]
[10:33:07.904]                   NAME <- NAMES[[kk]]
[10:33:07.904]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.904]                     next
[10:33:07.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.904]                 }
[10:33:07.904]                 NAMES <- toupper(added)
[10:33:07.904]                 for (kk in seq_along(NAMES)) {
[10:33:07.904]                   name <- added[[kk]]
[10:33:07.904]                   NAME <- NAMES[[kk]]
[10:33:07.904]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.904]                     next
[10:33:07.904]                   args[[name]] <- ""
[10:33:07.904]                 }
[10:33:07.904]                 NAMES <- toupper(removed)
[10:33:07.904]                 for (kk in seq_along(NAMES)) {
[10:33:07.904]                   name <- removed[[kk]]
[10:33:07.904]                   NAME <- NAMES[[kk]]
[10:33:07.904]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.904]                     next
[10:33:07.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.904]                 }
[10:33:07.904]                 if (length(args) > 0) 
[10:33:07.904]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.904]             }
[10:33:07.904]             else {
[10:33:07.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.904]             }
[10:33:07.904]             {
[10:33:07.904]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.904]                   0L) {
[10:33:07.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.904]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.904]                   base::options(opts)
[10:33:07.904]                 }
[10:33:07.904]                 {
[10:33:07.904]                   {
[10:33:07.904]                     NULL
[10:33:07.904]                     RNGkind("Mersenne-Twister")
[10:33:07.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.904]                       inherits = FALSE)
[10:33:07.904]                   }
[10:33:07.904]                   options(future.plan = NULL)
[10:33:07.904]                   if (is.na(NA_character_)) 
[10:33:07.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.904]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.904]                     .init = FALSE)
[10:33:07.904]                 }
[10:33:07.904]             }
[10:33:07.904]         }
[10:33:07.904]     })
[10:33:07.904]     if (TRUE) {
[10:33:07.904]         base::sink(type = "output", split = FALSE)
[10:33:07.904]         if (TRUE) {
[10:33:07.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.904]         }
[10:33:07.904]         else {
[10:33:07.904]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.904]         }
[10:33:07.904]         base::close(...future.stdout)
[10:33:07.904]         ...future.stdout <- NULL
[10:33:07.904]     }
[10:33:07.904]     ...future.result$conditions <- ...future.conditions
[10:33:07.904]     ...future.result$finished <- base::Sys.time()
[10:33:07.904]     ...future.result
[10:33:07.904] }
[10:33:07.905] assign_globals() ...
[10:33:07.906] List of 1
[10:33:07.906]  $ x: list()
[10:33:07.906]  - attr(*, "where")=List of 1
[10:33:07.906]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.906]  - attr(*, "resolved")= logi TRUE
[10:33:07.906]  - attr(*, "total_size")= num 0
[10:33:07.906]  - attr(*, "already-done")= logi TRUE
[10:33:07.908] - copied ‘x’ to environment
[10:33:07.908] assign_globals() ... done
[10:33:07.908] plan(): Setting new future strategy stack:
[10:33:07.908] List of future strategies:
[10:33:07.908] 1. sequential:
[10:33:07.908]    - args: function (..., envir = parent.frame())
[10:33:07.908]    - tweaked: FALSE
[10:33:07.908]    - call: NULL
[10:33:07.909] plan(): nbrOfWorkers() = 1
[10:33:07.909] plan(): Setting new future strategy stack:
[10:33:07.909] List of future strategies:
[10:33:07.909] 1. sequential:
[10:33:07.909]    - args: function (..., envir = parent.frame())
[10:33:07.909]    - tweaked: FALSE
[10:33:07.909]    - call: plan(strategy)
[10:33:07.910] plan(): nbrOfWorkers() = 1
[10:33:07.910] SequentialFuture started (and completed)
[10:33:07.910] - Launch lazy future ... done
[10:33:07.910] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.911] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.911] Searching for globals...
[10:33:07.914] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:33:07.914] Searching for globals ... DONE
[10:33:07.915] Resolving globals: TRUE
[10:33:07.915] Resolving any globals that are futures ...
[10:33:07.915] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:33:07.915] Resolving any globals that are futures ... DONE
[10:33:07.915] Resolving futures part of globals (recursively) ...
[10:33:07.916] resolve() on list ...
[10:33:07.916]  recursive: 99
[10:33:07.916]  length: 2
[10:33:07.916]  elements: ‘x’, ‘name’
[10:33:07.916]  length: 1 (resolved future 1)
[10:33:07.916]  length: 0 (resolved future 2)
[10:33:07.916] resolve() on list ... DONE
[10:33:07.916] - globals: [2] ‘x’, ‘name’
[10:33:07.916] Resolving futures part of globals (recursively) ... DONE
[10:33:07.916] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:07.917] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[10:33:07.917] - globals: [2] ‘x’, ‘name’
[10:33:07.917] 
[10:33:07.917] getGlobalsAndPackages() ... DONE
[10:33:07.917] run() for ‘Future’ ...
[10:33:07.918] - state: ‘created’
[10:33:07.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:07.918] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:07.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:07.918]   - Field: ‘label’
[10:33:07.918]   - Field: ‘local’
[10:33:07.918]   - Field: ‘owner’
[10:33:07.918]   - Field: ‘envir’
[10:33:07.918]   - Field: ‘packages’
[10:33:07.919]   - Field: ‘gc’
[10:33:07.919]   - Field: ‘conditions’
[10:33:07.919]   - Field: ‘expr’
[10:33:07.919]   - Field: ‘uuid’
[10:33:07.919]   - Field: ‘seed’
[10:33:07.919]   - Field: ‘version’
[10:33:07.919]   - Field: ‘result’
[10:33:07.919]   - Field: ‘asynchronous’
[10:33:07.919]   - Field: ‘calls’
[10:33:07.919]   - Field: ‘globals’
[10:33:07.919]   - Field: ‘stdout’
[10:33:07.920]   - Field: ‘earlySignal’
[10:33:07.920]   - Field: ‘lazy’
[10:33:07.920]   - Field: ‘state’
[10:33:07.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:07.920] - Launch lazy future ...
[10:33:07.920] Packages needed by the future expression (n = 0): <none>
[10:33:07.920] Packages needed by future strategies (n = 0): <none>
[10:33:07.921] {
[10:33:07.921]     {
[10:33:07.921]         {
[10:33:07.921]             ...future.startTime <- base::Sys.time()
[10:33:07.921]             {
[10:33:07.921]                 {
[10:33:07.921]                   {
[10:33:07.921]                     base::local({
[10:33:07.921]                       has_future <- base::requireNamespace("future", 
[10:33:07.921]                         quietly = TRUE)
[10:33:07.921]                       if (has_future) {
[10:33:07.921]                         ns <- base::getNamespace("future")
[10:33:07.921]                         version <- ns[[".package"]][["version"]]
[10:33:07.921]                         if (is.null(version)) 
[10:33:07.921]                           version <- utils::packageVersion("future")
[10:33:07.921]                       }
[10:33:07.921]                       else {
[10:33:07.921]                         version <- NULL
[10:33:07.921]                       }
[10:33:07.921]                       if (!has_future || version < "1.8.0") {
[10:33:07.921]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.921]                           "", base::R.version$version.string), 
[10:33:07.921]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:07.921]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.921]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.921]                             "release", "version")], collapse = " "), 
[10:33:07.921]                           hostname = base::Sys.info()[["nodename"]])
[10:33:07.921]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.921]                           info)
[10:33:07.921]                         info <- base::paste(info, collapse = "; ")
[10:33:07.921]                         if (!has_future) {
[10:33:07.921]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.921]                             info)
[10:33:07.921]                         }
[10:33:07.921]                         else {
[10:33:07.921]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.921]                             info, version)
[10:33:07.921]                         }
[10:33:07.921]                         base::stop(msg)
[10:33:07.921]                       }
[10:33:07.921]                     })
[10:33:07.921]                   }
[10:33:07.921]                   ...future.strategy.old <- future::plan("list")
[10:33:07.921]                   options(future.plan = NULL)
[10:33:07.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.921]                 }
[10:33:07.921]                 ...future.workdir <- getwd()
[10:33:07.921]             }
[10:33:07.921]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.921]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.921]         }
[10:33:07.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.921]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.921]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.921]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.921]             base::names(...future.oldOptions))
[10:33:07.921]     }
[10:33:07.921]     if (FALSE) {
[10:33:07.921]     }
[10:33:07.921]     else {
[10:33:07.921]         if (TRUE) {
[10:33:07.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.921]                 open = "w")
[10:33:07.921]         }
[10:33:07.921]         else {
[10:33:07.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.921]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.921]         }
[10:33:07.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.921]             base::sink(type = "output", split = FALSE)
[10:33:07.921]             base::close(...future.stdout)
[10:33:07.921]         }, add = TRUE)
[10:33:07.921]     }
[10:33:07.921]     ...future.frame <- base::sys.nframe()
[10:33:07.921]     ...future.conditions <- base::list()
[10:33:07.921]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.921]     if (FALSE) {
[10:33:07.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.921]     }
[10:33:07.921]     ...future.result <- base::tryCatch({
[10:33:07.921]         base::withCallingHandlers({
[10:33:07.921]             ...future.value <- base::withVisible(base::local({
[10:33:07.921]                 x[name] <- list(1)
[10:33:07.921]                 x
[10:33:07.921]             }))
[10:33:07.921]             future::FutureResult(value = ...future.value$value, 
[10:33:07.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.921]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.921]                     ...future.globalenv.names))
[10:33:07.921]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.921]         }, condition = base::local({
[10:33:07.921]             c <- base::c
[10:33:07.921]             inherits <- base::inherits
[10:33:07.921]             invokeRestart <- base::invokeRestart
[10:33:07.921]             length <- base::length
[10:33:07.921]             list <- base::list
[10:33:07.921]             seq.int <- base::seq.int
[10:33:07.921]             signalCondition <- base::signalCondition
[10:33:07.921]             sys.calls <- base::sys.calls
[10:33:07.921]             `[[` <- base::`[[`
[10:33:07.921]             `+` <- base::`+`
[10:33:07.921]             `<<-` <- base::`<<-`
[10:33:07.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.921]                   3L)]
[10:33:07.921]             }
[10:33:07.921]             function(cond) {
[10:33:07.921]                 is_error <- inherits(cond, "error")
[10:33:07.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.921]                   NULL)
[10:33:07.921]                 if (is_error) {
[10:33:07.921]                   sessionInformation <- function() {
[10:33:07.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.921]                       search = base::search(), system = base::Sys.info())
[10:33:07.921]                   }
[10:33:07.921]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.921]                     cond$call), session = sessionInformation(), 
[10:33:07.921]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.921]                   signalCondition(cond)
[10:33:07.921]                 }
[10:33:07.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.921]                 "immediateCondition"))) {
[10:33:07.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.921]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.921]                   if (TRUE && !signal) {
[10:33:07.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.921]                     {
[10:33:07.921]                       inherits <- base::inherits
[10:33:07.921]                       invokeRestart <- base::invokeRestart
[10:33:07.921]                       is.null <- base::is.null
[10:33:07.921]                       muffled <- FALSE
[10:33:07.921]                       if (inherits(cond, "message")) {
[10:33:07.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.921]                         if (muffled) 
[10:33:07.921]                           invokeRestart("muffleMessage")
[10:33:07.921]                       }
[10:33:07.921]                       else if (inherits(cond, "warning")) {
[10:33:07.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.921]                         if (muffled) 
[10:33:07.921]                           invokeRestart("muffleWarning")
[10:33:07.921]                       }
[10:33:07.921]                       else if (inherits(cond, "condition")) {
[10:33:07.921]                         if (!is.null(pattern)) {
[10:33:07.921]                           computeRestarts <- base::computeRestarts
[10:33:07.921]                           grepl <- base::grepl
[10:33:07.921]                           restarts <- computeRestarts(cond)
[10:33:07.921]                           for (restart in restarts) {
[10:33:07.921]                             name <- restart$name
[10:33:07.921]                             if (is.null(name)) 
[10:33:07.921]                               next
[10:33:07.921]                             if (!grepl(pattern, name)) 
[10:33:07.921]                               next
[10:33:07.921]                             invokeRestart(restart)
[10:33:07.921]                             muffled <- TRUE
[10:33:07.921]                             break
[10:33:07.921]                           }
[10:33:07.921]                         }
[10:33:07.921]                       }
[10:33:07.921]                       invisible(muffled)
[10:33:07.921]                     }
[10:33:07.921]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.921]                   }
[10:33:07.921]                 }
[10:33:07.921]                 else {
[10:33:07.921]                   if (TRUE) {
[10:33:07.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.921]                     {
[10:33:07.921]                       inherits <- base::inherits
[10:33:07.921]                       invokeRestart <- base::invokeRestart
[10:33:07.921]                       is.null <- base::is.null
[10:33:07.921]                       muffled <- FALSE
[10:33:07.921]                       if (inherits(cond, "message")) {
[10:33:07.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.921]                         if (muffled) 
[10:33:07.921]                           invokeRestart("muffleMessage")
[10:33:07.921]                       }
[10:33:07.921]                       else if (inherits(cond, "warning")) {
[10:33:07.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.921]                         if (muffled) 
[10:33:07.921]                           invokeRestart("muffleWarning")
[10:33:07.921]                       }
[10:33:07.921]                       else if (inherits(cond, "condition")) {
[10:33:07.921]                         if (!is.null(pattern)) {
[10:33:07.921]                           computeRestarts <- base::computeRestarts
[10:33:07.921]                           grepl <- base::grepl
[10:33:07.921]                           restarts <- computeRestarts(cond)
[10:33:07.921]                           for (restart in restarts) {
[10:33:07.921]                             name <- restart$name
[10:33:07.921]                             if (is.null(name)) 
[10:33:07.921]                               next
[10:33:07.921]                             if (!grepl(pattern, name)) 
[10:33:07.921]                               next
[10:33:07.921]                             invokeRestart(restart)
[10:33:07.921]                             muffled <- TRUE
[10:33:07.921]                             break
[10:33:07.921]                           }
[10:33:07.921]                         }
[10:33:07.921]                       }
[10:33:07.921]                       invisible(muffled)
[10:33:07.921]                     }
[10:33:07.921]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.921]                   }
[10:33:07.921]                 }
[10:33:07.921]             }
[10:33:07.921]         }))
[10:33:07.921]     }, error = function(ex) {
[10:33:07.921]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.921]                 ...future.rng), started = ...future.startTime, 
[10:33:07.921]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.921]             version = "1.8"), class = "FutureResult")
[10:33:07.921]     }, finally = {
[10:33:07.921]         if (!identical(...future.workdir, getwd())) 
[10:33:07.921]             setwd(...future.workdir)
[10:33:07.921]         {
[10:33:07.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.921]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.921]             }
[10:33:07.921]             base::options(...future.oldOptions)
[10:33:07.921]             if (.Platform$OS.type == "windows") {
[10:33:07.921]                 old_names <- names(...future.oldEnvVars)
[10:33:07.921]                 envs <- base::Sys.getenv()
[10:33:07.921]                 names <- names(envs)
[10:33:07.921]                 common <- intersect(names, old_names)
[10:33:07.921]                 added <- setdiff(names, old_names)
[10:33:07.921]                 removed <- setdiff(old_names, names)
[10:33:07.921]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.921]                   envs[common]]
[10:33:07.921]                 NAMES <- toupper(changed)
[10:33:07.921]                 args <- list()
[10:33:07.921]                 for (kk in seq_along(NAMES)) {
[10:33:07.921]                   name <- changed[[kk]]
[10:33:07.921]                   NAME <- NAMES[[kk]]
[10:33:07.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.921]                     next
[10:33:07.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.921]                 }
[10:33:07.921]                 NAMES <- toupper(added)
[10:33:07.921]                 for (kk in seq_along(NAMES)) {
[10:33:07.921]                   name <- added[[kk]]
[10:33:07.921]                   NAME <- NAMES[[kk]]
[10:33:07.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.921]                     next
[10:33:07.921]                   args[[name]] <- ""
[10:33:07.921]                 }
[10:33:07.921]                 NAMES <- toupper(removed)
[10:33:07.921]                 for (kk in seq_along(NAMES)) {
[10:33:07.921]                   name <- removed[[kk]]
[10:33:07.921]                   NAME <- NAMES[[kk]]
[10:33:07.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.921]                     next
[10:33:07.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.921]                 }
[10:33:07.921]                 if (length(args) > 0) 
[10:33:07.921]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.921]             }
[10:33:07.921]             else {
[10:33:07.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.921]             }
[10:33:07.921]             {
[10:33:07.921]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.921]                   0L) {
[10:33:07.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.921]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.921]                   base::options(opts)
[10:33:07.921]                 }
[10:33:07.921]                 {
[10:33:07.921]                   {
[10:33:07.921]                     NULL
[10:33:07.921]                     RNGkind("Mersenne-Twister")
[10:33:07.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:07.921]                       inherits = FALSE)
[10:33:07.921]                   }
[10:33:07.921]                   options(future.plan = NULL)
[10:33:07.921]                   if (is.na(NA_character_)) 
[10:33:07.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.921]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.921]                     .init = FALSE)
[10:33:07.921]                 }
[10:33:07.921]             }
[10:33:07.921]         }
[10:33:07.921]     })
[10:33:07.921]     if (TRUE) {
[10:33:07.921]         base::sink(type = "output", split = FALSE)
[10:33:07.921]         if (TRUE) {
[10:33:07.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.921]         }
[10:33:07.921]         else {
[10:33:07.921]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.921]         }
[10:33:07.921]         base::close(...future.stdout)
[10:33:07.921]         ...future.stdout <- NULL
[10:33:07.921]     }
[10:33:07.921]     ...future.result$conditions <- ...future.conditions
[10:33:07.921]     ...future.result$finished <- base::Sys.time()
[10:33:07.921]     ...future.result
[10:33:07.921] }
[10:33:07.922] assign_globals() ...
[10:33:07.922] List of 2
[10:33:07.922]  $ x   : list()
[10:33:07.922]  $ name: chr "a"
[10:33:07.922]  - attr(*, "where")=List of 2
[10:33:07.922]   ..$ x   :<environment: R_EmptyEnv> 
[10:33:07.922]   ..$ name:<environment: R_EmptyEnv> 
[10:33:07.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.922]  - attr(*, "resolved")= logi TRUE
[10:33:07.922]  - attr(*, "total_size")= num 112
[10:33:07.922]  - attr(*, "already-done")= logi TRUE
[10:33:07.925] - copied ‘x’ to environment
[10:33:07.925] - copied ‘name’ to environment
[10:33:07.925] assign_globals() ... done
[10:33:07.925] plan(): Setting new future strategy stack:
[10:33:07.925] List of future strategies:
[10:33:07.925] 1. sequential:
[10:33:07.925]    - args: function (..., envir = parent.frame())
[10:33:07.925]    - tweaked: FALSE
[10:33:07.925]    - call: NULL
[10:33:07.926] plan(): nbrOfWorkers() = 1
[10:33:07.926] plan(): Setting new future strategy stack:
[10:33:07.927] List of future strategies:
[10:33:07.927] 1. sequential:
[10:33:07.927]    - args: function (..., envir = parent.frame())
[10:33:07.927]    - tweaked: FALSE
[10:33:07.927]    - call: plan(strategy)
[10:33:07.927] plan(): nbrOfWorkers() = 1
[10:33:07.927] SequentialFuture started (and completed)
[10:33:07.927] - Launch lazy future ... done
[10:33:07.927] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[10:33:07.936] plan(): Setting new future strategy stack:
[10:33:07.936] List of future strategies:
[10:33:07.936] 1. multicore:
[10:33:07.936]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:07.936]    - tweaked: FALSE
[10:33:07.936]    - call: plan(strategy)
[10:33:07.940] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.940] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.940] Searching for globals...
[10:33:07.944] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.944] Searching for globals ... DONE
[10:33:07.944] Resolving globals: TRUE
[10:33:07.944] Resolving any globals that are futures ...
[10:33:07.944] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.944] Resolving any globals that are futures ... DONE
[10:33:07.944] Resolving futures part of globals (recursively) ...
[10:33:07.945] resolve() on list ...
[10:33:07.945]  recursive: 99
[10:33:07.945]  length: 1
[10:33:07.945]  elements: ‘x’
[10:33:07.945]  length: 0 (resolved future 1)
[10:33:07.945] resolve() on list ... DONE
[10:33:07.945] - globals: [1] ‘x’
[10:33:07.945] Resolving futures part of globals (recursively) ... DONE
[10:33:07.945] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.946] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.946] - globals: [1] ‘x’
[10:33:07.946] 
[10:33:07.946] getGlobalsAndPackages() ... DONE
[10:33:07.946] run() for ‘Future’ ...
[10:33:07.946] - state: ‘created’
[10:33:07.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:07.950] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:07.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:07.950]   - Field: ‘label’
[10:33:07.950]   - Field: ‘local’
[10:33:07.951]   - Field: ‘owner’
[10:33:07.951]   - Field: ‘envir’
[10:33:07.951]   - Field: ‘workers’
[10:33:07.951]   - Field: ‘packages’
[10:33:07.951]   - Field: ‘gc’
[10:33:07.951]   - Field: ‘job’
[10:33:07.951]   - Field: ‘conditions’
[10:33:07.951]   - Field: ‘expr’
[10:33:07.951]   - Field: ‘uuid’
[10:33:07.951]   - Field: ‘seed’
[10:33:07.952]   - Field: ‘version’
[10:33:07.952]   - Field: ‘result’
[10:33:07.952]   - Field: ‘asynchronous’
[10:33:07.952]   - Field: ‘calls’
[10:33:07.952]   - Field: ‘globals’
[10:33:07.952]   - Field: ‘stdout’
[10:33:07.952]   - Field: ‘earlySignal’
[10:33:07.952]   - Field: ‘lazy’
[10:33:07.952]   - Field: ‘state’
[10:33:07.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:07.952] - Launch lazy future ...
[10:33:07.953] Packages needed by the future expression (n = 0): <none>
[10:33:07.954] Packages needed by future strategies (n = 0): <none>
[10:33:07.954] {
[10:33:07.954]     {
[10:33:07.954]         {
[10:33:07.954]             ...future.startTime <- base::Sys.time()
[10:33:07.954]             {
[10:33:07.954]                 {
[10:33:07.954]                   {
[10:33:07.954]                     {
[10:33:07.954]                       base::local({
[10:33:07.954]                         has_future <- base::requireNamespace("future", 
[10:33:07.954]                           quietly = TRUE)
[10:33:07.954]                         if (has_future) {
[10:33:07.954]                           ns <- base::getNamespace("future")
[10:33:07.954]                           version <- ns[[".package"]][["version"]]
[10:33:07.954]                           if (is.null(version)) 
[10:33:07.954]                             version <- utils::packageVersion("future")
[10:33:07.954]                         }
[10:33:07.954]                         else {
[10:33:07.954]                           version <- NULL
[10:33:07.954]                         }
[10:33:07.954]                         if (!has_future || version < "1.8.0") {
[10:33:07.954]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.954]                             "", base::R.version$version.string), 
[10:33:07.954]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:07.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.954]                               "release", "version")], collapse = " "), 
[10:33:07.954]                             hostname = base::Sys.info()[["nodename"]])
[10:33:07.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.954]                             info)
[10:33:07.954]                           info <- base::paste(info, collapse = "; ")
[10:33:07.954]                           if (!has_future) {
[10:33:07.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.954]                               info)
[10:33:07.954]                           }
[10:33:07.954]                           else {
[10:33:07.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.954]                               info, version)
[10:33:07.954]                           }
[10:33:07.954]                           base::stop(msg)
[10:33:07.954]                         }
[10:33:07.954]                       })
[10:33:07.954]                     }
[10:33:07.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:07.954]                     base::options(mc.cores = 1L)
[10:33:07.954]                   }
[10:33:07.954]                   ...future.strategy.old <- future::plan("list")
[10:33:07.954]                   options(future.plan = NULL)
[10:33:07.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.954]                 }
[10:33:07.954]                 ...future.workdir <- getwd()
[10:33:07.954]             }
[10:33:07.954]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.954]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.954]         }
[10:33:07.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.954]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.954]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.954]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.954]             base::names(...future.oldOptions))
[10:33:07.954]     }
[10:33:07.954]     if (FALSE) {
[10:33:07.954]     }
[10:33:07.954]     else {
[10:33:07.954]         if (TRUE) {
[10:33:07.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.954]                 open = "w")
[10:33:07.954]         }
[10:33:07.954]         else {
[10:33:07.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.954]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.954]         }
[10:33:07.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.954]             base::sink(type = "output", split = FALSE)
[10:33:07.954]             base::close(...future.stdout)
[10:33:07.954]         }, add = TRUE)
[10:33:07.954]     }
[10:33:07.954]     ...future.frame <- base::sys.nframe()
[10:33:07.954]     ...future.conditions <- base::list()
[10:33:07.954]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.954]     if (FALSE) {
[10:33:07.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.954]     }
[10:33:07.954]     ...future.result <- base::tryCatch({
[10:33:07.954]         base::withCallingHandlers({
[10:33:07.954]             ...future.value <- base::withVisible(base::local({
[10:33:07.954]                 withCallingHandlers({
[10:33:07.954]                   {
[10:33:07.954]                     x$a <- 1
[10:33:07.954]                     x
[10:33:07.954]                   }
[10:33:07.954]                 }, immediateCondition = function(cond) {
[10:33:07.954]                   save_rds <- function (object, pathname, ...) 
[10:33:07.954]                   {
[10:33:07.954]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:07.954]                     if (file_test("-f", pathname_tmp)) {
[10:33:07.954]                       fi_tmp <- file.info(pathname_tmp)
[10:33:07.954]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:07.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:07.954]                         fi_tmp[["mtime"]])
[10:33:07.954]                     }
[10:33:07.954]                     tryCatch({
[10:33:07.954]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:07.954]                     }, error = function(ex) {
[10:33:07.954]                       msg <- conditionMessage(ex)
[10:33:07.954]                       fi_tmp <- file.info(pathname_tmp)
[10:33:07.954]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:07.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:07.954]                         fi_tmp[["mtime"]], msg)
[10:33:07.954]                       ex$message <- msg
[10:33:07.954]                       stop(ex)
[10:33:07.954]                     })
[10:33:07.954]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:07.954]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:07.954]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:07.954]                       fi_tmp <- file.info(pathname_tmp)
[10:33:07.954]                       fi <- file.info(pathname)
[10:33:07.954]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:07.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:07.954]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:07.954]                         fi[["size"]], fi[["mtime"]])
[10:33:07.954]                       stop(msg)
[10:33:07.954]                     }
[10:33:07.954]                     invisible(pathname)
[10:33:07.954]                   }
[10:33:07.954]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:07.954]                     rootPath = tempdir()) 
[10:33:07.954]                   {
[10:33:07.954]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:07.954]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:07.954]                       tmpdir = path, fileext = ".rds")
[10:33:07.954]                     save_rds(obj, file)
[10:33:07.954]                   }
[10:33:07.954]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:07.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.954]                   {
[10:33:07.954]                     inherits <- base::inherits
[10:33:07.954]                     invokeRestart <- base::invokeRestart
[10:33:07.954]                     is.null <- base::is.null
[10:33:07.954]                     muffled <- FALSE
[10:33:07.954]                     if (inherits(cond, "message")) {
[10:33:07.954]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:07.954]                       if (muffled) 
[10:33:07.954]                         invokeRestart("muffleMessage")
[10:33:07.954]                     }
[10:33:07.954]                     else if (inherits(cond, "warning")) {
[10:33:07.954]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:07.954]                       if (muffled) 
[10:33:07.954]                         invokeRestart("muffleWarning")
[10:33:07.954]                     }
[10:33:07.954]                     else if (inherits(cond, "condition")) {
[10:33:07.954]                       if (!is.null(pattern)) {
[10:33:07.954]                         computeRestarts <- base::computeRestarts
[10:33:07.954]                         grepl <- base::grepl
[10:33:07.954]                         restarts <- computeRestarts(cond)
[10:33:07.954]                         for (restart in restarts) {
[10:33:07.954]                           name <- restart$name
[10:33:07.954]                           if (is.null(name)) 
[10:33:07.954]                             next
[10:33:07.954]                           if (!grepl(pattern, name)) 
[10:33:07.954]                             next
[10:33:07.954]                           invokeRestart(restart)
[10:33:07.954]                           muffled <- TRUE
[10:33:07.954]                           break
[10:33:07.954]                         }
[10:33:07.954]                       }
[10:33:07.954]                     }
[10:33:07.954]                     invisible(muffled)
[10:33:07.954]                   }
[10:33:07.954]                   muffleCondition(cond)
[10:33:07.954]                 })
[10:33:07.954]             }))
[10:33:07.954]             future::FutureResult(value = ...future.value$value, 
[10:33:07.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.954]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.954]                     ...future.globalenv.names))
[10:33:07.954]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.954]         }, condition = base::local({
[10:33:07.954]             c <- base::c
[10:33:07.954]             inherits <- base::inherits
[10:33:07.954]             invokeRestart <- base::invokeRestart
[10:33:07.954]             length <- base::length
[10:33:07.954]             list <- base::list
[10:33:07.954]             seq.int <- base::seq.int
[10:33:07.954]             signalCondition <- base::signalCondition
[10:33:07.954]             sys.calls <- base::sys.calls
[10:33:07.954]             `[[` <- base::`[[`
[10:33:07.954]             `+` <- base::`+`
[10:33:07.954]             `<<-` <- base::`<<-`
[10:33:07.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.954]                   3L)]
[10:33:07.954]             }
[10:33:07.954]             function(cond) {
[10:33:07.954]                 is_error <- inherits(cond, "error")
[10:33:07.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.954]                   NULL)
[10:33:07.954]                 if (is_error) {
[10:33:07.954]                   sessionInformation <- function() {
[10:33:07.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.954]                       search = base::search(), system = base::Sys.info())
[10:33:07.954]                   }
[10:33:07.954]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.954]                     cond$call), session = sessionInformation(), 
[10:33:07.954]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.954]                   signalCondition(cond)
[10:33:07.954]                 }
[10:33:07.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.954]                 "immediateCondition"))) {
[10:33:07.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.954]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.954]                   if (TRUE && !signal) {
[10:33:07.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.954]                     {
[10:33:07.954]                       inherits <- base::inherits
[10:33:07.954]                       invokeRestart <- base::invokeRestart
[10:33:07.954]                       is.null <- base::is.null
[10:33:07.954]                       muffled <- FALSE
[10:33:07.954]                       if (inherits(cond, "message")) {
[10:33:07.954]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.954]                         if (muffled) 
[10:33:07.954]                           invokeRestart("muffleMessage")
[10:33:07.954]                       }
[10:33:07.954]                       else if (inherits(cond, "warning")) {
[10:33:07.954]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.954]                         if (muffled) 
[10:33:07.954]                           invokeRestart("muffleWarning")
[10:33:07.954]                       }
[10:33:07.954]                       else if (inherits(cond, "condition")) {
[10:33:07.954]                         if (!is.null(pattern)) {
[10:33:07.954]                           computeRestarts <- base::computeRestarts
[10:33:07.954]                           grepl <- base::grepl
[10:33:07.954]                           restarts <- computeRestarts(cond)
[10:33:07.954]                           for (restart in restarts) {
[10:33:07.954]                             name <- restart$name
[10:33:07.954]                             if (is.null(name)) 
[10:33:07.954]                               next
[10:33:07.954]                             if (!grepl(pattern, name)) 
[10:33:07.954]                               next
[10:33:07.954]                             invokeRestart(restart)
[10:33:07.954]                             muffled <- TRUE
[10:33:07.954]                             break
[10:33:07.954]                           }
[10:33:07.954]                         }
[10:33:07.954]                       }
[10:33:07.954]                       invisible(muffled)
[10:33:07.954]                     }
[10:33:07.954]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.954]                   }
[10:33:07.954]                 }
[10:33:07.954]                 else {
[10:33:07.954]                   if (TRUE) {
[10:33:07.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.954]                     {
[10:33:07.954]                       inherits <- base::inherits
[10:33:07.954]                       invokeRestart <- base::invokeRestart
[10:33:07.954]                       is.null <- base::is.null
[10:33:07.954]                       muffled <- FALSE
[10:33:07.954]                       if (inherits(cond, "message")) {
[10:33:07.954]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.954]                         if (muffled) 
[10:33:07.954]                           invokeRestart("muffleMessage")
[10:33:07.954]                       }
[10:33:07.954]                       else if (inherits(cond, "warning")) {
[10:33:07.954]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.954]                         if (muffled) 
[10:33:07.954]                           invokeRestart("muffleWarning")
[10:33:07.954]                       }
[10:33:07.954]                       else if (inherits(cond, "condition")) {
[10:33:07.954]                         if (!is.null(pattern)) {
[10:33:07.954]                           computeRestarts <- base::computeRestarts
[10:33:07.954]                           grepl <- base::grepl
[10:33:07.954]                           restarts <- computeRestarts(cond)
[10:33:07.954]                           for (restart in restarts) {
[10:33:07.954]                             name <- restart$name
[10:33:07.954]                             if (is.null(name)) 
[10:33:07.954]                               next
[10:33:07.954]                             if (!grepl(pattern, name)) 
[10:33:07.954]                               next
[10:33:07.954]                             invokeRestart(restart)
[10:33:07.954]                             muffled <- TRUE
[10:33:07.954]                             break
[10:33:07.954]                           }
[10:33:07.954]                         }
[10:33:07.954]                       }
[10:33:07.954]                       invisible(muffled)
[10:33:07.954]                     }
[10:33:07.954]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.954]                   }
[10:33:07.954]                 }
[10:33:07.954]             }
[10:33:07.954]         }))
[10:33:07.954]     }, error = function(ex) {
[10:33:07.954]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.954]                 ...future.rng), started = ...future.startTime, 
[10:33:07.954]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.954]             version = "1.8"), class = "FutureResult")
[10:33:07.954]     }, finally = {
[10:33:07.954]         if (!identical(...future.workdir, getwd())) 
[10:33:07.954]             setwd(...future.workdir)
[10:33:07.954]         {
[10:33:07.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.954]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.954]             }
[10:33:07.954]             base::options(...future.oldOptions)
[10:33:07.954]             if (.Platform$OS.type == "windows") {
[10:33:07.954]                 old_names <- names(...future.oldEnvVars)
[10:33:07.954]                 envs <- base::Sys.getenv()
[10:33:07.954]                 names <- names(envs)
[10:33:07.954]                 common <- intersect(names, old_names)
[10:33:07.954]                 added <- setdiff(names, old_names)
[10:33:07.954]                 removed <- setdiff(old_names, names)
[10:33:07.954]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.954]                   envs[common]]
[10:33:07.954]                 NAMES <- toupper(changed)
[10:33:07.954]                 args <- list()
[10:33:07.954]                 for (kk in seq_along(NAMES)) {
[10:33:07.954]                   name <- changed[[kk]]
[10:33:07.954]                   NAME <- NAMES[[kk]]
[10:33:07.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.954]                     next
[10:33:07.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.954]                 }
[10:33:07.954]                 NAMES <- toupper(added)
[10:33:07.954]                 for (kk in seq_along(NAMES)) {
[10:33:07.954]                   name <- added[[kk]]
[10:33:07.954]                   NAME <- NAMES[[kk]]
[10:33:07.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.954]                     next
[10:33:07.954]                   args[[name]] <- ""
[10:33:07.954]                 }
[10:33:07.954]                 NAMES <- toupper(removed)
[10:33:07.954]                 for (kk in seq_along(NAMES)) {
[10:33:07.954]                   name <- removed[[kk]]
[10:33:07.954]                   NAME <- NAMES[[kk]]
[10:33:07.954]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.954]                     next
[10:33:07.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.954]                 }
[10:33:07.954]                 if (length(args) > 0) 
[10:33:07.954]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.954]             }
[10:33:07.954]             else {
[10:33:07.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.954]             }
[10:33:07.954]             {
[10:33:07.954]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.954]                   0L) {
[10:33:07.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.954]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.954]                   base::options(opts)
[10:33:07.954]                 }
[10:33:07.954]                 {
[10:33:07.954]                   {
[10:33:07.954]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:07.954]                     NULL
[10:33:07.954]                   }
[10:33:07.954]                   options(future.plan = NULL)
[10:33:07.954]                   if (is.na(NA_character_)) 
[10:33:07.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.954]                     .init = FALSE)
[10:33:07.954]                 }
[10:33:07.954]             }
[10:33:07.954]         }
[10:33:07.954]     })
[10:33:07.954]     if (TRUE) {
[10:33:07.954]         base::sink(type = "output", split = FALSE)
[10:33:07.954]         if (TRUE) {
[10:33:07.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.954]         }
[10:33:07.954]         else {
[10:33:07.954]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.954]         }
[10:33:07.954]         base::close(...future.stdout)
[10:33:07.954]         ...future.stdout <- NULL
[10:33:07.954]     }
[10:33:07.954]     ...future.result$conditions <- ...future.conditions
[10:33:07.954]     ...future.result$finished <- base::Sys.time()
[10:33:07.954]     ...future.result
[10:33:07.954] }
[10:33:07.956] assign_globals() ...
[10:33:07.956] List of 1
[10:33:07.956]  $ x: list()
[10:33:07.956]  - attr(*, "where")=List of 1
[10:33:07.956]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.956]  - attr(*, "resolved")= logi TRUE
[10:33:07.956]  - attr(*, "total_size")= num 0
[10:33:07.956]  - attr(*, "already-done")= logi TRUE
[10:33:07.959] - copied ‘x’ to environment
[10:33:07.959] assign_globals() ... done
[10:33:07.959] requestCore(): workers = 2
[10:33:07.962] MulticoreFuture started
[10:33:07.962] - Launch lazy future ... done
[10:33:07.962] run() for ‘MulticoreFuture’ ... done
[10:33:07.962] plan(): Setting new future strategy stack:
[10:33:07.963] List of future strategies:
[10:33:07.963] 1. sequential:
[10:33:07.963]    - args: function (..., envir = parent.frame())
[10:33:07.963]    - tweaked: FALSE
[10:33:07.963]    - call: NULL
[10:33:07.964] plan(): nbrOfWorkers() = 1
[10:33:07.964] result() for MulticoreFuture ...
[10:33:07.965] plan(): Setting new future strategy stack:
[10:33:07.966] List of future strategies:
[10:33:07.966] 1. multicore:
[10:33:07.966]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:07.966]    - tweaked: FALSE
[10:33:07.966]    - call: plan(strategy)
[10:33:07.971] plan(): nbrOfWorkers() = 2
[10:33:07.975] result() for MulticoreFuture ...
[10:33:07.976] result() for MulticoreFuture ... done
[10:33:07.976] result() for MulticoreFuture ... done
[10:33:07.976] result() for MulticoreFuture ...
[10:33:07.976] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:07.976] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:07.977] Searching for globals...
[10:33:07.979] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.979] Searching for globals ... DONE
[10:33:07.979] Resolving globals: TRUE
[10:33:07.979] Resolving any globals that are futures ...
[10:33:07.980] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:07.980] Resolving any globals that are futures ... DONE
[10:33:07.980] Resolving futures part of globals (recursively) ...
[10:33:07.981] resolve() on list ...
[10:33:07.981]  recursive: 99
[10:33:07.981]  length: 1
[10:33:07.981]  elements: ‘x’
[10:33:07.981]  length: 0 (resolved future 1)
[10:33:07.981] resolve() on list ... DONE
[10:33:07.981] - globals: [1] ‘x’
[10:33:07.981] Resolving futures part of globals (recursively) ... DONE
[10:33:07.982] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:07.982] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:07.982] - globals: [1] ‘x’
[10:33:07.982] 
[10:33:07.982] getGlobalsAndPackages() ... DONE
[10:33:07.983] run() for ‘Future’ ...
[10:33:07.983] - state: ‘created’
[10:33:07.983] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:07.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:07.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:07.990]   - Field: ‘label’
[10:33:07.991]   - Field: ‘local’
[10:33:07.991]   - Field: ‘owner’
[10:33:07.991]   - Field: ‘envir’
[10:33:07.991]   - Field: ‘workers’
[10:33:07.991]   - Field: ‘packages’
[10:33:07.991]   - Field: ‘gc’
[10:33:07.991]   - Field: ‘job’
[10:33:07.992]   - Field: ‘conditions’
[10:33:07.992]   - Field: ‘expr’
[10:33:07.992]   - Field: ‘uuid’
[10:33:07.992]   - Field: ‘seed’
[10:33:07.992]   - Field: ‘version’
[10:33:07.992]   - Field: ‘result’
[10:33:07.992]   - Field: ‘asynchronous’
[10:33:07.992]   - Field: ‘calls’
[10:33:07.992]   - Field: ‘globals’
[10:33:07.993]   - Field: ‘stdout’
[10:33:07.993]   - Field: ‘earlySignal’
[10:33:07.993]   - Field: ‘lazy’
[10:33:07.993]   - Field: ‘state’
[10:33:07.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:07.993] - Launch lazy future ...
[10:33:07.994] Packages needed by the future expression (n = 0): <none>
[10:33:07.994] Packages needed by future strategies (n = 0): <none>
[10:33:07.994] {
[10:33:07.994]     {
[10:33:07.994]         {
[10:33:07.994]             ...future.startTime <- base::Sys.time()
[10:33:07.994]             {
[10:33:07.994]                 {
[10:33:07.994]                   {
[10:33:07.994]                     {
[10:33:07.994]                       base::local({
[10:33:07.994]                         has_future <- base::requireNamespace("future", 
[10:33:07.994]                           quietly = TRUE)
[10:33:07.994]                         if (has_future) {
[10:33:07.994]                           ns <- base::getNamespace("future")
[10:33:07.994]                           version <- ns[[".package"]][["version"]]
[10:33:07.994]                           if (is.null(version)) 
[10:33:07.994]                             version <- utils::packageVersion("future")
[10:33:07.994]                         }
[10:33:07.994]                         else {
[10:33:07.994]                           version <- NULL
[10:33:07.994]                         }
[10:33:07.994]                         if (!has_future || version < "1.8.0") {
[10:33:07.994]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:07.994]                             "", base::R.version$version.string), 
[10:33:07.994]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:07.994]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:07.994]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:07.994]                               "release", "version")], collapse = " "), 
[10:33:07.994]                             hostname = base::Sys.info()[["nodename"]])
[10:33:07.994]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:07.994]                             info)
[10:33:07.994]                           info <- base::paste(info, collapse = "; ")
[10:33:07.994]                           if (!has_future) {
[10:33:07.994]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:07.994]                               info)
[10:33:07.994]                           }
[10:33:07.994]                           else {
[10:33:07.994]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:07.994]                               info, version)
[10:33:07.994]                           }
[10:33:07.994]                           base::stop(msg)
[10:33:07.994]                         }
[10:33:07.994]                       })
[10:33:07.994]                     }
[10:33:07.994]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:07.994]                     base::options(mc.cores = 1L)
[10:33:07.994]                   }
[10:33:07.994]                   ...future.strategy.old <- future::plan("list")
[10:33:07.994]                   options(future.plan = NULL)
[10:33:07.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:07.994]                 }
[10:33:07.994]                 ...future.workdir <- getwd()
[10:33:07.994]             }
[10:33:07.994]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:07.994]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:07.994]         }
[10:33:07.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:07.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:07.994]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:07.994]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:07.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:07.994]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:07.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:07.994]             base::names(...future.oldOptions))
[10:33:07.994]     }
[10:33:07.994]     if (FALSE) {
[10:33:07.994]     }
[10:33:07.994]     else {
[10:33:07.994]         if (TRUE) {
[10:33:07.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:07.994]                 open = "w")
[10:33:07.994]         }
[10:33:07.994]         else {
[10:33:07.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:07.994]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:07.994]         }
[10:33:07.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:07.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:07.994]             base::sink(type = "output", split = FALSE)
[10:33:07.994]             base::close(...future.stdout)
[10:33:07.994]         }, add = TRUE)
[10:33:07.994]     }
[10:33:07.994]     ...future.frame <- base::sys.nframe()
[10:33:07.994]     ...future.conditions <- base::list()
[10:33:07.994]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:07.994]     if (FALSE) {
[10:33:07.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:07.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:07.994]     }
[10:33:07.994]     ...future.result <- base::tryCatch({
[10:33:07.994]         base::withCallingHandlers({
[10:33:07.994]             ...future.value <- base::withVisible(base::local({
[10:33:07.994]                 withCallingHandlers({
[10:33:07.994]                   {
[10:33:07.994]                     x$a <- 1
[10:33:07.994]                     x
[10:33:07.994]                   }
[10:33:07.994]                 }, immediateCondition = function(cond) {
[10:33:07.994]                   save_rds <- function (object, pathname, ...) 
[10:33:07.994]                   {
[10:33:07.994]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:07.994]                     if (file_test("-f", pathname_tmp)) {
[10:33:07.994]                       fi_tmp <- file.info(pathname_tmp)
[10:33:07.994]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:07.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:07.994]                         fi_tmp[["mtime"]])
[10:33:07.994]                     }
[10:33:07.994]                     tryCatch({
[10:33:07.994]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:07.994]                     }, error = function(ex) {
[10:33:07.994]                       msg <- conditionMessage(ex)
[10:33:07.994]                       fi_tmp <- file.info(pathname_tmp)
[10:33:07.994]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:07.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:07.994]                         fi_tmp[["mtime"]], msg)
[10:33:07.994]                       ex$message <- msg
[10:33:07.994]                       stop(ex)
[10:33:07.994]                     })
[10:33:07.994]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:07.994]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:07.994]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:07.994]                       fi_tmp <- file.info(pathname_tmp)
[10:33:07.994]                       fi <- file.info(pathname)
[10:33:07.994]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:07.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:07.994]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:07.994]                         fi[["size"]], fi[["mtime"]])
[10:33:07.994]                       stop(msg)
[10:33:07.994]                     }
[10:33:07.994]                     invisible(pathname)
[10:33:07.994]                   }
[10:33:07.994]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:07.994]                     rootPath = tempdir()) 
[10:33:07.994]                   {
[10:33:07.994]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:07.994]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:07.994]                       tmpdir = path, fileext = ".rds")
[10:33:07.994]                     save_rds(obj, file)
[10:33:07.994]                   }
[10:33:07.994]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:07.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.994]                   {
[10:33:07.994]                     inherits <- base::inherits
[10:33:07.994]                     invokeRestart <- base::invokeRestart
[10:33:07.994]                     is.null <- base::is.null
[10:33:07.994]                     muffled <- FALSE
[10:33:07.994]                     if (inherits(cond, "message")) {
[10:33:07.994]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:07.994]                       if (muffled) 
[10:33:07.994]                         invokeRestart("muffleMessage")
[10:33:07.994]                     }
[10:33:07.994]                     else if (inherits(cond, "warning")) {
[10:33:07.994]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:07.994]                       if (muffled) 
[10:33:07.994]                         invokeRestart("muffleWarning")
[10:33:07.994]                     }
[10:33:07.994]                     else if (inherits(cond, "condition")) {
[10:33:07.994]                       if (!is.null(pattern)) {
[10:33:07.994]                         computeRestarts <- base::computeRestarts
[10:33:07.994]                         grepl <- base::grepl
[10:33:07.994]                         restarts <- computeRestarts(cond)
[10:33:07.994]                         for (restart in restarts) {
[10:33:07.994]                           name <- restart$name
[10:33:07.994]                           if (is.null(name)) 
[10:33:07.994]                             next
[10:33:07.994]                           if (!grepl(pattern, name)) 
[10:33:07.994]                             next
[10:33:07.994]                           invokeRestart(restart)
[10:33:07.994]                           muffled <- TRUE
[10:33:07.994]                           break
[10:33:07.994]                         }
[10:33:07.994]                       }
[10:33:07.994]                     }
[10:33:07.994]                     invisible(muffled)
[10:33:07.994]                   }
[10:33:07.994]                   muffleCondition(cond)
[10:33:07.994]                 })
[10:33:07.994]             }))
[10:33:07.994]             future::FutureResult(value = ...future.value$value, 
[10:33:07.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.994]                   ...future.rng), globalenv = if (FALSE) 
[10:33:07.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:07.994]                     ...future.globalenv.names))
[10:33:07.994]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:07.994]         }, condition = base::local({
[10:33:07.994]             c <- base::c
[10:33:07.994]             inherits <- base::inherits
[10:33:07.994]             invokeRestart <- base::invokeRestart
[10:33:07.994]             length <- base::length
[10:33:07.994]             list <- base::list
[10:33:07.994]             seq.int <- base::seq.int
[10:33:07.994]             signalCondition <- base::signalCondition
[10:33:07.994]             sys.calls <- base::sys.calls
[10:33:07.994]             `[[` <- base::`[[`
[10:33:07.994]             `+` <- base::`+`
[10:33:07.994]             `<<-` <- base::`<<-`
[10:33:07.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:07.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:07.994]                   3L)]
[10:33:07.994]             }
[10:33:07.994]             function(cond) {
[10:33:07.994]                 is_error <- inherits(cond, "error")
[10:33:07.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:07.994]                   NULL)
[10:33:07.994]                 if (is_error) {
[10:33:07.994]                   sessionInformation <- function() {
[10:33:07.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:07.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:07.994]                       search = base::search(), system = base::Sys.info())
[10:33:07.994]                   }
[10:33:07.994]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:07.994]                     cond$call), session = sessionInformation(), 
[10:33:07.994]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:07.994]                   signalCondition(cond)
[10:33:07.994]                 }
[10:33:07.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:07.994]                 "immediateCondition"))) {
[10:33:07.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:07.994]                   ...future.conditions[[length(...future.conditions) + 
[10:33:07.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:07.994]                   if (TRUE && !signal) {
[10:33:07.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.994]                     {
[10:33:07.994]                       inherits <- base::inherits
[10:33:07.994]                       invokeRestart <- base::invokeRestart
[10:33:07.994]                       is.null <- base::is.null
[10:33:07.994]                       muffled <- FALSE
[10:33:07.994]                       if (inherits(cond, "message")) {
[10:33:07.994]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.994]                         if (muffled) 
[10:33:07.994]                           invokeRestart("muffleMessage")
[10:33:07.994]                       }
[10:33:07.994]                       else if (inherits(cond, "warning")) {
[10:33:07.994]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.994]                         if (muffled) 
[10:33:07.994]                           invokeRestart("muffleWarning")
[10:33:07.994]                       }
[10:33:07.994]                       else if (inherits(cond, "condition")) {
[10:33:07.994]                         if (!is.null(pattern)) {
[10:33:07.994]                           computeRestarts <- base::computeRestarts
[10:33:07.994]                           grepl <- base::grepl
[10:33:07.994]                           restarts <- computeRestarts(cond)
[10:33:07.994]                           for (restart in restarts) {
[10:33:07.994]                             name <- restart$name
[10:33:07.994]                             if (is.null(name)) 
[10:33:07.994]                               next
[10:33:07.994]                             if (!grepl(pattern, name)) 
[10:33:07.994]                               next
[10:33:07.994]                             invokeRestart(restart)
[10:33:07.994]                             muffled <- TRUE
[10:33:07.994]                             break
[10:33:07.994]                           }
[10:33:07.994]                         }
[10:33:07.994]                       }
[10:33:07.994]                       invisible(muffled)
[10:33:07.994]                     }
[10:33:07.994]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.994]                   }
[10:33:07.994]                 }
[10:33:07.994]                 else {
[10:33:07.994]                   if (TRUE) {
[10:33:07.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:07.994]                     {
[10:33:07.994]                       inherits <- base::inherits
[10:33:07.994]                       invokeRestart <- base::invokeRestart
[10:33:07.994]                       is.null <- base::is.null
[10:33:07.994]                       muffled <- FALSE
[10:33:07.994]                       if (inherits(cond, "message")) {
[10:33:07.994]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:07.994]                         if (muffled) 
[10:33:07.994]                           invokeRestart("muffleMessage")
[10:33:07.994]                       }
[10:33:07.994]                       else if (inherits(cond, "warning")) {
[10:33:07.994]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:07.994]                         if (muffled) 
[10:33:07.994]                           invokeRestart("muffleWarning")
[10:33:07.994]                       }
[10:33:07.994]                       else if (inherits(cond, "condition")) {
[10:33:07.994]                         if (!is.null(pattern)) {
[10:33:07.994]                           computeRestarts <- base::computeRestarts
[10:33:07.994]                           grepl <- base::grepl
[10:33:07.994]                           restarts <- computeRestarts(cond)
[10:33:07.994]                           for (restart in restarts) {
[10:33:07.994]                             name <- restart$name
[10:33:07.994]                             if (is.null(name)) 
[10:33:07.994]                               next
[10:33:07.994]                             if (!grepl(pattern, name)) 
[10:33:07.994]                               next
[10:33:07.994]                             invokeRestart(restart)
[10:33:07.994]                             muffled <- TRUE
[10:33:07.994]                             break
[10:33:07.994]                           }
[10:33:07.994]                         }
[10:33:07.994]                       }
[10:33:07.994]                       invisible(muffled)
[10:33:07.994]                     }
[10:33:07.994]                     muffleCondition(cond, pattern = "^muffle")
[10:33:07.994]                   }
[10:33:07.994]                 }
[10:33:07.994]             }
[10:33:07.994]         }))
[10:33:07.994]     }, error = function(ex) {
[10:33:07.994]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:07.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:07.994]                 ...future.rng), started = ...future.startTime, 
[10:33:07.994]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:07.994]             version = "1.8"), class = "FutureResult")
[10:33:07.994]     }, finally = {
[10:33:07.994]         if (!identical(...future.workdir, getwd())) 
[10:33:07.994]             setwd(...future.workdir)
[10:33:07.994]         {
[10:33:07.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:07.994]                 ...future.oldOptions$nwarnings <- NULL
[10:33:07.994]             }
[10:33:07.994]             base::options(...future.oldOptions)
[10:33:07.994]             if (.Platform$OS.type == "windows") {
[10:33:07.994]                 old_names <- names(...future.oldEnvVars)
[10:33:07.994]                 envs <- base::Sys.getenv()
[10:33:07.994]                 names <- names(envs)
[10:33:07.994]                 common <- intersect(names, old_names)
[10:33:07.994]                 added <- setdiff(names, old_names)
[10:33:07.994]                 removed <- setdiff(old_names, names)
[10:33:07.994]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:07.994]                   envs[common]]
[10:33:07.994]                 NAMES <- toupper(changed)
[10:33:07.994]                 args <- list()
[10:33:07.994]                 for (kk in seq_along(NAMES)) {
[10:33:07.994]                   name <- changed[[kk]]
[10:33:07.994]                   NAME <- NAMES[[kk]]
[10:33:07.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.994]                     next
[10:33:07.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.994]                 }
[10:33:07.994]                 NAMES <- toupper(added)
[10:33:07.994]                 for (kk in seq_along(NAMES)) {
[10:33:07.994]                   name <- added[[kk]]
[10:33:07.994]                   NAME <- NAMES[[kk]]
[10:33:07.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.994]                     next
[10:33:07.994]                   args[[name]] <- ""
[10:33:07.994]                 }
[10:33:07.994]                 NAMES <- toupper(removed)
[10:33:07.994]                 for (kk in seq_along(NAMES)) {
[10:33:07.994]                   name <- removed[[kk]]
[10:33:07.994]                   NAME <- NAMES[[kk]]
[10:33:07.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:07.994]                     next
[10:33:07.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:07.994]                 }
[10:33:07.994]                 if (length(args) > 0) 
[10:33:07.994]                   base::do.call(base::Sys.setenv, args = args)
[10:33:07.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:07.994]             }
[10:33:07.994]             else {
[10:33:07.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:07.994]             }
[10:33:07.994]             {
[10:33:07.994]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:07.994]                   0L) {
[10:33:07.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:07.994]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:07.994]                   base::options(opts)
[10:33:07.994]                 }
[10:33:07.994]                 {
[10:33:07.994]                   {
[10:33:07.994]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:07.994]                     NULL
[10:33:07.994]                   }
[10:33:07.994]                   options(future.plan = NULL)
[10:33:07.994]                   if (is.na(NA_character_)) 
[10:33:07.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:07.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:07.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:07.994]                     .init = FALSE)
[10:33:07.994]                 }
[10:33:07.994]             }
[10:33:07.994]         }
[10:33:07.994]     })
[10:33:07.994]     if (TRUE) {
[10:33:07.994]         base::sink(type = "output", split = FALSE)
[10:33:07.994]         if (TRUE) {
[10:33:07.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:07.994]         }
[10:33:07.994]         else {
[10:33:07.994]             ...future.result["stdout"] <- base::list(NULL)
[10:33:07.994]         }
[10:33:07.994]         base::close(...future.stdout)
[10:33:07.994]         ...future.stdout <- NULL
[10:33:07.994]     }
[10:33:07.994]     ...future.result$conditions <- ...future.conditions
[10:33:07.994]     ...future.result$finished <- base::Sys.time()
[10:33:07.994]     ...future.result
[10:33:07.994] }
[10:33:07.997] assign_globals() ...
[10:33:07.997] List of 1
[10:33:07.997]  $ x: list()
[10:33:07.997]  - attr(*, "where")=List of 1
[10:33:07.997]   ..$ x:<environment: R_EmptyEnv> 
[10:33:07.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:07.997]  - attr(*, "resolved")= logi TRUE
[10:33:07.997]  - attr(*, "total_size")= num 0
[10:33:07.997]  - attr(*, "already-done")= logi TRUE
[10:33:08.000] - copied ‘x’ to environment
[10:33:08.000] assign_globals() ... done
[10:33:08.000] requestCore(): workers = 2
[10:33:08.002] MulticoreFuture started
[10:33:08.002] - Launch lazy future ... done
[10:33:08.002] run() for ‘MulticoreFuture’ ... done
[10:33:08.003] result() for MulticoreFuture ...
[10:33:08.003] plan(): Setting new future strategy stack:
[10:33:08.003] List of future strategies:
[10:33:08.003] 1. sequential:
[10:33:08.003]    - args: function (..., envir = parent.frame())
[10:33:08.003]    - tweaked: FALSE
[10:33:08.003]    - call: NULL
[10:33:08.004] plan(): nbrOfWorkers() = 1
[10:33:08.006] plan(): Setting new future strategy stack:
[10:33:08.006] List of future strategies:
[10:33:08.006] 1. multicore:
[10:33:08.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.006]    - tweaked: FALSE
[10:33:08.006]    - call: plan(strategy)
[10:33:08.011] plan(): nbrOfWorkers() = 2
[10:33:08.012] result() for MulticoreFuture ...
[10:33:08.012] result() for MulticoreFuture ... done
[10:33:08.012] result() for MulticoreFuture ... done
[10:33:08.013] result() for MulticoreFuture ...
[10:33:08.013] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.014] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.014] Searching for globals...
[10:33:08.017] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:08.017] Searching for globals ... DONE
[10:33:08.017] Resolving globals: TRUE
[10:33:08.017] Resolving any globals that are futures ...
[10:33:08.017] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:08.018] Resolving any globals that are futures ... DONE
[10:33:08.018] Resolving futures part of globals (recursively) ...
[10:33:08.018] resolve() on list ...
[10:33:08.019]  recursive: 99
[10:33:08.019]  length: 1
[10:33:08.019]  elements: ‘x’
[10:33:08.019]  length: 0 (resolved future 1)
[10:33:08.019] resolve() on list ... DONE
[10:33:08.019] - globals: [1] ‘x’
[10:33:08.019] Resolving futures part of globals (recursively) ... DONE
[10:33:08.019] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.020] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.020] - globals: [1] ‘x’
[10:33:08.020] 
[10:33:08.020] getGlobalsAndPackages() ... DONE
[10:33:08.021] run() for ‘Future’ ...
[10:33:08.021] - state: ‘created’
[10:33:08.021] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.025] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.025]   - Field: ‘label’
[10:33:08.025]   - Field: ‘local’
[10:33:08.025]   - Field: ‘owner’
[10:33:08.026]   - Field: ‘envir’
[10:33:08.026]   - Field: ‘workers’
[10:33:08.026]   - Field: ‘packages’
[10:33:08.026]   - Field: ‘gc’
[10:33:08.026]   - Field: ‘job’
[10:33:08.026]   - Field: ‘conditions’
[10:33:08.026]   - Field: ‘expr’
[10:33:08.026]   - Field: ‘uuid’
[10:33:08.026]   - Field: ‘seed’
[10:33:08.027]   - Field: ‘version’
[10:33:08.027]   - Field: ‘result’
[10:33:08.027]   - Field: ‘asynchronous’
[10:33:08.027]   - Field: ‘calls’
[10:33:08.027]   - Field: ‘globals’
[10:33:08.027]   - Field: ‘stdout’
[10:33:08.027]   - Field: ‘earlySignal’
[10:33:08.027]   - Field: ‘lazy’
[10:33:08.027]   - Field: ‘state’
[10:33:08.028] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.028] - Launch lazy future ...
[10:33:08.028] Packages needed by the future expression (n = 0): <none>
[10:33:08.028] Packages needed by future strategies (n = 0): <none>
[10:33:08.029] {
[10:33:08.029]     {
[10:33:08.029]         {
[10:33:08.029]             ...future.startTime <- base::Sys.time()
[10:33:08.029]             {
[10:33:08.029]                 {
[10:33:08.029]                   {
[10:33:08.029]                     {
[10:33:08.029]                       base::local({
[10:33:08.029]                         has_future <- base::requireNamespace("future", 
[10:33:08.029]                           quietly = TRUE)
[10:33:08.029]                         if (has_future) {
[10:33:08.029]                           ns <- base::getNamespace("future")
[10:33:08.029]                           version <- ns[[".package"]][["version"]]
[10:33:08.029]                           if (is.null(version)) 
[10:33:08.029]                             version <- utils::packageVersion("future")
[10:33:08.029]                         }
[10:33:08.029]                         else {
[10:33:08.029]                           version <- NULL
[10:33:08.029]                         }
[10:33:08.029]                         if (!has_future || version < "1.8.0") {
[10:33:08.029]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.029]                             "", base::R.version$version.string), 
[10:33:08.029]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.029]                               "release", "version")], collapse = " "), 
[10:33:08.029]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.029]                             info)
[10:33:08.029]                           info <- base::paste(info, collapse = "; ")
[10:33:08.029]                           if (!has_future) {
[10:33:08.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.029]                               info)
[10:33:08.029]                           }
[10:33:08.029]                           else {
[10:33:08.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.029]                               info, version)
[10:33:08.029]                           }
[10:33:08.029]                           base::stop(msg)
[10:33:08.029]                         }
[10:33:08.029]                       })
[10:33:08.029]                     }
[10:33:08.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.029]                     base::options(mc.cores = 1L)
[10:33:08.029]                   }
[10:33:08.029]                   ...future.strategy.old <- future::plan("list")
[10:33:08.029]                   options(future.plan = NULL)
[10:33:08.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.029]                 }
[10:33:08.029]                 ...future.workdir <- getwd()
[10:33:08.029]             }
[10:33:08.029]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.029]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.029]         }
[10:33:08.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.029]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.029]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.029]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.029]             base::names(...future.oldOptions))
[10:33:08.029]     }
[10:33:08.029]     if (FALSE) {
[10:33:08.029]     }
[10:33:08.029]     else {
[10:33:08.029]         if (TRUE) {
[10:33:08.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.029]                 open = "w")
[10:33:08.029]         }
[10:33:08.029]         else {
[10:33:08.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.029]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.029]         }
[10:33:08.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.029]             base::sink(type = "output", split = FALSE)
[10:33:08.029]             base::close(...future.stdout)
[10:33:08.029]         }, add = TRUE)
[10:33:08.029]     }
[10:33:08.029]     ...future.frame <- base::sys.nframe()
[10:33:08.029]     ...future.conditions <- base::list()
[10:33:08.029]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.029]     if (FALSE) {
[10:33:08.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.029]     }
[10:33:08.029]     ...future.result <- base::tryCatch({
[10:33:08.029]         base::withCallingHandlers({
[10:33:08.029]             ...future.value <- base::withVisible(base::local({
[10:33:08.029]                 withCallingHandlers({
[10:33:08.029]                   {
[10:33:08.029]                     x$a <- 1
[10:33:08.029]                     x
[10:33:08.029]                   }
[10:33:08.029]                 }, immediateCondition = function(cond) {
[10:33:08.029]                   save_rds <- function (object, pathname, ...) 
[10:33:08.029]                   {
[10:33:08.029]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.029]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.029]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.029]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.029]                         fi_tmp[["mtime"]])
[10:33:08.029]                     }
[10:33:08.029]                     tryCatch({
[10:33:08.029]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.029]                     }, error = function(ex) {
[10:33:08.029]                       msg <- conditionMessage(ex)
[10:33:08.029]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.029]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.029]                         fi_tmp[["mtime"]], msg)
[10:33:08.029]                       ex$message <- msg
[10:33:08.029]                       stop(ex)
[10:33:08.029]                     })
[10:33:08.029]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.029]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.029]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.029]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.029]                       fi <- file.info(pathname)
[10:33:08.029]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.029]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.029]                         fi[["size"]], fi[["mtime"]])
[10:33:08.029]                       stop(msg)
[10:33:08.029]                     }
[10:33:08.029]                     invisible(pathname)
[10:33:08.029]                   }
[10:33:08.029]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.029]                     rootPath = tempdir()) 
[10:33:08.029]                   {
[10:33:08.029]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.029]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.029]                       tmpdir = path, fileext = ".rds")
[10:33:08.029]                     save_rds(obj, file)
[10:33:08.029]                   }
[10:33:08.029]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.029]                   {
[10:33:08.029]                     inherits <- base::inherits
[10:33:08.029]                     invokeRestart <- base::invokeRestart
[10:33:08.029]                     is.null <- base::is.null
[10:33:08.029]                     muffled <- FALSE
[10:33:08.029]                     if (inherits(cond, "message")) {
[10:33:08.029]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.029]                       if (muffled) 
[10:33:08.029]                         invokeRestart("muffleMessage")
[10:33:08.029]                     }
[10:33:08.029]                     else if (inherits(cond, "warning")) {
[10:33:08.029]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.029]                       if (muffled) 
[10:33:08.029]                         invokeRestart("muffleWarning")
[10:33:08.029]                     }
[10:33:08.029]                     else if (inherits(cond, "condition")) {
[10:33:08.029]                       if (!is.null(pattern)) {
[10:33:08.029]                         computeRestarts <- base::computeRestarts
[10:33:08.029]                         grepl <- base::grepl
[10:33:08.029]                         restarts <- computeRestarts(cond)
[10:33:08.029]                         for (restart in restarts) {
[10:33:08.029]                           name <- restart$name
[10:33:08.029]                           if (is.null(name)) 
[10:33:08.029]                             next
[10:33:08.029]                           if (!grepl(pattern, name)) 
[10:33:08.029]                             next
[10:33:08.029]                           invokeRestart(restart)
[10:33:08.029]                           muffled <- TRUE
[10:33:08.029]                           break
[10:33:08.029]                         }
[10:33:08.029]                       }
[10:33:08.029]                     }
[10:33:08.029]                     invisible(muffled)
[10:33:08.029]                   }
[10:33:08.029]                   muffleCondition(cond)
[10:33:08.029]                 })
[10:33:08.029]             }))
[10:33:08.029]             future::FutureResult(value = ...future.value$value, 
[10:33:08.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.029]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.029]                     ...future.globalenv.names))
[10:33:08.029]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.029]         }, condition = base::local({
[10:33:08.029]             c <- base::c
[10:33:08.029]             inherits <- base::inherits
[10:33:08.029]             invokeRestart <- base::invokeRestart
[10:33:08.029]             length <- base::length
[10:33:08.029]             list <- base::list
[10:33:08.029]             seq.int <- base::seq.int
[10:33:08.029]             signalCondition <- base::signalCondition
[10:33:08.029]             sys.calls <- base::sys.calls
[10:33:08.029]             `[[` <- base::`[[`
[10:33:08.029]             `+` <- base::`+`
[10:33:08.029]             `<<-` <- base::`<<-`
[10:33:08.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.029]                   3L)]
[10:33:08.029]             }
[10:33:08.029]             function(cond) {
[10:33:08.029]                 is_error <- inherits(cond, "error")
[10:33:08.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.029]                   NULL)
[10:33:08.029]                 if (is_error) {
[10:33:08.029]                   sessionInformation <- function() {
[10:33:08.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.029]                       search = base::search(), system = base::Sys.info())
[10:33:08.029]                   }
[10:33:08.029]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.029]                     cond$call), session = sessionInformation(), 
[10:33:08.029]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.029]                   signalCondition(cond)
[10:33:08.029]                 }
[10:33:08.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.029]                 "immediateCondition"))) {
[10:33:08.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.029]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.029]                   if (TRUE && !signal) {
[10:33:08.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.029]                     {
[10:33:08.029]                       inherits <- base::inherits
[10:33:08.029]                       invokeRestart <- base::invokeRestart
[10:33:08.029]                       is.null <- base::is.null
[10:33:08.029]                       muffled <- FALSE
[10:33:08.029]                       if (inherits(cond, "message")) {
[10:33:08.029]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.029]                         if (muffled) 
[10:33:08.029]                           invokeRestart("muffleMessage")
[10:33:08.029]                       }
[10:33:08.029]                       else if (inherits(cond, "warning")) {
[10:33:08.029]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.029]                         if (muffled) 
[10:33:08.029]                           invokeRestart("muffleWarning")
[10:33:08.029]                       }
[10:33:08.029]                       else if (inherits(cond, "condition")) {
[10:33:08.029]                         if (!is.null(pattern)) {
[10:33:08.029]                           computeRestarts <- base::computeRestarts
[10:33:08.029]                           grepl <- base::grepl
[10:33:08.029]                           restarts <- computeRestarts(cond)
[10:33:08.029]                           for (restart in restarts) {
[10:33:08.029]                             name <- restart$name
[10:33:08.029]                             if (is.null(name)) 
[10:33:08.029]                               next
[10:33:08.029]                             if (!grepl(pattern, name)) 
[10:33:08.029]                               next
[10:33:08.029]                             invokeRestart(restart)
[10:33:08.029]                             muffled <- TRUE
[10:33:08.029]                             break
[10:33:08.029]                           }
[10:33:08.029]                         }
[10:33:08.029]                       }
[10:33:08.029]                       invisible(muffled)
[10:33:08.029]                     }
[10:33:08.029]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.029]                   }
[10:33:08.029]                 }
[10:33:08.029]                 else {
[10:33:08.029]                   if (TRUE) {
[10:33:08.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.029]                     {
[10:33:08.029]                       inherits <- base::inherits
[10:33:08.029]                       invokeRestart <- base::invokeRestart
[10:33:08.029]                       is.null <- base::is.null
[10:33:08.029]                       muffled <- FALSE
[10:33:08.029]                       if (inherits(cond, "message")) {
[10:33:08.029]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.029]                         if (muffled) 
[10:33:08.029]                           invokeRestart("muffleMessage")
[10:33:08.029]                       }
[10:33:08.029]                       else if (inherits(cond, "warning")) {
[10:33:08.029]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.029]                         if (muffled) 
[10:33:08.029]                           invokeRestart("muffleWarning")
[10:33:08.029]                       }
[10:33:08.029]                       else if (inherits(cond, "condition")) {
[10:33:08.029]                         if (!is.null(pattern)) {
[10:33:08.029]                           computeRestarts <- base::computeRestarts
[10:33:08.029]                           grepl <- base::grepl
[10:33:08.029]                           restarts <- computeRestarts(cond)
[10:33:08.029]                           for (restart in restarts) {
[10:33:08.029]                             name <- restart$name
[10:33:08.029]                             if (is.null(name)) 
[10:33:08.029]                               next
[10:33:08.029]                             if (!grepl(pattern, name)) 
[10:33:08.029]                               next
[10:33:08.029]                             invokeRestart(restart)
[10:33:08.029]                             muffled <- TRUE
[10:33:08.029]                             break
[10:33:08.029]                           }
[10:33:08.029]                         }
[10:33:08.029]                       }
[10:33:08.029]                       invisible(muffled)
[10:33:08.029]                     }
[10:33:08.029]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.029]                   }
[10:33:08.029]                 }
[10:33:08.029]             }
[10:33:08.029]         }))
[10:33:08.029]     }, error = function(ex) {
[10:33:08.029]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.029]                 ...future.rng), started = ...future.startTime, 
[10:33:08.029]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.029]             version = "1.8"), class = "FutureResult")
[10:33:08.029]     }, finally = {
[10:33:08.029]         if (!identical(...future.workdir, getwd())) 
[10:33:08.029]             setwd(...future.workdir)
[10:33:08.029]         {
[10:33:08.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.029]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.029]             }
[10:33:08.029]             base::options(...future.oldOptions)
[10:33:08.029]             if (.Platform$OS.type == "windows") {
[10:33:08.029]                 old_names <- names(...future.oldEnvVars)
[10:33:08.029]                 envs <- base::Sys.getenv()
[10:33:08.029]                 names <- names(envs)
[10:33:08.029]                 common <- intersect(names, old_names)
[10:33:08.029]                 added <- setdiff(names, old_names)
[10:33:08.029]                 removed <- setdiff(old_names, names)
[10:33:08.029]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.029]                   envs[common]]
[10:33:08.029]                 NAMES <- toupper(changed)
[10:33:08.029]                 args <- list()
[10:33:08.029]                 for (kk in seq_along(NAMES)) {
[10:33:08.029]                   name <- changed[[kk]]
[10:33:08.029]                   NAME <- NAMES[[kk]]
[10:33:08.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.029]                     next
[10:33:08.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.029]                 }
[10:33:08.029]                 NAMES <- toupper(added)
[10:33:08.029]                 for (kk in seq_along(NAMES)) {
[10:33:08.029]                   name <- added[[kk]]
[10:33:08.029]                   NAME <- NAMES[[kk]]
[10:33:08.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.029]                     next
[10:33:08.029]                   args[[name]] <- ""
[10:33:08.029]                 }
[10:33:08.029]                 NAMES <- toupper(removed)
[10:33:08.029]                 for (kk in seq_along(NAMES)) {
[10:33:08.029]                   name <- removed[[kk]]
[10:33:08.029]                   NAME <- NAMES[[kk]]
[10:33:08.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.029]                     next
[10:33:08.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.029]                 }
[10:33:08.029]                 if (length(args) > 0) 
[10:33:08.029]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.029]             }
[10:33:08.029]             else {
[10:33:08.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.029]             }
[10:33:08.029]             {
[10:33:08.029]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.029]                   0L) {
[10:33:08.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.029]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.029]                   base::options(opts)
[10:33:08.029]                 }
[10:33:08.029]                 {
[10:33:08.029]                   {
[10:33:08.029]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.029]                     NULL
[10:33:08.029]                   }
[10:33:08.029]                   options(future.plan = NULL)
[10:33:08.029]                   if (is.na(NA_character_)) 
[10:33:08.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.029]                     .init = FALSE)
[10:33:08.029]                 }
[10:33:08.029]             }
[10:33:08.029]         }
[10:33:08.029]     })
[10:33:08.029]     if (TRUE) {
[10:33:08.029]         base::sink(type = "output", split = FALSE)
[10:33:08.029]         if (TRUE) {
[10:33:08.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.029]         }
[10:33:08.029]         else {
[10:33:08.029]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.029]         }
[10:33:08.029]         base::close(...future.stdout)
[10:33:08.029]         ...future.stdout <- NULL
[10:33:08.029]     }
[10:33:08.029]     ...future.result$conditions <- ...future.conditions
[10:33:08.029]     ...future.result$finished <- base::Sys.time()
[10:33:08.029]     ...future.result
[10:33:08.029] }
[10:33:08.031] assign_globals() ...
[10:33:08.031] List of 1
[10:33:08.031]  $ x: list()
[10:33:08.031]  - attr(*, "where")=List of 1
[10:33:08.031]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.031]  - attr(*, "resolved")= logi TRUE
[10:33:08.031]  - attr(*, "total_size")= num 0
[10:33:08.031]  - attr(*, "already-done")= logi TRUE
[10:33:08.034] - copied ‘x’ to environment
[10:33:08.034] assign_globals() ... done
[10:33:08.035] requestCore(): workers = 2
[10:33:08.036] MulticoreFuture started
[10:33:08.037] - Launch lazy future ... done
[10:33:08.037] run() for ‘MulticoreFuture’ ... done
[10:33:08.037] result() for MulticoreFuture ...
[10:33:08.038] plan(): Setting new future strategy stack:
[10:33:08.038] List of future strategies:
[10:33:08.038] 1. sequential:
[10:33:08.038]    - args: function (..., envir = parent.frame())
[10:33:08.038]    - tweaked: FALSE
[10:33:08.038]    - call: NULL
[10:33:08.039] plan(): nbrOfWorkers() = 1
[10:33:08.045] plan(): Setting new future strategy stack:
[10:33:08.045] List of future strategies:
[10:33:08.045] 1. multicore:
[10:33:08.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.045]    - tweaked: FALSE
[10:33:08.045]    - call: plan(strategy)
[10:33:08.051] plan(): nbrOfWorkers() = 2
[10:33:08.052] result() for MulticoreFuture ...
[10:33:08.055] result() for MulticoreFuture ... done
[10:33:08.056] result() for MulticoreFuture ... done
[10:33:08.056] result() for MulticoreFuture ...
[10:33:08.056] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.057] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.057] Searching for globals...
[10:33:08.060] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:08.060] Searching for globals ... DONE
[10:33:08.060] Resolving globals: TRUE
[10:33:08.060] Resolving any globals that are futures ...
[10:33:08.061] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:08.061] Resolving any globals that are futures ... DONE
[10:33:08.061] Resolving futures part of globals (recursively) ...
[10:33:08.062] resolve() on list ...
[10:33:08.062]  recursive: 99
[10:33:08.062]  length: 1
[10:33:08.062]  elements: ‘x’
[10:33:08.062]  length: 0 (resolved future 1)
[10:33:08.062] resolve() on list ... DONE
[10:33:08.062] - globals: [1] ‘x’
[10:33:08.062] Resolving futures part of globals (recursively) ... DONE
[10:33:08.063] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.063] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.063] - globals: [1] ‘x’
[10:33:08.063] 
[10:33:08.063] getGlobalsAndPackages() ... DONE
[10:33:08.064] run() for ‘Future’ ...
[10:33:08.064] - state: ‘created’
[10:33:08.064] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.068] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.069]   - Field: ‘label’
[10:33:08.069]   - Field: ‘local’
[10:33:08.069]   - Field: ‘owner’
[10:33:08.069]   - Field: ‘envir’
[10:33:08.069]   - Field: ‘workers’
[10:33:08.069]   - Field: ‘packages’
[10:33:08.069]   - Field: ‘gc’
[10:33:08.069]   - Field: ‘job’
[10:33:08.070]   - Field: ‘conditions’
[10:33:08.070]   - Field: ‘expr’
[10:33:08.070]   - Field: ‘uuid’
[10:33:08.070]   - Field: ‘seed’
[10:33:08.070]   - Field: ‘version’
[10:33:08.070]   - Field: ‘result’
[10:33:08.070]   - Field: ‘asynchronous’
[10:33:08.070]   - Field: ‘calls’
[10:33:08.070]   - Field: ‘globals’
[10:33:08.071]   - Field: ‘stdout’
[10:33:08.071]   - Field: ‘earlySignal’
[10:33:08.071]   - Field: ‘lazy’
[10:33:08.071]   - Field: ‘state’
[10:33:08.071] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.071] - Launch lazy future ...
[10:33:08.071] Packages needed by the future expression (n = 0): <none>
[10:33:08.072] Packages needed by future strategies (n = 0): <none>
[10:33:08.072] {
[10:33:08.072]     {
[10:33:08.072]         {
[10:33:08.072]             ...future.startTime <- base::Sys.time()
[10:33:08.072]             {
[10:33:08.072]                 {
[10:33:08.072]                   {
[10:33:08.072]                     {
[10:33:08.072]                       base::local({
[10:33:08.072]                         has_future <- base::requireNamespace("future", 
[10:33:08.072]                           quietly = TRUE)
[10:33:08.072]                         if (has_future) {
[10:33:08.072]                           ns <- base::getNamespace("future")
[10:33:08.072]                           version <- ns[[".package"]][["version"]]
[10:33:08.072]                           if (is.null(version)) 
[10:33:08.072]                             version <- utils::packageVersion("future")
[10:33:08.072]                         }
[10:33:08.072]                         else {
[10:33:08.072]                           version <- NULL
[10:33:08.072]                         }
[10:33:08.072]                         if (!has_future || version < "1.8.0") {
[10:33:08.072]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.072]                             "", base::R.version$version.string), 
[10:33:08.072]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.072]                               "release", "version")], collapse = " "), 
[10:33:08.072]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.072]                             info)
[10:33:08.072]                           info <- base::paste(info, collapse = "; ")
[10:33:08.072]                           if (!has_future) {
[10:33:08.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.072]                               info)
[10:33:08.072]                           }
[10:33:08.072]                           else {
[10:33:08.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.072]                               info, version)
[10:33:08.072]                           }
[10:33:08.072]                           base::stop(msg)
[10:33:08.072]                         }
[10:33:08.072]                       })
[10:33:08.072]                     }
[10:33:08.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.072]                     base::options(mc.cores = 1L)
[10:33:08.072]                   }
[10:33:08.072]                   ...future.strategy.old <- future::plan("list")
[10:33:08.072]                   options(future.plan = NULL)
[10:33:08.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.072]                 }
[10:33:08.072]                 ...future.workdir <- getwd()
[10:33:08.072]             }
[10:33:08.072]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.072]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.072]         }
[10:33:08.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.072]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.072]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.072]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.072]             base::names(...future.oldOptions))
[10:33:08.072]     }
[10:33:08.072]     if (FALSE) {
[10:33:08.072]     }
[10:33:08.072]     else {
[10:33:08.072]         if (TRUE) {
[10:33:08.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.072]                 open = "w")
[10:33:08.072]         }
[10:33:08.072]         else {
[10:33:08.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.072]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.072]         }
[10:33:08.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.072]             base::sink(type = "output", split = FALSE)
[10:33:08.072]             base::close(...future.stdout)
[10:33:08.072]         }, add = TRUE)
[10:33:08.072]     }
[10:33:08.072]     ...future.frame <- base::sys.nframe()
[10:33:08.072]     ...future.conditions <- base::list()
[10:33:08.072]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.072]     if (FALSE) {
[10:33:08.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.072]     }
[10:33:08.072]     ...future.result <- base::tryCatch({
[10:33:08.072]         base::withCallingHandlers({
[10:33:08.072]             ...future.value <- base::withVisible(base::local({
[10:33:08.072]                 withCallingHandlers({
[10:33:08.072]                   {
[10:33:08.072]                     x$a <- 1
[10:33:08.072]                     x
[10:33:08.072]                   }
[10:33:08.072]                 }, immediateCondition = function(cond) {
[10:33:08.072]                   save_rds <- function (object, pathname, ...) 
[10:33:08.072]                   {
[10:33:08.072]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.072]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.072]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.072]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.072]                         fi_tmp[["mtime"]])
[10:33:08.072]                     }
[10:33:08.072]                     tryCatch({
[10:33:08.072]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.072]                     }, error = function(ex) {
[10:33:08.072]                       msg <- conditionMessage(ex)
[10:33:08.072]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.072]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.072]                         fi_tmp[["mtime"]], msg)
[10:33:08.072]                       ex$message <- msg
[10:33:08.072]                       stop(ex)
[10:33:08.072]                     })
[10:33:08.072]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.072]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.072]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.072]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.072]                       fi <- file.info(pathname)
[10:33:08.072]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.072]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.072]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.072]                         fi[["size"]], fi[["mtime"]])
[10:33:08.072]                       stop(msg)
[10:33:08.072]                     }
[10:33:08.072]                     invisible(pathname)
[10:33:08.072]                   }
[10:33:08.072]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.072]                     rootPath = tempdir()) 
[10:33:08.072]                   {
[10:33:08.072]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.072]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.072]                       tmpdir = path, fileext = ".rds")
[10:33:08.072]                     save_rds(obj, file)
[10:33:08.072]                   }
[10:33:08.072]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.072]                   {
[10:33:08.072]                     inherits <- base::inherits
[10:33:08.072]                     invokeRestart <- base::invokeRestart
[10:33:08.072]                     is.null <- base::is.null
[10:33:08.072]                     muffled <- FALSE
[10:33:08.072]                     if (inherits(cond, "message")) {
[10:33:08.072]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.072]                       if (muffled) 
[10:33:08.072]                         invokeRestart("muffleMessage")
[10:33:08.072]                     }
[10:33:08.072]                     else if (inherits(cond, "warning")) {
[10:33:08.072]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.072]                       if (muffled) 
[10:33:08.072]                         invokeRestart("muffleWarning")
[10:33:08.072]                     }
[10:33:08.072]                     else if (inherits(cond, "condition")) {
[10:33:08.072]                       if (!is.null(pattern)) {
[10:33:08.072]                         computeRestarts <- base::computeRestarts
[10:33:08.072]                         grepl <- base::grepl
[10:33:08.072]                         restarts <- computeRestarts(cond)
[10:33:08.072]                         for (restart in restarts) {
[10:33:08.072]                           name <- restart$name
[10:33:08.072]                           if (is.null(name)) 
[10:33:08.072]                             next
[10:33:08.072]                           if (!grepl(pattern, name)) 
[10:33:08.072]                             next
[10:33:08.072]                           invokeRestart(restart)
[10:33:08.072]                           muffled <- TRUE
[10:33:08.072]                           break
[10:33:08.072]                         }
[10:33:08.072]                       }
[10:33:08.072]                     }
[10:33:08.072]                     invisible(muffled)
[10:33:08.072]                   }
[10:33:08.072]                   muffleCondition(cond)
[10:33:08.072]                 })
[10:33:08.072]             }))
[10:33:08.072]             future::FutureResult(value = ...future.value$value, 
[10:33:08.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.072]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.072]                     ...future.globalenv.names))
[10:33:08.072]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.072]         }, condition = base::local({
[10:33:08.072]             c <- base::c
[10:33:08.072]             inherits <- base::inherits
[10:33:08.072]             invokeRestart <- base::invokeRestart
[10:33:08.072]             length <- base::length
[10:33:08.072]             list <- base::list
[10:33:08.072]             seq.int <- base::seq.int
[10:33:08.072]             signalCondition <- base::signalCondition
[10:33:08.072]             sys.calls <- base::sys.calls
[10:33:08.072]             `[[` <- base::`[[`
[10:33:08.072]             `+` <- base::`+`
[10:33:08.072]             `<<-` <- base::`<<-`
[10:33:08.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.072]                   3L)]
[10:33:08.072]             }
[10:33:08.072]             function(cond) {
[10:33:08.072]                 is_error <- inherits(cond, "error")
[10:33:08.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.072]                   NULL)
[10:33:08.072]                 if (is_error) {
[10:33:08.072]                   sessionInformation <- function() {
[10:33:08.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.072]                       search = base::search(), system = base::Sys.info())
[10:33:08.072]                   }
[10:33:08.072]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.072]                     cond$call), session = sessionInformation(), 
[10:33:08.072]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.072]                   signalCondition(cond)
[10:33:08.072]                 }
[10:33:08.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.072]                 "immediateCondition"))) {
[10:33:08.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.072]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.072]                   if (TRUE && !signal) {
[10:33:08.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.072]                     {
[10:33:08.072]                       inherits <- base::inherits
[10:33:08.072]                       invokeRestart <- base::invokeRestart
[10:33:08.072]                       is.null <- base::is.null
[10:33:08.072]                       muffled <- FALSE
[10:33:08.072]                       if (inherits(cond, "message")) {
[10:33:08.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.072]                         if (muffled) 
[10:33:08.072]                           invokeRestart("muffleMessage")
[10:33:08.072]                       }
[10:33:08.072]                       else if (inherits(cond, "warning")) {
[10:33:08.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.072]                         if (muffled) 
[10:33:08.072]                           invokeRestart("muffleWarning")
[10:33:08.072]                       }
[10:33:08.072]                       else if (inherits(cond, "condition")) {
[10:33:08.072]                         if (!is.null(pattern)) {
[10:33:08.072]                           computeRestarts <- base::computeRestarts
[10:33:08.072]                           grepl <- base::grepl
[10:33:08.072]                           restarts <- computeRestarts(cond)
[10:33:08.072]                           for (restart in restarts) {
[10:33:08.072]                             name <- restart$name
[10:33:08.072]                             if (is.null(name)) 
[10:33:08.072]                               next
[10:33:08.072]                             if (!grepl(pattern, name)) 
[10:33:08.072]                               next
[10:33:08.072]                             invokeRestart(restart)
[10:33:08.072]                             muffled <- TRUE
[10:33:08.072]                             break
[10:33:08.072]                           }
[10:33:08.072]                         }
[10:33:08.072]                       }
[10:33:08.072]                       invisible(muffled)
[10:33:08.072]                     }
[10:33:08.072]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.072]                   }
[10:33:08.072]                 }
[10:33:08.072]                 else {
[10:33:08.072]                   if (TRUE) {
[10:33:08.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.072]                     {
[10:33:08.072]                       inherits <- base::inherits
[10:33:08.072]                       invokeRestart <- base::invokeRestart
[10:33:08.072]                       is.null <- base::is.null
[10:33:08.072]                       muffled <- FALSE
[10:33:08.072]                       if (inherits(cond, "message")) {
[10:33:08.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.072]                         if (muffled) 
[10:33:08.072]                           invokeRestart("muffleMessage")
[10:33:08.072]                       }
[10:33:08.072]                       else if (inherits(cond, "warning")) {
[10:33:08.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.072]                         if (muffled) 
[10:33:08.072]                           invokeRestart("muffleWarning")
[10:33:08.072]                       }
[10:33:08.072]                       else if (inherits(cond, "condition")) {
[10:33:08.072]                         if (!is.null(pattern)) {
[10:33:08.072]                           computeRestarts <- base::computeRestarts
[10:33:08.072]                           grepl <- base::grepl
[10:33:08.072]                           restarts <- computeRestarts(cond)
[10:33:08.072]                           for (restart in restarts) {
[10:33:08.072]                             name <- restart$name
[10:33:08.072]                             if (is.null(name)) 
[10:33:08.072]                               next
[10:33:08.072]                             if (!grepl(pattern, name)) 
[10:33:08.072]                               next
[10:33:08.072]                             invokeRestart(restart)
[10:33:08.072]                             muffled <- TRUE
[10:33:08.072]                             break
[10:33:08.072]                           }
[10:33:08.072]                         }
[10:33:08.072]                       }
[10:33:08.072]                       invisible(muffled)
[10:33:08.072]                     }
[10:33:08.072]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.072]                   }
[10:33:08.072]                 }
[10:33:08.072]             }
[10:33:08.072]         }))
[10:33:08.072]     }, error = function(ex) {
[10:33:08.072]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.072]                 ...future.rng), started = ...future.startTime, 
[10:33:08.072]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.072]             version = "1.8"), class = "FutureResult")
[10:33:08.072]     }, finally = {
[10:33:08.072]         if (!identical(...future.workdir, getwd())) 
[10:33:08.072]             setwd(...future.workdir)
[10:33:08.072]         {
[10:33:08.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.072]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.072]             }
[10:33:08.072]             base::options(...future.oldOptions)
[10:33:08.072]             if (.Platform$OS.type == "windows") {
[10:33:08.072]                 old_names <- names(...future.oldEnvVars)
[10:33:08.072]                 envs <- base::Sys.getenv()
[10:33:08.072]                 names <- names(envs)
[10:33:08.072]                 common <- intersect(names, old_names)
[10:33:08.072]                 added <- setdiff(names, old_names)
[10:33:08.072]                 removed <- setdiff(old_names, names)
[10:33:08.072]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.072]                   envs[common]]
[10:33:08.072]                 NAMES <- toupper(changed)
[10:33:08.072]                 args <- list()
[10:33:08.072]                 for (kk in seq_along(NAMES)) {
[10:33:08.072]                   name <- changed[[kk]]
[10:33:08.072]                   NAME <- NAMES[[kk]]
[10:33:08.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.072]                     next
[10:33:08.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.072]                 }
[10:33:08.072]                 NAMES <- toupper(added)
[10:33:08.072]                 for (kk in seq_along(NAMES)) {
[10:33:08.072]                   name <- added[[kk]]
[10:33:08.072]                   NAME <- NAMES[[kk]]
[10:33:08.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.072]                     next
[10:33:08.072]                   args[[name]] <- ""
[10:33:08.072]                 }
[10:33:08.072]                 NAMES <- toupper(removed)
[10:33:08.072]                 for (kk in seq_along(NAMES)) {
[10:33:08.072]                   name <- removed[[kk]]
[10:33:08.072]                   NAME <- NAMES[[kk]]
[10:33:08.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.072]                     next
[10:33:08.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.072]                 }
[10:33:08.072]                 if (length(args) > 0) 
[10:33:08.072]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.072]             }
[10:33:08.072]             else {
[10:33:08.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.072]             }
[10:33:08.072]             {
[10:33:08.072]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.072]                   0L) {
[10:33:08.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.072]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.072]                   base::options(opts)
[10:33:08.072]                 }
[10:33:08.072]                 {
[10:33:08.072]                   {
[10:33:08.072]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.072]                     NULL
[10:33:08.072]                   }
[10:33:08.072]                   options(future.plan = NULL)
[10:33:08.072]                   if (is.na(NA_character_)) 
[10:33:08.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.072]                     .init = FALSE)
[10:33:08.072]                 }
[10:33:08.072]             }
[10:33:08.072]         }
[10:33:08.072]     })
[10:33:08.072]     if (TRUE) {
[10:33:08.072]         base::sink(type = "output", split = FALSE)
[10:33:08.072]         if (TRUE) {
[10:33:08.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.072]         }
[10:33:08.072]         else {
[10:33:08.072]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.072]         }
[10:33:08.072]         base::close(...future.stdout)
[10:33:08.072]         ...future.stdout <- NULL
[10:33:08.072]     }
[10:33:08.072]     ...future.result$conditions <- ...future.conditions
[10:33:08.072]     ...future.result$finished <- base::Sys.time()
[10:33:08.072]     ...future.result
[10:33:08.072] }
[10:33:08.075] assign_globals() ...
[10:33:08.075] List of 1
[10:33:08.075]  $ x: list()
[10:33:08.075]  - attr(*, "where")=List of 1
[10:33:08.075]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.075]  - attr(*, "resolved")= logi TRUE
[10:33:08.075]  - attr(*, "total_size")= num 0
[10:33:08.075]  - attr(*, "already-done")= logi TRUE
[10:33:08.078] - copied ‘x’ to environment
[10:33:08.078] assign_globals() ... done
[10:33:08.078] requestCore(): workers = 2
[10:33:08.080] MulticoreFuture started
[10:33:08.080] - Launch lazy future ... done
[10:33:08.081] run() for ‘MulticoreFuture’ ... done
[10:33:08.081] result() for MulticoreFuture ...
[10:33:08.081] plan(): Setting new future strategy stack:
[10:33:08.082] List of future strategies:
[10:33:08.082] 1. sequential:
[10:33:08.082]    - args: function (..., envir = parent.frame())
[10:33:08.082]    - tweaked: FALSE
[10:33:08.082]    - call: NULL
[10:33:08.083] plan(): nbrOfWorkers() = 1
[10:33:08.085] plan(): Setting new future strategy stack:
[10:33:08.085] List of future strategies:
[10:33:08.085] 1. multicore:
[10:33:08.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.085]    - tweaked: FALSE
[10:33:08.085]    - call: plan(strategy)
[10:33:08.090] plan(): nbrOfWorkers() = 2
[10:33:08.091] result() for MulticoreFuture ...
[10:33:08.091] result() for MulticoreFuture ... done
[10:33:08.091] result() for MulticoreFuture ... done
[10:33:08.091] result() for MulticoreFuture ...
[10:33:08.091] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.092] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.092] Searching for globals...
[10:33:08.096] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:33:08.096] Searching for globals ... DONE
[10:33:08.096] Resolving globals: TRUE
[10:33:08.096] Resolving any globals that are futures ...
[10:33:08.096] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:33:08.096] Resolving any globals that are futures ... DONE
[10:33:08.097] 
[10:33:08.097] 
[10:33:08.097] getGlobalsAndPackages() ... DONE
[10:33:08.097] run() for ‘Future’ ...
[10:33:08.098] - state: ‘created’
[10:33:08.098] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.102] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.102]   - Field: ‘label’
[10:33:08.102]   - Field: ‘local’
[10:33:08.103]   - Field: ‘owner’
[10:33:08.103]   - Field: ‘envir’
[10:33:08.103]   - Field: ‘workers’
[10:33:08.105]   - Field: ‘packages’
[10:33:08.105]   - Field: ‘gc’
[10:33:08.106]   - Field: ‘job’
[10:33:08.106]   - Field: ‘conditions’
[10:33:08.106]   - Field: ‘expr’
[10:33:08.106]   - Field: ‘uuid’
[10:33:08.106]   - Field: ‘seed’
[10:33:08.106]   - Field: ‘version’
[10:33:08.107]   - Field: ‘result’
[10:33:08.107]   - Field: ‘asynchronous’
[10:33:08.107]   - Field: ‘calls’
[10:33:08.107]   - Field: ‘globals’
[10:33:08.107]   - Field: ‘stdout’
[10:33:08.107]   - Field: ‘earlySignal’
[10:33:08.107]   - Field: ‘lazy’
[10:33:08.107]   - Field: ‘state’
[10:33:08.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.108] - Launch lazy future ...
[10:33:08.108] Packages needed by the future expression (n = 0): <none>
[10:33:08.108] Packages needed by future strategies (n = 0): <none>
[10:33:08.109] {
[10:33:08.109]     {
[10:33:08.109]         {
[10:33:08.109]             ...future.startTime <- base::Sys.time()
[10:33:08.109]             {
[10:33:08.109]                 {
[10:33:08.109]                   {
[10:33:08.109]                     {
[10:33:08.109]                       base::local({
[10:33:08.109]                         has_future <- base::requireNamespace("future", 
[10:33:08.109]                           quietly = TRUE)
[10:33:08.109]                         if (has_future) {
[10:33:08.109]                           ns <- base::getNamespace("future")
[10:33:08.109]                           version <- ns[[".package"]][["version"]]
[10:33:08.109]                           if (is.null(version)) 
[10:33:08.109]                             version <- utils::packageVersion("future")
[10:33:08.109]                         }
[10:33:08.109]                         else {
[10:33:08.109]                           version <- NULL
[10:33:08.109]                         }
[10:33:08.109]                         if (!has_future || version < "1.8.0") {
[10:33:08.109]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.109]                             "", base::R.version$version.string), 
[10:33:08.109]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.109]                               "release", "version")], collapse = " "), 
[10:33:08.109]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.109]                             info)
[10:33:08.109]                           info <- base::paste(info, collapse = "; ")
[10:33:08.109]                           if (!has_future) {
[10:33:08.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.109]                               info)
[10:33:08.109]                           }
[10:33:08.109]                           else {
[10:33:08.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.109]                               info, version)
[10:33:08.109]                           }
[10:33:08.109]                           base::stop(msg)
[10:33:08.109]                         }
[10:33:08.109]                       })
[10:33:08.109]                     }
[10:33:08.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.109]                     base::options(mc.cores = 1L)
[10:33:08.109]                   }
[10:33:08.109]                   ...future.strategy.old <- future::plan("list")
[10:33:08.109]                   options(future.plan = NULL)
[10:33:08.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.109]                 }
[10:33:08.109]                 ...future.workdir <- getwd()
[10:33:08.109]             }
[10:33:08.109]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.109]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.109]         }
[10:33:08.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.109]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.109]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.109]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.109]             base::names(...future.oldOptions))
[10:33:08.109]     }
[10:33:08.109]     if (FALSE) {
[10:33:08.109]     }
[10:33:08.109]     else {
[10:33:08.109]         if (TRUE) {
[10:33:08.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.109]                 open = "w")
[10:33:08.109]         }
[10:33:08.109]         else {
[10:33:08.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.109]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.109]         }
[10:33:08.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.109]             base::sink(type = "output", split = FALSE)
[10:33:08.109]             base::close(...future.stdout)
[10:33:08.109]         }, add = TRUE)
[10:33:08.109]     }
[10:33:08.109]     ...future.frame <- base::sys.nframe()
[10:33:08.109]     ...future.conditions <- base::list()
[10:33:08.109]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.109]     if (FALSE) {
[10:33:08.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.109]     }
[10:33:08.109]     ...future.result <- base::tryCatch({
[10:33:08.109]         base::withCallingHandlers({
[10:33:08.109]             ...future.value <- base::withVisible(base::local({
[10:33:08.109]                 withCallingHandlers({
[10:33:08.109]                   {
[10:33:08.109]                     x <- list(b = 2)
[10:33:08.109]                     x$a <- 1
[10:33:08.109]                     x
[10:33:08.109]                   }
[10:33:08.109]                 }, immediateCondition = function(cond) {
[10:33:08.109]                   save_rds <- function (object, pathname, ...) 
[10:33:08.109]                   {
[10:33:08.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.109]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.109]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.109]                         fi_tmp[["mtime"]])
[10:33:08.109]                     }
[10:33:08.109]                     tryCatch({
[10:33:08.109]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.109]                     }, error = function(ex) {
[10:33:08.109]                       msg <- conditionMessage(ex)
[10:33:08.109]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.109]                         fi_tmp[["mtime"]], msg)
[10:33:08.109]                       ex$message <- msg
[10:33:08.109]                       stop(ex)
[10:33:08.109]                     })
[10:33:08.109]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.109]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.109]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.109]                       fi <- file.info(pathname)
[10:33:08.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.109]                         fi[["size"]], fi[["mtime"]])
[10:33:08.109]                       stop(msg)
[10:33:08.109]                     }
[10:33:08.109]                     invisible(pathname)
[10:33:08.109]                   }
[10:33:08.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.109]                     rootPath = tempdir()) 
[10:33:08.109]                   {
[10:33:08.109]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.109]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.109]                       tmpdir = path, fileext = ".rds")
[10:33:08.109]                     save_rds(obj, file)
[10:33:08.109]                   }
[10:33:08.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.109]                   {
[10:33:08.109]                     inherits <- base::inherits
[10:33:08.109]                     invokeRestart <- base::invokeRestart
[10:33:08.109]                     is.null <- base::is.null
[10:33:08.109]                     muffled <- FALSE
[10:33:08.109]                     if (inherits(cond, "message")) {
[10:33:08.109]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.109]                       if (muffled) 
[10:33:08.109]                         invokeRestart("muffleMessage")
[10:33:08.109]                     }
[10:33:08.109]                     else if (inherits(cond, "warning")) {
[10:33:08.109]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.109]                       if (muffled) 
[10:33:08.109]                         invokeRestart("muffleWarning")
[10:33:08.109]                     }
[10:33:08.109]                     else if (inherits(cond, "condition")) {
[10:33:08.109]                       if (!is.null(pattern)) {
[10:33:08.109]                         computeRestarts <- base::computeRestarts
[10:33:08.109]                         grepl <- base::grepl
[10:33:08.109]                         restarts <- computeRestarts(cond)
[10:33:08.109]                         for (restart in restarts) {
[10:33:08.109]                           name <- restart$name
[10:33:08.109]                           if (is.null(name)) 
[10:33:08.109]                             next
[10:33:08.109]                           if (!grepl(pattern, name)) 
[10:33:08.109]                             next
[10:33:08.109]                           invokeRestart(restart)
[10:33:08.109]                           muffled <- TRUE
[10:33:08.109]                           break
[10:33:08.109]                         }
[10:33:08.109]                       }
[10:33:08.109]                     }
[10:33:08.109]                     invisible(muffled)
[10:33:08.109]                   }
[10:33:08.109]                   muffleCondition(cond)
[10:33:08.109]                 })
[10:33:08.109]             }))
[10:33:08.109]             future::FutureResult(value = ...future.value$value, 
[10:33:08.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.109]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.109]                     ...future.globalenv.names))
[10:33:08.109]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.109]         }, condition = base::local({
[10:33:08.109]             c <- base::c
[10:33:08.109]             inherits <- base::inherits
[10:33:08.109]             invokeRestart <- base::invokeRestart
[10:33:08.109]             length <- base::length
[10:33:08.109]             list <- base::list
[10:33:08.109]             seq.int <- base::seq.int
[10:33:08.109]             signalCondition <- base::signalCondition
[10:33:08.109]             sys.calls <- base::sys.calls
[10:33:08.109]             `[[` <- base::`[[`
[10:33:08.109]             `+` <- base::`+`
[10:33:08.109]             `<<-` <- base::`<<-`
[10:33:08.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.109]                   3L)]
[10:33:08.109]             }
[10:33:08.109]             function(cond) {
[10:33:08.109]                 is_error <- inherits(cond, "error")
[10:33:08.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.109]                   NULL)
[10:33:08.109]                 if (is_error) {
[10:33:08.109]                   sessionInformation <- function() {
[10:33:08.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.109]                       search = base::search(), system = base::Sys.info())
[10:33:08.109]                   }
[10:33:08.109]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.109]                     cond$call), session = sessionInformation(), 
[10:33:08.109]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.109]                   signalCondition(cond)
[10:33:08.109]                 }
[10:33:08.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.109]                 "immediateCondition"))) {
[10:33:08.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.109]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.109]                   if (TRUE && !signal) {
[10:33:08.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.109]                     {
[10:33:08.109]                       inherits <- base::inherits
[10:33:08.109]                       invokeRestart <- base::invokeRestart
[10:33:08.109]                       is.null <- base::is.null
[10:33:08.109]                       muffled <- FALSE
[10:33:08.109]                       if (inherits(cond, "message")) {
[10:33:08.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.109]                         if (muffled) 
[10:33:08.109]                           invokeRestart("muffleMessage")
[10:33:08.109]                       }
[10:33:08.109]                       else if (inherits(cond, "warning")) {
[10:33:08.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.109]                         if (muffled) 
[10:33:08.109]                           invokeRestart("muffleWarning")
[10:33:08.109]                       }
[10:33:08.109]                       else if (inherits(cond, "condition")) {
[10:33:08.109]                         if (!is.null(pattern)) {
[10:33:08.109]                           computeRestarts <- base::computeRestarts
[10:33:08.109]                           grepl <- base::grepl
[10:33:08.109]                           restarts <- computeRestarts(cond)
[10:33:08.109]                           for (restart in restarts) {
[10:33:08.109]                             name <- restart$name
[10:33:08.109]                             if (is.null(name)) 
[10:33:08.109]                               next
[10:33:08.109]                             if (!grepl(pattern, name)) 
[10:33:08.109]                               next
[10:33:08.109]                             invokeRestart(restart)
[10:33:08.109]                             muffled <- TRUE
[10:33:08.109]                             break
[10:33:08.109]                           }
[10:33:08.109]                         }
[10:33:08.109]                       }
[10:33:08.109]                       invisible(muffled)
[10:33:08.109]                     }
[10:33:08.109]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.109]                   }
[10:33:08.109]                 }
[10:33:08.109]                 else {
[10:33:08.109]                   if (TRUE) {
[10:33:08.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.109]                     {
[10:33:08.109]                       inherits <- base::inherits
[10:33:08.109]                       invokeRestart <- base::invokeRestart
[10:33:08.109]                       is.null <- base::is.null
[10:33:08.109]                       muffled <- FALSE
[10:33:08.109]                       if (inherits(cond, "message")) {
[10:33:08.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.109]                         if (muffled) 
[10:33:08.109]                           invokeRestart("muffleMessage")
[10:33:08.109]                       }
[10:33:08.109]                       else if (inherits(cond, "warning")) {
[10:33:08.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.109]                         if (muffled) 
[10:33:08.109]                           invokeRestart("muffleWarning")
[10:33:08.109]                       }
[10:33:08.109]                       else if (inherits(cond, "condition")) {
[10:33:08.109]                         if (!is.null(pattern)) {
[10:33:08.109]                           computeRestarts <- base::computeRestarts
[10:33:08.109]                           grepl <- base::grepl
[10:33:08.109]                           restarts <- computeRestarts(cond)
[10:33:08.109]                           for (restart in restarts) {
[10:33:08.109]                             name <- restart$name
[10:33:08.109]                             if (is.null(name)) 
[10:33:08.109]                               next
[10:33:08.109]                             if (!grepl(pattern, name)) 
[10:33:08.109]                               next
[10:33:08.109]                             invokeRestart(restart)
[10:33:08.109]                             muffled <- TRUE
[10:33:08.109]                             break
[10:33:08.109]                           }
[10:33:08.109]                         }
[10:33:08.109]                       }
[10:33:08.109]                       invisible(muffled)
[10:33:08.109]                     }
[10:33:08.109]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.109]                   }
[10:33:08.109]                 }
[10:33:08.109]             }
[10:33:08.109]         }))
[10:33:08.109]     }, error = function(ex) {
[10:33:08.109]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.109]                 ...future.rng), started = ...future.startTime, 
[10:33:08.109]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.109]             version = "1.8"), class = "FutureResult")
[10:33:08.109]     }, finally = {
[10:33:08.109]         if (!identical(...future.workdir, getwd())) 
[10:33:08.109]             setwd(...future.workdir)
[10:33:08.109]         {
[10:33:08.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.109]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.109]             }
[10:33:08.109]             base::options(...future.oldOptions)
[10:33:08.109]             if (.Platform$OS.type == "windows") {
[10:33:08.109]                 old_names <- names(...future.oldEnvVars)
[10:33:08.109]                 envs <- base::Sys.getenv()
[10:33:08.109]                 names <- names(envs)
[10:33:08.109]                 common <- intersect(names, old_names)
[10:33:08.109]                 added <- setdiff(names, old_names)
[10:33:08.109]                 removed <- setdiff(old_names, names)
[10:33:08.109]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.109]                   envs[common]]
[10:33:08.109]                 NAMES <- toupper(changed)
[10:33:08.109]                 args <- list()
[10:33:08.109]                 for (kk in seq_along(NAMES)) {
[10:33:08.109]                   name <- changed[[kk]]
[10:33:08.109]                   NAME <- NAMES[[kk]]
[10:33:08.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.109]                     next
[10:33:08.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.109]                 }
[10:33:08.109]                 NAMES <- toupper(added)
[10:33:08.109]                 for (kk in seq_along(NAMES)) {
[10:33:08.109]                   name <- added[[kk]]
[10:33:08.109]                   NAME <- NAMES[[kk]]
[10:33:08.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.109]                     next
[10:33:08.109]                   args[[name]] <- ""
[10:33:08.109]                 }
[10:33:08.109]                 NAMES <- toupper(removed)
[10:33:08.109]                 for (kk in seq_along(NAMES)) {
[10:33:08.109]                   name <- removed[[kk]]
[10:33:08.109]                   NAME <- NAMES[[kk]]
[10:33:08.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.109]                     next
[10:33:08.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.109]                 }
[10:33:08.109]                 if (length(args) > 0) 
[10:33:08.109]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.109]             }
[10:33:08.109]             else {
[10:33:08.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.109]             }
[10:33:08.109]             {
[10:33:08.109]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.109]                   0L) {
[10:33:08.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.109]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.109]                   base::options(opts)
[10:33:08.109]                 }
[10:33:08.109]                 {
[10:33:08.109]                   {
[10:33:08.109]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.109]                     NULL
[10:33:08.109]                   }
[10:33:08.109]                   options(future.plan = NULL)
[10:33:08.109]                   if (is.na(NA_character_)) 
[10:33:08.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.109]                     .init = FALSE)
[10:33:08.109]                 }
[10:33:08.109]             }
[10:33:08.109]         }
[10:33:08.109]     })
[10:33:08.109]     if (TRUE) {
[10:33:08.109]         base::sink(type = "output", split = FALSE)
[10:33:08.109]         if (TRUE) {
[10:33:08.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.109]         }
[10:33:08.109]         else {
[10:33:08.109]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.109]         }
[10:33:08.109]         base::close(...future.stdout)
[10:33:08.109]         ...future.stdout <- NULL
[10:33:08.109]     }
[10:33:08.109]     ...future.result$conditions <- ...future.conditions
[10:33:08.109]     ...future.result$finished <- base::Sys.time()
[10:33:08.109]     ...future.result
[10:33:08.109] }
[10:33:08.111] requestCore(): workers = 2
[10:33:08.113] MulticoreFuture started
[10:33:08.114] - Launch lazy future ... done
[10:33:08.114] run() for ‘MulticoreFuture’ ... done
[10:33:08.114] result() for MulticoreFuture ...
[10:33:08.115] plan(): Setting new future strategy stack:
[10:33:08.115] List of future strategies:
[10:33:08.115] 1. sequential:
[10:33:08.115]    - args: function (..., envir = parent.frame())
[10:33:08.115]    - tweaked: FALSE
[10:33:08.115]    - call: NULL
[10:33:08.116] plan(): nbrOfWorkers() = 1
[10:33:08.118] plan(): Setting new future strategy stack:
[10:33:08.118] List of future strategies:
[10:33:08.118] 1. multicore:
[10:33:08.118]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.118]    - tweaked: FALSE
[10:33:08.118]    - call: plan(strategy)
[10:33:08.123] plan(): nbrOfWorkers() = 2
[10:33:08.124] result() for MulticoreFuture ...
[10:33:08.124] result() for MulticoreFuture ... done
[10:33:08.124] result() for MulticoreFuture ... done
[10:33:08.124] result() for MulticoreFuture ...
[10:33:08.124] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.125] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.125] Searching for globals...
[10:33:08.128] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:08.128] Searching for globals ... DONE
[10:33:08.128] Resolving globals: TRUE
[10:33:08.128] Resolving any globals that are futures ...
[10:33:08.128] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:08.128] Resolving any globals that are futures ... DONE
[10:33:08.129] Resolving futures part of globals (recursively) ...
[10:33:08.129] resolve() on list ...
[10:33:08.129]  recursive: 99
[10:33:08.129]  length: 1
[10:33:08.130]  elements: ‘x’
[10:33:08.130]  length: 0 (resolved future 1)
[10:33:08.130] resolve() on list ... DONE
[10:33:08.130] - globals: [1] ‘x’
[10:33:08.130] Resolving futures part of globals (recursively) ... DONE
[10:33:08.130] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.131] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.131] - globals: [1] ‘x’
[10:33:08.131] 
[10:33:08.131] getGlobalsAndPackages() ... DONE
[10:33:08.131] run() for ‘Future’ ...
[10:33:08.132] - state: ‘created’
[10:33:08.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.137]   - Field: ‘label’
[10:33:08.137]   - Field: ‘local’
[10:33:08.137]   - Field: ‘owner’
[10:33:08.137]   - Field: ‘envir’
[10:33:08.137]   - Field: ‘workers’
[10:33:08.137]   - Field: ‘packages’
[10:33:08.137]   - Field: ‘gc’
[10:33:08.138]   - Field: ‘job’
[10:33:08.138]   - Field: ‘conditions’
[10:33:08.138]   - Field: ‘expr’
[10:33:08.138]   - Field: ‘uuid’
[10:33:08.138]   - Field: ‘seed’
[10:33:08.138]   - Field: ‘version’
[10:33:08.138]   - Field: ‘result’
[10:33:08.138]   - Field: ‘asynchronous’
[10:33:08.139]   - Field: ‘calls’
[10:33:08.139]   - Field: ‘globals’
[10:33:08.139]   - Field: ‘stdout’
[10:33:08.139]   - Field: ‘earlySignal’
[10:33:08.139]   - Field: ‘lazy’
[10:33:08.139]   - Field: ‘state’
[10:33:08.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.139] - Launch lazy future ...
[10:33:08.140] Packages needed by the future expression (n = 0): <none>
[10:33:08.140] Packages needed by future strategies (n = 0): <none>
[10:33:08.140] {
[10:33:08.140]     {
[10:33:08.140]         {
[10:33:08.140]             ...future.startTime <- base::Sys.time()
[10:33:08.140]             {
[10:33:08.140]                 {
[10:33:08.140]                   {
[10:33:08.140]                     {
[10:33:08.140]                       base::local({
[10:33:08.140]                         has_future <- base::requireNamespace("future", 
[10:33:08.140]                           quietly = TRUE)
[10:33:08.140]                         if (has_future) {
[10:33:08.140]                           ns <- base::getNamespace("future")
[10:33:08.140]                           version <- ns[[".package"]][["version"]]
[10:33:08.140]                           if (is.null(version)) 
[10:33:08.140]                             version <- utils::packageVersion("future")
[10:33:08.140]                         }
[10:33:08.140]                         else {
[10:33:08.140]                           version <- NULL
[10:33:08.140]                         }
[10:33:08.140]                         if (!has_future || version < "1.8.0") {
[10:33:08.140]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.140]                             "", base::R.version$version.string), 
[10:33:08.140]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.140]                               "release", "version")], collapse = " "), 
[10:33:08.140]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.140]                             info)
[10:33:08.140]                           info <- base::paste(info, collapse = "; ")
[10:33:08.140]                           if (!has_future) {
[10:33:08.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.140]                               info)
[10:33:08.140]                           }
[10:33:08.140]                           else {
[10:33:08.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.140]                               info, version)
[10:33:08.140]                           }
[10:33:08.140]                           base::stop(msg)
[10:33:08.140]                         }
[10:33:08.140]                       })
[10:33:08.140]                     }
[10:33:08.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.140]                     base::options(mc.cores = 1L)
[10:33:08.140]                   }
[10:33:08.140]                   ...future.strategy.old <- future::plan("list")
[10:33:08.140]                   options(future.plan = NULL)
[10:33:08.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.140]                 }
[10:33:08.140]                 ...future.workdir <- getwd()
[10:33:08.140]             }
[10:33:08.140]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.140]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.140]         }
[10:33:08.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.140]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.140]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.140]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.140]             base::names(...future.oldOptions))
[10:33:08.140]     }
[10:33:08.140]     if (FALSE) {
[10:33:08.140]     }
[10:33:08.140]     else {
[10:33:08.140]         if (TRUE) {
[10:33:08.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.140]                 open = "w")
[10:33:08.140]         }
[10:33:08.140]         else {
[10:33:08.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.140]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.140]         }
[10:33:08.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.140]             base::sink(type = "output", split = FALSE)
[10:33:08.140]             base::close(...future.stdout)
[10:33:08.140]         }, add = TRUE)
[10:33:08.140]     }
[10:33:08.140]     ...future.frame <- base::sys.nframe()
[10:33:08.140]     ...future.conditions <- base::list()
[10:33:08.140]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.140]     if (FALSE) {
[10:33:08.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.140]     }
[10:33:08.140]     ...future.result <- base::tryCatch({
[10:33:08.140]         base::withCallingHandlers({
[10:33:08.140]             ...future.value <- base::withVisible(base::local({
[10:33:08.140]                 withCallingHandlers({
[10:33:08.140]                   {
[10:33:08.140]                     x[["a"]] <- 1
[10:33:08.140]                     x
[10:33:08.140]                   }
[10:33:08.140]                 }, immediateCondition = function(cond) {
[10:33:08.140]                   save_rds <- function (object, pathname, ...) 
[10:33:08.140]                   {
[10:33:08.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.140]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.140]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.140]                         fi_tmp[["mtime"]])
[10:33:08.140]                     }
[10:33:08.140]                     tryCatch({
[10:33:08.140]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.140]                     }, error = function(ex) {
[10:33:08.140]                       msg <- conditionMessage(ex)
[10:33:08.140]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.140]                         fi_tmp[["mtime"]], msg)
[10:33:08.140]                       ex$message <- msg
[10:33:08.140]                       stop(ex)
[10:33:08.140]                     })
[10:33:08.140]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.140]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.140]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.140]                       fi <- file.info(pathname)
[10:33:08.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.140]                         fi[["size"]], fi[["mtime"]])
[10:33:08.140]                       stop(msg)
[10:33:08.140]                     }
[10:33:08.140]                     invisible(pathname)
[10:33:08.140]                   }
[10:33:08.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.140]                     rootPath = tempdir()) 
[10:33:08.140]                   {
[10:33:08.140]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.140]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.140]                       tmpdir = path, fileext = ".rds")
[10:33:08.140]                     save_rds(obj, file)
[10:33:08.140]                   }
[10:33:08.140]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.140]                   {
[10:33:08.140]                     inherits <- base::inherits
[10:33:08.140]                     invokeRestart <- base::invokeRestart
[10:33:08.140]                     is.null <- base::is.null
[10:33:08.140]                     muffled <- FALSE
[10:33:08.140]                     if (inherits(cond, "message")) {
[10:33:08.140]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.140]                       if (muffled) 
[10:33:08.140]                         invokeRestart("muffleMessage")
[10:33:08.140]                     }
[10:33:08.140]                     else if (inherits(cond, "warning")) {
[10:33:08.140]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.140]                       if (muffled) 
[10:33:08.140]                         invokeRestart("muffleWarning")
[10:33:08.140]                     }
[10:33:08.140]                     else if (inherits(cond, "condition")) {
[10:33:08.140]                       if (!is.null(pattern)) {
[10:33:08.140]                         computeRestarts <- base::computeRestarts
[10:33:08.140]                         grepl <- base::grepl
[10:33:08.140]                         restarts <- computeRestarts(cond)
[10:33:08.140]                         for (restart in restarts) {
[10:33:08.140]                           name <- restart$name
[10:33:08.140]                           if (is.null(name)) 
[10:33:08.140]                             next
[10:33:08.140]                           if (!grepl(pattern, name)) 
[10:33:08.140]                             next
[10:33:08.140]                           invokeRestart(restart)
[10:33:08.140]                           muffled <- TRUE
[10:33:08.140]                           break
[10:33:08.140]                         }
[10:33:08.140]                       }
[10:33:08.140]                     }
[10:33:08.140]                     invisible(muffled)
[10:33:08.140]                   }
[10:33:08.140]                   muffleCondition(cond)
[10:33:08.140]                 })
[10:33:08.140]             }))
[10:33:08.140]             future::FutureResult(value = ...future.value$value, 
[10:33:08.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.140]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.140]                     ...future.globalenv.names))
[10:33:08.140]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.140]         }, condition = base::local({
[10:33:08.140]             c <- base::c
[10:33:08.140]             inherits <- base::inherits
[10:33:08.140]             invokeRestart <- base::invokeRestart
[10:33:08.140]             length <- base::length
[10:33:08.140]             list <- base::list
[10:33:08.140]             seq.int <- base::seq.int
[10:33:08.140]             signalCondition <- base::signalCondition
[10:33:08.140]             sys.calls <- base::sys.calls
[10:33:08.140]             `[[` <- base::`[[`
[10:33:08.140]             `+` <- base::`+`
[10:33:08.140]             `<<-` <- base::`<<-`
[10:33:08.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.140]                   3L)]
[10:33:08.140]             }
[10:33:08.140]             function(cond) {
[10:33:08.140]                 is_error <- inherits(cond, "error")
[10:33:08.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.140]                   NULL)
[10:33:08.140]                 if (is_error) {
[10:33:08.140]                   sessionInformation <- function() {
[10:33:08.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.140]                       search = base::search(), system = base::Sys.info())
[10:33:08.140]                   }
[10:33:08.140]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.140]                     cond$call), session = sessionInformation(), 
[10:33:08.140]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.140]                   signalCondition(cond)
[10:33:08.140]                 }
[10:33:08.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.140]                 "immediateCondition"))) {
[10:33:08.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.140]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.140]                   if (TRUE && !signal) {
[10:33:08.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.140]                     {
[10:33:08.140]                       inherits <- base::inherits
[10:33:08.140]                       invokeRestart <- base::invokeRestart
[10:33:08.140]                       is.null <- base::is.null
[10:33:08.140]                       muffled <- FALSE
[10:33:08.140]                       if (inherits(cond, "message")) {
[10:33:08.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.140]                         if (muffled) 
[10:33:08.140]                           invokeRestart("muffleMessage")
[10:33:08.140]                       }
[10:33:08.140]                       else if (inherits(cond, "warning")) {
[10:33:08.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.140]                         if (muffled) 
[10:33:08.140]                           invokeRestart("muffleWarning")
[10:33:08.140]                       }
[10:33:08.140]                       else if (inherits(cond, "condition")) {
[10:33:08.140]                         if (!is.null(pattern)) {
[10:33:08.140]                           computeRestarts <- base::computeRestarts
[10:33:08.140]                           grepl <- base::grepl
[10:33:08.140]                           restarts <- computeRestarts(cond)
[10:33:08.140]                           for (restart in restarts) {
[10:33:08.140]                             name <- restart$name
[10:33:08.140]                             if (is.null(name)) 
[10:33:08.140]                               next
[10:33:08.140]                             if (!grepl(pattern, name)) 
[10:33:08.140]                               next
[10:33:08.140]                             invokeRestart(restart)
[10:33:08.140]                             muffled <- TRUE
[10:33:08.140]                             break
[10:33:08.140]                           }
[10:33:08.140]                         }
[10:33:08.140]                       }
[10:33:08.140]                       invisible(muffled)
[10:33:08.140]                     }
[10:33:08.140]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.140]                   }
[10:33:08.140]                 }
[10:33:08.140]                 else {
[10:33:08.140]                   if (TRUE) {
[10:33:08.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.140]                     {
[10:33:08.140]                       inherits <- base::inherits
[10:33:08.140]                       invokeRestart <- base::invokeRestart
[10:33:08.140]                       is.null <- base::is.null
[10:33:08.140]                       muffled <- FALSE
[10:33:08.140]                       if (inherits(cond, "message")) {
[10:33:08.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.140]                         if (muffled) 
[10:33:08.140]                           invokeRestart("muffleMessage")
[10:33:08.140]                       }
[10:33:08.140]                       else if (inherits(cond, "warning")) {
[10:33:08.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.140]                         if (muffled) 
[10:33:08.140]                           invokeRestart("muffleWarning")
[10:33:08.140]                       }
[10:33:08.140]                       else if (inherits(cond, "condition")) {
[10:33:08.140]                         if (!is.null(pattern)) {
[10:33:08.140]                           computeRestarts <- base::computeRestarts
[10:33:08.140]                           grepl <- base::grepl
[10:33:08.140]                           restarts <- computeRestarts(cond)
[10:33:08.140]                           for (restart in restarts) {
[10:33:08.140]                             name <- restart$name
[10:33:08.140]                             if (is.null(name)) 
[10:33:08.140]                               next
[10:33:08.140]                             if (!grepl(pattern, name)) 
[10:33:08.140]                               next
[10:33:08.140]                             invokeRestart(restart)
[10:33:08.140]                             muffled <- TRUE
[10:33:08.140]                             break
[10:33:08.140]                           }
[10:33:08.140]                         }
[10:33:08.140]                       }
[10:33:08.140]                       invisible(muffled)
[10:33:08.140]                     }
[10:33:08.140]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.140]                   }
[10:33:08.140]                 }
[10:33:08.140]             }
[10:33:08.140]         }))
[10:33:08.140]     }, error = function(ex) {
[10:33:08.140]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.140]                 ...future.rng), started = ...future.startTime, 
[10:33:08.140]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.140]             version = "1.8"), class = "FutureResult")
[10:33:08.140]     }, finally = {
[10:33:08.140]         if (!identical(...future.workdir, getwd())) 
[10:33:08.140]             setwd(...future.workdir)
[10:33:08.140]         {
[10:33:08.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.140]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.140]             }
[10:33:08.140]             base::options(...future.oldOptions)
[10:33:08.140]             if (.Platform$OS.type == "windows") {
[10:33:08.140]                 old_names <- names(...future.oldEnvVars)
[10:33:08.140]                 envs <- base::Sys.getenv()
[10:33:08.140]                 names <- names(envs)
[10:33:08.140]                 common <- intersect(names, old_names)
[10:33:08.140]                 added <- setdiff(names, old_names)
[10:33:08.140]                 removed <- setdiff(old_names, names)
[10:33:08.140]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.140]                   envs[common]]
[10:33:08.140]                 NAMES <- toupper(changed)
[10:33:08.140]                 args <- list()
[10:33:08.140]                 for (kk in seq_along(NAMES)) {
[10:33:08.140]                   name <- changed[[kk]]
[10:33:08.140]                   NAME <- NAMES[[kk]]
[10:33:08.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.140]                     next
[10:33:08.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.140]                 }
[10:33:08.140]                 NAMES <- toupper(added)
[10:33:08.140]                 for (kk in seq_along(NAMES)) {
[10:33:08.140]                   name <- added[[kk]]
[10:33:08.140]                   NAME <- NAMES[[kk]]
[10:33:08.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.140]                     next
[10:33:08.140]                   args[[name]] <- ""
[10:33:08.140]                 }
[10:33:08.140]                 NAMES <- toupper(removed)
[10:33:08.140]                 for (kk in seq_along(NAMES)) {
[10:33:08.140]                   name <- removed[[kk]]
[10:33:08.140]                   NAME <- NAMES[[kk]]
[10:33:08.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.140]                     next
[10:33:08.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.140]                 }
[10:33:08.140]                 if (length(args) > 0) 
[10:33:08.140]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.140]             }
[10:33:08.140]             else {
[10:33:08.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.140]             }
[10:33:08.140]             {
[10:33:08.140]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.140]                   0L) {
[10:33:08.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.140]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.140]                   base::options(opts)
[10:33:08.140]                 }
[10:33:08.140]                 {
[10:33:08.140]                   {
[10:33:08.140]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.140]                     NULL
[10:33:08.140]                   }
[10:33:08.140]                   options(future.plan = NULL)
[10:33:08.140]                   if (is.na(NA_character_)) 
[10:33:08.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.140]                     .init = FALSE)
[10:33:08.140]                 }
[10:33:08.140]             }
[10:33:08.140]         }
[10:33:08.140]     })
[10:33:08.140]     if (TRUE) {
[10:33:08.140]         base::sink(type = "output", split = FALSE)
[10:33:08.140]         if (TRUE) {
[10:33:08.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.140]         }
[10:33:08.140]         else {
[10:33:08.140]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.140]         }
[10:33:08.140]         base::close(...future.stdout)
[10:33:08.140]         ...future.stdout <- NULL
[10:33:08.140]     }
[10:33:08.140]     ...future.result$conditions <- ...future.conditions
[10:33:08.140]     ...future.result$finished <- base::Sys.time()
[10:33:08.140]     ...future.result
[10:33:08.140] }
[10:33:08.143] assign_globals() ...
[10:33:08.143] List of 1
[10:33:08.143]  $ x: list()
[10:33:08.143]  - attr(*, "where")=List of 1
[10:33:08.143]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.143]  - attr(*, "resolved")= logi TRUE
[10:33:08.143]  - attr(*, "total_size")= num 0
[10:33:08.143]  - attr(*, "already-done")= logi TRUE
[10:33:08.146] - copied ‘x’ to environment
[10:33:08.146] assign_globals() ... done
[10:33:08.147] requestCore(): workers = 2
[10:33:08.148] MulticoreFuture started
[10:33:08.149] - Launch lazy future ... done
[10:33:08.149] run() for ‘MulticoreFuture’ ... done
[10:33:08.149] result() for MulticoreFuture ...
[10:33:08.149] plan(): Setting new future strategy stack:
[10:33:08.150] List of future strategies:
[10:33:08.150] 1. sequential:
[10:33:08.150]    - args: function (..., envir = parent.frame())
[10:33:08.150]    - tweaked: FALSE
[10:33:08.150]    - call: NULL
[10:33:08.151] plan(): nbrOfWorkers() = 1
[10:33:08.152] plan(): Setting new future strategy stack:
[10:33:08.153] List of future strategies:
[10:33:08.153] 1. multicore:
[10:33:08.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.153]    - tweaked: FALSE
[10:33:08.153]    - call: plan(strategy)
[10:33:08.158] plan(): nbrOfWorkers() = 2
[10:33:08.158] result() for MulticoreFuture ...
[10:33:08.159] result() for MulticoreFuture ... done
[10:33:08.159] result() for MulticoreFuture ... done
[10:33:08.159] result() for MulticoreFuture ...
[10:33:08.159] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.160] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.160] Searching for globals...
[10:33:08.163] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:08.163] Searching for globals ... DONE
[10:33:08.163] Resolving globals: TRUE
[10:33:08.163] Resolving any globals that are futures ...
[10:33:08.163] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:08.164] Resolving any globals that are futures ... DONE
[10:33:08.166] Resolving futures part of globals (recursively) ...
[10:33:08.167] resolve() on list ...
[10:33:08.167]  recursive: 99
[10:33:08.167]  length: 1
[10:33:08.167]  elements: ‘x’
[10:33:08.168]  length: 0 (resolved future 1)
[10:33:08.168] resolve() on list ... DONE
[10:33:08.168] - globals: [1] ‘x’
[10:33:08.168] Resolving futures part of globals (recursively) ... DONE
[10:33:08.168] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.169] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.169] - globals: [1] ‘x’
[10:33:08.169] 
[10:33:08.169] getGlobalsAndPackages() ... DONE
[10:33:08.169] run() for ‘Future’ ...
[10:33:08.170] - state: ‘created’
[10:33:08.170] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.173] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.174]   - Field: ‘label’
[10:33:08.174]   - Field: ‘local’
[10:33:08.174]   - Field: ‘owner’
[10:33:08.174]   - Field: ‘envir’
[10:33:08.174]   - Field: ‘workers’
[10:33:08.174]   - Field: ‘packages’
[10:33:08.175]   - Field: ‘gc’
[10:33:08.175]   - Field: ‘job’
[10:33:08.175]   - Field: ‘conditions’
[10:33:08.175]   - Field: ‘expr’
[10:33:08.175]   - Field: ‘uuid’
[10:33:08.175]   - Field: ‘seed’
[10:33:08.175]   - Field: ‘version’
[10:33:08.175]   - Field: ‘result’
[10:33:08.175]   - Field: ‘asynchronous’
[10:33:08.176]   - Field: ‘calls’
[10:33:08.176]   - Field: ‘globals’
[10:33:08.176]   - Field: ‘stdout’
[10:33:08.176]   - Field: ‘earlySignal’
[10:33:08.176]   - Field: ‘lazy’
[10:33:08.176]   - Field: ‘state’
[10:33:08.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.176] - Launch lazy future ...
[10:33:08.177] Packages needed by the future expression (n = 0): <none>
[10:33:08.177] Packages needed by future strategies (n = 0): <none>
[10:33:08.177] {
[10:33:08.177]     {
[10:33:08.177]         {
[10:33:08.177]             ...future.startTime <- base::Sys.time()
[10:33:08.177]             {
[10:33:08.177]                 {
[10:33:08.177]                   {
[10:33:08.177]                     {
[10:33:08.177]                       base::local({
[10:33:08.177]                         has_future <- base::requireNamespace("future", 
[10:33:08.177]                           quietly = TRUE)
[10:33:08.177]                         if (has_future) {
[10:33:08.177]                           ns <- base::getNamespace("future")
[10:33:08.177]                           version <- ns[[".package"]][["version"]]
[10:33:08.177]                           if (is.null(version)) 
[10:33:08.177]                             version <- utils::packageVersion("future")
[10:33:08.177]                         }
[10:33:08.177]                         else {
[10:33:08.177]                           version <- NULL
[10:33:08.177]                         }
[10:33:08.177]                         if (!has_future || version < "1.8.0") {
[10:33:08.177]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.177]                             "", base::R.version$version.string), 
[10:33:08.177]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.177]                               "release", "version")], collapse = " "), 
[10:33:08.177]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.177]                             info)
[10:33:08.177]                           info <- base::paste(info, collapse = "; ")
[10:33:08.177]                           if (!has_future) {
[10:33:08.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.177]                               info)
[10:33:08.177]                           }
[10:33:08.177]                           else {
[10:33:08.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.177]                               info, version)
[10:33:08.177]                           }
[10:33:08.177]                           base::stop(msg)
[10:33:08.177]                         }
[10:33:08.177]                       })
[10:33:08.177]                     }
[10:33:08.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.177]                     base::options(mc.cores = 1L)
[10:33:08.177]                   }
[10:33:08.177]                   ...future.strategy.old <- future::plan("list")
[10:33:08.177]                   options(future.plan = NULL)
[10:33:08.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.177]                 }
[10:33:08.177]                 ...future.workdir <- getwd()
[10:33:08.177]             }
[10:33:08.177]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.177]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.177]         }
[10:33:08.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.177]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.177]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.177]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.177]             base::names(...future.oldOptions))
[10:33:08.177]     }
[10:33:08.177]     if (FALSE) {
[10:33:08.177]     }
[10:33:08.177]     else {
[10:33:08.177]         if (TRUE) {
[10:33:08.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.177]                 open = "w")
[10:33:08.177]         }
[10:33:08.177]         else {
[10:33:08.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.177]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.177]         }
[10:33:08.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.177]             base::sink(type = "output", split = FALSE)
[10:33:08.177]             base::close(...future.stdout)
[10:33:08.177]         }, add = TRUE)
[10:33:08.177]     }
[10:33:08.177]     ...future.frame <- base::sys.nframe()
[10:33:08.177]     ...future.conditions <- base::list()
[10:33:08.177]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.177]     if (FALSE) {
[10:33:08.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.177]     }
[10:33:08.177]     ...future.result <- base::tryCatch({
[10:33:08.177]         base::withCallingHandlers({
[10:33:08.177]             ...future.value <- base::withVisible(base::local({
[10:33:08.177]                 withCallingHandlers({
[10:33:08.177]                   {
[10:33:08.177]                     x[["a"]] <- 1
[10:33:08.177]                     x
[10:33:08.177]                   }
[10:33:08.177]                 }, immediateCondition = function(cond) {
[10:33:08.177]                   save_rds <- function (object, pathname, ...) 
[10:33:08.177]                   {
[10:33:08.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.177]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.177]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.177]                         fi_tmp[["mtime"]])
[10:33:08.177]                     }
[10:33:08.177]                     tryCatch({
[10:33:08.177]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.177]                     }, error = function(ex) {
[10:33:08.177]                       msg <- conditionMessage(ex)
[10:33:08.177]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.177]                         fi_tmp[["mtime"]], msg)
[10:33:08.177]                       ex$message <- msg
[10:33:08.177]                       stop(ex)
[10:33:08.177]                     })
[10:33:08.177]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.177]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.177]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.177]                       fi <- file.info(pathname)
[10:33:08.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.177]                         fi[["size"]], fi[["mtime"]])
[10:33:08.177]                       stop(msg)
[10:33:08.177]                     }
[10:33:08.177]                     invisible(pathname)
[10:33:08.177]                   }
[10:33:08.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.177]                     rootPath = tempdir()) 
[10:33:08.177]                   {
[10:33:08.177]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.177]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.177]                       tmpdir = path, fileext = ".rds")
[10:33:08.177]                     save_rds(obj, file)
[10:33:08.177]                   }
[10:33:08.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.177]                   {
[10:33:08.177]                     inherits <- base::inherits
[10:33:08.177]                     invokeRestart <- base::invokeRestart
[10:33:08.177]                     is.null <- base::is.null
[10:33:08.177]                     muffled <- FALSE
[10:33:08.177]                     if (inherits(cond, "message")) {
[10:33:08.177]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.177]                       if (muffled) 
[10:33:08.177]                         invokeRestart("muffleMessage")
[10:33:08.177]                     }
[10:33:08.177]                     else if (inherits(cond, "warning")) {
[10:33:08.177]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.177]                       if (muffled) 
[10:33:08.177]                         invokeRestart("muffleWarning")
[10:33:08.177]                     }
[10:33:08.177]                     else if (inherits(cond, "condition")) {
[10:33:08.177]                       if (!is.null(pattern)) {
[10:33:08.177]                         computeRestarts <- base::computeRestarts
[10:33:08.177]                         grepl <- base::grepl
[10:33:08.177]                         restarts <- computeRestarts(cond)
[10:33:08.177]                         for (restart in restarts) {
[10:33:08.177]                           name <- restart$name
[10:33:08.177]                           if (is.null(name)) 
[10:33:08.177]                             next
[10:33:08.177]                           if (!grepl(pattern, name)) 
[10:33:08.177]                             next
[10:33:08.177]                           invokeRestart(restart)
[10:33:08.177]                           muffled <- TRUE
[10:33:08.177]                           break
[10:33:08.177]                         }
[10:33:08.177]                       }
[10:33:08.177]                     }
[10:33:08.177]                     invisible(muffled)
[10:33:08.177]                   }
[10:33:08.177]                   muffleCondition(cond)
[10:33:08.177]                 })
[10:33:08.177]             }))
[10:33:08.177]             future::FutureResult(value = ...future.value$value, 
[10:33:08.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.177]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.177]                     ...future.globalenv.names))
[10:33:08.177]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.177]         }, condition = base::local({
[10:33:08.177]             c <- base::c
[10:33:08.177]             inherits <- base::inherits
[10:33:08.177]             invokeRestart <- base::invokeRestart
[10:33:08.177]             length <- base::length
[10:33:08.177]             list <- base::list
[10:33:08.177]             seq.int <- base::seq.int
[10:33:08.177]             signalCondition <- base::signalCondition
[10:33:08.177]             sys.calls <- base::sys.calls
[10:33:08.177]             `[[` <- base::`[[`
[10:33:08.177]             `+` <- base::`+`
[10:33:08.177]             `<<-` <- base::`<<-`
[10:33:08.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.177]                   3L)]
[10:33:08.177]             }
[10:33:08.177]             function(cond) {
[10:33:08.177]                 is_error <- inherits(cond, "error")
[10:33:08.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.177]                   NULL)
[10:33:08.177]                 if (is_error) {
[10:33:08.177]                   sessionInformation <- function() {
[10:33:08.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.177]                       search = base::search(), system = base::Sys.info())
[10:33:08.177]                   }
[10:33:08.177]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.177]                     cond$call), session = sessionInformation(), 
[10:33:08.177]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.177]                   signalCondition(cond)
[10:33:08.177]                 }
[10:33:08.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.177]                 "immediateCondition"))) {
[10:33:08.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.177]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.177]                   if (TRUE && !signal) {
[10:33:08.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.177]                     {
[10:33:08.177]                       inherits <- base::inherits
[10:33:08.177]                       invokeRestart <- base::invokeRestart
[10:33:08.177]                       is.null <- base::is.null
[10:33:08.177]                       muffled <- FALSE
[10:33:08.177]                       if (inherits(cond, "message")) {
[10:33:08.177]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.177]                         if (muffled) 
[10:33:08.177]                           invokeRestart("muffleMessage")
[10:33:08.177]                       }
[10:33:08.177]                       else if (inherits(cond, "warning")) {
[10:33:08.177]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.177]                         if (muffled) 
[10:33:08.177]                           invokeRestart("muffleWarning")
[10:33:08.177]                       }
[10:33:08.177]                       else if (inherits(cond, "condition")) {
[10:33:08.177]                         if (!is.null(pattern)) {
[10:33:08.177]                           computeRestarts <- base::computeRestarts
[10:33:08.177]                           grepl <- base::grepl
[10:33:08.177]                           restarts <- computeRestarts(cond)
[10:33:08.177]                           for (restart in restarts) {
[10:33:08.177]                             name <- restart$name
[10:33:08.177]                             if (is.null(name)) 
[10:33:08.177]                               next
[10:33:08.177]                             if (!grepl(pattern, name)) 
[10:33:08.177]                               next
[10:33:08.177]                             invokeRestart(restart)
[10:33:08.177]                             muffled <- TRUE
[10:33:08.177]                             break
[10:33:08.177]                           }
[10:33:08.177]                         }
[10:33:08.177]                       }
[10:33:08.177]                       invisible(muffled)
[10:33:08.177]                     }
[10:33:08.177]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.177]                   }
[10:33:08.177]                 }
[10:33:08.177]                 else {
[10:33:08.177]                   if (TRUE) {
[10:33:08.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.177]                     {
[10:33:08.177]                       inherits <- base::inherits
[10:33:08.177]                       invokeRestart <- base::invokeRestart
[10:33:08.177]                       is.null <- base::is.null
[10:33:08.177]                       muffled <- FALSE
[10:33:08.177]                       if (inherits(cond, "message")) {
[10:33:08.177]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.177]                         if (muffled) 
[10:33:08.177]                           invokeRestart("muffleMessage")
[10:33:08.177]                       }
[10:33:08.177]                       else if (inherits(cond, "warning")) {
[10:33:08.177]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.177]                         if (muffled) 
[10:33:08.177]                           invokeRestart("muffleWarning")
[10:33:08.177]                       }
[10:33:08.177]                       else if (inherits(cond, "condition")) {
[10:33:08.177]                         if (!is.null(pattern)) {
[10:33:08.177]                           computeRestarts <- base::computeRestarts
[10:33:08.177]                           grepl <- base::grepl
[10:33:08.177]                           restarts <- computeRestarts(cond)
[10:33:08.177]                           for (restart in restarts) {
[10:33:08.177]                             name <- restart$name
[10:33:08.177]                             if (is.null(name)) 
[10:33:08.177]                               next
[10:33:08.177]                             if (!grepl(pattern, name)) 
[10:33:08.177]                               next
[10:33:08.177]                             invokeRestart(restart)
[10:33:08.177]                             muffled <- TRUE
[10:33:08.177]                             break
[10:33:08.177]                           }
[10:33:08.177]                         }
[10:33:08.177]                       }
[10:33:08.177]                       invisible(muffled)
[10:33:08.177]                     }
[10:33:08.177]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.177]                   }
[10:33:08.177]                 }
[10:33:08.177]             }
[10:33:08.177]         }))
[10:33:08.177]     }, error = function(ex) {
[10:33:08.177]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.177]                 ...future.rng), started = ...future.startTime, 
[10:33:08.177]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.177]             version = "1.8"), class = "FutureResult")
[10:33:08.177]     }, finally = {
[10:33:08.177]         if (!identical(...future.workdir, getwd())) 
[10:33:08.177]             setwd(...future.workdir)
[10:33:08.177]         {
[10:33:08.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.177]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.177]             }
[10:33:08.177]             base::options(...future.oldOptions)
[10:33:08.177]             if (.Platform$OS.type == "windows") {
[10:33:08.177]                 old_names <- names(...future.oldEnvVars)
[10:33:08.177]                 envs <- base::Sys.getenv()
[10:33:08.177]                 names <- names(envs)
[10:33:08.177]                 common <- intersect(names, old_names)
[10:33:08.177]                 added <- setdiff(names, old_names)
[10:33:08.177]                 removed <- setdiff(old_names, names)
[10:33:08.177]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.177]                   envs[common]]
[10:33:08.177]                 NAMES <- toupper(changed)
[10:33:08.177]                 args <- list()
[10:33:08.177]                 for (kk in seq_along(NAMES)) {
[10:33:08.177]                   name <- changed[[kk]]
[10:33:08.177]                   NAME <- NAMES[[kk]]
[10:33:08.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.177]                     next
[10:33:08.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.177]                 }
[10:33:08.177]                 NAMES <- toupper(added)
[10:33:08.177]                 for (kk in seq_along(NAMES)) {
[10:33:08.177]                   name <- added[[kk]]
[10:33:08.177]                   NAME <- NAMES[[kk]]
[10:33:08.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.177]                     next
[10:33:08.177]                   args[[name]] <- ""
[10:33:08.177]                 }
[10:33:08.177]                 NAMES <- toupper(removed)
[10:33:08.177]                 for (kk in seq_along(NAMES)) {
[10:33:08.177]                   name <- removed[[kk]]
[10:33:08.177]                   NAME <- NAMES[[kk]]
[10:33:08.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.177]                     next
[10:33:08.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.177]                 }
[10:33:08.177]                 if (length(args) > 0) 
[10:33:08.177]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.177]             }
[10:33:08.177]             else {
[10:33:08.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.177]             }
[10:33:08.177]             {
[10:33:08.177]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.177]                   0L) {
[10:33:08.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.177]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.177]                   base::options(opts)
[10:33:08.177]                 }
[10:33:08.177]                 {
[10:33:08.177]                   {
[10:33:08.177]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.177]                     NULL
[10:33:08.177]                   }
[10:33:08.177]                   options(future.plan = NULL)
[10:33:08.177]                   if (is.na(NA_character_)) 
[10:33:08.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.177]                     .init = FALSE)
[10:33:08.177]                 }
[10:33:08.177]             }
[10:33:08.177]         }
[10:33:08.177]     })
[10:33:08.177]     if (TRUE) {
[10:33:08.177]         base::sink(type = "output", split = FALSE)
[10:33:08.177]         if (TRUE) {
[10:33:08.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.177]         }
[10:33:08.177]         else {
[10:33:08.177]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.177]         }
[10:33:08.177]         base::close(...future.stdout)
[10:33:08.177]         ...future.stdout <- NULL
[10:33:08.177]     }
[10:33:08.177]     ...future.result$conditions <- ...future.conditions
[10:33:08.177]     ...future.result$finished <- base::Sys.time()
[10:33:08.177]     ...future.result
[10:33:08.177] }
[10:33:08.180] assign_globals() ...
[10:33:08.180] List of 1
[10:33:08.180]  $ x: list()
[10:33:08.180]  - attr(*, "where")=List of 1
[10:33:08.180]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.180]  - attr(*, "resolved")= logi TRUE
[10:33:08.180]  - attr(*, "total_size")= num 0
[10:33:08.180]  - attr(*, "already-done")= logi TRUE
[10:33:08.183] - copied ‘x’ to environment
[10:33:08.183] assign_globals() ... done
[10:33:08.183] requestCore(): workers = 2
[10:33:08.185] MulticoreFuture started
[10:33:08.185] - Launch lazy future ... done
[10:33:08.185] run() for ‘MulticoreFuture’ ... done
[10:33:08.186] result() for MulticoreFuture ...
[10:33:08.186] plan(): Setting new future strategy stack:
[10:33:08.186] List of future strategies:
[10:33:08.186] 1. sequential:
[10:33:08.186]    - args: function (..., envir = parent.frame())
[10:33:08.186]    - tweaked: FALSE
[10:33:08.186]    - call: NULL
[10:33:08.187] plan(): nbrOfWorkers() = 1
[10:33:08.189] plan(): Setting new future strategy stack:
[10:33:08.189] List of future strategies:
[10:33:08.189] 1. multicore:
[10:33:08.189]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.189]    - tweaked: FALSE
[10:33:08.189]    - call: plan(strategy)
[10:33:08.194] plan(): nbrOfWorkers() = 2
[10:33:08.195] result() for MulticoreFuture ...
[10:33:08.195] result() for MulticoreFuture ... done
[10:33:08.196] result() for MulticoreFuture ... done
[10:33:08.196] result() for MulticoreFuture ...
[10:33:08.196] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.197] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.197] Searching for globals...
[10:33:08.200] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:08.200] Searching for globals ... DONE
[10:33:08.200] Resolving globals: TRUE
[10:33:08.200] Resolving any globals that are futures ...
[10:33:08.201] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:08.201] Resolving any globals that are futures ... DONE
[10:33:08.201] Resolving futures part of globals (recursively) ...
[10:33:08.202] resolve() on list ...
[10:33:08.202]  recursive: 99
[10:33:08.202]  length: 1
[10:33:08.202]  elements: ‘x’
[10:33:08.202]  length: 0 (resolved future 1)
[10:33:08.202] resolve() on list ... DONE
[10:33:08.202] - globals: [1] ‘x’
[10:33:08.202] Resolving futures part of globals (recursively) ... DONE
[10:33:08.203] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.203] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.203] - globals: [1] ‘x’
[10:33:08.203] 
[10:33:08.203] getGlobalsAndPackages() ... DONE
[10:33:08.204] run() for ‘Future’ ...
[10:33:08.204] - state: ‘created’
[10:33:08.204] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.208] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.208]   - Field: ‘label’
[10:33:08.208]   - Field: ‘local’
[10:33:08.208]   - Field: ‘owner’
[10:33:08.209]   - Field: ‘envir’
[10:33:08.209]   - Field: ‘workers’
[10:33:08.209]   - Field: ‘packages’
[10:33:08.209]   - Field: ‘gc’
[10:33:08.209]   - Field: ‘job’
[10:33:08.209]   - Field: ‘conditions’
[10:33:08.209]   - Field: ‘expr’
[10:33:08.209]   - Field: ‘uuid’
[10:33:08.210]   - Field: ‘seed’
[10:33:08.210]   - Field: ‘version’
[10:33:08.210]   - Field: ‘result’
[10:33:08.210]   - Field: ‘asynchronous’
[10:33:08.210]   - Field: ‘calls’
[10:33:08.210]   - Field: ‘globals’
[10:33:08.210]   - Field: ‘stdout’
[10:33:08.210]   - Field: ‘earlySignal’
[10:33:08.210]   - Field: ‘lazy’
[10:33:08.211]   - Field: ‘state’
[10:33:08.211] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.211] - Launch lazy future ...
[10:33:08.211] Packages needed by the future expression (n = 0): <none>
[10:33:08.211] Packages needed by future strategies (n = 0): <none>
[10:33:08.212] {
[10:33:08.212]     {
[10:33:08.212]         {
[10:33:08.212]             ...future.startTime <- base::Sys.time()
[10:33:08.212]             {
[10:33:08.212]                 {
[10:33:08.212]                   {
[10:33:08.212]                     {
[10:33:08.212]                       base::local({
[10:33:08.212]                         has_future <- base::requireNamespace("future", 
[10:33:08.212]                           quietly = TRUE)
[10:33:08.212]                         if (has_future) {
[10:33:08.212]                           ns <- base::getNamespace("future")
[10:33:08.212]                           version <- ns[[".package"]][["version"]]
[10:33:08.212]                           if (is.null(version)) 
[10:33:08.212]                             version <- utils::packageVersion("future")
[10:33:08.212]                         }
[10:33:08.212]                         else {
[10:33:08.212]                           version <- NULL
[10:33:08.212]                         }
[10:33:08.212]                         if (!has_future || version < "1.8.0") {
[10:33:08.212]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.212]                             "", base::R.version$version.string), 
[10:33:08.212]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.212]                               "release", "version")], collapse = " "), 
[10:33:08.212]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.212]                             info)
[10:33:08.212]                           info <- base::paste(info, collapse = "; ")
[10:33:08.212]                           if (!has_future) {
[10:33:08.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.212]                               info)
[10:33:08.212]                           }
[10:33:08.212]                           else {
[10:33:08.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.212]                               info, version)
[10:33:08.212]                           }
[10:33:08.212]                           base::stop(msg)
[10:33:08.212]                         }
[10:33:08.212]                       })
[10:33:08.212]                     }
[10:33:08.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.212]                     base::options(mc.cores = 1L)
[10:33:08.212]                   }
[10:33:08.212]                   ...future.strategy.old <- future::plan("list")
[10:33:08.212]                   options(future.plan = NULL)
[10:33:08.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.212]                 }
[10:33:08.212]                 ...future.workdir <- getwd()
[10:33:08.212]             }
[10:33:08.212]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.212]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.212]         }
[10:33:08.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.212]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.212]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.212]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.212]             base::names(...future.oldOptions))
[10:33:08.212]     }
[10:33:08.212]     if (FALSE) {
[10:33:08.212]     }
[10:33:08.212]     else {
[10:33:08.212]         if (TRUE) {
[10:33:08.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.212]                 open = "w")
[10:33:08.212]         }
[10:33:08.212]         else {
[10:33:08.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.212]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.212]         }
[10:33:08.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.212]             base::sink(type = "output", split = FALSE)
[10:33:08.212]             base::close(...future.stdout)
[10:33:08.212]         }, add = TRUE)
[10:33:08.212]     }
[10:33:08.212]     ...future.frame <- base::sys.nframe()
[10:33:08.212]     ...future.conditions <- base::list()
[10:33:08.212]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.212]     if (FALSE) {
[10:33:08.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.212]     }
[10:33:08.212]     ...future.result <- base::tryCatch({
[10:33:08.212]         base::withCallingHandlers({
[10:33:08.212]             ...future.value <- base::withVisible(base::local({
[10:33:08.212]                 withCallingHandlers({
[10:33:08.212]                   {
[10:33:08.212]                     x[["a"]] <- 1
[10:33:08.212]                     x
[10:33:08.212]                   }
[10:33:08.212]                 }, immediateCondition = function(cond) {
[10:33:08.212]                   save_rds <- function (object, pathname, ...) 
[10:33:08.212]                   {
[10:33:08.212]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.212]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.212]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.212]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.212]                         fi_tmp[["mtime"]])
[10:33:08.212]                     }
[10:33:08.212]                     tryCatch({
[10:33:08.212]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.212]                     }, error = function(ex) {
[10:33:08.212]                       msg <- conditionMessage(ex)
[10:33:08.212]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.212]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.212]                         fi_tmp[["mtime"]], msg)
[10:33:08.212]                       ex$message <- msg
[10:33:08.212]                       stop(ex)
[10:33:08.212]                     })
[10:33:08.212]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.212]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.212]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.212]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.212]                       fi <- file.info(pathname)
[10:33:08.212]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.212]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.212]                         fi[["size"]], fi[["mtime"]])
[10:33:08.212]                       stop(msg)
[10:33:08.212]                     }
[10:33:08.212]                     invisible(pathname)
[10:33:08.212]                   }
[10:33:08.212]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.212]                     rootPath = tempdir()) 
[10:33:08.212]                   {
[10:33:08.212]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.212]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.212]                       tmpdir = path, fileext = ".rds")
[10:33:08.212]                     save_rds(obj, file)
[10:33:08.212]                   }
[10:33:08.212]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.212]                   {
[10:33:08.212]                     inherits <- base::inherits
[10:33:08.212]                     invokeRestart <- base::invokeRestart
[10:33:08.212]                     is.null <- base::is.null
[10:33:08.212]                     muffled <- FALSE
[10:33:08.212]                     if (inherits(cond, "message")) {
[10:33:08.212]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.212]                       if (muffled) 
[10:33:08.212]                         invokeRestart("muffleMessage")
[10:33:08.212]                     }
[10:33:08.212]                     else if (inherits(cond, "warning")) {
[10:33:08.212]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.212]                       if (muffled) 
[10:33:08.212]                         invokeRestart("muffleWarning")
[10:33:08.212]                     }
[10:33:08.212]                     else if (inherits(cond, "condition")) {
[10:33:08.212]                       if (!is.null(pattern)) {
[10:33:08.212]                         computeRestarts <- base::computeRestarts
[10:33:08.212]                         grepl <- base::grepl
[10:33:08.212]                         restarts <- computeRestarts(cond)
[10:33:08.212]                         for (restart in restarts) {
[10:33:08.212]                           name <- restart$name
[10:33:08.212]                           if (is.null(name)) 
[10:33:08.212]                             next
[10:33:08.212]                           if (!grepl(pattern, name)) 
[10:33:08.212]                             next
[10:33:08.212]                           invokeRestart(restart)
[10:33:08.212]                           muffled <- TRUE
[10:33:08.212]                           break
[10:33:08.212]                         }
[10:33:08.212]                       }
[10:33:08.212]                     }
[10:33:08.212]                     invisible(muffled)
[10:33:08.212]                   }
[10:33:08.212]                   muffleCondition(cond)
[10:33:08.212]                 })
[10:33:08.212]             }))
[10:33:08.212]             future::FutureResult(value = ...future.value$value, 
[10:33:08.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.212]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.212]                     ...future.globalenv.names))
[10:33:08.212]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.212]         }, condition = base::local({
[10:33:08.212]             c <- base::c
[10:33:08.212]             inherits <- base::inherits
[10:33:08.212]             invokeRestart <- base::invokeRestart
[10:33:08.212]             length <- base::length
[10:33:08.212]             list <- base::list
[10:33:08.212]             seq.int <- base::seq.int
[10:33:08.212]             signalCondition <- base::signalCondition
[10:33:08.212]             sys.calls <- base::sys.calls
[10:33:08.212]             `[[` <- base::`[[`
[10:33:08.212]             `+` <- base::`+`
[10:33:08.212]             `<<-` <- base::`<<-`
[10:33:08.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.212]                   3L)]
[10:33:08.212]             }
[10:33:08.212]             function(cond) {
[10:33:08.212]                 is_error <- inherits(cond, "error")
[10:33:08.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.212]                   NULL)
[10:33:08.212]                 if (is_error) {
[10:33:08.212]                   sessionInformation <- function() {
[10:33:08.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.212]                       search = base::search(), system = base::Sys.info())
[10:33:08.212]                   }
[10:33:08.212]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.212]                     cond$call), session = sessionInformation(), 
[10:33:08.212]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.212]                   signalCondition(cond)
[10:33:08.212]                 }
[10:33:08.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.212]                 "immediateCondition"))) {
[10:33:08.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.212]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.212]                   if (TRUE && !signal) {
[10:33:08.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.212]                     {
[10:33:08.212]                       inherits <- base::inherits
[10:33:08.212]                       invokeRestart <- base::invokeRestart
[10:33:08.212]                       is.null <- base::is.null
[10:33:08.212]                       muffled <- FALSE
[10:33:08.212]                       if (inherits(cond, "message")) {
[10:33:08.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.212]                         if (muffled) 
[10:33:08.212]                           invokeRestart("muffleMessage")
[10:33:08.212]                       }
[10:33:08.212]                       else if (inherits(cond, "warning")) {
[10:33:08.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.212]                         if (muffled) 
[10:33:08.212]                           invokeRestart("muffleWarning")
[10:33:08.212]                       }
[10:33:08.212]                       else if (inherits(cond, "condition")) {
[10:33:08.212]                         if (!is.null(pattern)) {
[10:33:08.212]                           computeRestarts <- base::computeRestarts
[10:33:08.212]                           grepl <- base::grepl
[10:33:08.212]                           restarts <- computeRestarts(cond)
[10:33:08.212]                           for (restart in restarts) {
[10:33:08.212]                             name <- restart$name
[10:33:08.212]                             if (is.null(name)) 
[10:33:08.212]                               next
[10:33:08.212]                             if (!grepl(pattern, name)) 
[10:33:08.212]                               next
[10:33:08.212]                             invokeRestart(restart)
[10:33:08.212]                             muffled <- TRUE
[10:33:08.212]                             break
[10:33:08.212]                           }
[10:33:08.212]                         }
[10:33:08.212]                       }
[10:33:08.212]                       invisible(muffled)
[10:33:08.212]                     }
[10:33:08.212]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.212]                   }
[10:33:08.212]                 }
[10:33:08.212]                 else {
[10:33:08.212]                   if (TRUE) {
[10:33:08.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.212]                     {
[10:33:08.212]                       inherits <- base::inherits
[10:33:08.212]                       invokeRestart <- base::invokeRestart
[10:33:08.212]                       is.null <- base::is.null
[10:33:08.212]                       muffled <- FALSE
[10:33:08.212]                       if (inherits(cond, "message")) {
[10:33:08.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.212]                         if (muffled) 
[10:33:08.212]                           invokeRestart("muffleMessage")
[10:33:08.212]                       }
[10:33:08.212]                       else if (inherits(cond, "warning")) {
[10:33:08.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.212]                         if (muffled) 
[10:33:08.212]                           invokeRestart("muffleWarning")
[10:33:08.212]                       }
[10:33:08.212]                       else if (inherits(cond, "condition")) {
[10:33:08.212]                         if (!is.null(pattern)) {
[10:33:08.212]                           computeRestarts <- base::computeRestarts
[10:33:08.212]                           grepl <- base::grepl
[10:33:08.212]                           restarts <- computeRestarts(cond)
[10:33:08.212]                           for (restart in restarts) {
[10:33:08.212]                             name <- restart$name
[10:33:08.212]                             if (is.null(name)) 
[10:33:08.212]                               next
[10:33:08.212]                             if (!grepl(pattern, name)) 
[10:33:08.212]                               next
[10:33:08.212]                             invokeRestart(restart)
[10:33:08.212]                             muffled <- TRUE
[10:33:08.212]                             break
[10:33:08.212]                           }
[10:33:08.212]                         }
[10:33:08.212]                       }
[10:33:08.212]                       invisible(muffled)
[10:33:08.212]                     }
[10:33:08.212]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.212]                   }
[10:33:08.212]                 }
[10:33:08.212]             }
[10:33:08.212]         }))
[10:33:08.212]     }, error = function(ex) {
[10:33:08.212]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.212]                 ...future.rng), started = ...future.startTime, 
[10:33:08.212]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.212]             version = "1.8"), class = "FutureResult")
[10:33:08.212]     }, finally = {
[10:33:08.212]         if (!identical(...future.workdir, getwd())) 
[10:33:08.212]             setwd(...future.workdir)
[10:33:08.212]         {
[10:33:08.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.212]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.212]             }
[10:33:08.212]             base::options(...future.oldOptions)
[10:33:08.212]             if (.Platform$OS.type == "windows") {
[10:33:08.212]                 old_names <- names(...future.oldEnvVars)
[10:33:08.212]                 envs <- base::Sys.getenv()
[10:33:08.212]                 names <- names(envs)
[10:33:08.212]                 common <- intersect(names, old_names)
[10:33:08.212]                 added <- setdiff(names, old_names)
[10:33:08.212]                 removed <- setdiff(old_names, names)
[10:33:08.212]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.212]                   envs[common]]
[10:33:08.212]                 NAMES <- toupper(changed)
[10:33:08.212]                 args <- list()
[10:33:08.212]                 for (kk in seq_along(NAMES)) {
[10:33:08.212]                   name <- changed[[kk]]
[10:33:08.212]                   NAME <- NAMES[[kk]]
[10:33:08.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.212]                     next
[10:33:08.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.212]                 }
[10:33:08.212]                 NAMES <- toupper(added)
[10:33:08.212]                 for (kk in seq_along(NAMES)) {
[10:33:08.212]                   name <- added[[kk]]
[10:33:08.212]                   NAME <- NAMES[[kk]]
[10:33:08.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.212]                     next
[10:33:08.212]                   args[[name]] <- ""
[10:33:08.212]                 }
[10:33:08.212]                 NAMES <- toupper(removed)
[10:33:08.212]                 for (kk in seq_along(NAMES)) {
[10:33:08.212]                   name <- removed[[kk]]
[10:33:08.212]                   NAME <- NAMES[[kk]]
[10:33:08.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.212]                     next
[10:33:08.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.212]                 }
[10:33:08.212]                 if (length(args) > 0) 
[10:33:08.212]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.212]             }
[10:33:08.212]             else {
[10:33:08.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.212]             }
[10:33:08.212]             {
[10:33:08.212]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.212]                   0L) {
[10:33:08.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.212]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.212]                   base::options(opts)
[10:33:08.212]                 }
[10:33:08.212]                 {
[10:33:08.212]                   {
[10:33:08.212]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.212]                     NULL
[10:33:08.212]                   }
[10:33:08.212]                   options(future.plan = NULL)
[10:33:08.212]                   if (is.na(NA_character_)) 
[10:33:08.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.212]                     .init = FALSE)
[10:33:08.212]                 }
[10:33:08.212]             }
[10:33:08.212]         }
[10:33:08.212]     })
[10:33:08.212]     if (TRUE) {
[10:33:08.212]         base::sink(type = "output", split = FALSE)
[10:33:08.212]         if (TRUE) {
[10:33:08.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.212]         }
[10:33:08.212]         else {
[10:33:08.212]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.212]         }
[10:33:08.212]         base::close(...future.stdout)
[10:33:08.212]         ...future.stdout <- NULL
[10:33:08.212]     }
[10:33:08.212]     ...future.result$conditions <- ...future.conditions
[10:33:08.212]     ...future.result$finished <- base::Sys.time()
[10:33:08.212]     ...future.result
[10:33:08.212] }
[10:33:08.214] assign_globals() ...
[10:33:08.214] List of 1
[10:33:08.214]  $ x: list()
[10:33:08.214]  - attr(*, "where")=List of 1
[10:33:08.214]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.214]  - attr(*, "resolved")= logi TRUE
[10:33:08.214]  - attr(*, "total_size")= num 0
[10:33:08.214]  - attr(*, "already-done")= logi TRUE
[10:33:08.220] - copied ‘x’ to environment
[10:33:08.220] assign_globals() ... done
[10:33:08.220] requestCore(): workers = 2
[10:33:08.222] MulticoreFuture started
[10:33:08.222] - Launch lazy future ... done
[10:33:08.222] run() for ‘MulticoreFuture’ ... done
[10:33:08.223] result() for MulticoreFuture ...
[10:33:08.223] plan(): Setting new future strategy stack:
[10:33:08.223] List of future strategies:
[10:33:08.223] 1. sequential:
[10:33:08.223]    - args: function (..., envir = parent.frame())
[10:33:08.223]    - tweaked: FALSE
[10:33:08.223]    - call: NULL
[10:33:08.224] plan(): nbrOfWorkers() = 1
[10:33:08.226] plan(): Setting new future strategy stack:
[10:33:08.226] List of future strategies:
[10:33:08.226] 1. multicore:
[10:33:08.226]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.226]    - tweaked: FALSE
[10:33:08.226]    - call: plan(strategy)
[10:33:08.231] plan(): nbrOfWorkers() = 2
[10:33:08.232] result() for MulticoreFuture ...
[10:33:08.232] result() for MulticoreFuture ... done
[10:33:08.233] result() for MulticoreFuture ... done
[10:33:08.233] result() for MulticoreFuture ...
[10:33:08.233] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.233] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.234] Searching for globals...
[10:33:08.237] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:08.237] Searching for globals ... DONE
[10:33:08.237] Resolving globals: TRUE
[10:33:08.237] Resolving any globals that are futures ...
[10:33:08.237] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:08.237] Resolving any globals that are futures ... DONE
[10:33:08.238] Resolving futures part of globals (recursively) ...
[10:33:08.238] resolve() on list ...
[10:33:08.238]  recursive: 99
[10:33:08.238]  length: 1
[10:33:08.238]  elements: ‘x’
[10:33:08.239]  length: 0 (resolved future 1)
[10:33:08.239] resolve() on list ... DONE
[10:33:08.239] - globals: [1] ‘x’
[10:33:08.239] Resolving futures part of globals (recursively) ... DONE
[10:33:08.239] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.240] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.240] - globals: [1] ‘x’
[10:33:08.240] 
[10:33:08.240] getGlobalsAndPackages() ... DONE
[10:33:08.240] run() for ‘Future’ ...
[10:33:08.240] - state: ‘created’
[10:33:08.241] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.245] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.245]   - Field: ‘label’
[10:33:08.245]   - Field: ‘local’
[10:33:08.245]   - Field: ‘owner’
[10:33:08.245]   - Field: ‘envir’
[10:33:08.245]   - Field: ‘workers’
[10:33:08.245]   - Field: ‘packages’
[10:33:08.246]   - Field: ‘gc’
[10:33:08.246]   - Field: ‘job’
[10:33:08.246]   - Field: ‘conditions’
[10:33:08.246]   - Field: ‘expr’
[10:33:08.246]   - Field: ‘uuid’
[10:33:08.246]   - Field: ‘seed’
[10:33:08.246]   - Field: ‘version’
[10:33:08.246]   - Field: ‘result’
[10:33:08.246]   - Field: ‘asynchronous’
[10:33:08.247]   - Field: ‘calls’
[10:33:08.247]   - Field: ‘globals’
[10:33:08.247]   - Field: ‘stdout’
[10:33:08.247]   - Field: ‘earlySignal’
[10:33:08.247]   - Field: ‘lazy’
[10:33:08.247]   - Field: ‘state’
[10:33:08.247] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.247] - Launch lazy future ...
[10:33:08.248] Packages needed by the future expression (n = 0): <none>
[10:33:08.248] Packages needed by future strategies (n = 0): <none>
[10:33:08.248] {
[10:33:08.248]     {
[10:33:08.248]         {
[10:33:08.248]             ...future.startTime <- base::Sys.time()
[10:33:08.248]             {
[10:33:08.248]                 {
[10:33:08.248]                   {
[10:33:08.248]                     {
[10:33:08.248]                       base::local({
[10:33:08.248]                         has_future <- base::requireNamespace("future", 
[10:33:08.248]                           quietly = TRUE)
[10:33:08.248]                         if (has_future) {
[10:33:08.248]                           ns <- base::getNamespace("future")
[10:33:08.248]                           version <- ns[[".package"]][["version"]]
[10:33:08.248]                           if (is.null(version)) 
[10:33:08.248]                             version <- utils::packageVersion("future")
[10:33:08.248]                         }
[10:33:08.248]                         else {
[10:33:08.248]                           version <- NULL
[10:33:08.248]                         }
[10:33:08.248]                         if (!has_future || version < "1.8.0") {
[10:33:08.248]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.248]                             "", base::R.version$version.string), 
[10:33:08.248]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.248]                               "release", "version")], collapse = " "), 
[10:33:08.248]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.248]                             info)
[10:33:08.248]                           info <- base::paste(info, collapse = "; ")
[10:33:08.248]                           if (!has_future) {
[10:33:08.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.248]                               info)
[10:33:08.248]                           }
[10:33:08.248]                           else {
[10:33:08.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.248]                               info, version)
[10:33:08.248]                           }
[10:33:08.248]                           base::stop(msg)
[10:33:08.248]                         }
[10:33:08.248]                       })
[10:33:08.248]                     }
[10:33:08.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.248]                     base::options(mc.cores = 1L)
[10:33:08.248]                   }
[10:33:08.248]                   ...future.strategy.old <- future::plan("list")
[10:33:08.248]                   options(future.plan = NULL)
[10:33:08.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.248]                 }
[10:33:08.248]                 ...future.workdir <- getwd()
[10:33:08.248]             }
[10:33:08.248]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.248]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.248]         }
[10:33:08.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.248]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.248]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.248]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.248]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.248]             base::names(...future.oldOptions))
[10:33:08.248]     }
[10:33:08.248]     if (FALSE) {
[10:33:08.248]     }
[10:33:08.248]     else {
[10:33:08.248]         if (TRUE) {
[10:33:08.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.248]                 open = "w")
[10:33:08.248]         }
[10:33:08.248]         else {
[10:33:08.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.248]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.248]         }
[10:33:08.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.248]             base::sink(type = "output", split = FALSE)
[10:33:08.248]             base::close(...future.stdout)
[10:33:08.248]         }, add = TRUE)
[10:33:08.248]     }
[10:33:08.248]     ...future.frame <- base::sys.nframe()
[10:33:08.248]     ...future.conditions <- base::list()
[10:33:08.248]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.248]     if (FALSE) {
[10:33:08.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.248]     }
[10:33:08.248]     ...future.result <- base::tryCatch({
[10:33:08.248]         base::withCallingHandlers({
[10:33:08.248]             ...future.value <- base::withVisible(base::local({
[10:33:08.248]                 withCallingHandlers({
[10:33:08.248]                   {
[10:33:08.248]                     x["a"] <- list(1)
[10:33:08.248]                     x
[10:33:08.248]                   }
[10:33:08.248]                 }, immediateCondition = function(cond) {
[10:33:08.248]                   save_rds <- function (object, pathname, ...) 
[10:33:08.248]                   {
[10:33:08.248]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.248]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.248]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.248]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.248]                         fi_tmp[["mtime"]])
[10:33:08.248]                     }
[10:33:08.248]                     tryCatch({
[10:33:08.248]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.248]                     }, error = function(ex) {
[10:33:08.248]                       msg <- conditionMessage(ex)
[10:33:08.248]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.248]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.248]                         fi_tmp[["mtime"]], msg)
[10:33:08.248]                       ex$message <- msg
[10:33:08.248]                       stop(ex)
[10:33:08.248]                     })
[10:33:08.248]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.248]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.248]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.248]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.248]                       fi <- file.info(pathname)
[10:33:08.248]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.248]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.248]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.248]                         fi[["size"]], fi[["mtime"]])
[10:33:08.248]                       stop(msg)
[10:33:08.248]                     }
[10:33:08.248]                     invisible(pathname)
[10:33:08.248]                   }
[10:33:08.248]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.248]                     rootPath = tempdir()) 
[10:33:08.248]                   {
[10:33:08.248]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.248]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.248]                       tmpdir = path, fileext = ".rds")
[10:33:08.248]                     save_rds(obj, file)
[10:33:08.248]                   }
[10:33:08.248]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.248]                   {
[10:33:08.248]                     inherits <- base::inherits
[10:33:08.248]                     invokeRestart <- base::invokeRestart
[10:33:08.248]                     is.null <- base::is.null
[10:33:08.248]                     muffled <- FALSE
[10:33:08.248]                     if (inherits(cond, "message")) {
[10:33:08.248]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.248]                       if (muffled) 
[10:33:08.248]                         invokeRestart("muffleMessage")
[10:33:08.248]                     }
[10:33:08.248]                     else if (inherits(cond, "warning")) {
[10:33:08.248]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.248]                       if (muffled) 
[10:33:08.248]                         invokeRestart("muffleWarning")
[10:33:08.248]                     }
[10:33:08.248]                     else if (inherits(cond, "condition")) {
[10:33:08.248]                       if (!is.null(pattern)) {
[10:33:08.248]                         computeRestarts <- base::computeRestarts
[10:33:08.248]                         grepl <- base::grepl
[10:33:08.248]                         restarts <- computeRestarts(cond)
[10:33:08.248]                         for (restart in restarts) {
[10:33:08.248]                           name <- restart$name
[10:33:08.248]                           if (is.null(name)) 
[10:33:08.248]                             next
[10:33:08.248]                           if (!grepl(pattern, name)) 
[10:33:08.248]                             next
[10:33:08.248]                           invokeRestart(restart)
[10:33:08.248]                           muffled <- TRUE
[10:33:08.248]                           break
[10:33:08.248]                         }
[10:33:08.248]                       }
[10:33:08.248]                     }
[10:33:08.248]                     invisible(muffled)
[10:33:08.248]                   }
[10:33:08.248]                   muffleCondition(cond)
[10:33:08.248]                 })
[10:33:08.248]             }))
[10:33:08.248]             future::FutureResult(value = ...future.value$value, 
[10:33:08.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.248]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.248]                     ...future.globalenv.names))
[10:33:08.248]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.248]         }, condition = base::local({
[10:33:08.248]             c <- base::c
[10:33:08.248]             inherits <- base::inherits
[10:33:08.248]             invokeRestart <- base::invokeRestart
[10:33:08.248]             length <- base::length
[10:33:08.248]             list <- base::list
[10:33:08.248]             seq.int <- base::seq.int
[10:33:08.248]             signalCondition <- base::signalCondition
[10:33:08.248]             sys.calls <- base::sys.calls
[10:33:08.248]             `[[` <- base::`[[`
[10:33:08.248]             `+` <- base::`+`
[10:33:08.248]             `<<-` <- base::`<<-`
[10:33:08.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.248]                   3L)]
[10:33:08.248]             }
[10:33:08.248]             function(cond) {
[10:33:08.248]                 is_error <- inherits(cond, "error")
[10:33:08.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.248]                   NULL)
[10:33:08.248]                 if (is_error) {
[10:33:08.248]                   sessionInformation <- function() {
[10:33:08.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.248]                       search = base::search(), system = base::Sys.info())
[10:33:08.248]                   }
[10:33:08.248]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.248]                     cond$call), session = sessionInformation(), 
[10:33:08.248]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.248]                   signalCondition(cond)
[10:33:08.248]                 }
[10:33:08.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.248]                 "immediateCondition"))) {
[10:33:08.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.248]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.248]                   if (TRUE && !signal) {
[10:33:08.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.248]                     {
[10:33:08.248]                       inherits <- base::inherits
[10:33:08.248]                       invokeRestart <- base::invokeRestart
[10:33:08.248]                       is.null <- base::is.null
[10:33:08.248]                       muffled <- FALSE
[10:33:08.248]                       if (inherits(cond, "message")) {
[10:33:08.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.248]                         if (muffled) 
[10:33:08.248]                           invokeRestart("muffleMessage")
[10:33:08.248]                       }
[10:33:08.248]                       else if (inherits(cond, "warning")) {
[10:33:08.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.248]                         if (muffled) 
[10:33:08.248]                           invokeRestart("muffleWarning")
[10:33:08.248]                       }
[10:33:08.248]                       else if (inherits(cond, "condition")) {
[10:33:08.248]                         if (!is.null(pattern)) {
[10:33:08.248]                           computeRestarts <- base::computeRestarts
[10:33:08.248]                           grepl <- base::grepl
[10:33:08.248]                           restarts <- computeRestarts(cond)
[10:33:08.248]                           for (restart in restarts) {
[10:33:08.248]                             name <- restart$name
[10:33:08.248]                             if (is.null(name)) 
[10:33:08.248]                               next
[10:33:08.248]                             if (!grepl(pattern, name)) 
[10:33:08.248]                               next
[10:33:08.248]                             invokeRestart(restart)
[10:33:08.248]                             muffled <- TRUE
[10:33:08.248]                             break
[10:33:08.248]                           }
[10:33:08.248]                         }
[10:33:08.248]                       }
[10:33:08.248]                       invisible(muffled)
[10:33:08.248]                     }
[10:33:08.248]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.248]                   }
[10:33:08.248]                 }
[10:33:08.248]                 else {
[10:33:08.248]                   if (TRUE) {
[10:33:08.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.248]                     {
[10:33:08.248]                       inherits <- base::inherits
[10:33:08.248]                       invokeRestart <- base::invokeRestart
[10:33:08.248]                       is.null <- base::is.null
[10:33:08.248]                       muffled <- FALSE
[10:33:08.248]                       if (inherits(cond, "message")) {
[10:33:08.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.248]                         if (muffled) 
[10:33:08.248]                           invokeRestart("muffleMessage")
[10:33:08.248]                       }
[10:33:08.248]                       else if (inherits(cond, "warning")) {
[10:33:08.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.248]                         if (muffled) 
[10:33:08.248]                           invokeRestart("muffleWarning")
[10:33:08.248]                       }
[10:33:08.248]                       else if (inherits(cond, "condition")) {
[10:33:08.248]                         if (!is.null(pattern)) {
[10:33:08.248]                           computeRestarts <- base::computeRestarts
[10:33:08.248]                           grepl <- base::grepl
[10:33:08.248]                           restarts <- computeRestarts(cond)
[10:33:08.248]                           for (restart in restarts) {
[10:33:08.248]                             name <- restart$name
[10:33:08.248]                             if (is.null(name)) 
[10:33:08.248]                               next
[10:33:08.248]                             if (!grepl(pattern, name)) 
[10:33:08.248]                               next
[10:33:08.248]                             invokeRestart(restart)
[10:33:08.248]                             muffled <- TRUE
[10:33:08.248]                             break
[10:33:08.248]                           }
[10:33:08.248]                         }
[10:33:08.248]                       }
[10:33:08.248]                       invisible(muffled)
[10:33:08.248]                     }
[10:33:08.248]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.248]                   }
[10:33:08.248]                 }
[10:33:08.248]             }
[10:33:08.248]         }))
[10:33:08.248]     }, error = function(ex) {
[10:33:08.248]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.248]                 ...future.rng), started = ...future.startTime, 
[10:33:08.248]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.248]             version = "1.8"), class = "FutureResult")
[10:33:08.248]     }, finally = {
[10:33:08.248]         if (!identical(...future.workdir, getwd())) 
[10:33:08.248]             setwd(...future.workdir)
[10:33:08.248]         {
[10:33:08.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.248]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.248]             }
[10:33:08.248]             base::options(...future.oldOptions)
[10:33:08.248]             if (.Platform$OS.type == "windows") {
[10:33:08.248]                 old_names <- names(...future.oldEnvVars)
[10:33:08.248]                 envs <- base::Sys.getenv()
[10:33:08.248]                 names <- names(envs)
[10:33:08.248]                 common <- intersect(names, old_names)
[10:33:08.248]                 added <- setdiff(names, old_names)
[10:33:08.248]                 removed <- setdiff(old_names, names)
[10:33:08.248]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.248]                   envs[common]]
[10:33:08.248]                 NAMES <- toupper(changed)
[10:33:08.248]                 args <- list()
[10:33:08.248]                 for (kk in seq_along(NAMES)) {
[10:33:08.248]                   name <- changed[[kk]]
[10:33:08.248]                   NAME <- NAMES[[kk]]
[10:33:08.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.248]                     next
[10:33:08.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.248]                 }
[10:33:08.248]                 NAMES <- toupper(added)
[10:33:08.248]                 for (kk in seq_along(NAMES)) {
[10:33:08.248]                   name <- added[[kk]]
[10:33:08.248]                   NAME <- NAMES[[kk]]
[10:33:08.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.248]                     next
[10:33:08.248]                   args[[name]] <- ""
[10:33:08.248]                 }
[10:33:08.248]                 NAMES <- toupper(removed)
[10:33:08.248]                 for (kk in seq_along(NAMES)) {
[10:33:08.248]                   name <- removed[[kk]]
[10:33:08.248]                   NAME <- NAMES[[kk]]
[10:33:08.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.248]                     next
[10:33:08.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.248]                 }
[10:33:08.248]                 if (length(args) > 0) 
[10:33:08.248]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.248]             }
[10:33:08.248]             else {
[10:33:08.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.248]             }
[10:33:08.248]             {
[10:33:08.248]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.248]                   0L) {
[10:33:08.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.248]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.248]                   base::options(opts)
[10:33:08.248]                 }
[10:33:08.248]                 {
[10:33:08.248]                   {
[10:33:08.248]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.248]                     NULL
[10:33:08.248]                   }
[10:33:08.248]                   options(future.plan = NULL)
[10:33:08.248]                   if (is.na(NA_character_)) 
[10:33:08.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.248]                     .init = FALSE)
[10:33:08.248]                 }
[10:33:08.248]             }
[10:33:08.248]         }
[10:33:08.248]     })
[10:33:08.248]     if (TRUE) {
[10:33:08.248]         base::sink(type = "output", split = FALSE)
[10:33:08.248]         if (TRUE) {
[10:33:08.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.248]         }
[10:33:08.248]         else {
[10:33:08.248]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.248]         }
[10:33:08.248]         base::close(...future.stdout)
[10:33:08.248]         ...future.stdout <- NULL
[10:33:08.248]     }
[10:33:08.248]     ...future.result$conditions <- ...future.conditions
[10:33:08.248]     ...future.result$finished <- base::Sys.time()
[10:33:08.248]     ...future.result
[10:33:08.248] }
[10:33:08.251] assign_globals() ...
[10:33:08.251] List of 1
[10:33:08.251]  $ x: list()
[10:33:08.251]  - attr(*, "where")=List of 1
[10:33:08.251]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.251]  - attr(*, "resolved")= logi TRUE
[10:33:08.251]  - attr(*, "total_size")= num 0
[10:33:08.251]  - attr(*, "already-done")= logi TRUE
[10:33:08.254] - copied ‘x’ to environment
[10:33:08.254] assign_globals() ... done
[10:33:08.254] requestCore(): workers = 2
[10:33:08.256] MulticoreFuture started
[10:33:08.256] - Launch lazy future ... done
[10:33:08.256] run() for ‘MulticoreFuture’ ... done
[10:33:08.257] result() for MulticoreFuture ...
[10:33:08.257] plan(): Setting new future strategy stack:
[10:33:08.257] List of future strategies:
[10:33:08.257] 1. sequential:
[10:33:08.257]    - args: function (..., envir = parent.frame())
[10:33:08.257]    - tweaked: FALSE
[10:33:08.257]    - call: NULL
[10:33:08.258] plan(): nbrOfWorkers() = 1
[10:33:08.260] plan(): Setting new future strategy stack:
[10:33:08.260] List of future strategies:
[10:33:08.260] 1. multicore:
[10:33:08.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.260]    - tweaked: FALSE
[10:33:08.260]    - call: plan(strategy)
[10:33:08.265] plan(): nbrOfWorkers() = 2
[10:33:08.266] result() for MulticoreFuture ...
[10:33:08.266] result() for MulticoreFuture ... done
[10:33:08.267] result() for MulticoreFuture ... done
[10:33:08.267] result() for MulticoreFuture ...
[10:33:08.267] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.267] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.268] Searching for globals...
[10:33:08.271] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:08.271] Searching for globals ... DONE
[10:33:08.273] Resolving globals: TRUE
[10:33:08.274] Resolving any globals that are futures ...
[10:33:08.274] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:08.274] Resolving any globals that are futures ... DONE
[10:33:08.274] Resolving futures part of globals (recursively) ...
[10:33:08.275] resolve() on list ...
[10:33:08.275]  recursive: 99
[10:33:08.275]  length: 1
[10:33:08.275]  elements: ‘x’
[10:33:08.275]  length: 0 (resolved future 1)
[10:33:08.275] resolve() on list ... DONE
[10:33:08.276] - globals: [1] ‘x’
[10:33:08.276] Resolving futures part of globals (recursively) ... DONE
[10:33:08.276] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.276] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.277] - globals: [1] ‘x’
[10:33:08.277] 
[10:33:08.277] getGlobalsAndPackages() ... DONE
[10:33:08.277] run() for ‘Future’ ...
[10:33:08.277] - state: ‘created’
[10:33:08.277] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.281] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.281] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.282]   - Field: ‘label’
[10:33:08.282]   - Field: ‘local’
[10:33:08.282]   - Field: ‘owner’
[10:33:08.282]   - Field: ‘envir’
[10:33:08.282]   - Field: ‘workers’
[10:33:08.282]   - Field: ‘packages’
[10:33:08.282]   - Field: ‘gc’
[10:33:08.282]   - Field: ‘job’
[10:33:08.283]   - Field: ‘conditions’
[10:33:08.283]   - Field: ‘expr’
[10:33:08.283]   - Field: ‘uuid’
[10:33:08.283]   - Field: ‘seed’
[10:33:08.283]   - Field: ‘version’
[10:33:08.283]   - Field: ‘result’
[10:33:08.283]   - Field: ‘asynchronous’
[10:33:08.283]   - Field: ‘calls’
[10:33:08.283]   - Field: ‘globals’
[10:33:08.284]   - Field: ‘stdout’
[10:33:08.284]   - Field: ‘earlySignal’
[10:33:08.284]   - Field: ‘lazy’
[10:33:08.284]   - Field: ‘state’
[10:33:08.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.284] - Launch lazy future ...
[10:33:08.284] Packages needed by the future expression (n = 0): <none>
[10:33:08.285] Packages needed by future strategies (n = 0): <none>
[10:33:08.285] {
[10:33:08.285]     {
[10:33:08.285]         {
[10:33:08.285]             ...future.startTime <- base::Sys.time()
[10:33:08.285]             {
[10:33:08.285]                 {
[10:33:08.285]                   {
[10:33:08.285]                     {
[10:33:08.285]                       base::local({
[10:33:08.285]                         has_future <- base::requireNamespace("future", 
[10:33:08.285]                           quietly = TRUE)
[10:33:08.285]                         if (has_future) {
[10:33:08.285]                           ns <- base::getNamespace("future")
[10:33:08.285]                           version <- ns[[".package"]][["version"]]
[10:33:08.285]                           if (is.null(version)) 
[10:33:08.285]                             version <- utils::packageVersion("future")
[10:33:08.285]                         }
[10:33:08.285]                         else {
[10:33:08.285]                           version <- NULL
[10:33:08.285]                         }
[10:33:08.285]                         if (!has_future || version < "1.8.0") {
[10:33:08.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.285]                             "", base::R.version$version.string), 
[10:33:08.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.285]                               "release", "version")], collapse = " "), 
[10:33:08.285]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.285]                             info)
[10:33:08.285]                           info <- base::paste(info, collapse = "; ")
[10:33:08.285]                           if (!has_future) {
[10:33:08.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.285]                               info)
[10:33:08.285]                           }
[10:33:08.285]                           else {
[10:33:08.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.285]                               info, version)
[10:33:08.285]                           }
[10:33:08.285]                           base::stop(msg)
[10:33:08.285]                         }
[10:33:08.285]                       })
[10:33:08.285]                     }
[10:33:08.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.285]                     base::options(mc.cores = 1L)
[10:33:08.285]                   }
[10:33:08.285]                   ...future.strategy.old <- future::plan("list")
[10:33:08.285]                   options(future.plan = NULL)
[10:33:08.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.285]                 }
[10:33:08.285]                 ...future.workdir <- getwd()
[10:33:08.285]             }
[10:33:08.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.285]         }
[10:33:08.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.285]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.285]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.285]             base::names(...future.oldOptions))
[10:33:08.285]     }
[10:33:08.285]     if (FALSE) {
[10:33:08.285]     }
[10:33:08.285]     else {
[10:33:08.285]         if (TRUE) {
[10:33:08.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.285]                 open = "w")
[10:33:08.285]         }
[10:33:08.285]         else {
[10:33:08.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.285]         }
[10:33:08.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.285]             base::sink(type = "output", split = FALSE)
[10:33:08.285]             base::close(...future.stdout)
[10:33:08.285]         }, add = TRUE)
[10:33:08.285]     }
[10:33:08.285]     ...future.frame <- base::sys.nframe()
[10:33:08.285]     ...future.conditions <- base::list()
[10:33:08.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.285]     if (FALSE) {
[10:33:08.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.285]     }
[10:33:08.285]     ...future.result <- base::tryCatch({
[10:33:08.285]         base::withCallingHandlers({
[10:33:08.285]             ...future.value <- base::withVisible(base::local({
[10:33:08.285]                 withCallingHandlers({
[10:33:08.285]                   {
[10:33:08.285]                     x["a"] <- list(1)
[10:33:08.285]                     x
[10:33:08.285]                   }
[10:33:08.285]                 }, immediateCondition = function(cond) {
[10:33:08.285]                   save_rds <- function (object, pathname, ...) 
[10:33:08.285]                   {
[10:33:08.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.285]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.285]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.285]                         fi_tmp[["mtime"]])
[10:33:08.285]                     }
[10:33:08.285]                     tryCatch({
[10:33:08.285]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.285]                     }, error = function(ex) {
[10:33:08.285]                       msg <- conditionMessage(ex)
[10:33:08.285]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.285]                         fi_tmp[["mtime"]], msg)
[10:33:08.285]                       ex$message <- msg
[10:33:08.285]                       stop(ex)
[10:33:08.285]                     })
[10:33:08.285]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.285]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.285]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.285]                       fi <- file.info(pathname)
[10:33:08.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.285]                         fi[["size"]], fi[["mtime"]])
[10:33:08.285]                       stop(msg)
[10:33:08.285]                     }
[10:33:08.285]                     invisible(pathname)
[10:33:08.285]                   }
[10:33:08.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.285]                     rootPath = tempdir()) 
[10:33:08.285]                   {
[10:33:08.285]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.285]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.285]                       tmpdir = path, fileext = ".rds")
[10:33:08.285]                     save_rds(obj, file)
[10:33:08.285]                   }
[10:33:08.285]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.285]                   {
[10:33:08.285]                     inherits <- base::inherits
[10:33:08.285]                     invokeRestart <- base::invokeRestart
[10:33:08.285]                     is.null <- base::is.null
[10:33:08.285]                     muffled <- FALSE
[10:33:08.285]                     if (inherits(cond, "message")) {
[10:33:08.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.285]                       if (muffled) 
[10:33:08.285]                         invokeRestart("muffleMessage")
[10:33:08.285]                     }
[10:33:08.285]                     else if (inherits(cond, "warning")) {
[10:33:08.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.285]                       if (muffled) 
[10:33:08.285]                         invokeRestart("muffleWarning")
[10:33:08.285]                     }
[10:33:08.285]                     else if (inherits(cond, "condition")) {
[10:33:08.285]                       if (!is.null(pattern)) {
[10:33:08.285]                         computeRestarts <- base::computeRestarts
[10:33:08.285]                         grepl <- base::grepl
[10:33:08.285]                         restarts <- computeRestarts(cond)
[10:33:08.285]                         for (restart in restarts) {
[10:33:08.285]                           name <- restart$name
[10:33:08.285]                           if (is.null(name)) 
[10:33:08.285]                             next
[10:33:08.285]                           if (!grepl(pattern, name)) 
[10:33:08.285]                             next
[10:33:08.285]                           invokeRestart(restart)
[10:33:08.285]                           muffled <- TRUE
[10:33:08.285]                           break
[10:33:08.285]                         }
[10:33:08.285]                       }
[10:33:08.285]                     }
[10:33:08.285]                     invisible(muffled)
[10:33:08.285]                   }
[10:33:08.285]                   muffleCondition(cond)
[10:33:08.285]                 })
[10:33:08.285]             }))
[10:33:08.285]             future::FutureResult(value = ...future.value$value, 
[10:33:08.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.285]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.285]                     ...future.globalenv.names))
[10:33:08.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.285]         }, condition = base::local({
[10:33:08.285]             c <- base::c
[10:33:08.285]             inherits <- base::inherits
[10:33:08.285]             invokeRestart <- base::invokeRestart
[10:33:08.285]             length <- base::length
[10:33:08.285]             list <- base::list
[10:33:08.285]             seq.int <- base::seq.int
[10:33:08.285]             signalCondition <- base::signalCondition
[10:33:08.285]             sys.calls <- base::sys.calls
[10:33:08.285]             `[[` <- base::`[[`
[10:33:08.285]             `+` <- base::`+`
[10:33:08.285]             `<<-` <- base::`<<-`
[10:33:08.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.285]                   3L)]
[10:33:08.285]             }
[10:33:08.285]             function(cond) {
[10:33:08.285]                 is_error <- inherits(cond, "error")
[10:33:08.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.285]                   NULL)
[10:33:08.285]                 if (is_error) {
[10:33:08.285]                   sessionInformation <- function() {
[10:33:08.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.285]                       search = base::search(), system = base::Sys.info())
[10:33:08.285]                   }
[10:33:08.285]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.285]                     cond$call), session = sessionInformation(), 
[10:33:08.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.285]                   signalCondition(cond)
[10:33:08.285]                 }
[10:33:08.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.285]                 "immediateCondition"))) {
[10:33:08.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.285]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.285]                   if (TRUE && !signal) {
[10:33:08.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.285]                     {
[10:33:08.285]                       inherits <- base::inherits
[10:33:08.285]                       invokeRestart <- base::invokeRestart
[10:33:08.285]                       is.null <- base::is.null
[10:33:08.285]                       muffled <- FALSE
[10:33:08.285]                       if (inherits(cond, "message")) {
[10:33:08.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.285]                         if (muffled) 
[10:33:08.285]                           invokeRestart("muffleMessage")
[10:33:08.285]                       }
[10:33:08.285]                       else if (inherits(cond, "warning")) {
[10:33:08.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.285]                         if (muffled) 
[10:33:08.285]                           invokeRestart("muffleWarning")
[10:33:08.285]                       }
[10:33:08.285]                       else if (inherits(cond, "condition")) {
[10:33:08.285]                         if (!is.null(pattern)) {
[10:33:08.285]                           computeRestarts <- base::computeRestarts
[10:33:08.285]                           grepl <- base::grepl
[10:33:08.285]                           restarts <- computeRestarts(cond)
[10:33:08.285]                           for (restart in restarts) {
[10:33:08.285]                             name <- restart$name
[10:33:08.285]                             if (is.null(name)) 
[10:33:08.285]                               next
[10:33:08.285]                             if (!grepl(pattern, name)) 
[10:33:08.285]                               next
[10:33:08.285]                             invokeRestart(restart)
[10:33:08.285]                             muffled <- TRUE
[10:33:08.285]                             break
[10:33:08.285]                           }
[10:33:08.285]                         }
[10:33:08.285]                       }
[10:33:08.285]                       invisible(muffled)
[10:33:08.285]                     }
[10:33:08.285]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.285]                   }
[10:33:08.285]                 }
[10:33:08.285]                 else {
[10:33:08.285]                   if (TRUE) {
[10:33:08.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.285]                     {
[10:33:08.285]                       inherits <- base::inherits
[10:33:08.285]                       invokeRestart <- base::invokeRestart
[10:33:08.285]                       is.null <- base::is.null
[10:33:08.285]                       muffled <- FALSE
[10:33:08.285]                       if (inherits(cond, "message")) {
[10:33:08.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.285]                         if (muffled) 
[10:33:08.285]                           invokeRestart("muffleMessage")
[10:33:08.285]                       }
[10:33:08.285]                       else if (inherits(cond, "warning")) {
[10:33:08.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.285]                         if (muffled) 
[10:33:08.285]                           invokeRestart("muffleWarning")
[10:33:08.285]                       }
[10:33:08.285]                       else if (inherits(cond, "condition")) {
[10:33:08.285]                         if (!is.null(pattern)) {
[10:33:08.285]                           computeRestarts <- base::computeRestarts
[10:33:08.285]                           grepl <- base::grepl
[10:33:08.285]                           restarts <- computeRestarts(cond)
[10:33:08.285]                           for (restart in restarts) {
[10:33:08.285]                             name <- restart$name
[10:33:08.285]                             if (is.null(name)) 
[10:33:08.285]                               next
[10:33:08.285]                             if (!grepl(pattern, name)) 
[10:33:08.285]                               next
[10:33:08.285]                             invokeRestart(restart)
[10:33:08.285]                             muffled <- TRUE
[10:33:08.285]                             break
[10:33:08.285]                           }
[10:33:08.285]                         }
[10:33:08.285]                       }
[10:33:08.285]                       invisible(muffled)
[10:33:08.285]                     }
[10:33:08.285]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.285]                   }
[10:33:08.285]                 }
[10:33:08.285]             }
[10:33:08.285]         }))
[10:33:08.285]     }, error = function(ex) {
[10:33:08.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.285]                 ...future.rng), started = ...future.startTime, 
[10:33:08.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.285]             version = "1.8"), class = "FutureResult")
[10:33:08.285]     }, finally = {
[10:33:08.285]         if (!identical(...future.workdir, getwd())) 
[10:33:08.285]             setwd(...future.workdir)
[10:33:08.285]         {
[10:33:08.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.285]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.285]             }
[10:33:08.285]             base::options(...future.oldOptions)
[10:33:08.285]             if (.Platform$OS.type == "windows") {
[10:33:08.285]                 old_names <- names(...future.oldEnvVars)
[10:33:08.285]                 envs <- base::Sys.getenv()
[10:33:08.285]                 names <- names(envs)
[10:33:08.285]                 common <- intersect(names, old_names)
[10:33:08.285]                 added <- setdiff(names, old_names)
[10:33:08.285]                 removed <- setdiff(old_names, names)
[10:33:08.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.285]                   envs[common]]
[10:33:08.285]                 NAMES <- toupper(changed)
[10:33:08.285]                 args <- list()
[10:33:08.285]                 for (kk in seq_along(NAMES)) {
[10:33:08.285]                   name <- changed[[kk]]
[10:33:08.285]                   NAME <- NAMES[[kk]]
[10:33:08.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.285]                     next
[10:33:08.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.285]                 }
[10:33:08.285]                 NAMES <- toupper(added)
[10:33:08.285]                 for (kk in seq_along(NAMES)) {
[10:33:08.285]                   name <- added[[kk]]
[10:33:08.285]                   NAME <- NAMES[[kk]]
[10:33:08.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.285]                     next
[10:33:08.285]                   args[[name]] <- ""
[10:33:08.285]                 }
[10:33:08.285]                 NAMES <- toupper(removed)
[10:33:08.285]                 for (kk in seq_along(NAMES)) {
[10:33:08.285]                   name <- removed[[kk]]
[10:33:08.285]                   NAME <- NAMES[[kk]]
[10:33:08.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.285]                     next
[10:33:08.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.285]                 }
[10:33:08.285]                 if (length(args) > 0) 
[10:33:08.285]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.285]             }
[10:33:08.285]             else {
[10:33:08.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.285]             }
[10:33:08.285]             {
[10:33:08.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.285]                   0L) {
[10:33:08.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.285]                   base::options(opts)
[10:33:08.285]                 }
[10:33:08.285]                 {
[10:33:08.285]                   {
[10:33:08.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.285]                     NULL
[10:33:08.285]                   }
[10:33:08.285]                   options(future.plan = NULL)
[10:33:08.285]                   if (is.na(NA_character_)) 
[10:33:08.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.285]                     .init = FALSE)
[10:33:08.285]                 }
[10:33:08.285]             }
[10:33:08.285]         }
[10:33:08.285]     })
[10:33:08.285]     if (TRUE) {
[10:33:08.285]         base::sink(type = "output", split = FALSE)
[10:33:08.285]         if (TRUE) {
[10:33:08.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.285]         }
[10:33:08.285]         else {
[10:33:08.285]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.285]         }
[10:33:08.285]         base::close(...future.stdout)
[10:33:08.285]         ...future.stdout <- NULL
[10:33:08.285]     }
[10:33:08.285]     ...future.result$conditions <- ...future.conditions
[10:33:08.285]     ...future.result$finished <- base::Sys.time()
[10:33:08.285]     ...future.result
[10:33:08.285] }
[10:33:08.288] assign_globals() ...
[10:33:08.288] List of 1
[10:33:08.288]  $ x: list()
[10:33:08.288]  - attr(*, "where")=List of 1
[10:33:08.288]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.288]  - attr(*, "resolved")= logi TRUE
[10:33:08.288]  - attr(*, "total_size")= num 0
[10:33:08.288]  - attr(*, "already-done")= logi TRUE
[10:33:08.291] - copied ‘x’ to environment
[10:33:08.291] assign_globals() ... done
[10:33:08.291] requestCore(): workers = 2
[10:33:08.293] MulticoreFuture started
[10:33:08.293] - Launch lazy future ... done
[10:33:08.293] run() for ‘MulticoreFuture’ ... done
[10:33:08.294] result() for MulticoreFuture ...
[10:33:08.294] plan(): Setting new future strategy stack:
[10:33:08.294] List of future strategies:
[10:33:08.294] 1. sequential:
[10:33:08.294]    - args: function (..., envir = parent.frame())
[10:33:08.294]    - tweaked: FALSE
[10:33:08.294]    - call: NULL
[10:33:08.295] plan(): nbrOfWorkers() = 1
[10:33:08.297] plan(): Setting new future strategy stack:
[10:33:08.297] List of future strategies:
[10:33:08.297] 1. multicore:
[10:33:08.297]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.297]    - tweaked: FALSE
[10:33:08.297]    - call: plan(strategy)
[10:33:08.302] plan(): nbrOfWorkers() = 2
[10:33:08.303] result() for MulticoreFuture ...
[10:33:08.304] result() for MulticoreFuture ... done
[10:33:08.304] result() for MulticoreFuture ... done
[10:33:08.304] result() for MulticoreFuture ...
[10:33:08.304] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.305] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.305] Searching for globals...
[10:33:08.308] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:08.308] Searching for globals ... DONE
[10:33:08.309] Resolving globals: TRUE
[10:33:08.309] Resolving any globals that are futures ...
[10:33:08.309] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:08.309] Resolving any globals that are futures ... DONE
[10:33:08.309] Resolving futures part of globals (recursively) ...
[10:33:08.310] resolve() on list ...
[10:33:08.310]  recursive: 99
[10:33:08.310]  length: 1
[10:33:08.310]  elements: ‘x’
[10:33:08.310]  length: 0 (resolved future 1)
[10:33:08.310] resolve() on list ... DONE
[10:33:08.311] - globals: [1] ‘x’
[10:33:08.311] Resolving futures part of globals (recursively) ... DONE
[10:33:08.311] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:08.311] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:08.311] - globals: [1] ‘x’
[10:33:08.312] 
[10:33:08.312] getGlobalsAndPackages() ... DONE
[10:33:08.312] run() for ‘Future’ ...
[10:33:08.312] - state: ‘created’
[10:33:08.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.316] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.316]   - Field: ‘label’
[10:33:08.317]   - Field: ‘local’
[10:33:08.317]   - Field: ‘owner’
[10:33:08.317]   - Field: ‘envir’
[10:33:08.317]   - Field: ‘workers’
[10:33:08.317]   - Field: ‘packages’
[10:33:08.317]   - Field: ‘gc’
[10:33:08.317]   - Field: ‘job’
[10:33:08.317]   - Field: ‘conditions’
[10:33:08.318]   - Field: ‘expr’
[10:33:08.318]   - Field: ‘uuid’
[10:33:08.318]   - Field: ‘seed’
[10:33:08.318]   - Field: ‘version’
[10:33:08.318]   - Field: ‘result’
[10:33:08.318]   - Field: ‘asynchronous’
[10:33:08.318]   - Field: ‘calls’
[10:33:08.318]   - Field: ‘globals’
[10:33:08.318]   - Field: ‘stdout’
[10:33:08.318]   - Field: ‘earlySignal’
[10:33:08.319]   - Field: ‘lazy’
[10:33:08.319]   - Field: ‘state’
[10:33:08.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.319] - Launch lazy future ...
[10:33:08.319] Packages needed by the future expression (n = 0): <none>
[10:33:08.322] Packages needed by future strategies (n = 0): <none>
[10:33:08.322] {
[10:33:08.322]     {
[10:33:08.322]         {
[10:33:08.322]             ...future.startTime <- base::Sys.time()
[10:33:08.322]             {
[10:33:08.322]                 {
[10:33:08.322]                   {
[10:33:08.322]                     {
[10:33:08.322]                       base::local({
[10:33:08.322]                         has_future <- base::requireNamespace("future", 
[10:33:08.322]                           quietly = TRUE)
[10:33:08.322]                         if (has_future) {
[10:33:08.322]                           ns <- base::getNamespace("future")
[10:33:08.322]                           version <- ns[[".package"]][["version"]]
[10:33:08.322]                           if (is.null(version)) 
[10:33:08.322]                             version <- utils::packageVersion("future")
[10:33:08.322]                         }
[10:33:08.322]                         else {
[10:33:08.322]                           version <- NULL
[10:33:08.322]                         }
[10:33:08.322]                         if (!has_future || version < "1.8.0") {
[10:33:08.322]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.322]                             "", base::R.version$version.string), 
[10:33:08.322]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.322]                               "release", "version")], collapse = " "), 
[10:33:08.322]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.322]                             info)
[10:33:08.322]                           info <- base::paste(info, collapse = "; ")
[10:33:08.322]                           if (!has_future) {
[10:33:08.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.322]                               info)
[10:33:08.322]                           }
[10:33:08.322]                           else {
[10:33:08.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.322]                               info, version)
[10:33:08.322]                           }
[10:33:08.322]                           base::stop(msg)
[10:33:08.322]                         }
[10:33:08.322]                       })
[10:33:08.322]                     }
[10:33:08.322]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.322]                     base::options(mc.cores = 1L)
[10:33:08.322]                   }
[10:33:08.322]                   ...future.strategy.old <- future::plan("list")
[10:33:08.322]                   options(future.plan = NULL)
[10:33:08.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.322]                 }
[10:33:08.322]                 ...future.workdir <- getwd()
[10:33:08.322]             }
[10:33:08.322]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.322]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.322]         }
[10:33:08.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.322]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.322]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.322]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.322]             base::names(...future.oldOptions))
[10:33:08.322]     }
[10:33:08.322]     if (FALSE) {
[10:33:08.322]     }
[10:33:08.322]     else {
[10:33:08.322]         if (TRUE) {
[10:33:08.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.322]                 open = "w")
[10:33:08.322]         }
[10:33:08.322]         else {
[10:33:08.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.322]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.322]         }
[10:33:08.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.322]             base::sink(type = "output", split = FALSE)
[10:33:08.322]             base::close(...future.stdout)
[10:33:08.322]         }, add = TRUE)
[10:33:08.322]     }
[10:33:08.322]     ...future.frame <- base::sys.nframe()
[10:33:08.322]     ...future.conditions <- base::list()
[10:33:08.322]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.322]     if (FALSE) {
[10:33:08.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.322]     }
[10:33:08.322]     ...future.result <- base::tryCatch({
[10:33:08.322]         base::withCallingHandlers({
[10:33:08.322]             ...future.value <- base::withVisible(base::local({
[10:33:08.322]                 withCallingHandlers({
[10:33:08.322]                   {
[10:33:08.322]                     x["a"] <- list(1)
[10:33:08.322]                     x
[10:33:08.322]                   }
[10:33:08.322]                 }, immediateCondition = function(cond) {
[10:33:08.322]                   save_rds <- function (object, pathname, ...) 
[10:33:08.322]                   {
[10:33:08.322]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.322]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.322]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.322]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.322]                         fi_tmp[["mtime"]])
[10:33:08.322]                     }
[10:33:08.322]                     tryCatch({
[10:33:08.322]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.322]                     }, error = function(ex) {
[10:33:08.322]                       msg <- conditionMessage(ex)
[10:33:08.322]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.322]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.322]                         fi_tmp[["mtime"]], msg)
[10:33:08.322]                       ex$message <- msg
[10:33:08.322]                       stop(ex)
[10:33:08.322]                     })
[10:33:08.322]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.322]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.322]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.322]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.322]                       fi <- file.info(pathname)
[10:33:08.322]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.322]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.322]                         fi[["size"]], fi[["mtime"]])
[10:33:08.322]                       stop(msg)
[10:33:08.322]                     }
[10:33:08.322]                     invisible(pathname)
[10:33:08.322]                   }
[10:33:08.322]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.322]                     rootPath = tempdir()) 
[10:33:08.322]                   {
[10:33:08.322]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.322]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.322]                       tmpdir = path, fileext = ".rds")
[10:33:08.322]                     save_rds(obj, file)
[10:33:08.322]                   }
[10:33:08.322]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.322]                   {
[10:33:08.322]                     inherits <- base::inherits
[10:33:08.322]                     invokeRestart <- base::invokeRestart
[10:33:08.322]                     is.null <- base::is.null
[10:33:08.322]                     muffled <- FALSE
[10:33:08.322]                     if (inherits(cond, "message")) {
[10:33:08.322]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.322]                       if (muffled) 
[10:33:08.322]                         invokeRestart("muffleMessage")
[10:33:08.322]                     }
[10:33:08.322]                     else if (inherits(cond, "warning")) {
[10:33:08.322]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.322]                       if (muffled) 
[10:33:08.322]                         invokeRestart("muffleWarning")
[10:33:08.322]                     }
[10:33:08.322]                     else if (inherits(cond, "condition")) {
[10:33:08.322]                       if (!is.null(pattern)) {
[10:33:08.322]                         computeRestarts <- base::computeRestarts
[10:33:08.322]                         grepl <- base::grepl
[10:33:08.322]                         restarts <- computeRestarts(cond)
[10:33:08.322]                         for (restart in restarts) {
[10:33:08.322]                           name <- restart$name
[10:33:08.322]                           if (is.null(name)) 
[10:33:08.322]                             next
[10:33:08.322]                           if (!grepl(pattern, name)) 
[10:33:08.322]                             next
[10:33:08.322]                           invokeRestart(restart)
[10:33:08.322]                           muffled <- TRUE
[10:33:08.322]                           break
[10:33:08.322]                         }
[10:33:08.322]                       }
[10:33:08.322]                     }
[10:33:08.322]                     invisible(muffled)
[10:33:08.322]                   }
[10:33:08.322]                   muffleCondition(cond)
[10:33:08.322]                 })
[10:33:08.322]             }))
[10:33:08.322]             future::FutureResult(value = ...future.value$value, 
[10:33:08.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.322]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.322]                     ...future.globalenv.names))
[10:33:08.322]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.322]         }, condition = base::local({
[10:33:08.322]             c <- base::c
[10:33:08.322]             inherits <- base::inherits
[10:33:08.322]             invokeRestart <- base::invokeRestart
[10:33:08.322]             length <- base::length
[10:33:08.322]             list <- base::list
[10:33:08.322]             seq.int <- base::seq.int
[10:33:08.322]             signalCondition <- base::signalCondition
[10:33:08.322]             sys.calls <- base::sys.calls
[10:33:08.322]             `[[` <- base::`[[`
[10:33:08.322]             `+` <- base::`+`
[10:33:08.322]             `<<-` <- base::`<<-`
[10:33:08.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.322]                   3L)]
[10:33:08.322]             }
[10:33:08.322]             function(cond) {
[10:33:08.322]                 is_error <- inherits(cond, "error")
[10:33:08.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.322]                   NULL)
[10:33:08.322]                 if (is_error) {
[10:33:08.322]                   sessionInformation <- function() {
[10:33:08.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.322]                       search = base::search(), system = base::Sys.info())
[10:33:08.322]                   }
[10:33:08.322]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.322]                     cond$call), session = sessionInformation(), 
[10:33:08.322]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.322]                   signalCondition(cond)
[10:33:08.322]                 }
[10:33:08.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.322]                 "immediateCondition"))) {
[10:33:08.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.322]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.322]                   if (TRUE && !signal) {
[10:33:08.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.322]                     {
[10:33:08.322]                       inherits <- base::inherits
[10:33:08.322]                       invokeRestart <- base::invokeRestart
[10:33:08.322]                       is.null <- base::is.null
[10:33:08.322]                       muffled <- FALSE
[10:33:08.322]                       if (inherits(cond, "message")) {
[10:33:08.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.322]                         if (muffled) 
[10:33:08.322]                           invokeRestart("muffleMessage")
[10:33:08.322]                       }
[10:33:08.322]                       else if (inherits(cond, "warning")) {
[10:33:08.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.322]                         if (muffled) 
[10:33:08.322]                           invokeRestart("muffleWarning")
[10:33:08.322]                       }
[10:33:08.322]                       else if (inherits(cond, "condition")) {
[10:33:08.322]                         if (!is.null(pattern)) {
[10:33:08.322]                           computeRestarts <- base::computeRestarts
[10:33:08.322]                           grepl <- base::grepl
[10:33:08.322]                           restarts <- computeRestarts(cond)
[10:33:08.322]                           for (restart in restarts) {
[10:33:08.322]                             name <- restart$name
[10:33:08.322]                             if (is.null(name)) 
[10:33:08.322]                               next
[10:33:08.322]                             if (!grepl(pattern, name)) 
[10:33:08.322]                               next
[10:33:08.322]                             invokeRestart(restart)
[10:33:08.322]                             muffled <- TRUE
[10:33:08.322]                             break
[10:33:08.322]                           }
[10:33:08.322]                         }
[10:33:08.322]                       }
[10:33:08.322]                       invisible(muffled)
[10:33:08.322]                     }
[10:33:08.322]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.322]                   }
[10:33:08.322]                 }
[10:33:08.322]                 else {
[10:33:08.322]                   if (TRUE) {
[10:33:08.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.322]                     {
[10:33:08.322]                       inherits <- base::inherits
[10:33:08.322]                       invokeRestart <- base::invokeRestart
[10:33:08.322]                       is.null <- base::is.null
[10:33:08.322]                       muffled <- FALSE
[10:33:08.322]                       if (inherits(cond, "message")) {
[10:33:08.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.322]                         if (muffled) 
[10:33:08.322]                           invokeRestart("muffleMessage")
[10:33:08.322]                       }
[10:33:08.322]                       else if (inherits(cond, "warning")) {
[10:33:08.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.322]                         if (muffled) 
[10:33:08.322]                           invokeRestart("muffleWarning")
[10:33:08.322]                       }
[10:33:08.322]                       else if (inherits(cond, "condition")) {
[10:33:08.322]                         if (!is.null(pattern)) {
[10:33:08.322]                           computeRestarts <- base::computeRestarts
[10:33:08.322]                           grepl <- base::grepl
[10:33:08.322]                           restarts <- computeRestarts(cond)
[10:33:08.322]                           for (restart in restarts) {
[10:33:08.322]                             name <- restart$name
[10:33:08.322]                             if (is.null(name)) 
[10:33:08.322]                               next
[10:33:08.322]                             if (!grepl(pattern, name)) 
[10:33:08.322]                               next
[10:33:08.322]                             invokeRestart(restart)
[10:33:08.322]                             muffled <- TRUE
[10:33:08.322]                             break
[10:33:08.322]                           }
[10:33:08.322]                         }
[10:33:08.322]                       }
[10:33:08.322]                       invisible(muffled)
[10:33:08.322]                     }
[10:33:08.322]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.322]                   }
[10:33:08.322]                 }
[10:33:08.322]             }
[10:33:08.322]         }))
[10:33:08.322]     }, error = function(ex) {
[10:33:08.322]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.322]                 ...future.rng), started = ...future.startTime, 
[10:33:08.322]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.322]             version = "1.8"), class = "FutureResult")
[10:33:08.322]     }, finally = {
[10:33:08.322]         if (!identical(...future.workdir, getwd())) 
[10:33:08.322]             setwd(...future.workdir)
[10:33:08.322]         {
[10:33:08.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.322]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.322]             }
[10:33:08.322]             base::options(...future.oldOptions)
[10:33:08.322]             if (.Platform$OS.type == "windows") {
[10:33:08.322]                 old_names <- names(...future.oldEnvVars)
[10:33:08.322]                 envs <- base::Sys.getenv()
[10:33:08.322]                 names <- names(envs)
[10:33:08.322]                 common <- intersect(names, old_names)
[10:33:08.322]                 added <- setdiff(names, old_names)
[10:33:08.322]                 removed <- setdiff(old_names, names)
[10:33:08.322]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.322]                   envs[common]]
[10:33:08.322]                 NAMES <- toupper(changed)
[10:33:08.322]                 args <- list()
[10:33:08.322]                 for (kk in seq_along(NAMES)) {
[10:33:08.322]                   name <- changed[[kk]]
[10:33:08.322]                   NAME <- NAMES[[kk]]
[10:33:08.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.322]                     next
[10:33:08.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.322]                 }
[10:33:08.322]                 NAMES <- toupper(added)
[10:33:08.322]                 for (kk in seq_along(NAMES)) {
[10:33:08.322]                   name <- added[[kk]]
[10:33:08.322]                   NAME <- NAMES[[kk]]
[10:33:08.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.322]                     next
[10:33:08.322]                   args[[name]] <- ""
[10:33:08.322]                 }
[10:33:08.322]                 NAMES <- toupper(removed)
[10:33:08.322]                 for (kk in seq_along(NAMES)) {
[10:33:08.322]                   name <- removed[[kk]]
[10:33:08.322]                   NAME <- NAMES[[kk]]
[10:33:08.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.322]                     next
[10:33:08.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.322]                 }
[10:33:08.322]                 if (length(args) > 0) 
[10:33:08.322]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.322]             }
[10:33:08.322]             else {
[10:33:08.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.322]             }
[10:33:08.322]             {
[10:33:08.322]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.322]                   0L) {
[10:33:08.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.322]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.322]                   base::options(opts)
[10:33:08.322]                 }
[10:33:08.322]                 {
[10:33:08.322]                   {
[10:33:08.322]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.322]                     NULL
[10:33:08.322]                   }
[10:33:08.322]                   options(future.plan = NULL)
[10:33:08.322]                   if (is.na(NA_character_)) 
[10:33:08.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.322]                     .init = FALSE)
[10:33:08.322]                 }
[10:33:08.322]             }
[10:33:08.322]         }
[10:33:08.322]     })
[10:33:08.322]     if (TRUE) {
[10:33:08.322]         base::sink(type = "output", split = FALSE)
[10:33:08.322]         if (TRUE) {
[10:33:08.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.322]         }
[10:33:08.322]         else {
[10:33:08.322]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.322]         }
[10:33:08.322]         base::close(...future.stdout)
[10:33:08.322]         ...future.stdout <- NULL
[10:33:08.322]     }
[10:33:08.322]     ...future.result$conditions <- ...future.conditions
[10:33:08.322]     ...future.result$finished <- base::Sys.time()
[10:33:08.322]     ...future.result
[10:33:08.322] }
[10:33:08.325] assign_globals() ...
[10:33:08.325] List of 1
[10:33:08.325]  $ x: list()
[10:33:08.325]  - attr(*, "where")=List of 1
[10:33:08.325]   ..$ x:<environment: R_EmptyEnv> 
[10:33:08.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.325]  - attr(*, "resolved")= logi TRUE
[10:33:08.325]  - attr(*, "total_size")= num 0
[10:33:08.325]  - attr(*, "already-done")= logi TRUE
[10:33:08.328] - copied ‘x’ to environment
[10:33:08.328] assign_globals() ... done
[10:33:08.328] requestCore(): workers = 2
[10:33:08.330] MulticoreFuture started
[10:33:08.330] - Launch lazy future ... done
[10:33:08.330] run() for ‘MulticoreFuture’ ... done
[10:33:08.331] result() for MulticoreFuture ...
[10:33:08.331] plan(): Setting new future strategy stack:
[10:33:08.331] List of future strategies:
[10:33:08.331] 1. sequential:
[10:33:08.331]    - args: function (..., envir = parent.frame())
[10:33:08.331]    - tweaked: FALSE
[10:33:08.331]    - call: NULL
[10:33:08.332] plan(): nbrOfWorkers() = 1
[10:33:08.334] plan(): Setting new future strategy stack:
[10:33:08.334] List of future strategies:
[10:33:08.334] 1. multicore:
[10:33:08.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.334]    - tweaked: FALSE
[10:33:08.334]    - call: plan(strategy)
[10:33:08.339] plan(): nbrOfWorkers() = 2
[10:33:08.340] result() for MulticoreFuture ...
[10:33:08.340] result() for MulticoreFuture ... done
[10:33:08.340] result() for MulticoreFuture ... done
[10:33:08.341] result() for MulticoreFuture ...
[10:33:08.341] result() for MulticoreFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.342] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.342] Searching for globals...
[10:33:08.345] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:33:08.345] Searching for globals ... DONE
[10:33:08.345] Resolving globals: TRUE
[10:33:08.346] Resolving any globals that are futures ...
[10:33:08.346] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:33:08.346] Resolving any globals that are futures ... DONE
[10:33:08.346] Resolving futures part of globals (recursively) ...
[10:33:08.347] resolve() on list ...
[10:33:08.347]  recursive: 99
[10:33:08.347]  length: 2
[10:33:08.347]  elements: ‘x’, ‘name’
[10:33:08.347]  length: 1 (resolved future 1)
[10:33:08.347]  length: 0 (resolved future 2)
[10:33:08.347] resolve() on list ... DONE
[10:33:08.348] - globals: [2] ‘x’, ‘name’
[10:33:08.348] Resolving futures part of globals (recursively) ... DONE
[10:33:08.348] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:08.348] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[10:33:08.349] - globals: [2] ‘x’, ‘name’
[10:33:08.349] 
[10:33:08.349] getGlobalsAndPackages() ... DONE
[10:33:08.349] run() for ‘Future’ ...
[10:33:08.349] - state: ‘created’
[10:33:08.349] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:08.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:08.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:08.354]   - Field: ‘label’
[10:33:08.354]   - Field: ‘local’
[10:33:08.354]   - Field: ‘owner’
[10:33:08.354]   - Field: ‘envir’
[10:33:08.354]   - Field: ‘workers’
[10:33:08.354]   - Field: ‘packages’
[10:33:08.354]   - Field: ‘gc’
[10:33:08.355]   - Field: ‘job’
[10:33:08.355]   - Field: ‘conditions’
[10:33:08.355]   - Field: ‘expr’
[10:33:08.355]   - Field: ‘uuid’
[10:33:08.355]   - Field: ‘seed’
[10:33:08.355]   - Field: ‘version’
[10:33:08.355]   - Field: ‘result’
[10:33:08.355]   - Field: ‘asynchronous’
[10:33:08.355]   - Field: ‘calls’
[10:33:08.356]   - Field: ‘globals’
[10:33:08.356]   - Field: ‘stdout’
[10:33:08.356]   - Field: ‘earlySignal’
[10:33:08.356]   - Field: ‘lazy’
[10:33:08.356]   - Field: ‘state’
[10:33:08.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:08.356] - Launch lazy future ...
[10:33:08.357] Packages needed by the future expression (n = 0): <none>
[10:33:08.357] Packages needed by future strategies (n = 0): <none>
[10:33:08.357] {
[10:33:08.357]     {
[10:33:08.357]         {
[10:33:08.357]             ...future.startTime <- base::Sys.time()
[10:33:08.357]             {
[10:33:08.357]                 {
[10:33:08.357]                   {
[10:33:08.357]                     {
[10:33:08.357]                       base::local({
[10:33:08.357]                         has_future <- base::requireNamespace("future", 
[10:33:08.357]                           quietly = TRUE)
[10:33:08.357]                         if (has_future) {
[10:33:08.357]                           ns <- base::getNamespace("future")
[10:33:08.357]                           version <- ns[[".package"]][["version"]]
[10:33:08.357]                           if (is.null(version)) 
[10:33:08.357]                             version <- utils::packageVersion("future")
[10:33:08.357]                         }
[10:33:08.357]                         else {
[10:33:08.357]                           version <- NULL
[10:33:08.357]                         }
[10:33:08.357]                         if (!has_future || version < "1.8.0") {
[10:33:08.357]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.357]                             "", base::R.version$version.string), 
[10:33:08.357]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.357]                               "release", "version")], collapse = " "), 
[10:33:08.357]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.357]                             info)
[10:33:08.357]                           info <- base::paste(info, collapse = "; ")
[10:33:08.357]                           if (!has_future) {
[10:33:08.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.357]                               info)
[10:33:08.357]                           }
[10:33:08.357]                           else {
[10:33:08.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.357]                               info, version)
[10:33:08.357]                           }
[10:33:08.357]                           base::stop(msg)
[10:33:08.357]                         }
[10:33:08.357]                       })
[10:33:08.357]                     }
[10:33:08.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.357]                     base::options(mc.cores = 1L)
[10:33:08.357]                   }
[10:33:08.357]                   ...future.strategy.old <- future::plan("list")
[10:33:08.357]                   options(future.plan = NULL)
[10:33:08.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.357]                 }
[10:33:08.357]                 ...future.workdir <- getwd()
[10:33:08.357]             }
[10:33:08.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.357]         }
[10:33:08.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.357]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.357]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.357]             base::names(...future.oldOptions))
[10:33:08.357]     }
[10:33:08.357]     if (FALSE) {
[10:33:08.357]     }
[10:33:08.357]     else {
[10:33:08.357]         if (TRUE) {
[10:33:08.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.357]                 open = "w")
[10:33:08.357]         }
[10:33:08.357]         else {
[10:33:08.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.357]         }
[10:33:08.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.357]             base::sink(type = "output", split = FALSE)
[10:33:08.357]             base::close(...future.stdout)
[10:33:08.357]         }, add = TRUE)
[10:33:08.357]     }
[10:33:08.357]     ...future.frame <- base::sys.nframe()
[10:33:08.357]     ...future.conditions <- base::list()
[10:33:08.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.357]     if (FALSE) {
[10:33:08.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.357]     }
[10:33:08.357]     ...future.result <- base::tryCatch({
[10:33:08.357]         base::withCallingHandlers({
[10:33:08.357]             ...future.value <- base::withVisible(base::local({
[10:33:08.357]                 withCallingHandlers({
[10:33:08.357]                   {
[10:33:08.357]                     x[name] <- list(1)
[10:33:08.357]                     x
[10:33:08.357]                   }
[10:33:08.357]                 }, immediateCondition = function(cond) {
[10:33:08.357]                   save_rds <- function (object, pathname, ...) 
[10:33:08.357]                   {
[10:33:08.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:08.357]                     if (file_test("-f", pathname_tmp)) {
[10:33:08.357]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:08.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.357]                         fi_tmp[["mtime"]])
[10:33:08.357]                     }
[10:33:08.357]                     tryCatch({
[10:33:08.357]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:08.357]                     }, error = function(ex) {
[10:33:08.357]                       msg <- conditionMessage(ex)
[10:33:08.357]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:08.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.357]                         fi_tmp[["mtime"]], msg)
[10:33:08.357]                       ex$message <- msg
[10:33:08.357]                       stop(ex)
[10:33:08.357]                     })
[10:33:08.357]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:08.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:08.357]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:08.357]                       fi_tmp <- file.info(pathname_tmp)
[10:33:08.357]                       fi <- file.info(pathname)
[10:33:08.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:08.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:08.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:08.357]                         fi[["size"]], fi[["mtime"]])
[10:33:08.357]                       stop(msg)
[10:33:08.357]                     }
[10:33:08.357]                     invisible(pathname)
[10:33:08.357]                   }
[10:33:08.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:08.357]                     rootPath = tempdir()) 
[10:33:08.357]                   {
[10:33:08.357]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:08.357]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:08.357]                       tmpdir = path, fileext = ".rds")
[10:33:08.357]                     save_rds(obj, file)
[10:33:08.357]                   }
[10:33:08.357]                   saveImmediateCondition(cond, path = "/tmp/RtmpxfYssj/.future/immediateConditions")
[10:33:08.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.357]                   {
[10:33:08.357]                     inherits <- base::inherits
[10:33:08.357]                     invokeRestart <- base::invokeRestart
[10:33:08.357]                     is.null <- base::is.null
[10:33:08.357]                     muffled <- FALSE
[10:33:08.357]                     if (inherits(cond, "message")) {
[10:33:08.357]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.357]                       if (muffled) 
[10:33:08.357]                         invokeRestart("muffleMessage")
[10:33:08.357]                     }
[10:33:08.357]                     else if (inherits(cond, "warning")) {
[10:33:08.357]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.357]                       if (muffled) 
[10:33:08.357]                         invokeRestart("muffleWarning")
[10:33:08.357]                     }
[10:33:08.357]                     else if (inherits(cond, "condition")) {
[10:33:08.357]                       if (!is.null(pattern)) {
[10:33:08.357]                         computeRestarts <- base::computeRestarts
[10:33:08.357]                         grepl <- base::grepl
[10:33:08.357]                         restarts <- computeRestarts(cond)
[10:33:08.357]                         for (restart in restarts) {
[10:33:08.357]                           name <- restart$name
[10:33:08.357]                           if (is.null(name)) 
[10:33:08.357]                             next
[10:33:08.357]                           if (!grepl(pattern, name)) 
[10:33:08.357]                             next
[10:33:08.357]                           invokeRestart(restart)
[10:33:08.357]                           muffled <- TRUE
[10:33:08.357]                           break
[10:33:08.357]                         }
[10:33:08.357]                       }
[10:33:08.357]                     }
[10:33:08.357]                     invisible(muffled)
[10:33:08.357]                   }
[10:33:08.357]                   muffleCondition(cond)
[10:33:08.357]                 })
[10:33:08.357]             }))
[10:33:08.357]             future::FutureResult(value = ...future.value$value, 
[10:33:08.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.357]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.357]                     ...future.globalenv.names))
[10:33:08.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.357]         }, condition = base::local({
[10:33:08.357]             c <- base::c
[10:33:08.357]             inherits <- base::inherits
[10:33:08.357]             invokeRestart <- base::invokeRestart
[10:33:08.357]             length <- base::length
[10:33:08.357]             list <- base::list
[10:33:08.357]             seq.int <- base::seq.int
[10:33:08.357]             signalCondition <- base::signalCondition
[10:33:08.357]             sys.calls <- base::sys.calls
[10:33:08.357]             `[[` <- base::`[[`
[10:33:08.357]             `+` <- base::`+`
[10:33:08.357]             `<<-` <- base::`<<-`
[10:33:08.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.357]                   3L)]
[10:33:08.357]             }
[10:33:08.357]             function(cond) {
[10:33:08.357]                 is_error <- inherits(cond, "error")
[10:33:08.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.357]                   NULL)
[10:33:08.357]                 if (is_error) {
[10:33:08.357]                   sessionInformation <- function() {
[10:33:08.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.357]                       search = base::search(), system = base::Sys.info())
[10:33:08.357]                   }
[10:33:08.357]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.357]                     cond$call), session = sessionInformation(), 
[10:33:08.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.357]                   signalCondition(cond)
[10:33:08.357]                 }
[10:33:08.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.357]                 "immediateCondition"))) {
[10:33:08.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.357]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.357]                   if (TRUE && !signal) {
[10:33:08.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.357]                     {
[10:33:08.357]                       inherits <- base::inherits
[10:33:08.357]                       invokeRestart <- base::invokeRestart
[10:33:08.357]                       is.null <- base::is.null
[10:33:08.357]                       muffled <- FALSE
[10:33:08.357]                       if (inherits(cond, "message")) {
[10:33:08.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.357]                         if (muffled) 
[10:33:08.357]                           invokeRestart("muffleMessage")
[10:33:08.357]                       }
[10:33:08.357]                       else if (inherits(cond, "warning")) {
[10:33:08.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.357]                         if (muffled) 
[10:33:08.357]                           invokeRestart("muffleWarning")
[10:33:08.357]                       }
[10:33:08.357]                       else if (inherits(cond, "condition")) {
[10:33:08.357]                         if (!is.null(pattern)) {
[10:33:08.357]                           computeRestarts <- base::computeRestarts
[10:33:08.357]                           grepl <- base::grepl
[10:33:08.357]                           restarts <- computeRestarts(cond)
[10:33:08.357]                           for (restart in restarts) {
[10:33:08.357]                             name <- restart$name
[10:33:08.357]                             if (is.null(name)) 
[10:33:08.357]                               next
[10:33:08.357]                             if (!grepl(pattern, name)) 
[10:33:08.357]                               next
[10:33:08.357]                             invokeRestart(restart)
[10:33:08.357]                             muffled <- TRUE
[10:33:08.357]                             break
[10:33:08.357]                           }
[10:33:08.357]                         }
[10:33:08.357]                       }
[10:33:08.357]                       invisible(muffled)
[10:33:08.357]                     }
[10:33:08.357]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.357]                   }
[10:33:08.357]                 }
[10:33:08.357]                 else {
[10:33:08.357]                   if (TRUE) {
[10:33:08.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.357]                     {
[10:33:08.357]                       inherits <- base::inherits
[10:33:08.357]                       invokeRestart <- base::invokeRestart
[10:33:08.357]                       is.null <- base::is.null
[10:33:08.357]                       muffled <- FALSE
[10:33:08.357]                       if (inherits(cond, "message")) {
[10:33:08.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.357]                         if (muffled) 
[10:33:08.357]                           invokeRestart("muffleMessage")
[10:33:08.357]                       }
[10:33:08.357]                       else if (inherits(cond, "warning")) {
[10:33:08.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.357]                         if (muffled) 
[10:33:08.357]                           invokeRestart("muffleWarning")
[10:33:08.357]                       }
[10:33:08.357]                       else if (inherits(cond, "condition")) {
[10:33:08.357]                         if (!is.null(pattern)) {
[10:33:08.357]                           computeRestarts <- base::computeRestarts
[10:33:08.357]                           grepl <- base::grepl
[10:33:08.357]                           restarts <- computeRestarts(cond)
[10:33:08.357]                           for (restart in restarts) {
[10:33:08.357]                             name <- restart$name
[10:33:08.357]                             if (is.null(name)) 
[10:33:08.357]                               next
[10:33:08.357]                             if (!grepl(pattern, name)) 
[10:33:08.357]                               next
[10:33:08.357]                             invokeRestart(restart)
[10:33:08.357]                             muffled <- TRUE
[10:33:08.357]                             break
[10:33:08.357]                           }
[10:33:08.357]                         }
[10:33:08.357]                       }
[10:33:08.357]                       invisible(muffled)
[10:33:08.357]                     }
[10:33:08.357]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.357]                   }
[10:33:08.357]                 }
[10:33:08.357]             }
[10:33:08.357]         }))
[10:33:08.357]     }, error = function(ex) {
[10:33:08.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.357]                 ...future.rng), started = ...future.startTime, 
[10:33:08.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.357]             version = "1.8"), class = "FutureResult")
[10:33:08.357]     }, finally = {
[10:33:08.357]         if (!identical(...future.workdir, getwd())) 
[10:33:08.357]             setwd(...future.workdir)
[10:33:08.357]         {
[10:33:08.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.357]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.357]             }
[10:33:08.357]             base::options(...future.oldOptions)
[10:33:08.357]             if (.Platform$OS.type == "windows") {
[10:33:08.357]                 old_names <- names(...future.oldEnvVars)
[10:33:08.357]                 envs <- base::Sys.getenv()
[10:33:08.357]                 names <- names(envs)
[10:33:08.357]                 common <- intersect(names, old_names)
[10:33:08.357]                 added <- setdiff(names, old_names)
[10:33:08.357]                 removed <- setdiff(old_names, names)
[10:33:08.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.357]                   envs[common]]
[10:33:08.357]                 NAMES <- toupper(changed)
[10:33:08.357]                 args <- list()
[10:33:08.357]                 for (kk in seq_along(NAMES)) {
[10:33:08.357]                   name <- changed[[kk]]
[10:33:08.357]                   NAME <- NAMES[[kk]]
[10:33:08.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.357]                     next
[10:33:08.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.357]                 }
[10:33:08.357]                 NAMES <- toupper(added)
[10:33:08.357]                 for (kk in seq_along(NAMES)) {
[10:33:08.357]                   name <- added[[kk]]
[10:33:08.357]                   NAME <- NAMES[[kk]]
[10:33:08.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.357]                     next
[10:33:08.357]                   args[[name]] <- ""
[10:33:08.357]                 }
[10:33:08.357]                 NAMES <- toupper(removed)
[10:33:08.357]                 for (kk in seq_along(NAMES)) {
[10:33:08.357]                   name <- removed[[kk]]
[10:33:08.357]                   NAME <- NAMES[[kk]]
[10:33:08.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.357]                     next
[10:33:08.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.357]                 }
[10:33:08.357]                 if (length(args) > 0) 
[10:33:08.357]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.357]             }
[10:33:08.357]             else {
[10:33:08.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.357]             }
[10:33:08.357]             {
[10:33:08.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.357]                   0L) {
[10:33:08.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.357]                   base::options(opts)
[10:33:08.357]                 }
[10:33:08.357]                 {
[10:33:08.357]                   {
[10:33:08.357]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.357]                     NULL
[10:33:08.357]                   }
[10:33:08.357]                   options(future.plan = NULL)
[10:33:08.357]                   if (is.na(NA_character_)) 
[10:33:08.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.357]                     .init = FALSE)
[10:33:08.357]                 }
[10:33:08.357]             }
[10:33:08.357]         }
[10:33:08.357]     })
[10:33:08.357]     if (TRUE) {
[10:33:08.357]         base::sink(type = "output", split = FALSE)
[10:33:08.357]         if (TRUE) {
[10:33:08.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.357]         }
[10:33:08.357]         else {
[10:33:08.357]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.357]         }
[10:33:08.357]         base::close(...future.stdout)
[10:33:08.357]         ...future.stdout <- NULL
[10:33:08.357]     }
[10:33:08.357]     ...future.result$conditions <- ...future.conditions
[10:33:08.357]     ...future.result$finished <- base::Sys.time()
[10:33:08.357]     ...future.result
[10:33:08.357] }
[10:33:08.360] assign_globals() ...
[10:33:08.360] List of 2
[10:33:08.360]  $ x   : list()
[10:33:08.360]  $ name: chr "a"
[10:33:08.360]  - attr(*, "where")=List of 2
[10:33:08.360]   ..$ x   :<environment: R_EmptyEnv> 
[10:33:08.360]   ..$ name:<environment: R_EmptyEnv> 
[10:33:08.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:08.360]  - attr(*, "resolved")= logi TRUE
[10:33:08.360]  - attr(*, "total_size")= num 112
[10:33:08.360]  - attr(*, "already-done")= logi TRUE
[10:33:08.364] - copied ‘x’ to environment
[10:33:08.364] - copied ‘name’ to environment
[10:33:08.364] assign_globals() ... done
[10:33:08.364] requestCore(): workers = 2
[10:33:08.366] MulticoreFuture started
[10:33:08.366] - Launch lazy future ... done
[10:33:08.366] run() for ‘MulticoreFuture’ ... done
[10:33:08.367] result() for MulticoreFuture ...
[10:33:08.367] plan(): Setting new future strategy stack:
[10:33:08.367] List of future strategies:
[10:33:08.367] 1. sequential:
[10:33:08.367]    - args: function (..., envir = parent.frame())
[10:33:08.367]    - tweaked: FALSE
[10:33:08.367]    - call: NULL
[10:33:08.368] plan(): nbrOfWorkers() = 1
[10:33:08.370] plan(): Setting new future strategy stack:
[10:33:08.370] List of future strategies:
[10:33:08.370] 1. multicore:
[10:33:08.370]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:08.370]    - tweaked: FALSE
[10:33:08.370]    - call: plan(strategy)
[10:33:08.379] plan(): nbrOfWorkers() = 2
[10:33:08.380] result() for MulticoreFuture ...
[10:33:08.381] result() for MulticoreFuture ... done
[10:33:08.381] result() for MulticoreFuture ... done
[10:33:08.381] result() for MulticoreFuture ...
[10:33:08.381] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[10:33:08.382] plan(): Setting new future strategy stack:
[10:33:08.382] List of future strategies:
[10:33:08.382] 1. multisession:
[10:33:08.382]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:08.382]    - tweaked: FALSE
[10:33:08.382]    - call: plan(strategy)
[10:33:08.383] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:33:08.386] multisession:
[10:33:08.386] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:33:08.386] - tweaked: FALSE
[10:33:08.386] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:08.393] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:08.393] Not searching for globals
[10:33:08.393] - globals: [0] <none>
[10:33:08.394] getGlobalsAndPackages() ... DONE
[10:33:08.394] [local output] makeClusterPSOCK() ...
[10:33:08.436] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:33:08.437] [local output] Base port: 11905
[10:33:08.437] [local output] Getting setup options for 2 cluster nodes ...
[10:33:08.438] [local output]  - Node 1 of 2 ...
[10:33:08.438] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:08.439] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpxfYssj/worker.rank=1.parallelly.parent=83843.14783335829bf.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpxfYssj/worker.rank=1.parallelly.parent=83843.14783335829bf.pid")'’
[10:33:08.627] - Possible to infer worker's PID: TRUE
[10:33:08.627] [local output] Rscript port: 11905

[10:33:08.628] [local output]  - Node 2 of 2 ...
[10:33:08.628] [local output] localMachine=TRUE => revtunnel=FALSE

[10:33:08.629] [local output] Rscript port: 11905

[10:33:08.629] [local output] Getting setup options for 2 cluster nodes ... done
[10:33:08.629] [local output]  - Parallel setup requested for some PSOCK nodes
[10:33:08.630] [local output] Setting up PSOCK nodes in parallel
[10:33:08.630] List of 36
[10:33:08.630]  $ worker          : chr "localhost"
[10:33:08.630]   ..- attr(*, "localhost")= logi TRUE
[10:33:08.630]  $ master          : chr "localhost"
[10:33:08.630]  $ port            : int 11905
[10:33:08.630]  $ connectTimeout  : num 120
[10:33:08.630]  $ timeout         : num 2592000
[10:33:08.630]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:33:08.630]  $ homogeneous     : logi TRUE
[10:33:08.630]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:33:08.630]  $ rscript_envs    : NULL
[10:33:08.630]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:08.630]  $ rscript_startup : NULL
[10:33:08.630]  $ rscript_sh      : chr "sh"
[10:33:08.630]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:08.630]  $ methods         : logi TRUE
[10:33:08.630]  $ socketOptions   : chr "no-delay"
[10:33:08.630]  $ useXDR          : logi FALSE
[10:33:08.630]  $ outfile         : chr "/dev/null"
[10:33:08.630]  $ renice          : int NA
[10:33:08.630]  $ rshcmd          : NULL
[10:33:08.630]  $ user            : chr(0) 
[10:33:08.630]  $ revtunnel       : logi FALSE
[10:33:08.630]  $ rshlogfile      : NULL
[10:33:08.630]  $ rshopts         : chr(0) 
[10:33:08.630]  $ rank            : int 1
[10:33:08.630]  $ manual          : logi FALSE
[10:33:08.630]  $ dryrun          : logi FALSE
[10:33:08.630]  $ quiet           : logi FALSE
[10:33:08.630]  $ setup_strategy  : chr "parallel"
[10:33:08.630]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:08.630]  $ pidfile         : chr "/tmp/RtmpxfYssj/worker.rank=1.parallelly.parent=83843.14783335829bf.pid"
[10:33:08.630]  $ rshcmd_label    : NULL
[10:33:08.630]  $ rsh_call        : NULL
[10:33:08.630]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:33:08.630]  $ localMachine    : logi TRUE
[10:33:08.630]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:33:08.630]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:33:08.630]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:33:08.630]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:33:08.630]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:33:08.630]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:33:08.630]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:33:08.630]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:33:08.630]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:33:08.630]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:33:08.630]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:33:08.630]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:33:08.630]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:33:08.630]  $ arguments       :List of 28
[10:33:08.630]   ..$ worker          : chr "localhost"
[10:33:08.630]   ..$ master          : NULL
[10:33:08.630]   ..$ port            : int 11905
[10:33:08.630]   ..$ connectTimeout  : num 120
[10:33:08.630]   ..$ timeout         : num 2592000
[10:33:08.630]   ..$ rscript         : NULL
[10:33:08.630]   ..$ homogeneous     : NULL
[10:33:08.630]   ..$ rscript_args    : NULL
[10:33:08.630]   ..$ rscript_envs    : NULL
[10:33:08.630]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:33:08.630]   ..$ rscript_startup : NULL
[10:33:08.630]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:33:08.630]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:33:08.630]   ..$ methods         : logi TRUE
[10:33:08.630]   ..$ socketOptions   : chr "no-delay"
[10:33:08.630]   ..$ useXDR          : logi FALSE
[10:33:08.630]   ..$ outfile         : chr "/dev/null"
[10:33:08.630]   ..$ renice          : int NA
[10:33:08.630]   ..$ rshcmd          : NULL
[10:33:08.630]   ..$ user            : NULL
[10:33:08.630]   ..$ revtunnel       : logi NA
[10:33:08.630]   ..$ rshlogfile      : NULL
[10:33:08.630]   ..$ rshopts         : NULL
[10:33:08.630]   ..$ rank            : int 1
[10:33:08.630]   ..$ manual          : logi FALSE
[10:33:08.630]   ..$ dryrun          : logi FALSE
[10:33:08.630]   ..$ quiet           : logi FALSE
[10:33:08.630]   ..$ setup_strategy  : chr "parallel"
[10:33:08.630]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:33:08.647] [local output] System call to launch all workers:
[10:33:08.647] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpxfYssj/worker.rank=1.parallelly.parent=83843.14783335829bf.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11905 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:33:08.647] [local output] Starting PSOCK main server
[10:33:08.652] [local output] Workers launched
[10:33:08.653] [local output] Waiting for workers to connect back
[10:33:08.653]  - [local output] 0 workers out of 2 ready
[10:33:08.917]  - [local output] 0 workers out of 2 ready
[10:33:08.918]  - [local output] 0 workers out of 2 ready
[10:33:08.918]  - [local output] 1 workers out of 2 ready
[10:33:08.918]  - [local output] 2 workers out of 2 ready
[10:33:08.919] [local output] Launching of workers completed
[10:33:08.919] [local output] Collecting session information from workers
[10:33:08.920] [local output]  - Worker #1 of 2
[10:33:08.920] [local output]  - Worker #2 of 2
[10:33:08.920] [local output] makeClusterPSOCK() ... done
[10:33:08.932] Packages needed by the future expression (n = 0): <none>
[10:33:08.932] Packages needed by future strategies (n = 0): <none>
[10:33:08.932] {
[10:33:08.932]     {
[10:33:08.932]         {
[10:33:08.932]             ...future.startTime <- base::Sys.time()
[10:33:08.932]             {
[10:33:08.932]                 {
[10:33:08.932]                   {
[10:33:08.932]                     {
[10:33:08.932]                       base::local({
[10:33:08.932]                         has_future <- base::requireNamespace("future", 
[10:33:08.932]                           quietly = TRUE)
[10:33:08.932]                         if (has_future) {
[10:33:08.932]                           ns <- base::getNamespace("future")
[10:33:08.932]                           version <- ns[[".package"]][["version"]]
[10:33:08.932]                           if (is.null(version)) 
[10:33:08.932]                             version <- utils::packageVersion("future")
[10:33:08.932]                         }
[10:33:08.932]                         else {
[10:33:08.932]                           version <- NULL
[10:33:08.932]                         }
[10:33:08.932]                         if (!has_future || version < "1.8.0") {
[10:33:08.932]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:08.932]                             "", base::R.version$version.string), 
[10:33:08.932]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:08.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:08.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:08.932]                               "release", "version")], collapse = " "), 
[10:33:08.932]                             hostname = base::Sys.info()[["nodename"]])
[10:33:08.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:08.932]                             info)
[10:33:08.932]                           info <- base::paste(info, collapse = "; ")
[10:33:08.932]                           if (!has_future) {
[10:33:08.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:08.932]                               info)
[10:33:08.932]                           }
[10:33:08.932]                           else {
[10:33:08.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:08.932]                               info, version)
[10:33:08.932]                           }
[10:33:08.932]                           base::stop(msg)
[10:33:08.932]                         }
[10:33:08.932]                       })
[10:33:08.932]                     }
[10:33:08.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:08.932]                     base::options(mc.cores = 1L)
[10:33:08.932]                   }
[10:33:08.932]                   ...future.strategy.old <- future::plan("list")
[10:33:08.932]                   options(future.plan = NULL)
[10:33:08.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:08.932]                 }
[10:33:08.932]                 ...future.workdir <- getwd()
[10:33:08.932]             }
[10:33:08.932]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:08.932]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:08.932]         }
[10:33:08.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:08.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:08.932]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:08.932]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:08.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:08.932]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:08.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:08.932]             base::names(...future.oldOptions))
[10:33:08.932]     }
[10:33:08.932]     if (FALSE) {
[10:33:08.932]     }
[10:33:08.932]     else {
[10:33:08.932]         if (TRUE) {
[10:33:08.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:08.932]                 open = "w")
[10:33:08.932]         }
[10:33:08.932]         else {
[10:33:08.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:08.932]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:08.932]         }
[10:33:08.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:08.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:08.932]             base::sink(type = "output", split = FALSE)
[10:33:08.932]             base::close(...future.stdout)
[10:33:08.932]         }, add = TRUE)
[10:33:08.932]     }
[10:33:08.932]     ...future.frame <- base::sys.nframe()
[10:33:08.932]     ...future.conditions <- base::list()
[10:33:08.932]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:08.932]     if (FALSE) {
[10:33:08.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:08.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:08.932]     }
[10:33:08.932]     ...future.result <- base::tryCatch({
[10:33:08.932]         base::withCallingHandlers({
[10:33:08.932]             ...future.value <- base::withVisible(base::local({
[10:33:08.932]                 ...future.makeSendCondition <- base::local({
[10:33:08.932]                   sendCondition <- NULL
[10:33:08.932]                   function(frame = 1L) {
[10:33:08.932]                     if (is.function(sendCondition)) 
[10:33:08.932]                       return(sendCondition)
[10:33:08.932]                     ns <- getNamespace("parallel")
[10:33:08.932]                     if (exists("sendData", mode = "function", 
[10:33:08.932]                       envir = ns)) {
[10:33:08.932]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:08.932]                         envir = ns)
[10:33:08.932]                       envir <- sys.frame(frame)
[10:33:08.932]                       master <- NULL
[10:33:08.932]                       while (!identical(envir, .GlobalEnv) && 
[10:33:08.932]                         !identical(envir, emptyenv())) {
[10:33:08.932]                         if (exists("master", mode = "list", envir = envir, 
[10:33:08.932]                           inherits = FALSE)) {
[10:33:08.932]                           master <- get("master", mode = "list", 
[10:33:08.932]                             envir = envir, inherits = FALSE)
[10:33:08.932]                           if (inherits(master, c("SOCKnode", 
[10:33:08.932]                             "SOCK0node"))) {
[10:33:08.932]                             sendCondition <<- function(cond) {
[10:33:08.932]                               data <- list(type = "VALUE", value = cond, 
[10:33:08.932]                                 success = TRUE)
[10:33:08.932]                               parallel_sendData(master, data)
[10:33:08.932]                             }
[10:33:08.932]                             return(sendCondition)
[10:33:08.932]                           }
[10:33:08.932]                         }
[10:33:08.932]                         frame <- frame + 1L
[10:33:08.932]                         envir <- sys.frame(frame)
[10:33:08.932]                       }
[10:33:08.932]                     }
[10:33:08.932]                     sendCondition <<- function(cond) NULL
[10:33:08.932]                   }
[10:33:08.932]                 })
[10:33:08.932]                 withCallingHandlers({
[10:33:08.932]                   NA
[10:33:08.932]                 }, immediateCondition = function(cond) {
[10:33:08.932]                   sendCondition <- ...future.makeSendCondition()
[10:33:08.932]                   sendCondition(cond)
[10:33:08.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.932]                   {
[10:33:08.932]                     inherits <- base::inherits
[10:33:08.932]                     invokeRestart <- base::invokeRestart
[10:33:08.932]                     is.null <- base::is.null
[10:33:08.932]                     muffled <- FALSE
[10:33:08.932]                     if (inherits(cond, "message")) {
[10:33:08.932]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:08.932]                       if (muffled) 
[10:33:08.932]                         invokeRestart("muffleMessage")
[10:33:08.932]                     }
[10:33:08.932]                     else if (inherits(cond, "warning")) {
[10:33:08.932]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:08.932]                       if (muffled) 
[10:33:08.932]                         invokeRestart("muffleWarning")
[10:33:08.932]                     }
[10:33:08.932]                     else if (inherits(cond, "condition")) {
[10:33:08.932]                       if (!is.null(pattern)) {
[10:33:08.932]                         computeRestarts <- base::computeRestarts
[10:33:08.932]                         grepl <- base::grepl
[10:33:08.932]                         restarts <- computeRestarts(cond)
[10:33:08.932]                         for (restart in restarts) {
[10:33:08.932]                           name <- restart$name
[10:33:08.932]                           if (is.null(name)) 
[10:33:08.932]                             next
[10:33:08.932]                           if (!grepl(pattern, name)) 
[10:33:08.932]                             next
[10:33:08.932]                           invokeRestart(restart)
[10:33:08.932]                           muffled <- TRUE
[10:33:08.932]                           break
[10:33:08.932]                         }
[10:33:08.932]                       }
[10:33:08.932]                     }
[10:33:08.932]                     invisible(muffled)
[10:33:08.932]                   }
[10:33:08.932]                   muffleCondition(cond)
[10:33:08.932]                 })
[10:33:08.932]             }))
[10:33:08.932]             future::FutureResult(value = ...future.value$value, 
[10:33:08.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.932]                   ...future.rng), globalenv = if (FALSE) 
[10:33:08.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:08.932]                     ...future.globalenv.names))
[10:33:08.932]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:08.932]         }, condition = base::local({
[10:33:08.932]             c <- base::c
[10:33:08.932]             inherits <- base::inherits
[10:33:08.932]             invokeRestart <- base::invokeRestart
[10:33:08.932]             length <- base::length
[10:33:08.932]             list <- base::list
[10:33:08.932]             seq.int <- base::seq.int
[10:33:08.932]             signalCondition <- base::signalCondition
[10:33:08.932]             sys.calls <- base::sys.calls
[10:33:08.932]             `[[` <- base::`[[`
[10:33:08.932]             `+` <- base::`+`
[10:33:08.932]             `<<-` <- base::`<<-`
[10:33:08.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:08.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:08.932]                   3L)]
[10:33:08.932]             }
[10:33:08.932]             function(cond) {
[10:33:08.932]                 is_error <- inherits(cond, "error")
[10:33:08.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:08.932]                   NULL)
[10:33:08.932]                 if (is_error) {
[10:33:08.932]                   sessionInformation <- function() {
[10:33:08.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:08.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:08.932]                       search = base::search(), system = base::Sys.info())
[10:33:08.932]                   }
[10:33:08.932]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:08.932]                     cond$call), session = sessionInformation(), 
[10:33:08.932]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:08.932]                   signalCondition(cond)
[10:33:08.932]                 }
[10:33:08.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:08.932]                 "immediateCondition"))) {
[10:33:08.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:08.932]                   ...future.conditions[[length(...future.conditions) + 
[10:33:08.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:08.932]                   if (TRUE && !signal) {
[10:33:08.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.932]                     {
[10:33:08.932]                       inherits <- base::inherits
[10:33:08.932]                       invokeRestart <- base::invokeRestart
[10:33:08.932]                       is.null <- base::is.null
[10:33:08.932]                       muffled <- FALSE
[10:33:08.932]                       if (inherits(cond, "message")) {
[10:33:08.932]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.932]                         if (muffled) 
[10:33:08.932]                           invokeRestart("muffleMessage")
[10:33:08.932]                       }
[10:33:08.932]                       else if (inherits(cond, "warning")) {
[10:33:08.932]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.932]                         if (muffled) 
[10:33:08.932]                           invokeRestart("muffleWarning")
[10:33:08.932]                       }
[10:33:08.932]                       else if (inherits(cond, "condition")) {
[10:33:08.932]                         if (!is.null(pattern)) {
[10:33:08.932]                           computeRestarts <- base::computeRestarts
[10:33:08.932]                           grepl <- base::grepl
[10:33:08.932]                           restarts <- computeRestarts(cond)
[10:33:08.932]                           for (restart in restarts) {
[10:33:08.932]                             name <- restart$name
[10:33:08.932]                             if (is.null(name)) 
[10:33:08.932]                               next
[10:33:08.932]                             if (!grepl(pattern, name)) 
[10:33:08.932]                               next
[10:33:08.932]                             invokeRestart(restart)
[10:33:08.932]                             muffled <- TRUE
[10:33:08.932]                             break
[10:33:08.932]                           }
[10:33:08.932]                         }
[10:33:08.932]                       }
[10:33:08.932]                       invisible(muffled)
[10:33:08.932]                     }
[10:33:08.932]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.932]                   }
[10:33:08.932]                 }
[10:33:08.932]                 else {
[10:33:08.932]                   if (TRUE) {
[10:33:08.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:08.932]                     {
[10:33:08.932]                       inherits <- base::inherits
[10:33:08.932]                       invokeRestart <- base::invokeRestart
[10:33:08.932]                       is.null <- base::is.null
[10:33:08.932]                       muffled <- FALSE
[10:33:08.932]                       if (inherits(cond, "message")) {
[10:33:08.932]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:08.932]                         if (muffled) 
[10:33:08.932]                           invokeRestart("muffleMessage")
[10:33:08.932]                       }
[10:33:08.932]                       else if (inherits(cond, "warning")) {
[10:33:08.932]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:08.932]                         if (muffled) 
[10:33:08.932]                           invokeRestart("muffleWarning")
[10:33:08.932]                       }
[10:33:08.932]                       else if (inherits(cond, "condition")) {
[10:33:08.932]                         if (!is.null(pattern)) {
[10:33:08.932]                           computeRestarts <- base::computeRestarts
[10:33:08.932]                           grepl <- base::grepl
[10:33:08.932]                           restarts <- computeRestarts(cond)
[10:33:08.932]                           for (restart in restarts) {
[10:33:08.932]                             name <- restart$name
[10:33:08.932]                             if (is.null(name)) 
[10:33:08.932]                               next
[10:33:08.932]                             if (!grepl(pattern, name)) 
[10:33:08.932]                               next
[10:33:08.932]                             invokeRestart(restart)
[10:33:08.932]                             muffled <- TRUE
[10:33:08.932]                             break
[10:33:08.932]                           }
[10:33:08.932]                         }
[10:33:08.932]                       }
[10:33:08.932]                       invisible(muffled)
[10:33:08.932]                     }
[10:33:08.932]                     muffleCondition(cond, pattern = "^muffle")
[10:33:08.932]                   }
[10:33:08.932]                 }
[10:33:08.932]             }
[10:33:08.932]         }))
[10:33:08.932]     }, error = function(ex) {
[10:33:08.932]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:08.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:08.932]                 ...future.rng), started = ...future.startTime, 
[10:33:08.932]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:08.932]             version = "1.8"), class = "FutureResult")
[10:33:08.932]     }, finally = {
[10:33:08.932]         if (!identical(...future.workdir, getwd())) 
[10:33:08.932]             setwd(...future.workdir)
[10:33:08.932]         {
[10:33:08.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:08.932]                 ...future.oldOptions$nwarnings <- NULL
[10:33:08.932]             }
[10:33:08.932]             base::options(...future.oldOptions)
[10:33:08.932]             if (.Platform$OS.type == "windows") {
[10:33:08.932]                 old_names <- names(...future.oldEnvVars)
[10:33:08.932]                 envs <- base::Sys.getenv()
[10:33:08.932]                 names <- names(envs)
[10:33:08.932]                 common <- intersect(names, old_names)
[10:33:08.932]                 added <- setdiff(names, old_names)
[10:33:08.932]                 removed <- setdiff(old_names, names)
[10:33:08.932]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:08.932]                   envs[common]]
[10:33:08.932]                 NAMES <- toupper(changed)
[10:33:08.932]                 args <- list()
[10:33:08.932]                 for (kk in seq_along(NAMES)) {
[10:33:08.932]                   name <- changed[[kk]]
[10:33:08.932]                   NAME <- NAMES[[kk]]
[10:33:08.932]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.932]                     next
[10:33:08.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.932]                 }
[10:33:08.932]                 NAMES <- toupper(added)
[10:33:08.932]                 for (kk in seq_along(NAMES)) {
[10:33:08.932]                   name <- added[[kk]]
[10:33:08.932]                   NAME <- NAMES[[kk]]
[10:33:08.932]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.932]                     next
[10:33:08.932]                   args[[name]] <- ""
[10:33:08.932]                 }
[10:33:08.932]                 NAMES <- toupper(removed)
[10:33:08.932]                 for (kk in seq_along(NAMES)) {
[10:33:08.932]                   name <- removed[[kk]]
[10:33:08.932]                   NAME <- NAMES[[kk]]
[10:33:08.932]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:08.932]                     next
[10:33:08.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:08.932]                 }
[10:33:08.932]                 if (length(args) > 0) 
[10:33:08.932]                   base::do.call(base::Sys.setenv, args = args)
[10:33:08.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:08.932]             }
[10:33:08.932]             else {
[10:33:08.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:08.932]             }
[10:33:08.932]             {
[10:33:08.932]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:08.932]                   0L) {
[10:33:08.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:08.932]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:08.932]                   base::options(opts)
[10:33:08.932]                 }
[10:33:08.932]                 {
[10:33:08.932]                   {
[10:33:08.932]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:08.932]                     NULL
[10:33:08.932]                   }
[10:33:08.932]                   options(future.plan = NULL)
[10:33:08.932]                   if (is.na(NA_character_)) 
[10:33:08.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:08.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:08.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:08.932]                     .init = FALSE)
[10:33:08.932]                 }
[10:33:08.932]             }
[10:33:08.932]         }
[10:33:08.932]     })
[10:33:08.932]     if (TRUE) {
[10:33:08.932]         base::sink(type = "output", split = FALSE)
[10:33:08.932]         if (TRUE) {
[10:33:08.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:08.932]         }
[10:33:08.932]         else {
[10:33:08.932]             ...future.result["stdout"] <- base::list(NULL)
[10:33:08.932]         }
[10:33:08.932]         base::close(...future.stdout)
[10:33:08.932]         ...future.stdout <- NULL
[10:33:08.932]     }
[10:33:08.932]     ...future.result$conditions <- ...future.conditions
[10:33:08.932]     ...future.result$finished <- base::Sys.time()
[10:33:08.932]     ...future.result
[10:33:08.932] }
[10:33:08.986] MultisessionFuture started
[10:33:08.986] result() for ClusterFuture ...
[10:33:08.987] receiveMessageFromWorker() for ClusterFuture ...
[10:33:08.987] - Validating connection of MultisessionFuture
[10:33:09.020] - received message: FutureResult
[10:33:09.020] - Received FutureResult
[10:33:09.020] - Erased future from FutureRegistry
[10:33:09.021] result() for ClusterFuture ...
[10:33:09.021] - result already collected: FutureResult
[10:33:09.021] result() for ClusterFuture ... done
[10:33:09.021] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.021] result() for ClusterFuture ... done
[10:33:09.021] result() for ClusterFuture ...
[10:33:09.021] - result already collected: FutureResult
[10:33:09.021] result() for ClusterFuture ... done
[10:33:09.022] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:33:09.026] plan(): nbrOfWorkers() = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.026] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.026] Searching for globals...
[10:33:09.029] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.029] Searching for globals ... DONE
[10:33:09.029] Resolving globals: TRUE
[10:33:09.029] Resolving any globals that are futures ...
[10:33:09.029] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.029] Resolving any globals that are futures ... DONE
[10:33:09.030] Resolving futures part of globals (recursively) ...
[10:33:09.030] resolve() on list ...
[10:33:09.030]  recursive: 99
[10:33:09.030]  length: 1
[10:33:09.031]  elements: ‘x’
[10:33:09.031]  length: 0 (resolved future 1)
[10:33:09.031] resolve() on list ... DONE
[10:33:09.031] - globals: [1] ‘x’
[10:33:09.031] Resolving futures part of globals (recursively) ... DONE
[10:33:09.031] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.032] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.032] - globals: [1] ‘x’
[10:33:09.032] 
[10:33:09.032] getGlobalsAndPackages() ... DONE
[10:33:09.032] run() for ‘Future’ ...
[10:33:09.032] - state: ‘created’
[10:33:09.033] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.047]   - Field: ‘node’
[10:33:09.047]   - Field: ‘label’
[10:33:09.047]   - Field: ‘local’
[10:33:09.047]   - Field: ‘owner’
[10:33:09.047]   - Field: ‘envir’
[10:33:09.048]   - Field: ‘workers’
[10:33:09.048]   - Field: ‘packages’
[10:33:09.048]   - Field: ‘gc’
[10:33:09.048]   - Field: ‘conditions’
[10:33:09.048]   - Field: ‘persistent’
[10:33:09.048]   - Field: ‘expr’
[10:33:09.048]   - Field: ‘uuid’
[10:33:09.048]   - Field: ‘seed’
[10:33:09.048]   - Field: ‘version’
[10:33:09.049]   - Field: ‘result’
[10:33:09.049]   - Field: ‘asynchronous’
[10:33:09.049]   - Field: ‘calls’
[10:33:09.049]   - Field: ‘globals’
[10:33:09.049]   - Field: ‘stdout’
[10:33:09.049]   - Field: ‘earlySignal’
[10:33:09.049]   - Field: ‘lazy’
[10:33:09.049]   - Field: ‘state’
[10:33:09.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.050] - Launch lazy future ...
[10:33:09.050] Packages needed by the future expression (n = 0): <none>
[10:33:09.050] Packages needed by future strategies (n = 0): <none>
[10:33:09.051] {
[10:33:09.051]     {
[10:33:09.051]         {
[10:33:09.051]             ...future.startTime <- base::Sys.time()
[10:33:09.051]             {
[10:33:09.051]                 {
[10:33:09.051]                   {
[10:33:09.051]                     {
[10:33:09.051]                       base::local({
[10:33:09.051]                         has_future <- base::requireNamespace("future", 
[10:33:09.051]                           quietly = TRUE)
[10:33:09.051]                         if (has_future) {
[10:33:09.051]                           ns <- base::getNamespace("future")
[10:33:09.051]                           version <- ns[[".package"]][["version"]]
[10:33:09.051]                           if (is.null(version)) 
[10:33:09.051]                             version <- utils::packageVersion("future")
[10:33:09.051]                         }
[10:33:09.051]                         else {
[10:33:09.051]                           version <- NULL
[10:33:09.051]                         }
[10:33:09.051]                         if (!has_future || version < "1.8.0") {
[10:33:09.051]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.051]                             "", base::R.version$version.string), 
[10:33:09.051]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.051]                               "release", "version")], collapse = " "), 
[10:33:09.051]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.051]                             info)
[10:33:09.051]                           info <- base::paste(info, collapse = "; ")
[10:33:09.051]                           if (!has_future) {
[10:33:09.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.051]                               info)
[10:33:09.051]                           }
[10:33:09.051]                           else {
[10:33:09.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.051]                               info, version)
[10:33:09.051]                           }
[10:33:09.051]                           base::stop(msg)
[10:33:09.051]                         }
[10:33:09.051]                       })
[10:33:09.051]                     }
[10:33:09.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.051]                     base::options(mc.cores = 1L)
[10:33:09.051]                   }
[10:33:09.051]                   ...future.strategy.old <- future::plan("list")
[10:33:09.051]                   options(future.plan = NULL)
[10:33:09.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.051]                 }
[10:33:09.051]                 ...future.workdir <- getwd()
[10:33:09.051]             }
[10:33:09.051]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.051]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.051]         }
[10:33:09.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.051]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.051]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.051]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.051]             base::names(...future.oldOptions))
[10:33:09.051]     }
[10:33:09.051]     if (FALSE) {
[10:33:09.051]     }
[10:33:09.051]     else {
[10:33:09.051]         if (TRUE) {
[10:33:09.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.051]                 open = "w")
[10:33:09.051]         }
[10:33:09.051]         else {
[10:33:09.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.051]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.051]         }
[10:33:09.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.051]             base::sink(type = "output", split = FALSE)
[10:33:09.051]             base::close(...future.stdout)
[10:33:09.051]         }, add = TRUE)
[10:33:09.051]     }
[10:33:09.051]     ...future.frame <- base::sys.nframe()
[10:33:09.051]     ...future.conditions <- base::list()
[10:33:09.051]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.051]     if (FALSE) {
[10:33:09.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.051]     }
[10:33:09.051]     ...future.result <- base::tryCatch({
[10:33:09.051]         base::withCallingHandlers({
[10:33:09.051]             ...future.value <- base::withVisible(base::local({
[10:33:09.051]                 ...future.makeSendCondition <- base::local({
[10:33:09.051]                   sendCondition <- NULL
[10:33:09.051]                   function(frame = 1L) {
[10:33:09.051]                     if (is.function(sendCondition)) 
[10:33:09.051]                       return(sendCondition)
[10:33:09.051]                     ns <- getNamespace("parallel")
[10:33:09.051]                     if (exists("sendData", mode = "function", 
[10:33:09.051]                       envir = ns)) {
[10:33:09.051]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.051]                         envir = ns)
[10:33:09.051]                       envir <- sys.frame(frame)
[10:33:09.051]                       master <- NULL
[10:33:09.051]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.051]                         !identical(envir, emptyenv())) {
[10:33:09.051]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.051]                           inherits = FALSE)) {
[10:33:09.051]                           master <- get("master", mode = "list", 
[10:33:09.051]                             envir = envir, inherits = FALSE)
[10:33:09.051]                           if (inherits(master, c("SOCKnode", 
[10:33:09.051]                             "SOCK0node"))) {
[10:33:09.051]                             sendCondition <<- function(cond) {
[10:33:09.051]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.051]                                 success = TRUE)
[10:33:09.051]                               parallel_sendData(master, data)
[10:33:09.051]                             }
[10:33:09.051]                             return(sendCondition)
[10:33:09.051]                           }
[10:33:09.051]                         }
[10:33:09.051]                         frame <- frame + 1L
[10:33:09.051]                         envir <- sys.frame(frame)
[10:33:09.051]                       }
[10:33:09.051]                     }
[10:33:09.051]                     sendCondition <<- function(cond) NULL
[10:33:09.051]                   }
[10:33:09.051]                 })
[10:33:09.051]                 withCallingHandlers({
[10:33:09.051]                   {
[10:33:09.051]                     x$a <- 1
[10:33:09.051]                     x
[10:33:09.051]                   }
[10:33:09.051]                 }, immediateCondition = function(cond) {
[10:33:09.051]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.051]                   sendCondition(cond)
[10:33:09.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.051]                   {
[10:33:09.051]                     inherits <- base::inherits
[10:33:09.051]                     invokeRestart <- base::invokeRestart
[10:33:09.051]                     is.null <- base::is.null
[10:33:09.051]                     muffled <- FALSE
[10:33:09.051]                     if (inherits(cond, "message")) {
[10:33:09.051]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.051]                       if (muffled) 
[10:33:09.051]                         invokeRestart("muffleMessage")
[10:33:09.051]                     }
[10:33:09.051]                     else if (inherits(cond, "warning")) {
[10:33:09.051]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.051]                       if (muffled) 
[10:33:09.051]                         invokeRestart("muffleWarning")
[10:33:09.051]                     }
[10:33:09.051]                     else if (inherits(cond, "condition")) {
[10:33:09.051]                       if (!is.null(pattern)) {
[10:33:09.051]                         computeRestarts <- base::computeRestarts
[10:33:09.051]                         grepl <- base::grepl
[10:33:09.051]                         restarts <- computeRestarts(cond)
[10:33:09.051]                         for (restart in restarts) {
[10:33:09.051]                           name <- restart$name
[10:33:09.051]                           if (is.null(name)) 
[10:33:09.051]                             next
[10:33:09.051]                           if (!grepl(pattern, name)) 
[10:33:09.051]                             next
[10:33:09.051]                           invokeRestart(restart)
[10:33:09.051]                           muffled <- TRUE
[10:33:09.051]                           break
[10:33:09.051]                         }
[10:33:09.051]                       }
[10:33:09.051]                     }
[10:33:09.051]                     invisible(muffled)
[10:33:09.051]                   }
[10:33:09.051]                   muffleCondition(cond)
[10:33:09.051]                 })
[10:33:09.051]             }))
[10:33:09.051]             future::FutureResult(value = ...future.value$value, 
[10:33:09.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.051]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.051]                     ...future.globalenv.names))
[10:33:09.051]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.051]         }, condition = base::local({
[10:33:09.051]             c <- base::c
[10:33:09.051]             inherits <- base::inherits
[10:33:09.051]             invokeRestart <- base::invokeRestart
[10:33:09.051]             length <- base::length
[10:33:09.051]             list <- base::list
[10:33:09.051]             seq.int <- base::seq.int
[10:33:09.051]             signalCondition <- base::signalCondition
[10:33:09.051]             sys.calls <- base::sys.calls
[10:33:09.051]             `[[` <- base::`[[`
[10:33:09.051]             `+` <- base::`+`
[10:33:09.051]             `<<-` <- base::`<<-`
[10:33:09.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.051]                   3L)]
[10:33:09.051]             }
[10:33:09.051]             function(cond) {
[10:33:09.051]                 is_error <- inherits(cond, "error")
[10:33:09.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.051]                   NULL)
[10:33:09.051]                 if (is_error) {
[10:33:09.051]                   sessionInformation <- function() {
[10:33:09.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.051]                       search = base::search(), system = base::Sys.info())
[10:33:09.051]                   }
[10:33:09.051]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.051]                     cond$call), session = sessionInformation(), 
[10:33:09.051]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.051]                   signalCondition(cond)
[10:33:09.051]                 }
[10:33:09.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.051]                 "immediateCondition"))) {
[10:33:09.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.051]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.051]                   if (TRUE && !signal) {
[10:33:09.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.051]                     {
[10:33:09.051]                       inherits <- base::inherits
[10:33:09.051]                       invokeRestart <- base::invokeRestart
[10:33:09.051]                       is.null <- base::is.null
[10:33:09.051]                       muffled <- FALSE
[10:33:09.051]                       if (inherits(cond, "message")) {
[10:33:09.051]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.051]                         if (muffled) 
[10:33:09.051]                           invokeRestart("muffleMessage")
[10:33:09.051]                       }
[10:33:09.051]                       else if (inherits(cond, "warning")) {
[10:33:09.051]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.051]                         if (muffled) 
[10:33:09.051]                           invokeRestart("muffleWarning")
[10:33:09.051]                       }
[10:33:09.051]                       else if (inherits(cond, "condition")) {
[10:33:09.051]                         if (!is.null(pattern)) {
[10:33:09.051]                           computeRestarts <- base::computeRestarts
[10:33:09.051]                           grepl <- base::grepl
[10:33:09.051]                           restarts <- computeRestarts(cond)
[10:33:09.051]                           for (restart in restarts) {
[10:33:09.051]                             name <- restart$name
[10:33:09.051]                             if (is.null(name)) 
[10:33:09.051]                               next
[10:33:09.051]                             if (!grepl(pattern, name)) 
[10:33:09.051]                               next
[10:33:09.051]                             invokeRestart(restart)
[10:33:09.051]                             muffled <- TRUE
[10:33:09.051]                             break
[10:33:09.051]                           }
[10:33:09.051]                         }
[10:33:09.051]                       }
[10:33:09.051]                       invisible(muffled)
[10:33:09.051]                     }
[10:33:09.051]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.051]                   }
[10:33:09.051]                 }
[10:33:09.051]                 else {
[10:33:09.051]                   if (TRUE) {
[10:33:09.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.051]                     {
[10:33:09.051]                       inherits <- base::inherits
[10:33:09.051]                       invokeRestart <- base::invokeRestart
[10:33:09.051]                       is.null <- base::is.null
[10:33:09.051]                       muffled <- FALSE
[10:33:09.051]                       if (inherits(cond, "message")) {
[10:33:09.051]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.051]                         if (muffled) 
[10:33:09.051]                           invokeRestart("muffleMessage")
[10:33:09.051]                       }
[10:33:09.051]                       else if (inherits(cond, "warning")) {
[10:33:09.051]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.051]                         if (muffled) 
[10:33:09.051]                           invokeRestart("muffleWarning")
[10:33:09.051]                       }
[10:33:09.051]                       else if (inherits(cond, "condition")) {
[10:33:09.051]                         if (!is.null(pattern)) {
[10:33:09.051]                           computeRestarts <- base::computeRestarts
[10:33:09.051]                           grepl <- base::grepl
[10:33:09.051]                           restarts <- computeRestarts(cond)
[10:33:09.051]                           for (restart in restarts) {
[10:33:09.051]                             name <- restart$name
[10:33:09.051]                             if (is.null(name)) 
[10:33:09.051]                               next
[10:33:09.051]                             if (!grepl(pattern, name)) 
[10:33:09.051]                               next
[10:33:09.051]                             invokeRestart(restart)
[10:33:09.051]                             muffled <- TRUE
[10:33:09.051]                             break
[10:33:09.051]                           }
[10:33:09.051]                         }
[10:33:09.051]                       }
[10:33:09.051]                       invisible(muffled)
[10:33:09.051]                     }
[10:33:09.051]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.051]                   }
[10:33:09.051]                 }
[10:33:09.051]             }
[10:33:09.051]         }))
[10:33:09.051]     }, error = function(ex) {
[10:33:09.051]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.051]                 ...future.rng), started = ...future.startTime, 
[10:33:09.051]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.051]             version = "1.8"), class = "FutureResult")
[10:33:09.051]     }, finally = {
[10:33:09.051]         if (!identical(...future.workdir, getwd())) 
[10:33:09.051]             setwd(...future.workdir)
[10:33:09.051]         {
[10:33:09.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.051]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.051]             }
[10:33:09.051]             base::options(...future.oldOptions)
[10:33:09.051]             if (.Platform$OS.type == "windows") {
[10:33:09.051]                 old_names <- names(...future.oldEnvVars)
[10:33:09.051]                 envs <- base::Sys.getenv()
[10:33:09.051]                 names <- names(envs)
[10:33:09.051]                 common <- intersect(names, old_names)
[10:33:09.051]                 added <- setdiff(names, old_names)
[10:33:09.051]                 removed <- setdiff(old_names, names)
[10:33:09.051]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.051]                   envs[common]]
[10:33:09.051]                 NAMES <- toupper(changed)
[10:33:09.051]                 args <- list()
[10:33:09.051]                 for (kk in seq_along(NAMES)) {
[10:33:09.051]                   name <- changed[[kk]]
[10:33:09.051]                   NAME <- NAMES[[kk]]
[10:33:09.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.051]                     next
[10:33:09.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.051]                 }
[10:33:09.051]                 NAMES <- toupper(added)
[10:33:09.051]                 for (kk in seq_along(NAMES)) {
[10:33:09.051]                   name <- added[[kk]]
[10:33:09.051]                   NAME <- NAMES[[kk]]
[10:33:09.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.051]                     next
[10:33:09.051]                   args[[name]] <- ""
[10:33:09.051]                 }
[10:33:09.051]                 NAMES <- toupper(removed)
[10:33:09.051]                 for (kk in seq_along(NAMES)) {
[10:33:09.051]                   name <- removed[[kk]]
[10:33:09.051]                   NAME <- NAMES[[kk]]
[10:33:09.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.051]                     next
[10:33:09.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.051]                 }
[10:33:09.051]                 if (length(args) > 0) 
[10:33:09.051]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.051]             }
[10:33:09.051]             else {
[10:33:09.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.051]             }
[10:33:09.051]             {
[10:33:09.051]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.051]                   0L) {
[10:33:09.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.051]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.051]                   base::options(opts)
[10:33:09.051]                 }
[10:33:09.051]                 {
[10:33:09.051]                   {
[10:33:09.051]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.051]                     NULL
[10:33:09.051]                   }
[10:33:09.051]                   options(future.plan = NULL)
[10:33:09.051]                   if (is.na(NA_character_)) 
[10:33:09.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.051]                     .init = FALSE)
[10:33:09.051]                 }
[10:33:09.051]             }
[10:33:09.051]         }
[10:33:09.051]     })
[10:33:09.051]     if (TRUE) {
[10:33:09.051]         base::sink(type = "output", split = FALSE)
[10:33:09.051]         if (TRUE) {
[10:33:09.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.051]         }
[10:33:09.051]         else {
[10:33:09.051]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.051]         }
[10:33:09.051]         base::close(...future.stdout)
[10:33:09.051]         ...future.stdout <- NULL
[10:33:09.051]     }
[10:33:09.051]     ...future.result$conditions <- ...future.conditions
[10:33:09.051]     ...future.result$finished <- base::Sys.time()
[10:33:09.051]     ...future.result
[10:33:09.051] }
[10:33:09.054] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.054] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.054] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.054] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.055] MultisessionFuture started
[10:33:09.055] - Launch lazy future ... done
[10:33:09.055] run() for ‘MultisessionFuture’ ... done
[10:33:09.055] result() for ClusterFuture ...
[10:33:09.055] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.055] - Validating connection of MultisessionFuture
[10:33:09.060] - received message: FutureResult
[10:33:09.060] - Received FutureResult
[10:33:09.060] - Erased future from FutureRegistry
[10:33:09.060] result() for ClusterFuture ...
[10:33:09.060] - result already collected: FutureResult
[10:33:09.060] result() for ClusterFuture ... done
[10:33:09.061] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.061] result() for ClusterFuture ... done
[10:33:09.061] result() for ClusterFuture ...
[10:33:09.061] - result already collected: FutureResult
[10:33:09.061] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.061] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.062] Searching for globals...
[10:33:09.064] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.064] Searching for globals ... DONE
[10:33:09.064] Resolving globals: TRUE
[10:33:09.064] Resolving any globals that are futures ...
[10:33:09.065] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.065] Resolving any globals that are futures ... DONE
[10:33:09.065] Resolving futures part of globals (recursively) ...
[10:33:09.065] resolve() on list ...
[10:33:09.066]  recursive: 99
[10:33:09.066]  length: 1
[10:33:09.066]  elements: ‘x’
[10:33:09.066]  length: 0 (resolved future 1)
[10:33:09.066] resolve() on list ... DONE
[10:33:09.066] - globals: [1] ‘x’
[10:33:09.066] Resolving futures part of globals (recursively) ... DONE
[10:33:09.066] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.067] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.067] - globals: [1] ‘x’
[10:33:09.067] 
[10:33:09.067] getGlobalsAndPackages() ... DONE
[10:33:09.067] run() for ‘Future’ ...
[10:33:09.068] - state: ‘created’
[10:33:09.068] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.082]   - Field: ‘node’
[10:33:09.083]   - Field: ‘label’
[10:33:09.083]   - Field: ‘local’
[10:33:09.083]   - Field: ‘owner’
[10:33:09.083]   - Field: ‘envir’
[10:33:09.083]   - Field: ‘workers’
[10:33:09.083]   - Field: ‘packages’
[10:33:09.083]   - Field: ‘gc’
[10:33:09.083]   - Field: ‘conditions’
[10:33:09.083]   - Field: ‘persistent’
[10:33:09.084]   - Field: ‘expr’
[10:33:09.084]   - Field: ‘uuid’
[10:33:09.084]   - Field: ‘seed’
[10:33:09.084]   - Field: ‘version’
[10:33:09.084]   - Field: ‘result’
[10:33:09.084]   - Field: ‘asynchronous’
[10:33:09.084]   - Field: ‘calls’
[10:33:09.084]   - Field: ‘globals’
[10:33:09.084]   - Field: ‘stdout’
[10:33:09.085]   - Field: ‘earlySignal’
[10:33:09.085]   - Field: ‘lazy’
[10:33:09.085]   - Field: ‘state’
[10:33:09.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.085] - Launch lazy future ...
[10:33:09.085] Packages needed by the future expression (n = 0): <none>
[10:33:09.086] Packages needed by future strategies (n = 0): <none>
[10:33:09.086] {
[10:33:09.086]     {
[10:33:09.086]         {
[10:33:09.086]             ...future.startTime <- base::Sys.time()
[10:33:09.086]             {
[10:33:09.086]                 {
[10:33:09.086]                   {
[10:33:09.086]                     {
[10:33:09.086]                       base::local({
[10:33:09.086]                         has_future <- base::requireNamespace("future", 
[10:33:09.086]                           quietly = TRUE)
[10:33:09.086]                         if (has_future) {
[10:33:09.086]                           ns <- base::getNamespace("future")
[10:33:09.086]                           version <- ns[[".package"]][["version"]]
[10:33:09.086]                           if (is.null(version)) 
[10:33:09.086]                             version <- utils::packageVersion("future")
[10:33:09.086]                         }
[10:33:09.086]                         else {
[10:33:09.086]                           version <- NULL
[10:33:09.086]                         }
[10:33:09.086]                         if (!has_future || version < "1.8.0") {
[10:33:09.086]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.086]                             "", base::R.version$version.string), 
[10:33:09.086]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.086]                               "release", "version")], collapse = " "), 
[10:33:09.086]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.086]                             info)
[10:33:09.086]                           info <- base::paste(info, collapse = "; ")
[10:33:09.086]                           if (!has_future) {
[10:33:09.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.086]                               info)
[10:33:09.086]                           }
[10:33:09.086]                           else {
[10:33:09.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.086]                               info, version)
[10:33:09.086]                           }
[10:33:09.086]                           base::stop(msg)
[10:33:09.086]                         }
[10:33:09.086]                       })
[10:33:09.086]                     }
[10:33:09.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.086]                     base::options(mc.cores = 1L)
[10:33:09.086]                   }
[10:33:09.086]                   ...future.strategy.old <- future::plan("list")
[10:33:09.086]                   options(future.plan = NULL)
[10:33:09.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.086]                 }
[10:33:09.086]                 ...future.workdir <- getwd()
[10:33:09.086]             }
[10:33:09.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.086]         }
[10:33:09.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.086]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.086]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.086]             base::names(...future.oldOptions))
[10:33:09.086]     }
[10:33:09.086]     if (FALSE) {
[10:33:09.086]     }
[10:33:09.086]     else {
[10:33:09.086]         if (TRUE) {
[10:33:09.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.086]                 open = "w")
[10:33:09.086]         }
[10:33:09.086]         else {
[10:33:09.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.086]         }
[10:33:09.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.086]             base::sink(type = "output", split = FALSE)
[10:33:09.086]             base::close(...future.stdout)
[10:33:09.086]         }, add = TRUE)
[10:33:09.086]     }
[10:33:09.086]     ...future.frame <- base::sys.nframe()
[10:33:09.086]     ...future.conditions <- base::list()
[10:33:09.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.086]     if (FALSE) {
[10:33:09.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.086]     }
[10:33:09.086]     ...future.result <- base::tryCatch({
[10:33:09.086]         base::withCallingHandlers({
[10:33:09.086]             ...future.value <- base::withVisible(base::local({
[10:33:09.086]                 ...future.makeSendCondition <- base::local({
[10:33:09.086]                   sendCondition <- NULL
[10:33:09.086]                   function(frame = 1L) {
[10:33:09.086]                     if (is.function(sendCondition)) 
[10:33:09.086]                       return(sendCondition)
[10:33:09.086]                     ns <- getNamespace("parallel")
[10:33:09.086]                     if (exists("sendData", mode = "function", 
[10:33:09.086]                       envir = ns)) {
[10:33:09.086]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.086]                         envir = ns)
[10:33:09.086]                       envir <- sys.frame(frame)
[10:33:09.086]                       master <- NULL
[10:33:09.086]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.086]                         !identical(envir, emptyenv())) {
[10:33:09.086]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.086]                           inherits = FALSE)) {
[10:33:09.086]                           master <- get("master", mode = "list", 
[10:33:09.086]                             envir = envir, inherits = FALSE)
[10:33:09.086]                           if (inherits(master, c("SOCKnode", 
[10:33:09.086]                             "SOCK0node"))) {
[10:33:09.086]                             sendCondition <<- function(cond) {
[10:33:09.086]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.086]                                 success = TRUE)
[10:33:09.086]                               parallel_sendData(master, data)
[10:33:09.086]                             }
[10:33:09.086]                             return(sendCondition)
[10:33:09.086]                           }
[10:33:09.086]                         }
[10:33:09.086]                         frame <- frame + 1L
[10:33:09.086]                         envir <- sys.frame(frame)
[10:33:09.086]                       }
[10:33:09.086]                     }
[10:33:09.086]                     sendCondition <<- function(cond) NULL
[10:33:09.086]                   }
[10:33:09.086]                 })
[10:33:09.086]                 withCallingHandlers({
[10:33:09.086]                   {
[10:33:09.086]                     x$a <- 1
[10:33:09.086]                     x
[10:33:09.086]                   }
[10:33:09.086]                 }, immediateCondition = function(cond) {
[10:33:09.086]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.086]                   sendCondition(cond)
[10:33:09.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.086]                   {
[10:33:09.086]                     inherits <- base::inherits
[10:33:09.086]                     invokeRestart <- base::invokeRestart
[10:33:09.086]                     is.null <- base::is.null
[10:33:09.086]                     muffled <- FALSE
[10:33:09.086]                     if (inherits(cond, "message")) {
[10:33:09.086]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.086]                       if (muffled) 
[10:33:09.086]                         invokeRestart("muffleMessage")
[10:33:09.086]                     }
[10:33:09.086]                     else if (inherits(cond, "warning")) {
[10:33:09.086]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.086]                       if (muffled) 
[10:33:09.086]                         invokeRestart("muffleWarning")
[10:33:09.086]                     }
[10:33:09.086]                     else if (inherits(cond, "condition")) {
[10:33:09.086]                       if (!is.null(pattern)) {
[10:33:09.086]                         computeRestarts <- base::computeRestarts
[10:33:09.086]                         grepl <- base::grepl
[10:33:09.086]                         restarts <- computeRestarts(cond)
[10:33:09.086]                         for (restart in restarts) {
[10:33:09.086]                           name <- restart$name
[10:33:09.086]                           if (is.null(name)) 
[10:33:09.086]                             next
[10:33:09.086]                           if (!grepl(pattern, name)) 
[10:33:09.086]                             next
[10:33:09.086]                           invokeRestart(restart)
[10:33:09.086]                           muffled <- TRUE
[10:33:09.086]                           break
[10:33:09.086]                         }
[10:33:09.086]                       }
[10:33:09.086]                     }
[10:33:09.086]                     invisible(muffled)
[10:33:09.086]                   }
[10:33:09.086]                   muffleCondition(cond)
[10:33:09.086]                 })
[10:33:09.086]             }))
[10:33:09.086]             future::FutureResult(value = ...future.value$value, 
[10:33:09.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.086]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.086]                     ...future.globalenv.names))
[10:33:09.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.086]         }, condition = base::local({
[10:33:09.086]             c <- base::c
[10:33:09.086]             inherits <- base::inherits
[10:33:09.086]             invokeRestart <- base::invokeRestart
[10:33:09.086]             length <- base::length
[10:33:09.086]             list <- base::list
[10:33:09.086]             seq.int <- base::seq.int
[10:33:09.086]             signalCondition <- base::signalCondition
[10:33:09.086]             sys.calls <- base::sys.calls
[10:33:09.086]             `[[` <- base::`[[`
[10:33:09.086]             `+` <- base::`+`
[10:33:09.086]             `<<-` <- base::`<<-`
[10:33:09.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.086]                   3L)]
[10:33:09.086]             }
[10:33:09.086]             function(cond) {
[10:33:09.086]                 is_error <- inherits(cond, "error")
[10:33:09.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.086]                   NULL)
[10:33:09.086]                 if (is_error) {
[10:33:09.086]                   sessionInformation <- function() {
[10:33:09.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.086]                       search = base::search(), system = base::Sys.info())
[10:33:09.086]                   }
[10:33:09.086]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.086]                     cond$call), session = sessionInformation(), 
[10:33:09.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.086]                   signalCondition(cond)
[10:33:09.086]                 }
[10:33:09.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.086]                 "immediateCondition"))) {
[10:33:09.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.086]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.086]                   if (TRUE && !signal) {
[10:33:09.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.086]                     {
[10:33:09.086]                       inherits <- base::inherits
[10:33:09.086]                       invokeRestart <- base::invokeRestart
[10:33:09.086]                       is.null <- base::is.null
[10:33:09.086]                       muffled <- FALSE
[10:33:09.086]                       if (inherits(cond, "message")) {
[10:33:09.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.086]                         if (muffled) 
[10:33:09.086]                           invokeRestart("muffleMessage")
[10:33:09.086]                       }
[10:33:09.086]                       else if (inherits(cond, "warning")) {
[10:33:09.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.086]                         if (muffled) 
[10:33:09.086]                           invokeRestart("muffleWarning")
[10:33:09.086]                       }
[10:33:09.086]                       else if (inherits(cond, "condition")) {
[10:33:09.086]                         if (!is.null(pattern)) {
[10:33:09.086]                           computeRestarts <- base::computeRestarts
[10:33:09.086]                           grepl <- base::grepl
[10:33:09.086]                           restarts <- computeRestarts(cond)
[10:33:09.086]                           for (restart in restarts) {
[10:33:09.086]                             name <- restart$name
[10:33:09.086]                             if (is.null(name)) 
[10:33:09.086]                               next
[10:33:09.086]                             if (!grepl(pattern, name)) 
[10:33:09.086]                               next
[10:33:09.086]                             invokeRestart(restart)
[10:33:09.086]                             muffled <- TRUE
[10:33:09.086]                             break
[10:33:09.086]                           }
[10:33:09.086]                         }
[10:33:09.086]                       }
[10:33:09.086]                       invisible(muffled)
[10:33:09.086]                     }
[10:33:09.086]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.086]                   }
[10:33:09.086]                 }
[10:33:09.086]                 else {
[10:33:09.086]                   if (TRUE) {
[10:33:09.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.086]                     {
[10:33:09.086]                       inherits <- base::inherits
[10:33:09.086]                       invokeRestart <- base::invokeRestart
[10:33:09.086]                       is.null <- base::is.null
[10:33:09.086]                       muffled <- FALSE
[10:33:09.086]                       if (inherits(cond, "message")) {
[10:33:09.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.086]                         if (muffled) 
[10:33:09.086]                           invokeRestart("muffleMessage")
[10:33:09.086]                       }
[10:33:09.086]                       else if (inherits(cond, "warning")) {
[10:33:09.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.086]                         if (muffled) 
[10:33:09.086]                           invokeRestart("muffleWarning")
[10:33:09.086]                       }
[10:33:09.086]                       else if (inherits(cond, "condition")) {
[10:33:09.086]                         if (!is.null(pattern)) {
[10:33:09.086]                           computeRestarts <- base::computeRestarts
[10:33:09.086]                           grepl <- base::grepl
[10:33:09.086]                           restarts <- computeRestarts(cond)
[10:33:09.086]                           for (restart in restarts) {
[10:33:09.086]                             name <- restart$name
[10:33:09.086]                             if (is.null(name)) 
[10:33:09.086]                               next
[10:33:09.086]                             if (!grepl(pattern, name)) 
[10:33:09.086]                               next
[10:33:09.086]                             invokeRestart(restart)
[10:33:09.086]                             muffled <- TRUE
[10:33:09.086]                             break
[10:33:09.086]                           }
[10:33:09.086]                         }
[10:33:09.086]                       }
[10:33:09.086]                       invisible(muffled)
[10:33:09.086]                     }
[10:33:09.086]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.086]                   }
[10:33:09.086]                 }
[10:33:09.086]             }
[10:33:09.086]         }))
[10:33:09.086]     }, error = function(ex) {
[10:33:09.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.086]                 ...future.rng), started = ...future.startTime, 
[10:33:09.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.086]             version = "1.8"), class = "FutureResult")
[10:33:09.086]     }, finally = {
[10:33:09.086]         if (!identical(...future.workdir, getwd())) 
[10:33:09.086]             setwd(...future.workdir)
[10:33:09.086]         {
[10:33:09.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.086]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.086]             }
[10:33:09.086]             base::options(...future.oldOptions)
[10:33:09.086]             if (.Platform$OS.type == "windows") {
[10:33:09.086]                 old_names <- names(...future.oldEnvVars)
[10:33:09.086]                 envs <- base::Sys.getenv()
[10:33:09.086]                 names <- names(envs)
[10:33:09.086]                 common <- intersect(names, old_names)
[10:33:09.086]                 added <- setdiff(names, old_names)
[10:33:09.086]                 removed <- setdiff(old_names, names)
[10:33:09.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.086]                   envs[common]]
[10:33:09.086]                 NAMES <- toupper(changed)
[10:33:09.086]                 args <- list()
[10:33:09.086]                 for (kk in seq_along(NAMES)) {
[10:33:09.086]                   name <- changed[[kk]]
[10:33:09.086]                   NAME <- NAMES[[kk]]
[10:33:09.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.086]                     next
[10:33:09.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.086]                 }
[10:33:09.086]                 NAMES <- toupper(added)
[10:33:09.086]                 for (kk in seq_along(NAMES)) {
[10:33:09.086]                   name <- added[[kk]]
[10:33:09.086]                   NAME <- NAMES[[kk]]
[10:33:09.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.086]                     next
[10:33:09.086]                   args[[name]] <- ""
[10:33:09.086]                 }
[10:33:09.086]                 NAMES <- toupper(removed)
[10:33:09.086]                 for (kk in seq_along(NAMES)) {
[10:33:09.086]                   name <- removed[[kk]]
[10:33:09.086]                   NAME <- NAMES[[kk]]
[10:33:09.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.086]                     next
[10:33:09.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.086]                 }
[10:33:09.086]                 if (length(args) > 0) 
[10:33:09.086]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.086]             }
[10:33:09.086]             else {
[10:33:09.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.086]             }
[10:33:09.086]             {
[10:33:09.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.086]                   0L) {
[10:33:09.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.086]                   base::options(opts)
[10:33:09.086]                 }
[10:33:09.086]                 {
[10:33:09.086]                   {
[10:33:09.086]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.086]                     NULL
[10:33:09.086]                   }
[10:33:09.086]                   options(future.plan = NULL)
[10:33:09.086]                   if (is.na(NA_character_)) 
[10:33:09.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.086]                     .init = FALSE)
[10:33:09.086]                 }
[10:33:09.086]             }
[10:33:09.086]         }
[10:33:09.086]     })
[10:33:09.086]     if (TRUE) {
[10:33:09.086]         base::sink(type = "output", split = FALSE)
[10:33:09.086]         if (TRUE) {
[10:33:09.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.086]         }
[10:33:09.086]         else {
[10:33:09.086]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.086]         }
[10:33:09.086]         base::close(...future.stdout)
[10:33:09.086]         ...future.stdout <- NULL
[10:33:09.086]     }
[10:33:09.086]     ...future.result$conditions <- ...future.conditions
[10:33:09.086]     ...future.result$finished <- base::Sys.time()
[10:33:09.086]     ...future.result
[10:33:09.086] }
[10:33:09.089] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.089] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.089] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.090] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.090] MultisessionFuture started
[10:33:09.090] - Launch lazy future ... done
[10:33:09.091] run() for ‘MultisessionFuture’ ... done
[10:33:09.091] result() for ClusterFuture ...
[10:33:09.091] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.091] - Validating connection of MultisessionFuture
[10:33:09.092] - received message: FutureResult
[10:33:09.092] - Received FutureResult
[10:33:09.092] - Erased future from FutureRegistry
[10:33:09.093] result() for ClusterFuture ...
[10:33:09.093] - result already collected: FutureResult
[10:33:09.093] result() for ClusterFuture ... done
[10:33:09.093] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.093] result() for ClusterFuture ... done
[10:33:09.093] result() for ClusterFuture ...
[10:33:09.093] - result already collected: FutureResult
[10:33:09.093] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.094] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.094] Searching for globals...
[10:33:09.097] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.097] Searching for globals ... DONE
[10:33:09.097] Resolving globals: TRUE
[10:33:09.097] Resolving any globals that are futures ...
[10:33:09.097] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.097] Resolving any globals that are futures ... DONE
[10:33:09.098] Resolving futures part of globals (recursively) ...
[10:33:09.098] resolve() on list ...
[10:33:09.098]  recursive: 99
[10:33:09.098]  length: 1
[10:33:09.098]  elements: ‘x’
[10:33:09.098]  length: 0 (resolved future 1)
[10:33:09.099] resolve() on list ... DONE
[10:33:09.099] - globals: [1] ‘x’
[10:33:09.099] Resolving futures part of globals (recursively) ... DONE
[10:33:09.099] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.099] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.099] - globals: [1] ‘x’
[10:33:09.100] 
[10:33:09.100] getGlobalsAndPackages() ... DONE
[10:33:09.100] run() for ‘Future’ ...
[10:33:09.100] - state: ‘created’
[10:33:09.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.120]   - Field: ‘node’
[10:33:09.120]   - Field: ‘label’
[10:33:09.120]   - Field: ‘local’
[10:33:09.120]   - Field: ‘owner’
[10:33:09.120]   - Field: ‘envir’
[10:33:09.120]   - Field: ‘workers’
[10:33:09.120]   - Field: ‘packages’
[10:33:09.120]   - Field: ‘gc’
[10:33:09.121]   - Field: ‘conditions’
[10:33:09.121]   - Field: ‘persistent’
[10:33:09.121]   - Field: ‘expr’
[10:33:09.121]   - Field: ‘uuid’
[10:33:09.121]   - Field: ‘seed’
[10:33:09.121]   - Field: ‘version’
[10:33:09.121]   - Field: ‘result’
[10:33:09.121]   - Field: ‘asynchronous’
[10:33:09.121]   - Field: ‘calls’
[10:33:09.121]   - Field: ‘globals’
[10:33:09.121]   - Field: ‘stdout’
[10:33:09.122]   - Field: ‘earlySignal’
[10:33:09.122]   - Field: ‘lazy’
[10:33:09.122]   - Field: ‘state’
[10:33:09.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.122] - Launch lazy future ...
[10:33:09.122] Packages needed by the future expression (n = 0): <none>
[10:33:09.122] Packages needed by future strategies (n = 0): <none>
[10:33:09.123] {
[10:33:09.123]     {
[10:33:09.123]         {
[10:33:09.123]             ...future.startTime <- base::Sys.time()
[10:33:09.123]             {
[10:33:09.123]                 {
[10:33:09.123]                   {
[10:33:09.123]                     {
[10:33:09.123]                       base::local({
[10:33:09.123]                         has_future <- base::requireNamespace("future", 
[10:33:09.123]                           quietly = TRUE)
[10:33:09.123]                         if (has_future) {
[10:33:09.123]                           ns <- base::getNamespace("future")
[10:33:09.123]                           version <- ns[[".package"]][["version"]]
[10:33:09.123]                           if (is.null(version)) 
[10:33:09.123]                             version <- utils::packageVersion("future")
[10:33:09.123]                         }
[10:33:09.123]                         else {
[10:33:09.123]                           version <- NULL
[10:33:09.123]                         }
[10:33:09.123]                         if (!has_future || version < "1.8.0") {
[10:33:09.123]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.123]                             "", base::R.version$version.string), 
[10:33:09.123]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.123]                               "release", "version")], collapse = " "), 
[10:33:09.123]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.123]                             info)
[10:33:09.123]                           info <- base::paste(info, collapse = "; ")
[10:33:09.123]                           if (!has_future) {
[10:33:09.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.123]                               info)
[10:33:09.123]                           }
[10:33:09.123]                           else {
[10:33:09.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.123]                               info, version)
[10:33:09.123]                           }
[10:33:09.123]                           base::stop(msg)
[10:33:09.123]                         }
[10:33:09.123]                       })
[10:33:09.123]                     }
[10:33:09.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.123]                     base::options(mc.cores = 1L)
[10:33:09.123]                   }
[10:33:09.123]                   ...future.strategy.old <- future::plan("list")
[10:33:09.123]                   options(future.plan = NULL)
[10:33:09.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.123]                 }
[10:33:09.123]                 ...future.workdir <- getwd()
[10:33:09.123]             }
[10:33:09.123]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.123]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.123]         }
[10:33:09.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.123]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.123]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.123]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.123]             base::names(...future.oldOptions))
[10:33:09.123]     }
[10:33:09.123]     if (FALSE) {
[10:33:09.123]     }
[10:33:09.123]     else {
[10:33:09.123]         if (TRUE) {
[10:33:09.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.123]                 open = "w")
[10:33:09.123]         }
[10:33:09.123]         else {
[10:33:09.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.123]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.123]         }
[10:33:09.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.123]             base::sink(type = "output", split = FALSE)
[10:33:09.123]             base::close(...future.stdout)
[10:33:09.123]         }, add = TRUE)
[10:33:09.123]     }
[10:33:09.123]     ...future.frame <- base::sys.nframe()
[10:33:09.123]     ...future.conditions <- base::list()
[10:33:09.123]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.123]     if (FALSE) {
[10:33:09.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.123]     }
[10:33:09.123]     ...future.result <- base::tryCatch({
[10:33:09.123]         base::withCallingHandlers({
[10:33:09.123]             ...future.value <- base::withVisible(base::local({
[10:33:09.123]                 ...future.makeSendCondition <- base::local({
[10:33:09.123]                   sendCondition <- NULL
[10:33:09.123]                   function(frame = 1L) {
[10:33:09.123]                     if (is.function(sendCondition)) 
[10:33:09.123]                       return(sendCondition)
[10:33:09.123]                     ns <- getNamespace("parallel")
[10:33:09.123]                     if (exists("sendData", mode = "function", 
[10:33:09.123]                       envir = ns)) {
[10:33:09.123]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.123]                         envir = ns)
[10:33:09.123]                       envir <- sys.frame(frame)
[10:33:09.123]                       master <- NULL
[10:33:09.123]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.123]                         !identical(envir, emptyenv())) {
[10:33:09.123]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.123]                           inherits = FALSE)) {
[10:33:09.123]                           master <- get("master", mode = "list", 
[10:33:09.123]                             envir = envir, inherits = FALSE)
[10:33:09.123]                           if (inherits(master, c("SOCKnode", 
[10:33:09.123]                             "SOCK0node"))) {
[10:33:09.123]                             sendCondition <<- function(cond) {
[10:33:09.123]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.123]                                 success = TRUE)
[10:33:09.123]                               parallel_sendData(master, data)
[10:33:09.123]                             }
[10:33:09.123]                             return(sendCondition)
[10:33:09.123]                           }
[10:33:09.123]                         }
[10:33:09.123]                         frame <- frame + 1L
[10:33:09.123]                         envir <- sys.frame(frame)
[10:33:09.123]                       }
[10:33:09.123]                     }
[10:33:09.123]                     sendCondition <<- function(cond) NULL
[10:33:09.123]                   }
[10:33:09.123]                 })
[10:33:09.123]                 withCallingHandlers({
[10:33:09.123]                   {
[10:33:09.123]                     x$a <- 1
[10:33:09.123]                     x
[10:33:09.123]                   }
[10:33:09.123]                 }, immediateCondition = function(cond) {
[10:33:09.123]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.123]                   sendCondition(cond)
[10:33:09.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.123]                   {
[10:33:09.123]                     inherits <- base::inherits
[10:33:09.123]                     invokeRestart <- base::invokeRestart
[10:33:09.123]                     is.null <- base::is.null
[10:33:09.123]                     muffled <- FALSE
[10:33:09.123]                     if (inherits(cond, "message")) {
[10:33:09.123]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.123]                       if (muffled) 
[10:33:09.123]                         invokeRestart("muffleMessage")
[10:33:09.123]                     }
[10:33:09.123]                     else if (inherits(cond, "warning")) {
[10:33:09.123]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.123]                       if (muffled) 
[10:33:09.123]                         invokeRestart("muffleWarning")
[10:33:09.123]                     }
[10:33:09.123]                     else if (inherits(cond, "condition")) {
[10:33:09.123]                       if (!is.null(pattern)) {
[10:33:09.123]                         computeRestarts <- base::computeRestarts
[10:33:09.123]                         grepl <- base::grepl
[10:33:09.123]                         restarts <- computeRestarts(cond)
[10:33:09.123]                         for (restart in restarts) {
[10:33:09.123]                           name <- restart$name
[10:33:09.123]                           if (is.null(name)) 
[10:33:09.123]                             next
[10:33:09.123]                           if (!grepl(pattern, name)) 
[10:33:09.123]                             next
[10:33:09.123]                           invokeRestart(restart)
[10:33:09.123]                           muffled <- TRUE
[10:33:09.123]                           break
[10:33:09.123]                         }
[10:33:09.123]                       }
[10:33:09.123]                     }
[10:33:09.123]                     invisible(muffled)
[10:33:09.123]                   }
[10:33:09.123]                   muffleCondition(cond)
[10:33:09.123]                 })
[10:33:09.123]             }))
[10:33:09.123]             future::FutureResult(value = ...future.value$value, 
[10:33:09.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.123]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.123]                     ...future.globalenv.names))
[10:33:09.123]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.123]         }, condition = base::local({
[10:33:09.123]             c <- base::c
[10:33:09.123]             inherits <- base::inherits
[10:33:09.123]             invokeRestart <- base::invokeRestart
[10:33:09.123]             length <- base::length
[10:33:09.123]             list <- base::list
[10:33:09.123]             seq.int <- base::seq.int
[10:33:09.123]             signalCondition <- base::signalCondition
[10:33:09.123]             sys.calls <- base::sys.calls
[10:33:09.123]             `[[` <- base::`[[`
[10:33:09.123]             `+` <- base::`+`
[10:33:09.123]             `<<-` <- base::`<<-`
[10:33:09.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.123]                   3L)]
[10:33:09.123]             }
[10:33:09.123]             function(cond) {
[10:33:09.123]                 is_error <- inherits(cond, "error")
[10:33:09.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.123]                   NULL)
[10:33:09.123]                 if (is_error) {
[10:33:09.123]                   sessionInformation <- function() {
[10:33:09.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.123]                       search = base::search(), system = base::Sys.info())
[10:33:09.123]                   }
[10:33:09.123]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.123]                     cond$call), session = sessionInformation(), 
[10:33:09.123]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.123]                   signalCondition(cond)
[10:33:09.123]                 }
[10:33:09.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.123]                 "immediateCondition"))) {
[10:33:09.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.123]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.123]                   if (TRUE && !signal) {
[10:33:09.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.123]                     {
[10:33:09.123]                       inherits <- base::inherits
[10:33:09.123]                       invokeRestart <- base::invokeRestart
[10:33:09.123]                       is.null <- base::is.null
[10:33:09.123]                       muffled <- FALSE
[10:33:09.123]                       if (inherits(cond, "message")) {
[10:33:09.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.123]                         if (muffled) 
[10:33:09.123]                           invokeRestart("muffleMessage")
[10:33:09.123]                       }
[10:33:09.123]                       else if (inherits(cond, "warning")) {
[10:33:09.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.123]                         if (muffled) 
[10:33:09.123]                           invokeRestart("muffleWarning")
[10:33:09.123]                       }
[10:33:09.123]                       else if (inherits(cond, "condition")) {
[10:33:09.123]                         if (!is.null(pattern)) {
[10:33:09.123]                           computeRestarts <- base::computeRestarts
[10:33:09.123]                           grepl <- base::grepl
[10:33:09.123]                           restarts <- computeRestarts(cond)
[10:33:09.123]                           for (restart in restarts) {
[10:33:09.123]                             name <- restart$name
[10:33:09.123]                             if (is.null(name)) 
[10:33:09.123]                               next
[10:33:09.123]                             if (!grepl(pattern, name)) 
[10:33:09.123]                               next
[10:33:09.123]                             invokeRestart(restart)
[10:33:09.123]                             muffled <- TRUE
[10:33:09.123]                             break
[10:33:09.123]                           }
[10:33:09.123]                         }
[10:33:09.123]                       }
[10:33:09.123]                       invisible(muffled)
[10:33:09.123]                     }
[10:33:09.123]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.123]                   }
[10:33:09.123]                 }
[10:33:09.123]                 else {
[10:33:09.123]                   if (TRUE) {
[10:33:09.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.123]                     {
[10:33:09.123]                       inherits <- base::inherits
[10:33:09.123]                       invokeRestart <- base::invokeRestart
[10:33:09.123]                       is.null <- base::is.null
[10:33:09.123]                       muffled <- FALSE
[10:33:09.123]                       if (inherits(cond, "message")) {
[10:33:09.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.123]                         if (muffled) 
[10:33:09.123]                           invokeRestart("muffleMessage")
[10:33:09.123]                       }
[10:33:09.123]                       else if (inherits(cond, "warning")) {
[10:33:09.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.123]                         if (muffled) 
[10:33:09.123]                           invokeRestart("muffleWarning")
[10:33:09.123]                       }
[10:33:09.123]                       else if (inherits(cond, "condition")) {
[10:33:09.123]                         if (!is.null(pattern)) {
[10:33:09.123]                           computeRestarts <- base::computeRestarts
[10:33:09.123]                           grepl <- base::grepl
[10:33:09.123]                           restarts <- computeRestarts(cond)
[10:33:09.123]                           for (restart in restarts) {
[10:33:09.123]                             name <- restart$name
[10:33:09.123]                             if (is.null(name)) 
[10:33:09.123]                               next
[10:33:09.123]                             if (!grepl(pattern, name)) 
[10:33:09.123]                               next
[10:33:09.123]                             invokeRestart(restart)
[10:33:09.123]                             muffled <- TRUE
[10:33:09.123]                             break
[10:33:09.123]                           }
[10:33:09.123]                         }
[10:33:09.123]                       }
[10:33:09.123]                       invisible(muffled)
[10:33:09.123]                     }
[10:33:09.123]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.123]                   }
[10:33:09.123]                 }
[10:33:09.123]             }
[10:33:09.123]         }))
[10:33:09.123]     }, error = function(ex) {
[10:33:09.123]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.123]                 ...future.rng), started = ...future.startTime, 
[10:33:09.123]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.123]             version = "1.8"), class = "FutureResult")
[10:33:09.123]     }, finally = {
[10:33:09.123]         if (!identical(...future.workdir, getwd())) 
[10:33:09.123]             setwd(...future.workdir)
[10:33:09.123]         {
[10:33:09.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.123]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.123]             }
[10:33:09.123]             base::options(...future.oldOptions)
[10:33:09.123]             if (.Platform$OS.type == "windows") {
[10:33:09.123]                 old_names <- names(...future.oldEnvVars)
[10:33:09.123]                 envs <- base::Sys.getenv()
[10:33:09.123]                 names <- names(envs)
[10:33:09.123]                 common <- intersect(names, old_names)
[10:33:09.123]                 added <- setdiff(names, old_names)
[10:33:09.123]                 removed <- setdiff(old_names, names)
[10:33:09.123]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.123]                   envs[common]]
[10:33:09.123]                 NAMES <- toupper(changed)
[10:33:09.123]                 args <- list()
[10:33:09.123]                 for (kk in seq_along(NAMES)) {
[10:33:09.123]                   name <- changed[[kk]]
[10:33:09.123]                   NAME <- NAMES[[kk]]
[10:33:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.123]                     next
[10:33:09.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.123]                 }
[10:33:09.123]                 NAMES <- toupper(added)
[10:33:09.123]                 for (kk in seq_along(NAMES)) {
[10:33:09.123]                   name <- added[[kk]]
[10:33:09.123]                   NAME <- NAMES[[kk]]
[10:33:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.123]                     next
[10:33:09.123]                   args[[name]] <- ""
[10:33:09.123]                 }
[10:33:09.123]                 NAMES <- toupper(removed)
[10:33:09.123]                 for (kk in seq_along(NAMES)) {
[10:33:09.123]                   name <- removed[[kk]]
[10:33:09.123]                   NAME <- NAMES[[kk]]
[10:33:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.123]                     next
[10:33:09.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.123]                 }
[10:33:09.123]                 if (length(args) > 0) 
[10:33:09.123]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.123]             }
[10:33:09.123]             else {
[10:33:09.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.123]             }
[10:33:09.123]             {
[10:33:09.123]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.123]                   0L) {
[10:33:09.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.123]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.123]                   base::options(opts)
[10:33:09.123]                 }
[10:33:09.123]                 {
[10:33:09.123]                   {
[10:33:09.123]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.123]                     NULL
[10:33:09.123]                   }
[10:33:09.123]                   options(future.plan = NULL)
[10:33:09.123]                   if (is.na(NA_character_)) 
[10:33:09.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.123]                     .init = FALSE)
[10:33:09.123]                 }
[10:33:09.123]             }
[10:33:09.123]         }
[10:33:09.123]     })
[10:33:09.123]     if (TRUE) {
[10:33:09.123]         base::sink(type = "output", split = FALSE)
[10:33:09.123]         if (TRUE) {
[10:33:09.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.123]         }
[10:33:09.123]         else {
[10:33:09.123]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.123]         }
[10:33:09.123]         base::close(...future.stdout)
[10:33:09.123]         ...future.stdout <- NULL
[10:33:09.123]     }
[10:33:09.123]     ...future.result$conditions <- ...future.conditions
[10:33:09.123]     ...future.result$finished <- base::Sys.time()
[10:33:09.123]     ...future.result
[10:33:09.123] }
[10:33:09.125] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.125] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.126] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.126] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.126] MultisessionFuture started
[10:33:09.126] - Launch lazy future ... done
[10:33:09.126] run() for ‘MultisessionFuture’ ... done
[10:33:09.127] result() for ClusterFuture ...
[10:33:09.127] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.127] - Validating connection of MultisessionFuture
[10:33:09.128] - received message: FutureResult
[10:33:09.128] - Received FutureResult
[10:33:09.128] - Erased future from FutureRegistry
[10:33:09.128] result() for ClusterFuture ...
[10:33:09.128] - result already collected: FutureResult
[10:33:09.128] result() for ClusterFuture ... done
[10:33:09.128] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.128] result() for ClusterFuture ... done
[10:33:09.129] result() for ClusterFuture ...
[10:33:09.129] - result already collected: FutureResult
[10:33:09.129] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.129] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.129] Searching for globals...
[10:33:09.131] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.131] Searching for globals ... DONE
[10:33:09.131] Resolving globals: TRUE
[10:33:09.132] Resolving any globals that are futures ...
[10:33:09.132] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:33:09.132] Resolving any globals that are futures ... DONE
[10:33:09.132] Resolving futures part of globals (recursively) ...
[10:33:09.132] resolve() on list ...
[10:33:09.132]  recursive: 99
[10:33:09.132]  length: 1
[10:33:09.133]  elements: ‘x’
[10:33:09.133]  length: 0 (resolved future 1)
[10:33:09.133] resolve() on list ... DONE
[10:33:09.133] - globals: [1] ‘x’
[10:33:09.133] Resolving futures part of globals (recursively) ... DONE
[10:33:09.133] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.133] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.134] - globals: [1] ‘x’
[10:33:09.134] 
[10:33:09.134] getGlobalsAndPackages() ... DONE
[10:33:09.134] run() for ‘Future’ ...
[10:33:09.134] - state: ‘created’
[10:33:09.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.148] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.148]   - Field: ‘node’
[10:33:09.148]   - Field: ‘label’
[10:33:09.149]   - Field: ‘local’
[10:33:09.149]   - Field: ‘owner’
[10:33:09.149]   - Field: ‘envir’
[10:33:09.149]   - Field: ‘workers’
[10:33:09.149]   - Field: ‘packages’
[10:33:09.149]   - Field: ‘gc’
[10:33:09.149]   - Field: ‘conditions’
[10:33:09.149]   - Field: ‘persistent’
[10:33:09.149]   - Field: ‘expr’
[10:33:09.149]   - Field: ‘uuid’
[10:33:09.149]   - Field: ‘seed’
[10:33:09.150]   - Field: ‘version’
[10:33:09.150]   - Field: ‘result’
[10:33:09.150]   - Field: ‘asynchronous’
[10:33:09.150]   - Field: ‘calls’
[10:33:09.150]   - Field: ‘globals’
[10:33:09.150]   - Field: ‘stdout’
[10:33:09.150]   - Field: ‘earlySignal’
[10:33:09.150]   - Field: ‘lazy’
[10:33:09.150]   - Field: ‘state’
[10:33:09.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.151] - Launch lazy future ...
[10:33:09.151] Packages needed by the future expression (n = 0): <none>
[10:33:09.151] Packages needed by future strategies (n = 0): <none>
[10:33:09.151] {
[10:33:09.151]     {
[10:33:09.151]         {
[10:33:09.151]             ...future.startTime <- base::Sys.time()
[10:33:09.151]             {
[10:33:09.151]                 {
[10:33:09.151]                   {
[10:33:09.151]                     {
[10:33:09.151]                       base::local({
[10:33:09.151]                         has_future <- base::requireNamespace("future", 
[10:33:09.151]                           quietly = TRUE)
[10:33:09.151]                         if (has_future) {
[10:33:09.151]                           ns <- base::getNamespace("future")
[10:33:09.151]                           version <- ns[[".package"]][["version"]]
[10:33:09.151]                           if (is.null(version)) 
[10:33:09.151]                             version <- utils::packageVersion("future")
[10:33:09.151]                         }
[10:33:09.151]                         else {
[10:33:09.151]                           version <- NULL
[10:33:09.151]                         }
[10:33:09.151]                         if (!has_future || version < "1.8.0") {
[10:33:09.151]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.151]                             "", base::R.version$version.string), 
[10:33:09.151]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.151]                               "release", "version")], collapse = " "), 
[10:33:09.151]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.151]                             info)
[10:33:09.151]                           info <- base::paste(info, collapse = "; ")
[10:33:09.151]                           if (!has_future) {
[10:33:09.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.151]                               info)
[10:33:09.151]                           }
[10:33:09.151]                           else {
[10:33:09.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.151]                               info, version)
[10:33:09.151]                           }
[10:33:09.151]                           base::stop(msg)
[10:33:09.151]                         }
[10:33:09.151]                       })
[10:33:09.151]                     }
[10:33:09.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.151]                     base::options(mc.cores = 1L)
[10:33:09.151]                   }
[10:33:09.151]                   ...future.strategy.old <- future::plan("list")
[10:33:09.151]                   options(future.plan = NULL)
[10:33:09.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.151]                 }
[10:33:09.151]                 ...future.workdir <- getwd()
[10:33:09.151]             }
[10:33:09.151]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.151]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.151]         }
[10:33:09.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.151]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.151]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.151]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.151]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.151]             base::names(...future.oldOptions))
[10:33:09.151]     }
[10:33:09.151]     if (FALSE) {
[10:33:09.151]     }
[10:33:09.151]     else {
[10:33:09.151]         if (TRUE) {
[10:33:09.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.151]                 open = "w")
[10:33:09.151]         }
[10:33:09.151]         else {
[10:33:09.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.151]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.151]         }
[10:33:09.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.151]             base::sink(type = "output", split = FALSE)
[10:33:09.151]             base::close(...future.stdout)
[10:33:09.151]         }, add = TRUE)
[10:33:09.151]     }
[10:33:09.151]     ...future.frame <- base::sys.nframe()
[10:33:09.151]     ...future.conditions <- base::list()
[10:33:09.151]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.151]     if (FALSE) {
[10:33:09.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.151]     }
[10:33:09.151]     ...future.result <- base::tryCatch({
[10:33:09.151]         base::withCallingHandlers({
[10:33:09.151]             ...future.value <- base::withVisible(base::local({
[10:33:09.151]                 ...future.makeSendCondition <- base::local({
[10:33:09.151]                   sendCondition <- NULL
[10:33:09.151]                   function(frame = 1L) {
[10:33:09.151]                     if (is.function(sendCondition)) 
[10:33:09.151]                       return(sendCondition)
[10:33:09.151]                     ns <- getNamespace("parallel")
[10:33:09.151]                     if (exists("sendData", mode = "function", 
[10:33:09.151]                       envir = ns)) {
[10:33:09.151]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.151]                         envir = ns)
[10:33:09.151]                       envir <- sys.frame(frame)
[10:33:09.151]                       master <- NULL
[10:33:09.151]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.151]                         !identical(envir, emptyenv())) {
[10:33:09.151]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.151]                           inherits = FALSE)) {
[10:33:09.151]                           master <- get("master", mode = "list", 
[10:33:09.151]                             envir = envir, inherits = FALSE)
[10:33:09.151]                           if (inherits(master, c("SOCKnode", 
[10:33:09.151]                             "SOCK0node"))) {
[10:33:09.151]                             sendCondition <<- function(cond) {
[10:33:09.151]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.151]                                 success = TRUE)
[10:33:09.151]                               parallel_sendData(master, data)
[10:33:09.151]                             }
[10:33:09.151]                             return(sendCondition)
[10:33:09.151]                           }
[10:33:09.151]                         }
[10:33:09.151]                         frame <- frame + 1L
[10:33:09.151]                         envir <- sys.frame(frame)
[10:33:09.151]                       }
[10:33:09.151]                     }
[10:33:09.151]                     sendCondition <<- function(cond) NULL
[10:33:09.151]                   }
[10:33:09.151]                 })
[10:33:09.151]                 withCallingHandlers({
[10:33:09.151]                   {
[10:33:09.151]                     x$a <- 1
[10:33:09.151]                     x
[10:33:09.151]                   }
[10:33:09.151]                 }, immediateCondition = function(cond) {
[10:33:09.151]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.151]                   sendCondition(cond)
[10:33:09.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.151]                   {
[10:33:09.151]                     inherits <- base::inherits
[10:33:09.151]                     invokeRestart <- base::invokeRestart
[10:33:09.151]                     is.null <- base::is.null
[10:33:09.151]                     muffled <- FALSE
[10:33:09.151]                     if (inherits(cond, "message")) {
[10:33:09.151]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.151]                       if (muffled) 
[10:33:09.151]                         invokeRestart("muffleMessage")
[10:33:09.151]                     }
[10:33:09.151]                     else if (inherits(cond, "warning")) {
[10:33:09.151]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.151]                       if (muffled) 
[10:33:09.151]                         invokeRestart("muffleWarning")
[10:33:09.151]                     }
[10:33:09.151]                     else if (inherits(cond, "condition")) {
[10:33:09.151]                       if (!is.null(pattern)) {
[10:33:09.151]                         computeRestarts <- base::computeRestarts
[10:33:09.151]                         grepl <- base::grepl
[10:33:09.151]                         restarts <- computeRestarts(cond)
[10:33:09.151]                         for (restart in restarts) {
[10:33:09.151]                           name <- restart$name
[10:33:09.151]                           if (is.null(name)) 
[10:33:09.151]                             next
[10:33:09.151]                           if (!grepl(pattern, name)) 
[10:33:09.151]                             next
[10:33:09.151]                           invokeRestart(restart)
[10:33:09.151]                           muffled <- TRUE
[10:33:09.151]                           break
[10:33:09.151]                         }
[10:33:09.151]                       }
[10:33:09.151]                     }
[10:33:09.151]                     invisible(muffled)
[10:33:09.151]                   }
[10:33:09.151]                   muffleCondition(cond)
[10:33:09.151]                 })
[10:33:09.151]             }))
[10:33:09.151]             future::FutureResult(value = ...future.value$value, 
[10:33:09.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.151]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.151]                     ...future.globalenv.names))
[10:33:09.151]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.151]         }, condition = base::local({
[10:33:09.151]             c <- base::c
[10:33:09.151]             inherits <- base::inherits
[10:33:09.151]             invokeRestart <- base::invokeRestart
[10:33:09.151]             length <- base::length
[10:33:09.151]             list <- base::list
[10:33:09.151]             seq.int <- base::seq.int
[10:33:09.151]             signalCondition <- base::signalCondition
[10:33:09.151]             sys.calls <- base::sys.calls
[10:33:09.151]             `[[` <- base::`[[`
[10:33:09.151]             `+` <- base::`+`
[10:33:09.151]             `<<-` <- base::`<<-`
[10:33:09.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.151]                   3L)]
[10:33:09.151]             }
[10:33:09.151]             function(cond) {
[10:33:09.151]                 is_error <- inherits(cond, "error")
[10:33:09.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.151]                   NULL)
[10:33:09.151]                 if (is_error) {
[10:33:09.151]                   sessionInformation <- function() {
[10:33:09.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.151]                       search = base::search(), system = base::Sys.info())
[10:33:09.151]                   }
[10:33:09.151]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.151]                     cond$call), session = sessionInformation(), 
[10:33:09.151]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.151]                   signalCondition(cond)
[10:33:09.151]                 }
[10:33:09.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.151]                 "immediateCondition"))) {
[10:33:09.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.151]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.151]                   if (TRUE && !signal) {
[10:33:09.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.151]                     {
[10:33:09.151]                       inherits <- base::inherits
[10:33:09.151]                       invokeRestart <- base::invokeRestart
[10:33:09.151]                       is.null <- base::is.null
[10:33:09.151]                       muffled <- FALSE
[10:33:09.151]                       if (inherits(cond, "message")) {
[10:33:09.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.151]                         if (muffled) 
[10:33:09.151]                           invokeRestart("muffleMessage")
[10:33:09.151]                       }
[10:33:09.151]                       else if (inherits(cond, "warning")) {
[10:33:09.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.151]                         if (muffled) 
[10:33:09.151]                           invokeRestart("muffleWarning")
[10:33:09.151]                       }
[10:33:09.151]                       else if (inherits(cond, "condition")) {
[10:33:09.151]                         if (!is.null(pattern)) {
[10:33:09.151]                           computeRestarts <- base::computeRestarts
[10:33:09.151]                           grepl <- base::grepl
[10:33:09.151]                           restarts <- computeRestarts(cond)
[10:33:09.151]                           for (restart in restarts) {
[10:33:09.151]                             name <- restart$name
[10:33:09.151]                             if (is.null(name)) 
[10:33:09.151]                               next
[10:33:09.151]                             if (!grepl(pattern, name)) 
[10:33:09.151]                               next
[10:33:09.151]                             invokeRestart(restart)
[10:33:09.151]                             muffled <- TRUE
[10:33:09.151]                             break
[10:33:09.151]                           }
[10:33:09.151]                         }
[10:33:09.151]                       }
[10:33:09.151]                       invisible(muffled)
[10:33:09.151]                     }
[10:33:09.151]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.151]                   }
[10:33:09.151]                 }
[10:33:09.151]                 else {
[10:33:09.151]                   if (TRUE) {
[10:33:09.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.151]                     {
[10:33:09.151]                       inherits <- base::inherits
[10:33:09.151]                       invokeRestart <- base::invokeRestart
[10:33:09.151]                       is.null <- base::is.null
[10:33:09.151]                       muffled <- FALSE
[10:33:09.151]                       if (inherits(cond, "message")) {
[10:33:09.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.151]                         if (muffled) 
[10:33:09.151]                           invokeRestart("muffleMessage")
[10:33:09.151]                       }
[10:33:09.151]                       else if (inherits(cond, "warning")) {
[10:33:09.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.151]                         if (muffled) 
[10:33:09.151]                           invokeRestart("muffleWarning")
[10:33:09.151]                       }
[10:33:09.151]                       else if (inherits(cond, "condition")) {
[10:33:09.151]                         if (!is.null(pattern)) {
[10:33:09.151]                           computeRestarts <- base::computeRestarts
[10:33:09.151]                           grepl <- base::grepl
[10:33:09.151]                           restarts <- computeRestarts(cond)
[10:33:09.151]                           for (restart in restarts) {
[10:33:09.151]                             name <- restart$name
[10:33:09.151]                             if (is.null(name)) 
[10:33:09.151]                               next
[10:33:09.151]                             if (!grepl(pattern, name)) 
[10:33:09.151]                               next
[10:33:09.151]                             invokeRestart(restart)
[10:33:09.151]                             muffled <- TRUE
[10:33:09.151]                             break
[10:33:09.151]                           }
[10:33:09.151]                         }
[10:33:09.151]                       }
[10:33:09.151]                       invisible(muffled)
[10:33:09.151]                     }
[10:33:09.151]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.151]                   }
[10:33:09.151]                 }
[10:33:09.151]             }
[10:33:09.151]         }))
[10:33:09.151]     }, error = function(ex) {
[10:33:09.151]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.151]                 ...future.rng), started = ...future.startTime, 
[10:33:09.151]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.151]             version = "1.8"), class = "FutureResult")
[10:33:09.151]     }, finally = {
[10:33:09.151]         if (!identical(...future.workdir, getwd())) 
[10:33:09.151]             setwd(...future.workdir)
[10:33:09.151]         {
[10:33:09.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.151]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.151]             }
[10:33:09.151]             base::options(...future.oldOptions)
[10:33:09.151]             if (.Platform$OS.type == "windows") {
[10:33:09.151]                 old_names <- names(...future.oldEnvVars)
[10:33:09.151]                 envs <- base::Sys.getenv()
[10:33:09.151]                 names <- names(envs)
[10:33:09.151]                 common <- intersect(names, old_names)
[10:33:09.151]                 added <- setdiff(names, old_names)
[10:33:09.151]                 removed <- setdiff(old_names, names)
[10:33:09.151]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.151]                   envs[common]]
[10:33:09.151]                 NAMES <- toupper(changed)
[10:33:09.151]                 args <- list()
[10:33:09.151]                 for (kk in seq_along(NAMES)) {
[10:33:09.151]                   name <- changed[[kk]]
[10:33:09.151]                   NAME <- NAMES[[kk]]
[10:33:09.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.151]                     next
[10:33:09.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.151]                 }
[10:33:09.151]                 NAMES <- toupper(added)
[10:33:09.151]                 for (kk in seq_along(NAMES)) {
[10:33:09.151]                   name <- added[[kk]]
[10:33:09.151]                   NAME <- NAMES[[kk]]
[10:33:09.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.151]                     next
[10:33:09.151]                   args[[name]] <- ""
[10:33:09.151]                 }
[10:33:09.151]                 NAMES <- toupper(removed)
[10:33:09.151]                 for (kk in seq_along(NAMES)) {
[10:33:09.151]                   name <- removed[[kk]]
[10:33:09.151]                   NAME <- NAMES[[kk]]
[10:33:09.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.151]                     next
[10:33:09.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.151]                 }
[10:33:09.151]                 if (length(args) > 0) 
[10:33:09.151]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.151]             }
[10:33:09.151]             else {
[10:33:09.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.151]             }
[10:33:09.151]             {
[10:33:09.151]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.151]                   0L) {
[10:33:09.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.151]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.151]                   base::options(opts)
[10:33:09.151]                 }
[10:33:09.151]                 {
[10:33:09.151]                   {
[10:33:09.151]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.151]                     NULL
[10:33:09.151]                   }
[10:33:09.151]                   options(future.plan = NULL)
[10:33:09.151]                   if (is.na(NA_character_)) 
[10:33:09.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.151]                     .init = FALSE)
[10:33:09.151]                 }
[10:33:09.151]             }
[10:33:09.151]         }
[10:33:09.151]     })
[10:33:09.151]     if (TRUE) {
[10:33:09.151]         base::sink(type = "output", split = FALSE)
[10:33:09.151]         if (TRUE) {
[10:33:09.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.151]         }
[10:33:09.151]         else {
[10:33:09.151]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.151]         }
[10:33:09.151]         base::close(...future.stdout)
[10:33:09.151]         ...future.stdout <- NULL
[10:33:09.151]     }
[10:33:09.151]     ...future.result$conditions <- ...future.conditions
[10:33:09.151]     ...future.result$finished <- base::Sys.time()
[10:33:09.151]     ...future.result
[10:33:09.151] }
[10:33:09.154] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.154] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.154] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.154] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.155] MultisessionFuture started
[10:33:09.155] - Launch lazy future ... done
[10:33:09.155] run() for ‘MultisessionFuture’ ... done
[10:33:09.155] result() for ClusterFuture ...
[10:33:09.155] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.155] - Validating connection of MultisessionFuture
[10:33:09.156] - received message: FutureResult
[10:33:09.156] - Received FutureResult
[10:33:09.157] - Erased future from FutureRegistry
[10:33:09.157] result() for ClusterFuture ...
[10:33:09.157] - result already collected: FutureResult
[10:33:09.157] result() for ClusterFuture ... done
[10:33:09.157] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.157] result() for ClusterFuture ... done
[10:33:09.157] result() for ClusterFuture ...
[10:33:09.157] - result already collected: FutureResult
[10:33:09.157] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.158] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.158] Searching for globals...
[10:33:09.160] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:33:09.160] Searching for globals ... DONE
[10:33:09.160] Resolving globals: TRUE
[10:33:09.161] Resolving any globals that are futures ...
[10:33:09.161] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:33:09.161] Resolving any globals that are futures ... DONE
[10:33:09.161] 
[10:33:09.161] 
[10:33:09.161] getGlobalsAndPackages() ... DONE
[10:33:09.161] run() for ‘Future’ ...
[10:33:09.162] - state: ‘created’
[10:33:09.162] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.175]   - Field: ‘node’
[10:33:09.176]   - Field: ‘label’
[10:33:09.176]   - Field: ‘local’
[10:33:09.176]   - Field: ‘owner’
[10:33:09.176]   - Field: ‘envir’
[10:33:09.176]   - Field: ‘workers’
[10:33:09.176]   - Field: ‘packages’
[10:33:09.176]   - Field: ‘gc’
[10:33:09.176]   - Field: ‘conditions’
[10:33:09.176]   - Field: ‘persistent’
[10:33:09.176]   - Field: ‘expr’
[10:33:09.177]   - Field: ‘uuid’
[10:33:09.177]   - Field: ‘seed’
[10:33:09.177]   - Field: ‘version’
[10:33:09.177]   - Field: ‘result’
[10:33:09.177]   - Field: ‘asynchronous’
[10:33:09.177]   - Field: ‘calls’
[10:33:09.177]   - Field: ‘globals’
[10:33:09.177]   - Field: ‘stdout’
[10:33:09.177]   - Field: ‘earlySignal’
[10:33:09.177]   - Field: ‘lazy’
[10:33:09.178]   - Field: ‘state’
[10:33:09.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.178] - Launch lazy future ...
[10:33:09.178] Packages needed by the future expression (n = 0): <none>
[10:33:09.178] Packages needed by future strategies (n = 0): <none>
[10:33:09.179] {
[10:33:09.179]     {
[10:33:09.179]         {
[10:33:09.179]             ...future.startTime <- base::Sys.time()
[10:33:09.179]             {
[10:33:09.179]                 {
[10:33:09.179]                   {
[10:33:09.179]                     {
[10:33:09.179]                       base::local({
[10:33:09.179]                         has_future <- base::requireNamespace("future", 
[10:33:09.179]                           quietly = TRUE)
[10:33:09.179]                         if (has_future) {
[10:33:09.179]                           ns <- base::getNamespace("future")
[10:33:09.179]                           version <- ns[[".package"]][["version"]]
[10:33:09.179]                           if (is.null(version)) 
[10:33:09.179]                             version <- utils::packageVersion("future")
[10:33:09.179]                         }
[10:33:09.179]                         else {
[10:33:09.179]                           version <- NULL
[10:33:09.179]                         }
[10:33:09.179]                         if (!has_future || version < "1.8.0") {
[10:33:09.179]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.179]                             "", base::R.version$version.string), 
[10:33:09.179]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.179]                               "release", "version")], collapse = " "), 
[10:33:09.179]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.179]                             info)
[10:33:09.179]                           info <- base::paste(info, collapse = "; ")
[10:33:09.179]                           if (!has_future) {
[10:33:09.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.179]                               info)
[10:33:09.179]                           }
[10:33:09.179]                           else {
[10:33:09.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.179]                               info, version)
[10:33:09.179]                           }
[10:33:09.179]                           base::stop(msg)
[10:33:09.179]                         }
[10:33:09.179]                       })
[10:33:09.179]                     }
[10:33:09.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.179]                     base::options(mc.cores = 1L)
[10:33:09.179]                   }
[10:33:09.179]                   ...future.strategy.old <- future::plan("list")
[10:33:09.179]                   options(future.plan = NULL)
[10:33:09.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.179]                 }
[10:33:09.179]                 ...future.workdir <- getwd()
[10:33:09.179]             }
[10:33:09.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.179]         }
[10:33:09.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.179]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.179]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.179]             base::names(...future.oldOptions))
[10:33:09.179]     }
[10:33:09.179]     if (FALSE) {
[10:33:09.179]     }
[10:33:09.179]     else {
[10:33:09.179]         if (TRUE) {
[10:33:09.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.179]                 open = "w")
[10:33:09.179]         }
[10:33:09.179]         else {
[10:33:09.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.179]         }
[10:33:09.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.179]             base::sink(type = "output", split = FALSE)
[10:33:09.179]             base::close(...future.stdout)
[10:33:09.179]         }, add = TRUE)
[10:33:09.179]     }
[10:33:09.179]     ...future.frame <- base::sys.nframe()
[10:33:09.179]     ...future.conditions <- base::list()
[10:33:09.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.179]     if (FALSE) {
[10:33:09.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.179]     }
[10:33:09.179]     ...future.result <- base::tryCatch({
[10:33:09.179]         base::withCallingHandlers({
[10:33:09.179]             ...future.value <- base::withVisible(base::local({
[10:33:09.179]                 ...future.makeSendCondition <- base::local({
[10:33:09.179]                   sendCondition <- NULL
[10:33:09.179]                   function(frame = 1L) {
[10:33:09.179]                     if (is.function(sendCondition)) 
[10:33:09.179]                       return(sendCondition)
[10:33:09.179]                     ns <- getNamespace("parallel")
[10:33:09.179]                     if (exists("sendData", mode = "function", 
[10:33:09.179]                       envir = ns)) {
[10:33:09.179]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.179]                         envir = ns)
[10:33:09.179]                       envir <- sys.frame(frame)
[10:33:09.179]                       master <- NULL
[10:33:09.179]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.179]                         !identical(envir, emptyenv())) {
[10:33:09.179]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.179]                           inherits = FALSE)) {
[10:33:09.179]                           master <- get("master", mode = "list", 
[10:33:09.179]                             envir = envir, inherits = FALSE)
[10:33:09.179]                           if (inherits(master, c("SOCKnode", 
[10:33:09.179]                             "SOCK0node"))) {
[10:33:09.179]                             sendCondition <<- function(cond) {
[10:33:09.179]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.179]                                 success = TRUE)
[10:33:09.179]                               parallel_sendData(master, data)
[10:33:09.179]                             }
[10:33:09.179]                             return(sendCondition)
[10:33:09.179]                           }
[10:33:09.179]                         }
[10:33:09.179]                         frame <- frame + 1L
[10:33:09.179]                         envir <- sys.frame(frame)
[10:33:09.179]                       }
[10:33:09.179]                     }
[10:33:09.179]                     sendCondition <<- function(cond) NULL
[10:33:09.179]                   }
[10:33:09.179]                 })
[10:33:09.179]                 withCallingHandlers({
[10:33:09.179]                   {
[10:33:09.179]                     x <- list(b = 2)
[10:33:09.179]                     x$a <- 1
[10:33:09.179]                     x
[10:33:09.179]                   }
[10:33:09.179]                 }, immediateCondition = function(cond) {
[10:33:09.179]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.179]                   sendCondition(cond)
[10:33:09.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.179]                   {
[10:33:09.179]                     inherits <- base::inherits
[10:33:09.179]                     invokeRestart <- base::invokeRestart
[10:33:09.179]                     is.null <- base::is.null
[10:33:09.179]                     muffled <- FALSE
[10:33:09.179]                     if (inherits(cond, "message")) {
[10:33:09.179]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.179]                       if (muffled) 
[10:33:09.179]                         invokeRestart("muffleMessage")
[10:33:09.179]                     }
[10:33:09.179]                     else if (inherits(cond, "warning")) {
[10:33:09.179]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.179]                       if (muffled) 
[10:33:09.179]                         invokeRestart("muffleWarning")
[10:33:09.179]                     }
[10:33:09.179]                     else if (inherits(cond, "condition")) {
[10:33:09.179]                       if (!is.null(pattern)) {
[10:33:09.179]                         computeRestarts <- base::computeRestarts
[10:33:09.179]                         grepl <- base::grepl
[10:33:09.179]                         restarts <- computeRestarts(cond)
[10:33:09.179]                         for (restart in restarts) {
[10:33:09.179]                           name <- restart$name
[10:33:09.179]                           if (is.null(name)) 
[10:33:09.179]                             next
[10:33:09.179]                           if (!grepl(pattern, name)) 
[10:33:09.179]                             next
[10:33:09.179]                           invokeRestart(restart)
[10:33:09.179]                           muffled <- TRUE
[10:33:09.179]                           break
[10:33:09.179]                         }
[10:33:09.179]                       }
[10:33:09.179]                     }
[10:33:09.179]                     invisible(muffled)
[10:33:09.179]                   }
[10:33:09.179]                   muffleCondition(cond)
[10:33:09.179]                 })
[10:33:09.179]             }))
[10:33:09.179]             future::FutureResult(value = ...future.value$value, 
[10:33:09.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.179]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.179]                     ...future.globalenv.names))
[10:33:09.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.179]         }, condition = base::local({
[10:33:09.179]             c <- base::c
[10:33:09.179]             inherits <- base::inherits
[10:33:09.179]             invokeRestart <- base::invokeRestart
[10:33:09.179]             length <- base::length
[10:33:09.179]             list <- base::list
[10:33:09.179]             seq.int <- base::seq.int
[10:33:09.179]             signalCondition <- base::signalCondition
[10:33:09.179]             sys.calls <- base::sys.calls
[10:33:09.179]             `[[` <- base::`[[`
[10:33:09.179]             `+` <- base::`+`
[10:33:09.179]             `<<-` <- base::`<<-`
[10:33:09.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.179]                   3L)]
[10:33:09.179]             }
[10:33:09.179]             function(cond) {
[10:33:09.179]                 is_error <- inherits(cond, "error")
[10:33:09.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.179]                   NULL)
[10:33:09.179]                 if (is_error) {
[10:33:09.179]                   sessionInformation <- function() {
[10:33:09.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.179]                       search = base::search(), system = base::Sys.info())
[10:33:09.179]                   }
[10:33:09.179]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.179]                     cond$call), session = sessionInformation(), 
[10:33:09.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.179]                   signalCondition(cond)
[10:33:09.179]                 }
[10:33:09.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.179]                 "immediateCondition"))) {
[10:33:09.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.179]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.179]                   if (TRUE && !signal) {
[10:33:09.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.179]                     {
[10:33:09.179]                       inherits <- base::inherits
[10:33:09.179]                       invokeRestart <- base::invokeRestart
[10:33:09.179]                       is.null <- base::is.null
[10:33:09.179]                       muffled <- FALSE
[10:33:09.179]                       if (inherits(cond, "message")) {
[10:33:09.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.179]                         if (muffled) 
[10:33:09.179]                           invokeRestart("muffleMessage")
[10:33:09.179]                       }
[10:33:09.179]                       else if (inherits(cond, "warning")) {
[10:33:09.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.179]                         if (muffled) 
[10:33:09.179]                           invokeRestart("muffleWarning")
[10:33:09.179]                       }
[10:33:09.179]                       else if (inherits(cond, "condition")) {
[10:33:09.179]                         if (!is.null(pattern)) {
[10:33:09.179]                           computeRestarts <- base::computeRestarts
[10:33:09.179]                           grepl <- base::grepl
[10:33:09.179]                           restarts <- computeRestarts(cond)
[10:33:09.179]                           for (restart in restarts) {
[10:33:09.179]                             name <- restart$name
[10:33:09.179]                             if (is.null(name)) 
[10:33:09.179]                               next
[10:33:09.179]                             if (!grepl(pattern, name)) 
[10:33:09.179]                               next
[10:33:09.179]                             invokeRestart(restart)
[10:33:09.179]                             muffled <- TRUE
[10:33:09.179]                             break
[10:33:09.179]                           }
[10:33:09.179]                         }
[10:33:09.179]                       }
[10:33:09.179]                       invisible(muffled)
[10:33:09.179]                     }
[10:33:09.179]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.179]                   }
[10:33:09.179]                 }
[10:33:09.179]                 else {
[10:33:09.179]                   if (TRUE) {
[10:33:09.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.179]                     {
[10:33:09.179]                       inherits <- base::inherits
[10:33:09.179]                       invokeRestart <- base::invokeRestart
[10:33:09.179]                       is.null <- base::is.null
[10:33:09.179]                       muffled <- FALSE
[10:33:09.179]                       if (inherits(cond, "message")) {
[10:33:09.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.179]                         if (muffled) 
[10:33:09.179]                           invokeRestart("muffleMessage")
[10:33:09.179]                       }
[10:33:09.179]                       else if (inherits(cond, "warning")) {
[10:33:09.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.179]                         if (muffled) 
[10:33:09.179]                           invokeRestart("muffleWarning")
[10:33:09.179]                       }
[10:33:09.179]                       else if (inherits(cond, "condition")) {
[10:33:09.179]                         if (!is.null(pattern)) {
[10:33:09.179]                           computeRestarts <- base::computeRestarts
[10:33:09.179]                           grepl <- base::grepl
[10:33:09.179]                           restarts <- computeRestarts(cond)
[10:33:09.179]                           for (restart in restarts) {
[10:33:09.179]                             name <- restart$name
[10:33:09.179]                             if (is.null(name)) 
[10:33:09.179]                               next
[10:33:09.179]                             if (!grepl(pattern, name)) 
[10:33:09.179]                               next
[10:33:09.179]                             invokeRestart(restart)
[10:33:09.179]                             muffled <- TRUE
[10:33:09.179]                             break
[10:33:09.179]                           }
[10:33:09.179]                         }
[10:33:09.179]                       }
[10:33:09.179]                       invisible(muffled)
[10:33:09.179]                     }
[10:33:09.179]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.179]                   }
[10:33:09.179]                 }
[10:33:09.179]             }
[10:33:09.179]         }))
[10:33:09.179]     }, error = function(ex) {
[10:33:09.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.179]                 ...future.rng), started = ...future.startTime, 
[10:33:09.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.179]             version = "1.8"), class = "FutureResult")
[10:33:09.179]     }, finally = {
[10:33:09.179]         if (!identical(...future.workdir, getwd())) 
[10:33:09.179]             setwd(...future.workdir)
[10:33:09.179]         {
[10:33:09.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.179]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.179]             }
[10:33:09.179]             base::options(...future.oldOptions)
[10:33:09.179]             if (.Platform$OS.type == "windows") {
[10:33:09.179]                 old_names <- names(...future.oldEnvVars)
[10:33:09.179]                 envs <- base::Sys.getenv()
[10:33:09.179]                 names <- names(envs)
[10:33:09.179]                 common <- intersect(names, old_names)
[10:33:09.179]                 added <- setdiff(names, old_names)
[10:33:09.179]                 removed <- setdiff(old_names, names)
[10:33:09.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.179]                   envs[common]]
[10:33:09.179]                 NAMES <- toupper(changed)
[10:33:09.179]                 args <- list()
[10:33:09.179]                 for (kk in seq_along(NAMES)) {
[10:33:09.179]                   name <- changed[[kk]]
[10:33:09.179]                   NAME <- NAMES[[kk]]
[10:33:09.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.179]                     next
[10:33:09.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.179]                 }
[10:33:09.179]                 NAMES <- toupper(added)
[10:33:09.179]                 for (kk in seq_along(NAMES)) {
[10:33:09.179]                   name <- added[[kk]]
[10:33:09.179]                   NAME <- NAMES[[kk]]
[10:33:09.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.179]                     next
[10:33:09.179]                   args[[name]] <- ""
[10:33:09.179]                 }
[10:33:09.179]                 NAMES <- toupper(removed)
[10:33:09.179]                 for (kk in seq_along(NAMES)) {
[10:33:09.179]                   name <- removed[[kk]]
[10:33:09.179]                   NAME <- NAMES[[kk]]
[10:33:09.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.179]                     next
[10:33:09.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.179]                 }
[10:33:09.179]                 if (length(args) > 0) 
[10:33:09.179]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.179]             }
[10:33:09.179]             else {
[10:33:09.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.179]             }
[10:33:09.179]             {
[10:33:09.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.179]                   0L) {
[10:33:09.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.179]                   base::options(opts)
[10:33:09.179]                 }
[10:33:09.179]                 {
[10:33:09.179]                   {
[10:33:09.179]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.179]                     NULL
[10:33:09.179]                   }
[10:33:09.179]                   options(future.plan = NULL)
[10:33:09.179]                   if (is.na(NA_character_)) 
[10:33:09.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.179]                     .init = FALSE)
[10:33:09.179]                 }
[10:33:09.179]             }
[10:33:09.179]         }
[10:33:09.179]     })
[10:33:09.179]     if (TRUE) {
[10:33:09.179]         base::sink(type = "output", split = FALSE)
[10:33:09.179]         if (TRUE) {
[10:33:09.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.179]         }
[10:33:09.179]         else {
[10:33:09.179]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.179]         }
[10:33:09.179]         base::close(...future.stdout)
[10:33:09.179]         ...future.stdout <- NULL
[10:33:09.179]     }
[10:33:09.179]     ...future.result$conditions <- ...future.conditions
[10:33:09.179]     ...future.result$finished <- base::Sys.time()
[10:33:09.179]     ...future.result
[10:33:09.179] }
[10:33:09.181] MultisessionFuture started
[10:33:09.182] - Launch lazy future ... done
[10:33:09.182] run() for ‘MultisessionFuture’ ... done
[10:33:09.182] result() for ClusterFuture ...
[10:33:09.182] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.182] - Validating connection of MultisessionFuture
[10:33:09.183] - received message: FutureResult
[10:33:09.183] - Received FutureResult
[10:33:09.184] - Erased future from FutureRegistry
[10:33:09.184] result() for ClusterFuture ...
[10:33:09.184] - result already collected: FutureResult
[10:33:09.184] result() for ClusterFuture ... done
[10:33:09.184] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.184] result() for ClusterFuture ... done
[10:33:09.184] result() for ClusterFuture ...
[10:33:09.184] - result already collected: FutureResult
[10:33:09.184] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.185] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.185] Searching for globals...
[10:33:09.187] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:09.187] Searching for globals ... DONE
[10:33:09.187] Resolving globals: TRUE
[10:33:09.187] Resolving any globals that are futures ...
[10:33:09.187] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:09.187] Resolving any globals that are futures ... DONE
[10:33:09.188] Resolving futures part of globals (recursively) ...
[10:33:09.188] resolve() on list ...
[10:33:09.188]  recursive: 99
[10:33:09.188]  length: 1
[10:33:09.188]  elements: ‘x’
[10:33:09.188]  length: 0 (resolved future 1)
[10:33:09.188] resolve() on list ... DONE
[10:33:09.188] - globals: [1] ‘x’
[10:33:09.188] Resolving futures part of globals (recursively) ... DONE
[10:33:09.189] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.189] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.189] - globals: [1] ‘x’
[10:33:09.189] 
[10:33:09.189] getGlobalsAndPackages() ... DONE
[10:33:09.190] run() for ‘Future’ ...
[10:33:09.190] - state: ‘created’
[10:33:09.190] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.203] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.203]   - Field: ‘node’
[10:33:09.203]   - Field: ‘label’
[10:33:09.203]   - Field: ‘local’
[10:33:09.203]   - Field: ‘owner’
[10:33:09.204]   - Field: ‘envir’
[10:33:09.204]   - Field: ‘workers’
[10:33:09.204]   - Field: ‘packages’
[10:33:09.204]   - Field: ‘gc’
[10:33:09.204]   - Field: ‘conditions’
[10:33:09.204]   - Field: ‘persistent’
[10:33:09.204]   - Field: ‘expr’
[10:33:09.204]   - Field: ‘uuid’
[10:33:09.204]   - Field: ‘seed’
[10:33:09.204]   - Field: ‘version’
[10:33:09.205]   - Field: ‘result’
[10:33:09.205]   - Field: ‘asynchronous’
[10:33:09.205]   - Field: ‘calls’
[10:33:09.205]   - Field: ‘globals’
[10:33:09.205]   - Field: ‘stdout’
[10:33:09.205]   - Field: ‘earlySignal’
[10:33:09.205]   - Field: ‘lazy’
[10:33:09.205]   - Field: ‘state’
[10:33:09.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.205] - Launch lazy future ...
[10:33:09.206] Packages needed by the future expression (n = 0): <none>
[10:33:09.206] Packages needed by future strategies (n = 0): <none>
[10:33:09.206] {
[10:33:09.206]     {
[10:33:09.206]         {
[10:33:09.206]             ...future.startTime <- base::Sys.time()
[10:33:09.206]             {
[10:33:09.206]                 {
[10:33:09.206]                   {
[10:33:09.206]                     {
[10:33:09.206]                       base::local({
[10:33:09.206]                         has_future <- base::requireNamespace("future", 
[10:33:09.206]                           quietly = TRUE)
[10:33:09.206]                         if (has_future) {
[10:33:09.206]                           ns <- base::getNamespace("future")
[10:33:09.206]                           version <- ns[[".package"]][["version"]]
[10:33:09.206]                           if (is.null(version)) 
[10:33:09.206]                             version <- utils::packageVersion("future")
[10:33:09.206]                         }
[10:33:09.206]                         else {
[10:33:09.206]                           version <- NULL
[10:33:09.206]                         }
[10:33:09.206]                         if (!has_future || version < "1.8.0") {
[10:33:09.206]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.206]                             "", base::R.version$version.string), 
[10:33:09.206]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.206]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.206]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.206]                               "release", "version")], collapse = " "), 
[10:33:09.206]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.206]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.206]                             info)
[10:33:09.206]                           info <- base::paste(info, collapse = "; ")
[10:33:09.206]                           if (!has_future) {
[10:33:09.206]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.206]                               info)
[10:33:09.206]                           }
[10:33:09.206]                           else {
[10:33:09.206]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.206]                               info, version)
[10:33:09.206]                           }
[10:33:09.206]                           base::stop(msg)
[10:33:09.206]                         }
[10:33:09.206]                       })
[10:33:09.206]                     }
[10:33:09.206]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.206]                     base::options(mc.cores = 1L)
[10:33:09.206]                   }
[10:33:09.206]                   ...future.strategy.old <- future::plan("list")
[10:33:09.206]                   options(future.plan = NULL)
[10:33:09.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.206]                 }
[10:33:09.206]                 ...future.workdir <- getwd()
[10:33:09.206]             }
[10:33:09.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.206]         }
[10:33:09.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.206]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.206]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.206]             base::names(...future.oldOptions))
[10:33:09.206]     }
[10:33:09.206]     if (FALSE) {
[10:33:09.206]     }
[10:33:09.206]     else {
[10:33:09.206]         if (TRUE) {
[10:33:09.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.206]                 open = "w")
[10:33:09.206]         }
[10:33:09.206]         else {
[10:33:09.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.206]         }
[10:33:09.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.206]             base::sink(type = "output", split = FALSE)
[10:33:09.206]             base::close(...future.stdout)
[10:33:09.206]         }, add = TRUE)
[10:33:09.206]     }
[10:33:09.206]     ...future.frame <- base::sys.nframe()
[10:33:09.206]     ...future.conditions <- base::list()
[10:33:09.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.206]     if (FALSE) {
[10:33:09.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.206]     }
[10:33:09.206]     ...future.result <- base::tryCatch({
[10:33:09.206]         base::withCallingHandlers({
[10:33:09.206]             ...future.value <- base::withVisible(base::local({
[10:33:09.206]                 ...future.makeSendCondition <- base::local({
[10:33:09.206]                   sendCondition <- NULL
[10:33:09.206]                   function(frame = 1L) {
[10:33:09.206]                     if (is.function(sendCondition)) 
[10:33:09.206]                       return(sendCondition)
[10:33:09.206]                     ns <- getNamespace("parallel")
[10:33:09.206]                     if (exists("sendData", mode = "function", 
[10:33:09.206]                       envir = ns)) {
[10:33:09.206]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.206]                         envir = ns)
[10:33:09.206]                       envir <- sys.frame(frame)
[10:33:09.206]                       master <- NULL
[10:33:09.206]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.206]                         !identical(envir, emptyenv())) {
[10:33:09.206]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.206]                           inherits = FALSE)) {
[10:33:09.206]                           master <- get("master", mode = "list", 
[10:33:09.206]                             envir = envir, inherits = FALSE)
[10:33:09.206]                           if (inherits(master, c("SOCKnode", 
[10:33:09.206]                             "SOCK0node"))) {
[10:33:09.206]                             sendCondition <<- function(cond) {
[10:33:09.206]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.206]                                 success = TRUE)
[10:33:09.206]                               parallel_sendData(master, data)
[10:33:09.206]                             }
[10:33:09.206]                             return(sendCondition)
[10:33:09.206]                           }
[10:33:09.206]                         }
[10:33:09.206]                         frame <- frame + 1L
[10:33:09.206]                         envir <- sys.frame(frame)
[10:33:09.206]                       }
[10:33:09.206]                     }
[10:33:09.206]                     sendCondition <<- function(cond) NULL
[10:33:09.206]                   }
[10:33:09.206]                 })
[10:33:09.206]                 withCallingHandlers({
[10:33:09.206]                   {
[10:33:09.206]                     x[["a"]] <- 1
[10:33:09.206]                     x
[10:33:09.206]                   }
[10:33:09.206]                 }, immediateCondition = function(cond) {
[10:33:09.206]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.206]                   sendCondition(cond)
[10:33:09.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.206]                   {
[10:33:09.206]                     inherits <- base::inherits
[10:33:09.206]                     invokeRestart <- base::invokeRestart
[10:33:09.206]                     is.null <- base::is.null
[10:33:09.206]                     muffled <- FALSE
[10:33:09.206]                     if (inherits(cond, "message")) {
[10:33:09.206]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.206]                       if (muffled) 
[10:33:09.206]                         invokeRestart("muffleMessage")
[10:33:09.206]                     }
[10:33:09.206]                     else if (inherits(cond, "warning")) {
[10:33:09.206]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.206]                       if (muffled) 
[10:33:09.206]                         invokeRestart("muffleWarning")
[10:33:09.206]                     }
[10:33:09.206]                     else if (inherits(cond, "condition")) {
[10:33:09.206]                       if (!is.null(pattern)) {
[10:33:09.206]                         computeRestarts <- base::computeRestarts
[10:33:09.206]                         grepl <- base::grepl
[10:33:09.206]                         restarts <- computeRestarts(cond)
[10:33:09.206]                         for (restart in restarts) {
[10:33:09.206]                           name <- restart$name
[10:33:09.206]                           if (is.null(name)) 
[10:33:09.206]                             next
[10:33:09.206]                           if (!grepl(pattern, name)) 
[10:33:09.206]                             next
[10:33:09.206]                           invokeRestart(restart)
[10:33:09.206]                           muffled <- TRUE
[10:33:09.206]                           break
[10:33:09.206]                         }
[10:33:09.206]                       }
[10:33:09.206]                     }
[10:33:09.206]                     invisible(muffled)
[10:33:09.206]                   }
[10:33:09.206]                   muffleCondition(cond)
[10:33:09.206]                 })
[10:33:09.206]             }))
[10:33:09.206]             future::FutureResult(value = ...future.value$value, 
[10:33:09.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.206]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.206]                     ...future.globalenv.names))
[10:33:09.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.206]         }, condition = base::local({
[10:33:09.206]             c <- base::c
[10:33:09.206]             inherits <- base::inherits
[10:33:09.206]             invokeRestart <- base::invokeRestart
[10:33:09.206]             length <- base::length
[10:33:09.206]             list <- base::list
[10:33:09.206]             seq.int <- base::seq.int
[10:33:09.206]             signalCondition <- base::signalCondition
[10:33:09.206]             sys.calls <- base::sys.calls
[10:33:09.206]             `[[` <- base::`[[`
[10:33:09.206]             `+` <- base::`+`
[10:33:09.206]             `<<-` <- base::`<<-`
[10:33:09.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.206]                   3L)]
[10:33:09.206]             }
[10:33:09.206]             function(cond) {
[10:33:09.206]                 is_error <- inherits(cond, "error")
[10:33:09.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.206]                   NULL)
[10:33:09.206]                 if (is_error) {
[10:33:09.206]                   sessionInformation <- function() {
[10:33:09.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.206]                       search = base::search(), system = base::Sys.info())
[10:33:09.206]                   }
[10:33:09.206]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.206]                     cond$call), session = sessionInformation(), 
[10:33:09.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.206]                   signalCondition(cond)
[10:33:09.206]                 }
[10:33:09.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.206]                 "immediateCondition"))) {
[10:33:09.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.206]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.206]                   if (TRUE && !signal) {
[10:33:09.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.206]                     {
[10:33:09.206]                       inherits <- base::inherits
[10:33:09.206]                       invokeRestart <- base::invokeRestart
[10:33:09.206]                       is.null <- base::is.null
[10:33:09.206]                       muffled <- FALSE
[10:33:09.206]                       if (inherits(cond, "message")) {
[10:33:09.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.206]                         if (muffled) 
[10:33:09.206]                           invokeRestart("muffleMessage")
[10:33:09.206]                       }
[10:33:09.206]                       else if (inherits(cond, "warning")) {
[10:33:09.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.206]                         if (muffled) 
[10:33:09.206]                           invokeRestart("muffleWarning")
[10:33:09.206]                       }
[10:33:09.206]                       else if (inherits(cond, "condition")) {
[10:33:09.206]                         if (!is.null(pattern)) {
[10:33:09.206]                           computeRestarts <- base::computeRestarts
[10:33:09.206]                           grepl <- base::grepl
[10:33:09.206]                           restarts <- computeRestarts(cond)
[10:33:09.206]                           for (restart in restarts) {
[10:33:09.206]                             name <- restart$name
[10:33:09.206]                             if (is.null(name)) 
[10:33:09.206]                               next
[10:33:09.206]                             if (!grepl(pattern, name)) 
[10:33:09.206]                               next
[10:33:09.206]                             invokeRestart(restart)
[10:33:09.206]                             muffled <- TRUE
[10:33:09.206]                             break
[10:33:09.206]                           }
[10:33:09.206]                         }
[10:33:09.206]                       }
[10:33:09.206]                       invisible(muffled)
[10:33:09.206]                     }
[10:33:09.206]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.206]                   }
[10:33:09.206]                 }
[10:33:09.206]                 else {
[10:33:09.206]                   if (TRUE) {
[10:33:09.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.206]                     {
[10:33:09.206]                       inherits <- base::inherits
[10:33:09.206]                       invokeRestart <- base::invokeRestart
[10:33:09.206]                       is.null <- base::is.null
[10:33:09.206]                       muffled <- FALSE
[10:33:09.206]                       if (inherits(cond, "message")) {
[10:33:09.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.206]                         if (muffled) 
[10:33:09.206]                           invokeRestart("muffleMessage")
[10:33:09.206]                       }
[10:33:09.206]                       else if (inherits(cond, "warning")) {
[10:33:09.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.206]                         if (muffled) 
[10:33:09.206]                           invokeRestart("muffleWarning")
[10:33:09.206]                       }
[10:33:09.206]                       else if (inherits(cond, "condition")) {
[10:33:09.206]                         if (!is.null(pattern)) {
[10:33:09.206]                           computeRestarts <- base::computeRestarts
[10:33:09.206]                           grepl <- base::grepl
[10:33:09.206]                           restarts <- computeRestarts(cond)
[10:33:09.206]                           for (restart in restarts) {
[10:33:09.206]                             name <- restart$name
[10:33:09.206]                             if (is.null(name)) 
[10:33:09.206]                               next
[10:33:09.206]                             if (!grepl(pattern, name)) 
[10:33:09.206]                               next
[10:33:09.206]                             invokeRestart(restart)
[10:33:09.206]                             muffled <- TRUE
[10:33:09.206]                             break
[10:33:09.206]                           }
[10:33:09.206]                         }
[10:33:09.206]                       }
[10:33:09.206]                       invisible(muffled)
[10:33:09.206]                     }
[10:33:09.206]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.206]                   }
[10:33:09.206]                 }
[10:33:09.206]             }
[10:33:09.206]         }))
[10:33:09.206]     }, error = function(ex) {
[10:33:09.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.206]                 ...future.rng), started = ...future.startTime, 
[10:33:09.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.206]             version = "1.8"), class = "FutureResult")
[10:33:09.206]     }, finally = {
[10:33:09.206]         if (!identical(...future.workdir, getwd())) 
[10:33:09.206]             setwd(...future.workdir)
[10:33:09.206]         {
[10:33:09.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.206]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.206]             }
[10:33:09.206]             base::options(...future.oldOptions)
[10:33:09.206]             if (.Platform$OS.type == "windows") {
[10:33:09.206]                 old_names <- names(...future.oldEnvVars)
[10:33:09.206]                 envs <- base::Sys.getenv()
[10:33:09.206]                 names <- names(envs)
[10:33:09.206]                 common <- intersect(names, old_names)
[10:33:09.206]                 added <- setdiff(names, old_names)
[10:33:09.206]                 removed <- setdiff(old_names, names)
[10:33:09.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.206]                   envs[common]]
[10:33:09.206]                 NAMES <- toupper(changed)
[10:33:09.206]                 args <- list()
[10:33:09.206]                 for (kk in seq_along(NAMES)) {
[10:33:09.206]                   name <- changed[[kk]]
[10:33:09.206]                   NAME <- NAMES[[kk]]
[10:33:09.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.206]                     next
[10:33:09.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.206]                 }
[10:33:09.206]                 NAMES <- toupper(added)
[10:33:09.206]                 for (kk in seq_along(NAMES)) {
[10:33:09.206]                   name <- added[[kk]]
[10:33:09.206]                   NAME <- NAMES[[kk]]
[10:33:09.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.206]                     next
[10:33:09.206]                   args[[name]] <- ""
[10:33:09.206]                 }
[10:33:09.206]                 NAMES <- toupper(removed)
[10:33:09.206]                 for (kk in seq_along(NAMES)) {
[10:33:09.206]                   name <- removed[[kk]]
[10:33:09.206]                   NAME <- NAMES[[kk]]
[10:33:09.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.206]                     next
[10:33:09.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.206]                 }
[10:33:09.206]                 if (length(args) > 0) 
[10:33:09.206]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.206]             }
[10:33:09.206]             else {
[10:33:09.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.206]             }
[10:33:09.206]             {
[10:33:09.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.206]                   0L) {
[10:33:09.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.206]                   base::options(opts)
[10:33:09.206]                 }
[10:33:09.206]                 {
[10:33:09.206]                   {
[10:33:09.206]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.206]                     NULL
[10:33:09.206]                   }
[10:33:09.206]                   options(future.plan = NULL)
[10:33:09.206]                   if (is.na(NA_character_)) 
[10:33:09.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.206]                     .init = FALSE)
[10:33:09.206]                 }
[10:33:09.206]             }
[10:33:09.206]         }
[10:33:09.206]     })
[10:33:09.206]     if (TRUE) {
[10:33:09.206]         base::sink(type = "output", split = FALSE)
[10:33:09.206]         if (TRUE) {
[10:33:09.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.206]         }
[10:33:09.206]         else {
[10:33:09.206]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.206]         }
[10:33:09.206]         base::close(...future.stdout)
[10:33:09.206]         ...future.stdout <- NULL
[10:33:09.206]     }
[10:33:09.206]     ...future.result$conditions <- ...future.conditions
[10:33:09.206]     ...future.result$finished <- base::Sys.time()
[10:33:09.206]     ...future.result
[10:33:09.206] }
[10:33:09.209] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.209] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.209] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.209] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.210] MultisessionFuture started
[10:33:09.210] - Launch lazy future ... done
[10:33:09.210] run() for ‘MultisessionFuture’ ... done
[10:33:09.210] result() for ClusterFuture ...
[10:33:09.210] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.210] - Validating connection of MultisessionFuture
[10:33:09.211] - received message: FutureResult
[10:33:09.211] - Received FutureResult
[10:33:09.211] - Erased future from FutureRegistry
[10:33:09.211] result() for ClusterFuture ...
[10:33:09.211] - result already collected: FutureResult
[10:33:09.212] result() for ClusterFuture ... done
[10:33:09.212] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.212] result() for ClusterFuture ... done
[10:33:09.212] result() for ClusterFuture ...
[10:33:09.212] - result already collected: FutureResult
[10:33:09.212] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.212] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.212] Searching for globals...
[10:33:09.214] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:09.214] Searching for globals ... DONE
[10:33:09.214] Resolving globals: TRUE
[10:33:09.215] Resolving any globals that are futures ...
[10:33:09.215] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:09.215] Resolving any globals that are futures ... DONE
[10:33:09.215] Resolving futures part of globals (recursively) ...
[10:33:09.215] resolve() on list ...
[10:33:09.215]  recursive: 99
[10:33:09.216]  length: 1
[10:33:09.216]  elements: ‘x’
[10:33:09.216]  length: 0 (resolved future 1)
[10:33:09.216] resolve() on list ... DONE
[10:33:09.216] - globals: [1] ‘x’
[10:33:09.216] Resolving futures part of globals (recursively) ... DONE
[10:33:09.216] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.216] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.217] - globals: [1] ‘x’
[10:33:09.217] 
[10:33:09.217] getGlobalsAndPackages() ... DONE
[10:33:09.217] run() for ‘Future’ ...
[10:33:09.217] - state: ‘created’
[10:33:09.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.231]   - Field: ‘node’
[10:33:09.231]   - Field: ‘label’
[10:33:09.231]   - Field: ‘local’
[10:33:09.231]   - Field: ‘owner’
[10:33:09.231]   - Field: ‘envir’
[10:33:09.231]   - Field: ‘workers’
[10:33:09.231]   - Field: ‘packages’
[10:33:09.231]   - Field: ‘gc’
[10:33:09.231]   - Field: ‘conditions’
[10:33:09.232]   - Field: ‘persistent’
[10:33:09.232]   - Field: ‘expr’
[10:33:09.232]   - Field: ‘uuid’
[10:33:09.232]   - Field: ‘seed’
[10:33:09.232]   - Field: ‘version’
[10:33:09.232]   - Field: ‘result’
[10:33:09.232]   - Field: ‘asynchronous’
[10:33:09.232]   - Field: ‘calls’
[10:33:09.232]   - Field: ‘globals’
[10:33:09.232]   - Field: ‘stdout’
[10:33:09.232]   - Field: ‘earlySignal’
[10:33:09.233]   - Field: ‘lazy’
[10:33:09.233]   - Field: ‘state’
[10:33:09.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.233] - Launch lazy future ...
[10:33:09.233] Packages needed by the future expression (n = 0): <none>
[10:33:09.233] Packages needed by future strategies (n = 0): <none>
[10:33:09.234] {
[10:33:09.234]     {
[10:33:09.234]         {
[10:33:09.234]             ...future.startTime <- base::Sys.time()
[10:33:09.234]             {
[10:33:09.234]                 {
[10:33:09.234]                   {
[10:33:09.234]                     {
[10:33:09.234]                       base::local({
[10:33:09.234]                         has_future <- base::requireNamespace("future", 
[10:33:09.234]                           quietly = TRUE)
[10:33:09.234]                         if (has_future) {
[10:33:09.234]                           ns <- base::getNamespace("future")
[10:33:09.234]                           version <- ns[[".package"]][["version"]]
[10:33:09.234]                           if (is.null(version)) 
[10:33:09.234]                             version <- utils::packageVersion("future")
[10:33:09.234]                         }
[10:33:09.234]                         else {
[10:33:09.234]                           version <- NULL
[10:33:09.234]                         }
[10:33:09.234]                         if (!has_future || version < "1.8.0") {
[10:33:09.234]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.234]                             "", base::R.version$version.string), 
[10:33:09.234]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.234]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.234]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.234]                               "release", "version")], collapse = " "), 
[10:33:09.234]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.234]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.234]                             info)
[10:33:09.234]                           info <- base::paste(info, collapse = "; ")
[10:33:09.234]                           if (!has_future) {
[10:33:09.234]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.234]                               info)
[10:33:09.234]                           }
[10:33:09.234]                           else {
[10:33:09.234]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.234]                               info, version)
[10:33:09.234]                           }
[10:33:09.234]                           base::stop(msg)
[10:33:09.234]                         }
[10:33:09.234]                       })
[10:33:09.234]                     }
[10:33:09.234]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.234]                     base::options(mc.cores = 1L)
[10:33:09.234]                   }
[10:33:09.234]                   ...future.strategy.old <- future::plan("list")
[10:33:09.234]                   options(future.plan = NULL)
[10:33:09.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.234]                 }
[10:33:09.234]                 ...future.workdir <- getwd()
[10:33:09.234]             }
[10:33:09.234]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.234]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.234]         }
[10:33:09.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.234]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.234]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.234]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.234]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.234]             base::names(...future.oldOptions))
[10:33:09.234]     }
[10:33:09.234]     if (FALSE) {
[10:33:09.234]     }
[10:33:09.234]     else {
[10:33:09.234]         if (TRUE) {
[10:33:09.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.234]                 open = "w")
[10:33:09.234]         }
[10:33:09.234]         else {
[10:33:09.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.234]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.234]         }
[10:33:09.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.234]             base::sink(type = "output", split = FALSE)
[10:33:09.234]             base::close(...future.stdout)
[10:33:09.234]         }, add = TRUE)
[10:33:09.234]     }
[10:33:09.234]     ...future.frame <- base::sys.nframe()
[10:33:09.234]     ...future.conditions <- base::list()
[10:33:09.234]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.234]     if (FALSE) {
[10:33:09.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.234]     }
[10:33:09.234]     ...future.result <- base::tryCatch({
[10:33:09.234]         base::withCallingHandlers({
[10:33:09.234]             ...future.value <- base::withVisible(base::local({
[10:33:09.234]                 ...future.makeSendCondition <- base::local({
[10:33:09.234]                   sendCondition <- NULL
[10:33:09.234]                   function(frame = 1L) {
[10:33:09.234]                     if (is.function(sendCondition)) 
[10:33:09.234]                       return(sendCondition)
[10:33:09.234]                     ns <- getNamespace("parallel")
[10:33:09.234]                     if (exists("sendData", mode = "function", 
[10:33:09.234]                       envir = ns)) {
[10:33:09.234]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.234]                         envir = ns)
[10:33:09.234]                       envir <- sys.frame(frame)
[10:33:09.234]                       master <- NULL
[10:33:09.234]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.234]                         !identical(envir, emptyenv())) {
[10:33:09.234]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.234]                           inherits = FALSE)) {
[10:33:09.234]                           master <- get("master", mode = "list", 
[10:33:09.234]                             envir = envir, inherits = FALSE)
[10:33:09.234]                           if (inherits(master, c("SOCKnode", 
[10:33:09.234]                             "SOCK0node"))) {
[10:33:09.234]                             sendCondition <<- function(cond) {
[10:33:09.234]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.234]                                 success = TRUE)
[10:33:09.234]                               parallel_sendData(master, data)
[10:33:09.234]                             }
[10:33:09.234]                             return(sendCondition)
[10:33:09.234]                           }
[10:33:09.234]                         }
[10:33:09.234]                         frame <- frame + 1L
[10:33:09.234]                         envir <- sys.frame(frame)
[10:33:09.234]                       }
[10:33:09.234]                     }
[10:33:09.234]                     sendCondition <<- function(cond) NULL
[10:33:09.234]                   }
[10:33:09.234]                 })
[10:33:09.234]                 withCallingHandlers({
[10:33:09.234]                   {
[10:33:09.234]                     x[["a"]] <- 1
[10:33:09.234]                     x
[10:33:09.234]                   }
[10:33:09.234]                 }, immediateCondition = function(cond) {
[10:33:09.234]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.234]                   sendCondition(cond)
[10:33:09.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.234]                   {
[10:33:09.234]                     inherits <- base::inherits
[10:33:09.234]                     invokeRestart <- base::invokeRestart
[10:33:09.234]                     is.null <- base::is.null
[10:33:09.234]                     muffled <- FALSE
[10:33:09.234]                     if (inherits(cond, "message")) {
[10:33:09.234]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.234]                       if (muffled) 
[10:33:09.234]                         invokeRestart("muffleMessage")
[10:33:09.234]                     }
[10:33:09.234]                     else if (inherits(cond, "warning")) {
[10:33:09.234]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.234]                       if (muffled) 
[10:33:09.234]                         invokeRestart("muffleWarning")
[10:33:09.234]                     }
[10:33:09.234]                     else if (inherits(cond, "condition")) {
[10:33:09.234]                       if (!is.null(pattern)) {
[10:33:09.234]                         computeRestarts <- base::computeRestarts
[10:33:09.234]                         grepl <- base::grepl
[10:33:09.234]                         restarts <- computeRestarts(cond)
[10:33:09.234]                         for (restart in restarts) {
[10:33:09.234]                           name <- restart$name
[10:33:09.234]                           if (is.null(name)) 
[10:33:09.234]                             next
[10:33:09.234]                           if (!grepl(pattern, name)) 
[10:33:09.234]                             next
[10:33:09.234]                           invokeRestart(restart)
[10:33:09.234]                           muffled <- TRUE
[10:33:09.234]                           break
[10:33:09.234]                         }
[10:33:09.234]                       }
[10:33:09.234]                     }
[10:33:09.234]                     invisible(muffled)
[10:33:09.234]                   }
[10:33:09.234]                   muffleCondition(cond)
[10:33:09.234]                 })
[10:33:09.234]             }))
[10:33:09.234]             future::FutureResult(value = ...future.value$value, 
[10:33:09.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.234]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.234]                     ...future.globalenv.names))
[10:33:09.234]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.234]         }, condition = base::local({
[10:33:09.234]             c <- base::c
[10:33:09.234]             inherits <- base::inherits
[10:33:09.234]             invokeRestart <- base::invokeRestart
[10:33:09.234]             length <- base::length
[10:33:09.234]             list <- base::list
[10:33:09.234]             seq.int <- base::seq.int
[10:33:09.234]             signalCondition <- base::signalCondition
[10:33:09.234]             sys.calls <- base::sys.calls
[10:33:09.234]             `[[` <- base::`[[`
[10:33:09.234]             `+` <- base::`+`
[10:33:09.234]             `<<-` <- base::`<<-`
[10:33:09.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.234]                   3L)]
[10:33:09.234]             }
[10:33:09.234]             function(cond) {
[10:33:09.234]                 is_error <- inherits(cond, "error")
[10:33:09.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.234]                   NULL)
[10:33:09.234]                 if (is_error) {
[10:33:09.234]                   sessionInformation <- function() {
[10:33:09.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.234]                       search = base::search(), system = base::Sys.info())
[10:33:09.234]                   }
[10:33:09.234]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.234]                     cond$call), session = sessionInformation(), 
[10:33:09.234]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.234]                   signalCondition(cond)
[10:33:09.234]                 }
[10:33:09.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.234]                 "immediateCondition"))) {
[10:33:09.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.234]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.234]                   if (TRUE && !signal) {
[10:33:09.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.234]                     {
[10:33:09.234]                       inherits <- base::inherits
[10:33:09.234]                       invokeRestart <- base::invokeRestart
[10:33:09.234]                       is.null <- base::is.null
[10:33:09.234]                       muffled <- FALSE
[10:33:09.234]                       if (inherits(cond, "message")) {
[10:33:09.234]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.234]                         if (muffled) 
[10:33:09.234]                           invokeRestart("muffleMessage")
[10:33:09.234]                       }
[10:33:09.234]                       else if (inherits(cond, "warning")) {
[10:33:09.234]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.234]                         if (muffled) 
[10:33:09.234]                           invokeRestart("muffleWarning")
[10:33:09.234]                       }
[10:33:09.234]                       else if (inherits(cond, "condition")) {
[10:33:09.234]                         if (!is.null(pattern)) {
[10:33:09.234]                           computeRestarts <- base::computeRestarts
[10:33:09.234]                           grepl <- base::grepl
[10:33:09.234]                           restarts <- computeRestarts(cond)
[10:33:09.234]                           for (restart in restarts) {
[10:33:09.234]                             name <- restart$name
[10:33:09.234]                             if (is.null(name)) 
[10:33:09.234]                               next
[10:33:09.234]                             if (!grepl(pattern, name)) 
[10:33:09.234]                               next
[10:33:09.234]                             invokeRestart(restart)
[10:33:09.234]                             muffled <- TRUE
[10:33:09.234]                             break
[10:33:09.234]                           }
[10:33:09.234]                         }
[10:33:09.234]                       }
[10:33:09.234]                       invisible(muffled)
[10:33:09.234]                     }
[10:33:09.234]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.234]                   }
[10:33:09.234]                 }
[10:33:09.234]                 else {
[10:33:09.234]                   if (TRUE) {
[10:33:09.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.234]                     {
[10:33:09.234]                       inherits <- base::inherits
[10:33:09.234]                       invokeRestart <- base::invokeRestart
[10:33:09.234]                       is.null <- base::is.null
[10:33:09.234]                       muffled <- FALSE
[10:33:09.234]                       if (inherits(cond, "message")) {
[10:33:09.234]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.234]                         if (muffled) 
[10:33:09.234]                           invokeRestart("muffleMessage")
[10:33:09.234]                       }
[10:33:09.234]                       else if (inherits(cond, "warning")) {
[10:33:09.234]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.234]                         if (muffled) 
[10:33:09.234]                           invokeRestart("muffleWarning")
[10:33:09.234]                       }
[10:33:09.234]                       else if (inherits(cond, "condition")) {
[10:33:09.234]                         if (!is.null(pattern)) {
[10:33:09.234]                           computeRestarts <- base::computeRestarts
[10:33:09.234]                           grepl <- base::grepl
[10:33:09.234]                           restarts <- computeRestarts(cond)
[10:33:09.234]                           for (restart in restarts) {
[10:33:09.234]                             name <- restart$name
[10:33:09.234]                             if (is.null(name)) 
[10:33:09.234]                               next
[10:33:09.234]                             if (!grepl(pattern, name)) 
[10:33:09.234]                               next
[10:33:09.234]                             invokeRestart(restart)
[10:33:09.234]                             muffled <- TRUE
[10:33:09.234]                             break
[10:33:09.234]                           }
[10:33:09.234]                         }
[10:33:09.234]                       }
[10:33:09.234]                       invisible(muffled)
[10:33:09.234]                     }
[10:33:09.234]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.234]                   }
[10:33:09.234]                 }
[10:33:09.234]             }
[10:33:09.234]         }))
[10:33:09.234]     }, error = function(ex) {
[10:33:09.234]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.234]                 ...future.rng), started = ...future.startTime, 
[10:33:09.234]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.234]             version = "1.8"), class = "FutureResult")
[10:33:09.234]     }, finally = {
[10:33:09.234]         if (!identical(...future.workdir, getwd())) 
[10:33:09.234]             setwd(...future.workdir)
[10:33:09.234]         {
[10:33:09.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.234]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.234]             }
[10:33:09.234]             base::options(...future.oldOptions)
[10:33:09.234]             if (.Platform$OS.type == "windows") {
[10:33:09.234]                 old_names <- names(...future.oldEnvVars)
[10:33:09.234]                 envs <- base::Sys.getenv()
[10:33:09.234]                 names <- names(envs)
[10:33:09.234]                 common <- intersect(names, old_names)
[10:33:09.234]                 added <- setdiff(names, old_names)
[10:33:09.234]                 removed <- setdiff(old_names, names)
[10:33:09.234]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.234]                   envs[common]]
[10:33:09.234]                 NAMES <- toupper(changed)
[10:33:09.234]                 args <- list()
[10:33:09.234]                 for (kk in seq_along(NAMES)) {
[10:33:09.234]                   name <- changed[[kk]]
[10:33:09.234]                   NAME <- NAMES[[kk]]
[10:33:09.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.234]                     next
[10:33:09.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.234]                 }
[10:33:09.234]                 NAMES <- toupper(added)
[10:33:09.234]                 for (kk in seq_along(NAMES)) {
[10:33:09.234]                   name <- added[[kk]]
[10:33:09.234]                   NAME <- NAMES[[kk]]
[10:33:09.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.234]                     next
[10:33:09.234]                   args[[name]] <- ""
[10:33:09.234]                 }
[10:33:09.234]                 NAMES <- toupper(removed)
[10:33:09.234]                 for (kk in seq_along(NAMES)) {
[10:33:09.234]                   name <- removed[[kk]]
[10:33:09.234]                   NAME <- NAMES[[kk]]
[10:33:09.234]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.234]                     next
[10:33:09.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.234]                 }
[10:33:09.234]                 if (length(args) > 0) 
[10:33:09.234]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.234]             }
[10:33:09.234]             else {
[10:33:09.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.234]             }
[10:33:09.234]             {
[10:33:09.234]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.234]                   0L) {
[10:33:09.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.234]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.234]                   base::options(opts)
[10:33:09.234]                 }
[10:33:09.234]                 {
[10:33:09.234]                   {
[10:33:09.234]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.234]                     NULL
[10:33:09.234]                   }
[10:33:09.234]                   options(future.plan = NULL)
[10:33:09.234]                   if (is.na(NA_character_)) 
[10:33:09.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.234]                     .init = FALSE)
[10:33:09.234]                 }
[10:33:09.234]             }
[10:33:09.234]         }
[10:33:09.234]     })
[10:33:09.234]     if (TRUE) {
[10:33:09.234]         base::sink(type = "output", split = FALSE)
[10:33:09.234]         if (TRUE) {
[10:33:09.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.234]         }
[10:33:09.234]         else {
[10:33:09.234]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.234]         }
[10:33:09.234]         base::close(...future.stdout)
[10:33:09.234]         ...future.stdout <- NULL
[10:33:09.234]     }
[10:33:09.234]     ...future.result$conditions <- ...future.conditions
[10:33:09.234]     ...future.result$finished <- base::Sys.time()
[10:33:09.234]     ...future.result
[10:33:09.234] }
[10:33:09.236] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.236] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.237] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.237] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.237] MultisessionFuture started
[10:33:09.237] - Launch lazy future ... done
[10:33:09.238] run() for ‘MultisessionFuture’ ... done
[10:33:09.238] result() for ClusterFuture ...
[10:33:09.238] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.238] - Validating connection of MultisessionFuture
[10:33:09.239] - received message: FutureResult
[10:33:09.239] - Received FutureResult
[10:33:09.239] - Erased future from FutureRegistry
[10:33:09.239] result() for ClusterFuture ...
[10:33:09.239] - result already collected: FutureResult
[10:33:09.240] result() for ClusterFuture ... done
[10:33:09.240] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.240] result() for ClusterFuture ... done
[10:33:09.240] result() for ClusterFuture ...
[10:33:09.240] - result already collected: FutureResult
[10:33:09.240] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.240] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.241] Searching for globals...
[10:33:09.243] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:09.243] Searching for globals ... DONE
[10:33:09.243] Resolving globals: TRUE
[10:33:09.243] Resolving any globals that are futures ...
[10:33:09.243] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:33:09.244] Resolving any globals that are futures ... DONE
[10:33:09.244] Resolving futures part of globals (recursively) ...
[10:33:09.244] resolve() on list ...
[10:33:09.244]  recursive: 99
[10:33:09.244]  length: 1
[10:33:09.245]  elements: ‘x’
[10:33:09.247]  length: 0 (resolved future 1)
[10:33:09.247] resolve() on list ... DONE
[10:33:09.247] - globals: [1] ‘x’
[10:33:09.247] Resolving futures part of globals (recursively) ... DONE
[10:33:09.247] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.248] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.248] - globals: [1] ‘x’
[10:33:09.248] 
[10:33:09.248] getGlobalsAndPackages() ... DONE
[10:33:09.248] run() for ‘Future’ ...
[10:33:09.248] - state: ‘created’
[10:33:09.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.262] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.262]   - Field: ‘node’
[10:33:09.263]   - Field: ‘label’
[10:33:09.263]   - Field: ‘local’
[10:33:09.263]   - Field: ‘owner’
[10:33:09.263]   - Field: ‘envir’
[10:33:09.263]   - Field: ‘workers’
[10:33:09.263]   - Field: ‘packages’
[10:33:09.263]   - Field: ‘gc’
[10:33:09.263]   - Field: ‘conditions’
[10:33:09.263]   - Field: ‘persistent’
[10:33:09.263]   - Field: ‘expr’
[10:33:09.263]   - Field: ‘uuid’
[10:33:09.264]   - Field: ‘seed’
[10:33:09.264]   - Field: ‘version’
[10:33:09.264]   - Field: ‘result’
[10:33:09.264]   - Field: ‘asynchronous’
[10:33:09.264]   - Field: ‘calls’
[10:33:09.264]   - Field: ‘globals’
[10:33:09.264]   - Field: ‘stdout’
[10:33:09.264]   - Field: ‘earlySignal’
[10:33:09.264]   - Field: ‘lazy’
[10:33:09.264]   - Field: ‘state’
[10:33:09.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.265] - Launch lazy future ...
[10:33:09.265] Packages needed by the future expression (n = 0): <none>
[10:33:09.265] Packages needed by future strategies (n = 0): <none>
[10:33:09.265] {
[10:33:09.265]     {
[10:33:09.265]         {
[10:33:09.265]             ...future.startTime <- base::Sys.time()
[10:33:09.265]             {
[10:33:09.265]                 {
[10:33:09.265]                   {
[10:33:09.265]                     {
[10:33:09.265]                       base::local({
[10:33:09.265]                         has_future <- base::requireNamespace("future", 
[10:33:09.265]                           quietly = TRUE)
[10:33:09.265]                         if (has_future) {
[10:33:09.265]                           ns <- base::getNamespace("future")
[10:33:09.265]                           version <- ns[[".package"]][["version"]]
[10:33:09.265]                           if (is.null(version)) 
[10:33:09.265]                             version <- utils::packageVersion("future")
[10:33:09.265]                         }
[10:33:09.265]                         else {
[10:33:09.265]                           version <- NULL
[10:33:09.265]                         }
[10:33:09.265]                         if (!has_future || version < "1.8.0") {
[10:33:09.265]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.265]                             "", base::R.version$version.string), 
[10:33:09.265]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.265]                               "release", "version")], collapse = " "), 
[10:33:09.265]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.265]                             info)
[10:33:09.265]                           info <- base::paste(info, collapse = "; ")
[10:33:09.265]                           if (!has_future) {
[10:33:09.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.265]                               info)
[10:33:09.265]                           }
[10:33:09.265]                           else {
[10:33:09.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.265]                               info, version)
[10:33:09.265]                           }
[10:33:09.265]                           base::stop(msg)
[10:33:09.265]                         }
[10:33:09.265]                       })
[10:33:09.265]                     }
[10:33:09.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.265]                     base::options(mc.cores = 1L)
[10:33:09.265]                   }
[10:33:09.265]                   ...future.strategy.old <- future::plan("list")
[10:33:09.265]                   options(future.plan = NULL)
[10:33:09.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.265]                 }
[10:33:09.265]                 ...future.workdir <- getwd()
[10:33:09.265]             }
[10:33:09.265]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.265]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.265]         }
[10:33:09.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.265]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.265]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.265]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.265]             base::names(...future.oldOptions))
[10:33:09.265]     }
[10:33:09.265]     if (FALSE) {
[10:33:09.265]     }
[10:33:09.265]     else {
[10:33:09.265]         if (TRUE) {
[10:33:09.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.265]                 open = "w")
[10:33:09.265]         }
[10:33:09.265]         else {
[10:33:09.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.265]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.265]         }
[10:33:09.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.265]             base::sink(type = "output", split = FALSE)
[10:33:09.265]             base::close(...future.stdout)
[10:33:09.265]         }, add = TRUE)
[10:33:09.265]     }
[10:33:09.265]     ...future.frame <- base::sys.nframe()
[10:33:09.265]     ...future.conditions <- base::list()
[10:33:09.265]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.265]     if (FALSE) {
[10:33:09.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.265]     }
[10:33:09.265]     ...future.result <- base::tryCatch({
[10:33:09.265]         base::withCallingHandlers({
[10:33:09.265]             ...future.value <- base::withVisible(base::local({
[10:33:09.265]                 ...future.makeSendCondition <- base::local({
[10:33:09.265]                   sendCondition <- NULL
[10:33:09.265]                   function(frame = 1L) {
[10:33:09.265]                     if (is.function(sendCondition)) 
[10:33:09.265]                       return(sendCondition)
[10:33:09.265]                     ns <- getNamespace("parallel")
[10:33:09.265]                     if (exists("sendData", mode = "function", 
[10:33:09.265]                       envir = ns)) {
[10:33:09.265]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.265]                         envir = ns)
[10:33:09.265]                       envir <- sys.frame(frame)
[10:33:09.265]                       master <- NULL
[10:33:09.265]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.265]                         !identical(envir, emptyenv())) {
[10:33:09.265]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.265]                           inherits = FALSE)) {
[10:33:09.265]                           master <- get("master", mode = "list", 
[10:33:09.265]                             envir = envir, inherits = FALSE)
[10:33:09.265]                           if (inherits(master, c("SOCKnode", 
[10:33:09.265]                             "SOCK0node"))) {
[10:33:09.265]                             sendCondition <<- function(cond) {
[10:33:09.265]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.265]                                 success = TRUE)
[10:33:09.265]                               parallel_sendData(master, data)
[10:33:09.265]                             }
[10:33:09.265]                             return(sendCondition)
[10:33:09.265]                           }
[10:33:09.265]                         }
[10:33:09.265]                         frame <- frame + 1L
[10:33:09.265]                         envir <- sys.frame(frame)
[10:33:09.265]                       }
[10:33:09.265]                     }
[10:33:09.265]                     sendCondition <<- function(cond) NULL
[10:33:09.265]                   }
[10:33:09.265]                 })
[10:33:09.265]                 withCallingHandlers({
[10:33:09.265]                   {
[10:33:09.265]                     x[["a"]] <- 1
[10:33:09.265]                     x
[10:33:09.265]                   }
[10:33:09.265]                 }, immediateCondition = function(cond) {
[10:33:09.265]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.265]                   sendCondition(cond)
[10:33:09.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.265]                   {
[10:33:09.265]                     inherits <- base::inherits
[10:33:09.265]                     invokeRestart <- base::invokeRestart
[10:33:09.265]                     is.null <- base::is.null
[10:33:09.265]                     muffled <- FALSE
[10:33:09.265]                     if (inherits(cond, "message")) {
[10:33:09.265]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.265]                       if (muffled) 
[10:33:09.265]                         invokeRestart("muffleMessage")
[10:33:09.265]                     }
[10:33:09.265]                     else if (inherits(cond, "warning")) {
[10:33:09.265]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.265]                       if (muffled) 
[10:33:09.265]                         invokeRestart("muffleWarning")
[10:33:09.265]                     }
[10:33:09.265]                     else if (inherits(cond, "condition")) {
[10:33:09.265]                       if (!is.null(pattern)) {
[10:33:09.265]                         computeRestarts <- base::computeRestarts
[10:33:09.265]                         grepl <- base::grepl
[10:33:09.265]                         restarts <- computeRestarts(cond)
[10:33:09.265]                         for (restart in restarts) {
[10:33:09.265]                           name <- restart$name
[10:33:09.265]                           if (is.null(name)) 
[10:33:09.265]                             next
[10:33:09.265]                           if (!grepl(pattern, name)) 
[10:33:09.265]                             next
[10:33:09.265]                           invokeRestart(restart)
[10:33:09.265]                           muffled <- TRUE
[10:33:09.265]                           break
[10:33:09.265]                         }
[10:33:09.265]                       }
[10:33:09.265]                     }
[10:33:09.265]                     invisible(muffled)
[10:33:09.265]                   }
[10:33:09.265]                   muffleCondition(cond)
[10:33:09.265]                 })
[10:33:09.265]             }))
[10:33:09.265]             future::FutureResult(value = ...future.value$value, 
[10:33:09.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.265]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.265]                     ...future.globalenv.names))
[10:33:09.265]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.265]         }, condition = base::local({
[10:33:09.265]             c <- base::c
[10:33:09.265]             inherits <- base::inherits
[10:33:09.265]             invokeRestart <- base::invokeRestart
[10:33:09.265]             length <- base::length
[10:33:09.265]             list <- base::list
[10:33:09.265]             seq.int <- base::seq.int
[10:33:09.265]             signalCondition <- base::signalCondition
[10:33:09.265]             sys.calls <- base::sys.calls
[10:33:09.265]             `[[` <- base::`[[`
[10:33:09.265]             `+` <- base::`+`
[10:33:09.265]             `<<-` <- base::`<<-`
[10:33:09.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.265]                   3L)]
[10:33:09.265]             }
[10:33:09.265]             function(cond) {
[10:33:09.265]                 is_error <- inherits(cond, "error")
[10:33:09.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.265]                   NULL)
[10:33:09.265]                 if (is_error) {
[10:33:09.265]                   sessionInformation <- function() {
[10:33:09.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.265]                       search = base::search(), system = base::Sys.info())
[10:33:09.265]                   }
[10:33:09.265]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.265]                     cond$call), session = sessionInformation(), 
[10:33:09.265]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.265]                   signalCondition(cond)
[10:33:09.265]                 }
[10:33:09.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.265]                 "immediateCondition"))) {
[10:33:09.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.265]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.265]                   if (TRUE && !signal) {
[10:33:09.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.265]                     {
[10:33:09.265]                       inherits <- base::inherits
[10:33:09.265]                       invokeRestart <- base::invokeRestart
[10:33:09.265]                       is.null <- base::is.null
[10:33:09.265]                       muffled <- FALSE
[10:33:09.265]                       if (inherits(cond, "message")) {
[10:33:09.265]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.265]                         if (muffled) 
[10:33:09.265]                           invokeRestart("muffleMessage")
[10:33:09.265]                       }
[10:33:09.265]                       else if (inherits(cond, "warning")) {
[10:33:09.265]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.265]                         if (muffled) 
[10:33:09.265]                           invokeRestart("muffleWarning")
[10:33:09.265]                       }
[10:33:09.265]                       else if (inherits(cond, "condition")) {
[10:33:09.265]                         if (!is.null(pattern)) {
[10:33:09.265]                           computeRestarts <- base::computeRestarts
[10:33:09.265]                           grepl <- base::grepl
[10:33:09.265]                           restarts <- computeRestarts(cond)
[10:33:09.265]                           for (restart in restarts) {
[10:33:09.265]                             name <- restart$name
[10:33:09.265]                             if (is.null(name)) 
[10:33:09.265]                               next
[10:33:09.265]                             if (!grepl(pattern, name)) 
[10:33:09.265]                               next
[10:33:09.265]                             invokeRestart(restart)
[10:33:09.265]                             muffled <- TRUE
[10:33:09.265]                             break
[10:33:09.265]                           }
[10:33:09.265]                         }
[10:33:09.265]                       }
[10:33:09.265]                       invisible(muffled)
[10:33:09.265]                     }
[10:33:09.265]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.265]                   }
[10:33:09.265]                 }
[10:33:09.265]                 else {
[10:33:09.265]                   if (TRUE) {
[10:33:09.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.265]                     {
[10:33:09.265]                       inherits <- base::inherits
[10:33:09.265]                       invokeRestart <- base::invokeRestart
[10:33:09.265]                       is.null <- base::is.null
[10:33:09.265]                       muffled <- FALSE
[10:33:09.265]                       if (inherits(cond, "message")) {
[10:33:09.265]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.265]                         if (muffled) 
[10:33:09.265]                           invokeRestart("muffleMessage")
[10:33:09.265]                       }
[10:33:09.265]                       else if (inherits(cond, "warning")) {
[10:33:09.265]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.265]                         if (muffled) 
[10:33:09.265]                           invokeRestart("muffleWarning")
[10:33:09.265]                       }
[10:33:09.265]                       else if (inherits(cond, "condition")) {
[10:33:09.265]                         if (!is.null(pattern)) {
[10:33:09.265]                           computeRestarts <- base::computeRestarts
[10:33:09.265]                           grepl <- base::grepl
[10:33:09.265]                           restarts <- computeRestarts(cond)
[10:33:09.265]                           for (restart in restarts) {
[10:33:09.265]                             name <- restart$name
[10:33:09.265]                             if (is.null(name)) 
[10:33:09.265]                               next
[10:33:09.265]                             if (!grepl(pattern, name)) 
[10:33:09.265]                               next
[10:33:09.265]                             invokeRestart(restart)
[10:33:09.265]                             muffled <- TRUE
[10:33:09.265]                             break
[10:33:09.265]                           }
[10:33:09.265]                         }
[10:33:09.265]                       }
[10:33:09.265]                       invisible(muffled)
[10:33:09.265]                     }
[10:33:09.265]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.265]                   }
[10:33:09.265]                 }
[10:33:09.265]             }
[10:33:09.265]         }))
[10:33:09.265]     }, error = function(ex) {
[10:33:09.265]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.265]                 ...future.rng), started = ...future.startTime, 
[10:33:09.265]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.265]             version = "1.8"), class = "FutureResult")
[10:33:09.265]     }, finally = {
[10:33:09.265]         if (!identical(...future.workdir, getwd())) 
[10:33:09.265]             setwd(...future.workdir)
[10:33:09.265]         {
[10:33:09.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.265]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.265]             }
[10:33:09.265]             base::options(...future.oldOptions)
[10:33:09.265]             if (.Platform$OS.type == "windows") {
[10:33:09.265]                 old_names <- names(...future.oldEnvVars)
[10:33:09.265]                 envs <- base::Sys.getenv()
[10:33:09.265]                 names <- names(envs)
[10:33:09.265]                 common <- intersect(names, old_names)
[10:33:09.265]                 added <- setdiff(names, old_names)
[10:33:09.265]                 removed <- setdiff(old_names, names)
[10:33:09.265]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.265]                   envs[common]]
[10:33:09.265]                 NAMES <- toupper(changed)
[10:33:09.265]                 args <- list()
[10:33:09.265]                 for (kk in seq_along(NAMES)) {
[10:33:09.265]                   name <- changed[[kk]]
[10:33:09.265]                   NAME <- NAMES[[kk]]
[10:33:09.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.265]                     next
[10:33:09.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.265]                 }
[10:33:09.265]                 NAMES <- toupper(added)
[10:33:09.265]                 for (kk in seq_along(NAMES)) {
[10:33:09.265]                   name <- added[[kk]]
[10:33:09.265]                   NAME <- NAMES[[kk]]
[10:33:09.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.265]                     next
[10:33:09.265]                   args[[name]] <- ""
[10:33:09.265]                 }
[10:33:09.265]                 NAMES <- toupper(removed)
[10:33:09.265]                 for (kk in seq_along(NAMES)) {
[10:33:09.265]                   name <- removed[[kk]]
[10:33:09.265]                   NAME <- NAMES[[kk]]
[10:33:09.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.265]                     next
[10:33:09.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.265]                 }
[10:33:09.265]                 if (length(args) > 0) 
[10:33:09.265]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.265]             }
[10:33:09.265]             else {
[10:33:09.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.265]             }
[10:33:09.265]             {
[10:33:09.265]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.265]                   0L) {
[10:33:09.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.265]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.265]                   base::options(opts)
[10:33:09.265]                 }
[10:33:09.265]                 {
[10:33:09.265]                   {
[10:33:09.265]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.265]                     NULL
[10:33:09.265]                   }
[10:33:09.265]                   options(future.plan = NULL)
[10:33:09.265]                   if (is.na(NA_character_)) 
[10:33:09.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.265]                     .init = FALSE)
[10:33:09.265]                 }
[10:33:09.265]             }
[10:33:09.265]         }
[10:33:09.265]     })
[10:33:09.265]     if (TRUE) {
[10:33:09.265]         base::sink(type = "output", split = FALSE)
[10:33:09.265]         if (TRUE) {
[10:33:09.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.265]         }
[10:33:09.265]         else {
[10:33:09.265]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.265]         }
[10:33:09.265]         base::close(...future.stdout)
[10:33:09.265]         ...future.stdout <- NULL
[10:33:09.265]     }
[10:33:09.265]     ...future.result$conditions <- ...future.conditions
[10:33:09.265]     ...future.result$finished <- base::Sys.time()
[10:33:09.265]     ...future.result
[10:33:09.265] }
[10:33:09.268] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.268] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.268] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.268] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.269] MultisessionFuture started
[10:33:09.269] - Launch lazy future ... done
[10:33:09.269] run() for ‘MultisessionFuture’ ... done
[10:33:09.269] result() for ClusterFuture ...
[10:33:09.269] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.269] - Validating connection of MultisessionFuture
[10:33:09.270] - received message: FutureResult
[10:33:09.270] - Received FutureResult
[10:33:09.270] - Erased future from FutureRegistry
[10:33:09.270] result() for ClusterFuture ...
[10:33:09.271] - result already collected: FutureResult
[10:33:09.271] result() for ClusterFuture ... done
[10:33:09.271] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.271] result() for ClusterFuture ... done
[10:33:09.271] result() for ClusterFuture ...
[10:33:09.271] - result already collected: FutureResult
[10:33:09.271] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.271] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.272] Searching for globals...
[10:33:09.273] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:09.274] Searching for globals ... DONE
[10:33:09.274] Resolving globals: TRUE
[10:33:09.274] Resolving any globals that are futures ...
[10:33:09.274] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:09.274] Resolving any globals that are futures ... DONE
[10:33:09.274] Resolving futures part of globals (recursively) ...
[10:33:09.275] resolve() on list ...
[10:33:09.275]  recursive: 99
[10:33:09.275]  length: 1
[10:33:09.275]  elements: ‘x’
[10:33:09.275]  length: 0 (resolved future 1)
[10:33:09.275] resolve() on list ... DONE
[10:33:09.275] - globals: [1] ‘x’
[10:33:09.275] Resolving futures part of globals (recursively) ... DONE
[10:33:09.275] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.276] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.276] - globals: [1] ‘x’
[10:33:09.276] 
[10:33:09.276] getGlobalsAndPackages() ... DONE
[10:33:09.276] run() for ‘Future’ ...
[10:33:09.276] - state: ‘created’
[10:33:09.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.290]   - Field: ‘node’
[10:33:09.291]   - Field: ‘label’
[10:33:09.291]   - Field: ‘local’
[10:33:09.291]   - Field: ‘owner’
[10:33:09.291]   - Field: ‘envir’
[10:33:09.291]   - Field: ‘workers’
[10:33:09.291]   - Field: ‘packages’
[10:33:09.291]   - Field: ‘gc’
[10:33:09.291]   - Field: ‘conditions’
[10:33:09.291]   - Field: ‘persistent’
[10:33:09.292]   - Field: ‘expr’
[10:33:09.292]   - Field: ‘uuid’
[10:33:09.292]   - Field: ‘seed’
[10:33:09.292]   - Field: ‘version’
[10:33:09.292]   - Field: ‘result’
[10:33:09.292]   - Field: ‘asynchronous’
[10:33:09.292]   - Field: ‘calls’
[10:33:09.293]   - Field: ‘globals’
[10:33:09.293]   - Field: ‘stdout’
[10:33:09.293]   - Field: ‘earlySignal’
[10:33:09.293]   - Field: ‘lazy’
[10:33:09.293]   - Field: ‘state’
[10:33:09.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.293] - Launch lazy future ...
[10:33:09.294] Packages needed by the future expression (n = 0): <none>
[10:33:09.294] Packages needed by future strategies (n = 0): <none>
[10:33:09.294] {
[10:33:09.294]     {
[10:33:09.294]         {
[10:33:09.294]             ...future.startTime <- base::Sys.time()
[10:33:09.294]             {
[10:33:09.294]                 {
[10:33:09.294]                   {
[10:33:09.294]                     {
[10:33:09.294]                       base::local({
[10:33:09.294]                         has_future <- base::requireNamespace("future", 
[10:33:09.294]                           quietly = TRUE)
[10:33:09.294]                         if (has_future) {
[10:33:09.294]                           ns <- base::getNamespace("future")
[10:33:09.294]                           version <- ns[[".package"]][["version"]]
[10:33:09.294]                           if (is.null(version)) 
[10:33:09.294]                             version <- utils::packageVersion("future")
[10:33:09.294]                         }
[10:33:09.294]                         else {
[10:33:09.294]                           version <- NULL
[10:33:09.294]                         }
[10:33:09.294]                         if (!has_future || version < "1.8.0") {
[10:33:09.294]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.294]                             "", base::R.version$version.string), 
[10:33:09.294]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.294]                               "release", "version")], collapse = " "), 
[10:33:09.294]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.294]                             info)
[10:33:09.294]                           info <- base::paste(info, collapse = "; ")
[10:33:09.294]                           if (!has_future) {
[10:33:09.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.294]                               info)
[10:33:09.294]                           }
[10:33:09.294]                           else {
[10:33:09.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.294]                               info, version)
[10:33:09.294]                           }
[10:33:09.294]                           base::stop(msg)
[10:33:09.294]                         }
[10:33:09.294]                       })
[10:33:09.294]                     }
[10:33:09.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.294]                     base::options(mc.cores = 1L)
[10:33:09.294]                   }
[10:33:09.294]                   ...future.strategy.old <- future::plan("list")
[10:33:09.294]                   options(future.plan = NULL)
[10:33:09.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.294]                 }
[10:33:09.294]                 ...future.workdir <- getwd()
[10:33:09.294]             }
[10:33:09.294]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.294]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.294]         }
[10:33:09.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.294]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.294]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.294]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.294]             base::names(...future.oldOptions))
[10:33:09.294]     }
[10:33:09.294]     if (FALSE) {
[10:33:09.294]     }
[10:33:09.294]     else {
[10:33:09.294]         if (TRUE) {
[10:33:09.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.294]                 open = "w")
[10:33:09.294]         }
[10:33:09.294]         else {
[10:33:09.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.294]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.294]         }
[10:33:09.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.294]             base::sink(type = "output", split = FALSE)
[10:33:09.294]             base::close(...future.stdout)
[10:33:09.294]         }, add = TRUE)
[10:33:09.294]     }
[10:33:09.294]     ...future.frame <- base::sys.nframe()
[10:33:09.294]     ...future.conditions <- base::list()
[10:33:09.294]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.294]     if (FALSE) {
[10:33:09.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.294]     }
[10:33:09.294]     ...future.result <- base::tryCatch({
[10:33:09.294]         base::withCallingHandlers({
[10:33:09.294]             ...future.value <- base::withVisible(base::local({
[10:33:09.294]                 ...future.makeSendCondition <- base::local({
[10:33:09.294]                   sendCondition <- NULL
[10:33:09.294]                   function(frame = 1L) {
[10:33:09.294]                     if (is.function(sendCondition)) 
[10:33:09.294]                       return(sendCondition)
[10:33:09.294]                     ns <- getNamespace("parallel")
[10:33:09.294]                     if (exists("sendData", mode = "function", 
[10:33:09.294]                       envir = ns)) {
[10:33:09.294]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.294]                         envir = ns)
[10:33:09.294]                       envir <- sys.frame(frame)
[10:33:09.294]                       master <- NULL
[10:33:09.294]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.294]                         !identical(envir, emptyenv())) {
[10:33:09.294]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.294]                           inherits = FALSE)) {
[10:33:09.294]                           master <- get("master", mode = "list", 
[10:33:09.294]                             envir = envir, inherits = FALSE)
[10:33:09.294]                           if (inherits(master, c("SOCKnode", 
[10:33:09.294]                             "SOCK0node"))) {
[10:33:09.294]                             sendCondition <<- function(cond) {
[10:33:09.294]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.294]                                 success = TRUE)
[10:33:09.294]                               parallel_sendData(master, data)
[10:33:09.294]                             }
[10:33:09.294]                             return(sendCondition)
[10:33:09.294]                           }
[10:33:09.294]                         }
[10:33:09.294]                         frame <- frame + 1L
[10:33:09.294]                         envir <- sys.frame(frame)
[10:33:09.294]                       }
[10:33:09.294]                     }
[10:33:09.294]                     sendCondition <<- function(cond) NULL
[10:33:09.294]                   }
[10:33:09.294]                 })
[10:33:09.294]                 withCallingHandlers({
[10:33:09.294]                   {
[10:33:09.294]                     x["a"] <- list(1)
[10:33:09.294]                     x
[10:33:09.294]                   }
[10:33:09.294]                 }, immediateCondition = function(cond) {
[10:33:09.294]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.294]                   sendCondition(cond)
[10:33:09.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.294]                   {
[10:33:09.294]                     inherits <- base::inherits
[10:33:09.294]                     invokeRestart <- base::invokeRestart
[10:33:09.294]                     is.null <- base::is.null
[10:33:09.294]                     muffled <- FALSE
[10:33:09.294]                     if (inherits(cond, "message")) {
[10:33:09.294]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.294]                       if (muffled) 
[10:33:09.294]                         invokeRestart("muffleMessage")
[10:33:09.294]                     }
[10:33:09.294]                     else if (inherits(cond, "warning")) {
[10:33:09.294]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.294]                       if (muffled) 
[10:33:09.294]                         invokeRestart("muffleWarning")
[10:33:09.294]                     }
[10:33:09.294]                     else if (inherits(cond, "condition")) {
[10:33:09.294]                       if (!is.null(pattern)) {
[10:33:09.294]                         computeRestarts <- base::computeRestarts
[10:33:09.294]                         grepl <- base::grepl
[10:33:09.294]                         restarts <- computeRestarts(cond)
[10:33:09.294]                         for (restart in restarts) {
[10:33:09.294]                           name <- restart$name
[10:33:09.294]                           if (is.null(name)) 
[10:33:09.294]                             next
[10:33:09.294]                           if (!grepl(pattern, name)) 
[10:33:09.294]                             next
[10:33:09.294]                           invokeRestart(restart)
[10:33:09.294]                           muffled <- TRUE
[10:33:09.294]                           break
[10:33:09.294]                         }
[10:33:09.294]                       }
[10:33:09.294]                     }
[10:33:09.294]                     invisible(muffled)
[10:33:09.294]                   }
[10:33:09.294]                   muffleCondition(cond)
[10:33:09.294]                 })
[10:33:09.294]             }))
[10:33:09.294]             future::FutureResult(value = ...future.value$value, 
[10:33:09.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.294]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.294]                     ...future.globalenv.names))
[10:33:09.294]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.294]         }, condition = base::local({
[10:33:09.294]             c <- base::c
[10:33:09.294]             inherits <- base::inherits
[10:33:09.294]             invokeRestart <- base::invokeRestart
[10:33:09.294]             length <- base::length
[10:33:09.294]             list <- base::list
[10:33:09.294]             seq.int <- base::seq.int
[10:33:09.294]             signalCondition <- base::signalCondition
[10:33:09.294]             sys.calls <- base::sys.calls
[10:33:09.294]             `[[` <- base::`[[`
[10:33:09.294]             `+` <- base::`+`
[10:33:09.294]             `<<-` <- base::`<<-`
[10:33:09.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.294]                   3L)]
[10:33:09.294]             }
[10:33:09.294]             function(cond) {
[10:33:09.294]                 is_error <- inherits(cond, "error")
[10:33:09.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.294]                   NULL)
[10:33:09.294]                 if (is_error) {
[10:33:09.294]                   sessionInformation <- function() {
[10:33:09.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.294]                       search = base::search(), system = base::Sys.info())
[10:33:09.294]                   }
[10:33:09.294]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.294]                     cond$call), session = sessionInformation(), 
[10:33:09.294]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.294]                   signalCondition(cond)
[10:33:09.294]                 }
[10:33:09.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.294]                 "immediateCondition"))) {
[10:33:09.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.294]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.294]                   if (TRUE && !signal) {
[10:33:09.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.294]                     {
[10:33:09.294]                       inherits <- base::inherits
[10:33:09.294]                       invokeRestart <- base::invokeRestart
[10:33:09.294]                       is.null <- base::is.null
[10:33:09.294]                       muffled <- FALSE
[10:33:09.294]                       if (inherits(cond, "message")) {
[10:33:09.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.294]                         if (muffled) 
[10:33:09.294]                           invokeRestart("muffleMessage")
[10:33:09.294]                       }
[10:33:09.294]                       else if (inherits(cond, "warning")) {
[10:33:09.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.294]                         if (muffled) 
[10:33:09.294]                           invokeRestart("muffleWarning")
[10:33:09.294]                       }
[10:33:09.294]                       else if (inherits(cond, "condition")) {
[10:33:09.294]                         if (!is.null(pattern)) {
[10:33:09.294]                           computeRestarts <- base::computeRestarts
[10:33:09.294]                           grepl <- base::grepl
[10:33:09.294]                           restarts <- computeRestarts(cond)
[10:33:09.294]                           for (restart in restarts) {
[10:33:09.294]                             name <- restart$name
[10:33:09.294]                             if (is.null(name)) 
[10:33:09.294]                               next
[10:33:09.294]                             if (!grepl(pattern, name)) 
[10:33:09.294]                               next
[10:33:09.294]                             invokeRestart(restart)
[10:33:09.294]                             muffled <- TRUE
[10:33:09.294]                             break
[10:33:09.294]                           }
[10:33:09.294]                         }
[10:33:09.294]                       }
[10:33:09.294]                       invisible(muffled)
[10:33:09.294]                     }
[10:33:09.294]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.294]                   }
[10:33:09.294]                 }
[10:33:09.294]                 else {
[10:33:09.294]                   if (TRUE) {
[10:33:09.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.294]                     {
[10:33:09.294]                       inherits <- base::inherits
[10:33:09.294]                       invokeRestart <- base::invokeRestart
[10:33:09.294]                       is.null <- base::is.null
[10:33:09.294]                       muffled <- FALSE
[10:33:09.294]                       if (inherits(cond, "message")) {
[10:33:09.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.294]                         if (muffled) 
[10:33:09.294]                           invokeRestart("muffleMessage")
[10:33:09.294]                       }
[10:33:09.294]                       else if (inherits(cond, "warning")) {
[10:33:09.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.294]                         if (muffled) 
[10:33:09.294]                           invokeRestart("muffleWarning")
[10:33:09.294]                       }
[10:33:09.294]                       else if (inherits(cond, "condition")) {
[10:33:09.294]                         if (!is.null(pattern)) {
[10:33:09.294]                           computeRestarts <- base::computeRestarts
[10:33:09.294]                           grepl <- base::grepl
[10:33:09.294]                           restarts <- computeRestarts(cond)
[10:33:09.294]                           for (restart in restarts) {
[10:33:09.294]                             name <- restart$name
[10:33:09.294]                             if (is.null(name)) 
[10:33:09.294]                               next
[10:33:09.294]                             if (!grepl(pattern, name)) 
[10:33:09.294]                               next
[10:33:09.294]                             invokeRestart(restart)
[10:33:09.294]                             muffled <- TRUE
[10:33:09.294]                             break
[10:33:09.294]                           }
[10:33:09.294]                         }
[10:33:09.294]                       }
[10:33:09.294]                       invisible(muffled)
[10:33:09.294]                     }
[10:33:09.294]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.294]                   }
[10:33:09.294]                 }
[10:33:09.294]             }
[10:33:09.294]         }))
[10:33:09.294]     }, error = function(ex) {
[10:33:09.294]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.294]                 ...future.rng), started = ...future.startTime, 
[10:33:09.294]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.294]             version = "1.8"), class = "FutureResult")
[10:33:09.294]     }, finally = {
[10:33:09.294]         if (!identical(...future.workdir, getwd())) 
[10:33:09.294]             setwd(...future.workdir)
[10:33:09.294]         {
[10:33:09.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.294]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.294]             }
[10:33:09.294]             base::options(...future.oldOptions)
[10:33:09.294]             if (.Platform$OS.type == "windows") {
[10:33:09.294]                 old_names <- names(...future.oldEnvVars)
[10:33:09.294]                 envs <- base::Sys.getenv()
[10:33:09.294]                 names <- names(envs)
[10:33:09.294]                 common <- intersect(names, old_names)
[10:33:09.294]                 added <- setdiff(names, old_names)
[10:33:09.294]                 removed <- setdiff(old_names, names)
[10:33:09.294]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.294]                   envs[common]]
[10:33:09.294]                 NAMES <- toupper(changed)
[10:33:09.294]                 args <- list()
[10:33:09.294]                 for (kk in seq_along(NAMES)) {
[10:33:09.294]                   name <- changed[[kk]]
[10:33:09.294]                   NAME <- NAMES[[kk]]
[10:33:09.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.294]                     next
[10:33:09.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.294]                 }
[10:33:09.294]                 NAMES <- toupper(added)
[10:33:09.294]                 for (kk in seq_along(NAMES)) {
[10:33:09.294]                   name <- added[[kk]]
[10:33:09.294]                   NAME <- NAMES[[kk]]
[10:33:09.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.294]                     next
[10:33:09.294]                   args[[name]] <- ""
[10:33:09.294]                 }
[10:33:09.294]                 NAMES <- toupper(removed)
[10:33:09.294]                 for (kk in seq_along(NAMES)) {
[10:33:09.294]                   name <- removed[[kk]]
[10:33:09.294]                   NAME <- NAMES[[kk]]
[10:33:09.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.294]                     next
[10:33:09.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.294]                 }
[10:33:09.294]                 if (length(args) > 0) 
[10:33:09.294]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.294]             }
[10:33:09.294]             else {
[10:33:09.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.294]             }
[10:33:09.294]             {
[10:33:09.294]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.294]                   0L) {
[10:33:09.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.294]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.294]                   base::options(opts)
[10:33:09.294]                 }
[10:33:09.294]                 {
[10:33:09.294]                   {
[10:33:09.294]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.294]                     NULL
[10:33:09.294]                   }
[10:33:09.294]                   options(future.plan = NULL)
[10:33:09.294]                   if (is.na(NA_character_)) 
[10:33:09.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.294]                     .init = FALSE)
[10:33:09.294]                 }
[10:33:09.294]             }
[10:33:09.294]         }
[10:33:09.294]     })
[10:33:09.294]     if (TRUE) {
[10:33:09.294]         base::sink(type = "output", split = FALSE)
[10:33:09.294]         if (TRUE) {
[10:33:09.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.294]         }
[10:33:09.294]         else {
[10:33:09.294]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.294]         }
[10:33:09.294]         base::close(...future.stdout)
[10:33:09.294]         ...future.stdout <- NULL
[10:33:09.294]     }
[10:33:09.294]     ...future.result$conditions <- ...future.conditions
[10:33:09.294]     ...future.result$finished <- base::Sys.time()
[10:33:09.294]     ...future.result
[10:33:09.294] }
[10:33:09.297] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.297] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.298] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.298] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.298] MultisessionFuture started
[10:33:09.298] - Launch lazy future ... done
[10:33:09.299] run() for ‘MultisessionFuture’ ... done
[10:33:09.299] result() for ClusterFuture ...
[10:33:09.299] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.299] - Validating connection of MultisessionFuture
[10:33:09.300] - received message: FutureResult
[10:33:09.300] - Received FutureResult
[10:33:09.300] - Erased future from FutureRegistry
[10:33:09.300] result() for ClusterFuture ...
[10:33:09.300] - result already collected: FutureResult
[10:33:09.301] result() for ClusterFuture ... done
[10:33:09.301] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.301] result() for ClusterFuture ... done
[10:33:09.301] result() for ClusterFuture ...
[10:33:09.301] - result already collected: FutureResult
[10:33:09.301] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.301] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.302] Searching for globals...
[10:33:09.303] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:09.304] Searching for globals ... DONE
[10:33:09.304] Resolving globals: TRUE
[10:33:09.304] Resolving any globals that are futures ...
[10:33:09.304] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:09.304] Resolving any globals that are futures ... DONE
[10:33:09.304] Resolving futures part of globals (recursively) ...
[10:33:09.305] resolve() on list ...
[10:33:09.305]  recursive: 99
[10:33:09.305]  length: 1
[10:33:09.305]  elements: ‘x’
[10:33:09.305]  length: 0 (resolved future 1)
[10:33:09.305] resolve() on list ... DONE
[10:33:09.305] - globals: [1] ‘x’
[10:33:09.305] Resolving futures part of globals (recursively) ... DONE
[10:33:09.305] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.306] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.306] - globals: [1] ‘x’
[10:33:09.306] 
[10:33:09.306] getGlobalsAndPackages() ... DONE
[10:33:09.306] run() for ‘Future’ ...
[10:33:09.306] - state: ‘created’
[10:33:09.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.320] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.321]   - Field: ‘node’
[10:33:09.321]   - Field: ‘label’
[10:33:09.321]   - Field: ‘local’
[10:33:09.321]   - Field: ‘owner’
[10:33:09.321]   - Field: ‘envir’
[10:33:09.321]   - Field: ‘workers’
[10:33:09.321]   - Field: ‘packages’
[10:33:09.321]   - Field: ‘gc’
[10:33:09.321]   - Field: ‘conditions’
[10:33:09.322]   - Field: ‘persistent’
[10:33:09.322]   - Field: ‘expr’
[10:33:09.322]   - Field: ‘uuid’
[10:33:09.322]   - Field: ‘seed’
[10:33:09.322]   - Field: ‘version’
[10:33:09.322]   - Field: ‘result’
[10:33:09.322]   - Field: ‘asynchronous’
[10:33:09.322]   - Field: ‘calls’
[10:33:09.322]   - Field: ‘globals’
[10:33:09.322]   - Field: ‘stdout’
[10:33:09.322]   - Field: ‘earlySignal’
[10:33:09.323]   - Field: ‘lazy’
[10:33:09.323]   - Field: ‘state’
[10:33:09.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.323] - Launch lazy future ...
[10:33:09.323] Packages needed by the future expression (n = 0): <none>
[10:33:09.323] Packages needed by future strategies (n = 0): <none>
[10:33:09.324] {
[10:33:09.324]     {
[10:33:09.324]         {
[10:33:09.324]             ...future.startTime <- base::Sys.time()
[10:33:09.324]             {
[10:33:09.324]                 {
[10:33:09.324]                   {
[10:33:09.324]                     {
[10:33:09.324]                       base::local({
[10:33:09.324]                         has_future <- base::requireNamespace("future", 
[10:33:09.324]                           quietly = TRUE)
[10:33:09.324]                         if (has_future) {
[10:33:09.324]                           ns <- base::getNamespace("future")
[10:33:09.324]                           version <- ns[[".package"]][["version"]]
[10:33:09.324]                           if (is.null(version)) 
[10:33:09.324]                             version <- utils::packageVersion("future")
[10:33:09.324]                         }
[10:33:09.324]                         else {
[10:33:09.324]                           version <- NULL
[10:33:09.324]                         }
[10:33:09.324]                         if (!has_future || version < "1.8.0") {
[10:33:09.324]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.324]                             "", base::R.version$version.string), 
[10:33:09.324]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.324]                               "release", "version")], collapse = " "), 
[10:33:09.324]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.324]                             info)
[10:33:09.324]                           info <- base::paste(info, collapse = "; ")
[10:33:09.324]                           if (!has_future) {
[10:33:09.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.324]                               info)
[10:33:09.324]                           }
[10:33:09.324]                           else {
[10:33:09.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.324]                               info, version)
[10:33:09.324]                           }
[10:33:09.324]                           base::stop(msg)
[10:33:09.324]                         }
[10:33:09.324]                       })
[10:33:09.324]                     }
[10:33:09.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.324]                     base::options(mc.cores = 1L)
[10:33:09.324]                   }
[10:33:09.324]                   ...future.strategy.old <- future::plan("list")
[10:33:09.324]                   options(future.plan = NULL)
[10:33:09.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.324]                 }
[10:33:09.324]                 ...future.workdir <- getwd()
[10:33:09.324]             }
[10:33:09.324]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.324]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.324]         }
[10:33:09.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.324]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.324]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.324]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.324]             base::names(...future.oldOptions))
[10:33:09.324]     }
[10:33:09.324]     if (FALSE) {
[10:33:09.324]     }
[10:33:09.324]     else {
[10:33:09.324]         if (TRUE) {
[10:33:09.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.324]                 open = "w")
[10:33:09.324]         }
[10:33:09.324]         else {
[10:33:09.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.324]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.324]         }
[10:33:09.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.324]             base::sink(type = "output", split = FALSE)
[10:33:09.324]             base::close(...future.stdout)
[10:33:09.324]         }, add = TRUE)
[10:33:09.324]     }
[10:33:09.324]     ...future.frame <- base::sys.nframe()
[10:33:09.324]     ...future.conditions <- base::list()
[10:33:09.324]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.324]     if (FALSE) {
[10:33:09.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.324]     }
[10:33:09.324]     ...future.result <- base::tryCatch({
[10:33:09.324]         base::withCallingHandlers({
[10:33:09.324]             ...future.value <- base::withVisible(base::local({
[10:33:09.324]                 ...future.makeSendCondition <- base::local({
[10:33:09.324]                   sendCondition <- NULL
[10:33:09.324]                   function(frame = 1L) {
[10:33:09.324]                     if (is.function(sendCondition)) 
[10:33:09.324]                       return(sendCondition)
[10:33:09.324]                     ns <- getNamespace("parallel")
[10:33:09.324]                     if (exists("sendData", mode = "function", 
[10:33:09.324]                       envir = ns)) {
[10:33:09.324]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.324]                         envir = ns)
[10:33:09.324]                       envir <- sys.frame(frame)
[10:33:09.324]                       master <- NULL
[10:33:09.324]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.324]                         !identical(envir, emptyenv())) {
[10:33:09.324]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.324]                           inherits = FALSE)) {
[10:33:09.324]                           master <- get("master", mode = "list", 
[10:33:09.324]                             envir = envir, inherits = FALSE)
[10:33:09.324]                           if (inherits(master, c("SOCKnode", 
[10:33:09.324]                             "SOCK0node"))) {
[10:33:09.324]                             sendCondition <<- function(cond) {
[10:33:09.324]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.324]                                 success = TRUE)
[10:33:09.324]                               parallel_sendData(master, data)
[10:33:09.324]                             }
[10:33:09.324]                             return(sendCondition)
[10:33:09.324]                           }
[10:33:09.324]                         }
[10:33:09.324]                         frame <- frame + 1L
[10:33:09.324]                         envir <- sys.frame(frame)
[10:33:09.324]                       }
[10:33:09.324]                     }
[10:33:09.324]                     sendCondition <<- function(cond) NULL
[10:33:09.324]                   }
[10:33:09.324]                 })
[10:33:09.324]                 withCallingHandlers({
[10:33:09.324]                   {
[10:33:09.324]                     x["a"] <- list(1)
[10:33:09.324]                     x
[10:33:09.324]                   }
[10:33:09.324]                 }, immediateCondition = function(cond) {
[10:33:09.324]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.324]                   sendCondition(cond)
[10:33:09.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.324]                   {
[10:33:09.324]                     inherits <- base::inherits
[10:33:09.324]                     invokeRestart <- base::invokeRestart
[10:33:09.324]                     is.null <- base::is.null
[10:33:09.324]                     muffled <- FALSE
[10:33:09.324]                     if (inherits(cond, "message")) {
[10:33:09.324]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.324]                       if (muffled) 
[10:33:09.324]                         invokeRestart("muffleMessage")
[10:33:09.324]                     }
[10:33:09.324]                     else if (inherits(cond, "warning")) {
[10:33:09.324]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.324]                       if (muffled) 
[10:33:09.324]                         invokeRestart("muffleWarning")
[10:33:09.324]                     }
[10:33:09.324]                     else if (inherits(cond, "condition")) {
[10:33:09.324]                       if (!is.null(pattern)) {
[10:33:09.324]                         computeRestarts <- base::computeRestarts
[10:33:09.324]                         grepl <- base::grepl
[10:33:09.324]                         restarts <- computeRestarts(cond)
[10:33:09.324]                         for (restart in restarts) {
[10:33:09.324]                           name <- restart$name
[10:33:09.324]                           if (is.null(name)) 
[10:33:09.324]                             next
[10:33:09.324]                           if (!grepl(pattern, name)) 
[10:33:09.324]                             next
[10:33:09.324]                           invokeRestart(restart)
[10:33:09.324]                           muffled <- TRUE
[10:33:09.324]                           break
[10:33:09.324]                         }
[10:33:09.324]                       }
[10:33:09.324]                     }
[10:33:09.324]                     invisible(muffled)
[10:33:09.324]                   }
[10:33:09.324]                   muffleCondition(cond)
[10:33:09.324]                 })
[10:33:09.324]             }))
[10:33:09.324]             future::FutureResult(value = ...future.value$value, 
[10:33:09.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.324]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.324]                     ...future.globalenv.names))
[10:33:09.324]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.324]         }, condition = base::local({
[10:33:09.324]             c <- base::c
[10:33:09.324]             inherits <- base::inherits
[10:33:09.324]             invokeRestart <- base::invokeRestart
[10:33:09.324]             length <- base::length
[10:33:09.324]             list <- base::list
[10:33:09.324]             seq.int <- base::seq.int
[10:33:09.324]             signalCondition <- base::signalCondition
[10:33:09.324]             sys.calls <- base::sys.calls
[10:33:09.324]             `[[` <- base::`[[`
[10:33:09.324]             `+` <- base::`+`
[10:33:09.324]             `<<-` <- base::`<<-`
[10:33:09.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.324]                   3L)]
[10:33:09.324]             }
[10:33:09.324]             function(cond) {
[10:33:09.324]                 is_error <- inherits(cond, "error")
[10:33:09.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.324]                   NULL)
[10:33:09.324]                 if (is_error) {
[10:33:09.324]                   sessionInformation <- function() {
[10:33:09.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.324]                       search = base::search(), system = base::Sys.info())
[10:33:09.324]                   }
[10:33:09.324]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.324]                     cond$call), session = sessionInformation(), 
[10:33:09.324]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.324]                   signalCondition(cond)
[10:33:09.324]                 }
[10:33:09.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.324]                 "immediateCondition"))) {
[10:33:09.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.324]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.324]                   if (TRUE && !signal) {
[10:33:09.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.324]                     {
[10:33:09.324]                       inherits <- base::inherits
[10:33:09.324]                       invokeRestart <- base::invokeRestart
[10:33:09.324]                       is.null <- base::is.null
[10:33:09.324]                       muffled <- FALSE
[10:33:09.324]                       if (inherits(cond, "message")) {
[10:33:09.324]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.324]                         if (muffled) 
[10:33:09.324]                           invokeRestart("muffleMessage")
[10:33:09.324]                       }
[10:33:09.324]                       else if (inherits(cond, "warning")) {
[10:33:09.324]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.324]                         if (muffled) 
[10:33:09.324]                           invokeRestart("muffleWarning")
[10:33:09.324]                       }
[10:33:09.324]                       else if (inherits(cond, "condition")) {
[10:33:09.324]                         if (!is.null(pattern)) {
[10:33:09.324]                           computeRestarts <- base::computeRestarts
[10:33:09.324]                           grepl <- base::grepl
[10:33:09.324]                           restarts <- computeRestarts(cond)
[10:33:09.324]                           for (restart in restarts) {
[10:33:09.324]                             name <- restart$name
[10:33:09.324]                             if (is.null(name)) 
[10:33:09.324]                               next
[10:33:09.324]                             if (!grepl(pattern, name)) 
[10:33:09.324]                               next
[10:33:09.324]                             invokeRestart(restart)
[10:33:09.324]                             muffled <- TRUE
[10:33:09.324]                             break
[10:33:09.324]                           }
[10:33:09.324]                         }
[10:33:09.324]                       }
[10:33:09.324]                       invisible(muffled)
[10:33:09.324]                     }
[10:33:09.324]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.324]                   }
[10:33:09.324]                 }
[10:33:09.324]                 else {
[10:33:09.324]                   if (TRUE) {
[10:33:09.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.324]                     {
[10:33:09.324]                       inherits <- base::inherits
[10:33:09.324]                       invokeRestart <- base::invokeRestart
[10:33:09.324]                       is.null <- base::is.null
[10:33:09.324]                       muffled <- FALSE
[10:33:09.324]                       if (inherits(cond, "message")) {
[10:33:09.324]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.324]                         if (muffled) 
[10:33:09.324]                           invokeRestart("muffleMessage")
[10:33:09.324]                       }
[10:33:09.324]                       else if (inherits(cond, "warning")) {
[10:33:09.324]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.324]                         if (muffled) 
[10:33:09.324]                           invokeRestart("muffleWarning")
[10:33:09.324]                       }
[10:33:09.324]                       else if (inherits(cond, "condition")) {
[10:33:09.324]                         if (!is.null(pattern)) {
[10:33:09.324]                           computeRestarts <- base::computeRestarts
[10:33:09.324]                           grepl <- base::grepl
[10:33:09.324]                           restarts <- computeRestarts(cond)
[10:33:09.324]                           for (restart in restarts) {
[10:33:09.324]                             name <- restart$name
[10:33:09.324]                             if (is.null(name)) 
[10:33:09.324]                               next
[10:33:09.324]                             if (!grepl(pattern, name)) 
[10:33:09.324]                               next
[10:33:09.324]                             invokeRestart(restart)
[10:33:09.324]                             muffled <- TRUE
[10:33:09.324]                             break
[10:33:09.324]                           }
[10:33:09.324]                         }
[10:33:09.324]                       }
[10:33:09.324]                       invisible(muffled)
[10:33:09.324]                     }
[10:33:09.324]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.324]                   }
[10:33:09.324]                 }
[10:33:09.324]             }
[10:33:09.324]         }))
[10:33:09.324]     }, error = function(ex) {
[10:33:09.324]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.324]                 ...future.rng), started = ...future.startTime, 
[10:33:09.324]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.324]             version = "1.8"), class = "FutureResult")
[10:33:09.324]     }, finally = {
[10:33:09.324]         if (!identical(...future.workdir, getwd())) 
[10:33:09.324]             setwd(...future.workdir)
[10:33:09.324]         {
[10:33:09.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.324]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.324]             }
[10:33:09.324]             base::options(...future.oldOptions)
[10:33:09.324]             if (.Platform$OS.type == "windows") {
[10:33:09.324]                 old_names <- names(...future.oldEnvVars)
[10:33:09.324]                 envs <- base::Sys.getenv()
[10:33:09.324]                 names <- names(envs)
[10:33:09.324]                 common <- intersect(names, old_names)
[10:33:09.324]                 added <- setdiff(names, old_names)
[10:33:09.324]                 removed <- setdiff(old_names, names)
[10:33:09.324]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.324]                   envs[common]]
[10:33:09.324]                 NAMES <- toupper(changed)
[10:33:09.324]                 args <- list()
[10:33:09.324]                 for (kk in seq_along(NAMES)) {
[10:33:09.324]                   name <- changed[[kk]]
[10:33:09.324]                   NAME <- NAMES[[kk]]
[10:33:09.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.324]                     next
[10:33:09.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.324]                 }
[10:33:09.324]                 NAMES <- toupper(added)
[10:33:09.324]                 for (kk in seq_along(NAMES)) {
[10:33:09.324]                   name <- added[[kk]]
[10:33:09.324]                   NAME <- NAMES[[kk]]
[10:33:09.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.324]                     next
[10:33:09.324]                   args[[name]] <- ""
[10:33:09.324]                 }
[10:33:09.324]                 NAMES <- toupper(removed)
[10:33:09.324]                 for (kk in seq_along(NAMES)) {
[10:33:09.324]                   name <- removed[[kk]]
[10:33:09.324]                   NAME <- NAMES[[kk]]
[10:33:09.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.324]                     next
[10:33:09.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.324]                 }
[10:33:09.324]                 if (length(args) > 0) 
[10:33:09.324]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.324]             }
[10:33:09.324]             else {
[10:33:09.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.324]             }
[10:33:09.324]             {
[10:33:09.324]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.324]                   0L) {
[10:33:09.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.324]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.324]                   base::options(opts)
[10:33:09.324]                 }
[10:33:09.324]                 {
[10:33:09.324]                   {
[10:33:09.324]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.324]                     NULL
[10:33:09.324]                   }
[10:33:09.324]                   options(future.plan = NULL)
[10:33:09.324]                   if (is.na(NA_character_)) 
[10:33:09.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.324]                     .init = FALSE)
[10:33:09.324]                 }
[10:33:09.324]             }
[10:33:09.324]         }
[10:33:09.324]     })
[10:33:09.324]     if (TRUE) {
[10:33:09.324]         base::sink(type = "output", split = FALSE)
[10:33:09.324]         if (TRUE) {
[10:33:09.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.324]         }
[10:33:09.324]         else {
[10:33:09.324]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.324]         }
[10:33:09.324]         base::close(...future.stdout)
[10:33:09.324]         ...future.stdout <- NULL
[10:33:09.324]     }
[10:33:09.324]     ...future.result$conditions <- ...future.conditions
[10:33:09.324]     ...future.result$finished <- base::Sys.time()
[10:33:09.324]     ...future.result
[10:33:09.324] }
[10:33:09.326] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.326] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.327] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.327] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.327] MultisessionFuture started
[10:33:09.327] - Launch lazy future ... done
[10:33:09.327] run() for ‘MultisessionFuture’ ... done
[10:33:09.328] result() for ClusterFuture ...
[10:33:09.328] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.328] - Validating connection of MultisessionFuture
[10:33:09.329] - received message: FutureResult
[10:33:09.329] - Received FutureResult
[10:33:09.329] - Erased future from FutureRegistry
[10:33:09.329] result() for ClusterFuture ...
[10:33:09.329] - result already collected: FutureResult
[10:33:09.329] result() for ClusterFuture ... done
[10:33:09.329] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.329] result() for ClusterFuture ... done
[10:33:09.330] result() for ClusterFuture ...
[10:33:09.330] - result already collected: FutureResult
[10:33:09.330] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.330] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.330] Searching for globals...
[10:33:09.332] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:09.332] Searching for globals ... DONE
[10:33:09.332] Resolving globals: TRUE
[10:33:09.333] Resolving any globals that are futures ...
[10:33:09.333] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:33:09.333] Resolving any globals that are futures ... DONE
[10:33:09.333] Resolving futures part of globals (recursively) ...
[10:33:09.333] resolve() on list ...
[10:33:09.333]  recursive: 99
[10:33:09.334]  length: 1
[10:33:09.334]  elements: ‘x’
[10:33:09.334]  length: 0 (resolved future 1)
[10:33:09.334] resolve() on list ... DONE
[10:33:09.334] - globals: [1] ‘x’
[10:33:09.334] Resolving futures part of globals (recursively) ... DONE
[10:33:09.334] The total size of the 1 globals is 0 bytes (0 bytes)
[10:33:09.334] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[10:33:09.335] - globals: [1] ‘x’
[10:33:09.335] 
[10:33:09.335] getGlobalsAndPackages() ... DONE
[10:33:09.335] run() for ‘Future’ ...
[10:33:09.335] - state: ‘created’
[10:33:09.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.349]   - Field: ‘node’
[10:33:09.349]   - Field: ‘label’
[10:33:09.349]   - Field: ‘local’
[10:33:09.349]   - Field: ‘owner’
[10:33:09.349]   - Field: ‘envir’
[10:33:09.349]   - Field: ‘workers’
[10:33:09.349]   - Field: ‘packages’
[10:33:09.349]   - Field: ‘gc’
[10:33:09.350]   - Field: ‘conditions’
[10:33:09.350]   - Field: ‘persistent’
[10:33:09.350]   - Field: ‘expr’
[10:33:09.350]   - Field: ‘uuid’
[10:33:09.350]   - Field: ‘seed’
[10:33:09.350]   - Field: ‘version’
[10:33:09.350]   - Field: ‘result’
[10:33:09.350]   - Field: ‘asynchronous’
[10:33:09.350]   - Field: ‘calls’
[10:33:09.350]   - Field: ‘globals’
[10:33:09.350]   - Field: ‘stdout’
[10:33:09.351]   - Field: ‘earlySignal’
[10:33:09.351]   - Field: ‘lazy’
[10:33:09.351]   - Field: ‘state’
[10:33:09.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.351] - Launch lazy future ...
[10:33:09.351] Packages needed by the future expression (n = 0): <none>
[10:33:09.351] Packages needed by future strategies (n = 0): <none>
[10:33:09.352] {
[10:33:09.352]     {
[10:33:09.352]         {
[10:33:09.352]             ...future.startTime <- base::Sys.time()
[10:33:09.352]             {
[10:33:09.352]                 {
[10:33:09.352]                   {
[10:33:09.352]                     {
[10:33:09.352]                       base::local({
[10:33:09.352]                         has_future <- base::requireNamespace("future", 
[10:33:09.352]                           quietly = TRUE)
[10:33:09.352]                         if (has_future) {
[10:33:09.352]                           ns <- base::getNamespace("future")
[10:33:09.352]                           version <- ns[[".package"]][["version"]]
[10:33:09.352]                           if (is.null(version)) 
[10:33:09.352]                             version <- utils::packageVersion("future")
[10:33:09.352]                         }
[10:33:09.352]                         else {
[10:33:09.352]                           version <- NULL
[10:33:09.352]                         }
[10:33:09.352]                         if (!has_future || version < "1.8.0") {
[10:33:09.352]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.352]                             "", base::R.version$version.string), 
[10:33:09.352]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.352]                               "release", "version")], collapse = " "), 
[10:33:09.352]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.352]                             info)
[10:33:09.352]                           info <- base::paste(info, collapse = "; ")
[10:33:09.352]                           if (!has_future) {
[10:33:09.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.352]                               info)
[10:33:09.352]                           }
[10:33:09.352]                           else {
[10:33:09.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.352]                               info, version)
[10:33:09.352]                           }
[10:33:09.352]                           base::stop(msg)
[10:33:09.352]                         }
[10:33:09.352]                       })
[10:33:09.352]                     }
[10:33:09.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.352]                     base::options(mc.cores = 1L)
[10:33:09.352]                   }
[10:33:09.352]                   ...future.strategy.old <- future::plan("list")
[10:33:09.352]                   options(future.plan = NULL)
[10:33:09.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.352]                 }
[10:33:09.352]                 ...future.workdir <- getwd()
[10:33:09.352]             }
[10:33:09.352]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.352]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.352]         }
[10:33:09.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.352]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.352]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.352]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.352]             base::names(...future.oldOptions))
[10:33:09.352]     }
[10:33:09.352]     if (FALSE) {
[10:33:09.352]     }
[10:33:09.352]     else {
[10:33:09.352]         if (TRUE) {
[10:33:09.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.352]                 open = "w")
[10:33:09.352]         }
[10:33:09.352]         else {
[10:33:09.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.352]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.352]         }
[10:33:09.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.352]             base::sink(type = "output", split = FALSE)
[10:33:09.352]             base::close(...future.stdout)
[10:33:09.352]         }, add = TRUE)
[10:33:09.352]     }
[10:33:09.352]     ...future.frame <- base::sys.nframe()
[10:33:09.352]     ...future.conditions <- base::list()
[10:33:09.352]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.352]     if (FALSE) {
[10:33:09.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.352]     }
[10:33:09.352]     ...future.result <- base::tryCatch({
[10:33:09.352]         base::withCallingHandlers({
[10:33:09.352]             ...future.value <- base::withVisible(base::local({
[10:33:09.352]                 ...future.makeSendCondition <- base::local({
[10:33:09.352]                   sendCondition <- NULL
[10:33:09.352]                   function(frame = 1L) {
[10:33:09.352]                     if (is.function(sendCondition)) 
[10:33:09.352]                       return(sendCondition)
[10:33:09.352]                     ns <- getNamespace("parallel")
[10:33:09.352]                     if (exists("sendData", mode = "function", 
[10:33:09.352]                       envir = ns)) {
[10:33:09.352]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.352]                         envir = ns)
[10:33:09.352]                       envir <- sys.frame(frame)
[10:33:09.352]                       master <- NULL
[10:33:09.352]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.352]                         !identical(envir, emptyenv())) {
[10:33:09.352]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.352]                           inherits = FALSE)) {
[10:33:09.352]                           master <- get("master", mode = "list", 
[10:33:09.352]                             envir = envir, inherits = FALSE)
[10:33:09.352]                           if (inherits(master, c("SOCKnode", 
[10:33:09.352]                             "SOCK0node"))) {
[10:33:09.352]                             sendCondition <<- function(cond) {
[10:33:09.352]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.352]                                 success = TRUE)
[10:33:09.352]                               parallel_sendData(master, data)
[10:33:09.352]                             }
[10:33:09.352]                             return(sendCondition)
[10:33:09.352]                           }
[10:33:09.352]                         }
[10:33:09.352]                         frame <- frame + 1L
[10:33:09.352]                         envir <- sys.frame(frame)
[10:33:09.352]                       }
[10:33:09.352]                     }
[10:33:09.352]                     sendCondition <<- function(cond) NULL
[10:33:09.352]                   }
[10:33:09.352]                 })
[10:33:09.352]                 withCallingHandlers({
[10:33:09.352]                   {
[10:33:09.352]                     x["a"] <- list(1)
[10:33:09.352]                     x
[10:33:09.352]                   }
[10:33:09.352]                 }, immediateCondition = function(cond) {
[10:33:09.352]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.352]                   sendCondition(cond)
[10:33:09.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.352]                   {
[10:33:09.352]                     inherits <- base::inherits
[10:33:09.352]                     invokeRestart <- base::invokeRestart
[10:33:09.352]                     is.null <- base::is.null
[10:33:09.352]                     muffled <- FALSE
[10:33:09.352]                     if (inherits(cond, "message")) {
[10:33:09.352]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.352]                       if (muffled) 
[10:33:09.352]                         invokeRestart("muffleMessage")
[10:33:09.352]                     }
[10:33:09.352]                     else if (inherits(cond, "warning")) {
[10:33:09.352]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.352]                       if (muffled) 
[10:33:09.352]                         invokeRestart("muffleWarning")
[10:33:09.352]                     }
[10:33:09.352]                     else if (inherits(cond, "condition")) {
[10:33:09.352]                       if (!is.null(pattern)) {
[10:33:09.352]                         computeRestarts <- base::computeRestarts
[10:33:09.352]                         grepl <- base::grepl
[10:33:09.352]                         restarts <- computeRestarts(cond)
[10:33:09.352]                         for (restart in restarts) {
[10:33:09.352]                           name <- restart$name
[10:33:09.352]                           if (is.null(name)) 
[10:33:09.352]                             next
[10:33:09.352]                           if (!grepl(pattern, name)) 
[10:33:09.352]                             next
[10:33:09.352]                           invokeRestart(restart)
[10:33:09.352]                           muffled <- TRUE
[10:33:09.352]                           break
[10:33:09.352]                         }
[10:33:09.352]                       }
[10:33:09.352]                     }
[10:33:09.352]                     invisible(muffled)
[10:33:09.352]                   }
[10:33:09.352]                   muffleCondition(cond)
[10:33:09.352]                 })
[10:33:09.352]             }))
[10:33:09.352]             future::FutureResult(value = ...future.value$value, 
[10:33:09.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.352]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.352]                     ...future.globalenv.names))
[10:33:09.352]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.352]         }, condition = base::local({
[10:33:09.352]             c <- base::c
[10:33:09.352]             inherits <- base::inherits
[10:33:09.352]             invokeRestart <- base::invokeRestart
[10:33:09.352]             length <- base::length
[10:33:09.352]             list <- base::list
[10:33:09.352]             seq.int <- base::seq.int
[10:33:09.352]             signalCondition <- base::signalCondition
[10:33:09.352]             sys.calls <- base::sys.calls
[10:33:09.352]             `[[` <- base::`[[`
[10:33:09.352]             `+` <- base::`+`
[10:33:09.352]             `<<-` <- base::`<<-`
[10:33:09.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.352]                   3L)]
[10:33:09.352]             }
[10:33:09.352]             function(cond) {
[10:33:09.352]                 is_error <- inherits(cond, "error")
[10:33:09.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.352]                   NULL)
[10:33:09.352]                 if (is_error) {
[10:33:09.352]                   sessionInformation <- function() {
[10:33:09.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.352]                       search = base::search(), system = base::Sys.info())
[10:33:09.352]                   }
[10:33:09.352]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.352]                     cond$call), session = sessionInformation(), 
[10:33:09.352]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.352]                   signalCondition(cond)
[10:33:09.352]                 }
[10:33:09.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.352]                 "immediateCondition"))) {
[10:33:09.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.352]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.352]                   if (TRUE && !signal) {
[10:33:09.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.352]                     {
[10:33:09.352]                       inherits <- base::inherits
[10:33:09.352]                       invokeRestart <- base::invokeRestart
[10:33:09.352]                       is.null <- base::is.null
[10:33:09.352]                       muffled <- FALSE
[10:33:09.352]                       if (inherits(cond, "message")) {
[10:33:09.352]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.352]                         if (muffled) 
[10:33:09.352]                           invokeRestart("muffleMessage")
[10:33:09.352]                       }
[10:33:09.352]                       else if (inherits(cond, "warning")) {
[10:33:09.352]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.352]                         if (muffled) 
[10:33:09.352]                           invokeRestart("muffleWarning")
[10:33:09.352]                       }
[10:33:09.352]                       else if (inherits(cond, "condition")) {
[10:33:09.352]                         if (!is.null(pattern)) {
[10:33:09.352]                           computeRestarts <- base::computeRestarts
[10:33:09.352]                           grepl <- base::grepl
[10:33:09.352]                           restarts <- computeRestarts(cond)
[10:33:09.352]                           for (restart in restarts) {
[10:33:09.352]                             name <- restart$name
[10:33:09.352]                             if (is.null(name)) 
[10:33:09.352]                               next
[10:33:09.352]                             if (!grepl(pattern, name)) 
[10:33:09.352]                               next
[10:33:09.352]                             invokeRestart(restart)
[10:33:09.352]                             muffled <- TRUE
[10:33:09.352]                             break
[10:33:09.352]                           }
[10:33:09.352]                         }
[10:33:09.352]                       }
[10:33:09.352]                       invisible(muffled)
[10:33:09.352]                     }
[10:33:09.352]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.352]                   }
[10:33:09.352]                 }
[10:33:09.352]                 else {
[10:33:09.352]                   if (TRUE) {
[10:33:09.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.352]                     {
[10:33:09.352]                       inherits <- base::inherits
[10:33:09.352]                       invokeRestart <- base::invokeRestart
[10:33:09.352]                       is.null <- base::is.null
[10:33:09.352]                       muffled <- FALSE
[10:33:09.352]                       if (inherits(cond, "message")) {
[10:33:09.352]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.352]                         if (muffled) 
[10:33:09.352]                           invokeRestart("muffleMessage")
[10:33:09.352]                       }
[10:33:09.352]                       else if (inherits(cond, "warning")) {
[10:33:09.352]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.352]                         if (muffled) 
[10:33:09.352]                           invokeRestart("muffleWarning")
[10:33:09.352]                       }
[10:33:09.352]                       else if (inherits(cond, "condition")) {
[10:33:09.352]                         if (!is.null(pattern)) {
[10:33:09.352]                           computeRestarts <- base::computeRestarts
[10:33:09.352]                           grepl <- base::grepl
[10:33:09.352]                           restarts <- computeRestarts(cond)
[10:33:09.352]                           for (restart in restarts) {
[10:33:09.352]                             name <- restart$name
[10:33:09.352]                             if (is.null(name)) 
[10:33:09.352]                               next
[10:33:09.352]                             if (!grepl(pattern, name)) 
[10:33:09.352]                               next
[10:33:09.352]                             invokeRestart(restart)
[10:33:09.352]                             muffled <- TRUE
[10:33:09.352]                             break
[10:33:09.352]                           }
[10:33:09.352]                         }
[10:33:09.352]                       }
[10:33:09.352]                       invisible(muffled)
[10:33:09.352]                     }
[10:33:09.352]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.352]                   }
[10:33:09.352]                 }
[10:33:09.352]             }
[10:33:09.352]         }))
[10:33:09.352]     }, error = function(ex) {
[10:33:09.352]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.352]                 ...future.rng), started = ...future.startTime, 
[10:33:09.352]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.352]             version = "1.8"), class = "FutureResult")
[10:33:09.352]     }, finally = {
[10:33:09.352]         if (!identical(...future.workdir, getwd())) 
[10:33:09.352]             setwd(...future.workdir)
[10:33:09.352]         {
[10:33:09.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.352]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.352]             }
[10:33:09.352]             base::options(...future.oldOptions)
[10:33:09.352]             if (.Platform$OS.type == "windows") {
[10:33:09.352]                 old_names <- names(...future.oldEnvVars)
[10:33:09.352]                 envs <- base::Sys.getenv()
[10:33:09.352]                 names <- names(envs)
[10:33:09.352]                 common <- intersect(names, old_names)
[10:33:09.352]                 added <- setdiff(names, old_names)
[10:33:09.352]                 removed <- setdiff(old_names, names)
[10:33:09.352]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.352]                   envs[common]]
[10:33:09.352]                 NAMES <- toupper(changed)
[10:33:09.352]                 args <- list()
[10:33:09.352]                 for (kk in seq_along(NAMES)) {
[10:33:09.352]                   name <- changed[[kk]]
[10:33:09.352]                   NAME <- NAMES[[kk]]
[10:33:09.352]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.352]                     next
[10:33:09.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.352]                 }
[10:33:09.352]                 NAMES <- toupper(added)
[10:33:09.352]                 for (kk in seq_along(NAMES)) {
[10:33:09.352]                   name <- added[[kk]]
[10:33:09.352]                   NAME <- NAMES[[kk]]
[10:33:09.352]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.352]                     next
[10:33:09.352]                   args[[name]] <- ""
[10:33:09.352]                 }
[10:33:09.352]                 NAMES <- toupper(removed)
[10:33:09.352]                 for (kk in seq_along(NAMES)) {
[10:33:09.352]                   name <- removed[[kk]]
[10:33:09.352]                   NAME <- NAMES[[kk]]
[10:33:09.352]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.352]                     next
[10:33:09.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.352]                 }
[10:33:09.352]                 if (length(args) > 0) 
[10:33:09.352]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.352]             }
[10:33:09.352]             else {
[10:33:09.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.352]             }
[10:33:09.352]             {
[10:33:09.352]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.352]                   0L) {
[10:33:09.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.352]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.352]                   base::options(opts)
[10:33:09.352]                 }
[10:33:09.352]                 {
[10:33:09.352]                   {
[10:33:09.352]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.352]                     NULL
[10:33:09.352]                   }
[10:33:09.352]                   options(future.plan = NULL)
[10:33:09.352]                   if (is.na(NA_character_)) 
[10:33:09.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.352]                     .init = FALSE)
[10:33:09.352]                 }
[10:33:09.352]             }
[10:33:09.352]         }
[10:33:09.352]     })
[10:33:09.352]     if (TRUE) {
[10:33:09.352]         base::sink(type = "output", split = FALSE)
[10:33:09.352]         if (TRUE) {
[10:33:09.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.352]         }
[10:33:09.352]         else {
[10:33:09.352]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.352]         }
[10:33:09.352]         base::close(...future.stdout)
[10:33:09.352]         ...future.stdout <- NULL
[10:33:09.352]     }
[10:33:09.352]     ...future.result$conditions <- ...future.conditions
[10:33:09.352]     ...future.result$finished <- base::Sys.time()
[10:33:09.352]     ...future.result
[10:33:09.352] }
[10:33:09.354] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[10:33:09.354] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.355] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.355] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[10:33:09.355] MultisessionFuture started
[10:33:09.355] - Launch lazy future ... done
[10:33:09.355] run() for ‘MultisessionFuture’ ... done
[10:33:09.356] result() for ClusterFuture ...
[10:33:09.356] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.356] - Validating connection of MultisessionFuture
[10:33:09.357] - received message: FutureResult
[10:33:09.357] - Received FutureResult
[10:33:09.357] - Erased future from FutureRegistry
[10:33:09.357] result() for ClusterFuture ...
[10:33:09.357] - result already collected: FutureResult
[10:33:09.357] result() for ClusterFuture ... done
[10:33:09.357] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.357] result() for ClusterFuture ... done
[10:33:09.358] result() for ClusterFuture ...
[10:33:09.358] - result already collected: FutureResult
[10:33:09.358] result() for ClusterFuture ... done
$a
[1] 1

Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:33:09.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:33:09.358] Searching for globals...
[10:33:09.360] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:33:09.360] Searching for globals ... DONE
[10:33:09.361] Resolving globals: TRUE
[10:33:09.361] Resolving any globals that are futures ...
[10:33:09.361] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:33:09.361] Resolving any globals that are futures ... DONE
[10:33:09.361] Resolving futures part of globals (recursively) ...
[10:33:09.361] resolve() on list ...
[10:33:09.362]  recursive: 99
[10:33:09.362]  length: 2
[10:33:09.362]  elements: ‘x’, ‘name’
[10:33:09.362]  length: 1 (resolved future 1)
[10:33:09.362]  length: 0 (resolved future 2)
[10:33:09.362] resolve() on list ... DONE
[10:33:09.362] - globals: [2] ‘x’, ‘name’
[10:33:09.362] Resolving futures part of globals (recursively) ... DONE
[10:33:09.362] The total size of the 2 globals is 112 bytes (112 bytes)
[10:33:09.363] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[10:33:09.363] - globals: [2] ‘x’, ‘name’
[10:33:09.363] 
[10:33:09.363] getGlobalsAndPackages() ... DONE
[10:33:09.363] run() for ‘Future’ ...
[10:33:09.363] - state: ‘created’
[10:33:09.364] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:33:09.377] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:09.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:33:09.377]   - Field: ‘node’
[10:33:09.377]   - Field: ‘label’
[10:33:09.377]   - Field: ‘local’
[10:33:09.377]   - Field: ‘owner’
[10:33:09.378]   - Field: ‘envir’
[10:33:09.378]   - Field: ‘workers’
[10:33:09.378]   - Field: ‘packages’
[10:33:09.378]   - Field: ‘gc’
[10:33:09.378]   - Field: ‘conditions’
[10:33:09.378]   - Field: ‘persistent’
[10:33:09.378]   - Field: ‘expr’
[10:33:09.378]   - Field: ‘uuid’
[10:33:09.378]   - Field: ‘seed’
[10:33:09.378]   - Field: ‘version’
[10:33:09.378]   - Field: ‘result’
[10:33:09.379]   - Field: ‘asynchronous’
[10:33:09.379]   - Field: ‘calls’
[10:33:09.379]   - Field: ‘globals’
[10:33:09.379]   - Field: ‘stdout’
[10:33:09.379]   - Field: ‘earlySignal’
[10:33:09.379]   - Field: ‘lazy’
[10:33:09.379]   - Field: ‘state’
[10:33:09.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:33:09.379] - Launch lazy future ...
[10:33:09.379] Packages needed by the future expression (n = 0): <none>
[10:33:09.380] Packages needed by future strategies (n = 0): <none>
[10:33:09.380] {
[10:33:09.380]     {
[10:33:09.380]         {
[10:33:09.380]             ...future.startTime <- base::Sys.time()
[10:33:09.380]             {
[10:33:09.380]                 {
[10:33:09.380]                   {
[10:33:09.380]                     {
[10:33:09.380]                       base::local({
[10:33:09.380]                         has_future <- base::requireNamespace("future", 
[10:33:09.380]                           quietly = TRUE)
[10:33:09.380]                         if (has_future) {
[10:33:09.380]                           ns <- base::getNamespace("future")
[10:33:09.380]                           version <- ns[[".package"]][["version"]]
[10:33:09.380]                           if (is.null(version)) 
[10:33:09.380]                             version <- utils::packageVersion("future")
[10:33:09.380]                         }
[10:33:09.380]                         else {
[10:33:09.380]                           version <- NULL
[10:33:09.380]                         }
[10:33:09.380]                         if (!has_future || version < "1.8.0") {
[10:33:09.380]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:09.380]                             "", base::R.version$version.string), 
[10:33:09.380]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:09.380]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:09.380]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:09.380]                               "release", "version")], collapse = " "), 
[10:33:09.380]                             hostname = base::Sys.info()[["nodename"]])
[10:33:09.380]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:09.380]                             info)
[10:33:09.380]                           info <- base::paste(info, collapse = "; ")
[10:33:09.380]                           if (!has_future) {
[10:33:09.380]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:09.380]                               info)
[10:33:09.380]                           }
[10:33:09.380]                           else {
[10:33:09.380]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:09.380]                               info, version)
[10:33:09.380]                           }
[10:33:09.380]                           base::stop(msg)
[10:33:09.380]                         }
[10:33:09.380]                       })
[10:33:09.380]                     }
[10:33:09.380]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:09.380]                     base::options(mc.cores = 1L)
[10:33:09.380]                   }
[10:33:09.380]                   ...future.strategy.old <- future::plan("list")
[10:33:09.380]                   options(future.plan = NULL)
[10:33:09.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:09.380]                 }
[10:33:09.380]                 ...future.workdir <- getwd()
[10:33:09.380]             }
[10:33:09.380]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:09.380]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:09.380]         }
[10:33:09.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:33:09.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:09.380]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:33:09.380]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:33:09.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:09.380]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:09.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:09.380]             base::names(...future.oldOptions))
[10:33:09.380]     }
[10:33:09.380]     if (FALSE) {
[10:33:09.380]     }
[10:33:09.380]     else {
[10:33:09.380]         if (TRUE) {
[10:33:09.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:09.380]                 open = "w")
[10:33:09.380]         }
[10:33:09.380]         else {
[10:33:09.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:09.380]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:09.380]         }
[10:33:09.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:09.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:09.380]             base::sink(type = "output", split = FALSE)
[10:33:09.380]             base::close(...future.stdout)
[10:33:09.380]         }, add = TRUE)
[10:33:09.380]     }
[10:33:09.380]     ...future.frame <- base::sys.nframe()
[10:33:09.380]     ...future.conditions <- base::list()
[10:33:09.380]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:09.380]     if (FALSE) {
[10:33:09.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:09.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:09.380]     }
[10:33:09.380]     ...future.result <- base::tryCatch({
[10:33:09.380]         base::withCallingHandlers({
[10:33:09.380]             ...future.value <- base::withVisible(base::local({
[10:33:09.380]                 ...future.makeSendCondition <- base::local({
[10:33:09.380]                   sendCondition <- NULL
[10:33:09.380]                   function(frame = 1L) {
[10:33:09.380]                     if (is.function(sendCondition)) 
[10:33:09.380]                       return(sendCondition)
[10:33:09.380]                     ns <- getNamespace("parallel")
[10:33:09.380]                     if (exists("sendData", mode = "function", 
[10:33:09.380]                       envir = ns)) {
[10:33:09.380]                       parallel_sendData <- get("sendData", mode = "function", 
[10:33:09.380]                         envir = ns)
[10:33:09.380]                       envir <- sys.frame(frame)
[10:33:09.380]                       master <- NULL
[10:33:09.380]                       while (!identical(envir, .GlobalEnv) && 
[10:33:09.380]                         !identical(envir, emptyenv())) {
[10:33:09.380]                         if (exists("master", mode = "list", envir = envir, 
[10:33:09.380]                           inherits = FALSE)) {
[10:33:09.380]                           master <- get("master", mode = "list", 
[10:33:09.380]                             envir = envir, inherits = FALSE)
[10:33:09.380]                           if (inherits(master, c("SOCKnode", 
[10:33:09.380]                             "SOCK0node"))) {
[10:33:09.380]                             sendCondition <<- function(cond) {
[10:33:09.380]                               data <- list(type = "VALUE", value = cond, 
[10:33:09.380]                                 success = TRUE)
[10:33:09.380]                               parallel_sendData(master, data)
[10:33:09.380]                             }
[10:33:09.380]                             return(sendCondition)
[10:33:09.380]                           }
[10:33:09.380]                         }
[10:33:09.380]                         frame <- frame + 1L
[10:33:09.380]                         envir <- sys.frame(frame)
[10:33:09.380]                       }
[10:33:09.380]                     }
[10:33:09.380]                     sendCondition <<- function(cond) NULL
[10:33:09.380]                   }
[10:33:09.380]                 })
[10:33:09.380]                 withCallingHandlers({
[10:33:09.380]                   {
[10:33:09.380]                     x[name] <- list(1)
[10:33:09.380]                     x
[10:33:09.380]                   }
[10:33:09.380]                 }, immediateCondition = function(cond) {
[10:33:09.380]                   sendCondition <- ...future.makeSendCondition()
[10:33:09.380]                   sendCondition(cond)
[10:33:09.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.380]                   {
[10:33:09.380]                     inherits <- base::inherits
[10:33:09.380]                     invokeRestart <- base::invokeRestart
[10:33:09.380]                     is.null <- base::is.null
[10:33:09.380]                     muffled <- FALSE
[10:33:09.380]                     if (inherits(cond, "message")) {
[10:33:09.380]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:09.380]                       if (muffled) 
[10:33:09.380]                         invokeRestart("muffleMessage")
[10:33:09.380]                     }
[10:33:09.380]                     else if (inherits(cond, "warning")) {
[10:33:09.380]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:09.380]                       if (muffled) 
[10:33:09.380]                         invokeRestart("muffleWarning")
[10:33:09.380]                     }
[10:33:09.380]                     else if (inherits(cond, "condition")) {
[10:33:09.380]                       if (!is.null(pattern)) {
[10:33:09.380]                         computeRestarts <- base::computeRestarts
[10:33:09.380]                         grepl <- base::grepl
[10:33:09.380]                         restarts <- computeRestarts(cond)
[10:33:09.380]                         for (restart in restarts) {
[10:33:09.380]                           name <- restart$name
[10:33:09.380]                           if (is.null(name)) 
[10:33:09.380]                             next
[10:33:09.380]                           if (!grepl(pattern, name)) 
[10:33:09.380]                             next
[10:33:09.380]                           invokeRestart(restart)
[10:33:09.380]                           muffled <- TRUE
[10:33:09.380]                           break
[10:33:09.380]                         }
[10:33:09.380]                       }
[10:33:09.380]                     }
[10:33:09.380]                     invisible(muffled)
[10:33:09.380]                   }
[10:33:09.380]                   muffleCondition(cond)
[10:33:09.380]                 })
[10:33:09.380]             }))
[10:33:09.380]             future::FutureResult(value = ...future.value$value, 
[10:33:09.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.380]                   ...future.rng), globalenv = if (FALSE) 
[10:33:09.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:09.380]                     ...future.globalenv.names))
[10:33:09.380]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:09.380]         }, condition = base::local({
[10:33:09.380]             c <- base::c
[10:33:09.380]             inherits <- base::inherits
[10:33:09.380]             invokeRestart <- base::invokeRestart
[10:33:09.380]             length <- base::length
[10:33:09.380]             list <- base::list
[10:33:09.380]             seq.int <- base::seq.int
[10:33:09.380]             signalCondition <- base::signalCondition
[10:33:09.380]             sys.calls <- base::sys.calls
[10:33:09.380]             `[[` <- base::`[[`
[10:33:09.380]             `+` <- base::`+`
[10:33:09.380]             `<<-` <- base::`<<-`
[10:33:09.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:09.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:09.380]                   3L)]
[10:33:09.380]             }
[10:33:09.380]             function(cond) {
[10:33:09.380]                 is_error <- inherits(cond, "error")
[10:33:09.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:09.380]                   NULL)
[10:33:09.380]                 if (is_error) {
[10:33:09.380]                   sessionInformation <- function() {
[10:33:09.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:09.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:09.380]                       search = base::search(), system = base::Sys.info())
[10:33:09.380]                   }
[10:33:09.380]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:09.380]                     cond$call), session = sessionInformation(), 
[10:33:09.380]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:09.380]                   signalCondition(cond)
[10:33:09.380]                 }
[10:33:09.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:09.380]                 "immediateCondition"))) {
[10:33:09.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:09.380]                   ...future.conditions[[length(...future.conditions) + 
[10:33:09.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:09.380]                   if (TRUE && !signal) {
[10:33:09.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.380]                     {
[10:33:09.380]                       inherits <- base::inherits
[10:33:09.380]                       invokeRestart <- base::invokeRestart
[10:33:09.380]                       is.null <- base::is.null
[10:33:09.380]                       muffled <- FALSE
[10:33:09.380]                       if (inherits(cond, "message")) {
[10:33:09.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.380]                         if (muffled) 
[10:33:09.380]                           invokeRestart("muffleMessage")
[10:33:09.380]                       }
[10:33:09.380]                       else if (inherits(cond, "warning")) {
[10:33:09.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.380]                         if (muffled) 
[10:33:09.380]                           invokeRestart("muffleWarning")
[10:33:09.380]                       }
[10:33:09.380]                       else if (inherits(cond, "condition")) {
[10:33:09.380]                         if (!is.null(pattern)) {
[10:33:09.380]                           computeRestarts <- base::computeRestarts
[10:33:09.380]                           grepl <- base::grepl
[10:33:09.380]                           restarts <- computeRestarts(cond)
[10:33:09.380]                           for (restart in restarts) {
[10:33:09.380]                             name <- restart$name
[10:33:09.380]                             if (is.null(name)) 
[10:33:09.380]                               next
[10:33:09.380]                             if (!grepl(pattern, name)) 
[10:33:09.380]                               next
[10:33:09.380]                             invokeRestart(restart)
[10:33:09.380]                             muffled <- TRUE
[10:33:09.380]                             break
[10:33:09.380]                           }
[10:33:09.380]                         }
[10:33:09.380]                       }
[10:33:09.380]                       invisible(muffled)
[10:33:09.380]                     }
[10:33:09.380]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.380]                   }
[10:33:09.380]                 }
[10:33:09.380]                 else {
[10:33:09.380]                   if (TRUE) {
[10:33:09.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:09.380]                     {
[10:33:09.380]                       inherits <- base::inherits
[10:33:09.380]                       invokeRestart <- base::invokeRestart
[10:33:09.380]                       is.null <- base::is.null
[10:33:09.380]                       muffled <- FALSE
[10:33:09.380]                       if (inherits(cond, "message")) {
[10:33:09.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:09.380]                         if (muffled) 
[10:33:09.380]                           invokeRestart("muffleMessage")
[10:33:09.380]                       }
[10:33:09.380]                       else if (inherits(cond, "warning")) {
[10:33:09.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:09.380]                         if (muffled) 
[10:33:09.380]                           invokeRestart("muffleWarning")
[10:33:09.380]                       }
[10:33:09.380]                       else if (inherits(cond, "condition")) {
[10:33:09.380]                         if (!is.null(pattern)) {
[10:33:09.380]                           computeRestarts <- base::computeRestarts
[10:33:09.380]                           grepl <- base::grepl
[10:33:09.380]                           restarts <- computeRestarts(cond)
[10:33:09.380]                           for (restart in restarts) {
[10:33:09.380]                             name <- restart$name
[10:33:09.380]                             if (is.null(name)) 
[10:33:09.380]                               next
[10:33:09.380]                             if (!grepl(pattern, name)) 
[10:33:09.380]                               next
[10:33:09.380]                             invokeRestart(restart)
[10:33:09.380]                             muffled <- TRUE
[10:33:09.380]                             break
[10:33:09.380]                           }
[10:33:09.380]                         }
[10:33:09.380]                       }
[10:33:09.380]                       invisible(muffled)
[10:33:09.380]                     }
[10:33:09.380]                     muffleCondition(cond, pattern = "^muffle")
[10:33:09.380]                   }
[10:33:09.380]                 }
[10:33:09.380]             }
[10:33:09.380]         }))
[10:33:09.380]     }, error = function(ex) {
[10:33:09.380]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:09.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:09.380]                 ...future.rng), started = ...future.startTime, 
[10:33:09.380]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:09.380]             version = "1.8"), class = "FutureResult")
[10:33:09.380]     }, finally = {
[10:33:09.380]         if (!identical(...future.workdir, getwd())) 
[10:33:09.380]             setwd(...future.workdir)
[10:33:09.380]         {
[10:33:09.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:09.380]                 ...future.oldOptions$nwarnings <- NULL
[10:33:09.380]             }
[10:33:09.380]             base::options(...future.oldOptions)
[10:33:09.380]             if (.Platform$OS.type == "windows") {
[10:33:09.380]                 old_names <- names(...future.oldEnvVars)
[10:33:09.380]                 envs <- base::Sys.getenv()
[10:33:09.380]                 names <- names(envs)
[10:33:09.380]                 common <- intersect(names, old_names)
[10:33:09.380]                 added <- setdiff(names, old_names)
[10:33:09.380]                 removed <- setdiff(old_names, names)
[10:33:09.380]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:09.380]                   envs[common]]
[10:33:09.380]                 NAMES <- toupper(changed)
[10:33:09.380]                 args <- list()
[10:33:09.380]                 for (kk in seq_along(NAMES)) {
[10:33:09.380]                   name <- changed[[kk]]
[10:33:09.380]                   NAME <- NAMES[[kk]]
[10:33:09.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.380]                     next
[10:33:09.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.380]                 }
[10:33:09.380]                 NAMES <- toupper(added)
[10:33:09.380]                 for (kk in seq_along(NAMES)) {
[10:33:09.380]                   name <- added[[kk]]
[10:33:09.380]                   NAME <- NAMES[[kk]]
[10:33:09.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.380]                     next
[10:33:09.380]                   args[[name]] <- ""
[10:33:09.380]                 }
[10:33:09.380]                 NAMES <- toupper(removed)
[10:33:09.380]                 for (kk in seq_along(NAMES)) {
[10:33:09.380]                   name <- removed[[kk]]
[10:33:09.380]                   NAME <- NAMES[[kk]]
[10:33:09.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:09.380]                     next
[10:33:09.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:09.380]                 }
[10:33:09.380]                 if (length(args) > 0) 
[10:33:09.380]                   base::do.call(base::Sys.setenv, args = args)
[10:33:09.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:09.380]             }
[10:33:09.380]             else {
[10:33:09.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:09.380]             }
[10:33:09.380]             {
[10:33:09.380]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:09.380]                   0L) {
[10:33:09.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:09.380]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:09.380]                   base::options(opts)
[10:33:09.380]                 }
[10:33:09.380]                 {
[10:33:09.380]                   {
[10:33:09.380]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:09.380]                     NULL
[10:33:09.380]                   }
[10:33:09.380]                   options(future.plan = NULL)
[10:33:09.380]                   if (is.na(NA_character_)) 
[10:33:09.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:09.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:09.380]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:09.380]                     .init = FALSE)
[10:33:09.380]                 }
[10:33:09.380]             }
[10:33:09.380]         }
[10:33:09.380]     })
[10:33:09.380]     if (TRUE) {
[10:33:09.380]         base::sink(type = "output", split = FALSE)
[10:33:09.380]         if (TRUE) {
[10:33:09.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:09.380]         }
[10:33:09.380]         else {
[10:33:09.380]             ...future.result["stdout"] <- base::list(NULL)
[10:33:09.380]         }
[10:33:09.380]         base::close(...future.stdout)
[10:33:09.380]         ...future.stdout <- NULL
[10:33:09.380]     }
[10:33:09.380]     ...future.result$conditions <- ...future.conditions
[10:33:09.380]     ...future.result$finished <- base::Sys.time()
[10:33:09.380]     ...future.result
[10:33:09.380] }
[10:33:09.382] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:33:09.383] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[10:33:09.383] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[10:33:09.383] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[10:33:09.386] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[10:33:09.386] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:33:09.386] MultisessionFuture started
[10:33:09.386] - Launch lazy future ... done
[10:33:09.386] run() for ‘MultisessionFuture’ ... done
[10:33:09.387] result() for ClusterFuture ...
[10:33:09.387] receiveMessageFromWorker() for ClusterFuture ...
[10:33:09.387] - Validating connection of MultisessionFuture
[10:33:09.388] - received message: FutureResult
[10:33:09.388] - Received FutureResult
[10:33:09.388] - Erased future from FutureRegistry
[10:33:09.388] result() for ClusterFuture ...
[10:33:09.388] - result already collected: FutureResult
[10:33:09.388] result() for ClusterFuture ... done
[10:33:09.388] receiveMessageFromWorker() for ClusterFuture ... done
[10:33:09.388] result() for ClusterFuture ... done
[10:33:09.388] result() for ClusterFuture ...
[10:33:09.389] - result already collected: FutureResult
[10:33:09.389] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[10:33:09.390] plan(): Setting new future strategy stack:
[10:33:09.390] List of future strategies:
[10:33:09.390] 1. FutureStrategy:
[10:33:09.390]    - args: function (..., envir = parent.frame())
[10:33:09.390]    - tweaked: FALSE
[10:33:09.390]    - call: future::plan(oplan)
[10:33:09.390] plan(): nbrOfWorkers() = 1
> 
