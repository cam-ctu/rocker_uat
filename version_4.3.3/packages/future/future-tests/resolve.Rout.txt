
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:21:49.164] plan(): Setting new future strategy stack:
[16:21:49.165] List of future strategies:
[16:21:49.165] 1. sequential:
[16:21:49.165]    - args: function (..., envir = parent.frame())
[16:21:49.165]    - tweaked: FALSE
[16:21:49.165]    - call: future::plan("sequential")
[16:21:49.179] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[16:21:49.373] plan(): Setting new future strategy stack:
[16:21:49.373] List of future strategies:
[16:21:49.373] 1. sequential:
[16:21:49.373]    - args: function (..., envir = parent.frame())
[16:21:49.373]    - tweaked: FALSE
[16:21:49.373]    - call: plan(strategy)
[16:21:49.385] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[16:21:49.386] resolve() on list ...
[16:21:49.386]  recursive: 0
[16:21:49.386]  length: 2
[16:21:49.386]  elements: ‘a’, ‘b’
[16:21:49.386]  length: 1 (resolved future 1)
[16:21:49.386]  length: 0 (resolved future 2)
[16:21:49.386] resolve() on list ... DONE
[16:21:49.387] getGlobalsAndPackages() ...
[16:21:49.387] Searching for globals...
[16:21:49.390] 
[16:21:49.390] Searching for globals ... DONE
[16:21:49.390] - globals: [0] <none>
[16:21:49.390] getGlobalsAndPackages() ... DONE
[16:21:49.391] run() for ‘Future’ ...
[16:21:49.391] - state: ‘created’
[16:21:49.391] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.391] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.392]   - Field: ‘label’
[16:21:49.392]   - Field: ‘local’
[16:21:49.392]   - Field: ‘owner’
[16:21:49.392]   - Field: ‘envir’
[16:21:49.392]   - Field: ‘packages’
[16:21:49.392]   - Field: ‘gc’
[16:21:49.392]   - Field: ‘conditions’
[16:21:49.392]   - Field: ‘expr’
[16:21:49.392]   - Field: ‘uuid’
[16:21:49.392]   - Field: ‘seed’
[16:21:49.393]   - Field: ‘version’
[16:21:49.393]   - Field: ‘result’
[16:21:49.393]   - Field: ‘asynchronous’
[16:21:49.393]   - Field: ‘calls’
[16:21:49.393]   - Field: ‘globals’
[16:21:49.393]   - Field: ‘stdout’
[16:21:49.393]   - Field: ‘earlySignal’
[16:21:49.393]   - Field: ‘lazy’
[16:21:49.393]   - Field: ‘state’
[16:21:49.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.393] - Launch lazy future ...
[16:21:49.394] Packages needed by the future expression (n = 0): <none>
[16:21:49.394] Packages needed by future strategies (n = 0): <none>
[16:21:49.395] {
[16:21:49.395]     {
[16:21:49.395]         {
[16:21:49.395]             ...future.startTime <- base::Sys.time()
[16:21:49.395]             {
[16:21:49.395]                 {
[16:21:49.395]                   {
[16:21:49.395]                     base::local({
[16:21:49.395]                       has_future <- base::requireNamespace("future", 
[16:21:49.395]                         quietly = TRUE)
[16:21:49.395]                       if (has_future) {
[16:21:49.395]                         ns <- base::getNamespace("future")
[16:21:49.395]                         version <- ns[[".package"]][["version"]]
[16:21:49.395]                         if (is.null(version)) 
[16:21:49.395]                           version <- utils::packageVersion("future")
[16:21:49.395]                       }
[16:21:49.395]                       else {
[16:21:49.395]                         version <- NULL
[16:21:49.395]                       }
[16:21:49.395]                       if (!has_future || version < "1.8.0") {
[16:21:49.395]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.395]                           "", base::R.version$version.string), 
[16:21:49.395]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.395]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.395]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.395]                             "release", "version")], collapse = " "), 
[16:21:49.395]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.395]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.395]                           info)
[16:21:49.395]                         info <- base::paste(info, collapse = "; ")
[16:21:49.395]                         if (!has_future) {
[16:21:49.395]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.395]                             info)
[16:21:49.395]                         }
[16:21:49.395]                         else {
[16:21:49.395]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.395]                             info, version)
[16:21:49.395]                         }
[16:21:49.395]                         base::stop(msg)
[16:21:49.395]                       }
[16:21:49.395]                     })
[16:21:49.395]                   }
[16:21:49.395]                   ...future.strategy.old <- future::plan("list")
[16:21:49.395]                   options(future.plan = NULL)
[16:21:49.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.395]                 }
[16:21:49.395]                 ...future.workdir <- getwd()
[16:21:49.395]             }
[16:21:49.395]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.395]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.395]         }
[16:21:49.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.395]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.395]             base::names(...future.oldOptions))
[16:21:49.395]     }
[16:21:49.395]     if (FALSE) {
[16:21:49.395]     }
[16:21:49.395]     else {
[16:21:49.395]         if (TRUE) {
[16:21:49.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.395]                 open = "w")
[16:21:49.395]         }
[16:21:49.395]         else {
[16:21:49.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.395]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.395]         }
[16:21:49.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.395]             base::sink(type = "output", split = FALSE)
[16:21:49.395]             base::close(...future.stdout)
[16:21:49.395]         }, add = TRUE)
[16:21:49.395]     }
[16:21:49.395]     ...future.frame <- base::sys.nframe()
[16:21:49.395]     ...future.conditions <- base::list()
[16:21:49.395]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.395]     if (FALSE) {
[16:21:49.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.395]     }
[16:21:49.395]     ...future.result <- base::tryCatch({
[16:21:49.395]         base::withCallingHandlers({
[16:21:49.395]             ...future.value <- base::withVisible(base::local(1))
[16:21:49.395]             future::FutureResult(value = ...future.value$value, 
[16:21:49.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.395]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.395]                     ...future.globalenv.names))
[16:21:49.395]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.395]         }, condition = base::local({
[16:21:49.395]             c <- base::c
[16:21:49.395]             inherits <- base::inherits
[16:21:49.395]             invokeRestart <- base::invokeRestart
[16:21:49.395]             length <- base::length
[16:21:49.395]             list <- base::list
[16:21:49.395]             seq.int <- base::seq.int
[16:21:49.395]             signalCondition <- base::signalCondition
[16:21:49.395]             sys.calls <- base::sys.calls
[16:21:49.395]             `[[` <- base::`[[`
[16:21:49.395]             `+` <- base::`+`
[16:21:49.395]             `<<-` <- base::`<<-`
[16:21:49.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.395]                   3L)]
[16:21:49.395]             }
[16:21:49.395]             function(cond) {
[16:21:49.395]                 is_error <- inherits(cond, "error")
[16:21:49.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.395]                   NULL)
[16:21:49.395]                 if (is_error) {
[16:21:49.395]                   sessionInformation <- function() {
[16:21:49.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.395]                       search = base::search(), system = base::Sys.info())
[16:21:49.395]                   }
[16:21:49.395]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.395]                     cond$call), session = sessionInformation(), 
[16:21:49.395]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.395]                   signalCondition(cond)
[16:21:49.395]                 }
[16:21:49.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.395]                 "immediateCondition"))) {
[16:21:49.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.395]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.395]                   if (TRUE && !signal) {
[16:21:49.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.395]                     {
[16:21:49.395]                       inherits <- base::inherits
[16:21:49.395]                       invokeRestart <- base::invokeRestart
[16:21:49.395]                       is.null <- base::is.null
[16:21:49.395]                       muffled <- FALSE
[16:21:49.395]                       if (inherits(cond, "message")) {
[16:21:49.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.395]                         if (muffled) 
[16:21:49.395]                           invokeRestart("muffleMessage")
[16:21:49.395]                       }
[16:21:49.395]                       else if (inherits(cond, "warning")) {
[16:21:49.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.395]                         if (muffled) 
[16:21:49.395]                           invokeRestart("muffleWarning")
[16:21:49.395]                       }
[16:21:49.395]                       else if (inherits(cond, "condition")) {
[16:21:49.395]                         if (!is.null(pattern)) {
[16:21:49.395]                           computeRestarts <- base::computeRestarts
[16:21:49.395]                           grepl <- base::grepl
[16:21:49.395]                           restarts <- computeRestarts(cond)
[16:21:49.395]                           for (restart in restarts) {
[16:21:49.395]                             name <- restart$name
[16:21:49.395]                             if (is.null(name)) 
[16:21:49.395]                               next
[16:21:49.395]                             if (!grepl(pattern, name)) 
[16:21:49.395]                               next
[16:21:49.395]                             invokeRestart(restart)
[16:21:49.395]                             muffled <- TRUE
[16:21:49.395]                             break
[16:21:49.395]                           }
[16:21:49.395]                         }
[16:21:49.395]                       }
[16:21:49.395]                       invisible(muffled)
[16:21:49.395]                     }
[16:21:49.395]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.395]                   }
[16:21:49.395]                 }
[16:21:49.395]                 else {
[16:21:49.395]                   if (TRUE) {
[16:21:49.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.395]                     {
[16:21:49.395]                       inherits <- base::inherits
[16:21:49.395]                       invokeRestart <- base::invokeRestart
[16:21:49.395]                       is.null <- base::is.null
[16:21:49.395]                       muffled <- FALSE
[16:21:49.395]                       if (inherits(cond, "message")) {
[16:21:49.395]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.395]                         if (muffled) 
[16:21:49.395]                           invokeRestart("muffleMessage")
[16:21:49.395]                       }
[16:21:49.395]                       else if (inherits(cond, "warning")) {
[16:21:49.395]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.395]                         if (muffled) 
[16:21:49.395]                           invokeRestart("muffleWarning")
[16:21:49.395]                       }
[16:21:49.395]                       else if (inherits(cond, "condition")) {
[16:21:49.395]                         if (!is.null(pattern)) {
[16:21:49.395]                           computeRestarts <- base::computeRestarts
[16:21:49.395]                           grepl <- base::grepl
[16:21:49.395]                           restarts <- computeRestarts(cond)
[16:21:49.395]                           for (restart in restarts) {
[16:21:49.395]                             name <- restart$name
[16:21:49.395]                             if (is.null(name)) 
[16:21:49.395]                               next
[16:21:49.395]                             if (!grepl(pattern, name)) 
[16:21:49.395]                               next
[16:21:49.395]                             invokeRestart(restart)
[16:21:49.395]                             muffled <- TRUE
[16:21:49.395]                             break
[16:21:49.395]                           }
[16:21:49.395]                         }
[16:21:49.395]                       }
[16:21:49.395]                       invisible(muffled)
[16:21:49.395]                     }
[16:21:49.395]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.395]                   }
[16:21:49.395]                 }
[16:21:49.395]             }
[16:21:49.395]         }))
[16:21:49.395]     }, error = function(ex) {
[16:21:49.395]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.395]                 ...future.rng), started = ...future.startTime, 
[16:21:49.395]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.395]             version = "1.8"), class = "FutureResult")
[16:21:49.395]     }, finally = {
[16:21:49.395]         if (!identical(...future.workdir, getwd())) 
[16:21:49.395]             setwd(...future.workdir)
[16:21:49.395]         {
[16:21:49.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.395]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.395]             }
[16:21:49.395]             base::options(...future.oldOptions)
[16:21:49.395]             if (.Platform$OS.type == "windows") {
[16:21:49.395]                 old_names <- names(...future.oldEnvVars)
[16:21:49.395]                 envs <- base::Sys.getenv()
[16:21:49.395]                 names <- names(envs)
[16:21:49.395]                 common <- intersect(names, old_names)
[16:21:49.395]                 added <- setdiff(names, old_names)
[16:21:49.395]                 removed <- setdiff(old_names, names)
[16:21:49.395]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.395]                   envs[common]]
[16:21:49.395]                 NAMES <- toupper(changed)
[16:21:49.395]                 args <- list()
[16:21:49.395]                 for (kk in seq_along(NAMES)) {
[16:21:49.395]                   name <- changed[[kk]]
[16:21:49.395]                   NAME <- NAMES[[kk]]
[16:21:49.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.395]                     next
[16:21:49.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.395]                 }
[16:21:49.395]                 NAMES <- toupper(added)
[16:21:49.395]                 for (kk in seq_along(NAMES)) {
[16:21:49.395]                   name <- added[[kk]]
[16:21:49.395]                   NAME <- NAMES[[kk]]
[16:21:49.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.395]                     next
[16:21:49.395]                   args[[name]] <- ""
[16:21:49.395]                 }
[16:21:49.395]                 NAMES <- toupper(removed)
[16:21:49.395]                 for (kk in seq_along(NAMES)) {
[16:21:49.395]                   name <- removed[[kk]]
[16:21:49.395]                   NAME <- NAMES[[kk]]
[16:21:49.395]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.395]                     next
[16:21:49.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.395]                 }
[16:21:49.395]                 if (length(args) > 0) 
[16:21:49.395]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.395]             }
[16:21:49.395]             else {
[16:21:49.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.395]             }
[16:21:49.395]             {
[16:21:49.395]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.395]                   0L) {
[16:21:49.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.395]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.395]                   base::options(opts)
[16:21:49.395]                 }
[16:21:49.395]                 {
[16:21:49.395]                   {
[16:21:49.395]                     NULL
[16:21:49.395]                     RNGkind("Mersenne-Twister")
[16:21:49.395]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.395]                       inherits = FALSE)
[16:21:49.395]                   }
[16:21:49.395]                   options(future.plan = NULL)
[16:21:49.395]                   if (is.na(NA_character_)) 
[16:21:49.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.395]                     .init = FALSE)
[16:21:49.395]                 }
[16:21:49.395]             }
[16:21:49.395]         }
[16:21:49.395]     })
[16:21:49.395]     if (TRUE) {
[16:21:49.395]         base::sink(type = "output", split = FALSE)
[16:21:49.395]         if (TRUE) {
[16:21:49.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.395]         }
[16:21:49.395]         else {
[16:21:49.395]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.395]         }
[16:21:49.395]         base::close(...future.stdout)
[16:21:49.395]         ...future.stdout <- NULL
[16:21:49.395]     }
[16:21:49.395]     ...future.result$conditions <- ...future.conditions
[16:21:49.395]     ...future.result$finished <- base::Sys.time()
[16:21:49.395]     ...future.result
[16:21:49.395] }
[16:21:49.397] plan(): Setting new future strategy stack:
[16:21:49.397] List of future strategies:
[16:21:49.397] 1. sequential:
[16:21:49.397]    - args: function (..., envir = parent.frame())
[16:21:49.397]    - tweaked: FALSE
[16:21:49.397]    - call: NULL
[16:21:49.398] plan(): nbrOfWorkers() = 1
[16:21:49.399] plan(): Setting new future strategy stack:
[16:21:49.399] List of future strategies:
[16:21:49.399] 1. sequential:
[16:21:49.399]    - args: function (..., envir = parent.frame())
[16:21:49.399]    - tweaked: FALSE
[16:21:49.399]    - call: plan(strategy)
[16:21:49.399] plan(): nbrOfWorkers() = 1
[16:21:49.400] SequentialFuture started (and completed)
[16:21:49.400] - Launch lazy future ... done
[16:21:49.400] run() for ‘SequentialFuture’ ... done
[16:21:49.400] getGlobalsAndPackages() ...
[16:21:49.400] Searching for globals...
[16:21:49.401] 
[16:21:49.401] Searching for globals ... DONE
[16:21:49.401] - globals: [0] <none>
[16:21:49.401] getGlobalsAndPackages() ... DONE
[16:21:49.401] run() for ‘Future’ ...
[16:21:49.401] - state: ‘created’
[16:21:49.402] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.402]   - Field: ‘label’
[16:21:49.402]   - Field: ‘local’
[16:21:49.402]   - Field: ‘owner’
[16:21:49.402]   - Field: ‘envir’
[16:21:49.402]   - Field: ‘packages’
[16:21:49.402]   - Field: ‘gc’
[16:21:49.403]   - Field: ‘conditions’
[16:21:49.403]   - Field: ‘expr’
[16:21:49.403]   - Field: ‘uuid’
[16:21:49.403]   - Field: ‘seed’
[16:21:49.403]   - Field: ‘version’
[16:21:49.403]   - Field: ‘result’
[16:21:49.403]   - Field: ‘asynchronous’
[16:21:49.403]   - Field: ‘calls’
[16:21:49.403]   - Field: ‘globals’
[16:21:49.403]   - Field: ‘stdout’
[16:21:49.403]   - Field: ‘earlySignal’
[16:21:49.404]   - Field: ‘lazy’
[16:21:49.404]   - Field: ‘state’
[16:21:49.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.404] - Launch lazy future ...
[16:21:49.404] Packages needed by the future expression (n = 0): <none>
[16:21:49.404] Packages needed by future strategies (n = 0): <none>
[16:21:49.405] {
[16:21:49.405]     {
[16:21:49.405]         {
[16:21:49.405]             ...future.startTime <- base::Sys.time()
[16:21:49.405]             {
[16:21:49.405]                 {
[16:21:49.405]                   {
[16:21:49.405]                     base::local({
[16:21:49.405]                       has_future <- base::requireNamespace("future", 
[16:21:49.405]                         quietly = TRUE)
[16:21:49.405]                       if (has_future) {
[16:21:49.405]                         ns <- base::getNamespace("future")
[16:21:49.405]                         version <- ns[[".package"]][["version"]]
[16:21:49.405]                         if (is.null(version)) 
[16:21:49.405]                           version <- utils::packageVersion("future")
[16:21:49.405]                       }
[16:21:49.405]                       else {
[16:21:49.405]                         version <- NULL
[16:21:49.405]                       }
[16:21:49.405]                       if (!has_future || version < "1.8.0") {
[16:21:49.405]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.405]                           "", base::R.version$version.string), 
[16:21:49.405]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.405]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.405]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.405]                             "release", "version")], collapse = " "), 
[16:21:49.405]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.405]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.405]                           info)
[16:21:49.405]                         info <- base::paste(info, collapse = "; ")
[16:21:49.405]                         if (!has_future) {
[16:21:49.405]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.405]                             info)
[16:21:49.405]                         }
[16:21:49.405]                         else {
[16:21:49.405]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.405]                             info, version)
[16:21:49.405]                         }
[16:21:49.405]                         base::stop(msg)
[16:21:49.405]                       }
[16:21:49.405]                     })
[16:21:49.405]                   }
[16:21:49.405]                   ...future.strategy.old <- future::plan("list")
[16:21:49.405]                   options(future.plan = NULL)
[16:21:49.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.405]                 }
[16:21:49.405]                 ...future.workdir <- getwd()
[16:21:49.405]             }
[16:21:49.405]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.405]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.405]         }
[16:21:49.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.405]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.405]             base::names(...future.oldOptions))
[16:21:49.405]     }
[16:21:49.405]     if (FALSE) {
[16:21:49.405]     }
[16:21:49.405]     else {
[16:21:49.405]         if (TRUE) {
[16:21:49.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.405]                 open = "w")
[16:21:49.405]         }
[16:21:49.405]         else {
[16:21:49.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.405]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.405]         }
[16:21:49.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.405]             base::sink(type = "output", split = FALSE)
[16:21:49.405]             base::close(...future.stdout)
[16:21:49.405]         }, add = TRUE)
[16:21:49.405]     }
[16:21:49.405]     ...future.frame <- base::sys.nframe()
[16:21:49.405]     ...future.conditions <- base::list()
[16:21:49.405]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.405]     if (FALSE) {
[16:21:49.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.405]     }
[16:21:49.405]     ...future.result <- base::tryCatch({
[16:21:49.405]         base::withCallingHandlers({
[16:21:49.405]             ...future.value <- base::withVisible(base::local(2))
[16:21:49.405]             future::FutureResult(value = ...future.value$value, 
[16:21:49.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.405]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.405]                     ...future.globalenv.names))
[16:21:49.405]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.405]         }, condition = base::local({
[16:21:49.405]             c <- base::c
[16:21:49.405]             inherits <- base::inherits
[16:21:49.405]             invokeRestart <- base::invokeRestart
[16:21:49.405]             length <- base::length
[16:21:49.405]             list <- base::list
[16:21:49.405]             seq.int <- base::seq.int
[16:21:49.405]             signalCondition <- base::signalCondition
[16:21:49.405]             sys.calls <- base::sys.calls
[16:21:49.405]             `[[` <- base::`[[`
[16:21:49.405]             `+` <- base::`+`
[16:21:49.405]             `<<-` <- base::`<<-`
[16:21:49.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.405]                   3L)]
[16:21:49.405]             }
[16:21:49.405]             function(cond) {
[16:21:49.405]                 is_error <- inherits(cond, "error")
[16:21:49.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.405]                   NULL)
[16:21:49.405]                 if (is_error) {
[16:21:49.405]                   sessionInformation <- function() {
[16:21:49.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.405]                       search = base::search(), system = base::Sys.info())
[16:21:49.405]                   }
[16:21:49.405]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.405]                     cond$call), session = sessionInformation(), 
[16:21:49.405]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.405]                   signalCondition(cond)
[16:21:49.405]                 }
[16:21:49.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.405]                 "immediateCondition"))) {
[16:21:49.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.405]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.405]                   if (TRUE && !signal) {
[16:21:49.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.405]                     {
[16:21:49.405]                       inherits <- base::inherits
[16:21:49.405]                       invokeRestart <- base::invokeRestart
[16:21:49.405]                       is.null <- base::is.null
[16:21:49.405]                       muffled <- FALSE
[16:21:49.405]                       if (inherits(cond, "message")) {
[16:21:49.405]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.405]                         if (muffled) 
[16:21:49.405]                           invokeRestart("muffleMessage")
[16:21:49.405]                       }
[16:21:49.405]                       else if (inherits(cond, "warning")) {
[16:21:49.405]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.405]                         if (muffled) 
[16:21:49.405]                           invokeRestart("muffleWarning")
[16:21:49.405]                       }
[16:21:49.405]                       else if (inherits(cond, "condition")) {
[16:21:49.405]                         if (!is.null(pattern)) {
[16:21:49.405]                           computeRestarts <- base::computeRestarts
[16:21:49.405]                           grepl <- base::grepl
[16:21:49.405]                           restarts <- computeRestarts(cond)
[16:21:49.405]                           for (restart in restarts) {
[16:21:49.405]                             name <- restart$name
[16:21:49.405]                             if (is.null(name)) 
[16:21:49.405]                               next
[16:21:49.405]                             if (!grepl(pattern, name)) 
[16:21:49.405]                               next
[16:21:49.405]                             invokeRestart(restart)
[16:21:49.405]                             muffled <- TRUE
[16:21:49.405]                             break
[16:21:49.405]                           }
[16:21:49.405]                         }
[16:21:49.405]                       }
[16:21:49.405]                       invisible(muffled)
[16:21:49.405]                     }
[16:21:49.405]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.405]                   }
[16:21:49.405]                 }
[16:21:49.405]                 else {
[16:21:49.405]                   if (TRUE) {
[16:21:49.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.405]                     {
[16:21:49.405]                       inherits <- base::inherits
[16:21:49.405]                       invokeRestart <- base::invokeRestart
[16:21:49.405]                       is.null <- base::is.null
[16:21:49.405]                       muffled <- FALSE
[16:21:49.405]                       if (inherits(cond, "message")) {
[16:21:49.405]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.405]                         if (muffled) 
[16:21:49.405]                           invokeRestart("muffleMessage")
[16:21:49.405]                       }
[16:21:49.405]                       else if (inherits(cond, "warning")) {
[16:21:49.405]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.405]                         if (muffled) 
[16:21:49.405]                           invokeRestart("muffleWarning")
[16:21:49.405]                       }
[16:21:49.405]                       else if (inherits(cond, "condition")) {
[16:21:49.405]                         if (!is.null(pattern)) {
[16:21:49.405]                           computeRestarts <- base::computeRestarts
[16:21:49.405]                           grepl <- base::grepl
[16:21:49.405]                           restarts <- computeRestarts(cond)
[16:21:49.405]                           for (restart in restarts) {
[16:21:49.405]                             name <- restart$name
[16:21:49.405]                             if (is.null(name)) 
[16:21:49.405]                               next
[16:21:49.405]                             if (!grepl(pattern, name)) 
[16:21:49.405]                               next
[16:21:49.405]                             invokeRestart(restart)
[16:21:49.405]                             muffled <- TRUE
[16:21:49.405]                             break
[16:21:49.405]                           }
[16:21:49.405]                         }
[16:21:49.405]                       }
[16:21:49.405]                       invisible(muffled)
[16:21:49.405]                     }
[16:21:49.405]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.405]                   }
[16:21:49.405]                 }
[16:21:49.405]             }
[16:21:49.405]         }))
[16:21:49.405]     }, error = function(ex) {
[16:21:49.405]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.405]                 ...future.rng), started = ...future.startTime, 
[16:21:49.405]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.405]             version = "1.8"), class = "FutureResult")
[16:21:49.405]     }, finally = {
[16:21:49.405]         if (!identical(...future.workdir, getwd())) 
[16:21:49.405]             setwd(...future.workdir)
[16:21:49.405]         {
[16:21:49.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.405]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.405]             }
[16:21:49.405]             base::options(...future.oldOptions)
[16:21:49.405]             if (.Platform$OS.type == "windows") {
[16:21:49.405]                 old_names <- names(...future.oldEnvVars)
[16:21:49.405]                 envs <- base::Sys.getenv()
[16:21:49.405]                 names <- names(envs)
[16:21:49.405]                 common <- intersect(names, old_names)
[16:21:49.405]                 added <- setdiff(names, old_names)
[16:21:49.405]                 removed <- setdiff(old_names, names)
[16:21:49.405]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.405]                   envs[common]]
[16:21:49.405]                 NAMES <- toupper(changed)
[16:21:49.405]                 args <- list()
[16:21:49.405]                 for (kk in seq_along(NAMES)) {
[16:21:49.405]                   name <- changed[[kk]]
[16:21:49.405]                   NAME <- NAMES[[kk]]
[16:21:49.405]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.405]                     next
[16:21:49.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.405]                 }
[16:21:49.405]                 NAMES <- toupper(added)
[16:21:49.405]                 for (kk in seq_along(NAMES)) {
[16:21:49.405]                   name <- added[[kk]]
[16:21:49.405]                   NAME <- NAMES[[kk]]
[16:21:49.405]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.405]                     next
[16:21:49.405]                   args[[name]] <- ""
[16:21:49.405]                 }
[16:21:49.405]                 NAMES <- toupper(removed)
[16:21:49.405]                 for (kk in seq_along(NAMES)) {
[16:21:49.405]                   name <- removed[[kk]]
[16:21:49.405]                   NAME <- NAMES[[kk]]
[16:21:49.405]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.405]                     next
[16:21:49.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.405]                 }
[16:21:49.405]                 if (length(args) > 0) 
[16:21:49.405]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.405]             }
[16:21:49.405]             else {
[16:21:49.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.405]             }
[16:21:49.405]             {
[16:21:49.405]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.405]                   0L) {
[16:21:49.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.405]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.405]                   base::options(opts)
[16:21:49.405]                 }
[16:21:49.405]                 {
[16:21:49.405]                   {
[16:21:49.405]                     NULL
[16:21:49.405]                     RNGkind("Mersenne-Twister")
[16:21:49.405]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.405]                       inherits = FALSE)
[16:21:49.405]                   }
[16:21:49.405]                   options(future.plan = NULL)
[16:21:49.405]                   if (is.na(NA_character_)) 
[16:21:49.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.405]                     .init = FALSE)
[16:21:49.405]                 }
[16:21:49.405]             }
[16:21:49.405]         }
[16:21:49.405]     })
[16:21:49.405]     if (TRUE) {
[16:21:49.405]         base::sink(type = "output", split = FALSE)
[16:21:49.405]         if (TRUE) {
[16:21:49.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.405]         }
[16:21:49.405]         else {
[16:21:49.405]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.405]         }
[16:21:49.405]         base::close(...future.stdout)
[16:21:49.405]         ...future.stdout <- NULL
[16:21:49.405]     }
[16:21:49.405]     ...future.result$conditions <- ...future.conditions
[16:21:49.405]     ...future.result$finished <- base::Sys.time()
[16:21:49.405]     ...future.result
[16:21:49.405] }
[16:21:49.406] plan(): Setting new future strategy stack:
[16:21:49.406] List of future strategies:
[16:21:49.406] 1. sequential:
[16:21:49.406]    - args: function (..., envir = parent.frame())
[16:21:49.406]    - tweaked: FALSE
[16:21:49.406]    - call: NULL
[16:21:49.407] plan(): nbrOfWorkers() = 1
[16:21:49.408] plan(): Setting new future strategy stack:
[16:21:49.408] List of future strategies:
[16:21:49.408] 1. sequential:
[16:21:49.408]    - args: function (..., envir = parent.frame())
[16:21:49.408]    - tweaked: FALSE
[16:21:49.408]    - call: plan(strategy)
[16:21:49.408] plan(): nbrOfWorkers() = 1
[16:21:49.408] SequentialFuture started (and completed)
[16:21:49.408] - Launch lazy future ... done
[16:21:49.408] run() for ‘SequentialFuture’ ... done
[16:21:49.409] resolve() on list ...
[16:21:49.409]  recursive: 0
[16:21:49.409]  length: 3
[16:21:49.409]  elements: ‘a’, ‘b’, ‘’
[16:21:49.409] resolved() for ‘SequentialFuture’ ...
[16:21:49.409] - state: ‘finished’
[16:21:49.409] - run: TRUE
[16:21:49.409] - result: ‘FutureResult’
[16:21:49.410] resolved() for ‘SequentialFuture’ ... done
[16:21:49.410] Future #1
[16:21:49.410]  length: 2 (resolved future 1)
[16:21:49.410] resolved() for ‘SequentialFuture’ ...
[16:21:49.410] - state: ‘finished’
[16:21:49.410] - run: TRUE
[16:21:49.410] - result: ‘FutureResult’
[16:21:49.410] resolved() for ‘SequentialFuture’ ... done
[16:21:49.411] Future #2
[16:21:49.411]  length: 1 (resolved future 2)
[16:21:49.411]  length: 0 (resolved future 3)
[16:21:49.411] resolve() on list ... DONE
[16:21:49.411] resolved() for ‘SequentialFuture’ ...
[16:21:49.411] - state: ‘finished’
[16:21:49.411] - run: TRUE
[16:21:49.411] - result: ‘FutureResult’
[16:21:49.411] resolved() for ‘SequentialFuture’ ... done
[16:21:49.411] resolved() for ‘SequentialFuture’ ...
[16:21:49.412] - state: ‘finished’
[16:21:49.412] - run: TRUE
[16:21:49.412] - result: ‘FutureResult’
[16:21:49.412] resolved() for ‘SequentialFuture’ ... done
[16:21:49.412] getGlobalsAndPackages() ...
[16:21:49.414] Searching for globals...
[16:21:49.415] 
[16:21:49.415] Searching for globals ... DONE
[16:21:49.415] - globals: [0] <none>
[16:21:49.415] getGlobalsAndPackages() ... DONE
[16:21:49.415] getGlobalsAndPackages() ...
[16:21:49.415] Searching for globals...
[16:21:49.415] 
[16:21:49.416] Searching for globals ... DONE
[16:21:49.416] - globals: [0] <none>
[16:21:49.416] getGlobalsAndPackages() ... DONE
[16:21:49.416] run() for ‘Future’ ...
[16:21:49.416] - state: ‘created’
[16:21:49.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.417]   - Field: ‘label’
[16:21:49.417]   - Field: ‘local’
[16:21:49.417]   - Field: ‘owner’
[16:21:49.417]   - Field: ‘envir’
[16:21:49.417]   - Field: ‘packages’
[16:21:49.417]   - Field: ‘gc’
[16:21:49.417]   - Field: ‘conditions’
[16:21:49.417]   - Field: ‘expr’
[16:21:49.417]   - Field: ‘uuid’
[16:21:49.418]   - Field: ‘seed’
[16:21:49.418]   - Field: ‘version’
[16:21:49.418]   - Field: ‘result’
[16:21:49.418]   - Field: ‘asynchronous’
[16:21:49.418]   - Field: ‘calls’
[16:21:49.418]   - Field: ‘globals’
[16:21:49.418]   - Field: ‘stdout’
[16:21:49.418]   - Field: ‘earlySignal’
[16:21:49.418]   - Field: ‘lazy’
[16:21:49.418]   - Field: ‘state’
[16:21:49.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.419] - Launch lazy future ...
[16:21:49.419] Packages needed by the future expression (n = 0): <none>
[16:21:49.419] Packages needed by future strategies (n = 0): <none>
[16:21:49.419] {
[16:21:49.419]     {
[16:21:49.419]         {
[16:21:49.419]             ...future.startTime <- base::Sys.time()
[16:21:49.419]             {
[16:21:49.419]                 {
[16:21:49.419]                   {
[16:21:49.419]                     base::local({
[16:21:49.419]                       has_future <- base::requireNamespace("future", 
[16:21:49.419]                         quietly = TRUE)
[16:21:49.419]                       if (has_future) {
[16:21:49.419]                         ns <- base::getNamespace("future")
[16:21:49.419]                         version <- ns[[".package"]][["version"]]
[16:21:49.419]                         if (is.null(version)) 
[16:21:49.419]                           version <- utils::packageVersion("future")
[16:21:49.419]                       }
[16:21:49.419]                       else {
[16:21:49.419]                         version <- NULL
[16:21:49.419]                       }
[16:21:49.419]                       if (!has_future || version < "1.8.0") {
[16:21:49.419]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.419]                           "", base::R.version$version.string), 
[16:21:49.419]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.419]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.419]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.419]                             "release", "version")], collapse = " "), 
[16:21:49.419]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.419]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.419]                           info)
[16:21:49.419]                         info <- base::paste(info, collapse = "; ")
[16:21:49.419]                         if (!has_future) {
[16:21:49.419]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.419]                             info)
[16:21:49.419]                         }
[16:21:49.419]                         else {
[16:21:49.419]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.419]                             info, version)
[16:21:49.419]                         }
[16:21:49.419]                         base::stop(msg)
[16:21:49.419]                       }
[16:21:49.419]                     })
[16:21:49.419]                   }
[16:21:49.419]                   ...future.strategy.old <- future::plan("list")
[16:21:49.419]                   options(future.plan = NULL)
[16:21:49.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.419]                 }
[16:21:49.419]                 ...future.workdir <- getwd()
[16:21:49.419]             }
[16:21:49.419]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.419]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.419]         }
[16:21:49.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.419]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.419]             base::names(...future.oldOptions))
[16:21:49.419]     }
[16:21:49.419]     if (FALSE) {
[16:21:49.419]     }
[16:21:49.419]     else {
[16:21:49.419]         if (TRUE) {
[16:21:49.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.419]                 open = "w")
[16:21:49.419]         }
[16:21:49.419]         else {
[16:21:49.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.419]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.419]         }
[16:21:49.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.419]             base::sink(type = "output", split = FALSE)
[16:21:49.419]             base::close(...future.stdout)
[16:21:49.419]         }, add = TRUE)
[16:21:49.419]     }
[16:21:49.419]     ...future.frame <- base::sys.nframe()
[16:21:49.419]     ...future.conditions <- base::list()
[16:21:49.419]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.419]     if (FALSE) {
[16:21:49.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.419]     }
[16:21:49.419]     ...future.result <- base::tryCatch({
[16:21:49.419]         base::withCallingHandlers({
[16:21:49.419]             ...future.value <- base::withVisible(base::local(2))
[16:21:49.419]             future::FutureResult(value = ...future.value$value, 
[16:21:49.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.419]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.419]                     ...future.globalenv.names))
[16:21:49.419]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.419]         }, condition = base::local({
[16:21:49.419]             c <- base::c
[16:21:49.419]             inherits <- base::inherits
[16:21:49.419]             invokeRestart <- base::invokeRestart
[16:21:49.419]             length <- base::length
[16:21:49.419]             list <- base::list
[16:21:49.419]             seq.int <- base::seq.int
[16:21:49.419]             signalCondition <- base::signalCondition
[16:21:49.419]             sys.calls <- base::sys.calls
[16:21:49.419]             `[[` <- base::`[[`
[16:21:49.419]             `+` <- base::`+`
[16:21:49.419]             `<<-` <- base::`<<-`
[16:21:49.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.419]                   3L)]
[16:21:49.419]             }
[16:21:49.419]             function(cond) {
[16:21:49.419]                 is_error <- inherits(cond, "error")
[16:21:49.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.419]                   NULL)
[16:21:49.419]                 if (is_error) {
[16:21:49.419]                   sessionInformation <- function() {
[16:21:49.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.419]                       search = base::search(), system = base::Sys.info())
[16:21:49.419]                   }
[16:21:49.419]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.419]                     cond$call), session = sessionInformation(), 
[16:21:49.419]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.419]                   signalCondition(cond)
[16:21:49.419]                 }
[16:21:49.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.419]                 "immediateCondition"))) {
[16:21:49.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.419]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.419]                   if (TRUE && !signal) {
[16:21:49.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.419]                     {
[16:21:49.419]                       inherits <- base::inherits
[16:21:49.419]                       invokeRestart <- base::invokeRestart
[16:21:49.419]                       is.null <- base::is.null
[16:21:49.419]                       muffled <- FALSE
[16:21:49.419]                       if (inherits(cond, "message")) {
[16:21:49.419]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.419]                         if (muffled) 
[16:21:49.419]                           invokeRestart("muffleMessage")
[16:21:49.419]                       }
[16:21:49.419]                       else if (inherits(cond, "warning")) {
[16:21:49.419]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.419]                         if (muffled) 
[16:21:49.419]                           invokeRestart("muffleWarning")
[16:21:49.419]                       }
[16:21:49.419]                       else if (inherits(cond, "condition")) {
[16:21:49.419]                         if (!is.null(pattern)) {
[16:21:49.419]                           computeRestarts <- base::computeRestarts
[16:21:49.419]                           grepl <- base::grepl
[16:21:49.419]                           restarts <- computeRestarts(cond)
[16:21:49.419]                           for (restart in restarts) {
[16:21:49.419]                             name <- restart$name
[16:21:49.419]                             if (is.null(name)) 
[16:21:49.419]                               next
[16:21:49.419]                             if (!grepl(pattern, name)) 
[16:21:49.419]                               next
[16:21:49.419]                             invokeRestart(restart)
[16:21:49.419]                             muffled <- TRUE
[16:21:49.419]                             break
[16:21:49.419]                           }
[16:21:49.419]                         }
[16:21:49.419]                       }
[16:21:49.419]                       invisible(muffled)
[16:21:49.419]                     }
[16:21:49.419]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.419]                   }
[16:21:49.419]                 }
[16:21:49.419]                 else {
[16:21:49.419]                   if (TRUE) {
[16:21:49.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.419]                     {
[16:21:49.419]                       inherits <- base::inherits
[16:21:49.419]                       invokeRestart <- base::invokeRestart
[16:21:49.419]                       is.null <- base::is.null
[16:21:49.419]                       muffled <- FALSE
[16:21:49.419]                       if (inherits(cond, "message")) {
[16:21:49.419]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.419]                         if (muffled) 
[16:21:49.419]                           invokeRestart("muffleMessage")
[16:21:49.419]                       }
[16:21:49.419]                       else if (inherits(cond, "warning")) {
[16:21:49.419]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.419]                         if (muffled) 
[16:21:49.419]                           invokeRestart("muffleWarning")
[16:21:49.419]                       }
[16:21:49.419]                       else if (inherits(cond, "condition")) {
[16:21:49.419]                         if (!is.null(pattern)) {
[16:21:49.419]                           computeRestarts <- base::computeRestarts
[16:21:49.419]                           grepl <- base::grepl
[16:21:49.419]                           restarts <- computeRestarts(cond)
[16:21:49.419]                           for (restart in restarts) {
[16:21:49.419]                             name <- restart$name
[16:21:49.419]                             if (is.null(name)) 
[16:21:49.419]                               next
[16:21:49.419]                             if (!grepl(pattern, name)) 
[16:21:49.419]                               next
[16:21:49.419]                             invokeRestart(restart)
[16:21:49.419]                             muffled <- TRUE
[16:21:49.419]                             break
[16:21:49.419]                           }
[16:21:49.419]                         }
[16:21:49.419]                       }
[16:21:49.419]                       invisible(muffled)
[16:21:49.419]                     }
[16:21:49.419]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.419]                   }
[16:21:49.419]                 }
[16:21:49.419]             }
[16:21:49.419]         }))
[16:21:49.419]     }, error = function(ex) {
[16:21:49.419]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.419]                 ...future.rng), started = ...future.startTime, 
[16:21:49.419]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.419]             version = "1.8"), class = "FutureResult")
[16:21:49.419]     }, finally = {
[16:21:49.419]         if (!identical(...future.workdir, getwd())) 
[16:21:49.419]             setwd(...future.workdir)
[16:21:49.419]         {
[16:21:49.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.419]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.419]             }
[16:21:49.419]             base::options(...future.oldOptions)
[16:21:49.419]             if (.Platform$OS.type == "windows") {
[16:21:49.419]                 old_names <- names(...future.oldEnvVars)
[16:21:49.419]                 envs <- base::Sys.getenv()
[16:21:49.419]                 names <- names(envs)
[16:21:49.419]                 common <- intersect(names, old_names)
[16:21:49.419]                 added <- setdiff(names, old_names)
[16:21:49.419]                 removed <- setdiff(old_names, names)
[16:21:49.419]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.419]                   envs[common]]
[16:21:49.419]                 NAMES <- toupper(changed)
[16:21:49.419]                 args <- list()
[16:21:49.419]                 for (kk in seq_along(NAMES)) {
[16:21:49.419]                   name <- changed[[kk]]
[16:21:49.419]                   NAME <- NAMES[[kk]]
[16:21:49.419]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.419]                     next
[16:21:49.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.419]                 }
[16:21:49.419]                 NAMES <- toupper(added)
[16:21:49.419]                 for (kk in seq_along(NAMES)) {
[16:21:49.419]                   name <- added[[kk]]
[16:21:49.419]                   NAME <- NAMES[[kk]]
[16:21:49.419]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.419]                     next
[16:21:49.419]                   args[[name]] <- ""
[16:21:49.419]                 }
[16:21:49.419]                 NAMES <- toupper(removed)
[16:21:49.419]                 for (kk in seq_along(NAMES)) {
[16:21:49.419]                   name <- removed[[kk]]
[16:21:49.419]                   NAME <- NAMES[[kk]]
[16:21:49.419]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.419]                     next
[16:21:49.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.419]                 }
[16:21:49.419]                 if (length(args) > 0) 
[16:21:49.419]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.419]             }
[16:21:49.419]             else {
[16:21:49.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.419]             }
[16:21:49.419]             {
[16:21:49.419]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.419]                   0L) {
[16:21:49.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.419]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.419]                   base::options(opts)
[16:21:49.419]                 }
[16:21:49.419]                 {
[16:21:49.419]                   {
[16:21:49.419]                     NULL
[16:21:49.419]                     RNGkind("Mersenne-Twister")
[16:21:49.419]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.419]                       inherits = FALSE)
[16:21:49.419]                   }
[16:21:49.419]                   options(future.plan = NULL)
[16:21:49.419]                   if (is.na(NA_character_)) 
[16:21:49.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.419]                     .init = FALSE)
[16:21:49.419]                 }
[16:21:49.419]             }
[16:21:49.419]         }
[16:21:49.419]     })
[16:21:49.419]     if (TRUE) {
[16:21:49.419]         base::sink(type = "output", split = FALSE)
[16:21:49.419]         if (TRUE) {
[16:21:49.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.419]         }
[16:21:49.419]         else {
[16:21:49.419]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.419]         }
[16:21:49.419]         base::close(...future.stdout)
[16:21:49.419]         ...future.stdout <- NULL
[16:21:49.419]     }
[16:21:49.419]     ...future.result$conditions <- ...future.conditions
[16:21:49.419]     ...future.result$finished <- base::Sys.time()
[16:21:49.419]     ...future.result
[16:21:49.419] }
[16:21:49.421] plan(): Setting new future strategy stack:
[16:21:49.421] List of future strategies:
[16:21:49.421] 1. sequential:
[16:21:49.421]    - args: function (..., envir = parent.frame())
[16:21:49.421]    - tweaked: FALSE
[16:21:49.421]    - call: NULL
[16:21:49.421] plan(): nbrOfWorkers() = 1
[16:21:49.422] plan(): Setting new future strategy stack:
[16:21:49.422] List of future strategies:
[16:21:49.422] 1. sequential:
[16:21:49.422]    - args: function (..., envir = parent.frame())
[16:21:49.422]    - tweaked: FALSE
[16:21:49.422]    - call: plan(strategy)
[16:21:49.423] plan(): nbrOfWorkers() = 1
[16:21:49.423] SequentialFuture started (and completed)
[16:21:49.423] - Launch lazy future ... done
[16:21:49.423] run() for ‘SequentialFuture’ ... done
[16:21:49.423] resolve() on list ...
[16:21:49.423]  recursive: 0
[16:21:49.423]  length: 3
[16:21:49.423]  elements: ‘a’, ‘b’, ‘’
[16:21:49.423] run() for ‘Future’ ...
[16:21:49.424] - state: ‘created’
[16:21:49.424] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.424] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.424]   - Field: ‘label’
[16:21:49.424]   - Field: ‘local’
[16:21:49.424]   - Field: ‘owner’
[16:21:49.424]   - Field: ‘envir’
[16:21:49.425]   - Field: ‘packages’
[16:21:49.425]   - Field: ‘gc’
[16:21:49.425]   - Field: ‘conditions’
[16:21:49.425]   - Field: ‘expr’
[16:21:49.425]   - Field: ‘uuid’
[16:21:49.425]   - Field: ‘seed’
[16:21:49.425]   - Field: ‘version’
[16:21:49.425]   - Field: ‘result’
[16:21:49.425]   - Field: ‘asynchronous’
[16:21:49.425]   - Field: ‘calls’
[16:21:49.425]   - Field: ‘globals’
[16:21:49.426]   - Field: ‘stdout’
[16:21:49.426]   - Field: ‘earlySignal’
[16:21:49.426]   - Field: ‘lazy’
[16:21:49.426]   - Field: ‘state’
[16:21:49.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.426] - Launch lazy future ...
[16:21:49.426] Packages needed by the future expression (n = 0): <none>
[16:21:49.426] Packages needed by future strategies (n = 0): <none>
[16:21:49.427] {
[16:21:49.427]     {
[16:21:49.427]         {
[16:21:49.427]             ...future.startTime <- base::Sys.time()
[16:21:49.427]             {
[16:21:49.427]                 {
[16:21:49.427]                   {
[16:21:49.427]                     base::local({
[16:21:49.427]                       has_future <- base::requireNamespace("future", 
[16:21:49.427]                         quietly = TRUE)
[16:21:49.427]                       if (has_future) {
[16:21:49.427]                         ns <- base::getNamespace("future")
[16:21:49.427]                         version <- ns[[".package"]][["version"]]
[16:21:49.427]                         if (is.null(version)) 
[16:21:49.427]                           version <- utils::packageVersion("future")
[16:21:49.427]                       }
[16:21:49.427]                       else {
[16:21:49.427]                         version <- NULL
[16:21:49.427]                       }
[16:21:49.427]                       if (!has_future || version < "1.8.0") {
[16:21:49.427]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.427]                           "", base::R.version$version.string), 
[16:21:49.427]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.427]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.427]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.427]                             "release", "version")], collapse = " "), 
[16:21:49.427]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.427]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.427]                           info)
[16:21:49.427]                         info <- base::paste(info, collapse = "; ")
[16:21:49.427]                         if (!has_future) {
[16:21:49.427]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.427]                             info)
[16:21:49.427]                         }
[16:21:49.427]                         else {
[16:21:49.427]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.427]                             info, version)
[16:21:49.427]                         }
[16:21:49.427]                         base::stop(msg)
[16:21:49.427]                       }
[16:21:49.427]                     })
[16:21:49.427]                   }
[16:21:49.427]                   ...future.strategy.old <- future::plan("list")
[16:21:49.427]                   options(future.plan = NULL)
[16:21:49.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.427]                 }
[16:21:49.427]                 ...future.workdir <- getwd()
[16:21:49.427]             }
[16:21:49.427]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.427]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.427]         }
[16:21:49.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.427]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.427]             base::names(...future.oldOptions))
[16:21:49.427]     }
[16:21:49.427]     if (FALSE) {
[16:21:49.427]     }
[16:21:49.427]     else {
[16:21:49.427]         if (TRUE) {
[16:21:49.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.427]                 open = "w")
[16:21:49.427]         }
[16:21:49.427]         else {
[16:21:49.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.427]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.427]         }
[16:21:49.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.427]             base::sink(type = "output", split = FALSE)
[16:21:49.427]             base::close(...future.stdout)
[16:21:49.427]         }, add = TRUE)
[16:21:49.427]     }
[16:21:49.427]     ...future.frame <- base::sys.nframe()
[16:21:49.427]     ...future.conditions <- base::list()
[16:21:49.427]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.427]     if (FALSE) {
[16:21:49.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.427]     }
[16:21:49.427]     ...future.result <- base::tryCatch({
[16:21:49.427]         base::withCallingHandlers({
[16:21:49.427]             ...future.value <- base::withVisible(base::local(1))
[16:21:49.427]             future::FutureResult(value = ...future.value$value, 
[16:21:49.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.427]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.427]                     ...future.globalenv.names))
[16:21:49.427]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.427]         }, condition = base::local({
[16:21:49.427]             c <- base::c
[16:21:49.427]             inherits <- base::inherits
[16:21:49.427]             invokeRestart <- base::invokeRestart
[16:21:49.427]             length <- base::length
[16:21:49.427]             list <- base::list
[16:21:49.427]             seq.int <- base::seq.int
[16:21:49.427]             signalCondition <- base::signalCondition
[16:21:49.427]             sys.calls <- base::sys.calls
[16:21:49.427]             `[[` <- base::`[[`
[16:21:49.427]             `+` <- base::`+`
[16:21:49.427]             `<<-` <- base::`<<-`
[16:21:49.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.427]                   3L)]
[16:21:49.427]             }
[16:21:49.427]             function(cond) {
[16:21:49.427]                 is_error <- inherits(cond, "error")
[16:21:49.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.427]                   NULL)
[16:21:49.427]                 if (is_error) {
[16:21:49.427]                   sessionInformation <- function() {
[16:21:49.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.427]                       search = base::search(), system = base::Sys.info())
[16:21:49.427]                   }
[16:21:49.427]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.427]                     cond$call), session = sessionInformation(), 
[16:21:49.427]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.427]                   signalCondition(cond)
[16:21:49.427]                 }
[16:21:49.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.427]                 "immediateCondition"))) {
[16:21:49.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.427]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.427]                   if (TRUE && !signal) {
[16:21:49.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.427]                     {
[16:21:49.427]                       inherits <- base::inherits
[16:21:49.427]                       invokeRestart <- base::invokeRestart
[16:21:49.427]                       is.null <- base::is.null
[16:21:49.427]                       muffled <- FALSE
[16:21:49.427]                       if (inherits(cond, "message")) {
[16:21:49.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.427]                         if (muffled) 
[16:21:49.427]                           invokeRestart("muffleMessage")
[16:21:49.427]                       }
[16:21:49.427]                       else if (inherits(cond, "warning")) {
[16:21:49.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.427]                         if (muffled) 
[16:21:49.427]                           invokeRestart("muffleWarning")
[16:21:49.427]                       }
[16:21:49.427]                       else if (inherits(cond, "condition")) {
[16:21:49.427]                         if (!is.null(pattern)) {
[16:21:49.427]                           computeRestarts <- base::computeRestarts
[16:21:49.427]                           grepl <- base::grepl
[16:21:49.427]                           restarts <- computeRestarts(cond)
[16:21:49.427]                           for (restart in restarts) {
[16:21:49.427]                             name <- restart$name
[16:21:49.427]                             if (is.null(name)) 
[16:21:49.427]                               next
[16:21:49.427]                             if (!grepl(pattern, name)) 
[16:21:49.427]                               next
[16:21:49.427]                             invokeRestart(restart)
[16:21:49.427]                             muffled <- TRUE
[16:21:49.427]                             break
[16:21:49.427]                           }
[16:21:49.427]                         }
[16:21:49.427]                       }
[16:21:49.427]                       invisible(muffled)
[16:21:49.427]                     }
[16:21:49.427]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.427]                   }
[16:21:49.427]                 }
[16:21:49.427]                 else {
[16:21:49.427]                   if (TRUE) {
[16:21:49.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.427]                     {
[16:21:49.427]                       inherits <- base::inherits
[16:21:49.427]                       invokeRestart <- base::invokeRestart
[16:21:49.427]                       is.null <- base::is.null
[16:21:49.427]                       muffled <- FALSE
[16:21:49.427]                       if (inherits(cond, "message")) {
[16:21:49.427]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.427]                         if (muffled) 
[16:21:49.427]                           invokeRestart("muffleMessage")
[16:21:49.427]                       }
[16:21:49.427]                       else if (inherits(cond, "warning")) {
[16:21:49.427]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.427]                         if (muffled) 
[16:21:49.427]                           invokeRestart("muffleWarning")
[16:21:49.427]                       }
[16:21:49.427]                       else if (inherits(cond, "condition")) {
[16:21:49.427]                         if (!is.null(pattern)) {
[16:21:49.427]                           computeRestarts <- base::computeRestarts
[16:21:49.427]                           grepl <- base::grepl
[16:21:49.427]                           restarts <- computeRestarts(cond)
[16:21:49.427]                           for (restart in restarts) {
[16:21:49.427]                             name <- restart$name
[16:21:49.427]                             if (is.null(name)) 
[16:21:49.427]                               next
[16:21:49.427]                             if (!grepl(pattern, name)) 
[16:21:49.427]                               next
[16:21:49.427]                             invokeRestart(restart)
[16:21:49.427]                             muffled <- TRUE
[16:21:49.427]                             break
[16:21:49.427]                           }
[16:21:49.427]                         }
[16:21:49.427]                       }
[16:21:49.427]                       invisible(muffled)
[16:21:49.427]                     }
[16:21:49.427]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.427]                   }
[16:21:49.427]                 }
[16:21:49.427]             }
[16:21:49.427]         }))
[16:21:49.427]     }, error = function(ex) {
[16:21:49.427]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.427]                 ...future.rng), started = ...future.startTime, 
[16:21:49.427]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.427]             version = "1.8"), class = "FutureResult")
[16:21:49.427]     }, finally = {
[16:21:49.427]         if (!identical(...future.workdir, getwd())) 
[16:21:49.427]             setwd(...future.workdir)
[16:21:49.427]         {
[16:21:49.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.427]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.427]             }
[16:21:49.427]             base::options(...future.oldOptions)
[16:21:49.427]             if (.Platform$OS.type == "windows") {
[16:21:49.427]                 old_names <- names(...future.oldEnvVars)
[16:21:49.427]                 envs <- base::Sys.getenv()
[16:21:49.427]                 names <- names(envs)
[16:21:49.427]                 common <- intersect(names, old_names)
[16:21:49.427]                 added <- setdiff(names, old_names)
[16:21:49.427]                 removed <- setdiff(old_names, names)
[16:21:49.427]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.427]                   envs[common]]
[16:21:49.427]                 NAMES <- toupper(changed)
[16:21:49.427]                 args <- list()
[16:21:49.427]                 for (kk in seq_along(NAMES)) {
[16:21:49.427]                   name <- changed[[kk]]
[16:21:49.427]                   NAME <- NAMES[[kk]]
[16:21:49.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.427]                     next
[16:21:49.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.427]                 }
[16:21:49.427]                 NAMES <- toupper(added)
[16:21:49.427]                 for (kk in seq_along(NAMES)) {
[16:21:49.427]                   name <- added[[kk]]
[16:21:49.427]                   NAME <- NAMES[[kk]]
[16:21:49.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.427]                     next
[16:21:49.427]                   args[[name]] <- ""
[16:21:49.427]                 }
[16:21:49.427]                 NAMES <- toupper(removed)
[16:21:49.427]                 for (kk in seq_along(NAMES)) {
[16:21:49.427]                   name <- removed[[kk]]
[16:21:49.427]                   NAME <- NAMES[[kk]]
[16:21:49.427]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.427]                     next
[16:21:49.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.427]                 }
[16:21:49.427]                 if (length(args) > 0) 
[16:21:49.427]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.427]             }
[16:21:49.427]             else {
[16:21:49.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.427]             }
[16:21:49.427]             {
[16:21:49.427]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.427]                   0L) {
[16:21:49.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.427]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.427]                   base::options(opts)
[16:21:49.427]                 }
[16:21:49.427]                 {
[16:21:49.427]                   {
[16:21:49.427]                     NULL
[16:21:49.427]                     RNGkind("Mersenne-Twister")
[16:21:49.427]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.427]                       inherits = FALSE)
[16:21:49.427]                   }
[16:21:49.427]                   options(future.plan = NULL)
[16:21:49.427]                   if (is.na(NA_character_)) 
[16:21:49.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.427]                     .init = FALSE)
[16:21:49.427]                 }
[16:21:49.427]             }
[16:21:49.427]         }
[16:21:49.427]     })
[16:21:49.427]     if (TRUE) {
[16:21:49.427]         base::sink(type = "output", split = FALSE)
[16:21:49.427]         if (TRUE) {
[16:21:49.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.427]         }
[16:21:49.427]         else {
[16:21:49.427]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.427]         }
[16:21:49.427]         base::close(...future.stdout)
[16:21:49.427]         ...future.stdout <- NULL
[16:21:49.427]     }
[16:21:49.427]     ...future.result$conditions <- ...future.conditions
[16:21:49.427]     ...future.result$finished <- base::Sys.time()
[16:21:49.427]     ...future.result
[16:21:49.427] }
[16:21:49.428] plan(): Setting new future strategy stack:
[16:21:49.428] List of future strategies:
[16:21:49.428] 1. sequential:
[16:21:49.428]    - args: function (..., envir = parent.frame())
[16:21:49.428]    - tweaked: FALSE
[16:21:49.428]    - call: NULL
[16:21:49.429] plan(): nbrOfWorkers() = 1
[16:21:49.430] plan(): Setting new future strategy stack:
[16:21:49.430] List of future strategies:
[16:21:49.430] 1. sequential:
[16:21:49.430]    - args: function (..., envir = parent.frame())
[16:21:49.430]    - tweaked: FALSE
[16:21:49.430]    - call: plan(strategy)
[16:21:49.430] plan(): nbrOfWorkers() = 1
[16:21:49.430] SequentialFuture started (and completed)
[16:21:49.430] - Launch lazy future ... done
[16:21:49.430] run() for ‘SequentialFuture’ ... done
[16:21:49.430] resolved() for ‘SequentialFuture’ ...
[16:21:49.431] - state: ‘finished’
[16:21:49.431] - run: TRUE
[16:21:49.431] - result: ‘FutureResult’
[16:21:49.431] resolved() for ‘SequentialFuture’ ... done
[16:21:49.431] Future #1
[16:21:49.431]  length: 2 (resolved future 1)
[16:21:49.431] resolved() for ‘SequentialFuture’ ...
[16:21:49.431] - state: ‘finished’
[16:21:49.431] - run: TRUE
[16:21:49.431] - result: ‘FutureResult’
[16:21:49.432] resolved() for ‘SequentialFuture’ ... done
[16:21:49.432] Future #2
[16:21:49.432]  length: 1 (resolved future 2)
[16:21:49.432]  length: 0 (resolved future 3)
[16:21:49.432] resolve() on list ... DONE
[16:21:49.432] resolved() for ‘SequentialFuture’ ...
[16:21:49.432] - state: ‘finished’
[16:21:49.432] - run: TRUE
[16:21:49.432] - result: ‘FutureResult’
[16:21:49.432] resolved() for ‘SequentialFuture’ ... done
[16:21:49.433] resolved() for ‘SequentialFuture’ ...
[16:21:49.433] - state: ‘finished’
[16:21:49.433] - run: TRUE
[16:21:49.433] - result: ‘FutureResult’
[16:21:49.433] resolved() for ‘SequentialFuture’ ... done
[16:21:49.433] getGlobalsAndPackages() ...
[16:21:49.433] Searching for globals...
[16:21:49.433] 
[16:21:49.433] Searching for globals ... DONE
[16:21:49.434] - globals: [0] <none>
[16:21:49.434] getGlobalsAndPackages() ... DONE
[16:21:49.434] getGlobalsAndPackages() ...
[16:21:49.434] Searching for globals...
[16:21:49.434] 
[16:21:49.434] Searching for globals ... DONE
[16:21:49.434] - globals: [0] <none>
[16:21:49.434] getGlobalsAndPackages() ... DONE
[16:21:49.435] resolve() on list ...
[16:21:49.435]  recursive: 0
[16:21:49.435]  length: 3
[16:21:49.435]  elements: ‘a’, ‘b’, ‘’
[16:21:49.435] run() for ‘Future’ ...
[16:21:49.435] - state: ‘created’
[16:21:49.435] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.436] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.436]   - Field: ‘label’
[16:21:49.436]   - Field: ‘local’
[16:21:49.436]   - Field: ‘owner’
[16:21:49.436]   - Field: ‘envir’
[16:21:49.436]   - Field: ‘packages’
[16:21:49.436]   - Field: ‘gc’
[16:21:49.436]   - Field: ‘conditions’
[16:21:49.436]   - Field: ‘expr’
[16:21:49.436]   - Field: ‘uuid’
[16:21:49.437]   - Field: ‘seed’
[16:21:49.437]   - Field: ‘version’
[16:21:49.437]   - Field: ‘result’
[16:21:49.437]   - Field: ‘asynchronous’
[16:21:49.437]   - Field: ‘calls’
[16:21:49.437]   - Field: ‘globals’
[16:21:49.437]   - Field: ‘stdout’
[16:21:49.437]   - Field: ‘earlySignal’
[16:21:49.437]   - Field: ‘lazy’
[16:21:49.437]   - Field: ‘state’
[16:21:49.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.438] - Launch lazy future ...
[16:21:49.438] Packages needed by the future expression (n = 0): <none>
[16:21:49.438] Packages needed by future strategies (n = 0): <none>
[16:21:49.438] {
[16:21:49.438]     {
[16:21:49.438]         {
[16:21:49.438]             ...future.startTime <- base::Sys.time()
[16:21:49.438]             {
[16:21:49.438]                 {
[16:21:49.438]                   {
[16:21:49.438]                     base::local({
[16:21:49.438]                       has_future <- base::requireNamespace("future", 
[16:21:49.438]                         quietly = TRUE)
[16:21:49.438]                       if (has_future) {
[16:21:49.438]                         ns <- base::getNamespace("future")
[16:21:49.438]                         version <- ns[[".package"]][["version"]]
[16:21:49.438]                         if (is.null(version)) 
[16:21:49.438]                           version <- utils::packageVersion("future")
[16:21:49.438]                       }
[16:21:49.438]                       else {
[16:21:49.438]                         version <- NULL
[16:21:49.438]                       }
[16:21:49.438]                       if (!has_future || version < "1.8.0") {
[16:21:49.438]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.438]                           "", base::R.version$version.string), 
[16:21:49.438]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.438]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.438]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.438]                             "release", "version")], collapse = " "), 
[16:21:49.438]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.438]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.438]                           info)
[16:21:49.438]                         info <- base::paste(info, collapse = "; ")
[16:21:49.438]                         if (!has_future) {
[16:21:49.438]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.438]                             info)
[16:21:49.438]                         }
[16:21:49.438]                         else {
[16:21:49.438]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.438]                             info, version)
[16:21:49.438]                         }
[16:21:49.438]                         base::stop(msg)
[16:21:49.438]                       }
[16:21:49.438]                     })
[16:21:49.438]                   }
[16:21:49.438]                   ...future.strategy.old <- future::plan("list")
[16:21:49.438]                   options(future.plan = NULL)
[16:21:49.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.438]                 }
[16:21:49.438]                 ...future.workdir <- getwd()
[16:21:49.438]             }
[16:21:49.438]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.438]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.438]         }
[16:21:49.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.438]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.438]             base::names(...future.oldOptions))
[16:21:49.438]     }
[16:21:49.438]     if (FALSE) {
[16:21:49.438]     }
[16:21:49.438]     else {
[16:21:49.438]         if (TRUE) {
[16:21:49.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.438]                 open = "w")
[16:21:49.438]         }
[16:21:49.438]         else {
[16:21:49.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.438]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.438]         }
[16:21:49.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.438]             base::sink(type = "output", split = FALSE)
[16:21:49.438]             base::close(...future.stdout)
[16:21:49.438]         }, add = TRUE)
[16:21:49.438]     }
[16:21:49.438]     ...future.frame <- base::sys.nframe()
[16:21:49.438]     ...future.conditions <- base::list()
[16:21:49.438]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.438]     if (FALSE) {
[16:21:49.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.438]     }
[16:21:49.438]     ...future.result <- base::tryCatch({
[16:21:49.438]         base::withCallingHandlers({
[16:21:49.438]             ...future.value <- base::withVisible(base::local(1))
[16:21:49.438]             future::FutureResult(value = ...future.value$value, 
[16:21:49.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.438]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.438]                     ...future.globalenv.names))
[16:21:49.438]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.438]         }, condition = base::local({
[16:21:49.438]             c <- base::c
[16:21:49.438]             inherits <- base::inherits
[16:21:49.438]             invokeRestart <- base::invokeRestart
[16:21:49.438]             length <- base::length
[16:21:49.438]             list <- base::list
[16:21:49.438]             seq.int <- base::seq.int
[16:21:49.438]             signalCondition <- base::signalCondition
[16:21:49.438]             sys.calls <- base::sys.calls
[16:21:49.438]             `[[` <- base::`[[`
[16:21:49.438]             `+` <- base::`+`
[16:21:49.438]             `<<-` <- base::`<<-`
[16:21:49.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.438]                   3L)]
[16:21:49.438]             }
[16:21:49.438]             function(cond) {
[16:21:49.438]                 is_error <- inherits(cond, "error")
[16:21:49.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.438]                   NULL)
[16:21:49.438]                 if (is_error) {
[16:21:49.438]                   sessionInformation <- function() {
[16:21:49.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.438]                       search = base::search(), system = base::Sys.info())
[16:21:49.438]                   }
[16:21:49.438]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.438]                     cond$call), session = sessionInformation(), 
[16:21:49.438]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.438]                   signalCondition(cond)
[16:21:49.438]                 }
[16:21:49.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.438]                 "immediateCondition"))) {
[16:21:49.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.438]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.438]                   if (TRUE && !signal) {
[16:21:49.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.438]                     {
[16:21:49.438]                       inherits <- base::inherits
[16:21:49.438]                       invokeRestart <- base::invokeRestart
[16:21:49.438]                       is.null <- base::is.null
[16:21:49.438]                       muffled <- FALSE
[16:21:49.438]                       if (inherits(cond, "message")) {
[16:21:49.438]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.438]                         if (muffled) 
[16:21:49.438]                           invokeRestart("muffleMessage")
[16:21:49.438]                       }
[16:21:49.438]                       else if (inherits(cond, "warning")) {
[16:21:49.438]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.438]                         if (muffled) 
[16:21:49.438]                           invokeRestart("muffleWarning")
[16:21:49.438]                       }
[16:21:49.438]                       else if (inherits(cond, "condition")) {
[16:21:49.438]                         if (!is.null(pattern)) {
[16:21:49.438]                           computeRestarts <- base::computeRestarts
[16:21:49.438]                           grepl <- base::grepl
[16:21:49.438]                           restarts <- computeRestarts(cond)
[16:21:49.438]                           for (restart in restarts) {
[16:21:49.438]                             name <- restart$name
[16:21:49.438]                             if (is.null(name)) 
[16:21:49.438]                               next
[16:21:49.438]                             if (!grepl(pattern, name)) 
[16:21:49.438]                               next
[16:21:49.438]                             invokeRestart(restart)
[16:21:49.438]                             muffled <- TRUE
[16:21:49.438]                             break
[16:21:49.438]                           }
[16:21:49.438]                         }
[16:21:49.438]                       }
[16:21:49.438]                       invisible(muffled)
[16:21:49.438]                     }
[16:21:49.438]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.438]                   }
[16:21:49.438]                 }
[16:21:49.438]                 else {
[16:21:49.438]                   if (TRUE) {
[16:21:49.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.438]                     {
[16:21:49.438]                       inherits <- base::inherits
[16:21:49.438]                       invokeRestart <- base::invokeRestart
[16:21:49.438]                       is.null <- base::is.null
[16:21:49.438]                       muffled <- FALSE
[16:21:49.438]                       if (inherits(cond, "message")) {
[16:21:49.438]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.438]                         if (muffled) 
[16:21:49.438]                           invokeRestart("muffleMessage")
[16:21:49.438]                       }
[16:21:49.438]                       else if (inherits(cond, "warning")) {
[16:21:49.438]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.438]                         if (muffled) 
[16:21:49.438]                           invokeRestart("muffleWarning")
[16:21:49.438]                       }
[16:21:49.438]                       else if (inherits(cond, "condition")) {
[16:21:49.438]                         if (!is.null(pattern)) {
[16:21:49.438]                           computeRestarts <- base::computeRestarts
[16:21:49.438]                           grepl <- base::grepl
[16:21:49.438]                           restarts <- computeRestarts(cond)
[16:21:49.438]                           for (restart in restarts) {
[16:21:49.438]                             name <- restart$name
[16:21:49.438]                             if (is.null(name)) 
[16:21:49.438]                               next
[16:21:49.438]                             if (!grepl(pattern, name)) 
[16:21:49.438]                               next
[16:21:49.438]                             invokeRestart(restart)
[16:21:49.438]                             muffled <- TRUE
[16:21:49.438]                             break
[16:21:49.438]                           }
[16:21:49.438]                         }
[16:21:49.438]                       }
[16:21:49.438]                       invisible(muffled)
[16:21:49.438]                     }
[16:21:49.438]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.438]                   }
[16:21:49.438]                 }
[16:21:49.438]             }
[16:21:49.438]         }))
[16:21:49.438]     }, error = function(ex) {
[16:21:49.438]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.438]                 ...future.rng), started = ...future.startTime, 
[16:21:49.438]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.438]             version = "1.8"), class = "FutureResult")
[16:21:49.438]     }, finally = {
[16:21:49.438]         if (!identical(...future.workdir, getwd())) 
[16:21:49.438]             setwd(...future.workdir)
[16:21:49.438]         {
[16:21:49.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.438]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.438]             }
[16:21:49.438]             base::options(...future.oldOptions)
[16:21:49.438]             if (.Platform$OS.type == "windows") {
[16:21:49.438]                 old_names <- names(...future.oldEnvVars)
[16:21:49.438]                 envs <- base::Sys.getenv()
[16:21:49.438]                 names <- names(envs)
[16:21:49.438]                 common <- intersect(names, old_names)
[16:21:49.438]                 added <- setdiff(names, old_names)
[16:21:49.438]                 removed <- setdiff(old_names, names)
[16:21:49.438]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.438]                   envs[common]]
[16:21:49.438]                 NAMES <- toupper(changed)
[16:21:49.438]                 args <- list()
[16:21:49.438]                 for (kk in seq_along(NAMES)) {
[16:21:49.438]                   name <- changed[[kk]]
[16:21:49.438]                   NAME <- NAMES[[kk]]
[16:21:49.438]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.438]                     next
[16:21:49.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.438]                 }
[16:21:49.438]                 NAMES <- toupper(added)
[16:21:49.438]                 for (kk in seq_along(NAMES)) {
[16:21:49.438]                   name <- added[[kk]]
[16:21:49.438]                   NAME <- NAMES[[kk]]
[16:21:49.438]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.438]                     next
[16:21:49.438]                   args[[name]] <- ""
[16:21:49.438]                 }
[16:21:49.438]                 NAMES <- toupper(removed)
[16:21:49.438]                 for (kk in seq_along(NAMES)) {
[16:21:49.438]                   name <- removed[[kk]]
[16:21:49.438]                   NAME <- NAMES[[kk]]
[16:21:49.438]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.438]                     next
[16:21:49.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.438]                 }
[16:21:49.438]                 if (length(args) > 0) 
[16:21:49.438]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.438]             }
[16:21:49.438]             else {
[16:21:49.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.438]             }
[16:21:49.438]             {
[16:21:49.438]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.438]                   0L) {
[16:21:49.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.438]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.438]                   base::options(opts)
[16:21:49.438]                 }
[16:21:49.438]                 {
[16:21:49.438]                   {
[16:21:49.438]                     NULL
[16:21:49.438]                     RNGkind("Mersenne-Twister")
[16:21:49.438]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.438]                       inherits = FALSE)
[16:21:49.438]                   }
[16:21:49.438]                   options(future.plan = NULL)
[16:21:49.438]                   if (is.na(NA_character_)) 
[16:21:49.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.438]                     .init = FALSE)
[16:21:49.438]                 }
[16:21:49.438]             }
[16:21:49.438]         }
[16:21:49.438]     })
[16:21:49.438]     if (TRUE) {
[16:21:49.438]         base::sink(type = "output", split = FALSE)
[16:21:49.438]         if (TRUE) {
[16:21:49.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.438]         }
[16:21:49.438]         else {
[16:21:49.438]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.438]         }
[16:21:49.438]         base::close(...future.stdout)
[16:21:49.438]         ...future.stdout <- NULL
[16:21:49.438]     }
[16:21:49.438]     ...future.result$conditions <- ...future.conditions
[16:21:49.438]     ...future.result$finished <- base::Sys.time()
[16:21:49.438]     ...future.result
[16:21:49.438] }
[16:21:49.440] plan(): Setting new future strategy stack:
[16:21:49.440] List of future strategies:
[16:21:49.440] 1. sequential:
[16:21:49.440]    - args: function (..., envir = parent.frame())
[16:21:49.440]    - tweaked: FALSE
[16:21:49.440]    - call: NULL
[16:21:49.440] plan(): nbrOfWorkers() = 1
[16:21:49.441] plan(): Setting new future strategy stack:
[16:21:49.441] List of future strategies:
[16:21:49.441] 1. sequential:
[16:21:49.441]    - args: function (..., envir = parent.frame())
[16:21:49.441]    - tweaked: FALSE
[16:21:49.441]    - call: plan(strategy)
[16:21:49.441] plan(): nbrOfWorkers() = 1
[16:21:49.442] SequentialFuture started (and completed)
[16:21:49.442] - Launch lazy future ... done
[16:21:49.442] run() for ‘SequentialFuture’ ... done
[16:21:49.442] resolved() for ‘SequentialFuture’ ...
[16:21:49.442] - state: ‘finished’
[16:21:49.442] - run: TRUE
[16:21:49.442] - result: ‘FutureResult’
[16:21:49.442] resolved() for ‘SequentialFuture’ ... done
[16:21:49.442] Future #1
[16:21:49.443]  length: 2 (resolved future 1)
[16:21:49.443] run() for ‘Future’ ...
[16:21:49.443] - state: ‘created’
[16:21:49.443] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.443] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.443]   - Field: ‘label’
[16:21:49.443]   - Field: ‘local’
[16:21:49.443]   - Field: ‘owner’
[16:21:49.444]   - Field: ‘envir’
[16:21:49.444]   - Field: ‘packages’
[16:21:49.444]   - Field: ‘gc’
[16:21:49.444]   - Field: ‘conditions’
[16:21:49.444]   - Field: ‘expr’
[16:21:49.444]   - Field: ‘uuid’
[16:21:49.444]   - Field: ‘seed’
[16:21:49.444]   - Field: ‘version’
[16:21:49.444]   - Field: ‘result’
[16:21:49.444]   - Field: ‘asynchronous’
[16:21:49.445]   - Field: ‘calls’
[16:21:49.445]   - Field: ‘globals’
[16:21:49.445]   - Field: ‘stdout’
[16:21:49.445]   - Field: ‘earlySignal’
[16:21:49.445]   - Field: ‘lazy’
[16:21:49.445]   - Field: ‘state’
[16:21:49.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.445] - Launch lazy future ...
[16:21:49.445] Packages needed by the future expression (n = 0): <none>
[16:21:49.445] Packages needed by future strategies (n = 0): <none>
[16:21:49.448] {
[16:21:49.448]     {
[16:21:49.448]         {
[16:21:49.448]             ...future.startTime <- base::Sys.time()
[16:21:49.448]             {
[16:21:49.448]                 {
[16:21:49.448]                   {
[16:21:49.448]                     base::local({
[16:21:49.448]                       has_future <- base::requireNamespace("future", 
[16:21:49.448]                         quietly = TRUE)
[16:21:49.448]                       if (has_future) {
[16:21:49.448]                         ns <- base::getNamespace("future")
[16:21:49.448]                         version <- ns[[".package"]][["version"]]
[16:21:49.448]                         if (is.null(version)) 
[16:21:49.448]                           version <- utils::packageVersion("future")
[16:21:49.448]                       }
[16:21:49.448]                       else {
[16:21:49.448]                         version <- NULL
[16:21:49.448]                       }
[16:21:49.448]                       if (!has_future || version < "1.8.0") {
[16:21:49.448]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.448]                           "", base::R.version$version.string), 
[16:21:49.448]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.448]                             "release", "version")], collapse = " "), 
[16:21:49.448]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.448]                           info)
[16:21:49.448]                         info <- base::paste(info, collapse = "; ")
[16:21:49.448]                         if (!has_future) {
[16:21:49.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.448]                             info)
[16:21:49.448]                         }
[16:21:49.448]                         else {
[16:21:49.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.448]                             info, version)
[16:21:49.448]                         }
[16:21:49.448]                         base::stop(msg)
[16:21:49.448]                       }
[16:21:49.448]                     })
[16:21:49.448]                   }
[16:21:49.448]                   ...future.strategy.old <- future::plan("list")
[16:21:49.448]                   options(future.plan = NULL)
[16:21:49.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.448]                 }
[16:21:49.448]                 ...future.workdir <- getwd()
[16:21:49.448]             }
[16:21:49.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.448]         }
[16:21:49.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.448]             base::names(...future.oldOptions))
[16:21:49.448]     }
[16:21:49.448]     if (FALSE) {
[16:21:49.448]     }
[16:21:49.448]     else {
[16:21:49.448]         if (TRUE) {
[16:21:49.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.448]                 open = "w")
[16:21:49.448]         }
[16:21:49.448]         else {
[16:21:49.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.448]         }
[16:21:49.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.448]             base::sink(type = "output", split = FALSE)
[16:21:49.448]             base::close(...future.stdout)
[16:21:49.448]         }, add = TRUE)
[16:21:49.448]     }
[16:21:49.448]     ...future.frame <- base::sys.nframe()
[16:21:49.448]     ...future.conditions <- base::list()
[16:21:49.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.448]     if (FALSE) {
[16:21:49.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.448]     }
[16:21:49.448]     ...future.result <- base::tryCatch({
[16:21:49.448]         base::withCallingHandlers({
[16:21:49.448]             ...future.value <- base::withVisible(base::local(2))
[16:21:49.448]             future::FutureResult(value = ...future.value$value, 
[16:21:49.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.448]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.448]                     ...future.globalenv.names))
[16:21:49.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.448]         }, condition = base::local({
[16:21:49.448]             c <- base::c
[16:21:49.448]             inherits <- base::inherits
[16:21:49.448]             invokeRestart <- base::invokeRestart
[16:21:49.448]             length <- base::length
[16:21:49.448]             list <- base::list
[16:21:49.448]             seq.int <- base::seq.int
[16:21:49.448]             signalCondition <- base::signalCondition
[16:21:49.448]             sys.calls <- base::sys.calls
[16:21:49.448]             `[[` <- base::`[[`
[16:21:49.448]             `+` <- base::`+`
[16:21:49.448]             `<<-` <- base::`<<-`
[16:21:49.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.448]                   3L)]
[16:21:49.448]             }
[16:21:49.448]             function(cond) {
[16:21:49.448]                 is_error <- inherits(cond, "error")
[16:21:49.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.448]                   NULL)
[16:21:49.448]                 if (is_error) {
[16:21:49.448]                   sessionInformation <- function() {
[16:21:49.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.448]                       search = base::search(), system = base::Sys.info())
[16:21:49.448]                   }
[16:21:49.448]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.448]                     cond$call), session = sessionInformation(), 
[16:21:49.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.448]                   signalCondition(cond)
[16:21:49.448]                 }
[16:21:49.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.448]                 "immediateCondition"))) {
[16:21:49.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.448]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.448]                   if (TRUE && !signal) {
[16:21:49.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.448]                     {
[16:21:49.448]                       inherits <- base::inherits
[16:21:49.448]                       invokeRestart <- base::invokeRestart
[16:21:49.448]                       is.null <- base::is.null
[16:21:49.448]                       muffled <- FALSE
[16:21:49.448]                       if (inherits(cond, "message")) {
[16:21:49.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.448]                         if (muffled) 
[16:21:49.448]                           invokeRestart("muffleMessage")
[16:21:49.448]                       }
[16:21:49.448]                       else if (inherits(cond, "warning")) {
[16:21:49.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.448]                         if (muffled) 
[16:21:49.448]                           invokeRestart("muffleWarning")
[16:21:49.448]                       }
[16:21:49.448]                       else if (inherits(cond, "condition")) {
[16:21:49.448]                         if (!is.null(pattern)) {
[16:21:49.448]                           computeRestarts <- base::computeRestarts
[16:21:49.448]                           grepl <- base::grepl
[16:21:49.448]                           restarts <- computeRestarts(cond)
[16:21:49.448]                           for (restart in restarts) {
[16:21:49.448]                             name <- restart$name
[16:21:49.448]                             if (is.null(name)) 
[16:21:49.448]                               next
[16:21:49.448]                             if (!grepl(pattern, name)) 
[16:21:49.448]                               next
[16:21:49.448]                             invokeRestart(restart)
[16:21:49.448]                             muffled <- TRUE
[16:21:49.448]                             break
[16:21:49.448]                           }
[16:21:49.448]                         }
[16:21:49.448]                       }
[16:21:49.448]                       invisible(muffled)
[16:21:49.448]                     }
[16:21:49.448]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.448]                   }
[16:21:49.448]                 }
[16:21:49.448]                 else {
[16:21:49.448]                   if (TRUE) {
[16:21:49.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.448]                     {
[16:21:49.448]                       inherits <- base::inherits
[16:21:49.448]                       invokeRestart <- base::invokeRestart
[16:21:49.448]                       is.null <- base::is.null
[16:21:49.448]                       muffled <- FALSE
[16:21:49.448]                       if (inherits(cond, "message")) {
[16:21:49.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.448]                         if (muffled) 
[16:21:49.448]                           invokeRestart("muffleMessage")
[16:21:49.448]                       }
[16:21:49.448]                       else if (inherits(cond, "warning")) {
[16:21:49.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.448]                         if (muffled) 
[16:21:49.448]                           invokeRestart("muffleWarning")
[16:21:49.448]                       }
[16:21:49.448]                       else if (inherits(cond, "condition")) {
[16:21:49.448]                         if (!is.null(pattern)) {
[16:21:49.448]                           computeRestarts <- base::computeRestarts
[16:21:49.448]                           grepl <- base::grepl
[16:21:49.448]                           restarts <- computeRestarts(cond)
[16:21:49.448]                           for (restart in restarts) {
[16:21:49.448]                             name <- restart$name
[16:21:49.448]                             if (is.null(name)) 
[16:21:49.448]                               next
[16:21:49.448]                             if (!grepl(pattern, name)) 
[16:21:49.448]                               next
[16:21:49.448]                             invokeRestart(restart)
[16:21:49.448]                             muffled <- TRUE
[16:21:49.448]                             break
[16:21:49.448]                           }
[16:21:49.448]                         }
[16:21:49.448]                       }
[16:21:49.448]                       invisible(muffled)
[16:21:49.448]                     }
[16:21:49.448]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.448]                   }
[16:21:49.448]                 }
[16:21:49.448]             }
[16:21:49.448]         }))
[16:21:49.448]     }, error = function(ex) {
[16:21:49.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.448]                 ...future.rng), started = ...future.startTime, 
[16:21:49.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.448]             version = "1.8"), class = "FutureResult")
[16:21:49.448]     }, finally = {
[16:21:49.448]         if (!identical(...future.workdir, getwd())) 
[16:21:49.448]             setwd(...future.workdir)
[16:21:49.448]         {
[16:21:49.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.448]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.448]             }
[16:21:49.448]             base::options(...future.oldOptions)
[16:21:49.448]             if (.Platform$OS.type == "windows") {
[16:21:49.448]                 old_names <- names(...future.oldEnvVars)
[16:21:49.448]                 envs <- base::Sys.getenv()
[16:21:49.448]                 names <- names(envs)
[16:21:49.448]                 common <- intersect(names, old_names)
[16:21:49.448]                 added <- setdiff(names, old_names)
[16:21:49.448]                 removed <- setdiff(old_names, names)
[16:21:49.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.448]                   envs[common]]
[16:21:49.448]                 NAMES <- toupper(changed)
[16:21:49.448]                 args <- list()
[16:21:49.448]                 for (kk in seq_along(NAMES)) {
[16:21:49.448]                   name <- changed[[kk]]
[16:21:49.448]                   NAME <- NAMES[[kk]]
[16:21:49.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.448]                     next
[16:21:49.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.448]                 }
[16:21:49.448]                 NAMES <- toupper(added)
[16:21:49.448]                 for (kk in seq_along(NAMES)) {
[16:21:49.448]                   name <- added[[kk]]
[16:21:49.448]                   NAME <- NAMES[[kk]]
[16:21:49.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.448]                     next
[16:21:49.448]                   args[[name]] <- ""
[16:21:49.448]                 }
[16:21:49.448]                 NAMES <- toupper(removed)
[16:21:49.448]                 for (kk in seq_along(NAMES)) {
[16:21:49.448]                   name <- removed[[kk]]
[16:21:49.448]                   NAME <- NAMES[[kk]]
[16:21:49.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.448]                     next
[16:21:49.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.448]                 }
[16:21:49.448]                 if (length(args) > 0) 
[16:21:49.448]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.448]             }
[16:21:49.448]             else {
[16:21:49.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.448]             }
[16:21:49.448]             {
[16:21:49.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.448]                   0L) {
[16:21:49.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.448]                   base::options(opts)
[16:21:49.448]                 }
[16:21:49.448]                 {
[16:21:49.448]                   {
[16:21:49.448]                     NULL
[16:21:49.448]                     RNGkind("Mersenne-Twister")
[16:21:49.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.448]                       inherits = FALSE)
[16:21:49.448]                   }
[16:21:49.448]                   options(future.plan = NULL)
[16:21:49.448]                   if (is.na(NA_character_)) 
[16:21:49.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.448]                     .init = FALSE)
[16:21:49.448]                 }
[16:21:49.448]             }
[16:21:49.448]         }
[16:21:49.448]     })
[16:21:49.448]     if (TRUE) {
[16:21:49.448]         base::sink(type = "output", split = FALSE)
[16:21:49.448]         if (TRUE) {
[16:21:49.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.448]         }
[16:21:49.448]         else {
[16:21:49.448]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.448]         }
[16:21:49.448]         base::close(...future.stdout)
[16:21:49.448]         ...future.stdout <- NULL
[16:21:49.448]     }
[16:21:49.448]     ...future.result$conditions <- ...future.conditions
[16:21:49.448]     ...future.result$finished <- base::Sys.time()
[16:21:49.448]     ...future.result
[16:21:49.448] }
[16:21:49.449] plan(): Setting new future strategy stack:
[16:21:49.449] List of future strategies:
[16:21:49.449] 1. sequential:
[16:21:49.449]    - args: function (..., envir = parent.frame())
[16:21:49.449]    - tweaked: FALSE
[16:21:49.449]    - call: NULL
[16:21:49.450] plan(): nbrOfWorkers() = 1
[16:21:49.450] plan(): Setting new future strategy stack:
[16:21:49.451] List of future strategies:
[16:21:49.451] 1. sequential:
[16:21:49.451]    - args: function (..., envir = parent.frame())
[16:21:49.451]    - tweaked: FALSE
[16:21:49.451]    - call: plan(strategy)
[16:21:49.451] plan(): nbrOfWorkers() = 1
[16:21:49.451] SequentialFuture started (and completed)
[16:21:49.451] - Launch lazy future ... done
[16:21:49.451] run() for ‘SequentialFuture’ ... done
[16:21:49.451] resolved() for ‘SequentialFuture’ ...
[16:21:49.451] - state: ‘finished’
[16:21:49.452] - run: TRUE
[16:21:49.452] - result: ‘FutureResult’
[16:21:49.452] resolved() for ‘SequentialFuture’ ... done
[16:21:49.452] Future #2
[16:21:49.452]  length: 1 (resolved future 2)
[16:21:49.452]  length: 0 (resolved future 3)
[16:21:49.452] resolve() on list ... DONE
[16:21:49.452] resolved() for ‘SequentialFuture’ ...
[16:21:49.452] - state: ‘finished’
[16:21:49.452] - run: TRUE
[16:21:49.453] - result: ‘FutureResult’
[16:21:49.453] resolved() for ‘SequentialFuture’ ... done
[16:21:49.453] resolved() for ‘SequentialFuture’ ...
[16:21:49.453] - state: ‘finished’
[16:21:49.453] - run: TRUE
[16:21:49.453] - result: ‘FutureResult’
[16:21:49.453] resolved() for ‘SequentialFuture’ ... done
[16:21:49.453] getGlobalsAndPackages() ...
[16:21:49.453] Searching for globals...
[16:21:49.454] 
[16:21:49.454] Searching for globals ... DONE
[16:21:49.454] - globals: [0] <none>
[16:21:49.454] getGlobalsAndPackages() ... DONE
[16:21:49.454] run() for ‘Future’ ...
[16:21:49.454] - state: ‘created’
[16:21:49.454] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.455] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.455]   - Field: ‘label’
[16:21:49.455]   - Field: ‘local’
[16:21:49.455]   - Field: ‘owner’
[16:21:49.455]   - Field: ‘envir’
[16:21:49.455]   - Field: ‘packages’
[16:21:49.455]   - Field: ‘gc’
[16:21:49.455]   - Field: ‘conditions’
[16:21:49.455]   - Field: ‘expr’
[16:21:49.455]   - Field: ‘uuid’
[16:21:49.456]   - Field: ‘seed’
[16:21:49.456]   - Field: ‘version’
[16:21:49.456]   - Field: ‘result’
[16:21:49.456]   - Field: ‘asynchronous’
[16:21:49.456]   - Field: ‘calls’
[16:21:49.456]   - Field: ‘globals’
[16:21:49.456]   - Field: ‘stdout’
[16:21:49.456]   - Field: ‘earlySignal’
[16:21:49.456]   - Field: ‘lazy’
[16:21:49.456]   - Field: ‘state’
[16:21:49.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.457] - Launch lazy future ...
[16:21:49.457] Packages needed by the future expression (n = 0): <none>
[16:21:49.457] Packages needed by future strategies (n = 0): <none>
[16:21:49.457] {
[16:21:49.457]     {
[16:21:49.457]         {
[16:21:49.457]             ...future.startTime <- base::Sys.time()
[16:21:49.457]             {
[16:21:49.457]                 {
[16:21:49.457]                   {
[16:21:49.457]                     base::local({
[16:21:49.457]                       has_future <- base::requireNamespace("future", 
[16:21:49.457]                         quietly = TRUE)
[16:21:49.457]                       if (has_future) {
[16:21:49.457]                         ns <- base::getNamespace("future")
[16:21:49.457]                         version <- ns[[".package"]][["version"]]
[16:21:49.457]                         if (is.null(version)) 
[16:21:49.457]                           version <- utils::packageVersion("future")
[16:21:49.457]                       }
[16:21:49.457]                       else {
[16:21:49.457]                         version <- NULL
[16:21:49.457]                       }
[16:21:49.457]                       if (!has_future || version < "1.8.0") {
[16:21:49.457]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.457]                           "", base::R.version$version.string), 
[16:21:49.457]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.457]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.457]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.457]                             "release", "version")], collapse = " "), 
[16:21:49.457]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.457]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.457]                           info)
[16:21:49.457]                         info <- base::paste(info, collapse = "; ")
[16:21:49.457]                         if (!has_future) {
[16:21:49.457]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.457]                             info)
[16:21:49.457]                         }
[16:21:49.457]                         else {
[16:21:49.457]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.457]                             info, version)
[16:21:49.457]                         }
[16:21:49.457]                         base::stop(msg)
[16:21:49.457]                       }
[16:21:49.457]                     })
[16:21:49.457]                   }
[16:21:49.457]                   ...future.strategy.old <- future::plan("list")
[16:21:49.457]                   options(future.plan = NULL)
[16:21:49.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.457]                 }
[16:21:49.457]                 ...future.workdir <- getwd()
[16:21:49.457]             }
[16:21:49.457]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.457]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.457]         }
[16:21:49.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.457]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.457]             base::names(...future.oldOptions))
[16:21:49.457]     }
[16:21:49.457]     if (FALSE) {
[16:21:49.457]     }
[16:21:49.457]     else {
[16:21:49.457]         if (TRUE) {
[16:21:49.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.457]                 open = "w")
[16:21:49.457]         }
[16:21:49.457]         else {
[16:21:49.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.457]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.457]         }
[16:21:49.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.457]             base::sink(type = "output", split = FALSE)
[16:21:49.457]             base::close(...future.stdout)
[16:21:49.457]         }, add = TRUE)
[16:21:49.457]     }
[16:21:49.457]     ...future.frame <- base::sys.nframe()
[16:21:49.457]     ...future.conditions <- base::list()
[16:21:49.457]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.457]     if (FALSE) {
[16:21:49.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.457]     }
[16:21:49.457]     ...future.result <- base::tryCatch({
[16:21:49.457]         base::withCallingHandlers({
[16:21:49.457]             ...future.value <- base::withVisible(base::local(1))
[16:21:49.457]             future::FutureResult(value = ...future.value$value, 
[16:21:49.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.457]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.457]                     ...future.globalenv.names))
[16:21:49.457]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.457]         }, condition = base::local({
[16:21:49.457]             c <- base::c
[16:21:49.457]             inherits <- base::inherits
[16:21:49.457]             invokeRestart <- base::invokeRestart
[16:21:49.457]             length <- base::length
[16:21:49.457]             list <- base::list
[16:21:49.457]             seq.int <- base::seq.int
[16:21:49.457]             signalCondition <- base::signalCondition
[16:21:49.457]             sys.calls <- base::sys.calls
[16:21:49.457]             `[[` <- base::`[[`
[16:21:49.457]             `+` <- base::`+`
[16:21:49.457]             `<<-` <- base::`<<-`
[16:21:49.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.457]                   3L)]
[16:21:49.457]             }
[16:21:49.457]             function(cond) {
[16:21:49.457]                 is_error <- inherits(cond, "error")
[16:21:49.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.457]                   NULL)
[16:21:49.457]                 if (is_error) {
[16:21:49.457]                   sessionInformation <- function() {
[16:21:49.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.457]                       search = base::search(), system = base::Sys.info())
[16:21:49.457]                   }
[16:21:49.457]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.457]                     cond$call), session = sessionInformation(), 
[16:21:49.457]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.457]                   signalCondition(cond)
[16:21:49.457]                 }
[16:21:49.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.457]                 "immediateCondition"))) {
[16:21:49.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.457]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.457]                   if (TRUE && !signal) {
[16:21:49.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.457]                     {
[16:21:49.457]                       inherits <- base::inherits
[16:21:49.457]                       invokeRestart <- base::invokeRestart
[16:21:49.457]                       is.null <- base::is.null
[16:21:49.457]                       muffled <- FALSE
[16:21:49.457]                       if (inherits(cond, "message")) {
[16:21:49.457]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.457]                         if (muffled) 
[16:21:49.457]                           invokeRestart("muffleMessage")
[16:21:49.457]                       }
[16:21:49.457]                       else if (inherits(cond, "warning")) {
[16:21:49.457]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.457]                         if (muffled) 
[16:21:49.457]                           invokeRestart("muffleWarning")
[16:21:49.457]                       }
[16:21:49.457]                       else if (inherits(cond, "condition")) {
[16:21:49.457]                         if (!is.null(pattern)) {
[16:21:49.457]                           computeRestarts <- base::computeRestarts
[16:21:49.457]                           grepl <- base::grepl
[16:21:49.457]                           restarts <- computeRestarts(cond)
[16:21:49.457]                           for (restart in restarts) {
[16:21:49.457]                             name <- restart$name
[16:21:49.457]                             if (is.null(name)) 
[16:21:49.457]                               next
[16:21:49.457]                             if (!grepl(pattern, name)) 
[16:21:49.457]                               next
[16:21:49.457]                             invokeRestart(restart)
[16:21:49.457]                             muffled <- TRUE
[16:21:49.457]                             break
[16:21:49.457]                           }
[16:21:49.457]                         }
[16:21:49.457]                       }
[16:21:49.457]                       invisible(muffled)
[16:21:49.457]                     }
[16:21:49.457]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.457]                   }
[16:21:49.457]                 }
[16:21:49.457]                 else {
[16:21:49.457]                   if (TRUE) {
[16:21:49.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.457]                     {
[16:21:49.457]                       inherits <- base::inherits
[16:21:49.457]                       invokeRestart <- base::invokeRestart
[16:21:49.457]                       is.null <- base::is.null
[16:21:49.457]                       muffled <- FALSE
[16:21:49.457]                       if (inherits(cond, "message")) {
[16:21:49.457]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.457]                         if (muffled) 
[16:21:49.457]                           invokeRestart("muffleMessage")
[16:21:49.457]                       }
[16:21:49.457]                       else if (inherits(cond, "warning")) {
[16:21:49.457]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.457]                         if (muffled) 
[16:21:49.457]                           invokeRestart("muffleWarning")
[16:21:49.457]                       }
[16:21:49.457]                       else if (inherits(cond, "condition")) {
[16:21:49.457]                         if (!is.null(pattern)) {
[16:21:49.457]                           computeRestarts <- base::computeRestarts
[16:21:49.457]                           grepl <- base::grepl
[16:21:49.457]                           restarts <- computeRestarts(cond)
[16:21:49.457]                           for (restart in restarts) {
[16:21:49.457]                             name <- restart$name
[16:21:49.457]                             if (is.null(name)) 
[16:21:49.457]                               next
[16:21:49.457]                             if (!grepl(pattern, name)) 
[16:21:49.457]                               next
[16:21:49.457]                             invokeRestart(restart)
[16:21:49.457]                             muffled <- TRUE
[16:21:49.457]                             break
[16:21:49.457]                           }
[16:21:49.457]                         }
[16:21:49.457]                       }
[16:21:49.457]                       invisible(muffled)
[16:21:49.457]                     }
[16:21:49.457]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.457]                   }
[16:21:49.457]                 }
[16:21:49.457]             }
[16:21:49.457]         }))
[16:21:49.457]     }, error = function(ex) {
[16:21:49.457]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.457]                 ...future.rng), started = ...future.startTime, 
[16:21:49.457]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.457]             version = "1.8"), class = "FutureResult")
[16:21:49.457]     }, finally = {
[16:21:49.457]         if (!identical(...future.workdir, getwd())) 
[16:21:49.457]             setwd(...future.workdir)
[16:21:49.457]         {
[16:21:49.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.457]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.457]             }
[16:21:49.457]             base::options(...future.oldOptions)
[16:21:49.457]             if (.Platform$OS.type == "windows") {
[16:21:49.457]                 old_names <- names(...future.oldEnvVars)
[16:21:49.457]                 envs <- base::Sys.getenv()
[16:21:49.457]                 names <- names(envs)
[16:21:49.457]                 common <- intersect(names, old_names)
[16:21:49.457]                 added <- setdiff(names, old_names)
[16:21:49.457]                 removed <- setdiff(old_names, names)
[16:21:49.457]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.457]                   envs[common]]
[16:21:49.457]                 NAMES <- toupper(changed)
[16:21:49.457]                 args <- list()
[16:21:49.457]                 for (kk in seq_along(NAMES)) {
[16:21:49.457]                   name <- changed[[kk]]
[16:21:49.457]                   NAME <- NAMES[[kk]]
[16:21:49.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.457]                     next
[16:21:49.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.457]                 }
[16:21:49.457]                 NAMES <- toupper(added)
[16:21:49.457]                 for (kk in seq_along(NAMES)) {
[16:21:49.457]                   name <- added[[kk]]
[16:21:49.457]                   NAME <- NAMES[[kk]]
[16:21:49.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.457]                     next
[16:21:49.457]                   args[[name]] <- ""
[16:21:49.457]                 }
[16:21:49.457]                 NAMES <- toupper(removed)
[16:21:49.457]                 for (kk in seq_along(NAMES)) {
[16:21:49.457]                   name <- removed[[kk]]
[16:21:49.457]                   NAME <- NAMES[[kk]]
[16:21:49.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.457]                     next
[16:21:49.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.457]                 }
[16:21:49.457]                 if (length(args) > 0) 
[16:21:49.457]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.457]             }
[16:21:49.457]             else {
[16:21:49.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.457]             }
[16:21:49.457]             {
[16:21:49.457]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.457]                   0L) {
[16:21:49.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.457]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.457]                   base::options(opts)
[16:21:49.457]                 }
[16:21:49.457]                 {
[16:21:49.457]                   {
[16:21:49.457]                     NULL
[16:21:49.457]                     RNGkind("Mersenne-Twister")
[16:21:49.457]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.457]                       inherits = FALSE)
[16:21:49.457]                   }
[16:21:49.457]                   options(future.plan = NULL)
[16:21:49.457]                   if (is.na(NA_character_)) 
[16:21:49.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.457]                     .init = FALSE)
[16:21:49.457]                 }
[16:21:49.457]             }
[16:21:49.457]         }
[16:21:49.457]     })
[16:21:49.457]     if (TRUE) {
[16:21:49.457]         base::sink(type = "output", split = FALSE)
[16:21:49.457]         if (TRUE) {
[16:21:49.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.457]         }
[16:21:49.457]         else {
[16:21:49.457]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.457]         }
[16:21:49.457]         base::close(...future.stdout)
[16:21:49.457]         ...future.stdout <- NULL
[16:21:49.457]     }
[16:21:49.457]     ...future.result$conditions <- ...future.conditions
[16:21:49.457]     ...future.result$finished <- base::Sys.time()
[16:21:49.457]     ...future.result
[16:21:49.457] }
[16:21:49.459] plan(): Setting new future strategy stack:
[16:21:49.459] List of future strategies:
[16:21:49.459] 1. sequential:
[16:21:49.459]    - args: function (..., envir = parent.frame())
[16:21:49.459]    - tweaked: FALSE
[16:21:49.459]    - call: NULL
[16:21:49.459] plan(): nbrOfWorkers() = 1
[16:21:49.460] plan(): Setting new future strategy stack:
[16:21:49.460] List of future strategies:
[16:21:49.460] 1. sequential:
[16:21:49.460]    - args: function (..., envir = parent.frame())
[16:21:49.460]    - tweaked: FALSE
[16:21:49.460]    - call: plan(strategy)
[16:21:49.461] plan(): nbrOfWorkers() = 1
[16:21:49.461] SequentialFuture started (and completed)
[16:21:49.461] - Launch lazy future ... done
[16:21:49.461] run() for ‘SequentialFuture’ ... done
[16:21:49.461] getGlobalsAndPackages() ...
[16:21:49.461] Searching for globals...
[16:21:49.466] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:21:49.466] Searching for globals ... DONE
[16:21:49.466] Resolving globals: FALSE
[16:21:49.467] 
[16:21:49.467] 
[16:21:49.467] getGlobalsAndPackages() ... DONE
[16:21:49.467] run() for ‘Future’ ...
[16:21:49.467] - state: ‘created’
[16:21:49.467] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.467] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.468]   - Field: ‘label’
[16:21:49.468]   - Field: ‘local’
[16:21:49.468]   - Field: ‘owner’
[16:21:49.468]   - Field: ‘envir’
[16:21:49.468]   - Field: ‘packages’
[16:21:49.468]   - Field: ‘gc’
[16:21:49.468]   - Field: ‘conditions’
[16:21:49.468]   - Field: ‘expr’
[16:21:49.468]   - Field: ‘uuid’
[16:21:49.469]   - Field: ‘seed’
[16:21:49.469]   - Field: ‘version’
[16:21:49.469]   - Field: ‘result’
[16:21:49.469]   - Field: ‘asynchronous’
[16:21:49.469]   - Field: ‘calls’
[16:21:49.469]   - Field: ‘globals’
[16:21:49.469]   - Field: ‘stdout’
[16:21:49.469]   - Field: ‘earlySignal’
[16:21:49.469]   - Field: ‘lazy’
[16:21:49.469]   - Field: ‘state’
[16:21:49.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.470] - Launch lazy future ...
[16:21:49.470] Packages needed by the future expression (n = 0): <none>
[16:21:49.470] Packages needed by future strategies (n = 0): <none>
[16:21:49.470] {
[16:21:49.470]     {
[16:21:49.470]         {
[16:21:49.470]             ...future.startTime <- base::Sys.time()
[16:21:49.470]             {
[16:21:49.470]                 {
[16:21:49.470]                   {
[16:21:49.470]                     base::local({
[16:21:49.470]                       has_future <- base::requireNamespace("future", 
[16:21:49.470]                         quietly = TRUE)
[16:21:49.470]                       if (has_future) {
[16:21:49.470]                         ns <- base::getNamespace("future")
[16:21:49.470]                         version <- ns[[".package"]][["version"]]
[16:21:49.470]                         if (is.null(version)) 
[16:21:49.470]                           version <- utils::packageVersion("future")
[16:21:49.470]                       }
[16:21:49.470]                       else {
[16:21:49.470]                         version <- NULL
[16:21:49.470]                       }
[16:21:49.470]                       if (!has_future || version < "1.8.0") {
[16:21:49.470]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.470]                           "", base::R.version$version.string), 
[16:21:49.470]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.470]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.470]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.470]                             "release", "version")], collapse = " "), 
[16:21:49.470]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.470]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.470]                           info)
[16:21:49.470]                         info <- base::paste(info, collapse = "; ")
[16:21:49.470]                         if (!has_future) {
[16:21:49.470]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.470]                             info)
[16:21:49.470]                         }
[16:21:49.470]                         else {
[16:21:49.470]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.470]                             info, version)
[16:21:49.470]                         }
[16:21:49.470]                         base::stop(msg)
[16:21:49.470]                       }
[16:21:49.470]                     })
[16:21:49.470]                   }
[16:21:49.470]                   ...future.strategy.old <- future::plan("list")
[16:21:49.470]                   options(future.plan = NULL)
[16:21:49.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.470]                 }
[16:21:49.470]                 ...future.workdir <- getwd()
[16:21:49.470]             }
[16:21:49.470]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.470]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.470]         }
[16:21:49.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.470]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.470]             base::names(...future.oldOptions))
[16:21:49.470]     }
[16:21:49.470]     if (FALSE) {
[16:21:49.470]     }
[16:21:49.470]     else {
[16:21:49.470]         if (TRUE) {
[16:21:49.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.470]                 open = "w")
[16:21:49.470]         }
[16:21:49.470]         else {
[16:21:49.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.470]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.470]         }
[16:21:49.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.470]             base::sink(type = "output", split = FALSE)
[16:21:49.470]             base::close(...future.stdout)
[16:21:49.470]         }, add = TRUE)
[16:21:49.470]     }
[16:21:49.470]     ...future.frame <- base::sys.nframe()
[16:21:49.470]     ...future.conditions <- base::list()
[16:21:49.470]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.470]     if (FALSE) {
[16:21:49.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.470]     }
[16:21:49.470]     ...future.result <- base::tryCatch({
[16:21:49.470]         base::withCallingHandlers({
[16:21:49.470]             ...future.value <- base::withVisible(base::local({
[16:21:49.470]                 Sys.sleep(0.5)
[16:21:49.470]                 2
[16:21:49.470]             }))
[16:21:49.470]             future::FutureResult(value = ...future.value$value, 
[16:21:49.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.470]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.470]                     ...future.globalenv.names))
[16:21:49.470]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.470]         }, condition = base::local({
[16:21:49.470]             c <- base::c
[16:21:49.470]             inherits <- base::inherits
[16:21:49.470]             invokeRestart <- base::invokeRestart
[16:21:49.470]             length <- base::length
[16:21:49.470]             list <- base::list
[16:21:49.470]             seq.int <- base::seq.int
[16:21:49.470]             signalCondition <- base::signalCondition
[16:21:49.470]             sys.calls <- base::sys.calls
[16:21:49.470]             `[[` <- base::`[[`
[16:21:49.470]             `+` <- base::`+`
[16:21:49.470]             `<<-` <- base::`<<-`
[16:21:49.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.470]                   3L)]
[16:21:49.470]             }
[16:21:49.470]             function(cond) {
[16:21:49.470]                 is_error <- inherits(cond, "error")
[16:21:49.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.470]                   NULL)
[16:21:49.470]                 if (is_error) {
[16:21:49.470]                   sessionInformation <- function() {
[16:21:49.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.470]                       search = base::search(), system = base::Sys.info())
[16:21:49.470]                   }
[16:21:49.470]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.470]                     cond$call), session = sessionInformation(), 
[16:21:49.470]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.470]                   signalCondition(cond)
[16:21:49.470]                 }
[16:21:49.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.470]                 "immediateCondition"))) {
[16:21:49.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.470]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.470]                   if (TRUE && !signal) {
[16:21:49.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.470]                     {
[16:21:49.470]                       inherits <- base::inherits
[16:21:49.470]                       invokeRestart <- base::invokeRestart
[16:21:49.470]                       is.null <- base::is.null
[16:21:49.470]                       muffled <- FALSE
[16:21:49.470]                       if (inherits(cond, "message")) {
[16:21:49.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.470]                         if (muffled) 
[16:21:49.470]                           invokeRestart("muffleMessage")
[16:21:49.470]                       }
[16:21:49.470]                       else if (inherits(cond, "warning")) {
[16:21:49.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.470]                         if (muffled) 
[16:21:49.470]                           invokeRestart("muffleWarning")
[16:21:49.470]                       }
[16:21:49.470]                       else if (inherits(cond, "condition")) {
[16:21:49.470]                         if (!is.null(pattern)) {
[16:21:49.470]                           computeRestarts <- base::computeRestarts
[16:21:49.470]                           grepl <- base::grepl
[16:21:49.470]                           restarts <- computeRestarts(cond)
[16:21:49.470]                           for (restart in restarts) {
[16:21:49.470]                             name <- restart$name
[16:21:49.470]                             if (is.null(name)) 
[16:21:49.470]                               next
[16:21:49.470]                             if (!grepl(pattern, name)) 
[16:21:49.470]                               next
[16:21:49.470]                             invokeRestart(restart)
[16:21:49.470]                             muffled <- TRUE
[16:21:49.470]                             break
[16:21:49.470]                           }
[16:21:49.470]                         }
[16:21:49.470]                       }
[16:21:49.470]                       invisible(muffled)
[16:21:49.470]                     }
[16:21:49.470]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.470]                   }
[16:21:49.470]                 }
[16:21:49.470]                 else {
[16:21:49.470]                   if (TRUE) {
[16:21:49.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.470]                     {
[16:21:49.470]                       inherits <- base::inherits
[16:21:49.470]                       invokeRestart <- base::invokeRestart
[16:21:49.470]                       is.null <- base::is.null
[16:21:49.470]                       muffled <- FALSE
[16:21:49.470]                       if (inherits(cond, "message")) {
[16:21:49.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.470]                         if (muffled) 
[16:21:49.470]                           invokeRestart("muffleMessage")
[16:21:49.470]                       }
[16:21:49.470]                       else if (inherits(cond, "warning")) {
[16:21:49.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.470]                         if (muffled) 
[16:21:49.470]                           invokeRestart("muffleWarning")
[16:21:49.470]                       }
[16:21:49.470]                       else if (inherits(cond, "condition")) {
[16:21:49.470]                         if (!is.null(pattern)) {
[16:21:49.470]                           computeRestarts <- base::computeRestarts
[16:21:49.470]                           grepl <- base::grepl
[16:21:49.470]                           restarts <- computeRestarts(cond)
[16:21:49.470]                           for (restart in restarts) {
[16:21:49.470]                             name <- restart$name
[16:21:49.470]                             if (is.null(name)) 
[16:21:49.470]                               next
[16:21:49.470]                             if (!grepl(pattern, name)) 
[16:21:49.470]                               next
[16:21:49.470]                             invokeRestart(restart)
[16:21:49.470]                             muffled <- TRUE
[16:21:49.470]                             break
[16:21:49.470]                           }
[16:21:49.470]                         }
[16:21:49.470]                       }
[16:21:49.470]                       invisible(muffled)
[16:21:49.470]                     }
[16:21:49.470]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.470]                   }
[16:21:49.470]                 }
[16:21:49.470]             }
[16:21:49.470]         }))
[16:21:49.470]     }, error = function(ex) {
[16:21:49.470]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.470]                 ...future.rng), started = ...future.startTime, 
[16:21:49.470]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.470]             version = "1.8"), class = "FutureResult")
[16:21:49.470]     }, finally = {
[16:21:49.470]         if (!identical(...future.workdir, getwd())) 
[16:21:49.470]             setwd(...future.workdir)
[16:21:49.470]         {
[16:21:49.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.470]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.470]             }
[16:21:49.470]             base::options(...future.oldOptions)
[16:21:49.470]             if (.Platform$OS.type == "windows") {
[16:21:49.470]                 old_names <- names(...future.oldEnvVars)
[16:21:49.470]                 envs <- base::Sys.getenv()
[16:21:49.470]                 names <- names(envs)
[16:21:49.470]                 common <- intersect(names, old_names)
[16:21:49.470]                 added <- setdiff(names, old_names)
[16:21:49.470]                 removed <- setdiff(old_names, names)
[16:21:49.470]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.470]                   envs[common]]
[16:21:49.470]                 NAMES <- toupper(changed)
[16:21:49.470]                 args <- list()
[16:21:49.470]                 for (kk in seq_along(NAMES)) {
[16:21:49.470]                   name <- changed[[kk]]
[16:21:49.470]                   NAME <- NAMES[[kk]]
[16:21:49.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.470]                     next
[16:21:49.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.470]                 }
[16:21:49.470]                 NAMES <- toupper(added)
[16:21:49.470]                 for (kk in seq_along(NAMES)) {
[16:21:49.470]                   name <- added[[kk]]
[16:21:49.470]                   NAME <- NAMES[[kk]]
[16:21:49.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.470]                     next
[16:21:49.470]                   args[[name]] <- ""
[16:21:49.470]                 }
[16:21:49.470]                 NAMES <- toupper(removed)
[16:21:49.470]                 for (kk in seq_along(NAMES)) {
[16:21:49.470]                   name <- removed[[kk]]
[16:21:49.470]                   NAME <- NAMES[[kk]]
[16:21:49.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.470]                     next
[16:21:49.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.470]                 }
[16:21:49.470]                 if (length(args) > 0) 
[16:21:49.470]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.470]             }
[16:21:49.470]             else {
[16:21:49.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.470]             }
[16:21:49.470]             {
[16:21:49.470]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.470]                   0L) {
[16:21:49.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.470]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.470]                   base::options(opts)
[16:21:49.470]                 }
[16:21:49.470]                 {
[16:21:49.470]                   {
[16:21:49.470]                     NULL
[16:21:49.470]                     RNGkind("Mersenne-Twister")
[16:21:49.470]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.470]                       inherits = FALSE)
[16:21:49.470]                   }
[16:21:49.470]                   options(future.plan = NULL)
[16:21:49.470]                   if (is.na(NA_character_)) 
[16:21:49.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.470]                     .init = FALSE)
[16:21:49.470]                 }
[16:21:49.470]             }
[16:21:49.470]         }
[16:21:49.470]     })
[16:21:49.470]     if (TRUE) {
[16:21:49.470]         base::sink(type = "output", split = FALSE)
[16:21:49.470]         if (TRUE) {
[16:21:49.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.470]         }
[16:21:49.470]         else {
[16:21:49.470]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.470]         }
[16:21:49.470]         base::close(...future.stdout)
[16:21:49.470]         ...future.stdout <- NULL
[16:21:49.470]     }
[16:21:49.470]     ...future.result$conditions <- ...future.conditions
[16:21:49.470]     ...future.result$finished <- base::Sys.time()
[16:21:49.470]     ...future.result
[16:21:49.470] }
[16:21:49.472] plan(): Setting new future strategy stack:
[16:21:49.472] List of future strategies:
[16:21:49.472] 1. sequential:
[16:21:49.472]    - args: function (..., envir = parent.frame())
[16:21:49.472]    - tweaked: FALSE
[16:21:49.472]    - call: NULL
[16:21:49.472] plan(): nbrOfWorkers() = 1
[16:21:49.974] plan(): Setting new future strategy stack:
[16:21:49.974] List of future strategies:
[16:21:49.974] 1. sequential:
[16:21:49.974]    - args: function (..., envir = parent.frame())
[16:21:49.974]    - tweaked: FALSE
[16:21:49.974]    - call: plan(strategy)
[16:21:49.975] plan(): nbrOfWorkers() = 1
[16:21:49.975] SequentialFuture started (and completed)
[16:21:49.975] - Launch lazy future ... done
[16:21:49.975] run() for ‘SequentialFuture’ ... done
[16:21:49.976] resolve() on list ...
[16:21:49.976]  recursive: 0
[16:21:49.976]  length: 1
[16:21:49.976] 
[16:21:49.976] resolved() for ‘SequentialFuture’ ...
[16:21:49.976] - state: ‘finished’
[16:21:49.976] - run: TRUE
[16:21:49.976] - result: ‘FutureResult’
[16:21:49.976] resolved() for ‘SequentialFuture’ ... done
[16:21:49.977] Future #1
[16:21:49.977]  length: 0 (resolved future 1)
[16:21:49.977] resolve() on list ... DONE
[16:21:49.977] resolved() for ‘SequentialFuture’ ...
[16:21:49.977] - state: ‘finished’
[16:21:49.977] - run: TRUE
[16:21:49.977] - result: ‘FutureResult’
[16:21:49.977] resolved() for ‘SequentialFuture’ ... done
[16:21:49.977] resolve() on list ...
[16:21:49.977]  recursive: 0
[16:21:49.978]  length: 1
[16:21:49.978] 
[16:21:49.978] resolved() for ‘SequentialFuture’ ...
[16:21:49.978] - state: ‘finished’
[16:21:49.978] - run: TRUE
[16:21:49.978] - result: ‘FutureResult’
[16:21:49.978] resolved() for ‘SequentialFuture’ ... done
[16:21:49.978] Future #1
[16:21:49.978]  length: 0 (resolved future 1)
[16:21:49.978] resolve() on list ... DONE
[16:21:49.978] resolved() for ‘SequentialFuture’ ...
[16:21:49.979] - state: ‘finished’
[16:21:49.979] - run: TRUE
[16:21:49.979] - result: ‘FutureResult’
[16:21:49.979] resolved() for ‘SequentialFuture’ ... done
[16:21:49.979] resolve() on list ...
[16:21:49.979]  recursive: 0
[16:21:49.979]  length: 1
[16:21:49.979] 
[16:21:49.979]  length: 0 (resolved future 1)
[16:21:49.979] resolve() on list ... DONE
[16:21:49.980] resolve() on list ...
[16:21:49.980]  recursive: 0
[16:21:49.980]  length: 4
[16:21:49.980] 
[16:21:49.980] resolved() for ‘SequentialFuture’ ...
[16:21:49.982] - state: ‘finished’
[16:21:49.982] - run: TRUE
[16:21:49.982] - result: ‘FutureResult’
[16:21:49.982] resolved() for ‘SequentialFuture’ ... done
[16:21:49.982] Future #1
[16:21:49.983]  length: 3 (resolved future 1)
[16:21:49.983] resolved() for ‘SequentialFuture’ ...
[16:21:49.983] - state: ‘finished’
[16:21:49.983] - run: TRUE
[16:21:49.983] - result: ‘FutureResult’
[16:21:49.983] resolved() for ‘SequentialFuture’ ... done
[16:21:49.983] Future #2
[16:21:49.983]  length: 2 (resolved future 2)
[16:21:49.983]  length: 1 (resolved future 3)
[16:21:49.983]  length: 0 (resolved future 4)
[16:21:49.984] resolve() on list ... DONE
[16:21:49.984] resolve() on list ...
[16:21:49.984]  recursive: 0
[16:21:49.984]  length: 4
[16:21:49.984] 
[16:21:49.984] resolved() for ‘SequentialFuture’ ...
[16:21:49.984] - state: ‘finished’
[16:21:49.984] - run: TRUE
[16:21:49.984] - result: ‘FutureResult’
[16:21:49.984] resolved() for ‘SequentialFuture’ ... done
[16:21:49.985] Future #1
[16:21:49.985]  length: 3 (resolved future 1)
[16:21:49.985] resolved() for ‘SequentialFuture’ ...
[16:21:49.985] - state: ‘finished’
[16:21:49.985] - run: TRUE
[16:21:49.985] - result: ‘FutureResult’
[16:21:49.985] resolved() for ‘SequentialFuture’ ... done
[16:21:49.985] Future #2
[16:21:49.985]  length: 2 (resolved future 2)
[16:21:49.985]  length: 1 (resolved future 3)
[16:21:49.986]  length: 0 (resolved future 4)
[16:21:49.986] resolve() on list ... DONE
[16:21:49.986] resolve() on list ...
[16:21:49.986]  recursive: 0
[16:21:49.986]  length: 1
[16:21:49.986] 
[16:21:49.986]  length: 0 (resolved future 1)
[16:21:49.986] resolve() on list ... DONE
[16:21:49.986] getGlobalsAndPackages() ...
[16:21:49.987] Searching for globals...
[16:21:49.988] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:49.988] Searching for globals ... DONE
[16:21:49.988] Resolving globals: FALSE
[16:21:49.989] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:49.989] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:49.989] - globals: [1] ‘kk’
[16:21:49.989] 
[16:21:49.989] getGlobalsAndPackages() ... DONE
[16:21:49.990] run() for ‘Future’ ...
[16:21:49.990] - state: ‘created’
[16:21:49.990] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:49.990] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:49.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:49.990]   - Field: ‘label’
[16:21:49.990]   - Field: ‘local’
[16:21:49.991]   - Field: ‘owner’
[16:21:49.991]   - Field: ‘envir’
[16:21:49.991]   - Field: ‘packages’
[16:21:49.991]   - Field: ‘gc’
[16:21:49.991]   - Field: ‘conditions’
[16:21:49.991]   - Field: ‘expr’
[16:21:49.991]   - Field: ‘uuid’
[16:21:49.991]   - Field: ‘seed’
[16:21:49.991]   - Field: ‘version’
[16:21:49.991]   - Field: ‘result’
[16:21:49.991]   - Field: ‘asynchronous’
[16:21:49.992]   - Field: ‘calls’
[16:21:49.992]   - Field: ‘globals’
[16:21:49.992]   - Field: ‘stdout’
[16:21:49.992]   - Field: ‘earlySignal’
[16:21:49.992]   - Field: ‘lazy’
[16:21:49.992]   - Field: ‘state’
[16:21:49.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:49.992] - Launch lazy future ...
[16:21:49.992] Packages needed by the future expression (n = 0): <none>
[16:21:49.993] Packages needed by future strategies (n = 0): <none>
[16:21:49.993] {
[16:21:49.993]     {
[16:21:49.993]         {
[16:21:49.993]             ...future.startTime <- base::Sys.time()
[16:21:49.993]             {
[16:21:49.993]                 {
[16:21:49.993]                   {
[16:21:49.993]                     base::local({
[16:21:49.993]                       has_future <- base::requireNamespace("future", 
[16:21:49.993]                         quietly = TRUE)
[16:21:49.993]                       if (has_future) {
[16:21:49.993]                         ns <- base::getNamespace("future")
[16:21:49.993]                         version <- ns[[".package"]][["version"]]
[16:21:49.993]                         if (is.null(version)) 
[16:21:49.993]                           version <- utils::packageVersion("future")
[16:21:49.993]                       }
[16:21:49.993]                       else {
[16:21:49.993]                         version <- NULL
[16:21:49.993]                       }
[16:21:49.993]                       if (!has_future || version < "1.8.0") {
[16:21:49.993]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:49.993]                           "", base::R.version$version.string), 
[16:21:49.993]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:49.993]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:49.993]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:49.993]                             "release", "version")], collapse = " "), 
[16:21:49.993]                           hostname = base::Sys.info()[["nodename"]])
[16:21:49.993]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:49.993]                           info)
[16:21:49.993]                         info <- base::paste(info, collapse = "; ")
[16:21:49.993]                         if (!has_future) {
[16:21:49.993]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:49.993]                             info)
[16:21:49.993]                         }
[16:21:49.993]                         else {
[16:21:49.993]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:49.993]                             info, version)
[16:21:49.993]                         }
[16:21:49.993]                         base::stop(msg)
[16:21:49.993]                       }
[16:21:49.993]                     })
[16:21:49.993]                   }
[16:21:49.993]                   ...future.strategy.old <- future::plan("list")
[16:21:49.993]                   options(future.plan = NULL)
[16:21:49.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:49.993]                 }
[16:21:49.993]                 ...future.workdir <- getwd()
[16:21:49.993]             }
[16:21:49.993]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:49.993]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:49.993]         }
[16:21:49.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:49.993]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:49.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:49.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:49.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:49.993]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:49.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:49.993]             base::names(...future.oldOptions))
[16:21:49.993]     }
[16:21:49.993]     if (FALSE) {
[16:21:49.993]     }
[16:21:49.993]     else {
[16:21:49.993]         if (TRUE) {
[16:21:49.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:49.993]                 open = "w")
[16:21:49.993]         }
[16:21:49.993]         else {
[16:21:49.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:49.993]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:49.993]         }
[16:21:49.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:49.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:49.993]             base::sink(type = "output", split = FALSE)
[16:21:49.993]             base::close(...future.stdout)
[16:21:49.993]         }, add = TRUE)
[16:21:49.993]     }
[16:21:49.993]     ...future.frame <- base::sys.nframe()
[16:21:49.993]     ...future.conditions <- base::list()
[16:21:49.993]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:49.993]     if (FALSE) {
[16:21:49.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:49.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:49.993]     }
[16:21:49.993]     ...future.result <- base::tryCatch({
[16:21:49.993]         base::withCallingHandlers({
[16:21:49.993]             ...future.value <- base::withVisible(base::local({
[16:21:49.993]                 Sys.sleep(0.1)
[16:21:49.993]                 kk
[16:21:49.993]             }))
[16:21:49.993]             future::FutureResult(value = ...future.value$value, 
[16:21:49.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.993]                   ...future.rng), globalenv = if (FALSE) 
[16:21:49.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:49.993]                     ...future.globalenv.names))
[16:21:49.993]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:49.993]         }, condition = base::local({
[16:21:49.993]             c <- base::c
[16:21:49.993]             inherits <- base::inherits
[16:21:49.993]             invokeRestart <- base::invokeRestart
[16:21:49.993]             length <- base::length
[16:21:49.993]             list <- base::list
[16:21:49.993]             seq.int <- base::seq.int
[16:21:49.993]             signalCondition <- base::signalCondition
[16:21:49.993]             sys.calls <- base::sys.calls
[16:21:49.993]             `[[` <- base::`[[`
[16:21:49.993]             `+` <- base::`+`
[16:21:49.993]             `<<-` <- base::`<<-`
[16:21:49.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:49.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:49.993]                   3L)]
[16:21:49.993]             }
[16:21:49.993]             function(cond) {
[16:21:49.993]                 is_error <- inherits(cond, "error")
[16:21:49.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:49.993]                   NULL)
[16:21:49.993]                 if (is_error) {
[16:21:49.993]                   sessionInformation <- function() {
[16:21:49.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:49.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:49.993]                       search = base::search(), system = base::Sys.info())
[16:21:49.993]                   }
[16:21:49.993]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:49.993]                     cond$call), session = sessionInformation(), 
[16:21:49.993]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:49.993]                   signalCondition(cond)
[16:21:49.993]                 }
[16:21:49.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:49.993]                 "immediateCondition"))) {
[16:21:49.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:49.993]                   ...future.conditions[[length(...future.conditions) + 
[16:21:49.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:49.993]                   if (TRUE && !signal) {
[16:21:49.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.993]                     {
[16:21:49.993]                       inherits <- base::inherits
[16:21:49.993]                       invokeRestart <- base::invokeRestart
[16:21:49.993]                       is.null <- base::is.null
[16:21:49.993]                       muffled <- FALSE
[16:21:49.993]                       if (inherits(cond, "message")) {
[16:21:49.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.993]                         if (muffled) 
[16:21:49.993]                           invokeRestart("muffleMessage")
[16:21:49.993]                       }
[16:21:49.993]                       else if (inherits(cond, "warning")) {
[16:21:49.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.993]                         if (muffled) 
[16:21:49.993]                           invokeRestart("muffleWarning")
[16:21:49.993]                       }
[16:21:49.993]                       else if (inherits(cond, "condition")) {
[16:21:49.993]                         if (!is.null(pattern)) {
[16:21:49.993]                           computeRestarts <- base::computeRestarts
[16:21:49.993]                           grepl <- base::grepl
[16:21:49.993]                           restarts <- computeRestarts(cond)
[16:21:49.993]                           for (restart in restarts) {
[16:21:49.993]                             name <- restart$name
[16:21:49.993]                             if (is.null(name)) 
[16:21:49.993]                               next
[16:21:49.993]                             if (!grepl(pattern, name)) 
[16:21:49.993]                               next
[16:21:49.993]                             invokeRestart(restart)
[16:21:49.993]                             muffled <- TRUE
[16:21:49.993]                             break
[16:21:49.993]                           }
[16:21:49.993]                         }
[16:21:49.993]                       }
[16:21:49.993]                       invisible(muffled)
[16:21:49.993]                     }
[16:21:49.993]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.993]                   }
[16:21:49.993]                 }
[16:21:49.993]                 else {
[16:21:49.993]                   if (TRUE) {
[16:21:49.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:49.993]                     {
[16:21:49.993]                       inherits <- base::inherits
[16:21:49.993]                       invokeRestart <- base::invokeRestart
[16:21:49.993]                       is.null <- base::is.null
[16:21:49.993]                       muffled <- FALSE
[16:21:49.993]                       if (inherits(cond, "message")) {
[16:21:49.993]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:49.993]                         if (muffled) 
[16:21:49.993]                           invokeRestart("muffleMessage")
[16:21:49.993]                       }
[16:21:49.993]                       else if (inherits(cond, "warning")) {
[16:21:49.993]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:49.993]                         if (muffled) 
[16:21:49.993]                           invokeRestart("muffleWarning")
[16:21:49.993]                       }
[16:21:49.993]                       else if (inherits(cond, "condition")) {
[16:21:49.993]                         if (!is.null(pattern)) {
[16:21:49.993]                           computeRestarts <- base::computeRestarts
[16:21:49.993]                           grepl <- base::grepl
[16:21:49.993]                           restarts <- computeRestarts(cond)
[16:21:49.993]                           for (restart in restarts) {
[16:21:49.993]                             name <- restart$name
[16:21:49.993]                             if (is.null(name)) 
[16:21:49.993]                               next
[16:21:49.993]                             if (!grepl(pattern, name)) 
[16:21:49.993]                               next
[16:21:49.993]                             invokeRestart(restart)
[16:21:49.993]                             muffled <- TRUE
[16:21:49.993]                             break
[16:21:49.993]                           }
[16:21:49.993]                         }
[16:21:49.993]                       }
[16:21:49.993]                       invisible(muffled)
[16:21:49.993]                     }
[16:21:49.993]                     muffleCondition(cond, pattern = "^muffle")
[16:21:49.993]                   }
[16:21:49.993]                 }
[16:21:49.993]             }
[16:21:49.993]         }))
[16:21:49.993]     }, error = function(ex) {
[16:21:49.993]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:49.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:49.993]                 ...future.rng), started = ...future.startTime, 
[16:21:49.993]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:49.993]             version = "1.8"), class = "FutureResult")
[16:21:49.993]     }, finally = {
[16:21:49.993]         if (!identical(...future.workdir, getwd())) 
[16:21:49.993]             setwd(...future.workdir)
[16:21:49.993]         {
[16:21:49.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:49.993]                 ...future.oldOptions$nwarnings <- NULL
[16:21:49.993]             }
[16:21:49.993]             base::options(...future.oldOptions)
[16:21:49.993]             if (.Platform$OS.type == "windows") {
[16:21:49.993]                 old_names <- names(...future.oldEnvVars)
[16:21:49.993]                 envs <- base::Sys.getenv()
[16:21:49.993]                 names <- names(envs)
[16:21:49.993]                 common <- intersect(names, old_names)
[16:21:49.993]                 added <- setdiff(names, old_names)
[16:21:49.993]                 removed <- setdiff(old_names, names)
[16:21:49.993]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:49.993]                   envs[common]]
[16:21:49.993]                 NAMES <- toupper(changed)
[16:21:49.993]                 args <- list()
[16:21:49.993]                 for (kk in seq_along(NAMES)) {
[16:21:49.993]                   name <- changed[[kk]]
[16:21:49.993]                   NAME <- NAMES[[kk]]
[16:21:49.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.993]                     next
[16:21:49.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.993]                 }
[16:21:49.993]                 NAMES <- toupper(added)
[16:21:49.993]                 for (kk in seq_along(NAMES)) {
[16:21:49.993]                   name <- added[[kk]]
[16:21:49.993]                   NAME <- NAMES[[kk]]
[16:21:49.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.993]                     next
[16:21:49.993]                   args[[name]] <- ""
[16:21:49.993]                 }
[16:21:49.993]                 NAMES <- toupper(removed)
[16:21:49.993]                 for (kk in seq_along(NAMES)) {
[16:21:49.993]                   name <- removed[[kk]]
[16:21:49.993]                   NAME <- NAMES[[kk]]
[16:21:49.993]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:49.993]                     next
[16:21:49.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:49.993]                 }
[16:21:49.993]                 if (length(args) > 0) 
[16:21:49.993]                   base::do.call(base::Sys.setenv, args = args)
[16:21:49.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:49.993]             }
[16:21:49.993]             else {
[16:21:49.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:49.993]             }
[16:21:49.993]             {
[16:21:49.993]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:49.993]                   0L) {
[16:21:49.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:49.993]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:49.993]                   base::options(opts)
[16:21:49.993]                 }
[16:21:49.993]                 {
[16:21:49.993]                   {
[16:21:49.993]                     NULL
[16:21:49.993]                     RNGkind("Mersenne-Twister")
[16:21:49.993]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:49.993]                       inherits = FALSE)
[16:21:49.993]                   }
[16:21:49.993]                   options(future.plan = NULL)
[16:21:49.993]                   if (is.na(NA_character_)) 
[16:21:49.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:49.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:49.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:49.993]                     .init = FALSE)
[16:21:49.993]                 }
[16:21:49.993]             }
[16:21:49.993]         }
[16:21:49.993]     })
[16:21:49.993]     if (TRUE) {
[16:21:49.993]         base::sink(type = "output", split = FALSE)
[16:21:49.993]         if (TRUE) {
[16:21:49.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:49.993]         }
[16:21:49.993]         else {
[16:21:49.993]             ...future.result["stdout"] <- base::list(NULL)
[16:21:49.993]         }
[16:21:49.993]         base::close(...future.stdout)
[16:21:49.993]         ...future.stdout <- NULL
[16:21:49.993]     }
[16:21:49.993]     ...future.result$conditions <- ...future.conditions
[16:21:49.993]     ...future.result$finished <- base::Sys.time()
[16:21:49.993]     ...future.result
[16:21:49.993] }
[16:21:49.995] assign_globals() ...
[16:21:49.995] List of 1
[16:21:49.995]  $ kk: int 1
[16:21:49.995]  - attr(*, "where")=List of 1
[16:21:49.995]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:49.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:49.995]  - attr(*, "resolved")= logi FALSE
[16:21:49.995]  - attr(*, "total_size")= num 56
[16:21:49.995]  - attr(*, "already-done")= logi TRUE
[16:21:50.000] - copied ‘kk’ to environment
[16:21:50.000] assign_globals() ... done
[16:21:50.000] plan(): Setting new future strategy stack:
[16:21:50.000] List of future strategies:
[16:21:50.000] 1. sequential:
[16:21:50.000]    - args: function (..., envir = parent.frame())
[16:21:50.000]    - tweaked: FALSE
[16:21:50.000]    - call: NULL
[16:21:50.000] plan(): nbrOfWorkers() = 1
[16:21:50.101] plan(): Setting new future strategy stack:
[16:21:50.102] List of future strategies:
[16:21:50.102] 1. sequential:
[16:21:50.102]    - args: function (..., envir = parent.frame())
[16:21:50.102]    - tweaked: FALSE
[16:21:50.102]    - call: plan(strategy)
[16:21:50.102] plan(): nbrOfWorkers() = 1
[16:21:50.102] SequentialFuture started (and completed)
[16:21:50.102] - Launch lazy future ... done
[16:21:50.102] run() for ‘SequentialFuture’ ... done
[16:21:50.103] getGlobalsAndPackages() ...
[16:21:50.103] Searching for globals...
[16:21:50.104] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:50.104] Searching for globals ... DONE
[16:21:50.104] Resolving globals: FALSE
[16:21:50.104] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:50.105] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:50.105] - globals: [1] ‘kk’
[16:21:50.105] 
[16:21:50.105] getGlobalsAndPackages() ... DONE
[16:21:50.105] run() for ‘Future’ ...
[16:21:50.105] - state: ‘created’
[16:21:50.105] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.106]   - Field: ‘label’
[16:21:50.106]   - Field: ‘local’
[16:21:50.106]   - Field: ‘owner’
[16:21:50.106]   - Field: ‘envir’
[16:21:50.106]   - Field: ‘packages’
[16:21:50.106]   - Field: ‘gc’
[16:21:50.106]   - Field: ‘conditions’
[16:21:50.107]   - Field: ‘expr’
[16:21:50.107]   - Field: ‘uuid’
[16:21:50.107]   - Field: ‘seed’
[16:21:50.107]   - Field: ‘version’
[16:21:50.107]   - Field: ‘result’
[16:21:50.107]   - Field: ‘asynchronous’
[16:21:50.107]   - Field: ‘calls’
[16:21:50.107]   - Field: ‘globals’
[16:21:50.107]   - Field: ‘stdout’
[16:21:50.107]   - Field: ‘earlySignal’
[16:21:50.107]   - Field: ‘lazy’
[16:21:50.108]   - Field: ‘state’
[16:21:50.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.108] - Launch lazy future ...
[16:21:50.108] Packages needed by the future expression (n = 0): <none>
[16:21:50.108] Packages needed by future strategies (n = 0): <none>
[16:21:50.108] {
[16:21:50.108]     {
[16:21:50.108]         {
[16:21:50.108]             ...future.startTime <- base::Sys.time()
[16:21:50.108]             {
[16:21:50.108]                 {
[16:21:50.108]                   {
[16:21:50.108]                     base::local({
[16:21:50.108]                       has_future <- base::requireNamespace("future", 
[16:21:50.108]                         quietly = TRUE)
[16:21:50.108]                       if (has_future) {
[16:21:50.108]                         ns <- base::getNamespace("future")
[16:21:50.108]                         version <- ns[[".package"]][["version"]]
[16:21:50.108]                         if (is.null(version)) 
[16:21:50.108]                           version <- utils::packageVersion("future")
[16:21:50.108]                       }
[16:21:50.108]                       else {
[16:21:50.108]                         version <- NULL
[16:21:50.108]                       }
[16:21:50.108]                       if (!has_future || version < "1.8.0") {
[16:21:50.108]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.108]                           "", base::R.version$version.string), 
[16:21:50.108]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.108]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.108]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.108]                             "release", "version")], collapse = " "), 
[16:21:50.108]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.108]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.108]                           info)
[16:21:50.108]                         info <- base::paste(info, collapse = "; ")
[16:21:50.108]                         if (!has_future) {
[16:21:50.108]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.108]                             info)
[16:21:50.108]                         }
[16:21:50.108]                         else {
[16:21:50.108]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.108]                             info, version)
[16:21:50.108]                         }
[16:21:50.108]                         base::stop(msg)
[16:21:50.108]                       }
[16:21:50.108]                     })
[16:21:50.108]                   }
[16:21:50.108]                   ...future.strategy.old <- future::plan("list")
[16:21:50.108]                   options(future.plan = NULL)
[16:21:50.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.108]                 }
[16:21:50.108]                 ...future.workdir <- getwd()
[16:21:50.108]             }
[16:21:50.108]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.108]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.108]         }
[16:21:50.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.108]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.108]             base::names(...future.oldOptions))
[16:21:50.108]     }
[16:21:50.108]     if (FALSE) {
[16:21:50.108]     }
[16:21:50.108]     else {
[16:21:50.108]         if (TRUE) {
[16:21:50.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.108]                 open = "w")
[16:21:50.108]         }
[16:21:50.108]         else {
[16:21:50.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.108]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.108]         }
[16:21:50.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.108]             base::sink(type = "output", split = FALSE)
[16:21:50.108]             base::close(...future.stdout)
[16:21:50.108]         }, add = TRUE)
[16:21:50.108]     }
[16:21:50.108]     ...future.frame <- base::sys.nframe()
[16:21:50.108]     ...future.conditions <- base::list()
[16:21:50.108]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.108]     if (FALSE) {
[16:21:50.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.108]     }
[16:21:50.108]     ...future.result <- base::tryCatch({
[16:21:50.108]         base::withCallingHandlers({
[16:21:50.108]             ...future.value <- base::withVisible(base::local({
[16:21:50.108]                 Sys.sleep(0.1)
[16:21:50.108]                 kk
[16:21:50.108]             }))
[16:21:50.108]             future::FutureResult(value = ...future.value$value, 
[16:21:50.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.108]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.108]                     ...future.globalenv.names))
[16:21:50.108]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.108]         }, condition = base::local({
[16:21:50.108]             c <- base::c
[16:21:50.108]             inherits <- base::inherits
[16:21:50.108]             invokeRestart <- base::invokeRestart
[16:21:50.108]             length <- base::length
[16:21:50.108]             list <- base::list
[16:21:50.108]             seq.int <- base::seq.int
[16:21:50.108]             signalCondition <- base::signalCondition
[16:21:50.108]             sys.calls <- base::sys.calls
[16:21:50.108]             `[[` <- base::`[[`
[16:21:50.108]             `+` <- base::`+`
[16:21:50.108]             `<<-` <- base::`<<-`
[16:21:50.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.108]                   3L)]
[16:21:50.108]             }
[16:21:50.108]             function(cond) {
[16:21:50.108]                 is_error <- inherits(cond, "error")
[16:21:50.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.108]                   NULL)
[16:21:50.108]                 if (is_error) {
[16:21:50.108]                   sessionInformation <- function() {
[16:21:50.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.108]                       search = base::search(), system = base::Sys.info())
[16:21:50.108]                   }
[16:21:50.108]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.108]                     cond$call), session = sessionInformation(), 
[16:21:50.108]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.108]                   signalCondition(cond)
[16:21:50.108]                 }
[16:21:50.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.108]                 "immediateCondition"))) {
[16:21:50.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.108]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.108]                   if (TRUE && !signal) {
[16:21:50.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.108]                     {
[16:21:50.108]                       inherits <- base::inherits
[16:21:50.108]                       invokeRestart <- base::invokeRestart
[16:21:50.108]                       is.null <- base::is.null
[16:21:50.108]                       muffled <- FALSE
[16:21:50.108]                       if (inherits(cond, "message")) {
[16:21:50.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.108]                         if (muffled) 
[16:21:50.108]                           invokeRestart("muffleMessage")
[16:21:50.108]                       }
[16:21:50.108]                       else if (inherits(cond, "warning")) {
[16:21:50.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.108]                         if (muffled) 
[16:21:50.108]                           invokeRestart("muffleWarning")
[16:21:50.108]                       }
[16:21:50.108]                       else if (inherits(cond, "condition")) {
[16:21:50.108]                         if (!is.null(pattern)) {
[16:21:50.108]                           computeRestarts <- base::computeRestarts
[16:21:50.108]                           grepl <- base::grepl
[16:21:50.108]                           restarts <- computeRestarts(cond)
[16:21:50.108]                           for (restart in restarts) {
[16:21:50.108]                             name <- restart$name
[16:21:50.108]                             if (is.null(name)) 
[16:21:50.108]                               next
[16:21:50.108]                             if (!grepl(pattern, name)) 
[16:21:50.108]                               next
[16:21:50.108]                             invokeRestart(restart)
[16:21:50.108]                             muffled <- TRUE
[16:21:50.108]                             break
[16:21:50.108]                           }
[16:21:50.108]                         }
[16:21:50.108]                       }
[16:21:50.108]                       invisible(muffled)
[16:21:50.108]                     }
[16:21:50.108]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.108]                   }
[16:21:50.108]                 }
[16:21:50.108]                 else {
[16:21:50.108]                   if (TRUE) {
[16:21:50.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.108]                     {
[16:21:50.108]                       inherits <- base::inherits
[16:21:50.108]                       invokeRestart <- base::invokeRestart
[16:21:50.108]                       is.null <- base::is.null
[16:21:50.108]                       muffled <- FALSE
[16:21:50.108]                       if (inherits(cond, "message")) {
[16:21:50.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.108]                         if (muffled) 
[16:21:50.108]                           invokeRestart("muffleMessage")
[16:21:50.108]                       }
[16:21:50.108]                       else if (inherits(cond, "warning")) {
[16:21:50.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.108]                         if (muffled) 
[16:21:50.108]                           invokeRestart("muffleWarning")
[16:21:50.108]                       }
[16:21:50.108]                       else if (inherits(cond, "condition")) {
[16:21:50.108]                         if (!is.null(pattern)) {
[16:21:50.108]                           computeRestarts <- base::computeRestarts
[16:21:50.108]                           grepl <- base::grepl
[16:21:50.108]                           restarts <- computeRestarts(cond)
[16:21:50.108]                           for (restart in restarts) {
[16:21:50.108]                             name <- restart$name
[16:21:50.108]                             if (is.null(name)) 
[16:21:50.108]                               next
[16:21:50.108]                             if (!grepl(pattern, name)) 
[16:21:50.108]                               next
[16:21:50.108]                             invokeRestart(restart)
[16:21:50.108]                             muffled <- TRUE
[16:21:50.108]                             break
[16:21:50.108]                           }
[16:21:50.108]                         }
[16:21:50.108]                       }
[16:21:50.108]                       invisible(muffled)
[16:21:50.108]                     }
[16:21:50.108]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.108]                   }
[16:21:50.108]                 }
[16:21:50.108]             }
[16:21:50.108]         }))
[16:21:50.108]     }, error = function(ex) {
[16:21:50.108]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.108]                 ...future.rng), started = ...future.startTime, 
[16:21:50.108]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.108]             version = "1.8"), class = "FutureResult")
[16:21:50.108]     }, finally = {
[16:21:50.108]         if (!identical(...future.workdir, getwd())) 
[16:21:50.108]             setwd(...future.workdir)
[16:21:50.108]         {
[16:21:50.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.108]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.108]             }
[16:21:50.108]             base::options(...future.oldOptions)
[16:21:50.108]             if (.Platform$OS.type == "windows") {
[16:21:50.108]                 old_names <- names(...future.oldEnvVars)
[16:21:50.108]                 envs <- base::Sys.getenv()
[16:21:50.108]                 names <- names(envs)
[16:21:50.108]                 common <- intersect(names, old_names)
[16:21:50.108]                 added <- setdiff(names, old_names)
[16:21:50.108]                 removed <- setdiff(old_names, names)
[16:21:50.108]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.108]                   envs[common]]
[16:21:50.108]                 NAMES <- toupper(changed)
[16:21:50.108]                 args <- list()
[16:21:50.108]                 for (kk in seq_along(NAMES)) {
[16:21:50.108]                   name <- changed[[kk]]
[16:21:50.108]                   NAME <- NAMES[[kk]]
[16:21:50.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.108]                     next
[16:21:50.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.108]                 }
[16:21:50.108]                 NAMES <- toupper(added)
[16:21:50.108]                 for (kk in seq_along(NAMES)) {
[16:21:50.108]                   name <- added[[kk]]
[16:21:50.108]                   NAME <- NAMES[[kk]]
[16:21:50.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.108]                     next
[16:21:50.108]                   args[[name]] <- ""
[16:21:50.108]                 }
[16:21:50.108]                 NAMES <- toupper(removed)
[16:21:50.108]                 for (kk in seq_along(NAMES)) {
[16:21:50.108]                   name <- removed[[kk]]
[16:21:50.108]                   NAME <- NAMES[[kk]]
[16:21:50.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.108]                     next
[16:21:50.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.108]                 }
[16:21:50.108]                 if (length(args) > 0) 
[16:21:50.108]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.108]             }
[16:21:50.108]             else {
[16:21:50.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.108]             }
[16:21:50.108]             {
[16:21:50.108]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.108]                   0L) {
[16:21:50.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.108]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.108]                   base::options(opts)
[16:21:50.108]                 }
[16:21:50.108]                 {
[16:21:50.108]                   {
[16:21:50.108]                     NULL
[16:21:50.108]                     RNGkind("Mersenne-Twister")
[16:21:50.108]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.108]                       inherits = FALSE)
[16:21:50.108]                   }
[16:21:50.108]                   options(future.plan = NULL)
[16:21:50.108]                   if (is.na(NA_character_)) 
[16:21:50.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.108]                     .init = FALSE)
[16:21:50.108]                 }
[16:21:50.108]             }
[16:21:50.108]         }
[16:21:50.108]     })
[16:21:50.108]     if (TRUE) {
[16:21:50.108]         base::sink(type = "output", split = FALSE)
[16:21:50.108]         if (TRUE) {
[16:21:50.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.108]         }
[16:21:50.108]         else {
[16:21:50.108]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.108]         }
[16:21:50.108]         base::close(...future.stdout)
[16:21:50.108]         ...future.stdout <- NULL
[16:21:50.108]     }
[16:21:50.108]     ...future.result$conditions <- ...future.conditions
[16:21:50.108]     ...future.result$finished <- base::Sys.time()
[16:21:50.108]     ...future.result
[16:21:50.108] }
[16:21:50.110] assign_globals() ...
[16:21:50.110] List of 1
[16:21:50.110]  $ kk: int 2
[16:21:50.110]  - attr(*, "where")=List of 1
[16:21:50.110]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:50.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:50.110]  - attr(*, "resolved")= logi FALSE
[16:21:50.110]  - attr(*, "total_size")= num 56
[16:21:50.110]  - attr(*, "already-done")= logi TRUE
[16:21:50.114] - copied ‘kk’ to environment
[16:21:50.115] assign_globals() ... done
[16:21:50.115] plan(): Setting new future strategy stack:
[16:21:50.115] List of future strategies:
[16:21:50.115] 1. sequential:
[16:21:50.115]    - args: function (..., envir = parent.frame())
[16:21:50.115]    - tweaked: FALSE
[16:21:50.115]    - call: NULL
[16:21:50.115] plan(): nbrOfWorkers() = 1
[16:21:50.216] plan(): Setting new future strategy stack:
[16:21:50.217] List of future strategies:
[16:21:50.217] 1. sequential:
[16:21:50.217]    - args: function (..., envir = parent.frame())
[16:21:50.217]    - tweaked: FALSE
[16:21:50.217]    - call: plan(strategy)
[16:21:50.217] plan(): nbrOfWorkers() = 1
[16:21:50.217] SequentialFuture started (and completed)
[16:21:50.217] - Launch lazy future ... done
[16:21:50.217] run() for ‘SequentialFuture’ ... done
[16:21:50.218] getGlobalsAndPackages() ...
[16:21:50.218] Searching for globals...
[16:21:50.219] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:50.219] Searching for globals ... DONE
[16:21:50.219] Resolving globals: FALSE
[16:21:50.219] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:50.220] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:50.220] - globals: [1] ‘kk’
[16:21:50.220] 
[16:21:50.220] getGlobalsAndPackages() ... DONE
[16:21:50.220] run() for ‘Future’ ...
[16:21:50.220] - state: ‘created’
[16:21:50.221] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.221] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.221] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.221]   - Field: ‘label’
[16:21:50.221]   - Field: ‘local’
[16:21:50.221]   - Field: ‘owner’
[16:21:50.221]   - Field: ‘envir’
[16:21:50.221]   - Field: ‘packages’
[16:21:50.221]   - Field: ‘gc’
[16:21:50.222]   - Field: ‘conditions’
[16:21:50.222]   - Field: ‘expr’
[16:21:50.222]   - Field: ‘uuid’
[16:21:50.222]   - Field: ‘seed’
[16:21:50.222]   - Field: ‘version’
[16:21:50.222]   - Field: ‘result’
[16:21:50.222]   - Field: ‘asynchronous’
[16:21:50.222]   - Field: ‘calls’
[16:21:50.222]   - Field: ‘globals’
[16:21:50.222]   - Field: ‘stdout’
[16:21:50.222]   - Field: ‘earlySignal’
[16:21:50.223]   - Field: ‘lazy’
[16:21:50.223]   - Field: ‘state’
[16:21:50.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.223] - Launch lazy future ...
[16:21:50.223] Packages needed by the future expression (n = 0): <none>
[16:21:50.223] Packages needed by future strategies (n = 0): <none>
[16:21:50.224] {
[16:21:50.224]     {
[16:21:50.224]         {
[16:21:50.224]             ...future.startTime <- base::Sys.time()
[16:21:50.224]             {
[16:21:50.224]                 {
[16:21:50.224]                   {
[16:21:50.224]                     base::local({
[16:21:50.224]                       has_future <- base::requireNamespace("future", 
[16:21:50.224]                         quietly = TRUE)
[16:21:50.224]                       if (has_future) {
[16:21:50.224]                         ns <- base::getNamespace("future")
[16:21:50.224]                         version <- ns[[".package"]][["version"]]
[16:21:50.224]                         if (is.null(version)) 
[16:21:50.224]                           version <- utils::packageVersion("future")
[16:21:50.224]                       }
[16:21:50.224]                       else {
[16:21:50.224]                         version <- NULL
[16:21:50.224]                       }
[16:21:50.224]                       if (!has_future || version < "1.8.0") {
[16:21:50.224]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.224]                           "", base::R.version$version.string), 
[16:21:50.224]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.224]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.224]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.224]                             "release", "version")], collapse = " "), 
[16:21:50.224]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.224]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.224]                           info)
[16:21:50.224]                         info <- base::paste(info, collapse = "; ")
[16:21:50.224]                         if (!has_future) {
[16:21:50.224]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.224]                             info)
[16:21:50.224]                         }
[16:21:50.224]                         else {
[16:21:50.224]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.224]                             info, version)
[16:21:50.224]                         }
[16:21:50.224]                         base::stop(msg)
[16:21:50.224]                       }
[16:21:50.224]                     })
[16:21:50.224]                   }
[16:21:50.224]                   ...future.strategy.old <- future::plan("list")
[16:21:50.224]                   options(future.plan = NULL)
[16:21:50.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.224]                 }
[16:21:50.224]                 ...future.workdir <- getwd()
[16:21:50.224]             }
[16:21:50.224]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.224]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.224]         }
[16:21:50.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.224]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.224]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.224]             base::names(...future.oldOptions))
[16:21:50.224]     }
[16:21:50.224]     if (FALSE) {
[16:21:50.224]     }
[16:21:50.224]     else {
[16:21:50.224]         if (TRUE) {
[16:21:50.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.224]                 open = "w")
[16:21:50.224]         }
[16:21:50.224]         else {
[16:21:50.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.224]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.224]         }
[16:21:50.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.224]             base::sink(type = "output", split = FALSE)
[16:21:50.224]             base::close(...future.stdout)
[16:21:50.224]         }, add = TRUE)
[16:21:50.224]     }
[16:21:50.224]     ...future.frame <- base::sys.nframe()
[16:21:50.224]     ...future.conditions <- base::list()
[16:21:50.224]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.224]     if (FALSE) {
[16:21:50.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.224]     }
[16:21:50.224]     ...future.result <- base::tryCatch({
[16:21:50.224]         base::withCallingHandlers({
[16:21:50.224]             ...future.value <- base::withVisible(base::local({
[16:21:50.224]                 Sys.sleep(0.1)
[16:21:50.224]                 kk
[16:21:50.224]             }))
[16:21:50.224]             future::FutureResult(value = ...future.value$value, 
[16:21:50.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.224]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.224]                     ...future.globalenv.names))
[16:21:50.224]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.224]         }, condition = base::local({
[16:21:50.224]             c <- base::c
[16:21:50.224]             inherits <- base::inherits
[16:21:50.224]             invokeRestart <- base::invokeRestart
[16:21:50.224]             length <- base::length
[16:21:50.224]             list <- base::list
[16:21:50.224]             seq.int <- base::seq.int
[16:21:50.224]             signalCondition <- base::signalCondition
[16:21:50.224]             sys.calls <- base::sys.calls
[16:21:50.224]             `[[` <- base::`[[`
[16:21:50.224]             `+` <- base::`+`
[16:21:50.224]             `<<-` <- base::`<<-`
[16:21:50.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.224]                   3L)]
[16:21:50.224]             }
[16:21:50.224]             function(cond) {
[16:21:50.224]                 is_error <- inherits(cond, "error")
[16:21:50.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.224]                   NULL)
[16:21:50.224]                 if (is_error) {
[16:21:50.224]                   sessionInformation <- function() {
[16:21:50.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.224]                       search = base::search(), system = base::Sys.info())
[16:21:50.224]                   }
[16:21:50.224]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.224]                     cond$call), session = sessionInformation(), 
[16:21:50.224]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.224]                   signalCondition(cond)
[16:21:50.224]                 }
[16:21:50.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.224]                 "immediateCondition"))) {
[16:21:50.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.224]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.224]                   if (TRUE && !signal) {
[16:21:50.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.224]                     {
[16:21:50.224]                       inherits <- base::inherits
[16:21:50.224]                       invokeRestart <- base::invokeRestart
[16:21:50.224]                       is.null <- base::is.null
[16:21:50.224]                       muffled <- FALSE
[16:21:50.224]                       if (inherits(cond, "message")) {
[16:21:50.224]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.224]                         if (muffled) 
[16:21:50.224]                           invokeRestart("muffleMessage")
[16:21:50.224]                       }
[16:21:50.224]                       else if (inherits(cond, "warning")) {
[16:21:50.224]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.224]                         if (muffled) 
[16:21:50.224]                           invokeRestart("muffleWarning")
[16:21:50.224]                       }
[16:21:50.224]                       else if (inherits(cond, "condition")) {
[16:21:50.224]                         if (!is.null(pattern)) {
[16:21:50.224]                           computeRestarts <- base::computeRestarts
[16:21:50.224]                           grepl <- base::grepl
[16:21:50.224]                           restarts <- computeRestarts(cond)
[16:21:50.224]                           for (restart in restarts) {
[16:21:50.224]                             name <- restart$name
[16:21:50.224]                             if (is.null(name)) 
[16:21:50.224]                               next
[16:21:50.224]                             if (!grepl(pattern, name)) 
[16:21:50.224]                               next
[16:21:50.224]                             invokeRestart(restart)
[16:21:50.224]                             muffled <- TRUE
[16:21:50.224]                             break
[16:21:50.224]                           }
[16:21:50.224]                         }
[16:21:50.224]                       }
[16:21:50.224]                       invisible(muffled)
[16:21:50.224]                     }
[16:21:50.224]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.224]                   }
[16:21:50.224]                 }
[16:21:50.224]                 else {
[16:21:50.224]                   if (TRUE) {
[16:21:50.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.224]                     {
[16:21:50.224]                       inherits <- base::inherits
[16:21:50.224]                       invokeRestart <- base::invokeRestart
[16:21:50.224]                       is.null <- base::is.null
[16:21:50.224]                       muffled <- FALSE
[16:21:50.224]                       if (inherits(cond, "message")) {
[16:21:50.224]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.224]                         if (muffled) 
[16:21:50.224]                           invokeRestart("muffleMessage")
[16:21:50.224]                       }
[16:21:50.224]                       else if (inherits(cond, "warning")) {
[16:21:50.224]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.224]                         if (muffled) 
[16:21:50.224]                           invokeRestart("muffleWarning")
[16:21:50.224]                       }
[16:21:50.224]                       else if (inherits(cond, "condition")) {
[16:21:50.224]                         if (!is.null(pattern)) {
[16:21:50.224]                           computeRestarts <- base::computeRestarts
[16:21:50.224]                           grepl <- base::grepl
[16:21:50.224]                           restarts <- computeRestarts(cond)
[16:21:50.224]                           for (restart in restarts) {
[16:21:50.224]                             name <- restart$name
[16:21:50.224]                             if (is.null(name)) 
[16:21:50.224]                               next
[16:21:50.224]                             if (!grepl(pattern, name)) 
[16:21:50.224]                               next
[16:21:50.224]                             invokeRestart(restart)
[16:21:50.224]                             muffled <- TRUE
[16:21:50.224]                             break
[16:21:50.224]                           }
[16:21:50.224]                         }
[16:21:50.224]                       }
[16:21:50.224]                       invisible(muffled)
[16:21:50.224]                     }
[16:21:50.224]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.224]                   }
[16:21:50.224]                 }
[16:21:50.224]             }
[16:21:50.224]         }))
[16:21:50.224]     }, error = function(ex) {
[16:21:50.224]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.224]                 ...future.rng), started = ...future.startTime, 
[16:21:50.224]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.224]             version = "1.8"), class = "FutureResult")
[16:21:50.224]     }, finally = {
[16:21:50.224]         if (!identical(...future.workdir, getwd())) 
[16:21:50.224]             setwd(...future.workdir)
[16:21:50.224]         {
[16:21:50.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.224]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.224]             }
[16:21:50.224]             base::options(...future.oldOptions)
[16:21:50.224]             if (.Platform$OS.type == "windows") {
[16:21:50.224]                 old_names <- names(...future.oldEnvVars)
[16:21:50.224]                 envs <- base::Sys.getenv()
[16:21:50.224]                 names <- names(envs)
[16:21:50.224]                 common <- intersect(names, old_names)
[16:21:50.224]                 added <- setdiff(names, old_names)
[16:21:50.224]                 removed <- setdiff(old_names, names)
[16:21:50.224]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.224]                   envs[common]]
[16:21:50.224]                 NAMES <- toupper(changed)
[16:21:50.224]                 args <- list()
[16:21:50.224]                 for (kk in seq_along(NAMES)) {
[16:21:50.224]                   name <- changed[[kk]]
[16:21:50.224]                   NAME <- NAMES[[kk]]
[16:21:50.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.224]                     next
[16:21:50.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.224]                 }
[16:21:50.224]                 NAMES <- toupper(added)
[16:21:50.224]                 for (kk in seq_along(NAMES)) {
[16:21:50.224]                   name <- added[[kk]]
[16:21:50.224]                   NAME <- NAMES[[kk]]
[16:21:50.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.224]                     next
[16:21:50.224]                   args[[name]] <- ""
[16:21:50.224]                 }
[16:21:50.224]                 NAMES <- toupper(removed)
[16:21:50.224]                 for (kk in seq_along(NAMES)) {
[16:21:50.224]                   name <- removed[[kk]]
[16:21:50.224]                   NAME <- NAMES[[kk]]
[16:21:50.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.224]                     next
[16:21:50.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.224]                 }
[16:21:50.224]                 if (length(args) > 0) 
[16:21:50.224]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.224]             }
[16:21:50.224]             else {
[16:21:50.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.224]             }
[16:21:50.224]             {
[16:21:50.224]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.224]                   0L) {
[16:21:50.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.224]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.224]                   base::options(opts)
[16:21:50.224]                 }
[16:21:50.224]                 {
[16:21:50.224]                   {
[16:21:50.224]                     NULL
[16:21:50.224]                     RNGkind("Mersenne-Twister")
[16:21:50.224]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.224]                       inherits = FALSE)
[16:21:50.224]                   }
[16:21:50.224]                   options(future.plan = NULL)
[16:21:50.224]                   if (is.na(NA_character_)) 
[16:21:50.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.224]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.224]                     .init = FALSE)
[16:21:50.224]                 }
[16:21:50.224]             }
[16:21:50.224]         }
[16:21:50.224]     })
[16:21:50.224]     if (TRUE) {
[16:21:50.224]         base::sink(type = "output", split = FALSE)
[16:21:50.224]         if (TRUE) {
[16:21:50.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.224]         }
[16:21:50.224]         else {
[16:21:50.224]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.224]         }
[16:21:50.224]         base::close(...future.stdout)
[16:21:50.224]         ...future.stdout <- NULL
[16:21:50.224]     }
[16:21:50.224]     ...future.result$conditions <- ...future.conditions
[16:21:50.224]     ...future.result$finished <- base::Sys.time()
[16:21:50.224]     ...future.result
[16:21:50.224] }
[16:21:50.225] assign_globals() ...
[16:21:50.225] List of 1
[16:21:50.225]  $ kk: int 3
[16:21:50.225]  - attr(*, "where")=List of 1
[16:21:50.225]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:50.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:50.225]  - attr(*, "resolved")= logi FALSE
[16:21:50.225]  - attr(*, "total_size")= num 56
[16:21:50.225]  - attr(*, "already-done")= logi TRUE
[16:21:50.228] - copied ‘kk’ to environment
[16:21:50.228] assign_globals() ... done
[16:21:50.228] plan(): Setting new future strategy stack:
[16:21:50.228] List of future strategies:
[16:21:50.228] 1. sequential:
[16:21:50.228]    - args: function (..., envir = parent.frame())
[16:21:50.228]    - tweaked: FALSE
[16:21:50.228]    - call: NULL
[16:21:50.229] plan(): nbrOfWorkers() = 1
[16:21:50.330] plan(): Setting new future strategy stack:
[16:21:50.330] List of future strategies:
[16:21:50.330] 1. sequential:
[16:21:50.330]    - args: function (..., envir = parent.frame())
[16:21:50.330]    - tweaked: FALSE
[16:21:50.330]    - call: plan(strategy)
[16:21:50.330] plan(): nbrOfWorkers() = 1
[16:21:50.331] SequentialFuture started (and completed)
[16:21:50.331] - Launch lazy future ... done
[16:21:50.331] run() for ‘SequentialFuture’ ... done
[16:21:50.331] resolve() on list ...
[16:21:50.331]  recursive: 0
[16:21:50.331]  length: 3
[16:21:50.331] 
[16:21:50.331] resolved() for ‘SequentialFuture’ ...
[16:21:50.331] - state: ‘finished’
[16:21:50.332] - run: TRUE
[16:21:50.332] - result: ‘FutureResult’
[16:21:50.332] resolved() for ‘SequentialFuture’ ... done
[16:21:50.332] Future #1
[16:21:50.332]  length: 2 (resolved future 1)
[16:21:50.332] resolved() for ‘SequentialFuture’ ...
[16:21:50.332] - state: ‘finished’
[16:21:50.332] - run: TRUE
[16:21:50.332] - result: ‘FutureResult’
[16:21:50.332] resolved() for ‘SequentialFuture’ ... done
[16:21:50.333] Future #2
[16:21:50.333]  length: 1 (resolved future 2)
[16:21:50.333] resolved() for ‘SequentialFuture’ ...
[16:21:50.333] - state: ‘finished’
[16:21:50.333] - run: TRUE
[16:21:50.333] - result: ‘FutureResult’
[16:21:50.333] resolved() for ‘SequentialFuture’ ... done
[16:21:50.333] Future #3
[16:21:50.333]  length: 0 (resolved future 3)
[16:21:50.333] resolve() on list ... DONE
[16:21:50.333] getGlobalsAndPackages() ...
[16:21:50.334] Searching for globals...
[16:21:50.335] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:50.335] Searching for globals ... DONE
[16:21:50.335] Resolving globals: FALSE
[16:21:50.335] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:50.336] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:50.336] - globals: [1] ‘kk’
[16:21:50.336] 
[16:21:50.336] getGlobalsAndPackages() ... DONE
[16:21:50.336] getGlobalsAndPackages() ...
[16:21:50.336] Searching for globals...
[16:21:50.337] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:50.337] Searching for globals ... DONE
[16:21:50.337] Resolving globals: FALSE
[16:21:50.338] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:50.338] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:50.338] - globals: [1] ‘kk’
[16:21:50.338] 
[16:21:50.338] getGlobalsAndPackages() ... DONE
[16:21:50.339] getGlobalsAndPackages() ...
[16:21:50.339] Searching for globals...
[16:21:50.340] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:50.340] Searching for globals ... DONE
[16:21:50.340] Resolving globals: FALSE
[16:21:50.340] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:50.341] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:50.341] - globals: [1] ‘kk’
[16:21:50.341] 
[16:21:50.341] getGlobalsAndPackages() ... DONE
[16:21:50.343] resolve() on list ...
[16:21:50.343]  recursive: 0
[16:21:50.343]  length: 3
[16:21:50.343] 
[16:21:50.343] run() for ‘Future’ ...
[16:21:50.344] - state: ‘created’
[16:21:50.344] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.344] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.344]   - Field: ‘label’
[16:21:50.344]   - Field: ‘local’
[16:21:50.344]   - Field: ‘owner’
[16:21:50.345]   - Field: ‘envir’
[16:21:50.345]   - Field: ‘packages’
[16:21:50.345]   - Field: ‘gc’
[16:21:50.345]   - Field: ‘conditions’
[16:21:50.345]   - Field: ‘expr’
[16:21:50.345]   - Field: ‘uuid’
[16:21:50.345]   - Field: ‘seed’
[16:21:50.345]   - Field: ‘version’
[16:21:50.345]   - Field: ‘result’
[16:21:50.345]   - Field: ‘asynchronous’
[16:21:50.345]   - Field: ‘calls’
[16:21:50.346]   - Field: ‘globals’
[16:21:50.346]   - Field: ‘stdout’
[16:21:50.346]   - Field: ‘earlySignal’
[16:21:50.346]   - Field: ‘lazy’
[16:21:50.346]   - Field: ‘state’
[16:21:50.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.346] - Launch lazy future ...
[16:21:50.346] Packages needed by the future expression (n = 0): <none>
[16:21:50.346] Packages needed by future strategies (n = 0): <none>
[16:21:50.347] {
[16:21:50.347]     {
[16:21:50.347]         {
[16:21:50.347]             ...future.startTime <- base::Sys.time()
[16:21:50.347]             {
[16:21:50.347]                 {
[16:21:50.347]                   {
[16:21:50.347]                     base::local({
[16:21:50.347]                       has_future <- base::requireNamespace("future", 
[16:21:50.347]                         quietly = TRUE)
[16:21:50.347]                       if (has_future) {
[16:21:50.347]                         ns <- base::getNamespace("future")
[16:21:50.347]                         version <- ns[[".package"]][["version"]]
[16:21:50.347]                         if (is.null(version)) 
[16:21:50.347]                           version <- utils::packageVersion("future")
[16:21:50.347]                       }
[16:21:50.347]                       else {
[16:21:50.347]                         version <- NULL
[16:21:50.347]                       }
[16:21:50.347]                       if (!has_future || version < "1.8.0") {
[16:21:50.347]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.347]                           "", base::R.version$version.string), 
[16:21:50.347]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.347]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.347]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.347]                             "release", "version")], collapse = " "), 
[16:21:50.347]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.347]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.347]                           info)
[16:21:50.347]                         info <- base::paste(info, collapse = "; ")
[16:21:50.347]                         if (!has_future) {
[16:21:50.347]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.347]                             info)
[16:21:50.347]                         }
[16:21:50.347]                         else {
[16:21:50.347]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.347]                             info, version)
[16:21:50.347]                         }
[16:21:50.347]                         base::stop(msg)
[16:21:50.347]                       }
[16:21:50.347]                     })
[16:21:50.347]                   }
[16:21:50.347]                   ...future.strategy.old <- future::plan("list")
[16:21:50.347]                   options(future.plan = NULL)
[16:21:50.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.347]                 }
[16:21:50.347]                 ...future.workdir <- getwd()
[16:21:50.347]             }
[16:21:50.347]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.347]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.347]         }
[16:21:50.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.347]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.347]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.347]             base::names(...future.oldOptions))
[16:21:50.347]     }
[16:21:50.347]     if (FALSE) {
[16:21:50.347]     }
[16:21:50.347]     else {
[16:21:50.347]         if (TRUE) {
[16:21:50.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.347]                 open = "w")
[16:21:50.347]         }
[16:21:50.347]         else {
[16:21:50.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.347]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.347]         }
[16:21:50.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.347]             base::sink(type = "output", split = FALSE)
[16:21:50.347]             base::close(...future.stdout)
[16:21:50.347]         }, add = TRUE)
[16:21:50.347]     }
[16:21:50.347]     ...future.frame <- base::sys.nframe()
[16:21:50.347]     ...future.conditions <- base::list()
[16:21:50.347]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.347]     if (FALSE) {
[16:21:50.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.347]     }
[16:21:50.347]     ...future.result <- base::tryCatch({
[16:21:50.347]         base::withCallingHandlers({
[16:21:50.347]             ...future.value <- base::withVisible(base::local({
[16:21:50.347]                 Sys.sleep(0.1)
[16:21:50.347]                 kk
[16:21:50.347]             }))
[16:21:50.347]             future::FutureResult(value = ...future.value$value, 
[16:21:50.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.347]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.347]                     ...future.globalenv.names))
[16:21:50.347]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.347]         }, condition = base::local({
[16:21:50.347]             c <- base::c
[16:21:50.347]             inherits <- base::inherits
[16:21:50.347]             invokeRestart <- base::invokeRestart
[16:21:50.347]             length <- base::length
[16:21:50.347]             list <- base::list
[16:21:50.347]             seq.int <- base::seq.int
[16:21:50.347]             signalCondition <- base::signalCondition
[16:21:50.347]             sys.calls <- base::sys.calls
[16:21:50.347]             `[[` <- base::`[[`
[16:21:50.347]             `+` <- base::`+`
[16:21:50.347]             `<<-` <- base::`<<-`
[16:21:50.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.347]                   3L)]
[16:21:50.347]             }
[16:21:50.347]             function(cond) {
[16:21:50.347]                 is_error <- inherits(cond, "error")
[16:21:50.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.347]                   NULL)
[16:21:50.347]                 if (is_error) {
[16:21:50.347]                   sessionInformation <- function() {
[16:21:50.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.347]                       search = base::search(), system = base::Sys.info())
[16:21:50.347]                   }
[16:21:50.347]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.347]                     cond$call), session = sessionInformation(), 
[16:21:50.347]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.347]                   signalCondition(cond)
[16:21:50.347]                 }
[16:21:50.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.347]                 "immediateCondition"))) {
[16:21:50.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.347]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.347]                   if (TRUE && !signal) {
[16:21:50.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.347]                     {
[16:21:50.347]                       inherits <- base::inherits
[16:21:50.347]                       invokeRestart <- base::invokeRestart
[16:21:50.347]                       is.null <- base::is.null
[16:21:50.347]                       muffled <- FALSE
[16:21:50.347]                       if (inherits(cond, "message")) {
[16:21:50.347]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.347]                         if (muffled) 
[16:21:50.347]                           invokeRestart("muffleMessage")
[16:21:50.347]                       }
[16:21:50.347]                       else if (inherits(cond, "warning")) {
[16:21:50.347]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.347]                         if (muffled) 
[16:21:50.347]                           invokeRestart("muffleWarning")
[16:21:50.347]                       }
[16:21:50.347]                       else if (inherits(cond, "condition")) {
[16:21:50.347]                         if (!is.null(pattern)) {
[16:21:50.347]                           computeRestarts <- base::computeRestarts
[16:21:50.347]                           grepl <- base::grepl
[16:21:50.347]                           restarts <- computeRestarts(cond)
[16:21:50.347]                           for (restart in restarts) {
[16:21:50.347]                             name <- restart$name
[16:21:50.347]                             if (is.null(name)) 
[16:21:50.347]                               next
[16:21:50.347]                             if (!grepl(pattern, name)) 
[16:21:50.347]                               next
[16:21:50.347]                             invokeRestart(restart)
[16:21:50.347]                             muffled <- TRUE
[16:21:50.347]                             break
[16:21:50.347]                           }
[16:21:50.347]                         }
[16:21:50.347]                       }
[16:21:50.347]                       invisible(muffled)
[16:21:50.347]                     }
[16:21:50.347]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.347]                   }
[16:21:50.347]                 }
[16:21:50.347]                 else {
[16:21:50.347]                   if (TRUE) {
[16:21:50.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.347]                     {
[16:21:50.347]                       inherits <- base::inherits
[16:21:50.347]                       invokeRestart <- base::invokeRestart
[16:21:50.347]                       is.null <- base::is.null
[16:21:50.347]                       muffled <- FALSE
[16:21:50.347]                       if (inherits(cond, "message")) {
[16:21:50.347]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.347]                         if (muffled) 
[16:21:50.347]                           invokeRestart("muffleMessage")
[16:21:50.347]                       }
[16:21:50.347]                       else if (inherits(cond, "warning")) {
[16:21:50.347]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.347]                         if (muffled) 
[16:21:50.347]                           invokeRestart("muffleWarning")
[16:21:50.347]                       }
[16:21:50.347]                       else if (inherits(cond, "condition")) {
[16:21:50.347]                         if (!is.null(pattern)) {
[16:21:50.347]                           computeRestarts <- base::computeRestarts
[16:21:50.347]                           grepl <- base::grepl
[16:21:50.347]                           restarts <- computeRestarts(cond)
[16:21:50.347]                           for (restart in restarts) {
[16:21:50.347]                             name <- restart$name
[16:21:50.347]                             if (is.null(name)) 
[16:21:50.347]                               next
[16:21:50.347]                             if (!grepl(pattern, name)) 
[16:21:50.347]                               next
[16:21:50.347]                             invokeRestart(restart)
[16:21:50.347]                             muffled <- TRUE
[16:21:50.347]                             break
[16:21:50.347]                           }
[16:21:50.347]                         }
[16:21:50.347]                       }
[16:21:50.347]                       invisible(muffled)
[16:21:50.347]                     }
[16:21:50.347]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.347]                   }
[16:21:50.347]                 }
[16:21:50.347]             }
[16:21:50.347]         }))
[16:21:50.347]     }, error = function(ex) {
[16:21:50.347]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.347]                 ...future.rng), started = ...future.startTime, 
[16:21:50.347]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.347]             version = "1.8"), class = "FutureResult")
[16:21:50.347]     }, finally = {
[16:21:50.347]         if (!identical(...future.workdir, getwd())) 
[16:21:50.347]             setwd(...future.workdir)
[16:21:50.347]         {
[16:21:50.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.347]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.347]             }
[16:21:50.347]             base::options(...future.oldOptions)
[16:21:50.347]             if (.Platform$OS.type == "windows") {
[16:21:50.347]                 old_names <- names(...future.oldEnvVars)
[16:21:50.347]                 envs <- base::Sys.getenv()
[16:21:50.347]                 names <- names(envs)
[16:21:50.347]                 common <- intersect(names, old_names)
[16:21:50.347]                 added <- setdiff(names, old_names)
[16:21:50.347]                 removed <- setdiff(old_names, names)
[16:21:50.347]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.347]                   envs[common]]
[16:21:50.347]                 NAMES <- toupper(changed)
[16:21:50.347]                 args <- list()
[16:21:50.347]                 for (kk in seq_along(NAMES)) {
[16:21:50.347]                   name <- changed[[kk]]
[16:21:50.347]                   NAME <- NAMES[[kk]]
[16:21:50.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.347]                     next
[16:21:50.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.347]                 }
[16:21:50.347]                 NAMES <- toupper(added)
[16:21:50.347]                 for (kk in seq_along(NAMES)) {
[16:21:50.347]                   name <- added[[kk]]
[16:21:50.347]                   NAME <- NAMES[[kk]]
[16:21:50.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.347]                     next
[16:21:50.347]                   args[[name]] <- ""
[16:21:50.347]                 }
[16:21:50.347]                 NAMES <- toupper(removed)
[16:21:50.347]                 for (kk in seq_along(NAMES)) {
[16:21:50.347]                   name <- removed[[kk]]
[16:21:50.347]                   NAME <- NAMES[[kk]]
[16:21:50.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.347]                     next
[16:21:50.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.347]                 }
[16:21:50.347]                 if (length(args) > 0) 
[16:21:50.347]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.347]             }
[16:21:50.347]             else {
[16:21:50.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.347]             }
[16:21:50.347]             {
[16:21:50.347]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.347]                   0L) {
[16:21:50.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.347]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.347]                   base::options(opts)
[16:21:50.347]                 }
[16:21:50.347]                 {
[16:21:50.347]                   {
[16:21:50.347]                     NULL
[16:21:50.347]                     RNGkind("Mersenne-Twister")
[16:21:50.347]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.347]                       inherits = FALSE)
[16:21:50.347]                   }
[16:21:50.347]                   options(future.plan = NULL)
[16:21:50.347]                   if (is.na(NA_character_)) 
[16:21:50.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.347]                     .init = FALSE)
[16:21:50.347]                 }
[16:21:50.347]             }
[16:21:50.347]         }
[16:21:50.347]     })
[16:21:50.347]     if (TRUE) {
[16:21:50.347]         base::sink(type = "output", split = FALSE)
[16:21:50.347]         if (TRUE) {
[16:21:50.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.347]         }
[16:21:50.347]         else {
[16:21:50.347]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.347]         }
[16:21:50.347]         base::close(...future.stdout)
[16:21:50.347]         ...future.stdout <- NULL
[16:21:50.347]     }
[16:21:50.347]     ...future.result$conditions <- ...future.conditions
[16:21:50.347]     ...future.result$finished <- base::Sys.time()
[16:21:50.347]     ...future.result
[16:21:50.347] }
[16:21:50.348] assign_globals() ...
[16:21:50.349] List of 1
[16:21:50.349]  $ kk: int 1
[16:21:50.349]  - attr(*, "where")=List of 1
[16:21:50.349]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:50.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:50.349]  - attr(*, "resolved")= logi FALSE
[16:21:50.349]  - attr(*, "total_size")= num 56
[16:21:50.349]  - attr(*, "already-done")= logi TRUE
[16:21:50.351] - copied ‘kk’ to environment
[16:21:50.351] assign_globals() ... done
[16:21:50.351] plan(): Setting new future strategy stack:
[16:21:50.352] List of future strategies:
[16:21:50.352] 1. sequential:
[16:21:50.352]    - args: function (..., envir = parent.frame())
[16:21:50.352]    - tweaked: FALSE
[16:21:50.352]    - call: NULL
[16:21:50.352] plan(): nbrOfWorkers() = 1
[16:21:50.453] plan(): Setting new future strategy stack:
[16:21:50.453] List of future strategies:
[16:21:50.453] 1. sequential:
[16:21:50.453]    - args: function (..., envir = parent.frame())
[16:21:50.453]    - tweaked: FALSE
[16:21:50.453]    - call: plan(strategy)
[16:21:50.454] plan(): nbrOfWorkers() = 1
[16:21:50.454] SequentialFuture started (and completed)
[16:21:50.454] - Launch lazy future ... done
[16:21:50.454] run() for ‘SequentialFuture’ ... done
[16:21:50.454] resolved() for ‘SequentialFuture’ ...
[16:21:50.454] - state: ‘finished’
[16:21:50.454] - run: TRUE
[16:21:50.454] - result: ‘FutureResult’
[16:21:50.454] resolved() for ‘SequentialFuture’ ... done
[16:21:50.455] Future #1
[16:21:50.455]  length: 2 (resolved future 1)
[16:21:50.455] run() for ‘Future’ ...
[16:21:50.455] - state: ‘created’
[16:21:50.455] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.455] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.456]   - Field: ‘label’
[16:21:50.456]   - Field: ‘local’
[16:21:50.456]   - Field: ‘owner’
[16:21:50.456]   - Field: ‘envir’
[16:21:50.456]   - Field: ‘packages’
[16:21:50.456]   - Field: ‘gc’
[16:21:50.456]   - Field: ‘conditions’
[16:21:50.456]   - Field: ‘expr’
[16:21:50.456]   - Field: ‘uuid’
[16:21:50.456]   - Field: ‘seed’
[16:21:50.456]   - Field: ‘version’
[16:21:50.457]   - Field: ‘result’
[16:21:50.457]   - Field: ‘asynchronous’
[16:21:50.457]   - Field: ‘calls’
[16:21:50.457]   - Field: ‘globals’
[16:21:50.457]   - Field: ‘stdout’
[16:21:50.457]   - Field: ‘earlySignal’
[16:21:50.457]   - Field: ‘lazy’
[16:21:50.457]   - Field: ‘state’
[16:21:50.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.457] - Launch lazy future ...
[16:21:50.458] Packages needed by the future expression (n = 0): <none>
[16:21:50.458] Packages needed by future strategies (n = 0): <none>
[16:21:50.458] {
[16:21:50.458]     {
[16:21:50.458]         {
[16:21:50.458]             ...future.startTime <- base::Sys.time()
[16:21:50.458]             {
[16:21:50.458]                 {
[16:21:50.458]                   {
[16:21:50.458]                     base::local({
[16:21:50.458]                       has_future <- base::requireNamespace("future", 
[16:21:50.458]                         quietly = TRUE)
[16:21:50.458]                       if (has_future) {
[16:21:50.458]                         ns <- base::getNamespace("future")
[16:21:50.458]                         version <- ns[[".package"]][["version"]]
[16:21:50.458]                         if (is.null(version)) 
[16:21:50.458]                           version <- utils::packageVersion("future")
[16:21:50.458]                       }
[16:21:50.458]                       else {
[16:21:50.458]                         version <- NULL
[16:21:50.458]                       }
[16:21:50.458]                       if (!has_future || version < "1.8.0") {
[16:21:50.458]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.458]                           "", base::R.version$version.string), 
[16:21:50.458]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.458]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.458]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.458]                             "release", "version")], collapse = " "), 
[16:21:50.458]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.458]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.458]                           info)
[16:21:50.458]                         info <- base::paste(info, collapse = "; ")
[16:21:50.458]                         if (!has_future) {
[16:21:50.458]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.458]                             info)
[16:21:50.458]                         }
[16:21:50.458]                         else {
[16:21:50.458]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.458]                             info, version)
[16:21:50.458]                         }
[16:21:50.458]                         base::stop(msg)
[16:21:50.458]                       }
[16:21:50.458]                     })
[16:21:50.458]                   }
[16:21:50.458]                   ...future.strategy.old <- future::plan("list")
[16:21:50.458]                   options(future.plan = NULL)
[16:21:50.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.458]                 }
[16:21:50.458]                 ...future.workdir <- getwd()
[16:21:50.458]             }
[16:21:50.458]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.458]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.458]         }
[16:21:50.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.458]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.458]             base::names(...future.oldOptions))
[16:21:50.458]     }
[16:21:50.458]     if (FALSE) {
[16:21:50.458]     }
[16:21:50.458]     else {
[16:21:50.458]         if (TRUE) {
[16:21:50.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.458]                 open = "w")
[16:21:50.458]         }
[16:21:50.458]         else {
[16:21:50.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.458]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.458]         }
[16:21:50.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.458]             base::sink(type = "output", split = FALSE)
[16:21:50.458]             base::close(...future.stdout)
[16:21:50.458]         }, add = TRUE)
[16:21:50.458]     }
[16:21:50.458]     ...future.frame <- base::sys.nframe()
[16:21:50.458]     ...future.conditions <- base::list()
[16:21:50.458]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.458]     if (FALSE) {
[16:21:50.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.458]     }
[16:21:50.458]     ...future.result <- base::tryCatch({
[16:21:50.458]         base::withCallingHandlers({
[16:21:50.458]             ...future.value <- base::withVisible(base::local({
[16:21:50.458]                 Sys.sleep(0.1)
[16:21:50.458]                 kk
[16:21:50.458]             }))
[16:21:50.458]             future::FutureResult(value = ...future.value$value, 
[16:21:50.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.458]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.458]                     ...future.globalenv.names))
[16:21:50.458]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.458]         }, condition = base::local({
[16:21:50.458]             c <- base::c
[16:21:50.458]             inherits <- base::inherits
[16:21:50.458]             invokeRestart <- base::invokeRestart
[16:21:50.458]             length <- base::length
[16:21:50.458]             list <- base::list
[16:21:50.458]             seq.int <- base::seq.int
[16:21:50.458]             signalCondition <- base::signalCondition
[16:21:50.458]             sys.calls <- base::sys.calls
[16:21:50.458]             `[[` <- base::`[[`
[16:21:50.458]             `+` <- base::`+`
[16:21:50.458]             `<<-` <- base::`<<-`
[16:21:50.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.458]                   3L)]
[16:21:50.458]             }
[16:21:50.458]             function(cond) {
[16:21:50.458]                 is_error <- inherits(cond, "error")
[16:21:50.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.458]                   NULL)
[16:21:50.458]                 if (is_error) {
[16:21:50.458]                   sessionInformation <- function() {
[16:21:50.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.458]                       search = base::search(), system = base::Sys.info())
[16:21:50.458]                   }
[16:21:50.458]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.458]                     cond$call), session = sessionInformation(), 
[16:21:50.458]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.458]                   signalCondition(cond)
[16:21:50.458]                 }
[16:21:50.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.458]                 "immediateCondition"))) {
[16:21:50.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.458]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.458]                   if (TRUE && !signal) {
[16:21:50.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.458]                     {
[16:21:50.458]                       inherits <- base::inherits
[16:21:50.458]                       invokeRestart <- base::invokeRestart
[16:21:50.458]                       is.null <- base::is.null
[16:21:50.458]                       muffled <- FALSE
[16:21:50.458]                       if (inherits(cond, "message")) {
[16:21:50.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.458]                         if (muffled) 
[16:21:50.458]                           invokeRestart("muffleMessage")
[16:21:50.458]                       }
[16:21:50.458]                       else if (inherits(cond, "warning")) {
[16:21:50.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.458]                         if (muffled) 
[16:21:50.458]                           invokeRestart("muffleWarning")
[16:21:50.458]                       }
[16:21:50.458]                       else if (inherits(cond, "condition")) {
[16:21:50.458]                         if (!is.null(pattern)) {
[16:21:50.458]                           computeRestarts <- base::computeRestarts
[16:21:50.458]                           grepl <- base::grepl
[16:21:50.458]                           restarts <- computeRestarts(cond)
[16:21:50.458]                           for (restart in restarts) {
[16:21:50.458]                             name <- restart$name
[16:21:50.458]                             if (is.null(name)) 
[16:21:50.458]                               next
[16:21:50.458]                             if (!grepl(pattern, name)) 
[16:21:50.458]                               next
[16:21:50.458]                             invokeRestart(restart)
[16:21:50.458]                             muffled <- TRUE
[16:21:50.458]                             break
[16:21:50.458]                           }
[16:21:50.458]                         }
[16:21:50.458]                       }
[16:21:50.458]                       invisible(muffled)
[16:21:50.458]                     }
[16:21:50.458]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.458]                   }
[16:21:50.458]                 }
[16:21:50.458]                 else {
[16:21:50.458]                   if (TRUE) {
[16:21:50.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.458]                     {
[16:21:50.458]                       inherits <- base::inherits
[16:21:50.458]                       invokeRestart <- base::invokeRestart
[16:21:50.458]                       is.null <- base::is.null
[16:21:50.458]                       muffled <- FALSE
[16:21:50.458]                       if (inherits(cond, "message")) {
[16:21:50.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.458]                         if (muffled) 
[16:21:50.458]                           invokeRestart("muffleMessage")
[16:21:50.458]                       }
[16:21:50.458]                       else if (inherits(cond, "warning")) {
[16:21:50.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.458]                         if (muffled) 
[16:21:50.458]                           invokeRestart("muffleWarning")
[16:21:50.458]                       }
[16:21:50.458]                       else if (inherits(cond, "condition")) {
[16:21:50.458]                         if (!is.null(pattern)) {
[16:21:50.458]                           computeRestarts <- base::computeRestarts
[16:21:50.458]                           grepl <- base::grepl
[16:21:50.458]                           restarts <- computeRestarts(cond)
[16:21:50.458]                           for (restart in restarts) {
[16:21:50.458]                             name <- restart$name
[16:21:50.458]                             if (is.null(name)) 
[16:21:50.458]                               next
[16:21:50.458]                             if (!grepl(pattern, name)) 
[16:21:50.458]                               next
[16:21:50.458]                             invokeRestart(restart)
[16:21:50.458]                             muffled <- TRUE
[16:21:50.458]                             break
[16:21:50.458]                           }
[16:21:50.458]                         }
[16:21:50.458]                       }
[16:21:50.458]                       invisible(muffled)
[16:21:50.458]                     }
[16:21:50.458]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.458]                   }
[16:21:50.458]                 }
[16:21:50.458]             }
[16:21:50.458]         }))
[16:21:50.458]     }, error = function(ex) {
[16:21:50.458]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.458]                 ...future.rng), started = ...future.startTime, 
[16:21:50.458]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.458]             version = "1.8"), class = "FutureResult")
[16:21:50.458]     }, finally = {
[16:21:50.458]         if (!identical(...future.workdir, getwd())) 
[16:21:50.458]             setwd(...future.workdir)
[16:21:50.458]         {
[16:21:50.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.458]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.458]             }
[16:21:50.458]             base::options(...future.oldOptions)
[16:21:50.458]             if (.Platform$OS.type == "windows") {
[16:21:50.458]                 old_names <- names(...future.oldEnvVars)
[16:21:50.458]                 envs <- base::Sys.getenv()
[16:21:50.458]                 names <- names(envs)
[16:21:50.458]                 common <- intersect(names, old_names)
[16:21:50.458]                 added <- setdiff(names, old_names)
[16:21:50.458]                 removed <- setdiff(old_names, names)
[16:21:50.458]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.458]                   envs[common]]
[16:21:50.458]                 NAMES <- toupper(changed)
[16:21:50.458]                 args <- list()
[16:21:50.458]                 for (kk in seq_along(NAMES)) {
[16:21:50.458]                   name <- changed[[kk]]
[16:21:50.458]                   NAME <- NAMES[[kk]]
[16:21:50.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.458]                     next
[16:21:50.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.458]                 }
[16:21:50.458]                 NAMES <- toupper(added)
[16:21:50.458]                 for (kk in seq_along(NAMES)) {
[16:21:50.458]                   name <- added[[kk]]
[16:21:50.458]                   NAME <- NAMES[[kk]]
[16:21:50.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.458]                     next
[16:21:50.458]                   args[[name]] <- ""
[16:21:50.458]                 }
[16:21:50.458]                 NAMES <- toupper(removed)
[16:21:50.458]                 for (kk in seq_along(NAMES)) {
[16:21:50.458]                   name <- removed[[kk]]
[16:21:50.458]                   NAME <- NAMES[[kk]]
[16:21:50.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.458]                     next
[16:21:50.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.458]                 }
[16:21:50.458]                 if (length(args) > 0) 
[16:21:50.458]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.458]             }
[16:21:50.458]             else {
[16:21:50.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.458]             }
[16:21:50.458]             {
[16:21:50.458]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.458]                   0L) {
[16:21:50.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.458]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.458]                   base::options(opts)
[16:21:50.458]                 }
[16:21:50.458]                 {
[16:21:50.458]                   {
[16:21:50.458]                     NULL
[16:21:50.458]                     RNGkind("Mersenne-Twister")
[16:21:50.458]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.458]                       inherits = FALSE)
[16:21:50.458]                   }
[16:21:50.458]                   options(future.plan = NULL)
[16:21:50.458]                   if (is.na(NA_character_)) 
[16:21:50.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.458]                     .init = FALSE)
[16:21:50.458]                 }
[16:21:50.458]             }
[16:21:50.458]         }
[16:21:50.458]     })
[16:21:50.458]     if (TRUE) {
[16:21:50.458]         base::sink(type = "output", split = FALSE)
[16:21:50.458]         if (TRUE) {
[16:21:50.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.458]         }
[16:21:50.458]         else {
[16:21:50.458]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.458]         }
[16:21:50.458]         base::close(...future.stdout)
[16:21:50.458]         ...future.stdout <- NULL
[16:21:50.458]     }
[16:21:50.458]     ...future.result$conditions <- ...future.conditions
[16:21:50.458]     ...future.result$finished <- base::Sys.time()
[16:21:50.458]     ...future.result
[16:21:50.458] }
[16:21:50.460] assign_globals() ...
[16:21:50.460] List of 1
[16:21:50.460]  $ kk: int 2
[16:21:50.460]  - attr(*, "where")=List of 1
[16:21:50.460]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:50.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:50.460]  - attr(*, "resolved")= logi FALSE
[16:21:50.460]  - attr(*, "total_size")= num 56
[16:21:50.460]  - attr(*, "already-done")= logi TRUE
[16:21:50.462] - copied ‘kk’ to environment
[16:21:50.462] assign_globals() ... done
[16:21:50.463] plan(): Setting new future strategy stack:
[16:21:50.463] List of future strategies:
[16:21:50.463] 1. sequential:
[16:21:50.463]    - args: function (..., envir = parent.frame())
[16:21:50.463]    - tweaked: FALSE
[16:21:50.463]    - call: NULL
[16:21:50.463] plan(): nbrOfWorkers() = 1
[16:21:50.564] plan(): Setting new future strategy stack:
[16:21:50.564] List of future strategies:
[16:21:50.564] 1. sequential:
[16:21:50.564]    - args: function (..., envir = parent.frame())
[16:21:50.564]    - tweaked: FALSE
[16:21:50.564]    - call: plan(strategy)
[16:21:50.565] plan(): nbrOfWorkers() = 1
[16:21:50.565] SequentialFuture started (and completed)
[16:21:50.565] - Launch lazy future ... done
[16:21:50.565] run() for ‘SequentialFuture’ ... done
[16:21:50.565] resolved() for ‘SequentialFuture’ ...
[16:21:50.565] - state: ‘finished’
[16:21:50.565] - run: TRUE
[16:21:50.566] - result: ‘FutureResult’
[16:21:50.566] resolved() for ‘SequentialFuture’ ... done
[16:21:50.566] Future #2
[16:21:50.566]  length: 1 (resolved future 2)
[16:21:50.566] run() for ‘Future’ ...
[16:21:50.566] - state: ‘created’
[16:21:50.566] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.566] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.567]   - Field: ‘label’
[16:21:50.567]   - Field: ‘local’
[16:21:50.567]   - Field: ‘owner’
[16:21:50.567]   - Field: ‘envir’
[16:21:50.567]   - Field: ‘packages’
[16:21:50.567]   - Field: ‘gc’
[16:21:50.567]   - Field: ‘conditions’
[16:21:50.567]   - Field: ‘expr’
[16:21:50.567]   - Field: ‘uuid’
[16:21:50.567]   - Field: ‘seed’
[16:21:50.568]   - Field: ‘version’
[16:21:50.568]   - Field: ‘result’
[16:21:50.568]   - Field: ‘asynchronous’
[16:21:50.568]   - Field: ‘calls’
[16:21:50.568]   - Field: ‘globals’
[16:21:50.568]   - Field: ‘stdout’
[16:21:50.568]   - Field: ‘earlySignal’
[16:21:50.568]   - Field: ‘lazy’
[16:21:50.568]   - Field: ‘state’
[16:21:50.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.568] - Launch lazy future ...
[16:21:50.569] Packages needed by the future expression (n = 0): <none>
[16:21:50.569] Packages needed by future strategies (n = 0): <none>
[16:21:50.569] {
[16:21:50.569]     {
[16:21:50.569]         {
[16:21:50.569]             ...future.startTime <- base::Sys.time()
[16:21:50.569]             {
[16:21:50.569]                 {
[16:21:50.569]                   {
[16:21:50.569]                     base::local({
[16:21:50.569]                       has_future <- base::requireNamespace("future", 
[16:21:50.569]                         quietly = TRUE)
[16:21:50.569]                       if (has_future) {
[16:21:50.569]                         ns <- base::getNamespace("future")
[16:21:50.569]                         version <- ns[[".package"]][["version"]]
[16:21:50.569]                         if (is.null(version)) 
[16:21:50.569]                           version <- utils::packageVersion("future")
[16:21:50.569]                       }
[16:21:50.569]                       else {
[16:21:50.569]                         version <- NULL
[16:21:50.569]                       }
[16:21:50.569]                       if (!has_future || version < "1.8.0") {
[16:21:50.569]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.569]                           "", base::R.version$version.string), 
[16:21:50.569]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.569]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.569]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.569]                             "release", "version")], collapse = " "), 
[16:21:50.569]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.569]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.569]                           info)
[16:21:50.569]                         info <- base::paste(info, collapse = "; ")
[16:21:50.569]                         if (!has_future) {
[16:21:50.569]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.569]                             info)
[16:21:50.569]                         }
[16:21:50.569]                         else {
[16:21:50.569]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.569]                             info, version)
[16:21:50.569]                         }
[16:21:50.569]                         base::stop(msg)
[16:21:50.569]                       }
[16:21:50.569]                     })
[16:21:50.569]                   }
[16:21:50.569]                   ...future.strategy.old <- future::plan("list")
[16:21:50.569]                   options(future.plan = NULL)
[16:21:50.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.569]                 }
[16:21:50.569]                 ...future.workdir <- getwd()
[16:21:50.569]             }
[16:21:50.569]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.569]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.569]         }
[16:21:50.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.569]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.569]             base::names(...future.oldOptions))
[16:21:50.569]     }
[16:21:50.569]     if (FALSE) {
[16:21:50.569]     }
[16:21:50.569]     else {
[16:21:50.569]         if (TRUE) {
[16:21:50.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.569]                 open = "w")
[16:21:50.569]         }
[16:21:50.569]         else {
[16:21:50.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.569]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.569]         }
[16:21:50.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.569]             base::sink(type = "output", split = FALSE)
[16:21:50.569]             base::close(...future.stdout)
[16:21:50.569]         }, add = TRUE)
[16:21:50.569]     }
[16:21:50.569]     ...future.frame <- base::sys.nframe()
[16:21:50.569]     ...future.conditions <- base::list()
[16:21:50.569]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.569]     if (FALSE) {
[16:21:50.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.569]     }
[16:21:50.569]     ...future.result <- base::tryCatch({
[16:21:50.569]         base::withCallingHandlers({
[16:21:50.569]             ...future.value <- base::withVisible(base::local({
[16:21:50.569]                 Sys.sleep(0.1)
[16:21:50.569]                 kk
[16:21:50.569]             }))
[16:21:50.569]             future::FutureResult(value = ...future.value$value, 
[16:21:50.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.569]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.569]                     ...future.globalenv.names))
[16:21:50.569]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.569]         }, condition = base::local({
[16:21:50.569]             c <- base::c
[16:21:50.569]             inherits <- base::inherits
[16:21:50.569]             invokeRestart <- base::invokeRestart
[16:21:50.569]             length <- base::length
[16:21:50.569]             list <- base::list
[16:21:50.569]             seq.int <- base::seq.int
[16:21:50.569]             signalCondition <- base::signalCondition
[16:21:50.569]             sys.calls <- base::sys.calls
[16:21:50.569]             `[[` <- base::`[[`
[16:21:50.569]             `+` <- base::`+`
[16:21:50.569]             `<<-` <- base::`<<-`
[16:21:50.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.569]                   3L)]
[16:21:50.569]             }
[16:21:50.569]             function(cond) {
[16:21:50.569]                 is_error <- inherits(cond, "error")
[16:21:50.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.569]                   NULL)
[16:21:50.569]                 if (is_error) {
[16:21:50.569]                   sessionInformation <- function() {
[16:21:50.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.569]                       search = base::search(), system = base::Sys.info())
[16:21:50.569]                   }
[16:21:50.569]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.569]                     cond$call), session = sessionInformation(), 
[16:21:50.569]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.569]                   signalCondition(cond)
[16:21:50.569]                 }
[16:21:50.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.569]                 "immediateCondition"))) {
[16:21:50.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.569]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.569]                   if (TRUE && !signal) {
[16:21:50.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.569]                     {
[16:21:50.569]                       inherits <- base::inherits
[16:21:50.569]                       invokeRestart <- base::invokeRestart
[16:21:50.569]                       is.null <- base::is.null
[16:21:50.569]                       muffled <- FALSE
[16:21:50.569]                       if (inherits(cond, "message")) {
[16:21:50.569]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.569]                         if (muffled) 
[16:21:50.569]                           invokeRestart("muffleMessage")
[16:21:50.569]                       }
[16:21:50.569]                       else if (inherits(cond, "warning")) {
[16:21:50.569]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.569]                         if (muffled) 
[16:21:50.569]                           invokeRestart("muffleWarning")
[16:21:50.569]                       }
[16:21:50.569]                       else if (inherits(cond, "condition")) {
[16:21:50.569]                         if (!is.null(pattern)) {
[16:21:50.569]                           computeRestarts <- base::computeRestarts
[16:21:50.569]                           grepl <- base::grepl
[16:21:50.569]                           restarts <- computeRestarts(cond)
[16:21:50.569]                           for (restart in restarts) {
[16:21:50.569]                             name <- restart$name
[16:21:50.569]                             if (is.null(name)) 
[16:21:50.569]                               next
[16:21:50.569]                             if (!grepl(pattern, name)) 
[16:21:50.569]                               next
[16:21:50.569]                             invokeRestart(restart)
[16:21:50.569]                             muffled <- TRUE
[16:21:50.569]                             break
[16:21:50.569]                           }
[16:21:50.569]                         }
[16:21:50.569]                       }
[16:21:50.569]                       invisible(muffled)
[16:21:50.569]                     }
[16:21:50.569]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.569]                   }
[16:21:50.569]                 }
[16:21:50.569]                 else {
[16:21:50.569]                   if (TRUE) {
[16:21:50.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.569]                     {
[16:21:50.569]                       inherits <- base::inherits
[16:21:50.569]                       invokeRestart <- base::invokeRestart
[16:21:50.569]                       is.null <- base::is.null
[16:21:50.569]                       muffled <- FALSE
[16:21:50.569]                       if (inherits(cond, "message")) {
[16:21:50.569]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.569]                         if (muffled) 
[16:21:50.569]                           invokeRestart("muffleMessage")
[16:21:50.569]                       }
[16:21:50.569]                       else if (inherits(cond, "warning")) {
[16:21:50.569]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.569]                         if (muffled) 
[16:21:50.569]                           invokeRestart("muffleWarning")
[16:21:50.569]                       }
[16:21:50.569]                       else if (inherits(cond, "condition")) {
[16:21:50.569]                         if (!is.null(pattern)) {
[16:21:50.569]                           computeRestarts <- base::computeRestarts
[16:21:50.569]                           grepl <- base::grepl
[16:21:50.569]                           restarts <- computeRestarts(cond)
[16:21:50.569]                           for (restart in restarts) {
[16:21:50.569]                             name <- restart$name
[16:21:50.569]                             if (is.null(name)) 
[16:21:50.569]                               next
[16:21:50.569]                             if (!grepl(pattern, name)) 
[16:21:50.569]                               next
[16:21:50.569]                             invokeRestart(restart)
[16:21:50.569]                             muffled <- TRUE
[16:21:50.569]                             break
[16:21:50.569]                           }
[16:21:50.569]                         }
[16:21:50.569]                       }
[16:21:50.569]                       invisible(muffled)
[16:21:50.569]                     }
[16:21:50.569]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.569]                   }
[16:21:50.569]                 }
[16:21:50.569]             }
[16:21:50.569]         }))
[16:21:50.569]     }, error = function(ex) {
[16:21:50.569]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.569]                 ...future.rng), started = ...future.startTime, 
[16:21:50.569]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.569]             version = "1.8"), class = "FutureResult")
[16:21:50.569]     }, finally = {
[16:21:50.569]         if (!identical(...future.workdir, getwd())) 
[16:21:50.569]             setwd(...future.workdir)
[16:21:50.569]         {
[16:21:50.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.569]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.569]             }
[16:21:50.569]             base::options(...future.oldOptions)
[16:21:50.569]             if (.Platform$OS.type == "windows") {
[16:21:50.569]                 old_names <- names(...future.oldEnvVars)
[16:21:50.569]                 envs <- base::Sys.getenv()
[16:21:50.569]                 names <- names(envs)
[16:21:50.569]                 common <- intersect(names, old_names)
[16:21:50.569]                 added <- setdiff(names, old_names)
[16:21:50.569]                 removed <- setdiff(old_names, names)
[16:21:50.569]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.569]                   envs[common]]
[16:21:50.569]                 NAMES <- toupper(changed)
[16:21:50.569]                 args <- list()
[16:21:50.569]                 for (kk in seq_along(NAMES)) {
[16:21:50.569]                   name <- changed[[kk]]
[16:21:50.569]                   NAME <- NAMES[[kk]]
[16:21:50.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.569]                     next
[16:21:50.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.569]                 }
[16:21:50.569]                 NAMES <- toupper(added)
[16:21:50.569]                 for (kk in seq_along(NAMES)) {
[16:21:50.569]                   name <- added[[kk]]
[16:21:50.569]                   NAME <- NAMES[[kk]]
[16:21:50.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.569]                     next
[16:21:50.569]                   args[[name]] <- ""
[16:21:50.569]                 }
[16:21:50.569]                 NAMES <- toupper(removed)
[16:21:50.569]                 for (kk in seq_along(NAMES)) {
[16:21:50.569]                   name <- removed[[kk]]
[16:21:50.569]                   NAME <- NAMES[[kk]]
[16:21:50.569]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.569]                     next
[16:21:50.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.569]                 }
[16:21:50.569]                 if (length(args) > 0) 
[16:21:50.569]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.569]             }
[16:21:50.569]             else {
[16:21:50.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.569]             }
[16:21:50.569]             {
[16:21:50.569]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.569]                   0L) {
[16:21:50.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.569]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.569]                   base::options(opts)
[16:21:50.569]                 }
[16:21:50.569]                 {
[16:21:50.569]                   {
[16:21:50.569]                     NULL
[16:21:50.569]                     RNGkind("Mersenne-Twister")
[16:21:50.569]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.569]                       inherits = FALSE)
[16:21:50.569]                   }
[16:21:50.569]                   options(future.plan = NULL)
[16:21:50.569]                   if (is.na(NA_character_)) 
[16:21:50.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.569]                     .init = FALSE)
[16:21:50.569]                 }
[16:21:50.569]             }
[16:21:50.569]         }
[16:21:50.569]     })
[16:21:50.569]     if (TRUE) {
[16:21:50.569]         base::sink(type = "output", split = FALSE)
[16:21:50.569]         if (TRUE) {
[16:21:50.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.569]         }
[16:21:50.569]         else {
[16:21:50.569]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.569]         }
[16:21:50.569]         base::close(...future.stdout)
[16:21:50.569]         ...future.stdout <- NULL
[16:21:50.569]     }
[16:21:50.569]     ...future.result$conditions <- ...future.conditions
[16:21:50.569]     ...future.result$finished <- base::Sys.time()
[16:21:50.569]     ...future.result
[16:21:50.569] }
[16:21:50.571] assign_globals() ...
[16:21:50.571] List of 1
[16:21:50.571]  $ kk: int 3
[16:21:50.571]  - attr(*, "where")=List of 1
[16:21:50.571]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:50.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:50.571]  - attr(*, "resolved")= logi FALSE
[16:21:50.571]  - attr(*, "total_size")= num 56
[16:21:50.571]  - attr(*, "already-done")= logi TRUE
[16:21:50.575] - copied ‘kk’ to environment
[16:21:50.575] assign_globals() ... done
[16:21:50.576] plan(): Setting new future strategy stack:
[16:21:50.576] List of future strategies:
[16:21:50.576] 1. sequential:
[16:21:50.576]    - args: function (..., envir = parent.frame())
[16:21:50.576]    - tweaked: FALSE
[16:21:50.576]    - call: NULL
[16:21:50.576] plan(): nbrOfWorkers() = 1
[16:21:50.677] plan(): Setting new future strategy stack:
[16:21:50.677] List of future strategies:
[16:21:50.677] 1. sequential:
[16:21:50.677]    - args: function (..., envir = parent.frame())
[16:21:50.677]    - tweaked: FALSE
[16:21:50.677]    - call: plan(strategy)
[16:21:50.678] plan(): nbrOfWorkers() = 1
[16:21:50.678] SequentialFuture started (and completed)
[16:21:50.678] - Launch lazy future ... done
[16:21:50.678] run() for ‘SequentialFuture’ ... done
[16:21:50.678] resolved() for ‘SequentialFuture’ ...
[16:21:50.679] - state: ‘finished’
[16:21:50.679] - run: TRUE
[16:21:50.679] - result: ‘FutureResult’
[16:21:50.679] resolved() for ‘SequentialFuture’ ... done
[16:21:50.679] Future #3
[16:21:50.679]  length: 0 (resolved future 3)
[16:21:50.679] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:21:50.680] resolve() on environment ...
[16:21:50.680]  recursive: 0
[16:21:50.681]  elements: [2] ‘a’, ‘b’
[16:21:50.682]  length: 1 (resolved future 1)
[16:21:50.682]  length: 0 (resolved future 2)
[16:21:50.682] resolve() on environment ... DONE
[16:21:50.682] getGlobalsAndPackages() ...
[16:21:50.682] Searching for globals...
[16:21:50.683] 
[16:21:50.683] Searching for globals ... DONE
[16:21:50.683] - globals: [0] <none>
[16:21:50.683] getGlobalsAndPackages() ... DONE
[16:21:50.683] run() for ‘Future’ ...
[16:21:50.683] - state: ‘created’
[16:21:50.684] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.684] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.684] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.684]   - Field: ‘label’
[16:21:50.684]   - Field: ‘local’
[16:21:50.684]   - Field: ‘owner’
[16:21:50.684]   - Field: ‘envir’
[16:21:50.684]   - Field: ‘packages’
[16:21:50.685]   - Field: ‘gc’
[16:21:50.685]   - Field: ‘conditions’
[16:21:50.685]   - Field: ‘expr’
[16:21:50.685]   - Field: ‘uuid’
[16:21:50.685]   - Field: ‘seed’
[16:21:50.685]   - Field: ‘version’
[16:21:50.685]   - Field: ‘result’
[16:21:50.685]   - Field: ‘asynchronous’
[16:21:50.685]   - Field: ‘calls’
[16:21:50.685]   - Field: ‘globals’
[16:21:50.686]   - Field: ‘stdout’
[16:21:50.686]   - Field: ‘earlySignal’
[16:21:50.686]   - Field: ‘lazy’
[16:21:50.686]   - Field: ‘state’
[16:21:50.686] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.686] - Launch lazy future ...
[16:21:50.686] Packages needed by the future expression (n = 0): <none>
[16:21:50.686] Packages needed by future strategies (n = 0): <none>
[16:21:50.687] {
[16:21:50.687]     {
[16:21:50.687]         {
[16:21:50.687]             ...future.startTime <- base::Sys.time()
[16:21:50.687]             {
[16:21:50.687]                 {
[16:21:50.687]                   {
[16:21:50.687]                     base::local({
[16:21:50.687]                       has_future <- base::requireNamespace("future", 
[16:21:50.687]                         quietly = TRUE)
[16:21:50.687]                       if (has_future) {
[16:21:50.687]                         ns <- base::getNamespace("future")
[16:21:50.687]                         version <- ns[[".package"]][["version"]]
[16:21:50.687]                         if (is.null(version)) 
[16:21:50.687]                           version <- utils::packageVersion("future")
[16:21:50.687]                       }
[16:21:50.687]                       else {
[16:21:50.687]                         version <- NULL
[16:21:50.687]                       }
[16:21:50.687]                       if (!has_future || version < "1.8.0") {
[16:21:50.687]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.687]                           "", base::R.version$version.string), 
[16:21:50.687]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.687]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.687]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.687]                             "release", "version")], collapse = " "), 
[16:21:50.687]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.687]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.687]                           info)
[16:21:50.687]                         info <- base::paste(info, collapse = "; ")
[16:21:50.687]                         if (!has_future) {
[16:21:50.687]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.687]                             info)
[16:21:50.687]                         }
[16:21:50.687]                         else {
[16:21:50.687]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.687]                             info, version)
[16:21:50.687]                         }
[16:21:50.687]                         base::stop(msg)
[16:21:50.687]                       }
[16:21:50.687]                     })
[16:21:50.687]                   }
[16:21:50.687]                   ...future.strategy.old <- future::plan("list")
[16:21:50.687]                   options(future.plan = NULL)
[16:21:50.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.687]                 }
[16:21:50.687]                 ...future.workdir <- getwd()
[16:21:50.687]             }
[16:21:50.687]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.687]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.687]         }
[16:21:50.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.687]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.687]             base::names(...future.oldOptions))
[16:21:50.687]     }
[16:21:50.687]     if (FALSE) {
[16:21:50.687]     }
[16:21:50.687]     else {
[16:21:50.687]         if (TRUE) {
[16:21:50.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.687]                 open = "w")
[16:21:50.687]         }
[16:21:50.687]         else {
[16:21:50.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.687]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.687]         }
[16:21:50.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.687]             base::sink(type = "output", split = FALSE)
[16:21:50.687]             base::close(...future.stdout)
[16:21:50.687]         }, add = TRUE)
[16:21:50.687]     }
[16:21:50.687]     ...future.frame <- base::sys.nframe()
[16:21:50.687]     ...future.conditions <- base::list()
[16:21:50.687]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.687]     if (FALSE) {
[16:21:50.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.687]     }
[16:21:50.687]     ...future.result <- base::tryCatch({
[16:21:50.687]         base::withCallingHandlers({
[16:21:50.687]             ...future.value <- base::withVisible(base::local(1))
[16:21:50.687]             future::FutureResult(value = ...future.value$value, 
[16:21:50.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.687]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.687]                     ...future.globalenv.names))
[16:21:50.687]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.687]         }, condition = base::local({
[16:21:50.687]             c <- base::c
[16:21:50.687]             inherits <- base::inherits
[16:21:50.687]             invokeRestart <- base::invokeRestart
[16:21:50.687]             length <- base::length
[16:21:50.687]             list <- base::list
[16:21:50.687]             seq.int <- base::seq.int
[16:21:50.687]             signalCondition <- base::signalCondition
[16:21:50.687]             sys.calls <- base::sys.calls
[16:21:50.687]             `[[` <- base::`[[`
[16:21:50.687]             `+` <- base::`+`
[16:21:50.687]             `<<-` <- base::`<<-`
[16:21:50.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.687]                   3L)]
[16:21:50.687]             }
[16:21:50.687]             function(cond) {
[16:21:50.687]                 is_error <- inherits(cond, "error")
[16:21:50.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.687]                   NULL)
[16:21:50.687]                 if (is_error) {
[16:21:50.687]                   sessionInformation <- function() {
[16:21:50.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.687]                       search = base::search(), system = base::Sys.info())
[16:21:50.687]                   }
[16:21:50.687]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.687]                     cond$call), session = sessionInformation(), 
[16:21:50.687]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.687]                   signalCondition(cond)
[16:21:50.687]                 }
[16:21:50.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.687]                 "immediateCondition"))) {
[16:21:50.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.687]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.687]                   if (TRUE && !signal) {
[16:21:50.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.687]                     {
[16:21:50.687]                       inherits <- base::inherits
[16:21:50.687]                       invokeRestart <- base::invokeRestart
[16:21:50.687]                       is.null <- base::is.null
[16:21:50.687]                       muffled <- FALSE
[16:21:50.687]                       if (inherits(cond, "message")) {
[16:21:50.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.687]                         if (muffled) 
[16:21:50.687]                           invokeRestart("muffleMessage")
[16:21:50.687]                       }
[16:21:50.687]                       else if (inherits(cond, "warning")) {
[16:21:50.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.687]                         if (muffled) 
[16:21:50.687]                           invokeRestart("muffleWarning")
[16:21:50.687]                       }
[16:21:50.687]                       else if (inherits(cond, "condition")) {
[16:21:50.687]                         if (!is.null(pattern)) {
[16:21:50.687]                           computeRestarts <- base::computeRestarts
[16:21:50.687]                           grepl <- base::grepl
[16:21:50.687]                           restarts <- computeRestarts(cond)
[16:21:50.687]                           for (restart in restarts) {
[16:21:50.687]                             name <- restart$name
[16:21:50.687]                             if (is.null(name)) 
[16:21:50.687]                               next
[16:21:50.687]                             if (!grepl(pattern, name)) 
[16:21:50.687]                               next
[16:21:50.687]                             invokeRestart(restart)
[16:21:50.687]                             muffled <- TRUE
[16:21:50.687]                             break
[16:21:50.687]                           }
[16:21:50.687]                         }
[16:21:50.687]                       }
[16:21:50.687]                       invisible(muffled)
[16:21:50.687]                     }
[16:21:50.687]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.687]                   }
[16:21:50.687]                 }
[16:21:50.687]                 else {
[16:21:50.687]                   if (TRUE) {
[16:21:50.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.687]                     {
[16:21:50.687]                       inherits <- base::inherits
[16:21:50.687]                       invokeRestart <- base::invokeRestart
[16:21:50.687]                       is.null <- base::is.null
[16:21:50.687]                       muffled <- FALSE
[16:21:50.687]                       if (inherits(cond, "message")) {
[16:21:50.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.687]                         if (muffled) 
[16:21:50.687]                           invokeRestart("muffleMessage")
[16:21:50.687]                       }
[16:21:50.687]                       else if (inherits(cond, "warning")) {
[16:21:50.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.687]                         if (muffled) 
[16:21:50.687]                           invokeRestart("muffleWarning")
[16:21:50.687]                       }
[16:21:50.687]                       else if (inherits(cond, "condition")) {
[16:21:50.687]                         if (!is.null(pattern)) {
[16:21:50.687]                           computeRestarts <- base::computeRestarts
[16:21:50.687]                           grepl <- base::grepl
[16:21:50.687]                           restarts <- computeRestarts(cond)
[16:21:50.687]                           for (restart in restarts) {
[16:21:50.687]                             name <- restart$name
[16:21:50.687]                             if (is.null(name)) 
[16:21:50.687]                               next
[16:21:50.687]                             if (!grepl(pattern, name)) 
[16:21:50.687]                               next
[16:21:50.687]                             invokeRestart(restart)
[16:21:50.687]                             muffled <- TRUE
[16:21:50.687]                             break
[16:21:50.687]                           }
[16:21:50.687]                         }
[16:21:50.687]                       }
[16:21:50.687]                       invisible(muffled)
[16:21:50.687]                     }
[16:21:50.687]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.687]                   }
[16:21:50.687]                 }
[16:21:50.687]             }
[16:21:50.687]         }))
[16:21:50.687]     }, error = function(ex) {
[16:21:50.687]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.687]                 ...future.rng), started = ...future.startTime, 
[16:21:50.687]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.687]             version = "1.8"), class = "FutureResult")
[16:21:50.687]     }, finally = {
[16:21:50.687]         if (!identical(...future.workdir, getwd())) 
[16:21:50.687]             setwd(...future.workdir)
[16:21:50.687]         {
[16:21:50.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.687]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.687]             }
[16:21:50.687]             base::options(...future.oldOptions)
[16:21:50.687]             if (.Platform$OS.type == "windows") {
[16:21:50.687]                 old_names <- names(...future.oldEnvVars)
[16:21:50.687]                 envs <- base::Sys.getenv()
[16:21:50.687]                 names <- names(envs)
[16:21:50.687]                 common <- intersect(names, old_names)
[16:21:50.687]                 added <- setdiff(names, old_names)
[16:21:50.687]                 removed <- setdiff(old_names, names)
[16:21:50.687]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.687]                   envs[common]]
[16:21:50.687]                 NAMES <- toupper(changed)
[16:21:50.687]                 args <- list()
[16:21:50.687]                 for (kk in seq_along(NAMES)) {
[16:21:50.687]                   name <- changed[[kk]]
[16:21:50.687]                   NAME <- NAMES[[kk]]
[16:21:50.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.687]                     next
[16:21:50.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.687]                 }
[16:21:50.687]                 NAMES <- toupper(added)
[16:21:50.687]                 for (kk in seq_along(NAMES)) {
[16:21:50.687]                   name <- added[[kk]]
[16:21:50.687]                   NAME <- NAMES[[kk]]
[16:21:50.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.687]                     next
[16:21:50.687]                   args[[name]] <- ""
[16:21:50.687]                 }
[16:21:50.687]                 NAMES <- toupper(removed)
[16:21:50.687]                 for (kk in seq_along(NAMES)) {
[16:21:50.687]                   name <- removed[[kk]]
[16:21:50.687]                   NAME <- NAMES[[kk]]
[16:21:50.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.687]                     next
[16:21:50.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.687]                 }
[16:21:50.687]                 if (length(args) > 0) 
[16:21:50.687]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.687]             }
[16:21:50.687]             else {
[16:21:50.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.687]             }
[16:21:50.687]             {
[16:21:50.687]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.687]                   0L) {
[16:21:50.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.687]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.687]                   base::options(opts)
[16:21:50.687]                 }
[16:21:50.687]                 {
[16:21:50.687]                   {
[16:21:50.687]                     NULL
[16:21:50.687]                     RNGkind("Mersenne-Twister")
[16:21:50.687]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.687]                       inherits = FALSE)
[16:21:50.687]                   }
[16:21:50.687]                   options(future.plan = NULL)
[16:21:50.687]                   if (is.na(NA_character_)) 
[16:21:50.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.687]                     .init = FALSE)
[16:21:50.687]                 }
[16:21:50.687]             }
[16:21:50.687]         }
[16:21:50.687]     })
[16:21:50.687]     if (TRUE) {
[16:21:50.687]         base::sink(type = "output", split = FALSE)
[16:21:50.687]         if (TRUE) {
[16:21:50.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.687]         }
[16:21:50.687]         else {
[16:21:50.687]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.687]         }
[16:21:50.687]         base::close(...future.stdout)
[16:21:50.687]         ...future.stdout <- NULL
[16:21:50.687]     }
[16:21:50.687]     ...future.result$conditions <- ...future.conditions
[16:21:50.687]     ...future.result$finished <- base::Sys.time()
[16:21:50.687]     ...future.result
[16:21:50.687] }
[16:21:50.689] plan(): Setting new future strategy stack:
[16:21:50.689] List of future strategies:
[16:21:50.689] 1. sequential:
[16:21:50.689]    - args: function (..., envir = parent.frame())
[16:21:50.689]    - tweaked: FALSE
[16:21:50.689]    - call: NULL
[16:21:50.689] plan(): nbrOfWorkers() = 1
[16:21:50.690] plan(): Setting new future strategy stack:
[16:21:50.690] List of future strategies:
[16:21:50.690] 1. sequential:
[16:21:50.690]    - args: function (..., envir = parent.frame())
[16:21:50.690]    - tweaked: FALSE
[16:21:50.690]    - call: plan(strategy)
[16:21:50.690] plan(): nbrOfWorkers() = 1
[16:21:50.691] SequentialFuture started (and completed)
[16:21:50.691] - Launch lazy future ... done
[16:21:50.691] run() for ‘SequentialFuture’ ... done
[16:21:50.691] getGlobalsAndPackages() ...
[16:21:50.691] Searching for globals...
[16:21:50.691] 
[16:21:50.692] Searching for globals ... DONE
[16:21:50.692] - globals: [0] <none>
[16:21:50.692] getGlobalsAndPackages() ... DONE
[16:21:50.692] run() for ‘Future’ ...
[16:21:50.692] - state: ‘created’
[16:21:50.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.692] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.693]   - Field: ‘label’
[16:21:50.693]   - Field: ‘local’
[16:21:50.693]   - Field: ‘owner’
[16:21:50.693]   - Field: ‘envir’
[16:21:50.693]   - Field: ‘packages’
[16:21:50.693]   - Field: ‘gc’
[16:21:50.693]   - Field: ‘conditions’
[16:21:50.693]   - Field: ‘expr’
[16:21:50.693]   - Field: ‘uuid’
[16:21:50.694]   - Field: ‘seed’
[16:21:50.694]   - Field: ‘version’
[16:21:50.694]   - Field: ‘result’
[16:21:50.694]   - Field: ‘asynchronous’
[16:21:50.694]   - Field: ‘calls’
[16:21:50.694]   - Field: ‘globals’
[16:21:50.694]   - Field: ‘stdout’
[16:21:50.694]   - Field: ‘earlySignal’
[16:21:50.694]   - Field: ‘lazy’
[16:21:50.694]   - Field: ‘state’
[16:21:50.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.695] - Launch lazy future ...
[16:21:50.695] Packages needed by the future expression (n = 0): <none>
[16:21:50.695] Packages needed by future strategies (n = 0): <none>
[16:21:50.695] {
[16:21:50.695]     {
[16:21:50.695]         {
[16:21:50.695]             ...future.startTime <- base::Sys.time()
[16:21:50.695]             {
[16:21:50.695]                 {
[16:21:50.695]                   {
[16:21:50.695]                     base::local({
[16:21:50.695]                       has_future <- base::requireNamespace("future", 
[16:21:50.695]                         quietly = TRUE)
[16:21:50.695]                       if (has_future) {
[16:21:50.695]                         ns <- base::getNamespace("future")
[16:21:50.695]                         version <- ns[[".package"]][["version"]]
[16:21:50.695]                         if (is.null(version)) 
[16:21:50.695]                           version <- utils::packageVersion("future")
[16:21:50.695]                       }
[16:21:50.695]                       else {
[16:21:50.695]                         version <- NULL
[16:21:50.695]                       }
[16:21:50.695]                       if (!has_future || version < "1.8.0") {
[16:21:50.695]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.695]                           "", base::R.version$version.string), 
[16:21:50.695]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.695]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.695]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.695]                             "release", "version")], collapse = " "), 
[16:21:50.695]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.695]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.695]                           info)
[16:21:50.695]                         info <- base::paste(info, collapse = "; ")
[16:21:50.695]                         if (!has_future) {
[16:21:50.695]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.695]                             info)
[16:21:50.695]                         }
[16:21:50.695]                         else {
[16:21:50.695]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.695]                             info, version)
[16:21:50.695]                         }
[16:21:50.695]                         base::stop(msg)
[16:21:50.695]                       }
[16:21:50.695]                     })
[16:21:50.695]                   }
[16:21:50.695]                   ...future.strategy.old <- future::plan("list")
[16:21:50.695]                   options(future.plan = NULL)
[16:21:50.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.695]                 }
[16:21:50.695]                 ...future.workdir <- getwd()
[16:21:50.695]             }
[16:21:50.695]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.695]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.695]         }
[16:21:50.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.695]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.695]             base::names(...future.oldOptions))
[16:21:50.695]     }
[16:21:50.695]     if (FALSE) {
[16:21:50.695]     }
[16:21:50.695]     else {
[16:21:50.695]         if (TRUE) {
[16:21:50.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.695]                 open = "w")
[16:21:50.695]         }
[16:21:50.695]         else {
[16:21:50.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.695]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.695]         }
[16:21:50.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.695]             base::sink(type = "output", split = FALSE)
[16:21:50.695]             base::close(...future.stdout)
[16:21:50.695]         }, add = TRUE)
[16:21:50.695]     }
[16:21:50.695]     ...future.frame <- base::sys.nframe()
[16:21:50.695]     ...future.conditions <- base::list()
[16:21:50.695]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.695]     if (FALSE) {
[16:21:50.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.695]     }
[16:21:50.695]     ...future.result <- base::tryCatch({
[16:21:50.695]         base::withCallingHandlers({
[16:21:50.695]             ...future.value <- base::withVisible(base::local(2))
[16:21:50.695]             future::FutureResult(value = ...future.value$value, 
[16:21:50.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.695]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.695]                     ...future.globalenv.names))
[16:21:50.695]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.695]         }, condition = base::local({
[16:21:50.695]             c <- base::c
[16:21:50.695]             inherits <- base::inherits
[16:21:50.695]             invokeRestart <- base::invokeRestart
[16:21:50.695]             length <- base::length
[16:21:50.695]             list <- base::list
[16:21:50.695]             seq.int <- base::seq.int
[16:21:50.695]             signalCondition <- base::signalCondition
[16:21:50.695]             sys.calls <- base::sys.calls
[16:21:50.695]             `[[` <- base::`[[`
[16:21:50.695]             `+` <- base::`+`
[16:21:50.695]             `<<-` <- base::`<<-`
[16:21:50.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.695]                   3L)]
[16:21:50.695]             }
[16:21:50.695]             function(cond) {
[16:21:50.695]                 is_error <- inherits(cond, "error")
[16:21:50.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.695]                   NULL)
[16:21:50.695]                 if (is_error) {
[16:21:50.695]                   sessionInformation <- function() {
[16:21:50.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.695]                       search = base::search(), system = base::Sys.info())
[16:21:50.695]                   }
[16:21:50.695]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.695]                     cond$call), session = sessionInformation(), 
[16:21:50.695]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.695]                   signalCondition(cond)
[16:21:50.695]                 }
[16:21:50.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.695]                 "immediateCondition"))) {
[16:21:50.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.695]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.695]                   if (TRUE && !signal) {
[16:21:50.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.695]                     {
[16:21:50.695]                       inherits <- base::inherits
[16:21:50.695]                       invokeRestart <- base::invokeRestart
[16:21:50.695]                       is.null <- base::is.null
[16:21:50.695]                       muffled <- FALSE
[16:21:50.695]                       if (inherits(cond, "message")) {
[16:21:50.695]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.695]                         if (muffled) 
[16:21:50.695]                           invokeRestart("muffleMessage")
[16:21:50.695]                       }
[16:21:50.695]                       else if (inherits(cond, "warning")) {
[16:21:50.695]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.695]                         if (muffled) 
[16:21:50.695]                           invokeRestart("muffleWarning")
[16:21:50.695]                       }
[16:21:50.695]                       else if (inherits(cond, "condition")) {
[16:21:50.695]                         if (!is.null(pattern)) {
[16:21:50.695]                           computeRestarts <- base::computeRestarts
[16:21:50.695]                           grepl <- base::grepl
[16:21:50.695]                           restarts <- computeRestarts(cond)
[16:21:50.695]                           for (restart in restarts) {
[16:21:50.695]                             name <- restart$name
[16:21:50.695]                             if (is.null(name)) 
[16:21:50.695]                               next
[16:21:50.695]                             if (!grepl(pattern, name)) 
[16:21:50.695]                               next
[16:21:50.695]                             invokeRestart(restart)
[16:21:50.695]                             muffled <- TRUE
[16:21:50.695]                             break
[16:21:50.695]                           }
[16:21:50.695]                         }
[16:21:50.695]                       }
[16:21:50.695]                       invisible(muffled)
[16:21:50.695]                     }
[16:21:50.695]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.695]                   }
[16:21:50.695]                 }
[16:21:50.695]                 else {
[16:21:50.695]                   if (TRUE) {
[16:21:50.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.695]                     {
[16:21:50.695]                       inherits <- base::inherits
[16:21:50.695]                       invokeRestart <- base::invokeRestart
[16:21:50.695]                       is.null <- base::is.null
[16:21:50.695]                       muffled <- FALSE
[16:21:50.695]                       if (inherits(cond, "message")) {
[16:21:50.695]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.695]                         if (muffled) 
[16:21:50.695]                           invokeRestart("muffleMessage")
[16:21:50.695]                       }
[16:21:50.695]                       else if (inherits(cond, "warning")) {
[16:21:50.695]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.695]                         if (muffled) 
[16:21:50.695]                           invokeRestart("muffleWarning")
[16:21:50.695]                       }
[16:21:50.695]                       else if (inherits(cond, "condition")) {
[16:21:50.695]                         if (!is.null(pattern)) {
[16:21:50.695]                           computeRestarts <- base::computeRestarts
[16:21:50.695]                           grepl <- base::grepl
[16:21:50.695]                           restarts <- computeRestarts(cond)
[16:21:50.695]                           for (restart in restarts) {
[16:21:50.695]                             name <- restart$name
[16:21:50.695]                             if (is.null(name)) 
[16:21:50.695]                               next
[16:21:50.695]                             if (!grepl(pattern, name)) 
[16:21:50.695]                               next
[16:21:50.695]                             invokeRestart(restart)
[16:21:50.695]                             muffled <- TRUE
[16:21:50.695]                             break
[16:21:50.695]                           }
[16:21:50.695]                         }
[16:21:50.695]                       }
[16:21:50.695]                       invisible(muffled)
[16:21:50.695]                     }
[16:21:50.695]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.695]                   }
[16:21:50.695]                 }
[16:21:50.695]             }
[16:21:50.695]         }))
[16:21:50.695]     }, error = function(ex) {
[16:21:50.695]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.695]                 ...future.rng), started = ...future.startTime, 
[16:21:50.695]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.695]             version = "1.8"), class = "FutureResult")
[16:21:50.695]     }, finally = {
[16:21:50.695]         if (!identical(...future.workdir, getwd())) 
[16:21:50.695]             setwd(...future.workdir)
[16:21:50.695]         {
[16:21:50.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.695]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.695]             }
[16:21:50.695]             base::options(...future.oldOptions)
[16:21:50.695]             if (.Platform$OS.type == "windows") {
[16:21:50.695]                 old_names <- names(...future.oldEnvVars)
[16:21:50.695]                 envs <- base::Sys.getenv()
[16:21:50.695]                 names <- names(envs)
[16:21:50.695]                 common <- intersect(names, old_names)
[16:21:50.695]                 added <- setdiff(names, old_names)
[16:21:50.695]                 removed <- setdiff(old_names, names)
[16:21:50.695]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.695]                   envs[common]]
[16:21:50.695]                 NAMES <- toupper(changed)
[16:21:50.695]                 args <- list()
[16:21:50.695]                 for (kk in seq_along(NAMES)) {
[16:21:50.695]                   name <- changed[[kk]]
[16:21:50.695]                   NAME <- NAMES[[kk]]
[16:21:50.695]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.695]                     next
[16:21:50.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.695]                 }
[16:21:50.695]                 NAMES <- toupper(added)
[16:21:50.695]                 for (kk in seq_along(NAMES)) {
[16:21:50.695]                   name <- added[[kk]]
[16:21:50.695]                   NAME <- NAMES[[kk]]
[16:21:50.695]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.695]                     next
[16:21:50.695]                   args[[name]] <- ""
[16:21:50.695]                 }
[16:21:50.695]                 NAMES <- toupper(removed)
[16:21:50.695]                 for (kk in seq_along(NAMES)) {
[16:21:50.695]                   name <- removed[[kk]]
[16:21:50.695]                   NAME <- NAMES[[kk]]
[16:21:50.695]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.695]                     next
[16:21:50.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.695]                 }
[16:21:50.695]                 if (length(args) > 0) 
[16:21:50.695]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.695]             }
[16:21:50.695]             else {
[16:21:50.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.695]             }
[16:21:50.695]             {
[16:21:50.695]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.695]                   0L) {
[16:21:50.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.695]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.695]                   base::options(opts)
[16:21:50.695]                 }
[16:21:50.695]                 {
[16:21:50.695]                   {
[16:21:50.695]                     NULL
[16:21:50.695]                     RNGkind("Mersenne-Twister")
[16:21:50.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.695]                       inherits = FALSE)
[16:21:50.695]                   }
[16:21:50.695]                   options(future.plan = NULL)
[16:21:50.695]                   if (is.na(NA_character_)) 
[16:21:50.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.695]                     .init = FALSE)
[16:21:50.695]                 }
[16:21:50.695]             }
[16:21:50.695]         }
[16:21:50.695]     })
[16:21:50.695]     if (TRUE) {
[16:21:50.695]         base::sink(type = "output", split = FALSE)
[16:21:50.695]         if (TRUE) {
[16:21:50.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.695]         }
[16:21:50.695]         else {
[16:21:50.695]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.695]         }
[16:21:50.695]         base::close(...future.stdout)
[16:21:50.695]         ...future.stdout <- NULL
[16:21:50.695]     }
[16:21:50.695]     ...future.result$conditions <- ...future.conditions
[16:21:50.695]     ...future.result$finished <- base::Sys.time()
[16:21:50.695]     ...future.result
[16:21:50.695] }
[16:21:50.697] plan(): Setting new future strategy stack:
[16:21:50.697] List of future strategies:
[16:21:50.697] 1. sequential:
[16:21:50.697]    - args: function (..., envir = parent.frame())
[16:21:50.697]    - tweaked: FALSE
[16:21:50.697]    - call: NULL
[16:21:50.697] plan(): nbrOfWorkers() = 1
[16:21:50.698] plan(): Setting new future strategy stack:
[16:21:50.698] List of future strategies:
[16:21:50.698] 1. sequential:
[16:21:50.698]    - args: function (..., envir = parent.frame())
[16:21:50.698]    - tweaked: FALSE
[16:21:50.698]    - call: plan(strategy)
[16:21:50.699] plan(): nbrOfWorkers() = 1
[16:21:50.699] SequentialFuture started (and completed)
[16:21:50.699] - Launch lazy future ... done
[16:21:50.699] run() for ‘SequentialFuture’ ... done
[16:21:50.700] resolve() on environment ...
[16:21:50.700]  recursive: 0
[16:21:50.700]  elements: [3] ‘a’, ‘b’, ‘c’
[16:21:50.700] resolved() for ‘SequentialFuture’ ...
[16:21:50.700] - state: ‘finished’
[16:21:50.700] - run: TRUE
[16:21:50.701] - result: ‘FutureResult’
[16:21:50.701] resolved() for ‘SequentialFuture’ ... done
[16:21:50.701] Future #1
[16:21:50.701]  length: 2 (resolved future 1)
[16:21:50.701] resolved() for ‘SequentialFuture’ ...
[16:21:50.701] - state: ‘finished’
[16:21:50.701] - run: TRUE
[16:21:50.701] - result: ‘FutureResult’
[16:21:50.701] resolved() for ‘SequentialFuture’ ... done
[16:21:50.701] Future #2
[16:21:50.702]  length: 1 (resolved future 2)
[16:21:50.702]  length: 0 (resolved future 3)
[16:21:50.702] resolve() on environment ... DONE
[16:21:50.702] resolved() for ‘SequentialFuture’ ...
[16:21:50.702] - state: ‘finished’
[16:21:50.702] - run: TRUE
[16:21:50.702] - result: ‘FutureResult’
[16:21:50.702] resolved() for ‘SequentialFuture’ ... done
[16:21:50.702] resolved() for ‘SequentialFuture’ ...
[16:21:50.702] - state: ‘finished’
[16:21:50.703] - run: TRUE
[16:21:50.703] - result: ‘FutureResult’
[16:21:50.703] resolved() for ‘SequentialFuture’ ... done
[16:21:50.706] getGlobalsAndPackages() ...
[16:21:50.706] Searching for globals...
[16:21:50.706] - globals found: [1] ‘{’
[16:21:50.707] Searching for globals ... DONE
[16:21:50.707] Resolving globals: FALSE
[16:21:50.707] 
[16:21:50.707] 
[16:21:50.707] getGlobalsAndPackages() ... DONE
[16:21:50.707] run() for ‘Future’ ...
[16:21:50.707] - state: ‘created’
[16:21:50.708] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.708] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.708]   - Field: ‘label’
[16:21:50.708]   - Field: ‘local’
[16:21:50.708]   - Field: ‘owner’
[16:21:50.708]   - Field: ‘envir’
[16:21:50.709]   - Field: ‘packages’
[16:21:50.709]   - Field: ‘gc’
[16:21:50.709]   - Field: ‘conditions’
[16:21:50.709]   - Field: ‘expr’
[16:21:50.709]   - Field: ‘uuid’
[16:21:50.709]   - Field: ‘seed’
[16:21:50.709]   - Field: ‘version’
[16:21:50.709]   - Field: ‘result’
[16:21:50.709]   - Field: ‘asynchronous’
[16:21:50.709]   - Field: ‘calls’
[16:21:50.709]   - Field: ‘globals’
[16:21:50.710]   - Field: ‘stdout’
[16:21:50.710]   - Field: ‘earlySignal’
[16:21:50.710]   - Field: ‘lazy’
[16:21:50.710]   - Field: ‘state’
[16:21:50.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.710] - Launch lazy future ...
[16:21:50.710] Packages needed by the future expression (n = 0): <none>
[16:21:50.710] Packages needed by future strategies (n = 0): <none>
[16:21:50.711] {
[16:21:50.711]     {
[16:21:50.711]         {
[16:21:50.711]             ...future.startTime <- base::Sys.time()
[16:21:50.711]             {
[16:21:50.711]                 {
[16:21:50.711]                   {
[16:21:50.711]                     base::local({
[16:21:50.711]                       has_future <- base::requireNamespace("future", 
[16:21:50.711]                         quietly = TRUE)
[16:21:50.711]                       if (has_future) {
[16:21:50.711]                         ns <- base::getNamespace("future")
[16:21:50.711]                         version <- ns[[".package"]][["version"]]
[16:21:50.711]                         if (is.null(version)) 
[16:21:50.711]                           version <- utils::packageVersion("future")
[16:21:50.711]                       }
[16:21:50.711]                       else {
[16:21:50.711]                         version <- NULL
[16:21:50.711]                       }
[16:21:50.711]                       if (!has_future || version < "1.8.0") {
[16:21:50.711]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.711]                           "", base::R.version$version.string), 
[16:21:50.711]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.711]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.711]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.711]                             "release", "version")], collapse = " "), 
[16:21:50.711]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.711]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.711]                           info)
[16:21:50.711]                         info <- base::paste(info, collapse = "; ")
[16:21:50.711]                         if (!has_future) {
[16:21:50.711]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.711]                             info)
[16:21:50.711]                         }
[16:21:50.711]                         else {
[16:21:50.711]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.711]                             info, version)
[16:21:50.711]                         }
[16:21:50.711]                         base::stop(msg)
[16:21:50.711]                       }
[16:21:50.711]                     })
[16:21:50.711]                   }
[16:21:50.711]                   ...future.strategy.old <- future::plan("list")
[16:21:50.711]                   options(future.plan = NULL)
[16:21:50.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.711]                 }
[16:21:50.711]                 ...future.workdir <- getwd()
[16:21:50.711]             }
[16:21:50.711]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.711]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.711]         }
[16:21:50.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.711]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.711]             base::names(...future.oldOptions))
[16:21:50.711]     }
[16:21:50.711]     if (FALSE) {
[16:21:50.711]     }
[16:21:50.711]     else {
[16:21:50.711]         if (TRUE) {
[16:21:50.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.711]                 open = "w")
[16:21:50.711]         }
[16:21:50.711]         else {
[16:21:50.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.711]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.711]         }
[16:21:50.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.711]             base::sink(type = "output", split = FALSE)
[16:21:50.711]             base::close(...future.stdout)
[16:21:50.711]         }, add = TRUE)
[16:21:50.711]     }
[16:21:50.711]     ...future.frame <- base::sys.nframe()
[16:21:50.711]     ...future.conditions <- base::list()
[16:21:50.711]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.711]     if (FALSE) {
[16:21:50.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.711]     }
[16:21:50.711]     ...future.result <- base::tryCatch({
[16:21:50.711]         base::withCallingHandlers({
[16:21:50.711]             ...future.value <- base::withVisible(base::local({
[16:21:50.711]                 1
[16:21:50.711]             }))
[16:21:50.711]             future::FutureResult(value = ...future.value$value, 
[16:21:50.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.711]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.711]                     ...future.globalenv.names))
[16:21:50.711]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.711]         }, condition = base::local({
[16:21:50.711]             c <- base::c
[16:21:50.711]             inherits <- base::inherits
[16:21:50.711]             invokeRestart <- base::invokeRestart
[16:21:50.711]             length <- base::length
[16:21:50.711]             list <- base::list
[16:21:50.711]             seq.int <- base::seq.int
[16:21:50.711]             signalCondition <- base::signalCondition
[16:21:50.711]             sys.calls <- base::sys.calls
[16:21:50.711]             `[[` <- base::`[[`
[16:21:50.711]             `+` <- base::`+`
[16:21:50.711]             `<<-` <- base::`<<-`
[16:21:50.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.711]                   3L)]
[16:21:50.711]             }
[16:21:50.711]             function(cond) {
[16:21:50.711]                 is_error <- inherits(cond, "error")
[16:21:50.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.711]                   NULL)
[16:21:50.711]                 if (is_error) {
[16:21:50.711]                   sessionInformation <- function() {
[16:21:50.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.711]                       search = base::search(), system = base::Sys.info())
[16:21:50.711]                   }
[16:21:50.711]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.711]                     cond$call), session = sessionInformation(), 
[16:21:50.711]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.711]                   signalCondition(cond)
[16:21:50.711]                 }
[16:21:50.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.711]                 "immediateCondition"))) {
[16:21:50.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.711]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.711]                   if (TRUE && !signal) {
[16:21:50.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.711]                     {
[16:21:50.711]                       inherits <- base::inherits
[16:21:50.711]                       invokeRestart <- base::invokeRestart
[16:21:50.711]                       is.null <- base::is.null
[16:21:50.711]                       muffled <- FALSE
[16:21:50.711]                       if (inherits(cond, "message")) {
[16:21:50.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.711]                         if (muffled) 
[16:21:50.711]                           invokeRestart("muffleMessage")
[16:21:50.711]                       }
[16:21:50.711]                       else if (inherits(cond, "warning")) {
[16:21:50.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.711]                         if (muffled) 
[16:21:50.711]                           invokeRestart("muffleWarning")
[16:21:50.711]                       }
[16:21:50.711]                       else if (inherits(cond, "condition")) {
[16:21:50.711]                         if (!is.null(pattern)) {
[16:21:50.711]                           computeRestarts <- base::computeRestarts
[16:21:50.711]                           grepl <- base::grepl
[16:21:50.711]                           restarts <- computeRestarts(cond)
[16:21:50.711]                           for (restart in restarts) {
[16:21:50.711]                             name <- restart$name
[16:21:50.711]                             if (is.null(name)) 
[16:21:50.711]                               next
[16:21:50.711]                             if (!grepl(pattern, name)) 
[16:21:50.711]                               next
[16:21:50.711]                             invokeRestart(restart)
[16:21:50.711]                             muffled <- TRUE
[16:21:50.711]                             break
[16:21:50.711]                           }
[16:21:50.711]                         }
[16:21:50.711]                       }
[16:21:50.711]                       invisible(muffled)
[16:21:50.711]                     }
[16:21:50.711]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.711]                   }
[16:21:50.711]                 }
[16:21:50.711]                 else {
[16:21:50.711]                   if (TRUE) {
[16:21:50.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.711]                     {
[16:21:50.711]                       inherits <- base::inherits
[16:21:50.711]                       invokeRestart <- base::invokeRestart
[16:21:50.711]                       is.null <- base::is.null
[16:21:50.711]                       muffled <- FALSE
[16:21:50.711]                       if (inherits(cond, "message")) {
[16:21:50.711]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.711]                         if (muffled) 
[16:21:50.711]                           invokeRestart("muffleMessage")
[16:21:50.711]                       }
[16:21:50.711]                       else if (inherits(cond, "warning")) {
[16:21:50.711]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.711]                         if (muffled) 
[16:21:50.711]                           invokeRestart("muffleWarning")
[16:21:50.711]                       }
[16:21:50.711]                       else if (inherits(cond, "condition")) {
[16:21:50.711]                         if (!is.null(pattern)) {
[16:21:50.711]                           computeRestarts <- base::computeRestarts
[16:21:50.711]                           grepl <- base::grepl
[16:21:50.711]                           restarts <- computeRestarts(cond)
[16:21:50.711]                           for (restart in restarts) {
[16:21:50.711]                             name <- restart$name
[16:21:50.711]                             if (is.null(name)) 
[16:21:50.711]                               next
[16:21:50.711]                             if (!grepl(pattern, name)) 
[16:21:50.711]                               next
[16:21:50.711]                             invokeRestart(restart)
[16:21:50.711]                             muffled <- TRUE
[16:21:50.711]                             break
[16:21:50.711]                           }
[16:21:50.711]                         }
[16:21:50.711]                       }
[16:21:50.711]                       invisible(muffled)
[16:21:50.711]                     }
[16:21:50.711]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.711]                   }
[16:21:50.711]                 }
[16:21:50.711]             }
[16:21:50.711]         }))
[16:21:50.711]     }, error = function(ex) {
[16:21:50.711]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.711]                 ...future.rng), started = ...future.startTime, 
[16:21:50.711]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.711]             version = "1.8"), class = "FutureResult")
[16:21:50.711]     }, finally = {
[16:21:50.711]         if (!identical(...future.workdir, getwd())) 
[16:21:50.711]             setwd(...future.workdir)
[16:21:50.711]         {
[16:21:50.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.711]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.711]             }
[16:21:50.711]             base::options(...future.oldOptions)
[16:21:50.711]             if (.Platform$OS.type == "windows") {
[16:21:50.711]                 old_names <- names(...future.oldEnvVars)
[16:21:50.711]                 envs <- base::Sys.getenv()
[16:21:50.711]                 names <- names(envs)
[16:21:50.711]                 common <- intersect(names, old_names)
[16:21:50.711]                 added <- setdiff(names, old_names)
[16:21:50.711]                 removed <- setdiff(old_names, names)
[16:21:50.711]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.711]                   envs[common]]
[16:21:50.711]                 NAMES <- toupper(changed)
[16:21:50.711]                 args <- list()
[16:21:50.711]                 for (kk in seq_along(NAMES)) {
[16:21:50.711]                   name <- changed[[kk]]
[16:21:50.711]                   NAME <- NAMES[[kk]]
[16:21:50.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.711]                     next
[16:21:50.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.711]                 }
[16:21:50.711]                 NAMES <- toupper(added)
[16:21:50.711]                 for (kk in seq_along(NAMES)) {
[16:21:50.711]                   name <- added[[kk]]
[16:21:50.711]                   NAME <- NAMES[[kk]]
[16:21:50.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.711]                     next
[16:21:50.711]                   args[[name]] <- ""
[16:21:50.711]                 }
[16:21:50.711]                 NAMES <- toupper(removed)
[16:21:50.711]                 for (kk in seq_along(NAMES)) {
[16:21:50.711]                   name <- removed[[kk]]
[16:21:50.711]                   NAME <- NAMES[[kk]]
[16:21:50.711]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.711]                     next
[16:21:50.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.711]                 }
[16:21:50.711]                 if (length(args) > 0) 
[16:21:50.711]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.711]             }
[16:21:50.711]             else {
[16:21:50.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.711]             }
[16:21:50.711]             {
[16:21:50.711]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.711]                   0L) {
[16:21:50.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.711]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.711]                   base::options(opts)
[16:21:50.711]                 }
[16:21:50.711]                 {
[16:21:50.711]                   {
[16:21:50.711]                     NULL
[16:21:50.711]                     RNGkind("Mersenne-Twister")
[16:21:50.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.711]                       inherits = FALSE)
[16:21:50.711]                   }
[16:21:50.711]                   options(future.plan = NULL)
[16:21:50.711]                   if (is.na(NA_character_)) 
[16:21:50.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.711]                     .init = FALSE)
[16:21:50.711]                 }
[16:21:50.711]             }
[16:21:50.711]         }
[16:21:50.711]     })
[16:21:50.711]     if (TRUE) {
[16:21:50.711]         base::sink(type = "output", split = FALSE)
[16:21:50.711]         if (TRUE) {
[16:21:50.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.711]         }
[16:21:50.711]         else {
[16:21:50.711]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.711]         }
[16:21:50.711]         base::close(...future.stdout)
[16:21:50.711]         ...future.stdout <- NULL
[16:21:50.711]     }
[16:21:50.711]     ...future.result$conditions <- ...future.conditions
[16:21:50.711]     ...future.result$finished <- base::Sys.time()
[16:21:50.711]     ...future.result
[16:21:50.711] }
[16:21:50.713] plan(): Setting new future strategy stack:
[16:21:50.713] List of future strategies:
[16:21:50.713] 1. sequential:
[16:21:50.713]    - args: function (..., envir = parent.frame())
[16:21:50.713]    - tweaked: FALSE
[16:21:50.713]    - call: NULL
[16:21:50.713] plan(): nbrOfWorkers() = 1
[16:21:50.714] plan(): Setting new future strategy stack:
[16:21:50.714] List of future strategies:
[16:21:50.714] 1. sequential:
[16:21:50.714]    - args: function (..., envir = parent.frame())
[16:21:50.714]    - tweaked: FALSE
[16:21:50.714]    - call: plan(strategy)
[16:21:50.714] plan(): nbrOfWorkers() = 1
[16:21:50.714] SequentialFuture started (and completed)
[16:21:50.715] - Launch lazy future ... done
[16:21:50.715] run() for ‘SequentialFuture’ ... done
[16:21:50.715] getGlobalsAndPackages() ...
[16:21:50.715] Searching for globals...
[16:21:50.716] - globals found: [1] ‘{’
[16:21:50.716] Searching for globals ... DONE
[16:21:50.716] Resolving globals: FALSE
[16:21:50.716] 
[16:21:50.716] 
[16:21:50.716] getGlobalsAndPackages() ... DONE
[16:21:50.717] run() for ‘Future’ ...
[16:21:50.717] - state: ‘created’
[16:21:50.717] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.717]   - Field: ‘label’
[16:21:50.717]   - Field: ‘local’
[16:21:50.717]   - Field: ‘owner’
[16:21:50.718]   - Field: ‘envir’
[16:21:50.718]   - Field: ‘packages’
[16:21:50.718]   - Field: ‘gc’
[16:21:50.718]   - Field: ‘conditions’
[16:21:50.718]   - Field: ‘expr’
[16:21:50.718]   - Field: ‘uuid’
[16:21:50.718]   - Field: ‘seed’
[16:21:50.718]   - Field: ‘version’
[16:21:50.718]   - Field: ‘result’
[16:21:50.718]   - Field: ‘asynchronous’
[16:21:50.719]   - Field: ‘calls’
[16:21:50.719]   - Field: ‘globals’
[16:21:50.719]   - Field: ‘stdout’
[16:21:50.719]   - Field: ‘earlySignal’
[16:21:50.719]   - Field: ‘lazy’
[16:21:50.719]   - Field: ‘state’
[16:21:50.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.719] - Launch lazy future ...
[16:21:50.719] Packages needed by the future expression (n = 0): <none>
[16:21:50.719] Packages needed by future strategies (n = 0): <none>
[16:21:50.720] {
[16:21:50.720]     {
[16:21:50.720]         {
[16:21:50.720]             ...future.startTime <- base::Sys.time()
[16:21:50.720]             {
[16:21:50.720]                 {
[16:21:50.720]                   {
[16:21:50.720]                     base::local({
[16:21:50.720]                       has_future <- base::requireNamespace("future", 
[16:21:50.720]                         quietly = TRUE)
[16:21:50.720]                       if (has_future) {
[16:21:50.720]                         ns <- base::getNamespace("future")
[16:21:50.720]                         version <- ns[[".package"]][["version"]]
[16:21:50.720]                         if (is.null(version)) 
[16:21:50.720]                           version <- utils::packageVersion("future")
[16:21:50.720]                       }
[16:21:50.720]                       else {
[16:21:50.720]                         version <- NULL
[16:21:50.720]                       }
[16:21:50.720]                       if (!has_future || version < "1.8.0") {
[16:21:50.720]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.720]                           "", base::R.version$version.string), 
[16:21:50.720]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.720]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.720]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.720]                             "release", "version")], collapse = " "), 
[16:21:50.720]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.720]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.720]                           info)
[16:21:50.720]                         info <- base::paste(info, collapse = "; ")
[16:21:50.720]                         if (!has_future) {
[16:21:50.720]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.720]                             info)
[16:21:50.720]                         }
[16:21:50.720]                         else {
[16:21:50.720]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.720]                             info, version)
[16:21:50.720]                         }
[16:21:50.720]                         base::stop(msg)
[16:21:50.720]                       }
[16:21:50.720]                     })
[16:21:50.720]                   }
[16:21:50.720]                   ...future.strategy.old <- future::plan("list")
[16:21:50.720]                   options(future.plan = NULL)
[16:21:50.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.720]                 }
[16:21:50.720]                 ...future.workdir <- getwd()
[16:21:50.720]             }
[16:21:50.720]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.720]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.720]         }
[16:21:50.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.720]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.720]             base::names(...future.oldOptions))
[16:21:50.720]     }
[16:21:50.720]     if (FALSE) {
[16:21:50.720]     }
[16:21:50.720]     else {
[16:21:50.720]         if (TRUE) {
[16:21:50.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.720]                 open = "w")
[16:21:50.720]         }
[16:21:50.720]         else {
[16:21:50.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.720]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.720]         }
[16:21:50.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.720]             base::sink(type = "output", split = FALSE)
[16:21:50.720]             base::close(...future.stdout)
[16:21:50.720]         }, add = TRUE)
[16:21:50.720]     }
[16:21:50.720]     ...future.frame <- base::sys.nframe()
[16:21:50.720]     ...future.conditions <- base::list()
[16:21:50.720]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.720]     if (FALSE) {
[16:21:50.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.720]     }
[16:21:50.720]     ...future.result <- base::tryCatch({
[16:21:50.720]         base::withCallingHandlers({
[16:21:50.720]             ...future.value <- base::withVisible(base::local({
[16:21:50.720]                 2
[16:21:50.720]             }))
[16:21:50.720]             future::FutureResult(value = ...future.value$value, 
[16:21:50.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.720]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.720]                     ...future.globalenv.names))
[16:21:50.720]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.720]         }, condition = base::local({
[16:21:50.720]             c <- base::c
[16:21:50.720]             inherits <- base::inherits
[16:21:50.720]             invokeRestart <- base::invokeRestart
[16:21:50.720]             length <- base::length
[16:21:50.720]             list <- base::list
[16:21:50.720]             seq.int <- base::seq.int
[16:21:50.720]             signalCondition <- base::signalCondition
[16:21:50.720]             sys.calls <- base::sys.calls
[16:21:50.720]             `[[` <- base::`[[`
[16:21:50.720]             `+` <- base::`+`
[16:21:50.720]             `<<-` <- base::`<<-`
[16:21:50.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.720]                   3L)]
[16:21:50.720]             }
[16:21:50.720]             function(cond) {
[16:21:50.720]                 is_error <- inherits(cond, "error")
[16:21:50.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.720]                   NULL)
[16:21:50.720]                 if (is_error) {
[16:21:50.720]                   sessionInformation <- function() {
[16:21:50.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.720]                       search = base::search(), system = base::Sys.info())
[16:21:50.720]                   }
[16:21:50.720]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.720]                     cond$call), session = sessionInformation(), 
[16:21:50.720]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.720]                   signalCondition(cond)
[16:21:50.720]                 }
[16:21:50.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.720]                 "immediateCondition"))) {
[16:21:50.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.720]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.720]                   if (TRUE && !signal) {
[16:21:50.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.720]                     {
[16:21:50.720]                       inherits <- base::inherits
[16:21:50.720]                       invokeRestart <- base::invokeRestart
[16:21:50.720]                       is.null <- base::is.null
[16:21:50.720]                       muffled <- FALSE
[16:21:50.720]                       if (inherits(cond, "message")) {
[16:21:50.720]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.720]                         if (muffled) 
[16:21:50.720]                           invokeRestart("muffleMessage")
[16:21:50.720]                       }
[16:21:50.720]                       else if (inherits(cond, "warning")) {
[16:21:50.720]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.720]                         if (muffled) 
[16:21:50.720]                           invokeRestart("muffleWarning")
[16:21:50.720]                       }
[16:21:50.720]                       else if (inherits(cond, "condition")) {
[16:21:50.720]                         if (!is.null(pattern)) {
[16:21:50.720]                           computeRestarts <- base::computeRestarts
[16:21:50.720]                           grepl <- base::grepl
[16:21:50.720]                           restarts <- computeRestarts(cond)
[16:21:50.720]                           for (restart in restarts) {
[16:21:50.720]                             name <- restart$name
[16:21:50.720]                             if (is.null(name)) 
[16:21:50.720]                               next
[16:21:50.720]                             if (!grepl(pattern, name)) 
[16:21:50.720]                               next
[16:21:50.720]                             invokeRestart(restart)
[16:21:50.720]                             muffled <- TRUE
[16:21:50.720]                             break
[16:21:50.720]                           }
[16:21:50.720]                         }
[16:21:50.720]                       }
[16:21:50.720]                       invisible(muffled)
[16:21:50.720]                     }
[16:21:50.720]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.720]                   }
[16:21:50.720]                 }
[16:21:50.720]                 else {
[16:21:50.720]                   if (TRUE) {
[16:21:50.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.720]                     {
[16:21:50.720]                       inherits <- base::inherits
[16:21:50.720]                       invokeRestart <- base::invokeRestart
[16:21:50.720]                       is.null <- base::is.null
[16:21:50.720]                       muffled <- FALSE
[16:21:50.720]                       if (inherits(cond, "message")) {
[16:21:50.720]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.720]                         if (muffled) 
[16:21:50.720]                           invokeRestart("muffleMessage")
[16:21:50.720]                       }
[16:21:50.720]                       else if (inherits(cond, "warning")) {
[16:21:50.720]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.720]                         if (muffled) 
[16:21:50.720]                           invokeRestart("muffleWarning")
[16:21:50.720]                       }
[16:21:50.720]                       else if (inherits(cond, "condition")) {
[16:21:50.720]                         if (!is.null(pattern)) {
[16:21:50.720]                           computeRestarts <- base::computeRestarts
[16:21:50.720]                           grepl <- base::grepl
[16:21:50.720]                           restarts <- computeRestarts(cond)
[16:21:50.720]                           for (restart in restarts) {
[16:21:50.720]                             name <- restart$name
[16:21:50.720]                             if (is.null(name)) 
[16:21:50.720]                               next
[16:21:50.720]                             if (!grepl(pattern, name)) 
[16:21:50.720]                               next
[16:21:50.720]                             invokeRestart(restart)
[16:21:50.720]                             muffled <- TRUE
[16:21:50.720]                             break
[16:21:50.720]                           }
[16:21:50.720]                         }
[16:21:50.720]                       }
[16:21:50.720]                       invisible(muffled)
[16:21:50.720]                     }
[16:21:50.720]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.720]                   }
[16:21:50.720]                 }
[16:21:50.720]             }
[16:21:50.720]         }))
[16:21:50.720]     }, error = function(ex) {
[16:21:50.720]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.720]                 ...future.rng), started = ...future.startTime, 
[16:21:50.720]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.720]             version = "1.8"), class = "FutureResult")
[16:21:50.720]     }, finally = {
[16:21:50.720]         if (!identical(...future.workdir, getwd())) 
[16:21:50.720]             setwd(...future.workdir)
[16:21:50.720]         {
[16:21:50.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.720]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.720]             }
[16:21:50.720]             base::options(...future.oldOptions)
[16:21:50.720]             if (.Platform$OS.type == "windows") {
[16:21:50.720]                 old_names <- names(...future.oldEnvVars)
[16:21:50.720]                 envs <- base::Sys.getenv()
[16:21:50.720]                 names <- names(envs)
[16:21:50.720]                 common <- intersect(names, old_names)
[16:21:50.720]                 added <- setdiff(names, old_names)
[16:21:50.720]                 removed <- setdiff(old_names, names)
[16:21:50.720]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.720]                   envs[common]]
[16:21:50.720]                 NAMES <- toupper(changed)
[16:21:50.720]                 args <- list()
[16:21:50.720]                 for (kk in seq_along(NAMES)) {
[16:21:50.720]                   name <- changed[[kk]]
[16:21:50.720]                   NAME <- NAMES[[kk]]
[16:21:50.720]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.720]                     next
[16:21:50.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.720]                 }
[16:21:50.720]                 NAMES <- toupper(added)
[16:21:50.720]                 for (kk in seq_along(NAMES)) {
[16:21:50.720]                   name <- added[[kk]]
[16:21:50.720]                   NAME <- NAMES[[kk]]
[16:21:50.720]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.720]                     next
[16:21:50.720]                   args[[name]] <- ""
[16:21:50.720]                 }
[16:21:50.720]                 NAMES <- toupper(removed)
[16:21:50.720]                 for (kk in seq_along(NAMES)) {
[16:21:50.720]                   name <- removed[[kk]]
[16:21:50.720]                   NAME <- NAMES[[kk]]
[16:21:50.720]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.720]                     next
[16:21:50.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.720]                 }
[16:21:50.720]                 if (length(args) > 0) 
[16:21:50.720]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.720]             }
[16:21:50.720]             else {
[16:21:50.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.720]             }
[16:21:50.720]             {
[16:21:50.720]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.720]                   0L) {
[16:21:50.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.720]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.720]                   base::options(opts)
[16:21:50.720]                 }
[16:21:50.720]                 {
[16:21:50.720]                   {
[16:21:50.720]                     NULL
[16:21:50.720]                     RNGkind("Mersenne-Twister")
[16:21:50.720]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.720]                       inherits = FALSE)
[16:21:50.720]                   }
[16:21:50.720]                   options(future.plan = NULL)
[16:21:50.720]                   if (is.na(NA_character_)) 
[16:21:50.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.720]                     .init = FALSE)
[16:21:50.720]                 }
[16:21:50.720]             }
[16:21:50.720]         }
[16:21:50.720]     })
[16:21:50.720]     if (TRUE) {
[16:21:50.720]         base::sink(type = "output", split = FALSE)
[16:21:50.720]         if (TRUE) {
[16:21:50.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.720]         }
[16:21:50.720]         else {
[16:21:50.720]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.720]         }
[16:21:50.720]         base::close(...future.stdout)
[16:21:50.720]         ...future.stdout <- NULL
[16:21:50.720]     }
[16:21:50.720]     ...future.result$conditions <- ...future.conditions
[16:21:50.720]     ...future.result$finished <- base::Sys.time()
[16:21:50.720]     ...future.result
[16:21:50.720] }
[16:21:50.722] plan(): Setting new future strategy stack:
[16:21:50.722] List of future strategies:
[16:21:50.722] 1. sequential:
[16:21:50.722]    - args: function (..., envir = parent.frame())
[16:21:50.722]    - tweaked: FALSE
[16:21:50.722]    - call: NULL
[16:21:50.722] plan(): nbrOfWorkers() = 1
[16:21:50.723] plan(): Setting new future strategy stack:
[16:21:50.723] List of future strategies:
[16:21:50.723] 1. sequential:
[16:21:50.723]    - args: function (..., envir = parent.frame())
[16:21:50.723]    - tweaked: FALSE
[16:21:50.723]    - call: plan(strategy)
[16:21:50.723] plan(): nbrOfWorkers() = 1
[16:21:50.723] SequentialFuture started (and completed)
[16:21:50.723] - Launch lazy future ... done
[16:21:50.724] run() for ‘SequentialFuture’ ... done
[16:21:50.724] resolve() on environment ...
[16:21:50.724]  recursive: 0
[16:21:50.725]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:21:50.725] resolved() for ‘SequentialFuture’ ...
[16:21:50.725] - state: ‘finished’
[16:21:50.725] - run: TRUE
[16:21:50.725] - result: ‘FutureResult’
[16:21:50.725] resolved() for ‘SequentialFuture’ ... done
[16:21:50.725] Future #1
[16:21:50.725]  length: 2 (resolved future 1)
[16:21:50.725] resolved() for ‘SequentialFuture’ ...
[16:21:50.726] - state: ‘finished’
[16:21:50.726] - run: TRUE
[16:21:50.726] - result: ‘FutureResult’
[16:21:50.726] resolved() for ‘SequentialFuture’ ... done
[16:21:50.726] Future #2
[16:21:50.726]  length: 1 (resolved future 2)
[16:21:50.726]  length: 0 (resolved future 3)
[16:21:50.726] resolve() on environment ... DONE
[16:21:50.727] getGlobalsAndPackages() ...
[16:21:50.727] Searching for globals...
[16:21:50.727] - globals found: [1] ‘{’
[16:21:50.727] Searching for globals ... DONE
[16:21:50.728] Resolving globals: FALSE
[16:21:50.728] 
[16:21:50.728] 
[16:21:50.728] getGlobalsAndPackages() ... DONE
[16:21:50.728] run() for ‘Future’ ...
[16:21:50.728] - state: ‘created’
[16:21:50.728] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.729] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.729]   - Field: ‘label’
[16:21:50.729]   - Field: ‘local’
[16:21:50.729]   - Field: ‘owner’
[16:21:50.729]   - Field: ‘envir’
[16:21:50.729]   - Field: ‘packages’
[16:21:50.729]   - Field: ‘gc’
[16:21:50.729]   - Field: ‘conditions’
[16:21:50.730]   - Field: ‘expr’
[16:21:50.730]   - Field: ‘uuid’
[16:21:50.730]   - Field: ‘seed’
[16:21:50.730]   - Field: ‘version’
[16:21:50.730]   - Field: ‘result’
[16:21:50.730]   - Field: ‘asynchronous’
[16:21:50.730]   - Field: ‘calls’
[16:21:50.730]   - Field: ‘globals’
[16:21:50.730]   - Field: ‘stdout’
[16:21:50.730]   - Field: ‘earlySignal’
[16:21:50.731]   - Field: ‘lazy’
[16:21:50.731]   - Field: ‘state’
[16:21:50.731] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.731] - Launch lazy future ...
[16:21:50.731] Packages needed by the future expression (n = 0): <none>
[16:21:50.731] Packages needed by future strategies (n = 0): <none>
[16:21:50.733] {
[16:21:50.733]     {
[16:21:50.733]         {
[16:21:50.733]             ...future.startTime <- base::Sys.time()
[16:21:50.733]             {
[16:21:50.733]                 {
[16:21:50.733]                   {
[16:21:50.733]                     base::local({
[16:21:50.733]                       has_future <- base::requireNamespace("future", 
[16:21:50.733]                         quietly = TRUE)
[16:21:50.733]                       if (has_future) {
[16:21:50.733]                         ns <- base::getNamespace("future")
[16:21:50.733]                         version <- ns[[".package"]][["version"]]
[16:21:50.733]                         if (is.null(version)) 
[16:21:50.733]                           version <- utils::packageVersion("future")
[16:21:50.733]                       }
[16:21:50.733]                       else {
[16:21:50.733]                         version <- NULL
[16:21:50.733]                       }
[16:21:50.733]                       if (!has_future || version < "1.8.0") {
[16:21:50.733]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.733]                           "", base::R.version$version.string), 
[16:21:50.733]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.733]                             "release", "version")], collapse = " "), 
[16:21:50.733]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.733]                           info)
[16:21:50.733]                         info <- base::paste(info, collapse = "; ")
[16:21:50.733]                         if (!has_future) {
[16:21:50.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.733]                             info)
[16:21:50.733]                         }
[16:21:50.733]                         else {
[16:21:50.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.733]                             info, version)
[16:21:50.733]                         }
[16:21:50.733]                         base::stop(msg)
[16:21:50.733]                       }
[16:21:50.733]                     })
[16:21:50.733]                   }
[16:21:50.733]                   ...future.strategy.old <- future::plan("list")
[16:21:50.733]                   options(future.plan = NULL)
[16:21:50.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.733]                 }
[16:21:50.733]                 ...future.workdir <- getwd()
[16:21:50.733]             }
[16:21:50.733]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.733]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.733]         }
[16:21:50.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.733]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.733]             base::names(...future.oldOptions))
[16:21:50.733]     }
[16:21:50.733]     if (FALSE) {
[16:21:50.733]     }
[16:21:50.733]     else {
[16:21:50.733]         if (TRUE) {
[16:21:50.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.733]                 open = "w")
[16:21:50.733]         }
[16:21:50.733]         else {
[16:21:50.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.733]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.733]         }
[16:21:50.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.733]             base::sink(type = "output", split = FALSE)
[16:21:50.733]             base::close(...future.stdout)
[16:21:50.733]         }, add = TRUE)
[16:21:50.733]     }
[16:21:50.733]     ...future.frame <- base::sys.nframe()
[16:21:50.733]     ...future.conditions <- base::list()
[16:21:50.733]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.733]     if (FALSE) {
[16:21:50.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.733]     }
[16:21:50.733]     ...future.result <- base::tryCatch({
[16:21:50.733]         base::withCallingHandlers({
[16:21:50.733]             ...future.value <- base::withVisible(base::local({
[16:21:50.733]                 1
[16:21:50.733]             }))
[16:21:50.733]             future::FutureResult(value = ...future.value$value, 
[16:21:50.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.733]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.733]                     ...future.globalenv.names))
[16:21:50.733]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.733]         }, condition = base::local({
[16:21:50.733]             c <- base::c
[16:21:50.733]             inherits <- base::inherits
[16:21:50.733]             invokeRestart <- base::invokeRestart
[16:21:50.733]             length <- base::length
[16:21:50.733]             list <- base::list
[16:21:50.733]             seq.int <- base::seq.int
[16:21:50.733]             signalCondition <- base::signalCondition
[16:21:50.733]             sys.calls <- base::sys.calls
[16:21:50.733]             `[[` <- base::`[[`
[16:21:50.733]             `+` <- base::`+`
[16:21:50.733]             `<<-` <- base::`<<-`
[16:21:50.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.733]                   3L)]
[16:21:50.733]             }
[16:21:50.733]             function(cond) {
[16:21:50.733]                 is_error <- inherits(cond, "error")
[16:21:50.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.733]                   NULL)
[16:21:50.733]                 if (is_error) {
[16:21:50.733]                   sessionInformation <- function() {
[16:21:50.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.733]                       search = base::search(), system = base::Sys.info())
[16:21:50.733]                   }
[16:21:50.733]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.733]                     cond$call), session = sessionInformation(), 
[16:21:50.733]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.733]                   signalCondition(cond)
[16:21:50.733]                 }
[16:21:50.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.733]                 "immediateCondition"))) {
[16:21:50.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.733]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.733]                   if (TRUE && !signal) {
[16:21:50.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.733]                     {
[16:21:50.733]                       inherits <- base::inherits
[16:21:50.733]                       invokeRestart <- base::invokeRestart
[16:21:50.733]                       is.null <- base::is.null
[16:21:50.733]                       muffled <- FALSE
[16:21:50.733]                       if (inherits(cond, "message")) {
[16:21:50.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.733]                         if (muffled) 
[16:21:50.733]                           invokeRestart("muffleMessage")
[16:21:50.733]                       }
[16:21:50.733]                       else if (inherits(cond, "warning")) {
[16:21:50.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.733]                         if (muffled) 
[16:21:50.733]                           invokeRestart("muffleWarning")
[16:21:50.733]                       }
[16:21:50.733]                       else if (inherits(cond, "condition")) {
[16:21:50.733]                         if (!is.null(pattern)) {
[16:21:50.733]                           computeRestarts <- base::computeRestarts
[16:21:50.733]                           grepl <- base::grepl
[16:21:50.733]                           restarts <- computeRestarts(cond)
[16:21:50.733]                           for (restart in restarts) {
[16:21:50.733]                             name <- restart$name
[16:21:50.733]                             if (is.null(name)) 
[16:21:50.733]                               next
[16:21:50.733]                             if (!grepl(pattern, name)) 
[16:21:50.733]                               next
[16:21:50.733]                             invokeRestart(restart)
[16:21:50.733]                             muffled <- TRUE
[16:21:50.733]                             break
[16:21:50.733]                           }
[16:21:50.733]                         }
[16:21:50.733]                       }
[16:21:50.733]                       invisible(muffled)
[16:21:50.733]                     }
[16:21:50.733]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.733]                   }
[16:21:50.733]                 }
[16:21:50.733]                 else {
[16:21:50.733]                   if (TRUE) {
[16:21:50.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.733]                     {
[16:21:50.733]                       inherits <- base::inherits
[16:21:50.733]                       invokeRestart <- base::invokeRestart
[16:21:50.733]                       is.null <- base::is.null
[16:21:50.733]                       muffled <- FALSE
[16:21:50.733]                       if (inherits(cond, "message")) {
[16:21:50.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.733]                         if (muffled) 
[16:21:50.733]                           invokeRestart("muffleMessage")
[16:21:50.733]                       }
[16:21:50.733]                       else if (inherits(cond, "warning")) {
[16:21:50.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.733]                         if (muffled) 
[16:21:50.733]                           invokeRestart("muffleWarning")
[16:21:50.733]                       }
[16:21:50.733]                       else if (inherits(cond, "condition")) {
[16:21:50.733]                         if (!is.null(pattern)) {
[16:21:50.733]                           computeRestarts <- base::computeRestarts
[16:21:50.733]                           grepl <- base::grepl
[16:21:50.733]                           restarts <- computeRestarts(cond)
[16:21:50.733]                           for (restart in restarts) {
[16:21:50.733]                             name <- restart$name
[16:21:50.733]                             if (is.null(name)) 
[16:21:50.733]                               next
[16:21:50.733]                             if (!grepl(pattern, name)) 
[16:21:50.733]                               next
[16:21:50.733]                             invokeRestart(restart)
[16:21:50.733]                             muffled <- TRUE
[16:21:50.733]                             break
[16:21:50.733]                           }
[16:21:50.733]                         }
[16:21:50.733]                       }
[16:21:50.733]                       invisible(muffled)
[16:21:50.733]                     }
[16:21:50.733]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.733]                   }
[16:21:50.733]                 }
[16:21:50.733]             }
[16:21:50.733]         }))
[16:21:50.733]     }, error = function(ex) {
[16:21:50.733]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.733]                 ...future.rng), started = ...future.startTime, 
[16:21:50.733]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.733]             version = "1.8"), class = "FutureResult")
[16:21:50.733]     }, finally = {
[16:21:50.733]         if (!identical(...future.workdir, getwd())) 
[16:21:50.733]             setwd(...future.workdir)
[16:21:50.733]         {
[16:21:50.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.733]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.733]             }
[16:21:50.733]             base::options(...future.oldOptions)
[16:21:50.733]             if (.Platform$OS.type == "windows") {
[16:21:50.733]                 old_names <- names(...future.oldEnvVars)
[16:21:50.733]                 envs <- base::Sys.getenv()
[16:21:50.733]                 names <- names(envs)
[16:21:50.733]                 common <- intersect(names, old_names)
[16:21:50.733]                 added <- setdiff(names, old_names)
[16:21:50.733]                 removed <- setdiff(old_names, names)
[16:21:50.733]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.733]                   envs[common]]
[16:21:50.733]                 NAMES <- toupper(changed)
[16:21:50.733]                 args <- list()
[16:21:50.733]                 for (kk in seq_along(NAMES)) {
[16:21:50.733]                   name <- changed[[kk]]
[16:21:50.733]                   NAME <- NAMES[[kk]]
[16:21:50.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.733]                     next
[16:21:50.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.733]                 }
[16:21:50.733]                 NAMES <- toupper(added)
[16:21:50.733]                 for (kk in seq_along(NAMES)) {
[16:21:50.733]                   name <- added[[kk]]
[16:21:50.733]                   NAME <- NAMES[[kk]]
[16:21:50.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.733]                     next
[16:21:50.733]                   args[[name]] <- ""
[16:21:50.733]                 }
[16:21:50.733]                 NAMES <- toupper(removed)
[16:21:50.733]                 for (kk in seq_along(NAMES)) {
[16:21:50.733]                   name <- removed[[kk]]
[16:21:50.733]                   NAME <- NAMES[[kk]]
[16:21:50.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.733]                     next
[16:21:50.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.733]                 }
[16:21:50.733]                 if (length(args) > 0) 
[16:21:50.733]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.733]             }
[16:21:50.733]             else {
[16:21:50.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.733]             }
[16:21:50.733]             {
[16:21:50.733]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.733]                   0L) {
[16:21:50.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.733]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.733]                   base::options(opts)
[16:21:50.733]                 }
[16:21:50.733]                 {
[16:21:50.733]                   {
[16:21:50.733]                     NULL
[16:21:50.733]                     RNGkind("Mersenne-Twister")
[16:21:50.733]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.733]                       inherits = FALSE)
[16:21:50.733]                   }
[16:21:50.733]                   options(future.plan = NULL)
[16:21:50.733]                   if (is.na(NA_character_)) 
[16:21:50.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.733]                     .init = FALSE)
[16:21:50.733]                 }
[16:21:50.733]             }
[16:21:50.733]         }
[16:21:50.733]     })
[16:21:50.733]     if (TRUE) {
[16:21:50.733]         base::sink(type = "output", split = FALSE)
[16:21:50.733]         if (TRUE) {
[16:21:50.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.733]         }
[16:21:50.733]         else {
[16:21:50.733]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.733]         }
[16:21:50.733]         base::close(...future.stdout)
[16:21:50.733]         ...future.stdout <- NULL
[16:21:50.733]     }
[16:21:50.733]     ...future.result$conditions <- ...future.conditions
[16:21:50.733]     ...future.result$finished <- base::Sys.time()
[16:21:50.733]     ...future.result
[16:21:50.733] }
[16:21:50.735] plan(): Setting new future strategy stack:
[16:21:50.735] List of future strategies:
[16:21:50.735] 1. sequential:
[16:21:50.735]    - args: function (..., envir = parent.frame())
[16:21:50.735]    - tweaked: FALSE
[16:21:50.735]    - call: NULL
[16:21:50.736] plan(): nbrOfWorkers() = 1
[16:21:50.737] plan(): Setting new future strategy stack:
[16:21:50.737] List of future strategies:
[16:21:50.737] 1. sequential:
[16:21:50.737]    - args: function (..., envir = parent.frame())
[16:21:50.737]    - tweaked: FALSE
[16:21:50.737]    - call: plan(strategy)
[16:21:50.737] plan(): nbrOfWorkers() = 1
[16:21:50.737] SequentialFuture started (and completed)
[16:21:50.737] - Launch lazy future ... done
[16:21:50.737] run() for ‘SequentialFuture’ ... done
[16:21:50.738] getGlobalsAndPackages() ...
[16:21:50.738] Searching for globals...
[16:21:50.738] - globals found: [1] ‘{’
[16:21:50.738] Searching for globals ... DONE
[16:21:50.739] Resolving globals: FALSE
[16:21:50.739] 
[16:21:50.739] 
[16:21:50.739] getGlobalsAndPackages() ... DONE
[16:21:50.739] run() for ‘Future’ ...
[16:21:50.739] - state: ‘created’
[16:21:50.739] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.740] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.740]   - Field: ‘label’
[16:21:50.740]   - Field: ‘local’
[16:21:50.740]   - Field: ‘owner’
[16:21:50.740]   - Field: ‘envir’
[16:21:50.740]   - Field: ‘packages’
[16:21:50.740]   - Field: ‘gc’
[16:21:50.740]   - Field: ‘conditions’
[16:21:50.741]   - Field: ‘expr’
[16:21:50.741]   - Field: ‘uuid’
[16:21:50.741]   - Field: ‘seed’
[16:21:50.741]   - Field: ‘version’
[16:21:50.741]   - Field: ‘result’
[16:21:50.741]   - Field: ‘asynchronous’
[16:21:50.741]   - Field: ‘calls’
[16:21:50.741]   - Field: ‘globals’
[16:21:50.741]   - Field: ‘stdout’
[16:21:50.741]   - Field: ‘earlySignal’
[16:21:50.742]   - Field: ‘lazy’
[16:21:50.742]   - Field: ‘state’
[16:21:50.742] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.742] - Launch lazy future ...
[16:21:50.742] Packages needed by the future expression (n = 0): <none>
[16:21:50.742] Packages needed by future strategies (n = 0): <none>
[16:21:50.742] {
[16:21:50.742]     {
[16:21:50.742]         {
[16:21:50.742]             ...future.startTime <- base::Sys.time()
[16:21:50.742]             {
[16:21:50.742]                 {
[16:21:50.742]                   {
[16:21:50.742]                     base::local({
[16:21:50.742]                       has_future <- base::requireNamespace("future", 
[16:21:50.742]                         quietly = TRUE)
[16:21:50.742]                       if (has_future) {
[16:21:50.742]                         ns <- base::getNamespace("future")
[16:21:50.742]                         version <- ns[[".package"]][["version"]]
[16:21:50.742]                         if (is.null(version)) 
[16:21:50.742]                           version <- utils::packageVersion("future")
[16:21:50.742]                       }
[16:21:50.742]                       else {
[16:21:50.742]                         version <- NULL
[16:21:50.742]                       }
[16:21:50.742]                       if (!has_future || version < "1.8.0") {
[16:21:50.742]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.742]                           "", base::R.version$version.string), 
[16:21:50.742]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.742]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.742]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.742]                             "release", "version")], collapse = " "), 
[16:21:50.742]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.742]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.742]                           info)
[16:21:50.742]                         info <- base::paste(info, collapse = "; ")
[16:21:50.742]                         if (!has_future) {
[16:21:50.742]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.742]                             info)
[16:21:50.742]                         }
[16:21:50.742]                         else {
[16:21:50.742]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.742]                             info, version)
[16:21:50.742]                         }
[16:21:50.742]                         base::stop(msg)
[16:21:50.742]                       }
[16:21:50.742]                     })
[16:21:50.742]                   }
[16:21:50.742]                   ...future.strategy.old <- future::plan("list")
[16:21:50.742]                   options(future.plan = NULL)
[16:21:50.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.742]                 }
[16:21:50.742]                 ...future.workdir <- getwd()
[16:21:50.742]             }
[16:21:50.742]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.742]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.742]         }
[16:21:50.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.742]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.742]             base::names(...future.oldOptions))
[16:21:50.742]     }
[16:21:50.742]     if (FALSE) {
[16:21:50.742]     }
[16:21:50.742]     else {
[16:21:50.742]         if (TRUE) {
[16:21:50.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.742]                 open = "w")
[16:21:50.742]         }
[16:21:50.742]         else {
[16:21:50.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.742]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.742]         }
[16:21:50.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.742]             base::sink(type = "output", split = FALSE)
[16:21:50.742]             base::close(...future.stdout)
[16:21:50.742]         }, add = TRUE)
[16:21:50.742]     }
[16:21:50.742]     ...future.frame <- base::sys.nframe()
[16:21:50.742]     ...future.conditions <- base::list()
[16:21:50.742]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.742]     if (FALSE) {
[16:21:50.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.742]     }
[16:21:50.742]     ...future.result <- base::tryCatch({
[16:21:50.742]         base::withCallingHandlers({
[16:21:50.742]             ...future.value <- base::withVisible(base::local({
[16:21:50.742]                 2
[16:21:50.742]             }))
[16:21:50.742]             future::FutureResult(value = ...future.value$value, 
[16:21:50.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.742]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.742]                     ...future.globalenv.names))
[16:21:50.742]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.742]         }, condition = base::local({
[16:21:50.742]             c <- base::c
[16:21:50.742]             inherits <- base::inherits
[16:21:50.742]             invokeRestart <- base::invokeRestart
[16:21:50.742]             length <- base::length
[16:21:50.742]             list <- base::list
[16:21:50.742]             seq.int <- base::seq.int
[16:21:50.742]             signalCondition <- base::signalCondition
[16:21:50.742]             sys.calls <- base::sys.calls
[16:21:50.742]             `[[` <- base::`[[`
[16:21:50.742]             `+` <- base::`+`
[16:21:50.742]             `<<-` <- base::`<<-`
[16:21:50.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.742]                   3L)]
[16:21:50.742]             }
[16:21:50.742]             function(cond) {
[16:21:50.742]                 is_error <- inherits(cond, "error")
[16:21:50.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.742]                   NULL)
[16:21:50.742]                 if (is_error) {
[16:21:50.742]                   sessionInformation <- function() {
[16:21:50.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.742]                       search = base::search(), system = base::Sys.info())
[16:21:50.742]                   }
[16:21:50.742]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.742]                     cond$call), session = sessionInformation(), 
[16:21:50.742]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.742]                   signalCondition(cond)
[16:21:50.742]                 }
[16:21:50.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.742]                 "immediateCondition"))) {
[16:21:50.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.742]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.742]                   if (TRUE && !signal) {
[16:21:50.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.742]                     {
[16:21:50.742]                       inherits <- base::inherits
[16:21:50.742]                       invokeRestart <- base::invokeRestart
[16:21:50.742]                       is.null <- base::is.null
[16:21:50.742]                       muffled <- FALSE
[16:21:50.742]                       if (inherits(cond, "message")) {
[16:21:50.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.742]                         if (muffled) 
[16:21:50.742]                           invokeRestart("muffleMessage")
[16:21:50.742]                       }
[16:21:50.742]                       else if (inherits(cond, "warning")) {
[16:21:50.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.742]                         if (muffled) 
[16:21:50.742]                           invokeRestart("muffleWarning")
[16:21:50.742]                       }
[16:21:50.742]                       else if (inherits(cond, "condition")) {
[16:21:50.742]                         if (!is.null(pattern)) {
[16:21:50.742]                           computeRestarts <- base::computeRestarts
[16:21:50.742]                           grepl <- base::grepl
[16:21:50.742]                           restarts <- computeRestarts(cond)
[16:21:50.742]                           for (restart in restarts) {
[16:21:50.742]                             name <- restart$name
[16:21:50.742]                             if (is.null(name)) 
[16:21:50.742]                               next
[16:21:50.742]                             if (!grepl(pattern, name)) 
[16:21:50.742]                               next
[16:21:50.742]                             invokeRestart(restart)
[16:21:50.742]                             muffled <- TRUE
[16:21:50.742]                             break
[16:21:50.742]                           }
[16:21:50.742]                         }
[16:21:50.742]                       }
[16:21:50.742]                       invisible(muffled)
[16:21:50.742]                     }
[16:21:50.742]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.742]                   }
[16:21:50.742]                 }
[16:21:50.742]                 else {
[16:21:50.742]                   if (TRUE) {
[16:21:50.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.742]                     {
[16:21:50.742]                       inherits <- base::inherits
[16:21:50.742]                       invokeRestart <- base::invokeRestart
[16:21:50.742]                       is.null <- base::is.null
[16:21:50.742]                       muffled <- FALSE
[16:21:50.742]                       if (inherits(cond, "message")) {
[16:21:50.742]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.742]                         if (muffled) 
[16:21:50.742]                           invokeRestart("muffleMessage")
[16:21:50.742]                       }
[16:21:50.742]                       else if (inherits(cond, "warning")) {
[16:21:50.742]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.742]                         if (muffled) 
[16:21:50.742]                           invokeRestart("muffleWarning")
[16:21:50.742]                       }
[16:21:50.742]                       else if (inherits(cond, "condition")) {
[16:21:50.742]                         if (!is.null(pattern)) {
[16:21:50.742]                           computeRestarts <- base::computeRestarts
[16:21:50.742]                           grepl <- base::grepl
[16:21:50.742]                           restarts <- computeRestarts(cond)
[16:21:50.742]                           for (restart in restarts) {
[16:21:50.742]                             name <- restart$name
[16:21:50.742]                             if (is.null(name)) 
[16:21:50.742]                               next
[16:21:50.742]                             if (!grepl(pattern, name)) 
[16:21:50.742]                               next
[16:21:50.742]                             invokeRestart(restart)
[16:21:50.742]                             muffled <- TRUE
[16:21:50.742]                             break
[16:21:50.742]                           }
[16:21:50.742]                         }
[16:21:50.742]                       }
[16:21:50.742]                       invisible(muffled)
[16:21:50.742]                     }
[16:21:50.742]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.742]                   }
[16:21:50.742]                 }
[16:21:50.742]             }
[16:21:50.742]         }))
[16:21:50.742]     }, error = function(ex) {
[16:21:50.742]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.742]                 ...future.rng), started = ...future.startTime, 
[16:21:50.742]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.742]             version = "1.8"), class = "FutureResult")
[16:21:50.742]     }, finally = {
[16:21:50.742]         if (!identical(...future.workdir, getwd())) 
[16:21:50.742]             setwd(...future.workdir)
[16:21:50.742]         {
[16:21:50.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.742]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.742]             }
[16:21:50.742]             base::options(...future.oldOptions)
[16:21:50.742]             if (.Platform$OS.type == "windows") {
[16:21:50.742]                 old_names <- names(...future.oldEnvVars)
[16:21:50.742]                 envs <- base::Sys.getenv()
[16:21:50.742]                 names <- names(envs)
[16:21:50.742]                 common <- intersect(names, old_names)
[16:21:50.742]                 added <- setdiff(names, old_names)
[16:21:50.742]                 removed <- setdiff(old_names, names)
[16:21:50.742]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.742]                   envs[common]]
[16:21:50.742]                 NAMES <- toupper(changed)
[16:21:50.742]                 args <- list()
[16:21:50.742]                 for (kk in seq_along(NAMES)) {
[16:21:50.742]                   name <- changed[[kk]]
[16:21:50.742]                   NAME <- NAMES[[kk]]
[16:21:50.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.742]                     next
[16:21:50.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.742]                 }
[16:21:50.742]                 NAMES <- toupper(added)
[16:21:50.742]                 for (kk in seq_along(NAMES)) {
[16:21:50.742]                   name <- added[[kk]]
[16:21:50.742]                   NAME <- NAMES[[kk]]
[16:21:50.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.742]                     next
[16:21:50.742]                   args[[name]] <- ""
[16:21:50.742]                 }
[16:21:50.742]                 NAMES <- toupper(removed)
[16:21:50.742]                 for (kk in seq_along(NAMES)) {
[16:21:50.742]                   name <- removed[[kk]]
[16:21:50.742]                   NAME <- NAMES[[kk]]
[16:21:50.742]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.742]                     next
[16:21:50.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.742]                 }
[16:21:50.742]                 if (length(args) > 0) 
[16:21:50.742]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.742]             }
[16:21:50.742]             else {
[16:21:50.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.742]             }
[16:21:50.742]             {
[16:21:50.742]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.742]                   0L) {
[16:21:50.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.742]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.742]                   base::options(opts)
[16:21:50.742]                 }
[16:21:50.742]                 {
[16:21:50.742]                   {
[16:21:50.742]                     NULL
[16:21:50.742]                     RNGkind("Mersenne-Twister")
[16:21:50.742]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.742]                       inherits = FALSE)
[16:21:50.742]                   }
[16:21:50.742]                   options(future.plan = NULL)
[16:21:50.742]                   if (is.na(NA_character_)) 
[16:21:50.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.742]                     .init = FALSE)
[16:21:50.742]                 }
[16:21:50.742]             }
[16:21:50.742]         }
[16:21:50.742]     })
[16:21:50.742]     if (TRUE) {
[16:21:50.742]         base::sink(type = "output", split = FALSE)
[16:21:50.742]         if (TRUE) {
[16:21:50.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.742]         }
[16:21:50.742]         else {
[16:21:50.742]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.742]         }
[16:21:50.742]         base::close(...future.stdout)
[16:21:50.742]         ...future.stdout <- NULL
[16:21:50.742]     }
[16:21:50.742]     ...future.result$conditions <- ...future.conditions
[16:21:50.742]     ...future.result$finished <- base::Sys.time()
[16:21:50.742]     ...future.result
[16:21:50.742] }
[16:21:50.744] plan(): Setting new future strategy stack:
[16:21:50.744] List of future strategies:
[16:21:50.744] 1. sequential:
[16:21:50.744]    - args: function (..., envir = parent.frame())
[16:21:50.744]    - tweaked: FALSE
[16:21:50.744]    - call: NULL
[16:21:50.745] plan(): nbrOfWorkers() = 1
[16:21:50.745] plan(): Setting new future strategy stack:
[16:21:50.745] List of future strategies:
[16:21:50.745] 1. sequential:
[16:21:50.745]    - args: function (..., envir = parent.frame())
[16:21:50.745]    - tweaked: FALSE
[16:21:50.745]    - call: plan(strategy)
[16:21:50.746] plan(): nbrOfWorkers() = 1
[16:21:50.746] SequentialFuture started (and completed)
[16:21:50.746] - Launch lazy future ... done
[16:21:50.746] run() for ‘SequentialFuture’ ... done
[16:21:50.747] resolve() on environment ...
[16:21:50.747]  recursive: 0
[16:21:50.747]  elements: [3] ‘a’
[16:21:50.748] resolved() for ‘SequentialFuture’ ...
[16:21:50.748] - state: ‘finished’
[16:21:50.748] - run: TRUE
[16:21:50.748] - result: ‘FutureResult’
[16:21:50.748] resolved() for ‘SequentialFuture’ ... done
[16:21:50.748] Future #1
[16:21:50.748]  length: 2 (resolved future 1)
[16:21:50.748] resolved() for ‘SequentialFuture’ ...
[16:21:50.748] - state: ‘finished’
[16:21:50.748] - run: TRUE
[16:21:50.749] - result: ‘FutureResult’
[16:21:50.749] resolved() for ‘SequentialFuture’ ... done
[16:21:50.749] Future #2
[16:21:50.749]  length: 1 (resolved future 2)
[16:21:50.749]  length: 0 (resolved future 3)
[16:21:50.749] resolve() on environment ... DONE
[16:21:50.749] resolved() for ‘SequentialFuture’ ...
[16:21:50.749] - state: ‘finished’
[16:21:50.749] - run: TRUE
[16:21:50.749] - result: ‘FutureResult’
[16:21:50.750] resolved() for ‘SequentialFuture’ ... done
[16:21:50.750] resolve() on environment ...
[16:21:50.750]  recursive: 0
[16:21:50.751]  elements: [3] ‘b’
[16:21:50.751] resolved() for ‘SequentialFuture’ ...
[16:21:50.751] - state: ‘finished’
[16:21:50.751] - run: TRUE
[16:21:50.751] - result: ‘FutureResult’
[16:21:50.751] resolved() for ‘SequentialFuture’ ... done
[16:21:50.751] Future #1
[16:21:50.751]  length: 2 (resolved future 1)
[16:21:50.751] resolved() for ‘SequentialFuture’ ...
[16:21:50.751] - state: ‘finished’
[16:21:50.752] - run: TRUE
[16:21:50.752] - result: ‘FutureResult’
[16:21:50.752] resolved() for ‘SequentialFuture’ ... done
[16:21:50.752] Future #2
[16:21:50.752]  length: 1 (resolved future 2)
[16:21:50.752]  length: 0 (resolved future 3)
[16:21:50.752] resolve() on environment ... DONE
[16:21:50.753] resolve() on environment ...
[16:21:50.753]  recursive: 0
[16:21:50.753]  elements: [3] ‘c’
[16:21:50.753] resolved() for ‘SequentialFuture’ ...
[16:21:50.753] - state: ‘finished’
[16:21:50.753] - run: TRUE
[16:21:50.754] - result: ‘FutureResult’
[16:21:50.754] resolved() for ‘SequentialFuture’ ... done
[16:21:50.754] Future #1
[16:21:50.754]  length: 2 (resolved future 1)
[16:21:50.754] resolved() for ‘SequentialFuture’ ...
[16:21:50.754] - state: ‘finished’
[16:21:50.754] - run: TRUE
[16:21:50.754] - result: ‘FutureResult’
[16:21:50.754] resolved() for ‘SequentialFuture’ ... done
[16:21:50.754] Future #2
[16:21:50.754]  length: 1 (resolved future 2)
[16:21:50.755]  length: 0 (resolved future 3)
[16:21:50.755] resolve() on environment ... DONE
[16:21:50.755] resolve() on environment ...
[16:21:50.755]  recursive: 0
[16:21:50.756]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:21:50.756] resolved() for ‘SequentialFuture’ ...
[16:21:50.756] - state: ‘finished’
[16:21:50.756] - run: TRUE
[16:21:50.756] - result: ‘FutureResult’
[16:21:50.756] resolved() for ‘SequentialFuture’ ... done
[16:21:50.756] Future #1
[16:21:50.757]  length: 2 (resolved future 1)
[16:21:50.757] resolved() for ‘SequentialFuture’ ...
[16:21:50.757] - state: ‘finished’
[16:21:50.757] - run: TRUE
[16:21:50.757] - result: ‘FutureResult’
[16:21:50.757] resolved() for ‘SequentialFuture’ ... done
[16:21:50.757] Future #2
[16:21:50.758]  length: 1 (resolved future 2)
[16:21:50.758]  length: 0 (resolved future 3)
[16:21:50.758] resolve() on environment ... DONE
[16:21:50.758] resolve() on environment ...
[16:21:50.758]  recursive: 99
[16:21:50.759]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:21:50.759] resolved() for ‘SequentialFuture’ ...
[16:21:50.759] - state: ‘finished’
[16:21:50.759] - run: TRUE
[16:21:50.761] - result: ‘FutureResult’
[16:21:50.761] resolved() for ‘SequentialFuture’ ... done
[16:21:50.761] Future #1
[16:21:50.761] resolved() for ‘SequentialFuture’ ...
[16:21:50.762] - state: ‘finished’
[16:21:50.762] - run: TRUE
[16:21:50.762] - result: ‘FutureResult’
[16:21:50.762] resolved() for ‘SequentialFuture’ ... done
[16:21:50.762] A SequentialFuture was resolved
[16:21:50.762]  length: 2 (resolved future 1)
[16:21:50.762] resolved() for ‘SequentialFuture’ ...
[16:21:50.762] - state: ‘finished’
[16:21:50.762] - run: TRUE
[16:21:50.762] - result: ‘FutureResult’
[16:21:50.763] resolved() for ‘SequentialFuture’ ... done
[16:21:50.763] Future #2
[16:21:50.763] resolved() for ‘SequentialFuture’ ...
[16:21:50.763] - state: ‘finished’
[16:21:50.763] - run: TRUE
[16:21:50.763] - result: ‘FutureResult’
[16:21:50.763] resolved() for ‘SequentialFuture’ ... done
[16:21:50.763] A SequentialFuture was resolved
[16:21:50.763]  length: 1 (resolved future 2)
[16:21:50.763]  length: 0 (resolved future 3)
[16:21:50.764] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:21:50.765] resolve() on list environment ...
[16:21:50.765]  recursive: 0
[16:21:50.766]  length: 2
[16:21:50.766]  elements: ‘a’, ‘b’
[16:21:50.766]  length: 1 (resolved future 1)
[16:21:50.766]  length: 0 (resolved future 2)
[16:21:50.766] resolve() on list environment ... DONE
[16:21:50.766] getGlobalsAndPackages() ...
[16:21:50.766] Searching for globals...
[16:21:50.767] 
[16:21:50.767] Searching for globals ... DONE
[16:21:50.767] - globals: [0] <none>
[16:21:50.767] getGlobalsAndPackages() ... DONE
[16:21:50.767] run() for ‘Future’ ...
[16:21:50.767] - state: ‘created’
[16:21:50.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.768] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.768]   - Field: ‘label’
[16:21:50.768]   - Field: ‘local’
[16:21:50.768]   - Field: ‘owner’
[16:21:50.768]   - Field: ‘envir’
[16:21:50.768]   - Field: ‘packages’
[16:21:50.768]   - Field: ‘gc’
[16:21:50.769]   - Field: ‘conditions’
[16:21:50.769]   - Field: ‘expr’
[16:21:50.769]   - Field: ‘uuid’
[16:21:50.769]   - Field: ‘seed’
[16:21:50.769]   - Field: ‘version’
[16:21:50.769]   - Field: ‘result’
[16:21:50.769]   - Field: ‘asynchronous’
[16:21:50.769]   - Field: ‘calls’
[16:21:50.769]   - Field: ‘globals’
[16:21:50.769]   - Field: ‘stdout’
[16:21:50.770]   - Field: ‘earlySignal’
[16:21:50.770]   - Field: ‘lazy’
[16:21:50.770]   - Field: ‘state’
[16:21:50.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.770] - Launch lazy future ...
[16:21:50.770] Packages needed by the future expression (n = 0): <none>
[16:21:50.770] Packages needed by future strategies (n = 0): <none>
[16:21:50.771] {
[16:21:50.771]     {
[16:21:50.771]         {
[16:21:50.771]             ...future.startTime <- base::Sys.time()
[16:21:50.771]             {
[16:21:50.771]                 {
[16:21:50.771]                   {
[16:21:50.771]                     base::local({
[16:21:50.771]                       has_future <- base::requireNamespace("future", 
[16:21:50.771]                         quietly = TRUE)
[16:21:50.771]                       if (has_future) {
[16:21:50.771]                         ns <- base::getNamespace("future")
[16:21:50.771]                         version <- ns[[".package"]][["version"]]
[16:21:50.771]                         if (is.null(version)) 
[16:21:50.771]                           version <- utils::packageVersion("future")
[16:21:50.771]                       }
[16:21:50.771]                       else {
[16:21:50.771]                         version <- NULL
[16:21:50.771]                       }
[16:21:50.771]                       if (!has_future || version < "1.8.0") {
[16:21:50.771]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.771]                           "", base::R.version$version.string), 
[16:21:50.771]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.771]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.771]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.771]                             "release", "version")], collapse = " "), 
[16:21:50.771]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.771]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.771]                           info)
[16:21:50.771]                         info <- base::paste(info, collapse = "; ")
[16:21:50.771]                         if (!has_future) {
[16:21:50.771]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.771]                             info)
[16:21:50.771]                         }
[16:21:50.771]                         else {
[16:21:50.771]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.771]                             info, version)
[16:21:50.771]                         }
[16:21:50.771]                         base::stop(msg)
[16:21:50.771]                       }
[16:21:50.771]                     })
[16:21:50.771]                   }
[16:21:50.771]                   ...future.strategy.old <- future::plan("list")
[16:21:50.771]                   options(future.plan = NULL)
[16:21:50.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.771]                 }
[16:21:50.771]                 ...future.workdir <- getwd()
[16:21:50.771]             }
[16:21:50.771]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.771]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.771]         }
[16:21:50.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.771]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.771]             base::names(...future.oldOptions))
[16:21:50.771]     }
[16:21:50.771]     if (FALSE) {
[16:21:50.771]     }
[16:21:50.771]     else {
[16:21:50.771]         if (TRUE) {
[16:21:50.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.771]                 open = "w")
[16:21:50.771]         }
[16:21:50.771]         else {
[16:21:50.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.771]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.771]         }
[16:21:50.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.771]             base::sink(type = "output", split = FALSE)
[16:21:50.771]             base::close(...future.stdout)
[16:21:50.771]         }, add = TRUE)
[16:21:50.771]     }
[16:21:50.771]     ...future.frame <- base::sys.nframe()
[16:21:50.771]     ...future.conditions <- base::list()
[16:21:50.771]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.771]     if (FALSE) {
[16:21:50.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.771]     }
[16:21:50.771]     ...future.result <- base::tryCatch({
[16:21:50.771]         base::withCallingHandlers({
[16:21:50.771]             ...future.value <- base::withVisible(base::local(1))
[16:21:50.771]             future::FutureResult(value = ...future.value$value, 
[16:21:50.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.771]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.771]                     ...future.globalenv.names))
[16:21:50.771]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.771]         }, condition = base::local({
[16:21:50.771]             c <- base::c
[16:21:50.771]             inherits <- base::inherits
[16:21:50.771]             invokeRestart <- base::invokeRestart
[16:21:50.771]             length <- base::length
[16:21:50.771]             list <- base::list
[16:21:50.771]             seq.int <- base::seq.int
[16:21:50.771]             signalCondition <- base::signalCondition
[16:21:50.771]             sys.calls <- base::sys.calls
[16:21:50.771]             `[[` <- base::`[[`
[16:21:50.771]             `+` <- base::`+`
[16:21:50.771]             `<<-` <- base::`<<-`
[16:21:50.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.771]                   3L)]
[16:21:50.771]             }
[16:21:50.771]             function(cond) {
[16:21:50.771]                 is_error <- inherits(cond, "error")
[16:21:50.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.771]                   NULL)
[16:21:50.771]                 if (is_error) {
[16:21:50.771]                   sessionInformation <- function() {
[16:21:50.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.771]                       search = base::search(), system = base::Sys.info())
[16:21:50.771]                   }
[16:21:50.771]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.771]                     cond$call), session = sessionInformation(), 
[16:21:50.771]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.771]                   signalCondition(cond)
[16:21:50.771]                 }
[16:21:50.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.771]                 "immediateCondition"))) {
[16:21:50.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.771]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.771]                   if (TRUE && !signal) {
[16:21:50.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.771]                     {
[16:21:50.771]                       inherits <- base::inherits
[16:21:50.771]                       invokeRestart <- base::invokeRestart
[16:21:50.771]                       is.null <- base::is.null
[16:21:50.771]                       muffled <- FALSE
[16:21:50.771]                       if (inherits(cond, "message")) {
[16:21:50.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.771]                         if (muffled) 
[16:21:50.771]                           invokeRestart("muffleMessage")
[16:21:50.771]                       }
[16:21:50.771]                       else if (inherits(cond, "warning")) {
[16:21:50.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.771]                         if (muffled) 
[16:21:50.771]                           invokeRestart("muffleWarning")
[16:21:50.771]                       }
[16:21:50.771]                       else if (inherits(cond, "condition")) {
[16:21:50.771]                         if (!is.null(pattern)) {
[16:21:50.771]                           computeRestarts <- base::computeRestarts
[16:21:50.771]                           grepl <- base::grepl
[16:21:50.771]                           restarts <- computeRestarts(cond)
[16:21:50.771]                           for (restart in restarts) {
[16:21:50.771]                             name <- restart$name
[16:21:50.771]                             if (is.null(name)) 
[16:21:50.771]                               next
[16:21:50.771]                             if (!grepl(pattern, name)) 
[16:21:50.771]                               next
[16:21:50.771]                             invokeRestart(restart)
[16:21:50.771]                             muffled <- TRUE
[16:21:50.771]                             break
[16:21:50.771]                           }
[16:21:50.771]                         }
[16:21:50.771]                       }
[16:21:50.771]                       invisible(muffled)
[16:21:50.771]                     }
[16:21:50.771]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.771]                   }
[16:21:50.771]                 }
[16:21:50.771]                 else {
[16:21:50.771]                   if (TRUE) {
[16:21:50.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.771]                     {
[16:21:50.771]                       inherits <- base::inherits
[16:21:50.771]                       invokeRestart <- base::invokeRestart
[16:21:50.771]                       is.null <- base::is.null
[16:21:50.771]                       muffled <- FALSE
[16:21:50.771]                       if (inherits(cond, "message")) {
[16:21:50.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.771]                         if (muffled) 
[16:21:50.771]                           invokeRestart("muffleMessage")
[16:21:50.771]                       }
[16:21:50.771]                       else if (inherits(cond, "warning")) {
[16:21:50.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.771]                         if (muffled) 
[16:21:50.771]                           invokeRestart("muffleWarning")
[16:21:50.771]                       }
[16:21:50.771]                       else if (inherits(cond, "condition")) {
[16:21:50.771]                         if (!is.null(pattern)) {
[16:21:50.771]                           computeRestarts <- base::computeRestarts
[16:21:50.771]                           grepl <- base::grepl
[16:21:50.771]                           restarts <- computeRestarts(cond)
[16:21:50.771]                           for (restart in restarts) {
[16:21:50.771]                             name <- restart$name
[16:21:50.771]                             if (is.null(name)) 
[16:21:50.771]                               next
[16:21:50.771]                             if (!grepl(pattern, name)) 
[16:21:50.771]                               next
[16:21:50.771]                             invokeRestart(restart)
[16:21:50.771]                             muffled <- TRUE
[16:21:50.771]                             break
[16:21:50.771]                           }
[16:21:50.771]                         }
[16:21:50.771]                       }
[16:21:50.771]                       invisible(muffled)
[16:21:50.771]                     }
[16:21:50.771]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.771]                   }
[16:21:50.771]                 }
[16:21:50.771]             }
[16:21:50.771]         }))
[16:21:50.771]     }, error = function(ex) {
[16:21:50.771]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.771]                 ...future.rng), started = ...future.startTime, 
[16:21:50.771]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.771]             version = "1.8"), class = "FutureResult")
[16:21:50.771]     }, finally = {
[16:21:50.771]         if (!identical(...future.workdir, getwd())) 
[16:21:50.771]             setwd(...future.workdir)
[16:21:50.771]         {
[16:21:50.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.771]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.771]             }
[16:21:50.771]             base::options(...future.oldOptions)
[16:21:50.771]             if (.Platform$OS.type == "windows") {
[16:21:50.771]                 old_names <- names(...future.oldEnvVars)
[16:21:50.771]                 envs <- base::Sys.getenv()
[16:21:50.771]                 names <- names(envs)
[16:21:50.771]                 common <- intersect(names, old_names)
[16:21:50.771]                 added <- setdiff(names, old_names)
[16:21:50.771]                 removed <- setdiff(old_names, names)
[16:21:50.771]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.771]                   envs[common]]
[16:21:50.771]                 NAMES <- toupper(changed)
[16:21:50.771]                 args <- list()
[16:21:50.771]                 for (kk in seq_along(NAMES)) {
[16:21:50.771]                   name <- changed[[kk]]
[16:21:50.771]                   NAME <- NAMES[[kk]]
[16:21:50.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.771]                     next
[16:21:50.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.771]                 }
[16:21:50.771]                 NAMES <- toupper(added)
[16:21:50.771]                 for (kk in seq_along(NAMES)) {
[16:21:50.771]                   name <- added[[kk]]
[16:21:50.771]                   NAME <- NAMES[[kk]]
[16:21:50.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.771]                     next
[16:21:50.771]                   args[[name]] <- ""
[16:21:50.771]                 }
[16:21:50.771]                 NAMES <- toupper(removed)
[16:21:50.771]                 for (kk in seq_along(NAMES)) {
[16:21:50.771]                   name <- removed[[kk]]
[16:21:50.771]                   NAME <- NAMES[[kk]]
[16:21:50.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.771]                     next
[16:21:50.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.771]                 }
[16:21:50.771]                 if (length(args) > 0) 
[16:21:50.771]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.771]             }
[16:21:50.771]             else {
[16:21:50.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.771]             }
[16:21:50.771]             {
[16:21:50.771]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.771]                   0L) {
[16:21:50.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.771]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.771]                   base::options(opts)
[16:21:50.771]                 }
[16:21:50.771]                 {
[16:21:50.771]                   {
[16:21:50.771]                     NULL
[16:21:50.771]                     RNGkind("Mersenne-Twister")
[16:21:50.771]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.771]                       inherits = FALSE)
[16:21:50.771]                   }
[16:21:50.771]                   options(future.plan = NULL)
[16:21:50.771]                   if (is.na(NA_character_)) 
[16:21:50.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.771]                     .init = FALSE)
[16:21:50.771]                 }
[16:21:50.771]             }
[16:21:50.771]         }
[16:21:50.771]     })
[16:21:50.771]     if (TRUE) {
[16:21:50.771]         base::sink(type = "output", split = FALSE)
[16:21:50.771]         if (TRUE) {
[16:21:50.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.771]         }
[16:21:50.771]         else {
[16:21:50.771]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.771]         }
[16:21:50.771]         base::close(...future.stdout)
[16:21:50.771]         ...future.stdout <- NULL
[16:21:50.771]     }
[16:21:50.771]     ...future.result$conditions <- ...future.conditions
[16:21:50.771]     ...future.result$finished <- base::Sys.time()
[16:21:50.771]     ...future.result
[16:21:50.771] }
[16:21:50.772] plan(): Setting new future strategy stack:
[16:21:50.772] List of future strategies:
[16:21:50.772] 1. sequential:
[16:21:50.772]    - args: function (..., envir = parent.frame())
[16:21:50.772]    - tweaked: FALSE
[16:21:50.772]    - call: NULL
[16:21:50.773] plan(): nbrOfWorkers() = 1
[16:21:50.774] plan(): Setting new future strategy stack:
[16:21:50.774] List of future strategies:
[16:21:50.774] 1. sequential:
[16:21:50.774]    - args: function (..., envir = parent.frame())
[16:21:50.774]    - tweaked: FALSE
[16:21:50.774]    - call: plan(strategy)
[16:21:50.774] plan(): nbrOfWorkers() = 1
[16:21:50.774] SequentialFuture started (and completed)
[16:21:50.774] - Launch lazy future ... done
[16:21:50.774] run() for ‘SequentialFuture’ ... done
[16:21:50.775] getGlobalsAndPackages() ...
[16:21:50.775] Searching for globals...
[16:21:50.775] 
[16:21:50.775] Searching for globals ... DONE
[16:21:50.775] - globals: [0] <none>
[16:21:50.775] getGlobalsAndPackages() ... DONE
[16:21:50.775] run() for ‘Future’ ...
[16:21:50.776] - state: ‘created’
[16:21:50.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.776]   - Field: ‘label’
[16:21:50.776]   - Field: ‘local’
[16:21:50.776]   - Field: ‘owner’
[16:21:50.777]   - Field: ‘envir’
[16:21:50.777]   - Field: ‘packages’
[16:21:50.777]   - Field: ‘gc’
[16:21:50.777]   - Field: ‘conditions’
[16:21:50.777]   - Field: ‘expr’
[16:21:50.777]   - Field: ‘uuid’
[16:21:50.777]   - Field: ‘seed’
[16:21:50.777]   - Field: ‘version’
[16:21:50.777]   - Field: ‘result’
[16:21:50.777]   - Field: ‘asynchronous’
[16:21:50.777]   - Field: ‘calls’
[16:21:50.778]   - Field: ‘globals’
[16:21:50.778]   - Field: ‘stdout’
[16:21:50.778]   - Field: ‘earlySignal’
[16:21:50.778]   - Field: ‘lazy’
[16:21:50.778]   - Field: ‘state’
[16:21:50.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.778] - Launch lazy future ...
[16:21:50.778] Packages needed by the future expression (n = 0): <none>
[16:21:50.778] Packages needed by future strategies (n = 0): <none>
[16:21:50.779] {
[16:21:50.779]     {
[16:21:50.779]         {
[16:21:50.779]             ...future.startTime <- base::Sys.time()
[16:21:50.779]             {
[16:21:50.779]                 {
[16:21:50.779]                   {
[16:21:50.779]                     base::local({
[16:21:50.779]                       has_future <- base::requireNamespace("future", 
[16:21:50.779]                         quietly = TRUE)
[16:21:50.779]                       if (has_future) {
[16:21:50.779]                         ns <- base::getNamespace("future")
[16:21:50.779]                         version <- ns[[".package"]][["version"]]
[16:21:50.779]                         if (is.null(version)) 
[16:21:50.779]                           version <- utils::packageVersion("future")
[16:21:50.779]                       }
[16:21:50.779]                       else {
[16:21:50.779]                         version <- NULL
[16:21:50.779]                       }
[16:21:50.779]                       if (!has_future || version < "1.8.0") {
[16:21:50.779]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.779]                           "", base::R.version$version.string), 
[16:21:50.779]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.779]                             "release", "version")], collapse = " "), 
[16:21:50.779]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.779]                           info)
[16:21:50.779]                         info <- base::paste(info, collapse = "; ")
[16:21:50.779]                         if (!has_future) {
[16:21:50.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.779]                             info)
[16:21:50.779]                         }
[16:21:50.779]                         else {
[16:21:50.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.779]                             info, version)
[16:21:50.779]                         }
[16:21:50.779]                         base::stop(msg)
[16:21:50.779]                       }
[16:21:50.779]                     })
[16:21:50.779]                   }
[16:21:50.779]                   ...future.strategy.old <- future::plan("list")
[16:21:50.779]                   options(future.plan = NULL)
[16:21:50.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.779]                 }
[16:21:50.779]                 ...future.workdir <- getwd()
[16:21:50.779]             }
[16:21:50.779]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.779]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.779]         }
[16:21:50.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.779]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.779]             base::names(...future.oldOptions))
[16:21:50.779]     }
[16:21:50.779]     if (FALSE) {
[16:21:50.779]     }
[16:21:50.779]     else {
[16:21:50.779]         if (TRUE) {
[16:21:50.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.779]                 open = "w")
[16:21:50.779]         }
[16:21:50.779]         else {
[16:21:50.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.779]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.779]         }
[16:21:50.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.779]             base::sink(type = "output", split = FALSE)
[16:21:50.779]             base::close(...future.stdout)
[16:21:50.779]         }, add = TRUE)
[16:21:50.779]     }
[16:21:50.779]     ...future.frame <- base::sys.nframe()
[16:21:50.779]     ...future.conditions <- base::list()
[16:21:50.779]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.779]     if (FALSE) {
[16:21:50.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.779]     }
[16:21:50.779]     ...future.result <- base::tryCatch({
[16:21:50.779]         base::withCallingHandlers({
[16:21:50.779]             ...future.value <- base::withVisible(base::local(2))
[16:21:50.779]             future::FutureResult(value = ...future.value$value, 
[16:21:50.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.779]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.779]                     ...future.globalenv.names))
[16:21:50.779]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.779]         }, condition = base::local({
[16:21:50.779]             c <- base::c
[16:21:50.779]             inherits <- base::inherits
[16:21:50.779]             invokeRestart <- base::invokeRestart
[16:21:50.779]             length <- base::length
[16:21:50.779]             list <- base::list
[16:21:50.779]             seq.int <- base::seq.int
[16:21:50.779]             signalCondition <- base::signalCondition
[16:21:50.779]             sys.calls <- base::sys.calls
[16:21:50.779]             `[[` <- base::`[[`
[16:21:50.779]             `+` <- base::`+`
[16:21:50.779]             `<<-` <- base::`<<-`
[16:21:50.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.779]                   3L)]
[16:21:50.779]             }
[16:21:50.779]             function(cond) {
[16:21:50.779]                 is_error <- inherits(cond, "error")
[16:21:50.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.779]                   NULL)
[16:21:50.779]                 if (is_error) {
[16:21:50.779]                   sessionInformation <- function() {
[16:21:50.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.779]                       search = base::search(), system = base::Sys.info())
[16:21:50.779]                   }
[16:21:50.779]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.779]                     cond$call), session = sessionInformation(), 
[16:21:50.779]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.779]                   signalCondition(cond)
[16:21:50.779]                 }
[16:21:50.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.779]                 "immediateCondition"))) {
[16:21:50.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.779]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.779]                   if (TRUE && !signal) {
[16:21:50.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.779]                     {
[16:21:50.779]                       inherits <- base::inherits
[16:21:50.779]                       invokeRestart <- base::invokeRestart
[16:21:50.779]                       is.null <- base::is.null
[16:21:50.779]                       muffled <- FALSE
[16:21:50.779]                       if (inherits(cond, "message")) {
[16:21:50.779]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.779]                         if (muffled) 
[16:21:50.779]                           invokeRestart("muffleMessage")
[16:21:50.779]                       }
[16:21:50.779]                       else if (inherits(cond, "warning")) {
[16:21:50.779]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.779]                         if (muffled) 
[16:21:50.779]                           invokeRestart("muffleWarning")
[16:21:50.779]                       }
[16:21:50.779]                       else if (inherits(cond, "condition")) {
[16:21:50.779]                         if (!is.null(pattern)) {
[16:21:50.779]                           computeRestarts <- base::computeRestarts
[16:21:50.779]                           grepl <- base::grepl
[16:21:50.779]                           restarts <- computeRestarts(cond)
[16:21:50.779]                           for (restart in restarts) {
[16:21:50.779]                             name <- restart$name
[16:21:50.779]                             if (is.null(name)) 
[16:21:50.779]                               next
[16:21:50.779]                             if (!grepl(pattern, name)) 
[16:21:50.779]                               next
[16:21:50.779]                             invokeRestart(restart)
[16:21:50.779]                             muffled <- TRUE
[16:21:50.779]                             break
[16:21:50.779]                           }
[16:21:50.779]                         }
[16:21:50.779]                       }
[16:21:50.779]                       invisible(muffled)
[16:21:50.779]                     }
[16:21:50.779]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.779]                   }
[16:21:50.779]                 }
[16:21:50.779]                 else {
[16:21:50.779]                   if (TRUE) {
[16:21:50.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.779]                     {
[16:21:50.779]                       inherits <- base::inherits
[16:21:50.779]                       invokeRestart <- base::invokeRestart
[16:21:50.779]                       is.null <- base::is.null
[16:21:50.779]                       muffled <- FALSE
[16:21:50.779]                       if (inherits(cond, "message")) {
[16:21:50.779]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.779]                         if (muffled) 
[16:21:50.779]                           invokeRestart("muffleMessage")
[16:21:50.779]                       }
[16:21:50.779]                       else if (inherits(cond, "warning")) {
[16:21:50.779]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.779]                         if (muffled) 
[16:21:50.779]                           invokeRestart("muffleWarning")
[16:21:50.779]                       }
[16:21:50.779]                       else if (inherits(cond, "condition")) {
[16:21:50.779]                         if (!is.null(pattern)) {
[16:21:50.779]                           computeRestarts <- base::computeRestarts
[16:21:50.779]                           grepl <- base::grepl
[16:21:50.779]                           restarts <- computeRestarts(cond)
[16:21:50.779]                           for (restart in restarts) {
[16:21:50.779]                             name <- restart$name
[16:21:50.779]                             if (is.null(name)) 
[16:21:50.779]                               next
[16:21:50.779]                             if (!grepl(pattern, name)) 
[16:21:50.779]                               next
[16:21:50.779]                             invokeRestart(restart)
[16:21:50.779]                             muffled <- TRUE
[16:21:50.779]                             break
[16:21:50.779]                           }
[16:21:50.779]                         }
[16:21:50.779]                       }
[16:21:50.779]                       invisible(muffled)
[16:21:50.779]                     }
[16:21:50.779]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.779]                   }
[16:21:50.779]                 }
[16:21:50.779]             }
[16:21:50.779]         }))
[16:21:50.779]     }, error = function(ex) {
[16:21:50.779]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.779]                 ...future.rng), started = ...future.startTime, 
[16:21:50.779]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.779]             version = "1.8"), class = "FutureResult")
[16:21:50.779]     }, finally = {
[16:21:50.779]         if (!identical(...future.workdir, getwd())) 
[16:21:50.779]             setwd(...future.workdir)
[16:21:50.779]         {
[16:21:50.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.779]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.779]             }
[16:21:50.779]             base::options(...future.oldOptions)
[16:21:50.779]             if (.Platform$OS.type == "windows") {
[16:21:50.779]                 old_names <- names(...future.oldEnvVars)
[16:21:50.779]                 envs <- base::Sys.getenv()
[16:21:50.779]                 names <- names(envs)
[16:21:50.779]                 common <- intersect(names, old_names)
[16:21:50.779]                 added <- setdiff(names, old_names)
[16:21:50.779]                 removed <- setdiff(old_names, names)
[16:21:50.779]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.779]                   envs[common]]
[16:21:50.779]                 NAMES <- toupper(changed)
[16:21:50.779]                 args <- list()
[16:21:50.779]                 for (kk in seq_along(NAMES)) {
[16:21:50.779]                   name <- changed[[kk]]
[16:21:50.779]                   NAME <- NAMES[[kk]]
[16:21:50.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.779]                     next
[16:21:50.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.779]                 }
[16:21:50.779]                 NAMES <- toupper(added)
[16:21:50.779]                 for (kk in seq_along(NAMES)) {
[16:21:50.779]                   name <- added[[kk]]
[16:21:50.779]                   NAME <- NAMES[[kk]]
[16:21:50.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.779]                     next
[16:21:50.779]                   args[[name]] <- ""
[16:21:50.779]                 }
[16:21:50.779]                 NAMES <- toupper(removed)
[16:21:50.779]                 for (kk in seq_along(NAMES)) {
[16:21:50.779]                   name <- removed[[kk]]
[16:21:50.779]                   NAME <- NAMES[[kk]]
[16:21:50.779]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.779]                     next
[16:21:50.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.779]                 }
[16:21:50.779]                 if (length(args) > 0) 
[16:21:50.779]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.779]             }
[16:21:50.779]             else {
[16:21:50.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.779]             }
[16:21:50.779]             {
[16:21:50.779]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.779]                   0L) {
[16:21:50.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.779]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.779]                   base::options(opts)
[16:21:50.779]                 }
[16:21:50.779]                 {
[16:21:50.779]                   {
[16:21:50.779]                     NULL
[16:21:50.779]                     RNGkind("Mersenne-Twister")
[16:21:50.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.779]                       inherits = FALSE)
[16:21:50.779]                   }
[16:21:50.779]                   options(future.plan = NULL)
[16:21:50.779]                   if (is.na(NA_character_)) 
[16:21:50.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.779]                     .init = FALSE)
[16:21:50.779]                 }
[16:21:50.779]             }
[16:21:50.779]         }
[16:21:50.779]     })
[16:21:50.779]     if (TRUE) {
[16:21:50.779]         base::sink(type = "output", split = FALSE)
[16:21:50.779]         if (TRUE) {
[16:21:50.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.779]         }
[16:21:50.779]         else {
[16:21:50.779]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.779]         }
[16:21:50.779]         base::close(...future.stdout)
[16:21:50.779]         ...future.stdout <- NULL
[16:21:50.779]     }
[16:21:50.779]     ...future.result$conditions <- ...future.conditions
[16:21:50.779]     ...future.result$finished <- base::Sys.time()
[16:21:50.779]     ...future.result
[16:21:50.779] }
[16:21:50.781] plan(): Setting new future strategy stack:
[16:21:50.781] List of future strategies:
[16:21:50.781] 1. sequential:
[16:21:50.781]    - args: function (..., envir = parent.frame())
[16:21:50.781]    - tweaked: FALSE
[16:21:50.781]    - call: NULL
[16:21:50.781] plan(): nbrOfWorkers() = 1
[16:21:50.782] plan(): Setting new future strategy stack:
[16:21:50.782] List of future strategies:
[16:21:50.782] 1. sequential:
[16:21:50.782]    - args: function (..., envir = parent.frame())
[16:21:50.782]    - tweaked: FALSE
[16:21:50.782]    - call: plan(strategy)
[16:21:50.782] plan(): nbrOfWorkers() = 1
[16:21:50.782] SequentialFuture started (and completed)
[16:21:50.782] - Launch lazy future ... done
[16:21:50.783] run() for ‘SequentialFuture’ ... done
[16:21:50.783] resolve() on list environment ...
[16:21:50.783]  recursive: 0
[16:21:50.784]  length: 3
[16:21:50.784]  elements: ‘a’, ‘b’, ‘c’
[16:21:50.784] resolved() for ‘SequentialFuture’ ...
[16:21:50.784] - state: ‘finished’
[16:21:50.784] - run: TRUE
[16:21:50.785] - result: ‘FutureResult’
[16:21:50.785] resolved() for ‘SequentialFuture’ ... done
[16:21:50.785] Future #1
[16:21:50.785]  length: 2 (resolved future 1)
[16:21:50.785] resolved() for ‘SequentialFuture’ ...
[16:21:50.785] - state: ‘finished’
[16:21:50.785] - run: TRUE
[16:21:50.785] - result: ‘FutureResult’
[16:21:50.785] resolved() for ‘SequentialFuture’ ... done
[16:21:50.785] Future #2
[16:21:50.786]  length: 1 (resolved future 2)
[16:21:50.786]  length: 0 (resolved future 3)
[16:21:50.786] resolve() on list environment ... DONE
[16:21:50.787] getGlobalsAndPackages() ...
[16:21:50.787] Searching for globals...
[16:21:50.789] - globals found: [1] ‘{’
[16:21:50.790] Searching for globals ... DONE
[16:21:50.790] Resolving globals: FALSE
[16:21:50.790] 
[16:21:50.790] 
[16:21:50.790] getGlobalsAndPackages() ... DONE
[16:21:50.790] run() for ‘Future’ ...
[16:21:50.791] - state: ‘created’
[16:21:50.791] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.791] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.791]   - Field: ‘label’
[16:21:50.791]   - Field: ‘local’
[16:21:50.791]   - Field: ‘owner’
[16:21:50.791]   - Field: ‘envir’
[16:21:50.792]   - Field: ‘packages’
[16:21:50.792]   - Field: ‘gc’
[16:21:50.792]   - Field: ‘conditions’
[16:21:50.792]   - Field: ‘expr’
[16:21:50.792]   - Field: ‘uuid’
[16:21:50.792]   - Field: ‘seed’
[16:21:50.792]   - Field: ‘version’
[16:21:50.792]   - Field: ‘result’
[16:21:50.792]   - Field: ‘asynchronous’
[16:21:50.792]   - Field: ‘calls’
[16:21:50.793]   - Field: ‘globals’
[16:21:50.793]   - Field: ‘stdout’
[16:21:50.793]   - Field: ‘earlySignal’
[16:21:50.793]   - Field: ‘lazy’
[16:21:50.793]   - Field: ‘state’
[16:21:50.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.793] - Launch lazy future ...
[16:21:50.793] Packages needed by the future expression (n = 0): <none>
[16:21:50.793] Packages needed by future strategies (n = 0): <none>
[16:21:50.794] {
[16:21:50.794]     {
[16:21:50.794]         {
[16:21:50.794]             ...future.startTime <- base::Sys.time()
[16:21:50.794]             {
[16:21:50.794]                 {
[16:21:50.794]                   {
[16:21:50.794]                     base::local({
[16:21:50.794]                       has_future <- base::requireNamespace("future", 
[16:21:50.794]                         quietly = TRUE)
[16:21:50.794]                       if (has_future) {
[16:21:50.794]                         ns <- base::getNamespace("future")
[16:21:50.794]                         version <- ns[[".package"]][["version"]]
[16:21:50.794]                         if (is.null(version)) 
[16:21:50.794]                           version <- utils::packageVersion("future")
[16:21:50.794]                       }
[16:21:50.794]                       else {
[16:21:50.794]                         version <- NULL
[16:21:50.794]                       }
[16:21:50.794]                       if (!has_future || version < "1.8.0") {
[16:21:50.794]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.794]                           "", base::R.version$version.string), 
[16:21:50.794]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.794]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.794]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.794]                             "release", "version")], collapse = " "), 
[16:21:50.794]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.794]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.794]                           info)
[16:21:50.794]                         info <- base::paste(info, collapse = "; ")
[16:21:50.794]                         if (!has_future) {
[16:21:50.794]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.794]                             info)
[16:21:50.794]                         }
[16:21:50.794]                         else {
[16:21:50.794]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.794]                             info, version)
[16:21:50.794]                         }
[16:21:50.794]                         base::stop(msg)
[16:21:50.794]                       }
[16:21:50.794]                     })
[16:21:50.794]                   }
[16:21:50.794]                   ...future.strategy.old <- future::plan("list")
[16:21:50.794]                   options(future.plan = NULL)
[16:21:50.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.794]                 }
[16:21:50.794]                 ...future.workdir <- getwd()
[16:21:50.794]             }
[16:21:50.794]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.794]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.794]         }
[16:21:50.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.794]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.794]             base::names(...future.oldOptions))
[16:21:50.794]     }
[16:21:50.794]     if (FALSE) {
[16:21:50.794]     }
[16:21:50.794]     else {
[16:21:50.794]         if (TRUE) {
[16:21:50.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.794]                 open = "w")
[16:21:50.794]         }
[16:21:50.794]         else {
[16:21:50.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.794]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.794]         }
[16:21:50.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.794]             base::sink(type = "output", split = FALSE)
[16:21:50.794]             base::close(...future.stdout)
[16:21:50.794]         }, add = TRUE)
[16:21:50.794]     }
[16:21:50.794]     ...future.frame <- base::sys.nframe()
[16:21:50.794]     ...future.conditions <- base::list()
[16:21:50.794]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.794]     if (FALSE) {
[16:21:50.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.794]     }
[16:21:50.794]     ...future.result <- base::tryCatch({
[16:21:50.794]         base::withCallingHandlers({
[16:21:50.794]             ...future.value <- base::withVisible(base::local({
[16:21:50.794]                 1
[16:21:50.794]             }))
[16:21:50.794]             future::FutureResult(value = ...future.value$value, 
[16:21:50.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.794]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.794]                     ...future.globalenv.names))
[16:21:50.794]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.794]         }, condition = base::local({
[16:21:50.794]             c <- base::c
[16:21:50.794]             inherits <- base::inherits
[16:21:50.794]             invokeRestart <- base::invokeRestart
[16:21:50.794]             length <- base::length
[16:21:50.794]             list <- base::list
[16:21:50.794]             seq.int <- base::seq.int
[16:21:50.794]             signalCondition <- base::signalCondition
[16:21:50.794]             sys.calls <- base::sys.calls
[16:21:50.794]             `[[` <- base::`[[`
[16:21:50.794]             `+` <- base::`+`
[16:21:50.794]             `<<-` <- base::`<<-`
[16:21:50.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.794]                   3L)]
[16:21:50.794]             }
[16:21:50.794]             function(cond) {
[16:21:50.794]                 is_error <- inherits(cond, "error")
[16:21:50.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.794]                   NULL)
[16:21:50.794]                 if (is_error) {
[16:21:50.794]                   sessionInformation <- function() {
[16:21:50.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.794]                       search = base::search(), system = base::Sys.info())
[16:21:50.794]                   }
[16:21:50.794]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.794]                     cond$call), session = sessionInformation(), 
[16:21:50.794]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.794]                   signalCondition(cond)
[16:21:50.794]                 }
[16:21:50.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.794]                 "immediateCondition"))) {
[16:21:50.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.794]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.794]                   if (TRUE && !signal) {
[16:21:50.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.794]                     {
[16:21:50.794]                       inherits <- base::inherits
[16:21:50.794]                       invokeRestart <- base::invokeRestart
[16:21:50.794]                       is.null <- base::is.null
[16:21:50.794]                       muffled <- FALSE
[16:21:50.794]                       if (inherits(cond, "message")) {
[16:21:50.794]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.794]                         if (muffled) 
[16:21:50.794]                           invokeRestart("muffleMessage")
[16:21:50.794]                       }
[16:21:50.794]                       else if (inherits(cond, "warning")) {
[16:21:50.794]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.794]                         if (muffled) 
[16:21:50.794]                           invokeRestart("muffleWarning")
[16:21:50.794]                       }
[16:21:50.794]                       else if (inherits(cond, "condition")) {
[16:21:50.794]                         if (!is.null(pattern)) {
[16:21:50.794]                           computeRestarts <- base::computeRestarts
[16:21:50.794]                           grepl <- base::grepl
[16:21:50.794]                           restarts <- computeRestarts(cond)
[16:21:50.794]                           for (restart in restarts) {
[16:21:50.794]                             name <- restart$name
[16:21:50.794]                             if (is.null(name)) 
[16:21:50.794]                               next
[16:21:50.794]                             if (!grepl(pattern, name)) 
[16:21:50.794]                               next
[16:21:50.794]                             invokeRestart(restart)
[16:21:50.794]                             muffled <- TRUE
[16:21:50.794]                             break
[16:21:50.794]                           }
[16:21:50.794]                         }
[16:21:50.794]                       }
[16:21:50.794]                       invisible(muffled)
[16:21:50.794]                     }
[16:21:50.794]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.794]                   }
[16:21:50.794]                 }
[16:21:50.794]                 else {
[16:21:50.794]                   if (TRUE) {
[16:21:50.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.794]                     {
[16:21:50.794]                       inherits <- base::inherits
[16:21:50.794]                       invokeRestart <- base::invokeRestart
[16:21:50.794]                       is.null <- base::is.null
[16:21:50.794]                       muffled <- FALSE
[16:21:50.794]                       if (inherits(cond, "message")) {
[16:21:50.794]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.794]                         if (muffled) 
[16:21:50.794]                           invokeRestart("muffleMessage")
[16:21:50.794]                       }
[16:21:50.794]                       else if (inherits(cond, "warning")) {
[16:21:50.794]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.794]                         if (muffled) 
[16:21:50.794]                           invokeRestart("muffleWarning")
[16:21:50.794]                       }
[16:21:50.794]                       else if (inherits(cond, "condition")) {
[16:21:50.794]                         if (!is.null(pattern)) {
[16:21:50.794]                           computeRestarts <- base::computeRestarts
[16:21:50.794]                           grepl <- base::grepl
[16:21:50.794]                           restarts <- computeRestarts(cond)
[16:21:50.794]                           for (restart in restarts) {
[16:21:50.794]                             name <- restart$name
[16:21:50.794]                             if (is.null(name)) 
[16:21:50.794]                               next
[16:21:50.794]                             if (!grepl(pattern, name)) 
[16:21:50.794]                               next
[16:21:50.794]                             invokeRestart(restart)
[16:21:50.794]                             muffled <- TRUE
[16:21:50.794]                             break
[16:21:50.794]                           }
[16:21:50.794]                         }
[16:21:50.794]                       }
[16:21:50.794]                       invisible(muffled)
[16:21:50.794]                     }
[16:21:50.794]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.794]                   }
[16:21:50.794]                 }
[16:21:50.794]             }
[16:21:50.794]         }))
[16:21:50.794]     }, error = function(ex) {
[16:21:50.794]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.794]                 ...future.rng), started = ...future.startTime, 
[16:21:50.794]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.794]             version = "1.8"), class = "FutureResult")
[16:21:50.794]     }, finally = {
[16:21:50.794]         if (!identical(...future.workdir, getwd())) 
[16:21:50.794]             setwd(...future.workdir)
[16:21:50.794]         {
[16:21:50.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.794]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.794]             }
[16:21:50.794]             base::options(...future.oldOptions)
[16:21:50.794]             if (.Platform$OS.type == "windows") {
[16:21:50.794]                 old_names <- names(...future.oldEnvVars)
[16:21:50.794]                 envs <- base::Sys.getenv()
[16:21:50.794]                 names <- names(envs)
[16:21:50.794]                 common <- intersect(names, old_names)
[16:21:50.794]                 added <- setdiff(names, old_names)
[16:21:50.794]                 removed <- setdiff(old_names, names)
[16:21:50.794]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.794]                   envs[common]]
[16:21:50.794]                 NAMES <- toupper(changed)
[16:21:50.794]                 args <- list()
[16:21:50.794]                 for (kk in seq_along(NAMES)) {
[16:21:50.794]                   name <- changed[[kk]]
[16:21:50.794]                   NAME <- NAMES[[kk]]
[16:21:50.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.794]                     next
[16:21:50.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.794]                 }
[16:21:50.794]                 NAMES <- toupper(added)
[16:21:50.794]                 for (kk in seq_along(NAMES)) {
[16:21:50.794]                   name <- added[[kk]]
[16:21:50.794]                   NAME <- NAMES[[kk]]
[16:21:50.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.794]                     next
[16:21:50.794]                   args[[name]] <- ""
[16:21:50.794]                 }
[16:21:50.794]                 NAMES <- toupper(removed)
[16:21:50.794]                 for (kk in seq_along(NAMES)) {
[16:21:50.794]                   name <- removed[[kk]]
[16:21:50.794]                   NAME <- NAMES[[kk]]
[16:21:50.794]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.794]                     next
[16:21:50.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.794]                 }
[16:21:50.794]                 if (length(args) > 0) 
[16:21:50.794]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.794]             }
[16:21:50.794]             else {
[16:21:50.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.794]             }
[16:21:50.794]             {
[16:21:50.794]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.794]                   0L) {
[16:21:50.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.794]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.794]                   base::options(opts)
[16:21:50.794]                 }
[16:21:50.794]                 {
[16:21:50.794]                   {
[16:21:50.794]                     NULL
[16:21:50.794]                     RNGkind("Mersenne-Twister")
[16:21:50.794]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.794]                       inherits = FALSE)
[16:21:50.794]                   }
[16:21:50.794]                   options(future.plan = NULL)
[16:21:50.794]                   if (is.na(NA_character_)) 
[16:21:50.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.794]                     .init = FALSE)
[16:21:50.794]                 }
[16:21:50.794]             }
[16:21:50.794]         }
[16:21:50.794]     })
[16:21:50.794]     if (TRUE) {
[16:21:50.794]         base::sink(type = "output", split = FALSE)
[16:21:50.794]         if (TRUE) {
[16:21:50.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.794]         }
[16:21:50.794]         else {
[16:21:50.794]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.794]         }
[16:21:50.794]         base::close(...future.stdout)
[16:21:50.794]         ...future.stdout <- NULL
[16:21:50.794]     }
[16:21:50.794]     ...future.result$conditions <- ...future.conditions
[16:21:50.794]     ...future.result$finished <- base::Sys.time()
[16:21:50.794]     ...future.result
[16:21:50.794] }
[16:21:50.796] plan(): Setting new future strategy stack:
[16:21:50.796] List of future strategies:
[16:21:50.796] 1. sequential:
[16:21:50.796]    - args: function (..., envir = parent.frame())
[16:21:50.796]    - tweaked: FALSE
[16:21:50.796]    - call: NULL
[16:21:50.796] plan(): nbrOfWorkers() = 1
[16:21:50.797] plan(): Setting new future strategy stack:
[16:21:50.797] List of future strategies:
[16:21:50.797] 1. sequential:
[16:21:50.797]    - args: function (..., envir = parent.frame())
[16:21:50.797]    - tweaked: FALSE
[16:21:50.797]    - call: plan(strategy)
[16:21:50.797] plan(): nbrOfWorkers() = 1
[16:21:50.797] SequentialFuture started (and completed)
[16:21:50.797] - Launch lazy future ... done
[16:21:50.798] run() for ‘SequentialFuture’ ... done
[16:21:50.798] getGlobalsAndPackages() ...
[16:21:50.798] Searching for globals...
[16:21:50.799] - globals found: [1] ‘{’
[16:21:50.799] Searching for globals ... DONE
[16:21:50.799] Resolving globals: FALSE
[16:21:50.799] 
[16:21:50.799] 
[16:21:50.799] getGlobalsAndPackages() ... DONE
[16:21:50.799] run() for ‘Future’ ...
[16:21:50.800] - state: ‘created’
[16:21:50.800] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.800] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.800]   - Field: ‘label’
[16:21:50.800]   - Field: ‘local’
[16:21:50.800]   - Field: ‘owner’
[16:21:50.801]   - Field: ‘envir’
[16:21:50.801]   - Field: ‘packages’
[16:21:50.801]   - Field: ‘gc’
[16:21:50.801]   - Field: ‘conditions’
[16:21:50.801]   - Field: ‘expr’
[16:21:50.801]   - Field: ‘uuid’
[16:21:50.801]   - Field: ‘seed’
[16:21:50.801]   - Field: ‘version’
[16:21:50.801]   - Field: ‘result’
[16:21:50.801]   - Field: ‘asynchronous’
[16:21:50.802]   - Field: ‘calls’
[16:21:50.802]   - Field: ‘globals’
[16:21:50.802]   - Field: ‘stdout’
[16:21:50.802]   - Field: ‘earlySignal’
[16:21:50.802]   - Field: ‘lazy’
[16:21:50.802]   - Field: ‘state’
[16:21:50.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.802] - Launch lazy future ...
[16:21:50.802] Packages needed by the future expression (n = 0): <none>
[16:21:50.803] Packages needed by future strategies (n = 0): <none>
[16:21:50.803] {
[16:21:50.803]     {
[16:21:50.803]         {
[16:21:50.803]             ...future.startTime <- base::Sys.time()
[16:21:50.803]             {
[16:21:50.803]                 {
[16:21:50.803]                   {
[16:21:50.803]                     base::local({
[16:21:50.803]                       has_future <- base::requireNamespace("future", 
[16:21:50.803]                         quietly = TRUE)
[16:21:50.803]                       if (has_future) {
[16:21:50.803]                         ns <- base::getNamespace("future")
[16:21:50.803]                         version <- ns[[".package"]][["version"]]
[16:21:50.803]                         if (is.null(version)) 
[16:21:50.803]                           version <- utils::packageVersion("future")
[16:21:50.803]                       }
[16:21:50.803]                       else {
[16:21:50.803]                         version <- NULL
[16:21:50.803]                       }
[16:21:50.803]                       if (!has_future || version < "1.8.0") {
[16:21:50.803]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.803]                           "", base::R.version$version.string), 
[16:21:50.803]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.803]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.803]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.803]                             "release", "version")], collapse = " "), 
[16:21:50.803]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.803]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.803]                           info)
[16:21:50.803]                         info <- base::paste(info, collapse = "; ")
[16:21:50.803]                         if (!has_future) {
[16:21:50.803]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.803]                             info)
[16:21:50.803]                         }
[16:21:50.803]                         else {
[16:21:50.803]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.803]                             info, version)
[16:21:50.803]                         }
[16:21:50.803]                         base::stop(msg)
[16:21:50.803]                       }
[16:21:50.803]                     })
[16:21:50.803]                   }
[16:21:50.803]                   ...future.strategy.old <- future::plan("list")
[16:21:50.803]                   options(future.plan = NULL)
[16:21:50.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.803]                 }
[16:21:50.803]                 ...future.workdir <- getwd()
[16:21:50.803]             }
[16:21:50.803]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.803]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.803]         }
[16:21:50.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.803]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.803]             base::names(...future.oldOptions))
[16:21:50.803]     }
[16:21:50.803]     if (FALSE) {
[16:21:50.803]     }
[16:21:50.803]     else {
[16:21:50.803]         if (TRUE) {
[16:21:50.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.803]                 open = "w")
[16:21:50.803]         }
[16:21:50.803]         else {
[16:21:50.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.803]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.803]         }
[16:21:50.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.803]             base::sink(type = "output", split = FALSE)
[16:21:50.803]             base::close(...future.stdout)
[16:21:50.803]         }, add = TRUE)
[16:21:50.803]     }
[16:21:50.803]     ...future.frame <- base::sys.nframe()
[16:21:50.803]     ...future.conditions <- base::list()
[16:21:50.803]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.803]     if (FALSE) {
[16:21:50.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.803]     }
[16:21:50.803]     ...future.result <- base::tryCatch({
[16:21:50.803]         base::withCallingHandlers({
[16:21:50.803]             ...future.value <- base::withVisible(base::local({
[16:21:50.803]                 2
[16:21:50.803]             }))
[16:21:50.803]             future::FutureResult(value = ...future.value$value, 
[16:21:50.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.803]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.803]                     ...future.globalenv.names))
[16:21:50.803]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.803]         }, condition = base::local({
[16:21:50.803]             c <- base::c
[16:21:50.803]             inherits <- base::inherits
[16:21:50.803]             invokeRestart <- base::invokeRestart
[16:21:50.803]             length <- base::length
[16:21:50.803]             list <- base::list
[16:21:50.803]             seq.int <- base::seq.int
[16:21:50.803]             signalCondition <- base::signalCondition
[16:21:50.803]             sys.calls <- base::sys.calls
[16:21:50.803]             `[[` <- base::`[[`
[16:21:50.803]             `+` <- base::`+`
[16:21:50.803]             `<<-` <- base::`<<-`
[16:21:50.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.803]                   3L)]
[16:21:50.803]             }
[16:21:50.803]             function(cond) {
[16:21:50.803]                 is_error <- inherits(cond, "error")
[16:21:50.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.803]                   NULL)
[16:21:50.803]                 if (is_error) {
[16:21:50.803]                   sessionInformation <- function() {
[16:21:50.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.803]                       search = base::search(), system = base::Sys.info())
[16:21:50.803]                   }
[16:21:50.803]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.803]                     cond$call), session = sessionInformation(), 
[16:21:50.803]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.803]                   signalCondition(cond)
[16:21:50.803]                 }
[16:21:50.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.803]                 "immediateCondition"))) {
[16:21:50.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.803]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.803]                   if (TRUE && !signal) {
[16:21:50.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.803]                     {
[16:21:50.803]                       inherits <- base::inherits
[16:21:50.803]                       invokeRestart <- base::invokeRestart
[16:21:50.803]                       is.null <- base::is.null
[16:21:50.803]                       muffled <- FALSE
[16:21:50.803]                       if (inherits(cond, "message")) {
[16:21:50.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.803]                         if (muffled) 
[16:21:50.803]                           invokeRestart("muffleMessage")
[16:21:50.803]                       }
[16:21:50.803]                       else if (inherits(cond, "warning")) {
[16:21:50.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.803]                         if (muffled) 
[16:21:50.803]                           invokeRestart("muffleWarning")
[16:21:50.803]                       }
[16:21:50.803]                       else if (inherits(cond, "condition")) {
[16:21:50.803]                         if (!is.null(pattern)) {
[16:21:50.803]                           computeRestarts <- base::computeRestarts
[16:21:50.803]                           grepl <- base::grepl
[16:21:50.803]                           restarts <- computeRestarts(cond)
[16:21:50.803]                           for (restart in restarts) {
[16:21:50.803]                             name <- restart$name
[16:21:50.803]                             if (is.null(name)) 
[16:21:50.803]                               next
[16:21:50.803]                             if (!grepl(pattern, name)) 
[16:21:50.803]                               next
[16:21:50.803]                             invokeRestart(restart)
[16:21:50.803]                             muffled <- TRUE
[16:21:50.803]                             break
[16:21:50.803]                           }
[16:21:50.803]                         }
[16:21:50.803]                       }
[16:21:50.803]                       invisible(muffled)
[16:21:50.803]                     }
[16:21:50.803]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.803]                   }
[16:21:50.803]                 }
[16:21:50.803]                 else {
[16:21:50.803]                   if (TRUE) {
[16:21:50.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.803]                     {
[16:21:50.803]                       inherits <- base::inherits
[16:21:50.803]                       invokeRestart <- base::invokeRestart
[16:21:50.803]                       is.null <- base::is.null
[16:21:50.803]                       muffled <- FALSE
[16:21:50.803]                       if (inherits(cond, "message")) {
[16:21:50.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.803]                         if (muffled) 
[16:21:50.803]                           invokeRestart("muffleMessage")
[16:21:50.803]                       }
[16:21:50.803]                       else if (inherits(cond, "warning")) {
[16:21:50.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.803]                         if (muffled) 
[16:21:50.803]                           invokeRestart("muffleWarning")
[16:21:50.803]                       }
[16:21:50.803]                       else if (inherits(cond, "condition")) {
[16:21:50.803]                         if (!is.null(pattern)) {
[16:21:50.803]                           computeRestarts <- base::computeRestarts
[16:21:50.803]                           grepl <- base::grepl
[16:21:50.803]                           restarts <- computeRestarts(cond)
[16:21:50.803]                           for (restart in restarts) {
[16:21:50.803]                             name <- restart$name
[16:21:50.803]                             if (is.null(name)) 
[16:21:50.803]                               next
[16:21:50.803]                             if (!grepl(pattern, name)) 
[16:21:50.803]                               next
[16:21:50.803]                             invokeRestart(restart)
[16:21:50.803]                             muffled <- TRUE
[16:21:50.803]                             break
[16:21:50.803]                           }
[16:21:50.803]                         }
[16:21:50.803]                       }
[16:21:50.803]                       invisible(muffled)
[16:21:50.803]                     }
[16:21:50.803]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.803]                   }
[16:21:50.803]                 }
[16:21:50.803]             }
[16:21:50.803]         }))
[16:21:50.803]     }, error = function(ex) {
[16:21:50.803]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.803]                 ...future.rng), started = ...future.startTime, 
[16:21:50.803]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.803]             version = "1.8"), class = "FutureResult")
[16:21:50.803]     }, finally = {
[16:21:50.803]         if (!identical(...future.workdir, getwd())) 
[16:21:50.803]             setwd(...future.workdir)
[16:21:50.803]         {
[16:21:50.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.803]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.803]             }
[16:21:50.803]             base::options(...future.oldOptions)
[16:21:50.803]             if (.Platform$OS.type == "windows") {
[16:21:50.803]                 old_names <- names(...future.oldEnvVars)
[16:21:50.803]                 envs <- base::Sys.getenv()
[16:21:50.803]                 names <- names(envs)
[16:21:50.803]                 common <- intersect(names, old_names)
[16:21:50.803]                 added <- setdiff(names, old_names)
[16:21:50.803]                 removed <- setdiff(old_names, names)
[16:21:50.803]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.803]                   envs[common]]
[16:21:50.803]                 NAMES <- toupper(changed)
[16:21:50.803]                 args <- list()
[16:21:50.803]                 for (kk in seq_along(NAMES)) {
[16:21:50.803]                   name <- changed[[kk]]
[16:21:50.803]                   NAME <- NAMES[[kk]]
[16:21:50.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.803]                     next
[16:21:50.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.803]                 }
[16:21:50.803]                 NAMES <- toupper(added)
[16:21:50.803]                 for (kk in seq_along(NAMES)) {
[16:21:50.803]                   name <- added[[kk]]
[16:21:50.803]                   NAME <- NAMES[[kk]]
[16:21:50.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.803]                     next
[16:21:50.803]                   args[[name]] <- ""
[16:21:50.803]                 }
[16:21:50.803]                 NAMES <- toupper(removed)
[16:21:50.803]                 for (kk in seq_along(NAMES)) {
[16:21:50.803]                   name <- removed[[kk]]
[16:21:50.803]                   NAME <- NAMES[[kk]]
[16:21:50.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.803]                     next
[16:21:50.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.803]                 }
[16:21:50.803]                 if (length(args) > 0) 
[16:21:50.803]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.803]             }
[16:21:50.803]             else {
[16:21:50.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.803]             }
[16:21:50.803]             {
[16:21:50.803]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.803]                   0L) {
[16:21:50.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.803]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.803]                   base::options(opts)
[16:21:50.803]                 }
[16:21:50.803]                 {
[16:21:50.803]                   {
[16:21:50.803]                     NULL
[16:21:50.803]                     RNGkind("Mersenne-Twister")
[16:21:50.803]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.803]                       inherits = FALSE)
[16:21:50.803]                   }
[16:21:50.803]                   options(future.plan = NULL)
[16:21:50.803]                   if (is.na(NA_character_)) 
[16:21:50.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.803]                     .init = FALSE)
[16:21:50.803]                 }
[16:21:50.803]             }
[16:21:50.803]         }
[16:21:50.803]     })
[16:21:50.803]     if (TRUE) {
[16:21:50.803]         base::sink(type = "output", split = FALSE)
[16:21:50.803]         if (TRUE) {
[16:21:50.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.803]         }
[16:21:50.803]         else {
[16:21:50.803]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.803]         }
[16:21:50.803]         base::close(...future.stdout)
[16:21:50.803]         ...future.stdout <- NULL
[16:21:50.803]     }
[16:21:50.803]     ...future.result$conditions <- ...future.conditions
[16:21:50.803]     ...future.result$finished <- base::Sys.time()
[16:21:50.803]     ...future.result
[16:21:50.803] }
[16:21:50.805] plan(): Setting new future strategy stack:
[16:21:50.805] List of future strategies:
[16:21:50.805] 1. sequential:
[16:21:50.805]    - args: function (..., envir = parent.frame())
[16:21:50.805]    - tweaked: FALSE
[16:21:50.805]    - call: NULL
[16:21:50.805] plan(): nbrOfWorkers() = 1
[16:21:50.806] plan(): Setting new future strategy stack:
[16:21:50.806] List of future strategies:
[16:21:50.806] 1. sequential:
[16:21:50.806]    - args: function (..., envir = parent.frame())
[16:21:50.806]    - tweaked: FALSE
[16:21:50.806]    - call: plan(strategy)
[16:21:50.806] plan(): nbrOfWorkers() = 1
[16:21:50.806] SequentialFuture started (and completed)
[16:21:50.807] - Launch lazy future ... done
[16:21:50.807] run() for ‘SequentialFuture’ ... done
[16:21:50.807] resolve() on list environment ...
[16:21:50.807]  recursive: 0
[16:21:50.808]  length: 3
[16:21:50.808]  elements: ‘a’, ‘b’, ‘c’
[16:21:50.808] resolved() for ‘SequentialFuture’ ...
[16:21:50.808] - state: ‘finished’
[16:21:50.808] - run: TRUE
[16:21:50.808] - result: ‘FutureResult’
[16:21:50.808] resolved() for ‘SequentialFuture’ ... done
[16:21:50.808] Future #1
[16:21:50.808]  length: 2 (resolved future 1)
[16:21:50.809] resolved() for ‘SequentialFuture’ ...
[16:21:50.809] - state: ‘finished’
[16:21:50.809] - run: TRUE
[16:21:50.809] - result: ‘FutureResult’
[16:21:50.809] resolved() for ‘SequentialFuture’ ... done
[16:21:50.809] Future #2
[16:21:50.809]  length: 1 (resolved future 2)
[16:21:50.809]  length: 0 (resolved future 3)
[16:21:50.809] resolve() on list environment ... DONE
[16:21:50.810] getGlobalsAndPackages() ...
[16:21:50.810] Searching for globals...
[16:21:50.810] - globals found: [1] ‘{’
[16:21:50.811] Searching for globals ... DONE
[16:21:50.811] Resolving globals: FALSE
[16:21:50.811] 
[16:21:50.811] 
[16:21:50.811] getGlobalsAndPackages() ... DONE
[16:21:50.811] run() for ‘Future’ ...
[16:21:50.811] - state: ‘created’
[16:21:50.812] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.812] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.812]   - Field: ‘label’
[16:21:50.812]   - Field: ‘local’
[16:21:50.812]   - Field: ‘owner’
[16:21:50.812]   - Field: ‘envir’
[16:21:50.812]   - Field: ‘packages’
[16:21:50.813]   - Field: ‘gc’
[16:21:50.813]   - Field: ‘conditions’
[16:21:50.813]   - Field: ‘expr’
[16:21:50.813]   - Field: ‘uuid’
[16:21:50.813]   - Field: ‘seed’
[16:21:50.813]   - Field: ‘version’
[16:21:50.813]   - Field: ‘result’
[16:21:50.813]   - Field: ‘asynchronous’
[16:21:50.813]   - Field: ‘calls’
[16:21:50.813]   - Field: ‘globals’
[16:21:50.813]   - Field: ‘stdout’
[16:21:50.814]   - Field: ‘earlySignal’
[16:21:50.814]   - Field: ‘lazy’
[16:21:50.816]   - Field: ‘state’
[16:21:50.816] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.816] - Launch lazy future ...
[16:21:50.816] Packages needed by the future expression (n = 0): <none>
[16:21:50.816] Packages needed by future strategies (n = 0): <none>
[16:21:50.817] {
[16:21:50.817]     {
[16:21:50.817]         {
[16:21:50.817]             ...future.startTime <- base::Sys.time()
[16:21:50.817]             {
[16:21:50.817]                 {
[16:21:50.817]                   {
[16:21:50.817]                     base::local({
[16:21:50.817]                       has_future <- base::requireNamespace("future", 
[16:21:50.817]                         quietly = TRUE)
[16:21:50.817]                       if (has_future) {
[16:21:50.817]                         ns <- base::getNamespace("future")
[16:21:50.817]                         version <- ns[[".package"]][["version"]]
[16:21:50.817]                         if (is.null(version)) 
[16:21:50.817]                           version <- utils::packageVersion("future")
[16:21:50.817]                       }
[16:21:50.817]                       else {
[16:21:50.817]                         version <- NULL
[16:21:50.817]                       }
[16:21:50.817]                       if (!has_future || version < "1.8.0") {
[16:21:50.817]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.817]                           "", base::R.version$version.string), 
[16:21:50.817]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.817]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.817]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.817]                             "release", "version")], collapse = " "), 
[16:21:50.817]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.817]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.817]                           info)
[16:21:50.817]                         info <- base::paste(info, collapse = "; ")
[16:21:50.817]                         if (!has_future) {
[16:21:50.817]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.817]                             info)
[16:21:50.817]                         }
[16:21:50.817]                         else {
[16:21:50.817]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.817]                             info, version)
[16:21:50.817]                         }
[16:21:50.817]                         base::stop(msg)
[16:21:50.817]                       }
[16:21:50.817]                     })
[16:21:50.817]                   }
[16:21:50.817]                   ...future.strategy.old <- future::plan("list")
[16:21:50.817]                   options(future.plan = NULL)
[16:21:50.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.817]                 }
[16:21:50.817]                 ...future.workdir <- getwd()
[16:21:50.817]             }
[16:21:50.817]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.817]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.817]         }
[16:21:50.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.817]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.817]             base::names(...future.oldOptions))
[16:21:50.817]     }
[16:21:50.817]     if (FALSE) {
[16:21:50.817]     }
[16:21:50.817]     else {
[16:21:50.817]         if (TRUE) {
[16:21:50.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.817]                 open = "w")
[16:21:50.817]         }
[16:21:50.817]         else {
[16:21:50.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.817]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.817]         }
[16:21:50.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.817]             base::sink(type = "output", split = FALSE)
[16:21:50.817]             base::close(...future.stdout)
[16:21:50.817]         }, add = TRUE)
[16:21:50.817]     }
[16:21:50.817]     ...future.frame <- base::sys.nframe()
[16:21:50.817]     ...future.conditions <- base::list()
[16:21:50.817]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.817]     if (FALSE) {
[16:21:50.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.817]     }
[16:21:50.817]     ...future.result <- base::tryCatch({
[16:21:50.817]         base::withCallingHandlers({
[16:21:50.817]             ...future.value <- base::withVisible(base::local({
[16:21:50.817]                 1
[16:21:50.817]             }))
[16:21:50.817]             future::FutureResult(value = ...future.value$value, 
[16:21:50.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.817]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.817]                     ...future.globalenv.names))
[16:21:50.817]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.817]         }, condition = base::local({
[16:21:50.817]             c <- base::c
[16:21:50.817]             inherits <- base::inherits
[16:21:50.817]             invokeRestart <- base::invokeRestart
[16:21:50.817]             length <- base::length
[16:21:50.817]             list <- base::list
[16:21:50.817]             seq.int <- base::seq.int
[16:21:50.817]             signalCondition <- base::signalCondition
[16:21:50.817]             sys.calls <- base::sys.calls
[16:21:50.817]             `[[` <- base::`[[`
[16:21:50.817]             `+` <- base::`+`
[16:21:50.817]             `<<-` <- base::`<<-`
[16:21:50.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.817]                   3L)]
[16:21:50.817]             }
[16:21:50.817]             function(cond) {
[16:21:50.817]                 is_error <- inherits(cond, "error")
[16:21:50.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.817]                   NULL)
[16:21:50.817]                 if (is_error) {
[16:21:50.817]                   sessionInformation <- function() {
[16:21:50.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.817]                       search = base::search(), system = base::Sys.info())
[16:21:50.817]                   }
[16:21:50.817]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.817]                     cond$call), session = sessionInformation(), 
[16:21:50.817]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.817]                   signalCondition(cond)
[16:21:50.817]                 }
[16:21:50.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.817]                 "immediateCondition"))) {
[16:21:50.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.817]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.817]                   if (TRUE && !signal) {
[16:21:50.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.817]                     {
[16:21:50.817]                       inherits <- base::inherits
[16:21:50.817]                       invokeRestart <- base::invokeRestart
[16:21:50.817]                       is.null <- base::is.null
[16:21:50.817]                       muffled <- FALSE
[16:21:50.817]                       if (inherits(cond, "message")) {
[16:21:50.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.817]                         if (muffled) 
[16:21:50.817]                           invokeRestart("muffleMessage")
[16:21:50.817]                       }
[16:21:50.817]                       else if (inherits(cond, "warning")) {
[16:21:50.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.817]                         if (muffled) 
[16:21:50.817]                           invokeRestart("muffleWarning")
[16:21:50.817]                       }
[16:21:50.817]                       else if (inherits(cond, "condition")) {
[16:21:50.817]                         if (!is.null(pattern)) {
[16:21:50.817]                           computeRestarts <- base::computeRestarts
[16:21:50.817]                           grepl <- base::grepl
[16:21:50.817]                           restarts <- computeRestarts(cond)
[16:21:50.817]                           for (restart in restarts) {
[16:21:50.817]                             name <- restart$name
[16:21:50.817]                             if (is.null(name)) 
[16:21:50.817]                               next
[16:21:50.817]                             if (!grepl(pattern, name)) 
[16:21:50.817]                               next
[16:21:50.817]                             invokeRestart(restart)
[16:21:50.817]                             muffled <- TRUE
[16:21:50.817]                             break
[16:21:50.817]                           }
[16:21:50.817]                         }
[16:21:50.817]                       }
[16:21:50.817]                       invisible(muffled)
[16:21:50.817]                     }
[16:21:50.817]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.817]                   }
[16:21:50.817]                 }
[16:21:50.817]                 else {
[16:21:50.817]                   if (TRUE) {
[16:21:50.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.817]                     {
[16:21:50.817]                       inherits <- base::inherits
[16:21:50.817]                       invokeRestart <- base::invokeRestart
[16:21:50.817]                       is.null <- base::is.null
[16:21:50.817]                       muffled <- FALSE
[16:21:50.817]                       if (inherits(cond, "message")) {
[16:21:50.817]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.817]                         if (muffled) 
[16:21:50.817]                           invokeRestart("muffleMessage")
[16:21:50.817]                       }
[16:21:50.817]                       else if (inherits(cond, "warning")) {
[16:21:50.817]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.817]                         if (muffled) 
[16:21:50.817]                           invokeRestart("muffleWarning")
[16:21:50.817]                       }
[16:21:50.817]                       else if (inherits(cond, "condition")) {
[16:21:50.817]                         if (!is.null(pattern)) {
[16:21:50.817]                           computeRestarts <- base::computeRestarts
[16:21:50.817]                           grepl <- base::grepl
[16:21:50.817]                           restarts <- computeRestarts(cond)
[16:21:50.817]                           for (restart in restarts) {
[16:21:50.817]                             name <- restart$name
[16:21:50.817]                             if (is.null(name)) 
[16:21:50.817]                               next
[16:21:50.817]                             if (!grepl(pattern, name)) 
[16:21:50.817]                               next
[16:21:50.817]                             invokeRestart(restart)
[16:21:50.817]                             muffled <- TRUE
[16:21:50.817]                             break
[16:21:50.817]                           }
[16:21:50.817]                         }
[16:21:50.817]                       }
[16:21:50.817]                       invisible(muffled)
[16:21:50.817]                     }
[16:21:50.817]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.817]                   }
[16:21:50.817]                 }
[16:21:50.817]             }
[16:21:50.817]         }))
[16:21:50.817]     }, error = function(ex) {
[16:21:50.817]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.817]                 ...future.rng), started = ...future.startTime, 
[16:21:50.817]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.817]             version = "1.8"), class = "FutureResult")
[16:21:50.817]     }, finally = {
[16:21:50.817]         if (!identical(...future.workdir, getwd())) 
[16:21:50.817]             setwd(...future.workdir)
[16:21:50.817]         {
[16:21:50.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.817]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.817]             }
[16:21:50.817]             base::options(...future.oldOptions)
[16:21:50.817]             if (.Platform$OS.type == "windows") {
[16:21:50.817]                 old_names <- names(...future.oldEnvVars)
[16:21:50.817]                 envs <- base::Sys.getenv()
[16:21:50.817]                 names <- names(envs)
[16:21:50.817]                 common <- intersect(names, old_names)
[16:21:50.817]                 added <- setdiff(names, old_names)
[16:21:50.817]                 removed <- setdiff(old_names, names)
[16:21:50.817]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.817]                   envs[common]]
[16:21:50.817]                 NAMES <- toupper(changed)
[16:21:50.817]                 args <- list()
[16:21:50.817]                 for (kk in seq_along(NAMES)) {
[16:21:50.817]                   name <- changed[[kk]]
[16:21:50.817]                   NAME <- NAMES[[kk]]
[16:21:50.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.817]                     next
[16:21:50.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.817]                 }
[16:21:50.817]                 NAMES <- toupper(added)
[16:21:50.817]                 for (kk in seq_along(NAMES)) {
[16:21:50.817]                   name <- added[[kk]]
[16:21:50.817]                   NAME <- NAMES[[kk]]
[16:21:50.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.817]                     next
[16:21:50.817]                   args[[name]] <- ""
[16:21:50.817]                 }
[16:21:50.817]                 NAMES <- toupper(removed)
[16:21:50.817]                 for (kk in seq_along(NAMES)) {
[16:21:50.817]                   name <- removed[[kk]]
[16:21:50.817]                   NAME <- NAMES[[kk]]
[16:21:50.817]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.817]                     next
[16:21:50.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.817]                 }
[16:21:50.817]                 if (length(args) > 0) 
[16:21:50.817]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.817]             }
[16:21:50.817]             else {
[16:21:50.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.817]             }
[16:21:50.817]             {
[16:21:50.817]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.817]                   0L) {
[16:21:50.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.817]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.817]                   base::options(opts)
[16:21:50.817]                 }
[16:21:50.817]                 {
[16:21:50.817]                   {
[16:21:50.817]                     NULL
[16:21:50.817]                     RNGkind("Mersenne-Twister")
[16:21:50.817]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.817]                       inherits = FALSE)
[16:21:50.817]                   }
[16:21:50.817]                   options(future.plan = NULL)
[16:21:50.817]                   if (is.na(NA_character_)) 
[16:21:50.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.817]                     .init = FALSE)
[16:21:50.817]                 }
[16:21:50.817]             }
[16:21:50.817]         }
[16:21:50.817]     })
[16:21:50.817]     if (TRUE) {
[16:21:50.817]         base::sink(type = "output", split = FALSE)
[16:21:50.817]         if (TRUE) {
[16:21:50.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.817]         }
[16:21:50.817]         else {
[16:21:50.817]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.817]         }
[16:21:50.817]         base::close(...future.stdout)
[16:21:50.817]         ...future.stdout <- NULL
[16:21:50.817]     }
[16:21:50.817]     ...future.result$conditions <- ...future.conditions
[16:21:50.817]     ...future.result$finished <- base::Sys.time()
[16:21:50.817]     ...future.result
[16:21:50.817] }
[16:21:50.818] plan(): Setting new future strategy stack:
[16:21:50.818] List of future strategies:
[16:21:50.818] 1. sequential:
[16:21:50.818]    - args: function (..., envir = parent.frame())
[16:21:50.818]    - tweaked: FALSE
[16:21:50.818]    - call: NULL
[16:21:50.819] plan(): nbrOfWorkers() = 1
[16:21:50.820] plan(): Setting new future strategy stack:
[16:21:50.820] List of future strategies:
[16:21:50.820] 1. sequential:
[16:21:50.820]    - args: function (..., envir = parent.frame())
[16:21:50.820]    - tweaked: FALSE
[16:21:50.820]    - call: plan(strategy)
[16:21:50.820] plan(): nbrOfWorkers() = 1
[16:21:50.820] SequentialFuture started (and completed)
[16:21:50.820] - Launch lazy future ... done
[16:21:50.820] run() for ‘SequentialFuture’ ... done
[16:21:50.821] getGlobalsAndPackages() ...
[16:21:50.821] Searching for globals...
[16:21:50.822] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:21:50.822] Searching for globals ... DONE
[16:21:50.822] Resolving globals: FALSE
[16:21:50.822] 
[16:21:50.822] 
[16:21:50.822] getGlobalsAndPackages() ... DONE
[16:21:50.823] run() for ‘Future’ ...
[16:21:50.823] - state: ‘created’
[16:21:50.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:50.823] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:50.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:50.823]   - Field: ‘label’
[16:21:50.823]   - Field: ‘local’
[16:21:50.824]   - Field: ‘owner’
[16:21:50.824]   - Field: ‘envir’
[16:21:50.824]   - Field: ‘packages’
[16:21:50.824]   - Field: ‘gc’
[16:21:50.824]   - Field: ‘conditions’
[16:21:50.824]   - Field: ‘expr’
[16:21:50.824]   - Field: ‘uuid’
[16:21:50.824]   - Field: ‘seed’
[16:21:50.824]   - Field: ‘version’
[16:21:50.824]   - Field: ‘result’
[16:21:50.824]   - Field: ‘asynchronous’
[16:21:50.825]   - Field: ‘calls’
[16:21:50.825]   - Field: ‘globals’
[16:21:50.825]   - Field: ‘stdout’
[16:21:50.825]   - Field: ‘earlySignal’
[16:21:50.825]   - Field: ‘lazy’
[16:21:50.825]   - Field: ‘state’
[16:21:50.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:50.825] - Launch lazy future ...
[16:21:50.825] Packages needed by the future expression (n = 0): <none>
[16:21:50.825] Packages needed by future strategies (n = 0): <none>
[16:21:50.826] {
[16:21:50.826]     {
[16:21:50.826]         {
[16:21:50.826]             ...future.startTime <- base::Sys.time()
[16:21:50.826]             {
[16:21:50.826]                 {
[16:21:50.826]                   {
[16:21:50.826]                     base::local({
[16:21:50.826]                       has_future <- base::requireNamespace("future", 
[16:21:50.826]                         quietly = TRUE)
[16:21:50.826]                       if (has_future) {
[16:21:50.826]                         ns <- base::getNamespace("future")
[16:21:50.826]                         version <- ns[[".package"]][["version"]]
[16:21:50.826]                         if (is.null(version)) 
[16:21:50.826]                           version <- utils::packageVersion("future")
[16:21:50.826]                       }
[16:21:50.826]                       else {
[16:21:50.826]                         version <- NULL
[16:21:50.826]                       }
[16:21:50.826]                       if (!has_future || version < "1.8.0") {
[16:21:50.826]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:50.826]                           "", base::R.version$version.string), 
[16:21:50.826]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:50.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:50.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:50.826]                             "release", "version")], collapse = " "), 
[16:21:50.826]                           hostname = base::Sys.info()[["nodename"]])
[16:21:50.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:50.826]                           info)
[16:21:50.826]                         info <- base::paste(info, collapse = "; ")
[16:21:50.826]                         if (!has_future) {
[16:21:50.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:50.826]                             info)
[16:21:50.826]                         }
[16:21:50.826]                         else {
[16:21:50.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:50.826]                             info, version)
[16:21:50.826]                         }
[16:21:50.826]                         base::stop(msg)
[16:21:50.826]                       }
[16:21:50.826]                     })
[16:21:50.826]                   }
[16:21:50.826]                   ...future.strategy.old <- future::plan("list")
[16:21:50.826]                   options(future.plan = NULL)
[16:21:50.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:50.826]                 }
[16:21:50.826]                 ...future.workdir <- getwd()
[16:21:50.826]             }
[16:21:50.826]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:50.826]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:50.826]         }
[16:21:50.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:50.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:50.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:50.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:50.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:50.826]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:50.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:50.826]             base::names(...future.oldOptions))
[16:21:50.826]     }
[16:21:50.826]     if (FALSE) {
[16:21:50.826]     }
[16:21:50.826]     else {
[16:21:50.826]         if (TRUE) {
[16:21:50.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:50.826]                 open = "w")
[16:21:50.826]         }
[16:21:50.826]         else {
[16:21:50.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:50.826]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:50.826]         }
[16:21:50.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:50.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:50.826]             base::sink(type = "output", split = FALSE)
[16:21:50.826]             base::close(...future.stdout)
[16:21:50.826]         }, add = TRUE)
[16:21:50.826]     }
[16:21:50.826]     ...future.frame <- base::sys.nframe()
[16:21:50.826]     ...future.conditions <- base::list()
[16:21:50.826]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:50.826]     if (FALSE) {
[16:21:50.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:50.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:50.826]     }
[16:21:50.826]     ...future.result <- base::tryCatch({
[16:21:50.826]         base::withCallingHandlers({
[16:21:50.826]             ...future.value <- base::withVisible(base::local({
[16:21:50.826]                 Sys.sleep(0.5)
[16:21:50.826]                 2
[16:21:50.826]             }))
[16:21:50.826]             future::FutureResult(value = ...future.value$value, 
[16:21:50.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.826]                   ...future.rng), globalenv = if (FALSE) 
[16:21:50.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:50.826]                     ...future.globalenv.names))
[16:21:50.826]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:50.826]         }, condition = base::local({
[16:21:50.826]             c <- base::c
[16:21:50.826]             inherits <- base::inherits
[16:21:50.826]             invokeRestart <- base::invokeRestart
[16:21:50.826]             length <- base::length
[16:21:50.826]             list <- base::list
[16:21:50.826]             seq.int <- base::seq.int
[16:21:50.826]             signalCondition <- base::signalCondition
[16:21:50.826]             sys.calls <- base::sys.calls
[16:21:50.826]             `[[` <- base::`[[`
[16:21:50.826]             `+` <- base::`+`
[16:21:50.826]             `<<-` <- base::`<<-`
[16:21:50.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:50.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:50.826]                   3L)]
[16:21:50.826]             }
[16:21:50.826]             function(cond) {
[16:21:50.826]                 is_error <- inherits(cond, "error")
[16:21:50.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:50.826]                   NULL)
[16:21:50.826]                 if (is_error) {
[16:21:50.826]                   sessionInformation <- function() {
[16:21:50.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:50.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:50.826]                       search = base::search(), system = base::Sys.info())
[16:21:50.826]                   }
[16:21:50.826]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:50.826]                     cond$call), session = sessionInformation(), 
[16:21:50.826]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:50.826]                   signalCondition(cond)
[16:21:50.826]                 }
[16:21:50.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:50.826]                 "immediateCondition"))) {
[16:21:50.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:50.826]                   ...future.conditions[[length(...future.conditions) + 
[16:21:50.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:50.826]                   if (TRUE && !signal) {
[16:21:50.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.826]                     {
[16:21:50.826]                       inherits <- base::inherits
[16:21:50.826]                       invokeRestart <- base::invokeRestart
[16:21:50.826]                       is.null <- base::is.null
[16:21:50.826]                       muffled <- FALSE
[16:21:50.826]                       if (inherits(cond, "message")) {
[16:21:50.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.826]                         if (muffled) 
[16:21:50.826]                           invokeRestart("muffleMessage")
[16:21:50.826]                       }
[16:21:50.826]                       else if (inherits(cond, "warning")) {
[16:21:50.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.826]                         if (muffled) 
[16:21:50.826]                           invokeRestart("muffleWarning")
[16:21:50.826]                       }
[16:21:50.826]                       else if (inherits(cond, "condition")) {
[16:21:50.826]                         if (!is.null(pattern)) {
[16:21:50.826]                           computeRestarts <- base::computeRestarts
[16:21:50.826]                           grepl <- base::grepl
[16:21:50.826]                           restarts <- computeRestarts(cond)
[16:21:50.826]                           for (restart in restarts) {
[16:21:50.826]                             name <- restart$name
[16:21:50.826]                             if (is.null(name)) 
[16:21:50.826]                               next
[16:21:50.826]                             if (!grepl(pattern, name)) 
[16:21:50.826]                               next
[16:21:50.826]                             invokeRestart(restart)
[16:21:50.826]                             muffled <- TRUE
[16:21:50.826]                             break
[16:21:50.826]                           }
[16:21:50.826]                         }
[16:21:50.826]                       }
[16:21:50.826]                       invisible(muffled)
[16:21:50.826]                     }
[16:21:50.826]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.826]                   }
[16:21:50.826]                 }
[16:21:50.826]                 else {
[16:21:50.826]                   if (TRUE) {
[16:21:50.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:50.826]                     {
[16:21:50.826]                       inherits <- base::inherits
[16:21:50.826]                       invokeRestart <- base::invokeRestart
[16:21:50.826]                       is.null <- base::is.null
[16:21:50.826]                       muffled <- FALSE
[16:21:50.826]                       if (inherits(cond, "message")) {
[16:21:50.826]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:50.826]                         if (muffled) 
[16:21:50.826]                           invokeRestart("muffleMessage")
[16:21:50.826]                       }
[16:21:50.826]                       else if (inherits(cond, "warning")) {
[16:21:50.826]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:50.826]                         if (muffled) 
[16:21:50.826]                           invokeRestart("muffleWarning")
[16:21:50.826]                       }
[16:21:50.826]                       else if (inherits(cond, "condition")) {
[16:21:50.826]                         if (!is.null(pattern)) {
[16:21:50.826]                           computeRestarts <- base::computeRestarts
[16:21:50.826]                           grepl <- base::grepl
[16:21:50.826]                           restarts <- computeRestarts(cond)
[16:21:50.826]                           for (restart in restarts) {
[16:21:50.826]                             name <- restart$name
[16:21:50.826]                             if (is.null(name)) 
[16:21:50.826]                               next
[16:21:50.826]                             if (!grepl(pattern, name)) 
[16:21:50.826]                               next
[16:21:50.826]                             invokeRestart(restart)
[16:21:50.826]                             muffled <- TRUE
[16:21:50.826]                             break
[16:21:50.826]                           }
[16:21:50.826]                         }
[16:21:50.826]                       }
[16:21:50.826]                       invisible(muffled)
[16:21:50.826]                     }
[16:21:50.826]                     muffleCondition(cond, pattern = "^muffle")
[16:21:50.826]                   }
[16:21:50.826]                 }
[16:21:50.826]             }
[16:21:50.826]         }))
[16:21:50.826]     }, error = function(ex) {
[16:21:50.826]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:50.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:50.826]                 ...future.rng), started = ...future.startTime, 
[16:21:50.826]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:50.826]             version = "1.8"), class = "FutureResult")
[16:21:50.826]     }, finally = {
[16:21:50.826]         if (!identical(...future.workdir, getwd())) 
[16:21:50.826]             setwd(...future.workdir)
[16:21:50.826]         {
[16:21:50.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:50.826]                 ...future.oldOptions$nwarnings <- NULL
[16:21:50.826]             }
[16:21:50.826]             base::options(...future.oldOptions)
[16:21:50.826]             if (.Platform$OS.type == "windows") {
[16:21:50.826]                 old_names <- names(...future.oldEnvVars)
[16:21:50.826]                 envs <- base::Sys.getenv()
[16:21:50.826]                 names <- names(envs)
[16:21:50.826]                 common <- intersect(names, old_names)
[16:21:50.826]                 added <- setdiff(names, old_names)
[16:21:50.826]                 removed <- setdiff(old_names, names)
[16:21:50.826]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:50.826]                   envs[common]]
[16:21:50.826]                 NAMES <- toupper(changed)
[16:21:50.826]                 args <- list()
[16:21:50.826]                 for (kk in seq_along(NAMES)) {
[16:21:50.826]                   name <- changed[[kk]]
[16:21:50.826]                   NAME <- NAMES[[kk]]
[16:21:50.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.826]                     next
[16:21:50.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.826]                 }
[16:21:50.826]                 NAMES <- toupper(added)
[16:21:50.826]                 for (kk in seq_along(NAMES)) {
[16:21:50.826]                   name <- added[[kk]]
[16:21:50.826]                   NAME <- NAMES[[kk]]
[16:21:50.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.826]                     next
[16:21:50.826]                   args[[name]] <- ""
[16:21:50.826]                 }
[16:21:50.826]                 NAMES <- toupper(removed)
[16:21:50.826]                 for (kk in seq_along(NAMES)) {
[16:21:50.826]                   name <- removed[[kk]]
[16:21:50.826]                   NAME <- NAMES[[kk]]
[16:21:50.826]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:50.826]                     next
[16:21:50.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:50.826]                 }
[16:21:50.826]                 if (length(args) > 0) 
[16:21:50.826]                   base::do.call(base::Sys.setenv, args = args)
[16:21:50.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:50.826]             }
[16:21:50.826]             else {
[16:21:50.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:50.826]             }
[16:21:50.826]             {
[16:21:50.826]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:50.826]                   0L) {
[16:21:50.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:50.826]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:50.826]                   base::options(opts)
[16:21:50.826]                 }
[16:21:50.826]                 {
[16:21:50.826]                   {
[16:21:50.826]                     NULL
[16:21:50.826]                     RNGkind("Mersenne-Twister")
[16:21:50.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:50.826]                       inherits = FALSE)
[16:21:50.826]                   }
[16:21:50.826]                   options(future.plan = NULL)
[16:21:50.826]                   if (is.na(NA_character_)) 
[16:21:50.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:50.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:50.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:50.826]                     .init = FALSE)
[16:21:50.826]                 }
[16:21:50.826]             }
[16:21:50.826]         }
[16:21:50.826]     })
[16:21:50.826]     if (TRUE) {
[16:21:50.826]         base::sink(type = "output", split = FALSE)
[16:21:50.826]         if (TRUE) {
[16:21:50.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:50.826]         }
[16:21:50.826]         else {
[16:21:50.826]             ...future.result["stdout"] <- base::list(NULL)
[16:21:50.826]         }
[16:21:50.826]         base::close(...future.stdout)
[16:21:50.826]         ...future.stdout <- NULL
[16:21:50.826]     }
[16:21:50.826]     ...future.result$conditions <- ...future.conditions
[16:21:50.826]     ...future.result$finished <- base::Sys.time()
[16:21:50.826]     ...future.result
[16:21:50.826] }
[16:21:50.828] plan(): Setting new future strategy stack:
[16:21:50.828] List of future strategies:
[16:21:50.828] 1. sequential:
[16:21:50.828]    - args: function (..., envir = parent.frame())
[16:21:50.828]    - tweaked: FALSE
[16:21:50.828]    - call: NULL
[16:21:50.828] plan(): nbrOfWorkers() = 1
[16:21:51.330] plan(): Setting new future strategy stack:
[16:21:51.330] List of future strategies:
[16:21:51.330] 1. sequential:
[16:21:51.330]    - args: function (..., envir = parent.frame())
[16:21:51.330]    - tweaked: FALSE
[16:21:51.330]    - call: plan(strategy)
[16:21:51.330] plan(): nbrOfWorkers() = 1
[16:21:51.331] SequentialFuture started (and completed)
[16:21:51.331] - Launch lazy future ... done
[16:21:51.331] run() for ‘SequentialFuture’ ... done
[16:21:51.331] getGlobalsAndPackages() ...
[16:21:51.331] Searching for globals...
[16:21:51.332] - globals found: [1] ‘{’
[16:21:51.332] Searching for globals ... DONE
[16:21:51.332] Resolving globals: FALSE
[16:21:51.333] 
[16:21:51.333] 
[16:21:51.333] getGlobalsAndPackages() ... DONE
[16:21:51.333] run() for ‘Future’ ...
[16:21:51.333] - state: ‘created’
[16:21:51.333] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:21:51.334] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:21:51.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:21:51.334]   - Field: ‘label’
[16:21:51.334]   - Field: ‘local’
[16:21:51.334]   - Field: ‘owner’
[16:21:51.334]   - Field: ‘envir’
[16:21:51.334]   - Field: ‘packages’
[16:21:51.334]   - Field: ‘gc’
[16:21:51.334]   - Field: ‘conditions’
[16:21:51.334]   - Field: ‘expr’
[16:21:51.334]   - Field: ‘uuid’
[16:21:51.335]   - Field: ‘seed’
[16:21:51.335]   - Field: ‘version’
[16:21:51.335]   - Field: ‘result’
[16:21:51.335]   - Field: ‘asynchronous’
[16:21:51.335]   - Field: ‘calls’
[16:21:51.335]   - Field: ‘globals’
[16:21:51.335]   - Field: ‘stdout’
[16:21:51.335]   - Field: ‘earlySignal’
[16:21:51.335]   - Field: ‘lazy’
[16:21:51.335]   - Field: ‘state’
[16:21:51.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:21:51.336] - Launch lazy future ...
[16:21:51.336] Packages needed by the future expression (n = 0): <none>
[16:21:51.336] Packages needed by future strategies (n = 0): <none>
[16:21:51.336] {
[16:21:51.336]     {
[16:21:51.336]         {
[16:21:51.336]             ...future.startTime <- base::Sys.time()
[16:21:51.336]             {
[16:21:51.336]                 {
[16:21:51.336]                   {
[16:21:51.336]                     base::local({
[16:21:51.336]                       has_future <- base::requireNamespace("future", 
[16:21:51.336]                         quietly = TRUE)
[16:21:51.336]                       if (has_future) {
[16:21:51.336]                         ns <- base::getNamespace("future")
[16:21:51.336]                         version <- ns[[".package"]][["version"]]
[16:21:51.336]                         if (is.null(version)) 
[16:21:51.336]                           version <- utils::packageVersion("future")
[16:21:51.336]                       }
[16:21:51.336]                       else {
[16:21:51.336]                         version <- NULL
[16:21:51.336]                       }
[16:21:51.336]                       if (!has_future || version < "1.8.0") {
[16:21:51.336]                         info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.336]                           "", base::R.version$version.string), 
[16:21:51.336]                           platform = base::sprintf("%s (%s-bit)", 
[16:21:51.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.336]                             "release", "version")], collapse = " "), 
[16:21:51.336]                           hostname = base::Sys.info()[["nodename"]])
[16:21:51.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.336]                           info)
[16:21:51.336]                         info <- base::paste(info, collapse = "; ")
[16:21:51.336]                         if (!has_future) {
[16:21:51.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.336]                             info)
[16:21:51.336]                         }
[16:21:51.336]                         else {
[16:21:51.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.336]                             info, version)
[16:21:51.336]                         }
[16:21:51.336]                         base::stop(msg)
[16:21:51.336]                       }
[16:21:51.336]                     })
[16:21:51.336]                   }
[16:21:51.336]                   ...future.strategy.old <- future::plan("list")
[16:21:51.336]                   options(future.plan = NULL)
[16:21:51.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.336]                 }
[16:21:51.336]                 ...future.workdir <- getwd()
[16:21:51.336]             }
[16:21:51.336]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.336]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.336]         }
[16:21:51.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.336]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.336]             base::names(...future.oldOptions))
[16:21:51.336]     }
[16:21:51.336]     if (FALSE) {
[16:21:51.336]     }
[16:21:51.336]     else {
[16:21:51.336]         if (TRUE) {
[16:21:51.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.336]                 open = "w")
[16:21:51.336]         }
[16:21:51.336]         else {
[16:21:51.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.336]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.336]         }
[16:21:51.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.336]             base::sink(type = "output", split = FALSE)
[16:21:51.336]             base::close(...future.stdout)
[16:21:51.336]         }, add = TRUE)
[16:21:51.336]     }
[16:21:51.336]     ...future.frame <- base::sys.nframe()
[16:21:51.336]     ...future.conditions <- base::list()
[16:21:51.336]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.336]     if (FALSE) {
[16:21:51.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.336]     }
[16:21:51.336]     ...future.result <- base::tryCatch({
[16:21:51.336]         base::withCallingHandlers({
[16:21:51.336]             ...future.value <- base::withVisible(base::local({
[16:21:51.336]                 3
[16:21:51.336]             }))
[16:21:51.336]             future::FutureResult(value = ...future.value$value, 
[16:21:51.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.336]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.336]                     ...future.globalenv.names))
[16:21:51.336]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.336]         }, condition = base::local({
[16:21:51.336]             c <- base::c
[16:21:51.336]             inherits <- base::inherits
[16:21:51.336]             invokeRestart <- base::invokeRestart
[16:21:51.336]             length <- base::length
[16:21:51.336]             list <- base::list
[16:21:51.336]             seq.int <- base::seq.int
[16:21:51.336]             signalCondition <- base::signalCondition
[16:21:51.336]             sys.calls <- base::sys.calls
[16:21:51.336]             `[[` <- base::`[[`
[16:21:51.336]             `+` <- base::`+`
[16:21:51.336]             `<<-` <- base::`<<-`
[16:21:51.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.336]                   3L)]
[16:21:51.336]             }
[16:21:51.336]             function(cond) {
[16:21:51.336]                 is_error <- inherits(cond, "error")
[16:21:51.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.336]                   NULL)
[16:21:51.336]                 if (is_error) {
[16:21:51.336]                   sessionInformation <- function() {
[16:21:51.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.336]                       search = base::search(), system = base::Sys.info())
[16:21:51.336]                   }
[16:21:51.336]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.336]                     cond$call), session = sessionInformation(), 
[16:21:51.336]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.336]                   signalCondition(cond)
[16:21:51.336]                 }
[16:21:51.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.336]                 "immediateCondition"))) {
[16:21:51.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.336]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.336]                   if (TRUE && !signal) {
[16:21:51.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.336]                     {
[16:21:51.336]                       inherits <- base::inherits
[16:21:51.336]                       invokeRestart <- base::invokeRestart
[16:21:51.336]                       is.null <- base::is.null
[16:21:51.336]                       muffled <- FALSE
[16:21:51.336]                       if (inherits(cond, "message")) {
[16:21:51.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.336]                         if (muffled) 
[16:21:51.336]                           invokeRestart("muffleMessage")
[16:21:51.336]                       }
[16:21:51.336]                       else if (inherits(cond, "warning")) {
[16:21:51.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.336]                         if (muffled) 
[16:21:51.336]                           invokeRestart("muffleWarning")
[16:21:51.336]                       }
[16:21:51.336]                       else if (inherits(cond, "condition")) {
[16:21:51.336]                         if (!is.null(pattern)) {
[16:21:51.336]                           computeRestarts <- base::computeRestarts
[16:21:51.336]                           grepl <- base::grepl
[16:21:51.336]                           restarts <- computeRestarts(cond)
[16:21:51.336]                           for (restart in restarts) {
[16:21:51.336]                             name <- restart$name
[16:21:51.336]                             if (is.null(name)) 
[16:21:51.336]                               next
[16:21:51.336]                             if (!grepl(pattern, name)) 
[16:21:51.336]                               next
[16:21:51.336]                             invokeRestart(restart)
[16:21:51.336]                             muffled <- TRUE
[16:21:51.336]                             break
[16:21:51.336]                           }
[16:21:51.336]                         }
[16:21:51.336]                       }
[16:21:51.336]                       invisible(muffled)
[16:21:51.336]                     }
[16:21:51.336]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.336]                   }
[16:21:51.336]                 }
[16:21:51.336]                 else {
[16:21:51.336]                   if (TRUE) {
[16:21:51.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.336]                     {
[16:21:51.336]                       inherits <- base::inherits
[16:21:51.336]                       invokeRestart <- base::invokeRestart
[16:21:51.336]                       is.null <- base::is.null
[16:21:51.336]                       muffled <- FALSE
[16:21:51.336]                       if (inherits(cond, "message")) {
[16:21:51.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.336]                         if (muffled) 
[16:21:51.336]                           invokeRestart("muffleMessage")
[16:21:51.336]                       }
[16:21:51.336]                       else if (inherits(cond, "warning")) {
[16:21:51.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.336]                         if (muffled) 
[16:21:51.336]                           invokeRestart("muffleWarning")
[16:21:51.336]                       }
[16:21:51.336]                       else if (inherits(cond, "condition")) {
[16:21:51.336]                         if (!is.null(pattern)) {
[16:21:51.336]                           computeRestarts <- base::computeRestarts
[16:21:51.336]                           grepl <- base::grepl
[16:21:51.336]                           restarts <- computeRestarts(cond)
[16:21:51.336]                           for (restart in restarts) {
[16:21:51.336]                             name <- restart$name
[16:21:51.336]                             if (is.null(name)) 
[16:21:51.336]                               next
[16:21:51.336]                             if (!grepl(pattern, name)) 
[16:21:51.336]                               next
[16:21:51.336]                             invokeRestart(restart)
[16:21:51.336]                             muffled <- TRUE
[16:21:51.336]                             break
[16:21:51.336]                           }
[16:21:51.336]                         }
[16:21:51.336]                       }
[16:21:51.336]                       invisible(muffled)
[16:21:51.336]                     }
[16:21:51.336]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.336]                   }
[16:21:51.336]                 }
[16:21:51.336]             }
[16:21:51.336]         }))
[16:21:51.336]     }, error = function(ex) {
[16:21:51.336]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.336]                 ...future.rng), started = ...future.startTime, 
[16:21:51.336]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.336]             version = "1.8"), class = "FutureResult")
[16:21:51.336]     }, finally = {
[16:21:51.336]         if (!identical(...future.workdir, getwd())) 
[16:21:51.336]             setwd(...future.workdir)
[16:21:51.336]         {
[16:21:51.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.336]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.336]             }
[16:21:51.336]             base::options(...future.oldOptions)
[16:21:51.336]             if (.Platform$OS.type == "windows") {
[16:21:51.336]                 old_names <- names(...future.oldEnvVars)
[16:21:51.336]                 envs <- base::Sys.getenv()
[16:21:51.336]                 names <- names(envs)
[16:21:51.336]                 common <- intersect(names, old_names)
[16:21:51.336]                 added <- setdiff(names, old_names)
[16:21:51.336]                 removed <- setdiff(old_names, names)
[16:21:51.336]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.336]                   envs[common]]
[16:21:51.336]                 NAMES <- toupper(changed)
[16:21:51.336]                 args <- list()
[16:21:51.336]                 for (kk in seq_along(NAMES)) {
[16:21:51.336]                   name <- changed[[kk]]
[16:21:51.336]                   NAME <- NAMES[[kk]]
[16:21:51.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.336]                     next
[16:21:51.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.336]                 }
[16:21:51.336]                 NAMES <- toupper(added)
[16:21:51.336]                 for (kk in seq_along(NAMES)) {
[16:21:51.336]                   name <- added[[kk]]
[16:21:51.336]                   NAME <- NAMES[[kk]]
[16:21:51.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.336]                     next
[16:21:51.336]                   args[[name]] <- ""
[16:21:51.336]                 }
[16:21:51.336]                 NAMES <- toupper(removed)
[16:21:51.336]                 for (kk in seq_along(NAMES)) {
[16:21:51.336]                   name <- removed[[kk]]
[16:21:51.336]                   NAME <- NAMES[[kk]]
[16:21:51.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.336]                     next
[16:21:51.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.336]                 }
[16:21:51.336]                 if (length(args) > 0) 
[16:21:51.336]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.336]             }
[16:21:51.336]             else {
[16:21:51.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.336]             }
[16:21:51.336]             {
[16:21:51.336]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.336]                   0L) {
[16:21:51.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.336]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.336]                   base::options(opts)
[16:21:51.336]                 }
[16:21:51.336]                 {
[16:21:51.336]                   {
[16:21:51.336]                     NULL
[16:21:51.336]                     RNGkind("Mersenne-Twister")
[16:21:51.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:21:51.336]                       inherits = FALSE)
[16:21:51.336]                   }
[16:21:51.336]                   options(future.plan = NULL)
[16:21:51.336]                   if (is.na(NA_character_)) 
[16:21:51.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.336]                     .init = FALSE)
[16:21:51.336]                 }
[16:21:51.336]             }
[16:21:51.336]         }
[16:21:51.336]     })
[16:21:51.336]     if (TRUE) {
[16:21:51.336]         base::sink(type = "output", split = FALSE)
[16:21:51.336]         if (TRUE) {
[16:21:51.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.336]         }
[16:21:51.336]         else {
[16:21:51.336]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.336]         }
[16:21:51.336]         base::close(...future.stdout)
[16:21:51.336]         ...future.stdout <- NULL
[16:21:51.336]     }
[16:21:51.336]     ...future.result$conditions <- ...future.conditions
[16:21:51.336]     ...future.result$finished <- base::Sys.time()
[16:21:51.336]     ...future.result
[16:21:51.336] }
[16:21:51.338] plan(): Setting new future strategy stack:
[16:21:51.338] List of future strategies:
[16:21:51.338] 1. sequential:
[16:21:51.338]    - args: function (..., envir = parent.frame())
[16:21:51.338]    - tweaked: FALSE
[16:21:51.338]    - call: NULL
[16:21:51.339] plan(): nbrOfWorkers() = 1
[16:21:51.339] plan(): Setting new future strategy stack:
[16:21:51.340] List of future strategies:
[16:21:51.340] 1. sequential:
[16:21:51.340]    - args: function (..., envir = parent.frame())
[16:21:51.340]    - tweaked: FALSE
[16:21:51.340]    - call: plan(strategy)
[16:21:51.340] plan(): nbrOfWorkers() = 1
[16:21:51.340] SequentialFuture started (and completed)
[16:21:51.340] - Launch lazy future ... done
[16:21:51.340] run() for ‘SequentialFuture’ ... done
[16:21:51.341] resolve() on list environment ...
[16:21:51.341]  recursive: 0
[16:21:51.342]  length: 4
[16:21:51.342]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:51.342] resolved() for ‘SequentialFuture’ ...
[16:21:51.342] - state: ‘finished’
[16:21:51.342] - run: TRUE
[16:21:51.342] - result: ‘FutureResult’
[16:21:51.342] resolved() for ‘SequentialFuture’ ... done
[16:21:51.342] Future #1
[16:21:51.343]  length: 3 (resolved future 1)
[16:21:51.343] resolved() for ‘SequentialFuture’ ...
[16:21:51.343] - state: ‘finished’
[16:21:51.343] - run: TRUE
[16:21:51.343] - result: ‘FutureResult’
[16:21:51.343] resolved() for ‘SequentialFuture’ ... done
[16:21:51.343] Future #2
[16:21:51.346]  length: 2 (resolved future 2)
[16:21:51.346] resolved() for ‘SequentialFuture’ ...
[16:21:51.346] - state: ‘finished’
[16:21:51.346] - run: TRUE
[16:21:51.346] - result: ‘FutureResult’
[16:21:51.346] resolved() for ‘SequentialFuture’ ... done
[16:21:51.346] Future #3
[16:21:51.346]  length: 1 (resolved future 3)
[16:21:51.346]  length: 0 (resolved future 4)
[16:21:51.346] resolve() on list environment ... DONE
[16:21:51.347] resolved() for ‘SequentialFuture’ ...
[16:21:51.347] - state: ‘finished’
[16:21:51.347] - run: TRUE
[16:21:51.347] - result: ‘FutureResult’
[16:21:51.347] resolved() for ‘SequentialFuture’ ... done
[16:21:51.347] resolve() on list environment ...
[16:21:51.347]  recursive: 0
[16:21:51.348]  length: 4
[16:21:51.348]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:51.348] resolved() for ‘SequentialFuture’ ...
[16:21:51.348] - state: ‘finished’
[16:21:51.349] - run: TRUE
[16:21:51.349] - result: ‘FutureResult’
[16:21:51.349] resolved() for ‘SequentialFuture’ ... done
[16:21:51.349] Future #1
[16:21:51.349]  length: 3 (resolved future 1)
[16:21:51.349] resolved() for ‘SequentialFuture’ ...
[16:21:51.349] - state: ‘finished’
[16:21:51.349] - run: TRUE
[16:21:51.349] - result: ‘FutureResult’
[16:21:51.349] resolved() for ‘SequentialFuture’ ... done
[16:21:51.350] Future #2
[16:21:51.350]  length: 2 (resolved future 2)
[16:21:51.350] resolved() for ‘SequentialFuture’ ...
[16:21:51.350] - state: ‘finished’
[16:21:51.350] - run: TRUE
[16:21:51.350] - result: ‘FutureResult’
[16:21:51.350] resolved() for ‘SequentialFuture’ ... done
[16:21:51.350] Future #3
[16:21:51.350]  length: 1 (resolved future 3)
[16:21:51.350]  length: 0 (resolved future 4)
[16:21:51.351] resolve() on list environment ... DONE
[16:21:51.351] resolve() on list environment ...
[16:21:51.351]  recursive: 0
[16:21:51.352]  length: 4
[16:21:51.352]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:51.352] resolved() for ‘SequentialFuture’ ...
[16:21:51.352] - state: ‘finished’
[16:21:51.352] - run: TRUE
[16:21:51.352] - result: ‘FutureResult’
[16:21:51.352] resolved() for ‘SequentialFuture’ ... done
[16:21:51.353] Future #1
[16:21:51.353]  length: 3 (resolved future 1)
[16:21:51.353] resolved() for ‘SequentialFuture’ ...
[16:21:51.353] - state: ‘finished’
[16:21:51.353] - run: TRUE
[16:21:51.353] - result: ‘FutureResult’
[16:21:51.353] resolved() for ‘SequentialFuture’ ... done
[16:21:51.353] Future #2
[16:21:51.353]  length: 2 (resolved future 2)
[16:21:51.353] resolved() for ‘SequentialFuture’ ...
[16:21:51.354] - state: ‘finished’
[16:21:51.354] - run: TRUE
[16:21:51.354] - result: ‘FutureResult’
[16:21:51.354] resolved() for ‘SequentialFuture’ ... done
[16:21:51.354] Future #3
[16:21:51.354]  length: 1 (resolved future 3)
[16:21:51.354]  length: 0 (resolved future 4)
[16:21:51.354] resolve() on list environment ... DONE
[16:21:51.355] resolve() on list environment ...
[16:21:51.355]  recursive: 0
[16:21:51.355]  length: 4
[16:21:51.355]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:51.356] resolved() for ‘SequentialFuture’ ...
[16:21:51.356] - state: ‘finished’
[16:21:51.356] - run: TRUE
[16:21:51.356] - result: ‘FutureResult’
[16:21:51.356] resolved() for ‘SequentialFuture’ ... done
[16:21:51.356] Future #1
[16:21:51.356]  length: 3 (resolved future 1)
[16:21:51.356] resolved() for ‘SequentialFuture’ ...
[16:21:51.356] - state: ‘finished’
[16:21:51.356] - run: TRUE
[16:21:51.357] - result: ‘FutureResult’
[16:21:51.357] resolved() for ‘SequentialFuture’ ... done
[16:21:51.357] Future #2
[16:21:51.357]  length: 2 (resolved future 2)
[16:21:51.357] resolved() for ‘SequentialFuture’ ...
[16:21:51.357] - state: ‘finished’
[16:21:51.357] - run: TRUE
[16:21:51.357] - result: ‘FutureResult’
[16:21:51.357] resolved() for ‘SequentialFuture’ ... done
[16:21:51.357] Future #3
[16:21:51.358]  length: 1 (resolved future 3)
[16:21:51.358]  length: 0 (resolved future 4)
[16:21:51.358] resolve() on list environment ... DONE
[16:21:51.358] resolve() on list environment ...
[16:21:51.358]  recursive: 0
[16:21:51.359]  length: 4
[16:21:51.359]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:51.359] resolved() for ‘SequentialFuture’ ...
[16:21:51.359] - state: ‘finished’
[16:21:51.359] - run: TRUE
[16:21:51.359] - result: ‘FutureResult’
[16:21:51.359] resolved() for ‘SequentialFuture’ ... done
[16:21:51.360] Future #1
[16:21:51.360]  length: 3 (resolved future 1)
[16:21:51.360] resolved() for ‘SequentialFuture’ ...
[16:21:51.360] - state: ‘finished’
[16:21:51.360] - run: TRUE
[16:21:51.360] - result: ‘FutureResult’
[16:21:51.360] resolved() for ‘SequentialFuture’ ... done
[16:21:51.360] Future #2
[16:21:51.360]  length: 2 (resolved future 2)
[16:21:51.361] resolved() for ‘SequentialFuture’ ...
[16:21:51.361] - state: ‘finished’
[16:21:51.361] - run: TRUE
[16:21:51.361] - result: ‘FutureResult’
[16:21:51.361] resolved() for ‘SequentialFuture’ ... done
[16:21:51.361] Future #3
[16:21:51.361]  length: 1 (resolved future 3)
[16:21:51.361]  length: 0 (resolved future 4)
[16:21:51.361] resolve() on list environment ... DONE
[16:21:51.362] resolve() on list environment ...
[16:21:51.362]  recursive: 99
[16:21:51.363]  length: 4
[16:21:51.363]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:51.363] resolved() for ‘SequentialFuture’ ...
[16:21:51.363] - state: ‘finished’
[16:21:51.363] - run: TRUE
[16:21:51.363] - result: ‘FutureResult’
[16:21:51.363] resolved() for ‘SequentialFuture’ ... done
[16:21:51.363] Future #1
[16:21:51.363] resolved() for ‘SequentialFuture’ ...
[16:21:51.363] - state: ‘finished’
[16:21:51.364] - run: TRUE
[16:21:51.364] - result: ‘FutureResult’
[16:21:51.364] resolved() for ‘SequentialFuture’ ... done
[16:21:51.364] A SequentialFuture was resolved
[16:21:51.364]  length: 3 (resolved future 1)
[16:21:51.364] resolved() for ‘SequentialFuture’ ...
[16:21:51.364] - state: ‘finished’
[16:21:51.364] - run: TRUE
[16:21:51.364] - result: ‘FutureResult’
[16:21:51.364] resolved() for ‘SequentialFuture’ ... done
[16:21:51.365] Future #2
[16:21:51.365] resolved() for ‘SequentialFuture’ ...
[16:21:51.365] - state: ‘finished’
[16:21:51.365] - run: TRUE
[16:21:51.393] - result: ‘FutureResult’
[16:21:51.393] resolved() for ‘SequentialFuture’ ... done
[16:21:51.393] A SequentialFuture was resolved
[16:21:51.394]  length: 2 (resolved future 2)
[16:21:51.394] resolved() for ‘SequentialFuture’ ...
[16:21:51.394] - state: ‘finished’
[16:21:51.394] - run: TRUE
[16:21:51.394] - result: ‘FutureResult’
[16:21:51.394] resolved() for ‘SequentialFuture’ ... done
[16:21:51.394] Future #3
[16:21:51.395] resolved() for ‘SequentialFuture’ ...
[16:21:51.395] - state: ‘finished’
[16:21:51.395] - run: TRUE
[16:21:51.395] - result: ‘FutureResult’
[16:21:51.395] resolved() for ‘SequentialFuture’ ... done
[16:21:51.395] A SequentialFuture was resolved
[16:21:51.395]  length: 1 (resolved future 3)
[16:21:51.395]  length: 0 (resolved future 4)
[16:21:51.395] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[16:21:51.396] plan(): Setting new future strategy stack:
[16:21:51.396] List of future strategies:
[16:21:51.396] 1. multicore:
[16:21:51.396]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.396]    - tweaked: FALSE
[16:21:51.396]    - call: plan(strategy)
[16:21:51.400] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[16:21:51.400] resolve() on list ...
[16:21:51.401]  recursive: 0
[16:21:51.401]  length: 2
[16:21:51.401]  elements: ‘a’, ‘b’
[16:21:51.401]  length: 1 (resolved future 1)
[16:21:51.401]  length: 0 (resolved future 2)
[16:21:51.401] resolve() on list ... DONE
[16:21:51.401] getGlobalsAndPackages() ...
[16:21:51.401] Searching for globals...
[16:21:51.402] 
[16:21:51.402] Searching for globals ... DONE
[16:21:51.402] - globals: [0] <none>
[16:21:51.402] getGlobalsAndPackages() ... DONE
[16:21:51.402] run() for ‘Future’ ...
[16:21:51.402] - state: ‘created’
[16:21:51.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.406]   - Field: ‘label’
[16:21:51.406]   - Field: ‘local’
[16:21:51.406]   - Field: ‘owner’
[16:21:51.406]   - Field: ‘envir’
[16:21:51.407]   - Field: ‘workers’
[16:21:51.407]   - Field: ‘packages’
[16:21:51.407]   - Field: ‘gc’
[16:21:51.407]   - Field: ‘job’
[16:21:51.407]   - Field: ‘conditions’
[16:21:51.407]   - Field: ‘expr’
[16:21:51.407]   - Field: ‘uuid’
[16:21:51.407]   - Field: ‘seed’
[16:21:51.407]   - Field: ‘version’
[16:21:51.407]   - Field: ‘result’
[16:21:51.407]   - Field: ‘asynchronous’
[16:21:51.408]   - Field: ‘calls’
[16:21:51.408]   - Field: ‘globals’
[16:21:51.408]   - Field: ‘stdout’
[16:21:51.408]   - Field: ‘earlySignal’
[16:21:51.408]   - Field: ‘lazy’
[16:21:51.408]   - Field: ‘state’
[16:21:51.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.408] - Launch lazy future ...
[16:21:51.409] Packages needed by the future expression (n = 0): <none>
[16:21:51.409] Packages needed by future strategies (n = 0): <none>
[16:21:51.410] {
[16:21:51.410]     {
[16:21:51.410]         {
[16:21:51.410]             ...future.startTime <- base::Sys.time()
[16:21:51.410]             {
[16:21:51.410]                 {
[16:21:51.410]                   {
[16:21:51.410]                     {
[16:21:51.410]                       base::local({
[16:21:51.410]                         has_future <- base::requireNamespace("future", 
[16:21:51.410]                           quietly = TRUE)
[16:21:51.410]                         if (has_future) {
[16:21:51.410]                           ns <- base::getNamespace("future")
[16:21:51.410]                           version <- ns[[".package"]][["version"]]
[16:21:51.410]                           if (is.null(version)) 
[16:21:51.410]                             version <- utils::packageVersion("future")
[16:21:51.410]                         }
[16:21:51.410]                         else {
[16:21:51.410]                           version <- NULL
[16:21:51.410]                         }
[16:21:51.410]                         if (!has_future || version < "1.8.0") {
[16:21:51.410]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.410]                             "", base::R.version$version.string), 
[16:21:51.410]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.410]                               "release", "version")], collapse = " "), 
[16:21:51.410]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.410]                             info)
[16:21:51.410]                           info <- base::paste(info, collapse = "; ")
[16:21:51.410]                           if (!has_future) {
[16:21:51.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.410]                               info)
[16:21:51.410]                           }
[16:21:51.410]                           else {
[16:21:51.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.410]                               info, version)
[16:21:51.410]                           }
[16:21:51.410]                           base::stop(msg)
[16:21:51.410]                         }
[16:21:51.410]                       })
[16:21:51.410]                     }
[16:21:51.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.410]                     base::options(mc.cores = 1L)
[16:21:51.410]                   }
[16:21:51.410]                   ...future.strategy.old <- future::plan("list")
[16:21:51.410]                   options(future.plan = NULL)
[16:21:51.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.410]                 }
[16:21:51.410]                 ...future.workdir <- getwd()
[16:21:51.410]             }
[16:21:51.410]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.410]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.410]         }
[16:21:51.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.410]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.410]             base::names(...future.oldOptions))
[16:21:51.410]     }
[16:21:51.410]     if (FALSE) {
[16:21:51.410]     }
[16:21:51.410]     else {
[16:21:51.410]         if (TRUE) {
[16:21:51.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.410]                 open = "w")
[16:21:51.410]         }
[16:21:51.410]         else {
[16:21:51.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.410]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.410]         }
[16:21:51.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.410]             base::sink(type = "output", split = FALSE)
[16:21:51.410]             base::close(...future.stdout)
[16:21:51.410]         }, add = TRUE)
[16:21:51.410]     }
[16:21:51.410]     ...future.frame <- base::sys.nframe()
[16:21:51.410]     ...future.conditions <- base::list()
[16:21:51.410]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.410]     if (FALSE) {
[16:21:51.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.410]     }
[16:21:51.410]     ...future.result <- base::tryCatch({
[16:21:51.410]         base::withCallingHandlers({
[16:21:51.410]             ...future.value <- base::withVisible(base::local({
[16:21:51.410]                 withCallingHandlers({
[16:21:51.410]                   1
[16:21:51.410]                 }, immediateCondition = function(cond) {
[16:21:51.410]                   save_rds <- function (object, pathname, ...) 
[16:21:51.410]                   {
[16:21:51.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.410]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.410]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.410]                         fi_tmp[["mtime"]])
[16:21:51.410]                     }
[16:21:51.410]                     tryCatch({
[16:21:51.410]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.410]                     }, error = function(ex) {
[16:21:51.410]                       msg <- conditionMessage(ex)
[16:21:51.410]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.410]                         fi_tmp[["mtime"]], msg)
[16:21:51.410]                       ex$message <- msg
[16:21:51.410]                       stop(ex)
[16:21:51.410]                     })
[16:21:51.410]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.410]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.410]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.410]                       fi <- file.info(pathname)
[16:21:51.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.410]                         fi[["size"]], fi[["mtime"]])
[16:21:51.410]                       stop(msg)
[16:21:51.410]                     }
[16:21:51.410]                     invisible(pathname)
[16:21:51.410]                   }
[16:21:51.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.410]                     rootPath = tempdir()) 
[16:21:51.410]                   {
[16:21:51.410]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.410]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.410]                       tmpdir = path, fileext = ".rds")
[16:21:51.410]                     save_rds(obj, file)
[16:21:51.410]                   }
[16:21:51.410]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.410]                   {
[16:21:51.410]                     inherits <- base::inherits
[16:21:51.410]                     invokeRestart <- base::invokeRestart
[16:21:51.410]                     is.null <- base::is.null
[16:21:51.410]                     muffled <- FALSE
[16:21:51.410]                     if (inherits(cond, "message")) {
[16:21:51.410]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.410]                       if (muffled) 
[16:21:51.410]                         invokeRestart("muffleMessage")
[16:21:51.410]                     }
[16:21:51.410]                     else if (inherits(cond, "warning")) {
[16:21:51.410]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.410]                       if (muffled) 
[16:21:51.410]                         invokeRestart("muffleWarning")
[16:21:51.410]                     }
[16:21:51.410]                     else if (inherits(cond, "condition")) {
[16:21:51.410]                       if (!is.null(pattern)) {
[16:21:51.410]                         computeRestarts <- base::computeRestarts
[16:21:51.410]                         grepl <- base::grepl
[16:21:51.410]                         restarts <- computeRestarts(cond)
[16:21:51.410]                         for (restart in restarts) {
[16:21:51.410]                           name <- restart$name
[16:21:51.410]                           if (is.null(name)) 
[16:21:51.410]                             next
[16:21:51.410]                           if (!grepl(pattern, name)) 
[16:21:51.410]                             next
[16:21:51.410]                           invokeRestart(restart)
[16:21:51.410]                           muffled <- TRUE
[16:21:51.410]                           break
[16:21:51.410]                         }
[16:21:51.410]                       }
[16:21:51.410]                     }
[16:21:51.410]                     invisible(muffled)
[16:21:51.410]                   }
[16:21:51.410]                   muffleCondition(cond)
[16:21:51.410]                 })
[16:21:51.410]             }))
[16:21:51.410]             future::FutureResult(value = ...future.value$value, 
[16:21:51.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.410]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.410]                     ...future.globalenv.names))
[16:21:51.410]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.410]         }, condition = base::local({
[16:21:51.410]             c <- base::c
[16:21:51.410]             inherits <- base::inherits
[16:21:51.410]             invokeRestart <- base::invokeRestart
[16:21:51.410]             length <- base::length
[16:21:51.410]             list <- base::list
[16:21:51.410]             seq.int <- base::seq.int
[16:21:51.410]             signalCondition <- base::signalCondition
[16:21:51.410]             sys.calls <- base::sys.calls
[16:21:51.410]             `[[` <- base::`[[`
[16:21:51.410]             `+` <- base::`+`
[16:21:51.410]             `<<-` <- base::`<<-`
[16:21:51.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.410]                   3L)]
[16:21:51.410]             }
[16:21:51.410]             function(cond) {
[16:21:51.410]                 is_error <- inherits(cond, "error")
[16:21:51.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.410]                   NULL)
[16:21:51.410]                 if (is_error) {
[16:21:51.410]                   sessionInformation <- function() {
[16:21:51.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.410]                       search = base::search(), system = base::Sys.info())
[16:21:51.410]                   }
[16:21:51.410]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.410]                     cond$call), session = sessionInformation(), 
[16:21:51.410]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.410]                   signalCondition(cond)
[16:21:51.410]                 }
[16:21:51.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.410]                 "immediateCondition"))) {
[16:21:51.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.410]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.410]                   if (TRUE && !signal) {
[16:21:51.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.410]                     {
[16:21:51.410]                       inherits <- base::inherits
[16:21:51.410]                       invokeRestart <- base::invokeRestart
[16:21:51.410]                       is.null <- base::is.null
[16:21:51.410]                       muffled <- FALSE
[16:21:51.410]                       if (inherits(cond, "message")) {
[16:21:51.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.410]                         if (muffled) 
[16:21:51.410]                           invokeRestart("muffleMessage")
[16:21:51.410]                       }
[16:21:51.410]                       else if (inherits(cond, "warning")) {
[16:21:51.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.410]                         if (muffled) 
[16:21:51.410]                           invokeRestart("muffleWarning")
[16:21:51.410]                       }
[16:21:51.410]                       else if (inherits(cond, "condition")) {
[16:21:51.410]                         if (!is.null(pattern)) {
[16:21:51.410]                           computeRestarts <- base::computeRestarts
[16:21:51.410]                           grepl <- base::grepl
[16:21:51.410]                           restarts <- computeRestarts(cond)
[16:21:51.410]                           for (restart in restarts) {
[16:21:51.410]                             name <- restart$name
[16:21:51.410]                             if (is.null(name)) 
[16:21:51.410]                               next
[16:21:51.410]                             if (!grepl(pattern, name)) 
[16:21:51.410]                               next
[16:21:51.410]                             invokeRestart(restart)
[16:21:51.410]                             muffled <- TRUE
[16:21:51.410]                             break
[16:21:51.410]                           }
[16:21:51.410]                         }
[16:21:51.410]                       }
[16:21:51.410]                       invisible(muffled)
[16:21:51.410]                     }
[16:21:51.410]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.410]                   }
[16:21:51.410]                 }
[16:21:51.410]                 else {
[16:21:51.410]                   if (TRUE) {
[16:21:51.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.410]                     {
[16:21:51.410]                       inherits <- base::inherits
[16:21:51.410]                       invokeRestart <- base::invokeRestart
[16:21:51.410]                       is.null <- base::is.null
[16:21:51.410]                       muffled <- FALSE
[16:21:51.410]                       if (inherits(cond, "message")) {
[16:21:51.410]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.410]                         if (muffled) 
[16:21:51.410]                           invokeRestart("muffleMessage")
[16:21:51.410]                       }
[16:21:51.410]                       else if (inherits(cond, "warning")) {
[16:21:51.410]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.410]                         if (muffled) 
[16:21:51.410]                           invokeRestart("muffleWarning")
[16:21:51.410]                       }
[16:21:51.410]                       else if (inherits(cond, "condition")) {
[16:21:51.410]                         if (!is.null(pattern)) {
[16:21:51.410]                           computeRestarts <- base::computeRestarts
[16:21:51.410]                           grepl <- base::grepl
[16:21:51.410]                           restarts <- computeRestarts(cond)
[16:21:51.410]                           for (restart in restarts) {
[16:21:51.410]                             name <- restart$name
[16:21:51.410]                             if (is.null(name)) 
[16:21:51.410]                               next
[16:21:51.410]                             if (!grepl(pattern, name)) 
[16:21:51.410]                               next
[16:21:51.410]                             invokeRestart(restart)
[16:21:51.410]                             muffled <- TRUE
[16:21:51.410]                             break
[16:21:51.410]                           }
[16:21:51.410]                         }
[16:21:51.410]                       }
[16:21:51.410]                       invisible(muffled)
[16:21:51.410]                     }
[16:21:51.410]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.410]                   }
[16:21:51.410]                 }
[16:21:51.410]             }
[16:21:51.410]         }))
[16:21:51.410]     }, error = function(ex) {
[16:21:51.410]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.410]                 ...future.rng), started = ...future.startTime, 
[16:21:51.410]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.410]             version = "1.8"), class = "FutureResult")
[16:21:51.410]     }, finally = {
[16:21:51.410]         if (!identical(...future.workdir, getwd())) 
[16:21:51.410]             setwd(...future.workdir)
[16:21:51.410]         {
[16:21:51.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.410]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.410]             }
[16:21:51.410]             base::options(...future.oldOptions)
[16:21:51.410]             if (.Platform$OS.type == "windows") {
[16:21:51.410]                 old_names <- names(...future.oldEnvVars)
[16:21:51.410]                 envs <- base::Sys.getenv()
[16:21:51.410]                 names <- names(envs)
[16:21:51.410]                 common <- intersect(names, old_names)
[16:21:51.410]                 added <- setdiff(names, old_names)
[16:21:51.410]                 removed <- setdiff(old_names, names)
[16:21:51.410]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.410]                   envs[common]]
[16:21:51.410]                 NAMES <- toupper(changed)
[16:21:51.410]                 args <- list()
[16:21:51.410]                 for (kk in seq_along(NAMES)) {
[16:21:51.410]                   name <- changed[[kk]]
[16:21:51.410]                   NAME <- NAMES[[kk]]
[16:21:51.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.410]                     next
[16:21:51.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.410]                 }
[16:21:51.410]                 NAMES <- toupper(added)
[16:21:51.410]                 for (kk in seq_along(NAMES)) {
[16:21:51.410]                   name <- added[[kk]]
[16:21:51.410]                   NAME <- NAMES[[kk]]
[16:21:51.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.410]                     next
[16:21:51.410]                   args[[name]] <- ""
[16:21:51.410]                 }
[16:21:51.410]                 NAMES <- toupper(removed)
[16:21:51.410]                 for (kk in seq_along(NAMES)) {
[16:21:51.410]                   name <- removed[[kk]]
[16:21:51.410]                   NAME <- NAMES[[kk]]
[16:21:51.410]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.410]                     next
[16:21:51.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.410]                 }
[16:21:51.410]                 if (length(args) > 0) 
[16:21:51.410]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.410]             }
[16:21:51.410]             else {
[16:21:51.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.410]             }
[16:21:51.410]             {
[16:21:51.410]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.410]                   0L) {
[16:21:51.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.410]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.410]                   base::options(opts)
[16:21:51.410]                 }
[16:21:51.410]                 {
[16:21:51.410]                   {
[16:21:51.410]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.410]                     NULL
[16:21:51.410]                   }
[16:21:51.410]                   options(future.plan = NULL)
[16:21:51.410]                   if (is.na(NA_character_)) 
[16:21:51.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.410]                     .init = FALSE)
[16:21:51.410]                 }
[16:21:51.410]             }
[16:21:51.410]         }
[16:21:51.410]     })
[16:21:51.410]     if (TRUE) {
[16:21:51.410]         base::sink(type = "output", split = FALSE)
[16:21:51.410]         if (TRUE) {
[16:21:51.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.410]         }
[16:21:51.410]         else {
[16:21:51.410]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.410]         }
[16:21:51.410]         base::close(...future.stdout)
[16:21:51.410]         ...future.stdout <- NULL
[16:21:51.410]     }
[16:21:51.410]     ...future.result$conditions <- ...future.conditions
[16:21:51.410]     ...future.result$finished <- base::Sys.time()
[16:21:51.410]     ...future.result
[16:21:51.410] }
[16:21:51.412] requestCore(): workers = 2
[16:21:51.415] MulticoreFuture started
[16:21:51.416] - Launch lazy future ... done
[16:21:51.416] plan(): Setting new future strategy stack:
[16:21:51.416] run() for ‘MulticoreFuture’ ... done
[16:21:51.416] getGlobalsAndPackages() ...
[16:21:51.417] Searching for globals...
[16:21:51.416] List of future strategies:
[16:21:51.416] 1. sequential:
[16:21:51.416]    - args: function (..., envir = parent.frame())
[16:21:51.416]    - tweaked: FALSE
[16:21:51.416]    - call: NULL
[16:21:51.417] plan(): nbrOfWorkers() = 1
[16:21:51.418] 
[16:21:51.418] Searching for globals ... DONE
[16:21:51.418] - globals: [0] <none>
[16:21:51.418] getGlobalsAndPackages() ... DONE
[16:21:51.419] run() for ‘Future’ ...
[16:21:51.419] plan(): Setting new future strategy stack:
[16:21:51.419] - state: ‘created’
[16:21:51.420] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.419] List of future strategies:
[16:21:51.419] 1. multicore:
[16:21:51.419]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.419]    - tweaked: FALSE
[16:21:51.419]    - call: plan(strategy)
[16:21:51.425] plan(): nbrOfWorkers() = 2
[16:21:51.425] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.426]   - Field: ‘label’
[16:21:51.426]   - Field: ‘local’
[16:21:51.426]   - Field: ‘owner’
[16:21:51.426]   - Field: ‘envir’
[16:21:51.426]   - Field: ‘workers’
[16:21:51.427]   - Field: ‘packages’
[16:21:51.427]   - Field: ‘gc’
[16:21:51.427]   - Field: ‘job’
[16:21:51.427]   - Field: ‘conditions’
[16:21:51.427]   - Field: ‘expr’
[16:21:51.427]   - Field: ‘uuid’
[16:21:51.427]   - Field: ‘seed’
[16:21:51.428]   - Field: ‘version’
[16:21:51.428]   - Field: ‘result’
[16:21:51.428]   - Field: ‘asynchronous’
[16:21:51.428]   - Field: ‘calls’
[16:21:51.428]   - Field: ‘globals’
[16:21:51.428]   - Field: ‘stdout’
[16:21:51.429]   - Field: ‘earlySignal’
[16:21:51.429]   - Field: ‘lazy’
[16:21:51.429]   - Field: ‘state’
[16:21:51.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.429] - Launch lazy future ...
[16:21:51.430] Packages needed by the future expression (n = 0): <none>
[16:21:51.430] Packages needed by future strategies (n = 0): <none>
[16:21:51.431] {
[16:21:51.431]     {
[16:21:51.431]         {
[16:21:51.431]             ...future.startTime <- base::Sys.time()
[16:21:51.431]             {
[16:21:51.431]                 {
[16:21:51.431]                   {
[16:21:51.431]                     {
[16:21:51.431]                       base::local({
[16:21:51.431]                         has_future <- base::requireNamespace("future", 
[16:21:51.431]                           quietly = TRUE)
[16:21:51.431]                         if (has_future) {
[16:21:51.431]                           ns <- base::getNamespace("future")
[16:21:51.431]                           version <- ns[[".package"]][["version"]]
[16:21:51.431]                           if (is.null(version)) 
[16:21:51.431]                             version <- utils::packageVersion("future")
[16:21:51.431]                         }
[16:21:51.431]                         else {
[16:21:51.431]                           version <- NULL
[16:21:51.431]                         }
[16:21:51.431]                         if (!has_future || version < "1.8.0") {
[16:21:51.431]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.431]                             "", base::R.version$version.string), 
[16:21:51.431]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.431]                               "release", "version")], collapse = " "), 
[16:21:51.431]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.431]                             info)
[16:21:51.431]                           info <- base::paste(info, collapse = "; ")
[16:21:51.431]                           if (!has_future) {
[16:21:51.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.431]                               info)
[16:21:51.431]                           }
[16:21:51.431]                           else {
[16:21:51.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.431]                               info, version)
[16:21:51.431]                           }
[16:21:51.431]                           base::stop(msg)
[16:21:51.431]                         }
[16:21:51.431]                       })
[16:21:51.431]                     }
[16:21:51.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.431]                     base::options(mc.cores = 1L)
[16:21:51.431]                   }
[16:21:51.431]                   ...future.strategy.old <- future::plan("list")
[16:21:51.431]                   options(future.plan = NULL)
[16:21:51.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.431]                 }
[16:21:51.431]                 ...future.workdir <- getwd()
[16:21:51.431]             }
[16:21:51.431]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.431]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.431]         }
[16:21:51.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.431]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.431]             base::names(...future.oldOptions))
[16:21:51.431]     }
[16:21:51.431]     if (FALSE) {
[16:21:51.431]     }
[16:21:51.431]     else {
[16:21:51.431]         if (TRUE) {
[16:21:51.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.431]                 open = "w")
[16:21:51.431]         }
[16:21:51.431]         else {
[16:21:51.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.431]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.431]         }
[16:21:51.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.431]             base::sink(type = "output", split = FALSE)
[16:21:51.431]             base::close(...future.stdout)
[16:21:51.431]         }, add = TRUE)
[16:21:51.431]     }
[16:21:51.431]     ...future.frame <- base::sys.nframe()
[16:21:51.431]     ...future.conditions <- base::list()
[16:21:51.431]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.431]     if (FALSE) {
[16:21:51.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.431]     }
[16:21:51.431]     ...future.result <- base::tryCatch({
[16:21:51.431]         base::withCallingHandlers({
[16:21:51.431]             ...future.value <- base::withVisible(base::local({
[16:21:51.431]                 withCallingHandlers({
[16:21:51.431]                   2
[16:21:51.431]                 }, immediateCondition = function(cond) {
[16:21:51.431]                   save_rds <- function (object, pathname, ...) 
[16:21:51.431]                   {
[16:21:51.431]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.431]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.431]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.431]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.431]                         fi_tmp[["mtime"]])
[16:21:51.431]                     }
[16:21:51.431]                     tryCatch({
[16:21:51.431]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.431]                     }, error = function(ex) {
[16:21:51.431]                       msg <- conditionMessage(ex)
[16:21:51.431]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.431]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.431]                         fi_tmp[["mtime"]], msg)
[16:21:51.431]                       ex$message <- msg
[16:21:51.431]                       stop(ex)
[16:21:51.431]                     })
[16:21:51.431]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.431]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.431]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.431]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.431]                       fi <- file.info(pathname)
[16:21:51.431]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.431]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.431]                         fi[["size"]], fi[["mtime"]])
[16:21:51.431]                       stop(msg)
[16:21:51.431]                     }
[16:21:51.431]                     invisible(pathname)
[16:21:51.431]                   }
[16:21:51.431]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.431]                     rootPath = tempdir()) 
[16:21:51.431]                   {
[16:21:51.431]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.431]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.431]                       tmpdir = path, fileext = ".rds")
[16:21:51.431]                     save_rds(obj, file)
[16:21:51.431]                   }
[16:21:51.431]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.431]                   {
[16:21:51.431]                     inherits <- base::inherits
[16:21:51.431]                     invokeRestart <- base::invokeRestart
[16:21:51.431]                     is.null <- base::is.null
[16:21:51.431]                     muffled <- FALSE
[16:21:51.431]                     if (inherits(cond, "message")) {
[16:21:51.431]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.431]                       if (muffled) 
[16:21:51.431]                         invokeRestart("muffleMessage")
[16:21:51.431]                     }
[16:21:51.431]                     else if (inherits(cond, "warning")) {
[16:21:51.431]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.431]                       if (muffled) 
[16:21:51.431]                         invokeRestart("muffleWarning")
[16:21:51.431]                     }
[16:21:51.431]                     else if (inherits(cond, "condition")) {
[16:21:51.431]                       if (!is.null(pattern)) {
[16:21:51.431]                         computeRestarts <- base::computeRestarts
[16:21:51.431]                         grepl <- base::grepl
[16:21:51.431]                         restarts <- computeRestarts(cond)
[16:21:51.431]                         for (restart in restarts) {
[16:21:51.431]                           name <- restart$name
[16:21:51.431]                           if (is.null(name)) 
[16:21:51.431]                             next
[16:21:51.431]                           if (!grepl(pattern, name)) 
[16:21:51.431]                             next
[16:21:51.431]                           invokeRestart(restart)
[16:21:51.431]                           muffled <- TRUE
[16:21:51.431]                           break
[16:21:51.431]                         }
[16:21:51.431]                       }
[16:21:51.431]                     }
[16:21:51.431]                     invisible(muffled)
[16:21:51.431]                   }
[16:21:51.431]                   muffleCondition(cond)
[16:21:51.431]                 })
[16:21:51.431]             }))
[16:21:51.431]             future::FutureResult(value = ...future.value$value, 
[16:21:51.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.431]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.431]                     ...future.globalenv.names))
[16:21:51.431]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.431]         }, condition = base::local({
[16:21:51.431]             c <- base::c
[16:21:51.431]             inherits <- base::inherits
[16:21:51.431]             invokeRestart <- base::invokeRestart
[16:21:51.431]             length <- base::length
[16:21:51.431]             list <- base::list
[16:21:51.431]             seq.int <- base::seq.int
[16:21:51.431]             signalCondition <- base::signalCondition
[16:21:51.431]             sys.calls <- base::sys.calls
[16:21:51.431]             `[[` <- base::`[[`
[16:21:51.431]             `+` <- base::`+`
[16:21:51.431]             `<<-` <- base::`<<-`
[16:21:51.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.431]                   3L)]
[16:21:51.431]             }
[16:21:51.431]             function(cond) {
[16:21:51.431]                 is_error <- inherits(cond, "error")
[16:21:51.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.431]                   NULL)
[16:21:51.431]                 if (is_error) {
[16:21:51.431]                   sessionInformation <- function() {
[16:21:51.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.431]                       search = base::search(), system = base::Sys.info())
[16:21:51.431]                   }
[16:21:51.431]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.431]                     cond$call), session = sessionInformation(), 
[16:21:51.431]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.431]                   signalCondition(cond)
[16:21:51.431]                 }
[16:21:51.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.431]                 "immediateCondition"))) {
[16:21:51.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.431]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.431]                   if (TRUE && !signal) {
[16:21:51.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.431]                     {
[16:21:51.431]                       inherits <- base::inherits
[16:21:51.431]                       invokeRestart <- base::invokeRestart
[16:21:51.431]                       is.null <- base::is.null
[16:21:51.431]                       muffled <- FALSE
[16:21:51.431]                       if (inherits(cond, "message")) {
[16:21:51.431]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.431]                         if (muffled) 
[16:21:51.431]                           invokeRestart("muffleMessage")
[16:21:51.431]                       }
[16:21:51.431]                       else if (inherits(cond, "warning")) {
[16:21:51.431]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.431]                         if (muffled) 
[16:21:51.431]                           invokeRestart("muffleWarning")
[16:21:51.431]                       }
[16:21:51.431]                       else if (inherits(cond, "condition")) {
[16:21:51.431]                         if (!is.null(pattern)) {
[16:21:51.431]                           computeRestarts <- base::computeRestarts
[16:21:51.431]                           grepl <- base::grepl
[16:21:51.431]                           restarts <- computeRestarts(cond)
[16:21:51.431]                           for (restart in restarts) {
[16:21:51.431]                             name <- restart$name
[16:21:51.431]                             if (is.null(name)) 
[16:21:51.431]                               next
[16:21:51.431]                             if (!grepl(pattern, name)) 
[16:21:51.431]                               next
[16:21:51.431]                             invokeRestart(restart)
[16:21:51.431]                             muffled <- TRUE
[16:21:51.431]                             break
[16:21:51.431]                           }
[16:21:51.431]                         }
[16:21:51.431]                       }
[16:21:51.431]                       invisible(muffled)
[16:21:51.431]                     }
[16:21:51.431]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.431]                   }
[16:21:51.431]                 }
[16:21:51.431]                 else {
[16:21:51.431]                   if (TRUE) {
[16:21:51.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.431]                     {
[16:21:51.431]                       inherits <- base::inherits
[16:21:51.431]                       invokeRestart <- base::invokeRestart
[16:21:51.431]                       is.null <- base::is.null
[16:21:51.431]                       muffled <- FALSE
[16:21:51.431]                       if (inherits(cond, "message")) {
[16:21:51.431]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.431]                         if (muffled) 
[16:21:51.431]                           invokeRestart("muffleMessage")
[16:21:51.431]                       }
[16:21:51.431]                       else if (inherits(cond, "warning")) {
[16:21:51.431]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.431]                         if (muffled) 
[16:21:51.431]                           invokeRestart("muffleWarning")
[16:21:51.431]                       }
[16:21:51.431]                       else if (inherits(cond, "condition")) {
[16:21:51.431]                         if (!is.null(pattern)) {
[16:21:51.431]                           computeRestarts <- base::computeRestarts
[16:21:51.431]                           grepl <- base::grepl
[16:21:51.431]                           restarts <- computeRestarts(cond)
[16:21:51.431]                           for (restart in restarts) {
[16:21:51.431]                             name <- restart$name
[16:21:51.431]                             if (is.null(name)) 
[16:21:51.431]                               next
[16:21:51.431]                             if (!grepl(pattern, name)) 
[16:21:51.431]                               next
[16:21:51.431]                             invokeRestart(restart)
[16:21:51.431]                             muffled <- TRUE
[16:21:51.431]                             break
[16:21:51.431]                           }
[16:21:51.431]                         }
[16:21:51.431]                       }
[16:21:51.431]                       invisible(muffled)
[16:21:51.431]                     }
[16:21:51.431]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.431]                   }
[16:21:51.431]                 }
[16:21:51.431]             }
[16:21:51.431]         }))
[16:21:51.431]     }, error = function(ex) {
[16:21:51.431]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.431]                 ...future.rng), started = ...future.startTime, 
[16:21:51.431]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.431]             version = "1.8"), class = "FutureResult")
[16:21:51.431]     }, finally = {
[16:21:51.431]         if (!identical(...future.workdir, getwd())) 
[16:21:51.431]             setwd(...future.workdir)
[16:21:51.431]         {
[16:21:51.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.431]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.431]             }
[16:21:51.431]             base::options(...future.oldOptions)
[16:21:51.431]             if (.Platform$OS.type == "windows") {
[16:21:51.431]                 old_names <- names(...future.oldEnvVars)
[16:21:51.431]                 envs <- base::Sys.getenv()
[16:21:51.431]                 names <- names(envs)
[16:21:51.431]                 common <- intersect(names, old_names)
[16:21:51.431]                 added <- setdiff(names, old_names)
[16:21:51.431]                 removed <- setdiff(old_names, names)
[16:21:51.431]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.431]                   envs[common]]
[16:21:51.431]                 NAMES <- toupper(changed)
[16:21:51.431]                 args <- list()
[16:21:51.431]                 for (kk in seq_along(NAMES)) {
[16:21:51.431]                   name <- changed[[kk]]
[16:21:51.431]                   NAME <- NAMES[[kk]]
[16:21:51.431]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.431]                     next
[16:21:51.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.431]                 }
[16:21:51.431]                 NAMES <- toupper(added)
[16:21:51.431]                 for (kk in seq_along(NAMES)) {
[16:21:51.431]                   name <- added[[kk]]
[16:21:51.431]                   NAME <- NAMES[[kk]]
[16:21:51.431]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.431]                     next
[16:21:51.431]                   args[[name]] <- ""
[16:21:51.431]                 }
[16:21:51.431]                 NAMES <- toupper(removed)
[16:21:51.431]                 for (kk in seq_along(NAMES)) {
[16:21:51.431]                   name <- removed[[kk]]
[16:21:51.431]                   NAME <- NAMES[[kk]]
[16:21:51.431]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.431]                     next
[16:21:51.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.431]                 }
[16:21:51.431]                 if (length(args) > 0) 
[16:21:51.431]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.431]             }
[16:21:51.431]             else {
[16:21:51.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.431]             }
[16:21:51.431]             {
[16:21:51.431]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.431]                   0L) {
[16:21:51.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.431]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.431]                   base::options(opts)
[16:21:51.431]                 }
[16:21:51.431]                 {
[16:21:51.431]                   {
[16:21:51.431]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.431]                     NULL
[16:21:51.431]                   }
[16:21:51.431]                   options(future.plan = NULL)
[16:21:51.431]                   if (is.na(NA_character_)) 
[16:21:51.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.431]                     .init = FALSE)
[16:21:51.431]                 }
[16:21:51.431]             }
[16:21:51.431]         }
[16:21:51.431]     })
[16:21:51.431]     if (TRUE) {
[16:21:51.431]         base::sink(type = "output", split = FALSE)
[16:21:51.431]         if (TRUE) {
[16:21:51.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.431]         }
[16:21:51.431]         else {
[16:21:51.431]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.431]         }
[16:21:51.431]         base::close(...future.stdout)
[16:21:51.431]         ...future.stdout <- NULL
[16:21:51.431]     }
[16:21:51.431]     ...future.result$conditions <- ...future.conditions
[16:21:51.431]     ...future.result$finished <- base::Sys.time()
[16:21:51.431]     ...future.result
[16:21:51.431] }
[16:21:51.434] requestCore(): workers = 2
[16:21:51.440] MulticoreFuture started
[16:21:51.441] - Launch lazy future ... done
[16:21:51.441] run() for ‘MulticoreFuture’ ... done
[16:21:51.441] resolve() on list ...
[16:21:51.441]  recursive: 0
[16:21:51.442]  length: 3
[16:21:51.442] plan(): Setting new future strategy stack:
[16:21:51.442]  elements: ‘a’, ‘b’, ‘’
[16:21:51.442] List of future strategies:
[16:21:51.442] 1. sequential:
[16:21:51.442]    - args: function (..., envir = parent.frame())
[16:21:51.442]    - tweaked: FALSE
[16:21:51.442]    - call: NULL
[16:21:51.443] plan(): nbrOfWorkers() = 1
[16:21:51.444] Future #1
[16:21:51.444]  length: 2 (resolved future 1)
[16:21:51.445] plan(): Setting new future strategy stack:
[16:21:51.445] List of future strategies:
[16:21:51.445] 1. multicore:
[16:21:51.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.445]    - tweaked: FALSE
[16:21:51.445]    - call: plan(strategy)
[16:21:51.451] plan(): nbrOfWorkers() = 2
[16:21:51.451] Future #2
[16:21:51.451]  length: 1 (resolved future 2)
[16:21:51.452]  length: 0 (resolved future 3)
[16:21:51.452] resolve() on list ... DONE
[16:21:51.452] getGlobalsAndPackages() ...
[16:21:51.453] Searching for globals...
[16:21:51.453] 
[16:21:51.453] Searching for globals ... DONE
[16:21:51.454] - globals: [0] <none>
[16:21:51.454] getGlobalsAndPackages() ... DONE
[16:21:51.454] getGlobalsAndPackages() ...
[16:21:51.454] Searching for globals...
[16:21:51.455] 
[16:21:51.455] Searching for globals ... DONE
[16:21:51.455] - globals: [0] <none>
[16:21:51.455] getGlobalsAndPackages() ... DONE
[16:21:51.456] run() for ‘Future’ ...
[16:21:51.456] - state: ‘created’
[16:21:51.456] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.467] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.468]   - Field: ‘label’
[16:21:51.469]   - Field: ‘local’
[16:21:51.469]   - Field: ‘owner’
[16:21:51.469]   - Field: ‘envir’
[16:21:51.469]   - Field: ‘workers’
[16:21:51.469]   - Field: ‘packages’
[16:21:51.469]   - Field: ‘gc’
[16:21:51.470]   - Field: ‘job’
[16:21:51.470]   - Field: ‘conditions’
[16:21:51.470]   - Field: ‘expr’
[16:21:51.470]   - Field: ‘uuid’
[16:21:51.470]   - Field: ‘seed’
[16:21:51.470]   - Field: ‘version’
[16:21:51.471]   - Field: ‘result’
[16:21:51.471]   - Field: ‘asynchronous’
[16:21:51.471]   - Field: ‘calls’
[16:21:51.471]   - Field: ‘globals’
[16:21:51.471]   - Field: ‘stdout’
[16:21:51.472]   - Field: ‘earlySignal’
[16:21:51.472]   - Field: ‘lazy’
[16:21:51.472]   - Field: ‘state’
[16:21:51.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.472] - Launch lazy future ...
[16:21:51.473] Packages needed by the future expression (n = 0): <none>
[16:21:51.473] Packages needed by future strategies (n = 0): <none>
[16:21:51.474] {
[16:21:51.474]     {
[16:21:51.474]         {
[16:21:51.474]             ...future.startTime <- base::Sys.time()
[16:21:51.474]             {
[16:21:51.474]                 {
[16:21:51.474]                   {
[16:21:51.474]                     {
[16:21:51.474]                       base::local({
[16:21:51.474]                         has_future <- base::requireNamespace("future", 
[16:21:51.474]                           quietly = TRUE)
[16:21:51.474]                         if (has_future) {
[16:21:51.474]                           ns <- base::getNamespace("future")
[16:21:51.474]                           version <- ns[[".package"]][["version"]]
[16:21:51.474]                           if (is.null(version)) 
[16:21:51.474]                             version <- utils::packageVersion("future")
[16:21:51.474]                         }
[16:21:51.474]                         else {
[16:21:51.474]                           version <- NULL
[16:21:51.474]                         }
[16:21:51.474]                         if (!has_future || version < "1.8.0") {
[16:21:51.474]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.474]                             "", base::R.version$version.string), 
[16:21:51.474]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.474]                               "release", "version")], collapse = " "), 
[16:21:51.474]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.474]                             info)
[16:21:51.474]                           info <- base::paste(info, collapse = "; ")
[16:21:51.474]                           if (!has_future) {
[16:21:51.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.474]                               info)
[16:21:51.474]                           }
[16:21:51.474]                           else {
[16:21:51.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.474]                               info, version)
[16:21:51.474]                           }
[16:21:51.474]                           base::stop(msg)
[16:21:51.474]                         }
[16:21:51.474]                       })
[16:21:51.474]                     }
[16:21:51.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.474]                     base::options(mc.cores = 1L)
[16:21:51.474]                   }
[16:21:51.474]                   ...future.strategy.old <- future::plan("list")
[16:21:51.474]                   options(future.plan = NULL)
[16:21:51.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.474]                 }
[16:21:51.474]                 ...future.workdir <- getwd()
[16:21:51.474]             }
[16:21:51.474]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.474]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.474]         }
[16:21:51.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.474]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.474]             base::names(...future.oldOptions))
[16:21:51.474]     }
[16:21:51.474]     if (FALSE) {
[16:21:51.474]     }
[16:21:51.474]     else {
[16:21:51.474]         if (TRUE) {
[16:21:51.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.474]                 open = "w")
[16:21:51.474]         }
[16:21:51.474]         else {
[16:21:51.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.474]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.474]         }
[16:21:51.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.474]             base::sink(type = "output", split = FALSE)
[16:21:51.474]             base::close(...future.stdout)
[16:21:51.474]         }, add = TRUE)
[16:21:51.474]     }
[16:21:51.474]     ...future.frame <- base::sys.nframe()
[16:21:51.474]     ...future.conditions <- base::list()
[16:21:51.474]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.474]     if (FALSE) {
[16:21:51.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.474]     }
[16:21:51.474]     ...future.result <- base::tryCatch({
[16:21:51.474]         base::withCallingHandlers({
[16:21:51.474]             ...future.value <- base::withVisible(base::local({
[16:21:51.474]                 withCallingHandlers({
[16:21:51.474]                   2
[16:21:51.474]                 }, immediateCondition = function(cond) {
[16:21:51.474]                   save_rds <- function (object, pathname, ...) 
[16:21:51.474]                   {
[16:21:51.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.474]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.474]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.474]                         fi_tmp[["mtime"]])
[16:21:51.474]                     }
[16:21:51.474]                     tryCatch({
[16:21:51.474]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.474]                     }, error = function(ex) {
[16:21:51.474]                       msg <- conditionMessage(ex)
[16:21:51.474]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.474]                         fi_tmp[["mtime"]], msg)
[16:21:51.474]                       ex$message <- msg
[16:21:51.474]                       stop(ex)
[16:21:51.474]                     })
[16:21:51.474]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.474]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.474]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.474]                       fi <- file.info(pathname)
[16:21:51.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.474]                         fi[["size"]], fi[["mtime"]])
[16:21:51.474]                       stop(msg)
[16:21:51.474]                     }
[16:21:51.474]                     invisible(pathname)
[16:21:51.474]                   }
[16:21:51.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.474]                     rootPath = tempdir()) 
[16:21:51.474]                   {
[16:21:51.474]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.474]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.474]                       tmpdir = path, fileext = ".rds")
[16:21:51.474]                     save_rds(obj, file)
[16:21:51.474]                   }
[16:21:51.474]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.474]                   {
[16:21:51.474]                     inherits <- base::inherits
[16:21:51.474]                     invokeRestart <- base::invokeRestart
[16:21:51.474]                     is.null <- base::is.null
[16:21:51.474]                     muffled <- FALSE
[16:21:51.474]                     if (inherits(cond, "message")) {
[16:21:51.474]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.474]                       if (muffled) 
[16:21:51.474]                         invokeRestart("muffleMessage")
[16:21:51.474]                     }
[16:21:51.474]                     else if (inherits(cond, "warning")) {
[16:21:51.474]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.474]                       if (muffled) 
[16:21:51.474]                         invokeRestart("muffleWarning")
[16:21:51.474]                     }
[16:21:51.474]                     else if (inherits(cond, "condition")) {
[16:21:51.474]                       if (!is.null(pattern)) {
[16:21:51.474]                         computeRestarts <- base::computeRestarts
[16:21:51.474]                         grepl <- base::grepl
[16:21:51.474]                         restarts <- computeRestarts(cond)
[16:21:51.474]                         for (restart in restarts) {
[16:21:51.474]                           name <- restart$name
[16:21:51.474]                           if (is.null(name)) 
[16:21:51.474]                             next
[16:21:51.474]                           if (!grepl(pattern, name)) 
[16:21:51.474]                             next
[16:21:51.474]                           invokeRestart(restart)
[16:21:51.474]                           muffled <- TRUE
[16:21:51.474]                           break
[16:21:51.474]                         }
[16:21:51.474]                       }
[16:21:51.474]                     }
[16:21:51.474]                     invisible(muffled)
[16:21:51.474]                   }
[16:21:51.474]                   muffleCondition(cond)
[16:21:51.474]                 })
[16:21:51.474]             }))
[16:21:51.474]             future::FutureResult(value = ...future.value$value, 
[16:21:51.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.474]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.474]                     ...future.globalenv.names))
[16:21:51.474]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.474]         }, condition = base::local({
[16:21:51.474]             c <- base::c
[16:21:51.474]             inherits <- base::inherits
[16:21:51.474]             invokeRestart <- base::invokeRestart
[16:21:51.474]             length <- base::length
[16:21:51.474]             list <- base::list
[16:21:51.474]             seq.int <- base::seq.int
[16:21:51.474]             signalCondition <- base::signalCondition
[16:21:51.474]             sys.calls <- base::sys.calls
[16:21:51.474]             `[[` <- base::`[[`
[16:21:51.474]             `+` <- base::`+`
[16:21:51.474]             `<<-` <- base::`<<-`
[16:21:51.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.474]                   3L)]
[16:21:51.474]             }
[16:21:51.474]             function(cond) {
[16:21:51.474]                 is_error <- inherits(cond, "error")
[16:21:51.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.474]                   NULL)
[16:21:51.474]                 if (is_error) {
[16:21:51.474]                   sessionInformation <- function() {
[16:21:51.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.474]                       search = base::search(), system = base::Sys.info())
[16:21:51.474]                   }
[16:21:51.474]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.474]                     cond$call), session = sessionInformation(), 
[16:21:51.474]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.474]                   signalCondition(cond)
[16:21:51.474]                 }
[16:21:51.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.474]                 "immediateCondition"))) {
[16:21:51.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.474]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.474]                   if (TRUE && !signal) {
[16:21:51.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.474]                     {
[16:21:51.474]                       inherits <- base::inherits
[16:21:51.474]                       invokeRestart <- base::invokeRestart
[16:21:51.474]                       is.null <- base::is.null
[16:21:51.474]                       muffled <- FALSE
[16:21:51.474]                       if (inherits(cond, "message")) {
[16:21:51.474]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.474]                         if (muffled) 
[16:21:51.474]                           invokeRestart("muffleMessage")
[16:21:51.474]                       }
[16:21:51.474]                       else if (inherits(cond, "warning")) {
[16:21:51.474]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.474]                         if (muffled) 
[16:21:51.474]                           invokeRestart("muffleWarning")
[16:21:51.474]                       }
[16:21:51.474]                       else if (inherits(cond, "condition")) {
[16:21:51.474]                         if (!is.null(pattern)) {
[16:21:51.474]                           computeRestarts <- base::computeRestarts
[16:21:51.474]                           grepl <- base::grepl
[16:21:51.474]                           restarts <- computeRestarts(cond)
[16:21:51.474]                           for (restart in restarts) {
[16:21:51.474]                             name <- restart$name
[16:21:51.474]                             if (is.null(name)) 
[16:21:51.474]                               next
[16:21:51.474]                             if (!grepl(pattern, name)) 
[16:21:51.474]                               next
[16:21:51.474]                             invokeRestart(restart)
[16:21:51.474]                             muffled <- TRUE
[16:21:51.474]                             break
[16:21:51.474]                           }
[16:21:51.474]                         }
[16:21:51.474]                       }
[16:21:51.474]                       invisible(muffled)
[16:21:51.474]                     }
[16:21:51.474]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.474]                   }
[16:21:51.474]                 }
[16:21:51.474]                 else {
[16:21:51.474]                   if (TRUE) {
[16:21:51.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.474]                     {
[16:21:51.474]                       inherits <- base::inherits
[16:21:51.474]                       invokeRestart <- base::invokeRestart
[16:21:51.474]                       is.null <- base::is.null
[16:21:51.474]                       muffled <- FALSE
[16:21:51.474]                       if (inherits(cond, "message")) {
[16:21:51.474]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.474]                         if (muffled) 
[16:21:51.474]                           invokeRestart("muffleMessage")
[16:21:51.474]                       }
[16:21:51.474]                       else if (inherits(cond, "warning")) {
[16:21:51.474]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.474]                         if (muffled) 
[16:21:51.474]                           invokeRestart("muffleWarning")
[16:21:51.474]                       }
[16:21:51.474]                       else if (inherits(cond, "condition")) {
[16:21:51.474]                         if (!is.null(pattern)) {
[16:21:51.474]                           computeRestarts <- base::computeRestarts
[16:21:51.474]                           grepl <- base::grepl
[16:21:51.474]                           restarts <- computeRestarts(cond)
[16:21:51.474]                           for (restart in restarts) {
[16:21:51.474]                             name <- restart$name
[16:21:51.474]                             if (is.null(name)) 
[16:21:51.474]                               next
[16:21:51.474]                             if (!grepl(pattern, name)) 
[16:21:51.474]                               next
[16:21:51.474]                             invokeRestart(restart)
[16:21:51.474]                             muffled <- TRUE
[16:21:51.474]                             break
[16:21:51.474]                           }
[16:21:51.474]                         }
[16:21:51.474]                       }
[16:21:51.474]                       invisible(muffled)
[16:21:51.474]                     }
[16:21:51.474]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.474]                   }
[16:21:51.474]                 }
[16:21:51.474]             }
[16:21:51.474]         }))
[16:21:51.474]     }, error = function(ex) {
[16:21:51.474]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.474]                 ...future.rng), started = ...future.startTime, 
[16:21:51.474]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.474]             version = "1.8"), class = "FutureResult")
[16:21:51.474]     }, finally = {
[16:21:51.474]         if (!identical(...future.workdir, getwd())) 
[16:21:51.474]             setwd(...future.workdir)
[16:21:51.474]         {
[16:21:51.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.474]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.474]             }
[16:21:51.474]             base::options(...future.oldOptions)
[16:21:51.474]             if (.Platform$OS.type == "windows") {
[16:21:51.474]                 old_names <- names(...future.oldEnvVars)
[16:21:51.474]                 envs <- base::Sys.getenv()
[16:21:51.474]                 names <- names(envs)
[16:21:51.474]                 common <- intersect(names, old_names)
[16:21:51.474]                 added <- setdiff(names, old_names)
[16:21:51.474]                 removed <- setdiff(old_names, names)
[16:21:51.474]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.474]                   envs[common]]
[16:21:51.474]                 NAMES <- toupper(changed)
[16:21:51.474]                 args <- list()
[16:21:51.474]                 for (kk in seq_along(NAMES)) {
[16:21:51.474]                   name <- changed[[kk]]
[16:21:51.474]                   NAME <- NAMES[[kk]]
[16:21:51.474]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.474]                     next
[16:21:51.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.474]                 }
[16:21:51.474]                 NAMES <- toupper(added)
[16:21:51.474]                 for (kk in seq_along(NAMES)) {
[16:21:51.474]                   name <- added[[kk]]
[16:21:51.474]                   NAME <- NAMES[[kk]]
[16:21:51.474]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.474]                     next
[16:21:51.474]                   args[[name]] <- ""
[16:21:51.474]                 }
[16:21:51.474]                 NAMES <- toupper(removed)
[16:21:51.474]                 for (kk in seq_along(NAMES)) {
[16:21:51.474]                   name <- removed[[kk]]
[16:21:51.474]                   NAME <- NAMES[[kk]]
[16:21:51.474]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.474]                     next
[16:21:51.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.474]                 }
[16:21:51.474]                 if (length(args) > 0) 
[16:21:51.474]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.474]             }
[16:21:51.474]             else {
[16:21:51.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.474]             }
[16:21:51.474]             {
[16:21:51.474]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.474]                   0L) {
[16:21:51.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.474]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.474]                   base::options(opts)
[16:21:51.474]                 }
[16:21:51.474]                 {
[16:21:51.474]                   {
[16:21:51.474]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.474]                     NULL
[16:21:51.474]                   }
[16:21:51.474]                   options(future.plan = NULL)
[16:21:51.474]                   if (is.na(NA_character_)) 
[16:21:51.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.474]                     .init = FALSE)
[16:21:51.474]                 }
[16:21:51.474]             }
[16:21:51.474]         }
[16:21:51.474]     })
[16:21:51.474]     if (TRUE) {
[16:21:51.474]         base::sink(type = "output", split = FALSE)
[16:21:51.474]         if (TRUE) {
[16:21:51.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.474]         }
[16:21:51.474]         else {
[16:21:51.474]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.474]         }
[16:21:51.474]         base::close(...future.stdout)
[16:21:51.474]         ...future.stdout <- NULL
[16:21:51.474]     }
[16:21:51.474]     ...future.result$conditions <- ...future.conditions
[16:21:51.474]     ...future.result$finished <- base::Sys.time()
[16:21:51.474]     ...future.result
[16:21:51.474] }
[16:21:51.476] requestCore(): workers = 2
[16:21:51.477] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:51.488] result() for MulticoreFuture ...
[16:21:51.490] result() for MulticoreFuture ...
[16:21:51.490] result() for MulticoreFuture ... done
[16:21:51.490] result() for MulticoreFuture ... done
[16:21:51.490] result() for MulticoreFuture ...
[16:21:51.490] result() for MulticoreFuture ... done
[16:21:51.493] MulticoreFuture started
[16:21:51.493] - Launch lazy future ... done
[16:21:51.493] run() for ‘MulticoreFuture’ ... done
[16:21:51.494] resolve() on list ...
[16:21:51.494]  recursive: 0
[16:21:51.494] plan(): Setting new future strategy stack:
[16:21:51.494]  length: 3
[16:21:51.494]  elements: ‘a’, ‘b’, ‘’
[16:21:51.495] run() for ‘Future’ ...
[16:21:51.495] - state: ‘created’
[16:21:51.494] List of future strategies:
[16:21:51.494] 1. sequential:
[16:21:51.494]    - args: function (..., envir = parent.frame())
[16:21:51.494]    - tweaked: FALSE
[16:21:51.494]    - call: NULL
[16:21:51.495] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.495] plan(): nbrOfWorkers() = 1
[16:21:51.498] plan(): Setting new future strategy stack:
[16:21:51.498] List of future strategies:
[16:21:51.498] 1. multicore:
[16:21:51.498]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.498]    - tweaked: FALSE
[16:21:51.498]    - call: plan(strategy)
[16:21:51.501] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.501]   - Field: ‘label’
[16:21:51.501]   - Field: ‘local’
[16:21:51.502]   - Field: ‘owner’
[16:21:51.502]   - Field: ‘envir’
[16:21:51.502]   - Field: ‘workers’
[16:21:51.502]   - Field: ‘packages’
[16:21:51.502]   - Field: ‘gc’
[16:21:51.502]   - Field: ‘job’
[16:21:51.502] plan(): nbrOfWorkers() = 2
[16:21:51.503]   - Field: ‘conditions’
[16:21:51.503]   - Field: ‘expr’
[16:21:51.503]   - Field: ‘uuid’
[16:21:51.503]   - Field: ‘seed’
[16:21:51.503]   - Field: ‘version’
[16:21:51.503]   - Field: ‘result’
[16:21:51.504]   - Field: ‘asynchronous’
[16:21:51.504]   - Field: ‘calls’
[16:21:51.504]   - Field: ‘globals’
[16:21:51.504]   - Field: ‘stdout’
[16:21:51.504]   - Field: ‘earlySignal’
[16:21:51.504]   - Field: ‘lazy’
[16:21:51.505]   - Field: ‘state’
[16:21:51.505] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.505] - Launch lazy future ...
[16:21:51.505] Packages needed by the future expression (n = 0): <none>
[16:21:51.506] Packages needed by future strategies (n = 0): <none>
[16:21:51.506] {
[16:21:51.506]     {
[16:21:51.506]         {
[16:21:51.506]             ...future.startTime <- base::Sys.time()
[16:21:51.506]             {
[16:21:51.506]                 {
[16:21:51.506]                   {
[16:21:51.506]                     {
[16:21:51.506]                       base::local({
[16:21:51.506]                         has_future <- base::requireNamespace("future", 
[16:21:51.506]                           quietly = TRUE)
[16:21:51.506]                         if (has_future) {
[16:21:51.506]                           ns <- base::getNamespace("future")
[16:21:51.506]                           version <- ns[[".package"]][["version"]]
[16:21:51.506]                           if (is.null(version)) 
[16:21:51.506]                             version <- utils::packageVersion("future")
[16:21:51.506]                         }
[16:21:51.506]                         else {
[16:21:51.506]                           version <- NULL
[16:21:51.506]                         }
[16:21:51.506]                         if (!has_future || version < "1.8.0") {
[16:21:51.506]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.506]                             "", base::R.version$version.string), 
[16:21:51.506]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.506]                               "release", "version")], collapse = " "), 
[16:21:51.506]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.506]                             info)
[16:21:51.506]                           info <- base::paste(info, collapse = "; ")
[16:21:51.506]                           if (!has_future) {
[16:21:51.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.506]                               info)
[16:21:51.506]                           }
[16:21:51.506]                           else {
[16:21:51.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.506]                               info, version)
[16:21:51.506]                           }
[16:21:51.506]                           base::stop(msg)
[16:21:51.506]                         }
[16:21:51.506]                       })
[16:21:51.506]                     }
[16:21:51.506]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.506]                     base::options(mc.cores = 1L)
[16:21:51.506]                   }
[16:21:51.506]                   ...future.strategy.old <- future::plan("list")
[16:21:51.506]                   options(future.plan = NULL)
[16:21:51.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.506]                 }
[16:21:51.506]                 ...future.workdir <- getwd()
[16:21:51.506]             }
[16:21:51.506]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.506]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.506]         }
[16:21:51.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.506]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.506]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.506]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.506]             base::names(...future.oldOptions))
[16:21:51.506]     }
[16:21:51.506]     if (FALSE) {
[16:21:51.506]     }
[16:21:51.506]     else {
[16:21:51.506]         if (TRUE) {
[16:21:51.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.506]                 open = "w")
[16:21:51.506]         }
[16:21:51.506]         else {
[16:21:51.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.506]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.506]         }
[16:21:51.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.506]             base::sink(type = "output", split = FALSE)
[16:21:51.506]             base::close(...future.stdout)
[16:21:51.506]         }, add = TRUE)
[16:21:51.506]     }
[16:21:51.506]     ...future.frame <- base::sys.nframe()
[16:21:51.506]     ...future.conditions <- base::list()
[16:21:51.506]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.506]     if (FALSE) {
[16:21:51.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.506]     }
[16:21:51.506]     ...future.result <- base::tryCatch({
[16:21:51.506]         base::withCallingHandlers({
[16:21:51.506]             ...future.value <- base::withVisible(base::local({
[16:21:51.506]                 withCallingHandlers({
[16:21:51.506]                   1
[16:21:51.506]                 }, immediateCondition = function(cond) {
[16:21:51.506]                   save_rds <- function (object, pathname, ...) 
[16:21:51.506]                   {
[16:21:51.506]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.506]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.506]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.506]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.506]                         fi_tmp[["mtime"]])
[16:21:51.506]                     }
[16:21:51.506]                     tryCatch({
[16:21:51.506]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.506]                     }, error = function(ex) {
[16:21:51.506]                       msg <- conditionMessage(ex)
[16:21:51.506]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.506]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.506]                         fi_tmp[["mtime"]], msg)
[16:21:51.506]                       ex$message <- msg
[16:21:51.506]                       stop(ex)
[16:21:51.506]                     })
[16:21:51.506]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.506]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.506]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.506]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.506]                       fi <- file.info(pathname)
[16:21:51.506]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.506]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.506]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.506]                         fi[["size"]], fi[["mtime"]])
[16:21:51.506]                       stop(msg)
[16:21:51.506]                     }
[16:21:51.506]                     invisible(pathname)
[16:21:51.506]                   }
[16:21:51.506]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.506]                     rootPath = tempdir()) 
[16:21:51.506]                   {
[16:21:51.506]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.506]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.506]                       tmpdir = path, fileext = ".rds")
[16:21:51.506]                     save_rds(obj, file)
[16:21:51.506]                   }
[16:21:51.506]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.506]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.506]                   {
[16:21:51.506]                     inherits <- base::inherits
[16:21:51.506]                     invokeRestart <- base::invokeRestart
[16:21:51.506]                     is.null <- base::is.null
[16:21:51.506]                     muffled <- FALSE
[16:21:51.506]                     if (inherits(cond, "message")) {
[16:21:51.506]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.506]                       if (muffled) 
[16:21:51.506]                         invokeRestart("muffleMessage")
[16:21:51.506]                     }
[16:21:51.506]                     else if (inherits(cond, "warning")) {
[16:21:51.506]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.506]                       if (muffled) 
[16:21:51.506]                         invokeRestart("muffleWarning")
[16:21:51.506]                     }
[16:21:51.506]                     else if (inherits(cond, "condition")) {
[16:21:51.506]                       if (!is.null(pattern)) {
[16:21:51.506]                         computeRestarts <- base::computeRestarts
[16:21:51.506]                         grepl <- base::grepl
[16:21:51.506]                         restarts <- computeRestarts(cond)
[16:21:51.506]                         for (restart in restarts) {
[16:21:51.506]                           name <- restart$name
[16:21:51.506]                           if (is.null(name)) 
[16:21:51.506]                             next
[16:21:51.506]                           if (!grepl(pattern, name)) 
[16:21:51.506]                             next
[16:21:51.506]                           invokeRestart(restart)
[16:21:51.506]                           muffled <- TRUE
[16:21:51.506]                           break
[16:21:51.506]                         }
[16:21:51.506]                       }
[16:21:51.506]                     }
[16:21:51.506]                     invisible(muffled)
[16:21:51.506]                   }
[16:21:51.506]                   muffleCondition(cond)
[16:21:51.506]                 })
[16:21:51.506]             }))
[16:21:51.506]             future::FutureResult(value = ...future.value$value, 
[16:21:51.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.506]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.506]                     ...future.globalenv.names))
[16:21:51.506]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.506]         }, condition = base::local({
[16:21:51.506]             c <- base::c
[16:21:51.506]             inherits <- base::inherits
[16:21:51.506]             invokeRestart <- base::invokeRestart
[16:21:51.506]             length <- base::length
[16:21:51.506]             list <- base::list
[16:21:51.506]             seq.int <- base::seq.int
[16:21:51.506]             signalCondition <- base::signalCondition
[16:21:51.506]             sys.calls <- base::sys.calls
[16:21:51.506]             `[[` <- base::`[[`
[16:21:51.506]             `+` <- base::`+`
[16:21:51.506]             `<<-` <- base::`<<-`
[16:21:51.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.506]                   3L)]
[16:21:51.506]             }
[16:21:51.506]             function(cond) {
[16:21:51.506]                 is_error <- inherits(cond, "error")
[16:21:51.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.506]                   NULL)
[16:21:51.506]                 if (is_error) {
[16:21:51.506]                   sessionInformation <- function() {
[16:21:51.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.506]                       search = base::search(), system = base::Sys.info())
[16:21:51.506]                   }
[16:21:51.506]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.506]                     cond$call), session = sessionInformation(), 
[16:21:51.506]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.506]                   signalCondition(cond)
[16:21:51.506]                 }
[16:21:51.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.506]                 "immediateCondition"))) {
[16:21:51.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.506]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.506]                   if (TRUE && !signal) {
[16:21:51.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.506]                     {
[16:21:51.506]                       inherits <- base::inherits
[16:21:51.506]                       invokeRestart <- base::invokeRestart
[16:21:51.506]                       is.null <- base::is.null
[16:21:51.506]                       muffled <- FALSE
[16:21:51.506]                       if (inherits(cond, "message")) {
[16:21:51.506]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.506]                         if (muffled) 
[16:21:51.506]                           invokeRestart("muffleMessage")
[16:21:51.506]                       }
[16:21:51.506]                       else if (inherits(cond, "warning")) {
[16:21:51.506]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.506]                         if (muffled) 
[16:21:51.506]                           invokeRestart("muffleWarning")
[16:21:51.506]                       }
[16:21:51.506]                       else if (inherits(cond, "condition")) {
[16:21:51.506]                         if (!is.null(pattern)) {
[16:21:51.506]                           computeRestarts <- base::computeRestarts
[16:21:51.506]                           grepl <- base::grepl
[16:21:51.506]                           restarts <- computeRestarts(cond)
[16:21:51.506]                           for (restart in restarts) {
[16:21:51.506]                             name <- restart$name
[16:21:51.506]                             if (is.null(name)) 
[16:21:51.506]                               next
[16:21:51.506]                             if (!grepl(pattern, name)) 
[16:21:51.506]                               next
[16:21:51.506]                             invokeRestart(restart)
[16:21:51.506]                             muffled <- TRUE
[16:21:51.506]                             break
[16:21:51.506]                           }
[16:21:51.506]                         }
[16:21:51.506]                       }
[16:21:51.506]                       invisible(muffled)
[16:21:51.506]                     }
[16:21:51.506]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.506]                   }
[16:21:51.506]                 }
[16:21:51.506]                 else {
[16:21:51.506]                   if (TRUE) {
[16:21:51.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.506]                     {
[16:21:51.506]                       inherits <- base::inherits
[16:21:51.506]                       invokeRestart <- base::invokeRestart
[16:21:51.506]                       is.null <- base::is.null
[16:21:51.506]                       muffled <- FALSE
[16:21:51.506]                       if (inherits(cond, "message")) {
[16:21:51.506]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.506]                         if (muffled) 
[16:21:51.506]                           invokeRestart("muffleMessage")
[16:21:51.506]                       }
[16:21:51.506]                       else if (inherits(cond, "warning")) {
[16:21:51.506]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.506]                         if (muffled) 
[16:21:51.506]                           invokeRestart("muffleWarning")
[16:21:51.506]                       }
[16:21:51.506]                       else if (inherits(cond, "condition")) {
[16:21:51.506]                         if (!is.null(pattern)) {
[16:21:51.506]                           computeRestarts <- base::computeRestarts
[16:21:51.506]                           grepl <- base::grepl
[16:21:51.506]                           restarts <- computeRestarts(cond)
[16:21:51.506]                           for (restart in restarts) {
[16:21:51.506]                             name <- restart$name
[16:21:51.506]                             if (is.null(name)) 
[16:21:51.506]                               next
[16:21:51.506]                             if (!grepl(pattern, name)) 
[16:21:51.506]                               next
[16:21:51.506]                             invokeRestart(restart)
[16:21:51.506]                             muffled <- TRUE
[16:21:51.506]                             break
[16:21:51.506]                           }
[16:21:51.506]                         }
[16:21:51.506]                       }
[16:21:51.506]                       invisible(muffled)
[16:21:51.506]                     }
[16:21:51.506]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.506]                   }
[16:21:51.506]                 }
[16:21:51.506]             }
[16:21:51.506]         }))
[16:21:51.506]     }, error = function(ex) {
[16:21:51.506]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.506]                 ...future.rng), started = ...future.startTime, 
[16:21:51.506]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.506]             version = "1.8"), class = "FutureResult")
[16:21:51.506]     }, finally = {
[16:21:51.506]         if (!identical(...future.workdir, getwd())) 
[16:21:51.506]             setwd(...future.workdir)
[16:21:51.506]         {
[16:21:51.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.506]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.506]             }
[16:21:51.506]             base::options(...future.oldOptions)
[16:21:51.506]             if (.Platform$OS.type == "windows") {
[16:21:51.506]                 old_names <- names(...future.oldEnvVars)
[16:21:51.506]                 envs <- base::Sys.getenv()
[16:21:51.506]                 names <- names(envs)
[16:21:51.506]                 common <- intersect(names, old_names)
[16:21:51.506]                 added <- setdiff(names, old_names)
[16:21:51.506]                 removed <- setdiff(old_names, names)
[16:21:51.506]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.506]                   envs[common]]
[16:21:51.506]                 NAMES <- toupper(changed)
[16:21:51.506]                 args <- list()
[16:21:51.506]                 for (kk in seq_along(NAMES)) {
[16:21:51.506]                   name <- changed[[kk]]
[16:21:51.506]                   NAME <- NAMES[[kk]]
[16:21:51.506]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.506]                     next
[16:21:51.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.506]                 }
[16:21:51.506]                 NAMES <- toupper(added)
[16:21:51.506]                 for (kk in seq_along(NAMES)) {
[16:21:51.506]                   name <- added[[kk]]
[16:21:51.506]                   NAME <- NAMES[[kk]]
[16:21:51.506]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.506]                     next
[16:21:51.506]                   args[[name]] <- ""
[16:21:51.506]                 }
[16:21:51.506]                 NAMES <- toupper(removed)
[16:21:51.506]                 for (kk in seq_along(NAMES)) {
[16:21:51.506]                   name <- removed[[kk]]
[16:21:51.506]                   NAME <- NAMES[[kk]]
[16:21:51.506]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.506]                     next
[16:21:51.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.506]                 }
[16:21:51.506]                 if (length(args) > 0) 
[16:21:51.506]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.506]             }
[16:21:51.506]             else {
[16:21:51.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.506]             }
[16:21:51.506]             {
[16:21:51.506]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.506]                   0L) {
[16:21:51.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.506]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.506]                   base::options(opts)
[16:21:51.506]                 }
[16:21:51.506]                 {
[16:21:51.506]                   {
[16:21:51.506]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.506]                     NULL
[16:21:51.506]                   }
[16:21:51.506]                   options(future.plan = NULL)
[16:21:51.506]                   if (is.na(NA_character_)) 
[16:21:51.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.506]                     .init = FALSE)
[16:21:51.506]                 }
[16:21:51.506]             }
[16:21:51.506]         }
[16:21:51.506]     })
[16:21:51.506]     if (TRUE) {
[16:21:51.506]         base::sink(type = "output", split = FALSE)
[16:21:51.506]         if (TRUE) {
[16:21:51.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.506]         }
[16:21:51.506]         else {
[16:21:51.506]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.506]         }
[16:21:51.506]         base::close(...future.stdout)
[16:21:51.506]         ...future.stdout <- NULL
[16:21:51.506]     }
[16:21:51.506]     ...future.result$conditions <- ...future.conditions
[16:21:51.506]     ...future.result$finished <- base::Sys.time()
[16:21:51.506]     ...future.result
[16:21:51.506] }
[16:21:51.510] requestCore(): workers = 2
[16:21:51.510] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:51.534] result() for MulticoreFuture ...
[16:21:51.535] result() for MulticoreFuture ...
[16:21:51.535] result() for MulticoreFuture ... done
[16:21:51.535] result() for MulticoreFuture ... done
[16:21:51.539] result() for MulticoreFuture ...
[16:21:51.539] result() for MulticoreFuture ... done
[16:21:51.542] MulticoreFuture started
[16:21:51.542] - Launch lazy future ... done
[16:21:51.543] run() for ‘MulticoreFuture’ ... done
[16:21:51.543] plan(): Setting new future strategy stack:
[16:21:51.544] List of future strategies:
[16:21:51.544] 1. sequential:
[16:21:51.544]    - args: function (..., envir = parent.frame())
[16:21:51.544]    - tweaked: FALSE
[16:21:51.544]    - call: NULL
[16:21:51.545] plan(): nbrOfWorkers() = 1
[16:21:51.549] plan(): Setting new future strategy stack:
[16:21:51.549] List of future strategies:
[16:21:51.549] 1. multicore:
[16:21:51.549]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.549]    - tweaked: FALSE
[16:21:51.549]    - call: plan(strategy)
[16:21:51.554] Future #2
[16:21:51.555]  length: 2 (resolved future 2)
[16:21:51.555] plan(): nbrOfWorkers() = 2
[16:21:51.555]  length: 1 (resolved future 3)
[16:21:51.566] Future #1
[16:21:51.566]  length: 0 (resolved future 1)
[16:21:51.566] resolve() on list ... DONE
[16:21:51.567] getGlobalsAndPackages() ...
[16:21:51.567] Searching for globals...
[16:21:51.568] 
[16:21:51.568] Searching for globals ... DONE
[16:21:51.569] - globals: [0] <none>
[16:21:51.569] getGlobalsAndPackages() ... DONE
[16:21:51.569] getGlobalsAndPackages() ...
[16:21:51.570] Searching for globals...
[16:21:51.570] 
[16:21:51.570] Searching for globals ... DONE
[16:21:51.571] - globals: [0] <none>
[16:21:51.571] getGlobalsAndPackages() ... DONE
[16:21:51.571] resolve() on list ...
[16:21:51.571]  recursive: 0
[16:21:51.571]  length: 3
[16:21:51.572]  elements: ‘a’, ‘b’, ‘’
[16:21:51.572] run() for ‘Future’ ...
[16:21:51.572] - state: ‘created’
[16:21:51.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.578]   - Field: ‘label’
[16:21:51.579]   - Field: ‘local’
[16:21:51.579]   - Field: ‘owner’
[16:21:51.579]   - Field: ‘envir’
[16:21:51.579]   - Field: ‘workers’
[16:21:51.579]   - Field: ‘packages’
[16:21:51.579]   - Field: ‘gc’
[16:21:51.580]   - Field: ‘job’
[16:21:51.580]   - Field: ‘conditions’
[16:21:51.580]   - Field: ‘expr’
[16:21:51.580]   - Field: ‘uuid’
[16:21:51.580]   - Field: ‘seed’
[16:21:51.580]   - Field: ‘version’
[16:21:51.581]   - Field: ‘result’
[16:21:51.581]   - Field: ‘asynchronous’
[16:21:51.581]   - Field: ‘calls’
[16:21:51.581]   - Field: ‘globals’
[16:21:51.581]   - Field: ‘stdout’
[16:21:51.581]   - Field: ‘earlySignal’
[16:21:51.581]   - Field: ‘lazy’
[16:21:51.582]   - Field: ‘state’
[16:21:51.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.582] - Launch lazy future ...
[16:21:51.582] Packages needed by the future expression (n = 0): <none>
[16:21:51.582] Packages needed by future strategies (n = 0): <none>
[16:21:51.583] {
[16:21:51.583]     {
[16:21:51.583]         {
[16:21:51.583]             ...future.startTime <- base::Sys.time()
[16:21:51.583]             {
[16:21:51.583]                 {
[16:21:51.583]                   {
[16:21:51.583]                     {
[16:21:51.583]                       base::local({
[16:21:51.583]                         has_future <- base::requireNamespace("future", 
[16:21:51.583]                           quietly = TRUE)
[16:21:51.583]                         if (has_future) {
[16:21:51.583]                           ns <- base::getNamespace("future")
[16:21:51.583]                           version <- ns[[".package"]][["version"]]
[16:21:51.583]                           if (is.null(version)) 
[16:21:51.583]                             version <- utils::packageVersion("future")
[16:21:51.583]                         }
[16:21:51.583]                         else {
[16:21:51.583]                           version <- NULL
[16:21:51.583]                         }
[16:21:51.583]                         if (!has_future || version < "1.8.0") {
[16:21:51.583]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.583]                             "", base::R.version$version.string), 
[16:21:51.583]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.583]                               "release", "version")], collapse = " "), 
[16:21:51.583]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.583]                             info)
[16:21:51.583]                           info <- base::paste(info, collapse = "; ")
[16:21:51.583]                           if (!has_future) {
[16:21:51.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.583]                               info)
[16:21:51.583]                           }
[16:21:51.583]                           else {
[16:21:51.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.583]                               info, version)
[16:21:51.583]                           }
[16:21:51.583]                           base::stop(msg)
[16:21:51.583]                         }
[16:21:51.583]                       })
[16:21:51.583]                     }
[16:21:51.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.583]                     base::options(mc.cores = 1L)
[16:21:51.583]                   }
[16:21:51.583]                   ...future.strategy.old <- future::plan("list")
[16:21:51.583]                   options(future.plan = NULL)
[16:21:51.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.583]                 }
[16:21:51.583]                 ...future.workdir <- getwd()
[16:21:51.583]             }
[16:21:51.583]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.583]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.583]         }
[16:21:51.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.583]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.583]             base::names(...future.oldOptions))
[16:21:51.583]     }
[16:21:51.583]     if (FALSE) {
[16:21:51.583]     }
[16:21:51.583]     else {
[16:21:51.583]         if (TRUE) {
[16:21:51.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.583]                 open = "w")
[16:21:51.583]         }
[16:21:51.583]         else {
[16:21:51.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.583]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.583]         }
[16:21:51.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.583]             base::sink(type = "output", split = FALSE)
[16:21:51.583]             base::close(...future.stdout)
[16:21:51.583]         }, add = TRUE)
[16:21:51.583]     }
[16:21:51.583]     ...future.frame <- base::sys.nframe()
[16:21:51.583]     ...future.conditions <- base::list()
[16:21:51.583]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.583]     if (FALSE) {
[16:21:51.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.583]     }
[16:21:51.583]     ...future.result <- base::tryCatch({
[16:21:51.583]         base::withCallingHandlers({
[16:21:51.583]             ...future.value <- base::withVisible(base::local({
[16:21:51.583]                 withCallingHandlers({
[16:21:51.583]                   1
[16:21:51.583]                 }, immediateCondition = function(cond) {
[16:21:51.583]                   save_rds <- function (object, pathname, ...) 
[16:21:51.583]                   {
[16:21:51.583]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.583]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.583]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.583]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.583]                         fi_tmp[["mtime"]])
[16:21:51.583]                     }
[16:21:51.583]                     tryCatch({
[16:21:51.583]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.583]                     }, error = function(ex) {
[16:21:51.583]                       msg <- conditionMessage(ex)
[16:21:51.583]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.583]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.583]                         fi_tmp[["mtime"]], msg)
[16:21:51.583]                       ex$message <- msg
[16:21:51.583]                       stop(ex)
[16:21:51.583]                     })
[16:21:51.583]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.583]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.583]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.583]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.583]                       fi <- file.info(pathname)
[16:21:51.583]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.583]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.583]                         fi[["size"]], fi[["mtime"]])
[16:21:51.583]                       stop(msg)
[16:21:51.583]                     }
[16:21:51.583]                     invisible(pathname)
[16:21:51.583]                   }
[16:21:51.583]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.583]                     rootPath = tempdir()) 
[16:21:51.583]                   {
[16:21:51.583]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.583]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.583]                       tmpdir = path, fileext = ".rds")
[16:21:51.583]                     save_rds(obj, file)
[16:21:51.583]                   }
[16:21:51.583]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.583]                   {
[16:21:51.583]                     inherits <- base::inherits
[16:21:51.583]                     invokeRestart <- base::invokeRestart
[16:21:51.583]                     is.null <- base::is.null
[16:21:51.583]                     muffled <- FALSE
[16:21:51.583]                     if (inherits(cond, "message")) {
[16:21:51.583]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.583]                       if (muffled) 
[16:21:51.583]                         invokeRestart("muffleMessage")
[16:21:51.583]                     }
[16:21:51.583]                     else if (inherits(cond, "warning")) {
[16:21:51.583]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.583]                       if (muffled) 
[16:21:51.583]                         invokeRestart("muffleWarning")
[16:21:51.583]                     }
[16:21:51.583]                     else if (inherits(cond, "condition")) {
[16:21:51.583]                       if (!is.null(pattern)) {
[16:21:51.583]                         computeRestarts <- base::computeRestarts
[16:21:51.583]                         grepl <- base::grepl
[16:21:51.583]                         restarts <- computeRestarts(cond)
[16:21:51.583]                         for (restart in restarts) {
[16:21:51.583]                           name <- restart$name
[16:21:51.583]                           if (is.null(name)) 
[16:21:51.583]                             next
[16:21:51.583]                           if (!grepl(pattern, name)) 
[16:21:51.583]                             next
[16:21:51.583]                           invokeRestart(restart)
[16:21:51.583]                           muffled <- TRUE
[16:21:51.583]                           break
[16:21:51.583]                         }
[16:21:51.583]                       }
[16:21:51.583]                     }
[16:21:51.583]                     invisible(muffled)
[16:21:51.583]                   }
[16:21:51.583]                   muffleCondition(cond)
[16:21:51.583]                 })
[16:21:51.583]             }))
[16:21:51.583]             future::FutureResult(value = ...future.value$value, 
[16:21:51.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.583]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.583]                     ...future.globalenv.names))
[16:21:51.583]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.583]         }, condition = base::local({
[16:21:51.583]             c <- base::c
[16:21:51.583]             inherits <- base::inherits
[16:21:51.583]             invokeRestart <- base::invokeRestart
[16:21:51.583]             length <- base::length
[16:21:51.583]             list <- base::list
[16:21:51.583]             seq.int <- base::seq.int
[16:21:51.583]             signalCondition <- base::signalCondition
[16:21:51.583]             sys.calls <- base::sys.calls
[16:21:51.583]             `[[` <- base::`[[`
[16:21:51.583]             `+` <- base::`+`
[16:21:51.583]             `<<-` <- base::`<<-`
[16:21:51.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.583]                   3L)]
[16:21:51.583]             }
[16:21:51.583]             function(cond) {
[16:21:51.583]                 is_error <- inherits(cond, "error")
[16:21:51.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.583]                   NULL)
[16:21:51.583]                 if (is_error) {
[16:21:51.583]                   sessionInformation <- function() {
[16:21:51.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.583]                       search = base::search(), system = base::Sys.info())
[16:21:51.583]                   }
[16:21:51.583]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.583]                     cond$call), session = sessionInformation(), 
[16:21:51.583]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.583]                   signalCondition(cond)
[16:21:51.583]                 }
[16:21:51.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.583]                 "immediateCondition"))) {
[16:21:51.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.583]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.583]                   if (TRUE && !signal) {
[16:21:51.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.583]                     {
[16:21:51.583]                       inherits <- base::inherits
[16:21:51.583]                       invokeRestart <- base::invokeRestart
[16:21:51.583]                       is.null <- base::is.null
[16:21:51.583]                       muffled <- FALSE
[16:21:51.583]                       if (inherits(cond, "message")) {
[16:21:51.583]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.583]                         if (muffled) 
[16:21:51.583]                           invokeRestart("muffleMessage")
[16:21:51.583]                       }
[16:21:51.583]                       else if (inherits(cond, "warning")) {
[16:21:51.583]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.583]                         if (muffled) 
[16:21:51.583]                           invokeRestart("muffleWarning")
[16:21:51.583]                       }
[16:21:51.583]                       else if (inherits(cond, "condition")) {
[16:21:51.583]                         if (!is.null(pattern)) {
[16:21:51.583]                           computeRestarts <- base::computeRestarts
[16:21:51.583]                           grepl <- base::grepl
[16:21:51.583]                           restarts <- computeRestarts(cond)
[16:21:51.583]                           for (restart in restarts) {
[16:21:51.583]                             name <- restart$name
[16:21:51.583]                             if (is.null(name)) 
[16:21:51.583]                               next
[16:21:51.583]                             if (!grepl(pattern, name)) 
[16:21:51.583]                               next
[16:21:51.583]                             invokeRestart(restart)
[16:21:51.583]                             muffled <- TRUE
[16:21:51.583]                             break
[16:21:51.583]                           }
[16:21:51.583]                         }
[16:21:51.583]                       }
[16:21:51.583]                       invisible(muffled)
[16:21:51.583]                     }
[16:21:51.583]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.583]                   }
[16:21:51.583]                 }
[16:21:51.583]                 else {
[16:21:51.583]                   if (TRUE) {
[16:21:51.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.583]                     {
[16:21:51.583]                       inherits <- base::inherits
[16:21:51.583]                       invokeRestart <- base::invokeRestart
[16:21:51.583]                       is.null <- base::is.null
[16:21:51.583]                       muffled <- FALSE
[16:21:51.583]                       if (inherits(cond, "message")) {
[16:21:51.583]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.583]                         if (muffled) 
[16:21:51.583]                           invokeRestart("muffleMessage")
[16:21:51.583]                       }
[16:21:51.583]                       else if (inherits(cond, "warning")) {
[16:21:51.583]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.583]                         if (muffled) 
[16:21:51.583]                           invokeRestart("muffleWarning")
[16:21:51.583]                       }
[16:21:51.583]                       else if (inherits(cond, "condition")) {
[16:21:51.583]                         if (!is.null(pattern)) {
[16:21:51.583]                           computeRestarts <- base::computeRestarts
[16:21:51.583]                           grepl <- base::grepl
[16:21:51.583]                           restarts <- computeRestarts(cond)
[16:21:51.583]                           for (restart in restarts) {
[16:21:51.583]                             name <- restart$name
[16:21:51.583]                             if (is.null(name)) 
[16:21:51.583]                               next
[16:21:51.583]                             if (!grepl(pattern, name)) 
[16:21:51.583]                               next
[16:21:51.583]                             invokeRestart(restart)
[16:21:51.583]                             muffled <- TRUE
[16:21:51.583]                             break
[16:21:51.583]                           }
[16:21:51.583]                         }
[16:21:51.583]                       }
[16:21:51.583]                       invisible(muffled)
[16:21:51.583]                     }
[16:21:51.583]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.583]                   }
[16:21:51.583]                 }
[16:21:51.583]             }
[16:21:51.583]         }))
[16:21:51.583]     }, error = function(ex) {
[16:21:51.583]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.583]                 ...future.rng), started = ...future.startTime, 
[16:21:51.583]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.583]             version = "1.8"), class = "FutureResult")
[16:21:51.583]     }, finally = {
[16:21:51.583]         if (!identical(...future.workdir, getwd())) 
[16:21:51.583]             setwd(...future.workdir)
[16:21:51.583]         {
[16:21:51.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.583]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.583]             }
[16:21:51.583]             base::options(...future.oldOptions)
[16:21:51.583]             if (.Platform$OS.type == "windows") {
[16:21:51.583]                 old_names <- names(...future.oldEnvVars)
[16:21:51.583]                 envs <- base::Sys.getenv()
[16:21:51.583]                 names <- names(envs)
[16:21:51.583]                 common <- intersect(names, old_names)
[16:21:51.583]                 added <- setdiff(names, old_names)
[16:21:51.583]                 removed <- setdiff(old_names, names)
[16:21:51.583]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.583]                   envs[common]]
[16:21:51.583]                 NAMES <- toupper(changed)
[16:21:51.583]                 args <- list()
[16:21:51.583]                 for (kk in seq_along(NAMES)) {
[16:21:51.583]                   name <- changed[[kk]]
[16:21:51.583]                   NAME <- NAMES[[kk]]
[16:21:51.583]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.583]                     next
[16:21:51.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.583]                 }
[16:21:51.583]                 NAMES <- toupper(added)
[16:21:51.583]                 for (kk in seq_along(NAMES)) {
[16:21:51.583]                   name <- added[[kk]]
[16:21:51.583]                   NAME <- NAMES[[kk]]
[16:21:51.583]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.583]                     next
[16:21:51.583]                   args[[name]] <- ""
[16:21:51.583]                 }
[16:21:51.583]                 NAMES <- toupper(removed)
[16:21:51.583]                 for (kk in seq_along(NAMES)) {
[16:21:51.583]                   name <- removed[[kk]]
[16:21:51.583]                   NAME <- NAMES[[kk]]
[16:21:51.583]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.583]                     next
[16:21:51.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.583]                 }
[16:21:51.583]                 if (length(args) > 0) 
[16:21:51.583]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.583]             }
[16:21:51.583]             else {
[16:21:51.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.583]             }
[16:21:51.583]             {
[16:21:51.583]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.583]                   0L) {
[16:21:51.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.583]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.583]                   base::options(opts)
[16:21:51.583]                 }
[16:21:51.583]                 {
[16:21:51.583]                   {
[16:21:51.583]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.583]                     NULL
[16:21:51.583]                   }
[16:21:51.583]                   options(future.plan = NULL)
[16:21:51.583]                   if (is.na(NA_character_)) 
[16:21:51.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.583]                     .init = FALSE)
[16:21:51.583]                 }
[16:21:51.583]             }
[16:21:51.583]         }
[16:21:51.583]     })
[16:21:51.583]     if (TRUE) {
[16:21:51.583]         base::sink(type = "output", split = FALSE)
[16:21:51.583]         if (TRUE) {
[16:21:51.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.583]         }
[16:21:51.583]         else {
[16:21:51.583]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.583]         }
[16:21:51.583]         base::close(...future.stdout)
[16:21:51.583]         ...future.stdout <- NULL
[16:21:51.583]     }
[16:21:51.583]     ...future.result$conditions <- ...future.conditions
[16:21:51.583]     ...future.result$finished <- base::Sys.time()
[16:21:51.583]     ...future.result
[16:21:51.583] }
[16:21:51.587] requestCore(): workers = 2
[16:21:51.587] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:51.598] result() for MulticoreFuture ...
[16:21:51.599] result() for MulticoreFuture ...
[16:21:51.599] result() for MulticoreFuture ... done
[16:21:51.599] result() for MulticoreFuture ... done
[16:21:51.599] result() for MulticoreFuture ...
[16:21:51.599] result() for MulticoreFuture ... done
[16:21:51.602] MulticoreFuture started
[16:21:51.602] - Launch lazy future ... done
[16:21:51.603] run() for ‘MulticoreFuture’ ... done
[16:21:51.603] plan(): Setting new future strategy stack:
[16:21:51.604] List of future strategies:
[16:21:51.604] 1. sequential:
[16:21:51.604]    - args: function (..., envir = parent.frame())
[16:21:51.604]    - tweaked: FALSE
[16:21:51.604]    - call: NULL
[16:21:51.605] plan(): nbrOfWorkers() = 1
[16:21:51.607] plan(): Setting new future strategy stack:
[16:21:51.608] List of future strategies:
[16:21:51.608] 1. multicore:
[16:21:51.608]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.608]    - tweaked: FALSE
[16:21:51.608]    - call: plan(strategy)
[16:21:51.613] plan(): nbrOfWorkers() = 2
[16:21:51.614] run() for ‘Future’ ...
[16:21:51.614] - state: ‘created’
[16:21:51.614] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.619] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.619]   - Field: ‘label’
[16:21:51.620]   - Field: ‘local’
[16:21:51.620]   - Field: ‘owner’
[16:21:51.620]   - Field: ‘envir’
[16:21:51.620]   - Field: ‘workers’
[16:21:51.620]   - Field: ‘packages’
[16:21:51.620]   - Field: ‘gc’
[16:21:51.621]   - Field: ‘job’
[16:21:51.621]   - Field: ‘conditions’
[16:21:51.621]   - Field: ‘expr’
[16:21:51.621]   - Field: ‘uuid’
[16:21:51.621]   - Field: ‘seed’
[16:21:51.621]   - Field: ‘version’
[16:21:51.622]   - Field: ‘result’
[16:21:51.622]   - Field: ‘asynchronous’
[16:21:51.622]   - Field: ‘calls’
[16:21:51.622]   - Field: ‘globals’
[16:21:51.622]   - Field: ‘stdout’
[16:21:51.622]   - Field: ‘earlySignal’
[16:21:51.622]   - Field: ‘lazy’
[16:21:51.623]   - Field: ‘state’
[16:21:51.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.623] - Launch lazy future ...
[16:21:51.623] Packages needed by the future expression (n = 0): <none>
[16:21:51.624] Packages needed by future strategies (n = 0): <none>
[16:21:51.624] {
[16:21:51.624]     {
[16:21:51.624]         {
[16:21:51.624]             ...future.startTime <- base::Sys.time()
[16:21:51.624]             {
[16:21:51.624]                 {
[16:21:51.624]                   {
[16:21:51.624]                     {
[16:21:51.624]                       base::local({
[16:21:51.624]                         has_future <- base::requireNamespace("future", 
[16:21:51.624]                           quietly = TRUE)
[16:21:51.624]                         if (has_future) {
[16:21:51.624]                           ns <- base::getNamespace("future")
[16:21:51.624]                           version <- ns[[".package"]][["version"]]
[16:21:51.624]                           if (is.null(version)) 
[16:21:51.624]                             version <- utils::packageVersion("future")
[16:21:51.624]                         }
[16:21:51.624]                         else {
[16:21:51.624]                           version <- NULL
[16:21:51.624]                         }
[16:21:51.624]                         if (!has_future || version < "1.8.0") {
[16:21:51.624]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.624]                             "", base::R.version$version.string), 
[16:21:51.624]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.624]                               "release", "version")], collapse = " "), 
[16:21:51.624]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.624]                             info)
[16:21:51.624]                           info <- base::paste(info, collapse = "; ")
[16:21:51.624]                           if (!has_future) {
[16:21:51.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.624]                               info)
[16:21:51.624]                           }
[16:21:51.624]                           else {
[16:21:51.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.624]                               info, version)
[16:21:51.624]                           }
[16:21:51.624]                           base::stop(msg)
[16:21:51.624]                         }
[16:21:51.624]                       })
[16:21:51.624]                     }
[16:21:51.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.624]                     base::options(mc.cores = 1L)
[16:21:51.624]                   }
[16:21:51.624]                   ...future.strategy.old <- future::plan("list")
[16:21:51.624]                   options(future.plan = NULL)
[16:21:51.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.624]                 }
[16:21:51.624]                 ...future.workdir <- getwd()
[16:21:51.624]             }
[16:21:51.624]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.624]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.624]         }
[16:21:51.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.624]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.624]             base::names(...future.oldOptions))
[16:21:51.624]     }
[16:21:51.624]     if (FALSE) {
[16:21:51.624]     }
[16:21:51.624]     else {
[16:21:51.624]         if (TRUE) {
[16:21:51.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.624]                 open = "w")
[16:21:51.624]         }
[16:21:51.624]         else {
[16:21:51.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.624]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.624]         }
[16:21:51.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.624]             base::sink(type = "output", split = FALSE)
[16:21:51.624]             base::close(...future.stdout)
[16:21:51.624]         }, add = TRUE)
[16:21:51.624]     }
[16:21:51.624]     ...future.frame <- base::sys.nframe()
[16:21:51.624]     ...future.conditions <- base::list()
[16:21:51.624]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.624]     if (FALSE) {
[16:21:51.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.624]     }
[16:21:51.624]     ...future.result <- base::tryCatch({
[16:21:51.624]         base::withCallingHandlers({
[16:21:51.624]             ...future.value <- base::withVisible(base::local({
[16:21:51.624]                 withCallingHandlers({
[16:21:51.624]                   2
[16:21:51.624]                 }, immediateCondition = function(cond) {
[16:21:51.624]                   save_rds <- function (object, pathname, ...) 
[16:21:51.624]                   {
[16:21:51.624]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.624]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.624]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.624]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.624]                         fi_tmp[["mtime"]])
[16:21:51.624]                     }
[16:21:51.624]                     tryCatch({
[16:21:51.624]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.624]                     }, error = function(ex) {
[16:21:51.624]                       msg <- conditionMessage(ex)
[16:21:51.624]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.624]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.624]                         fi_tmp[["mtime"]], msg)
[16:21:51.624]                       ex$message <- msg
[16:21:51.624]                       stop(ex)
[16:21:51.624]                     })
[16:21:51.624]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.624]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.624]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.624]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.624]                       fi <- file.info(pathname)
[16:21:51.624]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.624]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.624]                         fi[["size"]], fi[["mtime"]])
[16:21:51.624]                       stop(msg)
[16:21:51.624]                     }
[16:21:51.624]                     invisible(pathname)
[16:21:51.624]                   }
[16:21:51.624]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.624]                     rootPath = tempdir()) 
[16:21:51.624]                   {
[16:21:51.624]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.624]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.624]                       tmpdir = path, fileext = ".rds")
[16:21:51.624]                     save_rds(obj, file)
[16:21:51.624]                   }
[16:21:51.624]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.624]                   {
[16:21:51.624]                     inherits <- base::inherits
[16:21:51.624]                     invokeRestart <- base::invokeRestart
[16:21:51.624]                     is.null <- base::is.null
[16:21:51.624]                     muffled <- FALSE
[16:21:51.624]                     if (inherits(cond, "message")) {
[16:21:51.624]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.624]                       if (muffled) 
[16:21:51.624]                         invokeRestart("muffleMessage")
[16:21:51.624]                     }
[16:21:51.624]                     else if (inherits(cond, "warning")) {
[16:21:51.624]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.624]                       if (muffled) 
[16:21:51.624]                         invokeRestart("muffleWarning")
[16:21:51.624]                     }
[16:21:51.624]                     else if (inherits(cond, "condition")) {
[16:21:51.624]                       if (!is.null(pattern)) {
[16:21:51.624]                         computeRestarts <- base::computeRestarts
[16:21:51.624]                         grepl <- base::grepl
[16:21:51.624]                         restarts <- computeRestarts(cond)
[16:21:51.624]                         for (restart in restarts) {
[16:21:51.624]                           name <- restart$name
[16:21:51.624]                           if (is.null(name)) 
[16:21:51.624]                             next
[16:21:51.624]                           if (!grepl(pattern, name)) 
[16:21:51.624]                             next
[16:21:51.624]                           invokeRestart(restart)
[16:21:51.624]                           muffled <- TRUE
[16:21:51.624]                           break
[16:21:51.624]                         }
[16:21:51.624]                       }
[16:21:51.624]                     }
[16:21:51.624]                     invisible(muffled)
[16:21:51.624]                   }
[16:21:51.624]                   muffleCondition(cond)
[16:21:51.624]                 })
[16:21:51.624]             }))
[16:21:51.624]             future::FutureResult(value = ...future.value$value, 
[16:21:51.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.624]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.624]                     ...future.globalenv.names))
[16:21:51.624]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.624]         }, condition = base::local({
[16:21:51.624]             c <- base::c
[16:21:51.624]             inherits <- base::inherits
[16:21:51.624]             invokeRestart <- base::invokeRestart
[16:21:51.624]             length <- base::length
[16:21:51.624]             list <- base::list
[16:21:51.624]             seq.int <- base::seq.int
[16:21:51.624]             signalCondition <- base::signalCondition
[16:21:51.624]             sys.calls <- base::sys.calls
[16:21:51.624]             `[[` <- base::`[[`
[16:21:51.624]             `+` <- base::`+`
[16:21:51.624]             `<<-` <- base::`<<-`
[16:21:51.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.624]                   3L)]
[16:21:51.624]             }
[16:21:51.624]             function(cond) {
[16:21:51.624]                 is_error <- inherits(cond, "error")
[16:21:51.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.624]                   NULL)
[16:21:51.624]                 if (is_error) {
[16:21:51.624]                   sessionInformation <- function() {
[16:21:51.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.624]                       search = base::search(), system = base::Sys.info())
[16:21:51.624]                   }
[16:21:51.624]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.624]                     cond$call), session = sessionInformation(), 
[16:21:51.624]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.624]                   signalCondition(cond)
[16:21:51.624]                 }
[16:21:51.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.624]                 "immediateCondition"))) {
[16:21:51.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.624]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.624]                   if (TRUE && !signal) {
[16:21:51.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.624]                     {
[16:21:51.624]                       inherits <- base::inherits
[16:21:51.624]                       invokeRestart <- base::invokeRestart
[16:21:51.624]                       is.null <- base::is.null
[16:21:51.624]                       muffled <- FALSE
[16:21:51.624]                       if (inherits(cond, "message")) {
[16:21:51.624]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.624]                         if (muffled) 
[16:21:51.624]                           invokeRestart("muffleMessage")
[16:21:51.624]                       }
[16:21:51.624]                       else if (inherits(cond, "warning")) {
[16:21:51.624]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.624]                         if (muffled) 
[16:21:51.624]                           invokeRestart("muffleWarning")
[16:21:51.624]                       }
[16:21:51.624]                       else if (inherits(cond, "condition")) {
[16:21:51.624]                         if (!is.null(pattern)) {
[16:21:51.624]                           computeRestarts <- base::computeRestarts
[16:21:51.624]                           grepl <- base::grepl
[16:21:51.624]                           restarts <- computeRestarts(cond)
[16:21:51.624]                           for (restart in restarts) {
[16:21:51.624]                             name <- restart$name
[16:21:51.624]                             if (is.null(name)) 
[16:21:51.624]                               next
[16:21:51.624]                             if (!grepl(pattern, name)) 
[16:21:51.624]                               next
[16:21:51.624]                             invokeRestart(restart)
[16:21:51.624]                             muffled <- TRUE
[16:21:51.624]                             break
[16:21:51.624]                           }
[16:21:51.624]                         }
[16:21:51.624]                       }
[16:21:51.624]                       invisible(muffled)
[16:21:51.624]                     }
[16:21:51.624]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.624]                   }
[16:21:51.624]                 }
[16:21:51.624]                 else {
[16:21:51.624]                   if (TRUE) {
[16:21:51.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.624]                     {
[16:21:51.624]                       inherits <- base::inherits
[16:21:51.624]                       invokeRestart <- base::invokeRestart
[16:21:51.624]                       is.null <- base::is.null
[16:21:51.624]                       muffled <- FALSE
[16:21:51.624]                       if (inherits(cond, "message")) {
[16:21:51.624]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.624]                         if (muffled) 
[16:21:51.624]                           invokeRestart("muffleMessage")
[16:21:51.624]                       }
[16:21:51.624]                       else if (inherits(cond, "warning")) {
[16:21:51.624]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.624]                         if (muffled) 
[16:21:51.624]                           invokeRestart("muffleWarning")
[16:21:51.624]                       }
[16:21:51.624]                       else if (inherits(cond, "condition")) {
[16:21:51.624]                         if (!is.null(pattern)) {
[16:21:51.624]                           computeRestarts <- base::computeRestarts
[16:21:51.624]                           grepl <- base::grepl
[16:21:51.624]                           restarts <- computeRestarts(cond)
[16:21:51.624]                           for (restart in restarts) {
[16:21:51.624]                             name <- restart$name
[16:21:51.624]                             if (is.null(name)) 
[16:21:51.624]                               next
[16:21:51.624]                             if (!grepl(pattern, name)) 
[16:21:51.624]                               next
[16:21:51.624]                             invokeRestart(restart)
[16:21:51.624]                             muffled <- TRUE
[16:21:51.624]                             break
[16:21:51.624]                           }
[16:21:51.624]                         }
[16:21:51.624]                       }
[16:21:51.624]                       invisible(muffled)
[16:21:51.624]                     }
[16:21:51.624]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.624]                   }
[16:21:51.624]                 }
[16:21:51.624]             }
[16:21:51.624]         }))
[16:21:51.624]     }, error = function(ex) {
[16:21:51.624]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.624]                 ...future.rng), started = ...future.startTime, 
[16:21:51.624]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.624]             version = "1.8"), class = "FutureResult")
[16:21:51.624]     }, finally = {
[16:21:51.624]         if (!identical(...future.workdir, getwd())) 
[16:21:51.624]             setwd(...future.workdir)
[16:21:51.624]         {
[16:21:51.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.624]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.624]             }
[16:21:51.624]             base::options(...future.oldOptions)
[16:21:51.624]             if (.Platform$OS.type == "windows") {
[16:21:51.624]                 old_names <- names(...future.oldEnvVars)
[16:21:51.624]                 envs <- base::Sys.getenv()
[16:21:51.624]                 names <- names(envs)
[16:21:51.624]                 common <- intersect(names, old_names)
[16:21:51.624]                 added <- setdiff(names, old_names)
[16:21:51.624]                 removed <- setdiff(old_names, names)
[16:21:51.624]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.624]                   envs[common]]
[16:21:51.624]                 NAMES <- toupper(changed)
[16:21:51.624]                 args <- list()
[16:21:51.624]                 for (kk in seq_along(NAMES)) {
[16:21:51.624]                   name <- changed[[kk]]
[16:21:51.624]                   NAME <- NAMES[[kk]]
[16:21:51.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.624]                     next
[16:21:51.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.624]                 }
[16:21:51.624]                 NAMES <- toupper(added)
[16:21:51.624]                 for (kk in seq_along(NAMES)) {
[16:21:51.624]                   name <- added[[kk]]
[16:21:51.624]                   NAME <- NAMES[[kk]]
[16:21:51.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.624]                     next
[16:21:51.624]                   args[[name]] <- ""
[16:21:51.624]                 }
[16:21:51.624]                 NAMES <- toupper(removed)
[16:21:51.624]                 for (kk in seq_along(NAMES)) {
[16:21:51.624]                   name <- removed[[kk]]
[16:21:51.624]                   NAME <- NAMES[[kk]]
[16:21:51.624]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.624]                     next
[16:21:51.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.624]                 }
[16:21:51.624]                 if (length(args) > 0) 
[16:21:51.624]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.624]             }
[16:21:51.624]             else {
[16:21:51.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.624]             }
[16:21:51.624]             {
[16:21:51.624]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.624]                   0L) {
[16:21:51.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.624]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.624]                   base::options(opts)
[16:21:51.624]                 }
[16:21:51.624]                 {
[16:21:51.624]                   {
[16:21:51.624]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.624]                     NULL
[16:21:51.624]                   }
[16:21:51.624]                   options(future.plan = NULL)
[16:21:51.624]                   if (is.na(NA_character_)) 
[16:21:51.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.624]                     .init = FALSE)
[16:21:51.624]                 }
[16:21:51.624]             }
[16:21:51.624]         }
[16:21:51.624]     })
[16:21:51.624]     if (TRUE) {
[16:21:51.624]         base::sink(type = "output", split = FALSE)
[16:21:51.624]         if (TRUE) {
[16:21:51.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.624]         }
[16:21:51.624]         else {
[16:21:51.624]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.624]         }
[16:21:51.624]         base::close(...future.stdout)
[16:21:51.624]         ...future.stdout <- NULL
[16:21:51.624]     }
[16:21:51.624]     ...future.result$conditions <- ...future.conditions
[16:21:51.624]     ...future.result$finished <- base::Sys.time()
[16:21:51.624]     ...future.result
[16:21:51.624] }
[16:21:51.628] requestCore(): workers = 2
[16:21:51.628] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:51.639] result() for MulticoreFuture ...
[16:21:51.640] result() for MulticoreFuture ...
[16:21:51.640] result() for MulticoreFuture ... done
[16:21:51.640] result() for MulticoreFuture ... done
[16:21:51.641] result() for MulticoreFuture ...
[16:21:51.641] result() for MulticoreFuture ... done
[16:21:51.643] MulticoreFuture started
[16:21:51.644] - Launch lazy future ... done
[16:21:51.644] run() for ‘MulticoreFuture’ ... done
[16:21:51.645] plan(): Setting new future strategy stack:
[16:21:51.645] List of future strategies:
[16:21:51.645] 1. sequential:
[16:21:51.645]    - args: function (..., envir = parent.frame())
[16:21:51.645]    - tweaked: FALSE
[16:21:51.645]    - call: NULL
[16:21:51.646] plan(): nbrOfWorkers() = 1
[16:21:51.648] plan(): Setting new future strategy stack:
[16:21:51.648] List of future strategies:
[16:21:51.648] 1. multicore:
[16:21:51.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.648]    - tweaked: FALSE
[16:21:51.648]    - call: plan(strategy)
[16:21:51.654] plan(): nbrOfWorkers() = 2
[16:21:51.654] Future #2
[16:21:51.655]  length: 2 (resolved future 2)
[16:21:51.655]  length: 1 (resolved future 3)
[16:21:51.665] Future #1
[16:21:51.665]  length: 0 (resolved future 1)
[16:21:51.666] resolve() on list ... DONE
[16:21:51.666] getGlobalsAndPackages() ...
[16:21:51.666] Searching for globals...
[16:21:51.667] 
[16:21:51.667] Searching for globals ... DONE
[16:21:51.668] - globals: [0] <none>
[16:21:51.668] getGlobalsAndPackages() ... DONE
[16:21:51.668] run() for ‘Future’ ...
[16:21:51.668] - state: ‘created’
[16:21:51.669] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.674]   - Field: ‘label’
[16:21:51.674]   - Field: ‘local’
[16:21:51.674]   - Field: ‘owner’
[16:21:51.674]   - Field: ‘envir’
[16:21:51.675]   - Field: ‘workers’
[16:21:51.675]   - Field: ‘packages’
[16:21:51.675]   - Field: ‘gc’
[16:21:51.675]   - Field: ‘job’
[16:21:51.675]   - Field: ‘conditions’
[16:21:51.675]   - Field: ‘expr’
[16:21:51.675]   - Field: ‘uuid’
[16:21:51.676]   - Field: ‘seed’
[16:21:51.676]   - Field: ‘version’
[16:21:51.676]   - Field: ‘result’
[16:21:51.676]   - Field: ‘asynchronous’
[16:21:51.676]   - Field: ‘calls’
[16:21:51.676]   - Field: ‘globals’
[16:21:51.677]   - Field: ‘stdout’
[16:21:51.677]   - Field: ‘earlySignal’
[16:21:51.677]   - Field: ‘lazy’
[16:21:51.677]   - Field: ‘state’
[16:21:51.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.677] - Launch lazy future ...
[16:21:51.682] Packages needed by the future expression (n = 0): <none>
[16:21:51.683] Packages needed by future strategies (n = 0): <none>
[16:21:51.684] {
[16:21:51.684]     {
[16:21:51.684]         {
[16:21:51.684]             ...future.startTime <- base::Sys.time()
[16:21:51.684]             {
[16:21:51.684]                 {
[16:21:51.684]                   {
[16:21:51.684]                     {
[16:21:51.684]                       base::local({
[16:21:51.684]                         has_future <- base::requireNamespace("future", 
[16:21:51.684]                           quietly = TRUE)
[16:21:51.684]                         if (has_future) {
[16:21:51.684]                           ns <- base::getNamespace("future")
[16:21:51.684]                           version <- ns[[".package"]][["version"]]
[16:21:51.684]                           if (is.null(version)) 
[16:21:51.684]                             version <- utils::packageVersion("future")
[16:21:51.684]                         }
[16:21:51.684]                         else {
[16:21:51.684]                           version <- NULL
[16:21:51.684]                         }
[16:21:51.684]                         if (!has_future || version < "1.8.0") {
[16:21:51.684]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.684]                             "", base::R.version$version.string), 
[16:21:51.684]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.684]                               "release", "version")], collapse = " "), 
[16:21:51.684]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.684]                             info)
[16:21:51.684]                           info <- base::paste(info, collapse = "; ")
[16:21:51.684]                           if (!has_future) {
[16:21:51.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.684]                               info)
[16:21:51.684]                           }
[16:21:51.684]                           else {
[16:21:51.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.684]                               info, version)
[16:21:51.684]                           }
[16:21:51.684]                           base::stop(msg)
[16:21:51.684]                         }
[16:21:51.684]                       })
[16:21:51.684]                     }
[16:21:51.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.684]                     base::options(mc.cores = 1L)
[16:21:51.684]                   }
[16:21:51.684]                   ...future.strategy.old <- future::plan("list")
[16:21:51.684]                   options(future.plan = NULL)
[16:21:51.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.684]                 }
[16:21:51.684]                 ...future.workdir <- getwd()
[16:21:51.684]             }
[16:21:51.684]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.684]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.684]         }
[16:21:51.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.684]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.684]             base::names(...future.oldOptions))
[16:21:51.684]     }
[16:21:51.684]     if (FALSE) {
[16:21:51.684]     }
[16:21:51.684]     else {
[16:21:51.684]         if (TRUE) {
[16:21:51.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.684]                 open = "w")
[16:21:51.684]         }
[16:21:51.684]         else {
[16:21:51.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.684]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.684]         }
[16:21:51.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.684]             base::sink(type = "output", split = FALSE)
[16:21:51.684]             base::close(...future.stdout)
[16:21:51.684]         }, add = TRUE)
[16:21:51.684]     }
[16:21:51.684]     ...future.frame <- base::sys.nframe()
[16:21:51.684]     ...future.conditions <- base::list()
[16:21:51.684]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.684]     if (FALSE) {
[16:21:51.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.684]     }
[16:21:51.684]     ...future.result <- base::tryCatch({
[16:21:51.684]         base::withCallingHandlers({
[16:21:51.684]             ...future.value <- base::withVisible(base::local({
[16:21:51.684]                 withCallingHandlers({
[16:21:51.684]                   1
[16:21:51.684]                 }, immediateCondition = function(cond) {
[16:21:51.684]                   save_rds <- function (object, pathname, ...) 
[16:21:51.684]                   {
[16:21:51.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.684]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.684]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.684]                         fi_tmp[["mtime"]])
[16:21:51.684]                     }
[16:21:51.684]                     tryCatch({
[16:21:51.684]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.684]                     }, error = function(ex) {
[16:21:51.684]                       msg <- conditionMessage(ex)
[16:21:51.684]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.684]                         fi_tmp[["mtime"]], msg)
[16:21:51.684]                       ex$message <- msg
[16:21:51.684]                       stop(ex)
[16:21:51.684]                     })
[16:21:51.684]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.684]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.684]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.684]                       fi <- file.info(pathname)
[16:21:51.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.684]                         fi[["size"]], fi[["mtime"]])
[16:21:51.684]                       stop(msg)
[16:21:51.684]                     }
[16:21:51.684]                     invisible(pathname)
[16:21:51.684]                   }
[16:21:51.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.684]                     rootPath = tempdir()) 
[16:21:51.684]                   {
[16:21:51.684]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.684]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.684]                       tmpdir = path, fileext = ".rds")
[16:21:51.684]                     save_rds(obj, file)
[16:21:51.684]                   }
[16:21:51.684]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.684]                   {
[16:21:51.684]                     inherits <- base::inherits
[16:21:51.684]                     invokeRestart <- base::invokeRestart
[16:21:51.684]                     is.null <- base::is.null
[16:21:51.684]                     muffled <- FALSE
[16:21:51.684]                     if (inherits(cond, "message")) {
[16:21:51.684]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.684]                       if (muffled) 
[16:21:51.684]                         invokeRestart("muffleMessage")
[16:21:51.684]                     }
[16:21:51.684]                     else if (inherits(cond, "warning")) {
[16:21:51.684]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.684]                       if (muffled) 
[16:21:51.684]                         invokeRestart("muffleWarning")
[16:21:51.684]                     }
[16:21:51.684]                     else if (inherits(cond, "condition")) {
[16:21:51.684]                       if (!is.null(pattern)) {
[16:21:51.684]                         computeRestarts <- base::computeRestarts
[16:21:51.684]                         grepl <- base::grepl
[16:21:51.684]                         restarts <- computeRestarts(cond)
[16:21:51.684]                         for (restart in restarts) {
[16:21:51.684]                           name <- restart$name
[16:21:51.684]                           if (is.null(name)) 
[16:21:51.684]                             next
[16:21:51.684]                           if (!grepl(pattern, name)) 
[16:21:51.684]                             next
[16:21:51.684]                           invokeRestart(restart)
[16:21:51.684]                           muffled <- TRUE
[16:21:51.684]                           break
[16:21:51.684]                         }
[16:21:51.684]                       }
[16:21:51.684]                     }
[16:21:51.684]                     invisible(muffled)
[16:21:51.684]                   }
[16:21:51.684]                   muffleCondition(cond)
[16:21:51.684]                 })
[16:21:51.684]             }))
[16:21:51.684]             future::FutureResult(value = ...future.value$value, 
[16:21:51.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.684]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.684]                     ...future.globalenv.names))
[16:21:51.684]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.684]         }, condition = base::local({
[16:21:51.684]             c <- base::c
[16:21:51.684]             inherits <- base::inherits
[16:21:51.684]             invokeRestart <- base::invokeRestart
[16:21:51.684]             length <- base::length
[16:21:51.684]             list <- base::list
[16:21:51.684]             seq.int <- base::seq.int
[16:21:51.684]             signalCondition <- base::signalCondition
[16:21:51.684]             sys.calls <- base::sys.calls
[16:21:51.684]             `[[` <- base::`[[`
[16:21:51.684]             `+` <- base::`+`
[16:21:51.684]             `<<-` <- base::`<<-`
[16:21:51.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.684]                   3L)]
[16:21:51.684]             }
[16:21:51.684]             function(cond) {
[16:21:51.684]                 is_error <- inherits(cond, "error")
[16:21:51.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.684]                   NULL)
[16:21:51.684]                 if (is_error) {
[16:21:51.684]                   sessionInformation <- function() {
[16:21:51.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.684]                       search = base::search(), system = base::Sys.info())
[16:21:51.684]                   }
[16:21:51.684]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.684]                     cond$call), session = sessionInformation(), 
[16:21:51.684]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.684]                   signalCondition(cond)
[16:21:51.684]                 }
[16:21:51.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.684]                 "immediateCondition"))) {
[16:21:51.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.684]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.684]                   if (TRUE && !signal) {
[16:21:51.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.684]                     {
[16:21:51.684]                       inherits <- base::inherits
[16:21:51.684]                       invokeRestart <- base::invokeRestart
[16:21:51.684]                       is.null <- base::is.null
[16:21:51.684]                       muffled <- FALSE
[16:21:51.684]                       if (inherits(cond, "message")) {
[16:21:51.684]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.684]                         if (muffled) 
[16:21:51.684]                           invokeRestart("muffleMessage")
[16:21:51.684]                       }
[16:21:51.684]                       else if (inherits(cond, "warning")) {
[16:21:51.684]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.684]                         if (muffled) 
[16:21:51.684]                           invokeRestart("muffleWarning")
[16:21:51.684]                       }
[16:21:51.684]                       else if (inherits(cond, "condition")) {
[16:21:51.684]                         if (!is.null(pattern)) {
[16:21:51.684]                           computeRestarts <- base::computeRestarts
[16:21:51.684]                           grepl <- base::grepl
[16:21:51.684]                           restarts <- computeRestarts(cond)
[16:21:51.684]                           for (restart in restarts) {
[16:21:51.684]                             name <- restart$name
[16:21:51.684]                             if (is.null(name)) 
[16:21:51.684]                               next
[16:21:51.684]                             if (!grepl(pattern, name)) 
[16:21:51.684]                               next
[16:21:51.684]                             invokeRestart(restart)
[16:21:51.684]                             muffled <- TRUE
[16:21:51.684]                             break
[16:21:51.684]                           }
[16:21:51.684]                         }
[16:21:51.684]                       }
[16:21:51.684]                       invisible(muffled)
[16:21:51.684]                     }
[16:21:51.684]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.684]                   }
[16:21:51.684]                 }
[16:21:51.684]                 else {
[16:21:51.684]                   if (TRUE) {
[16:21:51.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.684]                     {
[16:21:51.684]                       inherits <- base::inherits
[16:21:51.684]                       invokeRestart <- base::invokeRestart
[16:21:51.684]                       is.null <- base::is.null
[16:21:51.684]                       muffled <- FALSE
[16:21:51.684]                       if (inherits(cond, "message")) {
[16:21:51.684]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.684]                         if (muffled) 
[16:21:51.684]                           invokeRestart("muffleMessage")
[16:21:51.684]                       }
[16:21:51.684]                       else if (inherits(cond, "warning")) {
[16:21:51.684]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.684]                         if (muffled) 
[16:21:51.684]                           invokeRestart("muffleWarning")
[16:21:51.684]                       }
[16:21:51.684]                       else if (inherits(cond, "condition")) {
[16:21:51.684]                         if (!is.null(pattern)) {
[16:21:51.684]                           computeRestarts <- base::computeRestarts
[16:21:51.684]                           grepl <- base::grepl
[16:21:51.684]                           restarts <- computeRestarts(cond)
[16:21:51.684]                           for (restart in restarts) {
[16:21:51.684]                             name <- restart$name
[16:21:51.684]                             if (is.null(name)) 
[16:21:51.684]                               next
[16:21:51.684]                             if (!grepl(pattern, name)) 
[16:21:51.684]                               next
[16:21:51.684]                             invokeRestart(restart)
[16:21:51.684]                             muffled <- TRUE
[16:21:51.684]                             break
[16:21:51.684]                           }
[16:21:51.684]                         }
[16:21:51.684]                       }
[16:21:51.684]                       invisible(muffled)
[16:21:51.684]                     }
[16:21:51.684]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.684]                   }
[16:21:51.684]                 }
[16:21:51.684]             }
[16:21:51.684]         }))
[16:21:51.684]     }, error = function(ex) {
[16:21:51.684]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.684]                 ...future.rng), started = ...future.startTime, 
[16:21:51.684]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.684]             version = "1.8"), class = "FutureResult")
[16:21:51.684]     }, finally = {
[16:21:51.684]         if (!identical(...future.workdir, getwd())) 
[16:21:51.684]             setwd(...future.workdir)
[16:21:51.684]         {
[16:21:51.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.684]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.684]             }
[16:21:51.684]             base::options(...future.oldOptions)
[16:21:51.684]             if (.Platform$OS.type == "windows") {
[16:21:51.684]                 old_names <- names(...future.oldEnvVars)
[16:21:51.684]                 envs <- base::Sys.getenv()
[16:21:51.684]                 names <- names(envs)
[16:21:51.684]                 common <- intersect(names, old_names)
[16:21:51.684]                 added <- setdiff(names, old_names)
[16:21:51.684]                 removed <- setdiff(old_names, names)
[16:21:51.684]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.684]                   envs[common]]
[16:21:51.684]                 NAMES <- toupper(changed)
[16:21:51.684]                 args <- list()
[16:21:51.684]                 for (kk in seq_along(NAMES)) {
[16:21:51.684]                   name <- changed[[kk]]
[16:21:51.684]                   NAME <- NAMES[[kk]]
[16:21:51.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.684]                     next
[16:21:51.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.684]                 }
[16:21:51.684]                 NAMES <- toupper(added)
[16:21:51.684]                 for (kk in seq_along(NAMES)) {
[16:21:51.684]                   name <- added[[kk]]
[16:21:51.684]                   NAME <- NAMES[[kk]]
[16:21:51.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.684]                     next
[16:21:51.684]                   args[[name]] <- ""
[16:21:51.684]                 }
[16:21:51.684]                 NAMES <- toupper(removed)
[16:21:51.684]                 for (kk in seq_along(NAMES)) {
[16:21:51.684]                   name <- removed[[kk]]
[16:21:51.684]                   NAME <- NAMES[[kk]]
[16:21:51.684]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.684]                     next
[16:21:51.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.684]                 }
[16:21:51.684]                 if (length(args) > 0) 
[16:21:51.684]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.684]             }
[16:21:51.684]             else {
[16:21:51.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.684]             }
[16:21:51.684]             {
[16:21:51.684]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.684]                   0L) {
[16:21:51.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.684]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.684]                   base::options(opts)
[16:21:51.684]                 }
[16:21:51.684]                 {
[16:21:51.684]                   {
[16:21:51.684]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.684]                     NULL
[16:21:51.684]                   }
[16:21:51.684]                   options(future.plan = NULL)
[16:21:51.684]                   if (is.na(NA_character_)) 
[16:21:51.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.684]                     .init = FALSE)
[16:21:51.684]                 }
[16:21:51.684]             }
[16:21:51.684]         }
[16:21:51.684]     })
[16:21:51.684]     if (TRUE) {
[16:21:51.684]         base::sink(type = "output", split = FALSE)
[16:21:51.684]         if (TRUE) {
[16:21:51.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.684]         }
[16:21:51.684]         else {
[16:21:51.684]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.684]         }
[16:21:51.684]         base::close(...future.stdout)
[16:21:51.684]         ...future.stdout <- NULL
[16:21:51.684]     }
[16:21:51.684]     ...future.result$conditions <- ...future.conditions
[16:21:51.684]     ...future.result$finished <- base::Sys.time()
[16:21:51.684]     ...future.result
[16:21:51.684] }
[16:21:51.687] requestCore(): workers = 2
[16:21:51.688] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:51.699] result() for MulticoreFuture ...
[16:21:51.700] result() for MulticoreFuture ...
[16:21:51.700] result() for MulticoreFuture ... done
[16:21:51.701] result() for MulticoreFuture ... done
[16:21:51.701] result() for MulticoreFuture ...
[16:21:51.701] result() for MulticoreFuture ... done
[16:21:51.704] MulticoreFuture started
[16:21:51.705] - Launch lazy future ... done
[16:21:51.705] run() for ‘MulticoreFuture’ ... done
[16:21:51.706] getGlobalsAndPackages() ...
[16:21:51.706] plan(): Setting new future strategy stack:
[16:21:51.706] Searching for globals...
[16:21:51.706] List of future strategies:
[16:21:51.706] 1. sequential:
[16:21:51.706]    - args: function (..., envir = parent.frame())
[16:21:51.706]    - tweaked: FALSE
[16:21:51.706]    - call: NULL
[16:21:51.707] plan(): nbrOfWorkers() = 1
[16:21:51.709] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:21:51.709] Searching for globals ... DONE
[16:21:51.709] plan(): Setting new future strategy stack:
[16:21:51.709] Resolving globals: FALSE
[16:21:51.710] List of future strategies:
[16:21:51.710] 1. multicore:
[16:21:51.710]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:51.710]    - tweaked: FALSE
[16:21:51.710]    - call: plan(strategy)
[16:21:51.710] 
[16:21:51.710] 
[16:21:51.711] getGlobalsAndPackages() ... DONE
[16:21:51.711] run() for ‘Future’ ...
[16:21:51.711] - state: ‘created’
[16:21:51.712] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:51.716] plan(): nbrOfWorkers() = 2
[16:21:51.717] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:51.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:51.717]   - Field: ‘label’
[16:21:51.717]   - Field: ‘local’
[16:21:51.718]   - Field: ‘owner’
[16:21:51.718]   - Field: ‘envir’
[16:21:51.718]   - Field: ‘workers’
[16:21:51.718]   - Field: ‘packages’
[16:21:51.718]   - Field: ‘gc’
[16:21:51.718]   - Field: ‘job’
[16:21:51.719]   - Field: ‘conditions’
[16:21:51.719]   - Field: ‘expr’
[16:21:51.719]   - Field: ‘uuid’
[16:21:51.719]   - Field: ‘seed’
[16:21:51.719]   - Field: ‘version’
[16:21:51.719]   - Field: ‘result’
[16:21:51.719]   - Field: ‘asynchronous’
[16:21:51.720]   - Field: ‘calls’
[16:21:51.720]   - Field: ‘globals’
[16:21:51.720]   - Field: ‘stdout’
[16:21:51.720]   - Field: ‘earlySignal’
[16:21:51.720]   - Field: ‘lazy’
[16:21:51.720]   - Field: ‘state’
[16:21:51.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:51.721] - Launch lazy future ...
[16:21:51.721] Packages needed by the future expression (n = 0): <none>
[16:21:51.721] Packages needed by future strategies (n = 0): <none>
[16:21:51.722] {
[16:21:51.722]     {
[16:21:51.722]         {
[16:21:51.722]             ...future.startTime <- base::Sys.time()
[16:21:51.722]             {
[16:21:51.722]                 {
[16:21:51.722]                   {
[16:21:51.722]                     {
[16:21:51.722]                       base::local({
[16:21:51.722]                         has_future <- base::requireNamespace("future", 
[16:21:51.722]                           quietly = TRUE)
[16:21:51.722]                         if (has_future) {
[16:21:51.722]                           ns <- base::getNamespace("future")
[16:21:51.722]                           version <- ns[[".package"]][["version"]]
[16:21:51.722]                           if (is.null(version)) 
[16:21:51.722]                             version <- utils::packageVersion("future")
[16:21:51.722]                         }
[16:21:51.722]                         else {
[16:21:51.722]                           version <- NULL
[16:21:51.722]                         }
[16:21:51.722]                         if (!has_future || version < "1.8.0") {
[16:21:51.722]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:51.722]                             "", base::R.version$version.string), 
[16:21:51.722]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:51.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:51.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:51.722]                               "release", "version")], collapse = " "), 
[16:21:51.722]                             hostname = base::Sys.info()[["nodename"]])
[16:21:51.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:51.722]                             info)
[16:21:51.722]                           info <- base::paste(info, collapse = "; ")
[16:21:51.722]                           if (!has_future) {
[16:21:51.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:51.722]                               info)
[16:21:51.722]                           }
[16:21:51.722]                           else {
[16:21:51.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:51.722]                               info, version)
[16:21:51.722]                           }
[16:21:51.722]                           base::stop(msg)
[16:21:51.722]                         }
[16:21:51.722]                       })
[16:21:51.722]                     }
[16:21:51.722]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:51.722]                     base::options(mc.cores = 1L)
[16:21:51.722]                   }
[16:21:51.722]                   ...future.strategy.old <- future::plan("list")
[16:21:51.722]                   options(future.plan = NULL)
[16:21:51.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:51.722]                 }
[16:21:51.722]                 ...future.workdir <- getwd()
[16:21:51.722]             }
[16:21:51.722]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:51.722]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:51.722]         }
[16:21:51.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:51.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:51.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:51.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:51.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:51.722]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:51.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:51.722]             base::names(...future.oldOptions))
[16:21:51.722]     }
[16:21:51.722]     if (FALSE) {
[16:21:51.722]     }
[16:21:51.722]     else {
[16:21:51.722]         if (TRUE) {
[16:21:51.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:51.722]                 open = "w")
[16:21:51.722]         }
[16:21:51.722]         else {
[16:21:51.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:51.722]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:51.722]         }
[16:21:51.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:51.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:51.722]             base::sink(type = "output", split = FALSE)
[16:21:51.722]             base::close(...future.stdout)
[16:21:51.722]         }, add = TRUE)
[16:21:51.722]     }
[16:21:51.722]     ...future.frame <- base::sys.nframe()
[16:21:51.722]     ...future.conditions <- base::list()
[16:21:51.722]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:51.722]     if (FALSE) {
[16:21:51.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:51.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:51.722]     }
[16:21:51.722]     ...future.result <- base::tryCatch({
[16:21:51.722]         base::withCallingHandlers({
[16:21:51.722]             ...future.value <- base::withVisible(base::local({
[16:21:51.722]                 withCallingHandlers({
[16:21:51.722]                   {
[16:21:51.722]                     Sys.sleep(0.5)
[16:21:51.722]                     2
[16:21:51.722]                   }
[16:21:51.722]                 }, immediateCondition = function(cond) {
[16:21:51.722]                   save_rds <- function (object, pathname, ...) 
[16:21:51.722]                   {
[16:21:51.722]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:51.722]                     if (file_test("-f", pathname_tmp)) {
[16:21:51.722]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.722]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:51.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.722]                         fi_tmp[["mtime"]])
[16:21:51.722]                     }
[16:21:51.722]                     tryCatch({
[16:21:51.722]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:51.722]                     }, error = function(ex) {
[16:21:51.722]                       msg <- conditionMessage(ex)
[16:21:51.722]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.722]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:51.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.722]                         fi_tmp[["mtime"]], msg)
[16:21:51.722]                       ex$message <- msg
[16:21:51.722]                       stop(ex)
[16:21:51.722]                     })
[16:21:51.722]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:51.722]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:51.722]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:51.722]                       fi_tmp <- file.info(pathname_tmp)
[16:21:51.722]                       fi <- file.info(pathname)
[16:21:51.722]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:51.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:51.722]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:51.722]                         fi[["size"]], fi[["mtime"]])
[16:21:51.722]                       stop(msg)
[16:21:51.722]                     }
[16:21:51.722]                     invisible(pathname)
[16:21:51.722]                   }
[16:21:51.722]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:51.722]                     rootPath = tempdir()) 
[16:21:51.722]                   {
[16:21:51.722]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:51.722]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:51.722]                       tmpdir = path, fileext = ".rds")
[16:21:51.722]                     save_rds(obj, file)
[16:21:51.722]                   }
[16:21:51.722]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:51.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.722]                   {
[16:21:51.722]                     inherits <- base::inherits
[16:21:51.722]                     invokeRestart <- base::invokeRestart
[16:21:51.722]                     is.null <- base::is.null
[16:21:51.722]                     muffled <- FALSE
[16:21:51.722]                     if (inherits(cond, "message")) {
[16:21:51.722]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:51.722]                       if (muffled) 
[16:21:51.722]                         invokeRestart("muffleMessage")
[16:21:51.722]                     }
[16:21:51.722]                     else if (inherits(cond, "warning")) {
[16:21:51.722]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:51.722]                       if (muffled) 
[16:21:51.722]                         invokeRestart("muffleWarning")
[16:21:51.722]                     }
[16:21:51.722]                     else if (inherits(cond, "condition")) {
[16:21:51.722]                       if (!is.null(pattern)) {
[16:21:51.722]                         computeRestarts <- base::computeRestarts
[16:21:51.722]                         grepl <- base::grepl
[16:21:51.722]                         restarts <- computeRestarts(cond)
[16:21:51.722]                         for (restart in restarts) {
[16:21:51.722]                           name <- restart$name
[16:21:51.722]                           if (is.null(name)) 
[16:21:51.722]                             next
[16:21:51.722]                           if (!grepl(pattern, name)) 
[16:21:51.722]                             next
[16:21:51.722]                           invokeRestart(restart)
[16:21:51.722]                           muffled <- TRUE
[16:21:51.722]                           break
[16:21:51.722]                         }
[16:21:51.722]                       }
[16:21:51.722]                     }
[16:21:51.722]                     invisible(muffled)
[16:21:51.722]                   }
[16:21:51.722]                   muffleCondition(cond)
[16:21:51.722]                 })
[16:21:51.722]             }))
[16:21:51.722]             future::FutureResult(value = ...future.value$value, 
[16:21:51.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.722]                   ...future.rng), globalenv = if (FALSE) 
[16:21:51.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:51.722]                     ...future.globalenv.names))
[16:21:51.722]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:51.722]         }, condition = base::local({
[16:21:51.722]             c <- base::c
[16:21:51.722]             inherits <- base::inherits
[16:21:51.722]             invokeRestart <- base::invokeRestart
[16:21:51.722]             length <- base::length
[16:21:51.722]             list <- base::list
[16:21:51.722]             seq.int <- base::seq.int
[16:21:51.722]             signalCondition <- base::signalCondition
[16:21:51.722]             sys.calls <- base::sys.calls
[16:21:51.722]             `[[` <- base::`[[`
[16:21:51.722]             `+` <- base::`+`
[16:21:51.722]             `<<-` <- base::`<<-`
[16:21:51.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:51.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:51.722]                   3L)]
[16:21:51.722]             }
[16:21:51.722]             function(cond) {
[16:21:51.722]                 is_error <- inherits(cond, "error")
[16:21:51.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:51.722]                   NULL)
[16:21:51.722]                 if (is_error) {
[16:21:51.722]                   sessionInformation <- function() {
[16:21:51.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:51.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:51.722]                       search = base::search(), system = base::Sys.info())
[16:21:51.722]                   }
[16:21:51.722]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:51.722]                     cond$call), session = sessionInformation(), 
[16:21:51.722]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:51.722]                   signalCondition(cond)
[16:21:51.722]                 }
[16:21:51.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:51.722]                 "immediateCondition"))) {
[16:21:51.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:51.722]                   ...future.conditions[[length(...future.conditions) + 
[16:21:51.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:51.722]                   if (TRUE && !signal) {
[16:21:51.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.722]                     {
[16:21:51.722]                       inherits <- base::inherits
[16:21:51.722]                       invokeRestart <- base::invokeRestart
[16:21:51.722]                       is.null <- base::is.null
[16:21:51.722]                       muffled <- FALSE
[16:21:51.722]                       if (inherits(cond, "message")) {
[16:21:51.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.722]                         if (muffled) 
[16:21:51.722]                           invokeRestart("muffleMessage")
[16:21:51.722]                       }
[16:21:51.722]                       else if (inherits(cond, "warning")) {
[16:21:51.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.722]                         if (muffled) 
[16:21:51.722]                           invokeRestart("muffleWarning")
[16:21:51.722]                       }
[16:21:51.722]                       else if (inherits(cond, "condition")) {
[16:21:51.722]                         if (!is.null(pattern)) {
[16:21:51.722]                           computeRestarts <- base::computeRestarts
[16:21:51.722]                           grepl <- base::grepl
[16:21:51.722]                           restarts <- computeRestarts(cond)
[16:21:51.722]                           for (restart in restarts) {
[16:21:51.722]                             name <- restart$name
[16:21:51.722]                             if (is.null(name)) 
[16:21:51.722]                               next
[16:21:51.722]                             if (!grepl(pattern, name)) 
[16:21:51.722]                               next
[16:21:51.722]                             invokeRestart(restart)
[16:21:51.722]                             muffled <- TRUE
[16:21:51.722]                             break
[16:21:51.722]                           }
[16:21:51.722]                         }
[16:21:51.722]                       }
[16:21:51.722]                       invisible(muffled)
[16:21:51.722]                     }
[16:21:51.722]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.722]                   }
[16:21:51.722]                 }
[16:21:51.722]                 else {
[16:21:51.722]                   if (TRUE) {
[16:21:51.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:51.722]                     {
[16:21:51.722]                       inherits <- base::inherits
[16:21:51.722]                       invokeRestart <- base::invokeRestart
[16:21:51.722]                       is.null <- base::is.null
[16:21:51.722]                       muffled <- FALSE
[16:21:51.722]                       if (inherits(cond, "message")) {
[16:21:51.722]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:51.722]                         if (muffled) 
[16:21:51.722]                           invokeRestart("muffleMessage")
[16:21:51.722]                       }
[16:21:51.722]                       else if (inherits(cond, "warning")) {
[16:21:51.722]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:51.722]                         if (muffled) 
[16:21:51.722]                           invokeRestart("muffleWarning")
[16:21:51.722]                       }
[16:21:51.722]                       else if (inherits(cond, "condition")) {
[16:21:51.722]                         if (!is.null(pattern)) {
[16:21:51.722]                           computeRestarts <- base::computeRestarts
[16:21:51.722]                           grepl <- base::grepl
[16:21:51.722]                           restarts <- computeRestarts(cond)
[16:21:51.722]                           for (restart in restarts) {
[16:21:51.722]                             name <- restart$name
[16:21:51.722]                             if (is.null(name)) 
[16:21:51.722]                               next
[16:21:51.722]                             if (!grepl(pattern, name)) 
[16:21:51.722]                               next
[16:21:51.722]                             invokeRestart(restart)
[16:21:51.722]                             muffled <- TRUE
[16:21:51.722]                             break
[16:21:51.722]                           }
[16:21:51.722]                         }
[16:21:51.722]                       }
[16:21:51.722]                       invisible(muffled)
[16:21:51.722]                     }
[16:21:51.722]                     muffleCondition(cond, pattern = "^muffle")
[16:21:51.722]                   }
[16:21:51.722]                 }
[16:21:51.722]             }
[16:21:51.722]         }))
[16:21:51.722]     }, error = function(ex) {
[16:21:51.722]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:51.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:51.722]                 ...future.rng), started = ...future.startTime, 
[16:21:51.722]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:51.722]             version = "1.8"), class = "FutureResult")
[16:21:51.722]     }, finally = {
[16:21:51.722]         if (!identical(...future.workdir, getwd())) 
[16:21:51.722]             setwd(...future.workdir)
[16:21:51.722]         {
[16:21:51.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:51.722]                 ...future.oldOptions$nwarnings <- NULL
[16:21:51.722]             }
[16:21:51.722]             base::options(...future.oldOptions)
[16:21:51.722]             if (.Platform$OS.type == "windows") {
[16:21:51.722]                 old_names <- names(...future.oldEnvVars)
[16:21:51.722]                 envs <- base::Sys.getenv()
[16:21:51.722]                 names <- names(envs)
[16:21:51.722]                 common <- intersect(names, old_names)
[16:21:51.722]                 added <- setdiff(names, old_names)
[16:21:51.722]                 removed <- setdiff(old_names, names)
[16:21:51.722]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:51.722]                   envs[common]]
[16:21:51.722]                 NAMES <- toupper(changed)
[16:21:51.722]                 args <- list()
[16:21:51.722]                 for (kk in seq_along(NAMES)) {
[16:21:51.722]                   name <- changed[[kk]]
[16:21:51.722]                   NAME <- NAMES[[kk]]
[16:21:51.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.722]                     next
[16:21:51.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.722]                 }
[16:21:51.722]                 NAMES <- toupper(added)
[16:21:51.722]                 for (kk in seq_along(NAMES)) {
[16:21:51.722]                   name <- added[[kk]]
[16:21:51.722]                   NAME <- NAMES[[kk]]
[16:21:51.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.722]                     next
[16:21:51.722]                   args[[name]] <- ""
[16:21:51.722]                 }
[16:21:51.722]                 NAMES <- toupper(removed)
[16:21:51.722]                 for (kk in seq_along(NAMES)) {
[16:21:51.722]                   name <- removed[[kk]]
[16:21:51.722]                   NAME <- NAMES[[kk]]
[16:21:51.722]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:51.722]                     next
[16:21:51.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:51.722]                 }
[16:21:51.722]                 if (length(args) > 0) 
[16:21:51.722]                   base::do.call(base::Sys.setenv, args = args)
[16:21:51.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:51.722]             }
[16:21:51.722]             else {
[16:21:51.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:51.722]             }
[16:21:51.722]             {
[16:21:51.722]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:51.722]                   0L) {
[16:21:51.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:51.722]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:51.722]                   base::options(opts)
[16:21:51.722]                 }
[16:21:51.722]                 {
[16:21:51.722]                   {
[16:21:51.722]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:51.722]                     NULL
[16:21:51.722]                   }
[16:21:51.722]                   options(future.plan = NULL)
[16:21:51.722]                   if (is.na(NA_character_)) 
[16:21:51.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:51.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:51.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:51.722]                     .init = FALSE)
[16:21:51.722]                 }
[16:21:51.722]             }
[16:21:51.722]         }
[16:21:51.722]     })
[16:21:51.722]     if (TRUE) {
[16:21:51.722]         base::sink(type = "output", split = FALSE)
[16:21:51.722]         if (TRUE) {
[16:21:51.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:51.722]         }
[16:21:51.722]         else {
[16:21:51.722]             ...future.result["stdout"] <- base::list(NULL)
[16:21:51.722]         }
[16:21:51.722]         base::close(...future.stdout)
[16:21:51.722]         ...future.stdout <- NULL
[16:21:51.722]     }
[16:21:51.722]     ...future.result$conditions <- ...future.conditions
[16:21:51.722]     ...future.result$finished <- base::Sys.time()
[16:21:51.722]     ...future.result
[16:21:51.722] }
[16:21:51.726] requestCore(): workers = 2
[16:21:51.726] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:51.737] result() for MulticoreFuture ...
[16:21:51.738] result() for MulticoreFuture ...
[16:21:51.738] result() for MulticoreFuture ... done
[16:21:51.738] result() for MulticoreFuture ... done
[16:21:51.738] result() for MulticoreFuture ...
[16:21:51.739] result() for MulticoreFuture ... done
[16:21:51.742] MulticoreFuture started
[16:21:51.743] - Launch lazy future ... done
[16:21:51.743] run() for ‘MulticoreFuture’ ... done
[16:21:51.743] plan(): Setting new future strategy stack:
[16:21:51.744] resolve() on list ...
[16:21:51.744]  recursive: 0
[16:21:51.744]  length: 1
[16:21:51.744] 
[16:21:51.744] List of future strategies:
[16:21:51.744] 1. sequential:
[16:21:51.744]    - args: function (..., envir = parent.frame())
[16:21:51.744]    - tweaked: FALSE
[16:21:51.744]    - call: NULL
[16:21:51.745] plan(): nbrOfWorkers() = 1
[16:21:51.745] Future #1
[16:21:51.745]  length: 0 (resolved future 1)
[16:21:51.745] resolve() on list ... DONE
[16:21:51.746] resolve() on list ...
[16:21:51.746]  recursive: 0
[16:21:51.746]  length: 1
[16:21:51.746] 
[16:21:52.248] plan(): Setting new future strategy stack:
[16:21:52.248] List of future strategies:
[16:21:52.248] 1. multicore:
[16:21:52.248]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.248]    - tweaked: FALSE
[16:21:52.248]    - call: plan(strategy)
[16:21:52.253] plan(): nbrOfWorkers() = 2
[16:21:52.258] Future #1
[16:21:52.258]  length: 0 (resolved future 1)
[16:21:52.258] resolve() on list ... DONE
[16:21:52.259] resolve() on list ...
[16:21:52.259]  recursive: 0
[16:21:52.259]  length: 1
[16:21:52.259] 
[16:21:52.259]  length: 0 (resolved future 1)
[16:21:52.259] resolve() on list ... DONE
[16:21:52.260] resolve() on list ...
[16:21:52.260]  recursive: 0
[16:21:52.260]  length: 4
[16:21:52.260] 
[16:21:52.260] Future #1
[16:21:52.261]  length: 3 (resolved future 1)
[16:21:52.261] Future #2
[16:21:52.261]  length: 2 (resolved future 2)
[16:21:52.261]  length: 1 (resolved future 3)
[16:21:52.261]  length: 0 (resolved future 4)
[16:21:52.262] resolve() on list ... DONE
[16:21:52.262] resolve() on list ...
[16:21:52.262]  recursive: 0
[16:21:52.262]  length: 4
[16:21:52.262] 
[16:21:52.263] Future #1
[16:21:52.263]  length: 3 (resolved future 1)
[16:21:52.263] Future #2
[16:21:52.263]  length: 2 (resolved future 2)
[16:21:52.263]  length: 1 (resolved future 3)
[16:21:52.263]  length: 0 (resolved future 4)
[16:21:52.264] resolve() on list ... DONE
[16:21:52.264] resolve() on list ...
[16:21:52.264]  recursive: 0
[16:21:52.264]  length: 1
[16:21:52.264] 
[16:21:52.265]  length: 0 (resolved future 1)
[16:21:52.265] resolve() on list ... DONE
[16:21:52.265] getGlobalsAndPackages() ...
[16:21:52.265] Searching for globals...
[16:21:52.267] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:52.267] Searching for globals ... DONE
[16:21:52.267] Resolving globals: FALSE
[16:21:52.268] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:52.269] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:52.269] - globals: [1] ‘kk’
[16:21:52.269] 
[16:21:52.269] getGlobalsAndPackages() ... DONE
[16:21:52.270] run() for ‘Future’ ...
[16:21:52.270] - state: ‘created’
[16:21:52.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.278] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.279]   - Field: ‘label’
[16:21:52.279]   - Field: ‘local’
[16:21:52.279]   - Field: ‘owner’
[16:21:52.280]   - Field: ‘envir’
[16:21:52.280]   - Field: ‘workers’
[16:21:52.280]   - Field: ‘packages’
[16:21:52.280]   - Field: ‘gc’
[16:21:52.281]   - Field: ‘job’
[16:21:52.281]   - Field: ‘conditions’
[16:21:52.281]   - Field: ‘expr’
[16:21:52.281]   - Field: ‘uuid’
[16:21:52.282]   - Field: ‘seed’
[16:21:52.282]   - Field: ‘version’
[16:21:52.282]   - Field: ‘result’
[16:21:52.282]   - Field: ‘asynchronous’
[16:21:52.282]   - Field: ‘calls’
[16:21:52.282]   - Field: ‘globals’
[16:21:52.282]   - Field: ‘stdout’
[16:21:52.283]   - Field: ‘earlySignal’
[16:21:52.283]   - Field: ‘lazy’
[16:21:52.283]   - Field: ‘state’
[16:21:52.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.283] - Launch lazy future ...
[16:21:52.284] Packages needed by the future expression (n = 0): <none>
[16:21:52.284] Packages needed by future strategies (n = 0): <none>
[16:21:52.285] {
[16:21:52.285]     {
[16:21:52.285]         {
[16:21:52.285]             ...future.startTime <- base::Sys.time()
[16:21:52.285]             {
[16:21:52.285]                 {
[16:21:52.285]                   {
[16:21:52.285]                     {
[16:21:52.285]                       base::local({
[16:21:52.285]                         has_future <- base::requireNamespace("future", 
[16:21:52.285]                           quietly = TRUE)
[16:21:52.285]                         if (has_future) {
[16:21:52.285]                           ns <- base::getNamespace("future")
[16:21:52.285]                           version <- ns[[".package"]][["version"]]
[16:21:52.285]                           if (is.null(version)) 
[16:21:52.285]                             version <- utils::packageVersion("future")
[16:21:52.285]                         }
[16:21:52.285]                         else {
[16:21:52.285]                           version <- NULL
[16:21:52.285]                         }
[16:21:52.285]                         if (!has_future || version < "1.8.0") {
[16:21:52.285]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.285]                             "", base::R.version$version.string), 
[16:21:52.285]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.285]                               "release", "version")], collapse = " "), 
[16:21:52.285]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.285]                             info)
[16:21:52.285]                           info <- base::paste(info, collapse = "; ")
[16:21:52.285]                           if (!has_future) {
[16:21:52.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.285]                               info)
[16:21:52.285]                           }
[16:21:52.285]                           else {
[16:21:52.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.285]                               info, version)
[16:21:52.285]                           }
[16:21:52.285]                           base::stop(msg)
[16:21:52.285]                         }
[16:21:52.285]                       })
[16:21:52.285]                     }
[16:21:52.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.285]                     base::options(mc.cores = 1L)
[16:21:52.285]                   }
[16:21:52.285]                   ...future.strategy.old <- future::plan("list")
[16:21:52.285]                   options(future.plan = NULL)
[16:21:52.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.285]                 }
[16:21:52.285]                 ...future.workdir <- getwd()
[16:21:52.285]             }
[16:21:52.285]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.285]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.285]         }
[16:21:52.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.285]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.285]             base::names(...future.oldOptions))
[16:21:52.285]     }
[16:21:52.285]     if (FALSE) {
[16:21:52.285]     }
[16:21:52.285]     else {
[16:21:52.285]         if (TRUE) {
[16:21:52.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.285]                 open = "w")
[16:21:52.285]         }
[16:21:52.285]         else {
[16:21:52.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.285]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.285]         }
[16:21:52.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.285]             base::sink(type = "output", split = FALSE)
[16:21:52.285]             base::close(...future.stdout)
[16:21:52.285]         }, add = TRUE)
[16:21:52.285]     }
[16:21:52.285]     ...future.frame <- base::sys.nframe()
[16:21:52.285]     ...future.conditions <- base::list()
[16:21:52.285]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.285]     if (FALSE) {
[16:21:52.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.285]     }
[16:21:52.285]     ...future.result <- base::tryCatch({
[16:21:52.285]         base::withCallingHandlers({
[16:21:52.285]             ...future.value <- base::withVisible(base::local({
[16:21:52.285]                 withCallingHandlers({
[16:21:52.285]                   {
[16:21:52.285]                     Sys.sleep(0.1)
[16:21:52.285]                     kk
[16:21:52.285]                   }
[16:21:52.285]                 }, immediateCondition = function(cond) {
[16:21:52.285]                   save_rds <- function (object, pathname, ...) 
[16:21:52.285]                   {
[16:21:52.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.285]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.285]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.285]                         fi_tmp[["mtime"]])
[16:21:52.285]                     }
[16:21:52.285]                     tryCatch({
[16:21:52.285]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.285]                     }, error = function(ex) {
[16:21:52.285]                       msg <- conditionMessage(ex)
[16:21:52.285]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.285]                         fi_tmp[["mtime"]], msg)
[16:21:52.285]                       ex$message <- msg
[16:21:52.285]                       stop(ex)
[16:21:52.285]                     })
[16:21:52.285]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.285]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.285]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.285]                       fi <- file.info(pathname)
[16:21:52.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.285]                         fi[["size"]], fi[["mtime"]])
[16:21:52.285]                       stop(msg)
[16:21:52.285]                     }
[16:21:52.285]                     invisible(pathname)
[16:21:52.285]                   }
[16:21:52.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.285]                     rootPath = tempdir()) 
[16:21:52.285]                   {
[16:21:52.285]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.285]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.285]                       tmpdir = path, fileext = ".rds")
[16:21:52.285]                     save_rds(obj, file)
[16:21:52.285]                   }
[16:21:52.285]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.285]                   {
[16:21:52.285]                     inherits <- base::inherits
[16:21:52.285]                     invokeRestart <- base::invokeRestart
[16:21:52.285]                     is.null <- base::is.null
[16:21:52.285]                     muffled <- FALSE
[16:21:52.285]                     if (inherits(cond, "message")) {
[16:21:52.285]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.285]                       if (muffled) 
[16:21:52.285]                         invokeRestart("muffleMessage")
[16:21:52.285]                     }
[16:21:52.285]                     else if (inherits(cond, "warning")) {
[16:21:52.285]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.285]                       if (muffled) 
[16:21:52.285]                         invokeRestart("muffleWarning")
[16:21:52.285]                     }
[16:21:52.285]                     else if (inherits(cond, "condition")) {
[16:21:52.285]                       if (!is.null(pattern)) {
[16:21:52.285]                         computeRestarts <- base::computeRestarts
[16:21:52.285]                         grepl <- base::grepl
[16:21:52.285]                         restarts <- computeRestarts(cond)
[16:21:52.285]                         for (restart in restarts) {
[16:21:52.285]                           name <- restart$name
[16:21:52.285]                           if (is.null(name)) 
[16:21:52.285]                             next
[16:21:52.285]                           if (!grepl(pattern, name)) 
[16:21:52.285]                             next
[16:21:52.285]                           invokeRestart(restart)
[16:21:52.285]                           muffled <- TRUE
[16:21:52.285]                           break
[16:21:52.285]                         }
[16:21:52.285]                       }
[16:21:52.285]                     }
[16:21:52.285]                     invisible(muffled)
[16:21:52.285]                   }
[16:21:52.285]                   muffleCondition(cond)
[16:21:52.285]                 })
[16:21:52.285]             }))
[16:21:52.285]             future::FutureResult(value = ...future.value$value, 
[16:21:52.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.285]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.285]                     ...future.globalenv.names))
[16:21:52.285]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.285]         }, condition = base::local({
[16:21:52.285]             c <- base::c
[16:21:52.285]             inherits <- base::inherits
[16:21:52.285]             invokeRestart <- base::invokeRestart
[16:21:52.285]             length <- base::length
[16:21:52.285]             list <- base::list
[16:21:52.285]             seq.int <- base::seq.int
[16:21:52.285]             signalCondition <- base::signalCondition
[16:21:52.285]             sys.calls <- base::sys.calls
[16:21:52.285]             `[[` <- base::`[[`
[16:21:52.285]             `+` <- base::`+`
[16:21:52.285]             `<<-` <- base::`<<-`
[16:21:52.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.285]                   3L)]
[16:21:52.285]             }
[16:21:52.285]             function(cond) {
[16:21:52.285]                 is_error <- inherits(cond, "error")
[16:21:52.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.285]                   NULL)
[16:21:52.285]                 if (is_error) {
[16:21:52.285]                   sessionInformation <- function() {
[16:21:52.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.285]                       search = base::search(), system = base::Sys.info())
[16:21:52.285]                   }
[16:21:52.285]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.285]                     cond$call), session = sessionInformation(), 
[16:21:52.285]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.285]                   signalCondition(cond)
[16:21:52.285]                 }
[16:21:52.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.285]                 "immediateCondition"))) {
[16:21:52.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.285]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.285]                   if (TRUE && !signal) {
[16:21:52.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.285]                     {
[16:21:52.285]                       inherits <- base::inherits
[16:21:52.285]                       invokeRestart <- base::invokeRestart
[16:21:52.285]                       is.null <- base::is.null
[16:21:52.285]                       muffled <- FALSE
[16:21:52.285]                       if (inherits(cond, "message")) {
[16:21:52.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.285]                         if (muffled) 
[16:21:52.285]                           invokeRestart("muffleMessage")
[16:21:52.285]                       }
[16:21:52.285]                       else if (inherits(cond, "warning")) {
[16:21:52.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.285]                         if (muffled) 
[16:21:52.285]                           invokeRestart("muffleWarning")
[16:21:52.285]                       }
[16:21:52.285]                       else if (inherits(cond, "condition")) {
[16:21:52.285]                         if (!is.null(pattern)) {
[16:21:52.285]                           computeRestarts <- base::computeRestarts
[16:21:52.285]                           grepl <- base::grepl
[16:21:52.285]                           restarts <- computeRestarts(cond)
[16:21:52.285]                           for (restart in restarts) {
[16:21:52.285]                             name <- restart$name
[16:21:52.285]                             if (is.null(name)) 
[16:21:52.285]                               next
[16:21:52.285]                             if (!grepl(pattern, name)) 
[16:21:52.285]                               next
[16:21:52.285]                             invokeRestart(restart)
[16:21:52.285]                             muffled <- TRUE
[16:21:52.285]                             break
[16:21:52.285]                           }
[16:21:52.285]                         }
[16:21:52.285]                       }
[16:21:52.285]                       invisible(muffled)
[16:21:52.285]                     }
[16:21:52.285]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.285]                   }
[16:21:52.285]                 }
[16:21:52.285]                 else {
[16:21:52.285]                   if (TRUE) {
[16:21:52.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.285]                     {
[16:21:52.285]                       inherits <- base::inherits
[16:21:52.285]                       invokeRestart <- base::invokeRestart
[16:21:52.285]                       is.null <- base::is.null
[16:21:52.285]                       muffled <- FALSE
[16:21:52.285]                       if (inherits(cond, "message")) {
[16:21:52.285]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.285]                         if (muffled) 
[16:21:52.285]                           invokeRestart("muffleMessage")
[16:21:52.285]                       }
[16:21:52.285]                       else if (inherits(cond, "warning")) {
[16:21:52.285]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.285]                         if (muffled) 
[16:21:52.285]                           invokeRestart("muffleWarning")
[16:21:52.285]                       }
[16:21:52.285]                       else if (inherits(cond, "condition")) {
[16:21:52.285]                         if (!is.null(pattern)) {
[16:21:52.285]                           computeRestarts <- base::computeRestarts
[16:21:52.285]                           grepl <- base::grepl
[16:21:52.285]                           restarts <- computeRestarts(cond)
[16:21:52.285]                           for (restart in restarts) {
[16:21:52.285]                             name <- restart$name
[16:21:52.285]                             if (is.null(name)) 
[16:21:52.285]                               next
[16:21:52.285]                             if (!grepl(pattern, name)) 
[16:21:52.285]                               next
[16:21:52.285]                             invokeRestart(restart)
[16:21:52.285]                             muffled <- TRUE
[16:21:52.285]                             break
[16:21:52.285]                           }
[16:21:52.285]                         }
[16:21:52.285]                       }
[16:21:52.285]                       invisible(muffled)
[16:21:52.285]                     }
[16:21:52.285]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.285]                   }
[16:21:52.285]                 }
[16:21:52.285]             }
[16:21:52.285]         }))
[16:21:52.285]     }, error = function(ex) {
[16:21:52.285]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.285]                 ...future.rng), started = ...future.startTime, 
[16:21:52.285]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.285]             version = "1.8"), class = "FutureResult")
[16:21:52.285]     }, finally = {
[16:21:52.285]         if (!identical(...future.workdir, getwd())) 
[16:21:52.285]             setwd(...future.workdir)
[16:21:52.285]         {
[16:21:52.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.285]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.285]             }
[16:21:52.285]             base::options(...future.oldOptions)
[16:21:52.285]             if (.Platform$OS.type == "windows") {
[16:21:52.285]                 old_names <- names(...future.oldEnvVars)
[16:21:52.285]                 envs <- base::Sys.getenv()
[16:21:52.285]                 names <- names(envs)
[16:21:52.285]                 common <- intersect(names, old_names)
[16:21:52.285]                 added <- setdiff(names, old_names)
[16:21:52.285]                 removed <- setdiff(old_names, names)
[16:21:52.285]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.285]                   envs[common]]
[16:21:52.285]                 NAMES <- toupper(changed)
[16:21:52.285]                 args <- list()
[16:21:52.285]                 for (kk in seq_along(NAMES)) {
[16:21:52.285]                   name <- changed[[kk]]
[16:21:52.285]                   NAME <- NAMES[[kk]]
[16:21:52.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.285]                     next
[16:21:52.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.285]                 }
[16:21:52.285]                 NAMES <- toupper(added)
[16:21:52.285]                 for (kk in seq_along(NAMES)) {
[16:21:52.285]                   name <- added[[kk]]
[16:21:52.285]                   NAME <- NAMES[[kk]]
[16:21:52.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.285]                     next
[16:21:52.285]                   args[[name]] <- ""
[16:21:52.285]                 }
[16:21:52.285]                 NAMES <- toupper(removed)
[16:21:52.285]                 for (kk in seq_along(NAMES)) {
[16:21:52.285]                   name <- removed[[kk]]
[16:21:52.285]                   NAME <- NAMES[[kk]]
[16:21:52.285]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.285]                     next
[16:21:52.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.285]                 }
[16:21:52.285]                 if (length(args) > 0) 
[16:21:52.285]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.285]             }
[16:21:52.285]             else {
[16:21:52.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.285]             }
[16:21:52.285]             {
[16:21:52.285]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.285]                   0L) {
[16:21:52.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.285]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.285]                   base::options(opts)
[16:21:52.285]                 }
[16:21:52.285]                 {
[16:21:52.285]                   {
[16:21:52.285]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.285]                     NULL
[16:21:52.285]                   }
[16:21:52.285]                   options(future.plan = NULL)
[16:21:52.285]                   if (is.na(NA_character_)) 
[16:21:52.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.285]                     .init = FALSE)
[16:21:52.285]                 }
[16:21:52.285]             }
[16:21:52.285]         }
[16:21:52.285]     })
[16:21:52.285]     if (TRUE) {
[16:21:52.285]         base::sink(type = "output", split = FALSE)
[16:21:52.285]         if (TRUE) {
[16:21:52.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.285]         }
[16:21:52.285]         else {
[16:21:52.285]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.285]         }
[16:21:52.285]         base::close(...future.stdout)
[16:21:52.285]         ...future.stdout <- NULL
[16:21:52.285]     }
[16:21:52.285]     ...future.result$conditions <- ...future.conditions
[16:21:52.285]     ...future.result$finished <- base::Sys.time()
[16:21:52.285]     ...future.result
[16:21:52.285] }
[16:21:52.287] assign_globals() ...
[16:21:52.287] List of 1
[16:21:52.287]  $ kk: int 1
[16:21:52.287]  - attr(*, "where")=List of 1
[16:21:52.287]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:52.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:52.287]  - attr(*, "resolved")= logi FALSE
[16:21:52.287]  - attr(*, "total_size")= num 56
[16:21:52.287]  - attr(*, "already-done")= logi TRUE
[16:21:52.291] - copied ‘kk’ to environment
[16:21:52.292] assign_globals() ... done
[16:21:52.292] requestCore(): workers = 2
[16:21:52.292] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.303] result() for MulticoreFuture ...
[16:21:52.304] result() for MulticoreFuture ...
[16:21:52.304] result() for MulticoreFuture ... done
[16:21:52.304] result() for MulticoreFuture ... done
[16:21:52.304] result() for MulticoreFuture ...
[16:21:52.304] result() for MulticoreFuture ... done
[16:21:52.307] MulticoreFuture started
[16:21:52.307] - Launch lazy future ... done
[16:21:52.307] run() for ‘MulticoreFuture’ ... done
[16:21:52.308] getGlobalsAndPackages() ...
[16:21:52.308] plan(): Setting new future strategy stack:
[16:21:52.308] Searching for globals...
[16:21:52.308] List of future strategies:
[16:21:52.308] 1. sequential:
[16:21:52.308]    - args: function (..., envir = parent.frame())
[16:21:52.308]    - tweaked: FALSE
[16:21:52.308]    - call: NULL
[16:21:52.310] plan(): nbrOfWorkers() = 1
[16:21:52.312] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:52.312] Searching for globals ... DONE
[16:21:52.312] Resolving globals: FALSE
[16:21:52.313] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:52.314] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:52.314] - globals: [1] ‘kk’
[16:21:52.314] 
[16:21:52.314] getGlobalsAndPackages() ... DONE
[16:21:52.315] run() for ‘Future’ ...
[16:21:52.315] - state: ‘created’
[16:21:52.315] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.320] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.321]   - Field: ‘label’
[16:21:52.321]   - Field: ‘local’
[16:21:52.321]   - Field: ‘owner’
[16:21:52.321]   - Field: ‘envir’
[16:21:52.321]   - Field: ‘workers’
[16:21:52.321]   - Field: ‘packages’
[16:21:52.322]   - Field: ‘gc’
[16:21:52.322]   - Field: ‘job’
[16:21:52.322]   - Field: ‘conditions’
[16:21:52.322]   - Field: ‘expr’
[16:21:52.322]   - Field: ‘uuid’
[16:21:52.322]   - Field: ‘seed’
[16:21:52.322]   - Field: ‘version’
[16:21:52.323]   - Field: ‘result’
[16:21:52.323]   - Field: ‘asynchronous’
[16:21:52.323]   - Field: ‘calls’
[16:21:52.323]   - Field: ‘globals’
[16:21:52.323]   - Field: ‘stdout’
[16:21:52.323]   - Field: ‘earlySignal’
[16:21:52.323]   - Field: ‘lazy’
[16:21:52.324]   - Field: ‘state’
[16:21:52.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.324] - Launch lazy future ...
[16:21:52.324] Packages needed by the future expression (n = 0): <none>
[16:21:52.325] Packages needed by future strategies (n = 0): <none>
[16:21:52.325] {
[16:21:52.325]     {
[16:21:52.325]         {
[16:21:52.325]             ...future.startTime <- base::Sys.time()
[16:21:52.325]             {
[16:21:52.325]                 {
[16:21:52.325]                   {
[16:21:52.325]                     {
[16:21:52.325]                       base::local({
[16:21:52.325]                         has_future <- base::requireNamespace("future", 
[16:21:52.325]                           quietly = TRUE)
[16:21:52.325]                         if (has_future) {
[16:21:52.325]                           ns <- base::getNamespace("future")
[16:21:52.325]                           version <- ns[[".package"]][["version"]]
[16:21:52.325]                           if (is.null(version)) 
[16:21:52.325]                             version <- utils::packageVersion("future")
[16:21:52.325]                         }
[16:21:52.325]                         else {
[16:21:52.325]                           version <- NULL
[16:21:52.325]                         }
[16:21:52.325]                         if (!has_future || version < "1.8.0") {
[16:21:52.325]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.325]                             "", base::R.version$version.string), 
[16:21:52.325]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.325]                               "release", "version")], collapse = " "), 
[16:21:52.325]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.325]                             info)
[16:21:52.325]                           info <- base::paste(info, collapse = "; ")
[16:21:52.325]                           if (!has_future) {
[16:21:52.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.325]                               info)
[16:21:52.325]                           }
[16:21:52.325]                           else {
[16:21:52.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.325]                               info, version)
[16:21:52.325]                           }
[16:21:52.325]                           base::stop(msg)
[16:21:52.325]                         }
[16:21:52.325]                       })
[16:21:52.325]                     }
[16:21:52.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.325]                     base::options(mc.cores = 1L)
[16:21:52.325]                   }
[16:21:52.325]                   ...future.strategy.old <- future::plan("list")
[16:21:52.325]                   options(future.plan = NULL)
[16:21:52.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.325]                 }
[16:21:52.325]                 ...future.workdir <- getwd()
[16:21:52.325]             }
[16:21:52.325]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.325]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.325]         }
[16:21:52.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.325]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.325]             base::names(...future.oldOptions))
[16:21:52.325]     }
[16:21:52.325]     if (FALSE) {
[16:21:52.325]     }
[16:21:52.325]     else {
[16:21:52.325]         if (TRUE) {
[16:21:52.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.325]                 open = "w")
[16:21:52.325]         }
[16:21:52.325]         else {
[16:21:52.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.325]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.325]         }
[16:21:52.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.325]             base::sink(type = "output", split = FALSE)
[16:21:52.325]             base::close(...future.stdout)
[16:21:52.325]         }, add = TRUE)
[16:21:52.325]     }
[16:21:52.325]     ...future.frame <- base::sys.nframe()
[16:21:52.325]     ...future.conditions <- base::list()
[16:21:52.325]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.325]     if (FALSE) {
[16:21:52.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.325]     }
[16:21:52.325]     ...future.result <- base::tryCatch({
[16:21:52.325]         base::withCallingHandlers({
[16:21:52.325]             ...future.value <- base::withVisible(base::local({
[16:21:52.325]                 withCallingHandlers({
[16:21:52.325]                   {
[16:21:52.325]                     Sys.sleep(0.1)
[16:21:52.325]                     kk
[16:21:52.325]                   }
[16:21:52.325]                 }, immediateCondition = function(cond) {
[16:21:52.325]                   save_rds <- function (object, pathname, ...) 
[16:21:52.325]                   {
[16:21:52.325]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.325]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.325]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.325]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.325]                         fi_tmp[["mtime"]])
[16:21:52.325]                     }
[16:21:52.325]                     tryCatch({
[16:21:52.325]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.325]                     }, error = function(ex) {
[16:21:52.325]                       msg <- conditionMessage(ex)
[16:21:52.325]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.325]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.325]                         fi_tmp[["mtime"]], msg)
[16:21:52.325]                       ex$message <- msg
[16:21:52.325]                       stop(ex)
[16:21:52.325]                     })
[16:21:52.325]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.325]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.325]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.325]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.325]                       fi <- file.info(pathname)
[16:21:52.325]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.325]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.325]                         fi[["size"]], fi[["mtime"]])
[16:21:52.325]                       stop(msg)
[16:21:52.325]                     }
[16:21:52.325]                     invisible(pathname)
[16:21:52.325]                   }
[16:21:52.325]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.325]                     rootPath = tempdir()) 
[16:21:52.325]                   {
[16:21:52.325]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.325]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.325]                       tmpdir = path, fileext = ".rds")
[16:21:52.325]                     save_rds(obj, file)
[16:21:52.325]                   }
[16:21:52.325]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.325]                   {
[16:21:52.325]                     inherits <- base::inherits
[16:21:52.325]                     invokeRestart <- base::invokeRestart
[16:21:52.325]                     is.null <- base::is.null
[16:21:52.325]                     muffled <- FALSE
[16:21:52.325]                     if (inherits(cond, "message")) {
[16:21:52.325]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.325]                       if (muffled) 
[16:21:52.325]                         invokeRestart("muffleMessage")
[16:21:52.325]                     }
[16:21:52.325]                     else if (inherits(cond, "warning")) {
[16:21:52.325]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.325]                       if (muffled) 
[16:21:52.325]                         invokeRestart("muffleWarning")
[16:21:52.325]                     }
[16:21:52.325]                     else if (inherits(cond, "condition")) {
[16:21:52.325]                       if (!is.null(pattern)) {
[16:21:52.325]                         computeRestarts <- base::computeRestarts
[16:21:52.325]                         grepl <- base::grepl
[16:21:52.325]                         restarts <- computeRestarts(cond)
[16:21:52.325]                         for (restart in restarts) {
[16:21:52.325]                           name <- restart$name
[16:21:52.325]                           if (is.null(name)) 
[16:21:52.325]                             next
[16:21:52.325]                           if (!grepl(pattern, name)) 
[16:21:52.325]                             next
[16:21:52.325]                           invokeRestart(restart)
[16:21:52.325]                           muffled <- TRUE
[16:21:52.325]                           break
[16:21:52.325]                         }
[16:21:52.325]                       }
[16:21:52.325]                     }
[16:21:52.325]                     invisible(muffled)
[16:21:52.325]                   }
[16:21:52.325]                   muffleCondition(cond)
[16:21:52.325]                 })
[16:21:52.325]             }))
[16:21:52.325]             future::FutureResult(value = ...future.value$value, 
[16:21:52.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.325]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.325]                     ...future.globalenv.names))
[16:21:52.325]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.325]         }, condition = base::local({
[16:21:52.325]             c <- base::c
[16:21:52.325]             inherits <- base::inherits
[16:21:52.325]             invokeRestart <- base::invokeRestart
[16:21:52.325]             length <- base::length
[16:21:52.325]             list <- base::list
[16:21:52.325]             seq.int <- base::seq.int
[16:21:52.325]             signalCondition <- base::signalCondition
[16:21:52.325]             sys.calls <- base::sys.calls
[16:21:52.325]             `[[` <- base::`[[`
[16:21:52.325]             `+` <- base::`+`
[16:21:52.325]             `<<-` <- base::`<<-`
[16:21:52.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.325]                   3L)]
[16:21:52.325]             }
[16:21:52.325]             function(cond) {
[16:21:52.325]                 is_error <- inherits(cond, "error")
[16:21:52.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.325]                   NULL)
[16:21:52.325]                 if (is_error) {
[16:21:52.325]                   sessionInformation <- function() {
[16:21:52.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.325]                       search = base::search(), system = base::Sys.info())
[16:21:52.325]                   }
[16:21:52.325]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.325]                     cond$call), session = sessionInformation(), 
[16:21:52.325]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.325]                   signalCondition(cond)
[16:21:52.325]                 }
[16:21:52.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.325]                 "immediateCondition"))) {
[16:21:52.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.325]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.325]                   if (TRUE && !signal) {
[16:21:52.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.325]                     {
[16:21:52.325]                       inherits <- base::inherits
[16:21:52.325]                       invokeRestart <- base::invokeRestart
[16:21:52.325]                       is.null <- base::is.null
[16:21:52.325]                       muffled <- FALSE
[16:21:52.325]                       if (inherits(cond, "message")) {
[16:21:52.325]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.325]                         if (muffled) 
[16:21:52.325]                           invokeRestart("muffleMessage")
[16:21:52.325]                       }
[16:21:52.325]                       else if (inherits(cond, "warning")) {
[16:21:52.325]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.325]                         if (muffled) 
[16:21:52.325]                           invokeRestart("muffleWarning")
[16:21:52.325]                       }
[16:21:52.325]                       else if (inherits(cond, "condition")) {
[16:21:52.325]                         if (!is.null(pattern)) {
[16:21:52.325]                           computeRestarts <- base::computeRestarts
[16:21:52.325]                           grepl <- base::grepl
[16:21:52.325]                           restarts <- computeRestarts(cond)
[16:21:52.325]                           for (restart in restarts) {
[16:21:52.325]                             name <- restart$name
[16:21:52.325]                             if (is.null(name)) 
[16:21:52.325]                               next
[16:21:52.325]                             if (!grepl(pattern, name)) 
[16:21:52.325]                               next
[16:21:52.325]                             invokeRestart(restart)
[16:21:52.325]                             muffled <- TRUE
[16:21:52.325]                             break
[16:21:52.325]                           }
[16:21:52.325]                         }
[16:21:52.325]                       }
[16:21:52.325]                       invisible(muffled)
[16:21:52.325]                     }
[16:21:52.325]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.325]                   }
[16:21:52.325]                 }
[16:21:52.325]                 else {
[16:21:52.325]                   if (TRUE) {
[16:21:52.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.325]                     {
[16:21:52.325]                       inherits <- base::inherits
[16:21:52.325]                       invokeRestart <- base::invokeRestart
[16:21:52.325]                       is.null <- base::is.null
[16:21:52.325]                       muffled <- FALSE
[16:21:52.325]                       if (inherits(cond, "message")) {
[16:21:52.325]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.325]                         if (muffled) 
[16:21:52.325]                           invokeRestart("muffleMessage")
[16:21:52.325]                       }
[16:21:52.325]                       else if (inherits(cond, "warning")) {
[16:21:52.325]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.325]                         if (muffled) 
[16:21:52.325]                           invokeRestart("muffleWarning")
[16:21:52.325]                       }
[16:21:52.325]                       else if (inherits(cond, "condition")) {
[16:21:52.325]                         if (!is.null(pattern)) {
[16:21:52.325]                           computeRestarts <- base::computeRestarts
[16:21:52.325]                           grepl <- base::grepl
[16:21:52.325]                           restarts <- computeRestarts(cond)
[16:21:52.325]                           for (restart in restarts) {
[16:21:52.325]                             name <- restart$name
[16:21:52.325]                             if (is.null(name)) 
[16:21:52.325]                               next
[16:21:52.325]                             if (!grepl(pattern, name)) 
[16:21:52.325]                               next
[16:21:52.325]                             invokeRestart(restart)
[16:21:52.325]                             muffled <- TRUE
[16:21:52.325]                             break
[16:21:52.325]                           }
[16:21:52.325]                         }
[16:21:52.325]                       }
[16:21:52.325]                       invisible(muffled)
[16:21:52.325]                     }
[16:21:52.325]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.325]                   }
[16:21:52.325]                 }
[16:21:52.325]             }
[16:21:52.325]         }))
[16:21:52.325]     }, error = function(ex) {
[16:21:52.325]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.325]                 ...future.rng), started = ...future.startTime, 
[16:21:52.325]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.325]             version = "1.8"), class = "FutureResult")
[16:21:52.325]     }, finally = {
[16:21:52.325]         if (!identical(...future.workdir, getwd())) 
[16:21:52.325]             setwd(...future.workdir)
[16:21:52.325]         {
[16:21:52.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.325]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.325]             }
[16:21:52.325]             base::options(...future.oldOptions)
[16:21:52.325]             if (.Platform$OS.type == "windows") {
[16:21:52.325]                 old_names <- names(...future.oldEnvVars)
[16:21:52.325]                 envs <- base::Sys.getenv()
[16:21:52.325]                 names <- names(envs)
[16:21:52.325]                 common <- intersect(names, old_names)
[16:21:52.325]                 added <- setdiff(names, old_names)
[16:21:52.325]                 removed <- setdiff(old_names, names)
[16:21:52.325]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.325]                   envs[common]]
[16:21:52.325]                 NAMES <- toupper(changed)
[16:21:52.325]                 args <- list()
[16:21:52.325]                 for (kk in seq_along(NAMES)) {
[16:21:52.325]                   name <- changed[[kk]]
[16:21:52.325]                   NAME <- NAMES[[kk]]
[16:21:52.325]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.325]                     next
[16:21:52.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.325]                 }
[16:21:52.325]                 NAMES <- toupper(added)
[16:21:52.325]                 for (kk in seq_along(NAMES)) {
[16:21:52.325]                   name <- added[[kk]]
[16:21:52.325]                   NAME <- NAMES[[kk]]
[16:21:52.325]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.325]                     next
[16:21:52.325]                   args[[name]] <- ""
[16:21:52.325]                 }
[16:21:52.325]                 NAMES <- toupper(removed)
[16:21:52.325]                 for (kk in seq_along(NAMES)) {
[16:21:52.325]                   name <- removed[[kk]]
[16:21:52.325]                   NAME <- NAMES[[kk]]
[16:21:52.325]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.325]                     next
[16:21:52.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.325]                 }
[16:21:52.325]                 if (length(args) > 0) 
[16:21:52.325]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.325]             }
[16:21:52.325]             else {
[16:21:52.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.325]             }
[16:21:52.325]             {
[16:21:52.325]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.325]                   0L) {
[16:21:52.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.325]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.325]                   base::options(opts)
[16:21:52.325]                 }
[16:21:52.325]                 {
[16:21:52.325]                   {
[16:21:52.325]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.325]                     NULL
[16:21:52.325]                   }
[16:21:52.325]                   options(future.plan = NULL)
[16:21:52.325]                   if (is.na(NA_character_)) 
[16:21:52.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.325]                     .init = FALSE)
[16:21:52.325]                 }
[16:21:52.325]             }
[16:21:52.325]         }
[16:21:52.325]     })
[16:21:52.325]     if (TRUE) {
[16:21:52.325]         base::sink(type = "output", split = FALSE)
[16:21:52.325]         if (TRUE) {
[16:21:52.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.325]         }
[16:21:52.325]         else {
[16:21:52.325]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.325]         }
[16:21:52.325]         base::close(...future.stdout)
[16:21:52.325]         ...future.stdout <- NULL
[16:21:52.325]     }
[16:21:52.325]     ...future.result$conditions <- ...future.conditions
[16:21:52.325]     ...future.result$finished <- base::Sys.time()
[16:21:52.325]     ...future.result
[16:21:52.325] }
[16:21:52.329] assign_globals() ...
[16:21:52.329] List of 1
[16:21:52.329]  $ kk: int 2
[16:21:52.329]  - attr(*, "where")=List of 1
[16:21:52.329]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:52.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:52.329]  - attr(*, "resolved")= logi FALSE
[16:21:52.329]  - attr(*, "total_size")= num 56
[16:21:52.329]  - attr(*, "already-done")= logi TRUE
[16:21:52.333] - copied ‘kk’ to environment
[16:21:52.333] assign_globals() ... done
[16:21:52.333] requestCore(): workers = 2
[16:21:52.333] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.344] result() for MulticoreFuture ...
[16:21:52.345] result() for MulticoreFuture ...
[16:21:52.345] result() for MulticoreFuture ... done
[16:21:52.345] result() for MulticoreFuture ... done
[16:21:52.345] result() for MulticoreFuture ...
[16:21:52.346] result() for MulticoreFuture ... done
[16:21:52.348] MulticoreFuture started
[16:21:52.348] - Launch lazy future ... done
[16:21:52.349] run() for ‘MulticoreFuture’ ... done
[16:21:52.349] getGlobalsAndPackages() ...
[16:21:52.349] Searching for globals...
[16:21:52.349] plan(): Setting new future strategy stack:
[16:21:52.350] List of future strategies:
[16:21:52.350] 1. sequential:
[16:21:52.350]    - args: function (..., envir = parent.frame())
[16:21:52.350]    - tweaked: FALSE
[16:21:52.350]    - call: NULL
[16:21:52.351] plan(): nbrOfWorkers() = 1
[16:21:52.353] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:52.353] Searching for globals ... DONE
[16:21:52.353] Resolving globals: FALSE
[16:21:52.354] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:52.354] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:52.355] - globals: [1] ‘kk’
[16:21:52.359] 
[16:21:52.360] getGlobalsAndPackages() ... DONE
[16:21:52.360] run() for ‘Future’ ...
[16:21:52.361] - state: ‘created’
[16:21:52.361] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.369]   - Field: ‘label’
[16:21:52.369]   - Field: ‘local’
[16:21:52.370]   - Field: ‘owner’
[16:21:52.370]   - Field: ‘envir’
[16:21:52.370]   - Field: ‘workers’
[16:21:52.370]   - Field: ‘packages’
[16:21:52.370]   - Field: ‘gc’
[16:21:52.371]   - Field: ‘job’
[16:21:52.371]   - Field: ‘conditions’
[16:21:52.371]   - Field: ‘expr’
[16:21:52.371]   - Field: ‘uuid’
[16:21:52.372]   - Field: ‘seed’
[16:21:52.372]   - Field: ‘version’
[16:21:52.372]   - Field: ‘result’
[16:21:52.372]   - Field: ‘asynchronous’
[16:21:52.372]   - Field: ‘calls’
[16:21:52.373]   - Field: ‘globals’
[16:21:52.373]   - Field: ‘stdout’
[16:21:52.373]   - Field: ‘earlySignal’
[16:21:52.373]   - Field: ‘lazy’
[16:21:52.374]   - Field: ‘state’
[16:21:52.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.374] - Launch lazy future ...
[16:21:52.375] Packages needed by the future expression (n = 0): <none>
[16:21:52.375] Packages needed by future strategies (n = 0): <none>
[16:21:52.376] {
[16:21:52.376]     {
[16:21:52.376]         {
[16:21:52.376]             ...future.startTime <- base::Sys.time()
[16:21:52.376]             {
[16:21:52.376]                 {
[16:21:52.376]                   {
[16:21:52.376]                     {
[16:21:52.376]                       base::local({
[16:21:52.376]                         has_future <- base::requireNamespace("future", 
[16:21:52.376]                           quietly = TRUE)
[16:21:52.376]                         if (has_future) {
[16:21:52.376]                           ns <- base::getNamespace("future")
[16:21:52.376]                           version <- ns[[".package"]][["version"]]
[16:21:52.376]                           if (is.null(version)) 
[16:21:52.376]                             version <- utils::packageVersion("future")
[16:21:52.376]                         }
[16:21:52.376]                         else {
[16:21:52.376]                           version <- NULL
[16:21:52.376]                         }
[16:21:52.376]                         if (!has_future || version < "1.8.0") {
[16:21:52.376]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.376]                             "", base::R.version$version.string), 
[16:21:52.376]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.376]                               "release", "version")], collapse = " "), 
[16:21:52.376]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.376]                             info)
[16:21:52.376]                           info <- base::paste(info, collapse = "; ")
[16:21:52.376]                           if (!has_future) {
[16:21:52.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.376]                               info)
[16:21:52.376]                           }
[16:21:52.376]                           else {
[16:21:52.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.376]                               info, version)
[16:21:52.376]                           }
[16:21:52.376]                           base::stop(msg)
[16:21:52.376]                         }
[16:21:52.376]                       })
[16:21:52.376]                     }
[16:21:52.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.376]                     base::options(mc.cores = 1L)
[16:21:52.376]                   }
[16:21:52.376]                   ...future.strategy.old <- future::plan("list")
[16:21:52.376]                   options(future.plan = NULL)
[16:21:52.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.376]                 }
[16:21:52.376]                 ...future.workdir <- getwd()
[16:21:52.376]             }
[16:21:52.376]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.376]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.376]         }
[16:21:52.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.376]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.376]             base::names(...future.oldOptions))
[16:21:52.376]     }
[16:21:52.376]     if (FALSE) {
[16:21:52.376]     }
[16:21:52.376]     else {
[16:21:52.376]         if (TRUE) {
[16:21:52.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.376]                 open = "w")
[16:21:52.376]         }
[16:21:52.376]         else {
[16:21:52.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.376]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.376]         }
[16:21:52.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.376]             base::sink(type = "output", split = FALSE)
[16:21:52.376]             base::close(...future.stdout)
[16:21:52.376]         }, add = TRUE)
[16:21:52.376]     }
[16:21:52.376]     ...future.frame <- base::sys.nframe()
[16:21:52.376]     ...future.conditions <- base::list()
[16:21:52.376]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.376]     if (FALSE) {
[16:21:52.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.376]     }
[16:21:52.376]     ...future.result <- base::tryCatch({
[16:21:52.376]         base::withCallingHandlers({
[16:21:52.376]             ...future.value <- base::withVisible(base::local({
[16:21:52.376]                 withCallingHandlers({
[16:21:52.376]                   {
[16:21:52.376]                     Sys.sleep(0.1)
[16:21:52.376]                     kk
[16:21:52.376]                   }
[16:21:52.376]                 }, immediateCondition = function(cond) {
[16:21:52.376]                   save_rds <- function (object, pathname, ...) 
[16:21:52.376]                   {
[16:21:52.376]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.376]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.376]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.376]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.376]                         fi_tmp[["mtime"]])
[16:21:52.376]                     }
[16:21:52.376]                     tryCatch({
[16:21:52.376]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.376]                     }, error = function(ex) {
[16:21:52.376]                       msg <- conditionMessage(ex)
[16:21:52.376]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.376]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.376]                         fi_tmp[["mtime"]], msg)
[16:21:52.376]                       ex$message <- msg
[16:21:52.376]                       stop(ex)
[16:21:52.376]                     })
[16:21:52.376]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.376]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.376]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.376]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.376]                       fi <- file.info(pathname)
[16:21:52.376]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.376]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.376]                         fi[["size"]], fi[["mtime"]])
[16:21:52.376]                       stop(msg)
[16:21:52.376]                     }
[16:21:52.376]                     invisible(pathname)
[16:21:52.376]                   }
[16:21:52.376]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.376]                     rootPath = tempdir()) 
[16:21:52.376]                   {
[16:21:52.376]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.376]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.376]                       tmpdir = path, fileext = ".rds")
[16:21:52.376]                     save_rds(obj, file)
[16:21:52.376]                   }
[16:21:52.376]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.376]                   {
[16:21:52.376]                     inherits <- base::inherits
[16:21:52.376]                     invokeRestart <- base::invokeRestart
[16:21:52.376]                     is.null <- base::is.null
[16:21:52.376]                     muffled <- FALSE
[16:21:52.376]                     if (inherits(cond, "message")) {
[16:21:52.376]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.376]                       if (muffled) 
[16:21:52.376]                         invokeRestart("muffleMessage")
[16:21:52.376]                     }
[16:21:52.376]                     else if (inherits(cond, "warning")) {
[16:21:52.376]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.376]                       if (muffled) 
[16:21:52.376]                         invokeRestart("muffleWarning")
[16:21:52.376]                     }
[16:21:52.376]                     else if (inherits(cond, "condition")) {
[16:21:52.376]                       if (!is.null(pattern)) {
[16:21:52.376]                         computeRestarts <- base::computeRestarts
[16:21:52.376]                         grepl <- base::grepl
[16:21:52.376]                         restarts <- computeRestarts(cond)
[16:21:52.376]                         for (restart in restarts) {
[16:21:52.376]                           name <- restart$name
[16:21:52.376]                           if (is.null(name)) 
[16:21:52.376]                             next
[16:21:52.376]                           if (!grepl(pattern, name)) 
[16:21:52.376]                             next
[16:21:52.376]                           invokeRestart(restart)
[16:21:52.376]                           muffled <- TRUE
[16:21:52.376]                           break
[16:21:52.376]                         }
[16:21:52.376]                       }
[16:21:52.376]                     }
[16:21:52.376]                     invisible(muffled)
[16:21:52.376]                   }
[16:21:52.376]                   muffleCondition(cond)
[16:21:52.376]                 })
[16:21:52.376]             }))
[16:21:52.376]             future::FutureResult(value = ...future.value$value, 
[16:21:52.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.376]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.376]                     ...future.globalenv.names))
[16:21:52.376]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.376]         }, condition = base::local({
[16:21:52.376]             c <- base::c
[16:21:52.376]             inherits <- base::inherits
[16:21:52.376]             invokeRestart <- base::invokeRestart
[16:21:52.376]             length <- base::length
[16:21:52.376]             list <- base::list
[16:21:52.376]             seq.int <- base::seq.int
[16:21:52.376]             signalCondition <- base::signalCondition
[16:21:52.376]             sys.calls <- base::sys.calls
[16:21:52.376]             `[[` <- base::`[[`
[16:21:52.376]             `+` <- base::`+`
[16:21:52.376]             `<<-` <- base::`<<-`
[16:21:52.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.376]                   3L)]
[16:21:52.376]             }
[16:21:52.376]             function(cond) {
[16:21:52.376]                 is_error <- inherits(cond, "error")
[16:21:52.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.376]                   NULL)
[16:21:52.376]                 if (is_error) {
[16:21:52.376]                   sessionInformation <- function() {
[16:21:52.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.376]                       search = base::search(), system = base::Sys.info())
[16:21:52.376]                   }
[16:21:52.376]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.376]                     cond$call), session = sessionInformation(), 
[16:21:52.376]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.376]                   signalCondition(cond)
[16:21:52.376]                 }
[16:21:52.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.376]                 "immediateCondition"))) {
[16:21:52.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.376]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.376]                   if (TRUE && !signal) {
[16:21:52.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.376]                     {
[16:21:52.376]                       inherits <- base::inherits
[16:21:52.376]                       invokeRestart <- base::invokeRestart
[16:21:52.376]                       is.null <- base::is.null
[16:21:52.376]                       muffled <- FALSE
[16:21:52.376]                       if (inherits(cond, "message")) {
[16:21:52.376]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.376]                         if (muffled) 
[16:21:52.376]                           invokeRestart("muffleMessage")
[16:21:52.376]                       }
[16:21:52.376]                       else if (inherits(cond, "warning")) {
[16:21:52.376]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.376]                         if (muffled) 
[16:21:52.376]                           invokeRestart("muffleWarning")
[16:21:52.376]                       }
[16:21:52.376]                       else if (inherits(cond, "condition")) {
[16:21:52.376]                         if (!is.null(pattern)) {
[16:21:52.376]                           computeRestarts <- base::computeRestarts
[16:21:52.376]                           grepl <- base::grepl
[16:21:52.376]                           restarts <- computeRestarts(cond)
[16:21:52.376]                           for (restart in restarts) {
[16:21:52.376]                             name <- restart$name
[16:21:52.376]                             if (is.null(name)) 
[16:21:52.376]                               next
[16:21:52.376]                             if (!grepl(pattern, name)) 
[16:21:52.376]                               next
[16:21:52.376]                             invokeRestart(restart)
[16:21:52.376]                             muffled <- TRUE
[16:21:52.376]                             break
[16:21:52.376]                           }
[16:21:52.376]                         }
[16:21:52.376]                       }
[16:21:52.376]                       invisible(muffled)
[16:21:52.376]                     }
[16:21:52.376]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.376]                   }
[16:21:52.376]                 }
[16:21:52.376]                 else {
[16:21:52.376]                   if (TRUE) {
[16:21:52.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.376]                     {
[16:21:52.376]                       inherits <- base::inherits
[16:21:52.376]                       invokeRestart <- base::invokeRestart
[16:21:52.376]                       is.null <- base::is.null
[16:21:52.376]                       muffled <- FALSE
[16:21:52.376]                       if (inherits(cond, "message")) {
[16:21:52.376]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.376]                         if (muffled) 
[16:21:52.376]                           invokeRestart("muffleMessage")
[16:21:52.376]                       }
[16:21:52.376]                       else if (inherits(cond, "warning")) {
[16:21:52.376]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.376]                         if (muffled) 
[16:21:52.376]                           invokeRestart("muffleWarning")
[16:21:52.376]                       }
[16:21:52.376]                       else if (inherits(cond, "condition")) {
[16:21:52.376]                         if (!is.null(pattern)) {
[16:21:52.376]                           computeRestarts <- base::computeRestarts
[16:21:52.376]                           grepl <- base::grepl
[16:21:52.376]                           restarts <- computeRestarts(cond)
[16:21:52.376]                           for (restart in restarts) {
[16:21:52.376]                             name <- restart$name
[16:21:52.376]                             if (is.null(name)) 
[16:21:52.376]                               next
[16:21:52.376]                             if (!grepl(pattern, name)) 
[16:21:52.376]                               next
[16:21:52.376]                             invokeRestart(restart)
[16:21:52.376]                             muffled <- TRUE
[16:21:52.376]                             break
[16:21:52.376]                           }
[16:21:52.376]                         }
[16:21:52.376]                       }
[16:21:52.376]                       invisible(muffled)
[16:21:52.376]                     }
[16:21:52.376]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.376]                   }
[16:21:52.376]                 }
[16:21:52.376]             }
[16:21:52.376]         }))
[16:21:52.376]     }, error = function(ex) {
[16:21:52.376]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.376]                 ...future.rng), started = ...future.startTime, 
[16:21:52.376]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.376]             version = "1.8"), class = "FutureResult")
[16:21:52.376]     }, finally = {
[16:21:52.376]         if (!identical(...future.workdir, getwd())) 
[16:21:52.376]             setwd(...future.workdir)
[16:21:52.376]         {
[16:21:52.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.376]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.376]             }
[16:21:52.376]             base::options(...future.oldOptions)
[16:21:52.376]             if (.Platform$OS.type == "windows") {
[16:21:52.376]                 old_names <- names(...future.oldEnvVars)
[16:21:52.376]                 envs <- base::Sys.getenv()
[16:21:52.376]                 names <- names(envs)
[16:21:52.376]                 common <- intersect(names, old_names)
[16:21:52.376]                 added <- setdiff(names, old_names)
[16:21:52.376]                 removed <- setdiff(old_names, names)
[16:21:52.376]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.376]                   envs[common]]
[16:21:52.376]                 NAMES <- toupper(changed)
[16:21:52.376]                 args <- list()
[16:21:52.376]                 for (kk in seq_along(NAMES)) {
[16:21:52.376]                   name <- changed[[kk]]
[16:21:52.376]                   NAME <- NAMES[[kk]]
[16:21:52.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.376]                     next
[16:21:52.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.376]                 }
[16:21:52.376]                 NAMES <- toupper(added)
[16:21:52.376]                 for (kk in seq_along(NAMES)) {
[16:21:52.376]                   name <- added[[kk]]
[16:21:52.376]                   NAME <- NAMES[[kk]]
[16:21:52.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.376]                     next
[16:21:52.376]                   args[[name]] <- ""
[16:21:52.376]                 }
[16:21:52.376]                 NAMES <- toupper(removed)
[16:21:52.376]                 for (kk in seq_along(NAMES)) {
[16:21:52.376]                   name <- removed[[kk]]
[16:21:52.376]                   NAME <- NAMES[[kk]]
[16:21:52.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.376]                     next
[16:21:52.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.376]                 }
[16:21:52.376]                 if (length(args) > 0) 
[16:21:52.376]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.376]             }
[16:21:52.376]             else {
[16:21:52.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.376]             }
[16:21:52.376]             {
[16:21:52.376]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.376]                   0L) {
[16:21:52.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.376]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.376]                   base::options(opts)
[16:21:52.376]                 }
[16:21:52.376]                 {
[16:21:52.376]                   {
[16:21:52.376]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.376]                     NULL
[16:21:52.376]                   }
[16:21:52.376]                   options(future.plan = NULL)
[16:21:52.376]                   if (is.na(NA_character_)) 
[16:21:52.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.376]                     .init = FALSE)
[16:21:52.376]                 }
[16:21:52.376]             }
[16:21:52.376]         }
[16:21:52.376]     })
[16:21:52.376]     if (TRUE) {
[16:21:52.376]         base::sink(type = "output", split = FALSE)
[16:21:52.376]         if (TRUE) {
[16:21:52.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.376]         }
[16:21:52.376]         else {
[16:21:52.376]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.376]         }
[16:21:52.376]         base::close(...future.stdout)
[16:21:52.376]         ...future.stdout <- NULL
[16:21:52.376]     }
[16:21:52.376]     ...future.result$conditions <- ...future.conditions
[16:21:52.376]     ...future.result$finished <- base::Sys.time()
[16:21:52.376]     ...future.result
[16:21:52.376] }
[16:21:52.379] assign_globals() ...
[16:21:52.379] List of 1
[16:21:52.379]  $ kk: int 3
[16:21:52.379]  - attr(*, "where")=List of 1
[16:21:52.379]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:52.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:52.379]  - attr(*, "resolved")= logi FALSE
[16:21:52.379]  - attr(*, "total_size")= num 56
[16:21:52.379]  - attr(*, "already-done")= logi TRUE
[16:21:52.384] - copied ‘kk’ to environment
[16:21:52.384] assign_globals() ... done
[16:21:52.384] requestCore(): workers = 2
[16:21:52.384] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.412] plan(): Setting new future strategy stack:
[16:21:52.413] List of future strategies:
[16:21:52.413] 1. multicore:
[16:21:52.413]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.413]    - tweaked: FALSE
[16:21:52.413]    - call: plan(strategy)
[16:21:52.416] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[16:21:52.417] plan(): nbrOfWorkers() = 2
[16:21:52.427] result() for MulticoreFuture ...
[16:21:52.428] result() for MulticoreFuture ...
[16:21:52.428] result() for MulticoreFuture ... done
[16:21:52.428] result() for MulticoreFuture ... done
[16:21:52.428] result() for MulticoreFuture ...
[16:21:52.429] result() for MulticoreFuture ... done
[16:21:52.431] MulticoreFuture started
[16:21:52.432] - Launch lazy future ... done
[16:21:52.432] run() for ‘MulticoreFuture’ ... done
[16:21:52.433] resolve() on list ...
[16:21:52.433] plan(): Setting new future strategy stack:
[16:21:52.433]  recursive: 0
[16:21:52.433]  length: 3
[16:21:52.433] 
[16:21:52.433] Future #1
[16:21:52.433] List of future strategies:
[16:21:52.433] 1. sequential:
[16:21:52.433]    - args: function (..., envir = parent.frame())
[16:21:52.433]    - tweaked: FALSE
[16:21:52.433]    - call: NULL
[16:21:52.434]  length: 2 (resolved future 1)
[16:21:52.434] plan(): nbrOfWorkers() = 1
[16:21:52.454] plan(): Setting new future strategy stack:
[16:21:52.454] List of future strategies:
[16:21:52.454] 1. multicore:
[16:21:52.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.454]    - tweaked: FALSE
[16:21:52.454]    - call: plan(strategy)
[16:21:52.459] plan(): nbrOfWorkers() = 2
[16:21:52.465] Future #2
[16:21:52.465]  length: 1 (resolved future 2)
[16:21:52.536] plan(): Setting new future strategy stack:
[16:21:52.537] List of future strategies:
[16:21:52.537] 1. multicore:
[16:21:52.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.537]    - tweaked: FALSE
[16:21:52.537]    - call: plan(strategy)
[16:21:52.542] plan(): nbrOfWorkers() = 2
[16:21:52.547] Future #3
[16:21:52.547]  length: 0 (resolved future 3)
[16:21:52.547] resolve() on list ... DONE
[16:21:52.548] getGlobalsAndPackages() ...
[16:21:52.548] Searching for globals...
[16:21:52.550] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:52.550] Searching for globals ... DONE
[16:21:52.550] Resolving globals: FALSE
[16:21:52.551] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:52.552] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:52.552] - globals: [1] ‘kk’
[16:21:52.552] 
[16:21:52.552] getGlobalsAndPackages() ... DONE
[16:21:52.553] getGlobalsAndPackages() ...
[16:21:52.553] Searching for globals...
[16:21:52.554] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:52.554] Searching for globals ... DONE
[16:21:52.554] Resolving globals: FALSE
[16:21:52.555] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:52.555] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:52.556] - globals: [1] ‘kk’
[16:21:52.556] 
[16:21:52.556] getGlobalsAndPackages() ... DONE
[16:21:52.556] getGlobalsAndPackages() ...
[16:21:52.556] Searching for globals...
[16:21:52.558] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:21:52.558] Searching for globals ... DONE
[16:21:52.558] Resolving globals: FALSE
[16:21:52.559] The total size of the 1 globals is 56 bytes (56 bytes)
[16:21:52.559] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:21:52.559] - globals: [1] ‘kk’
[16:21:52.559] 
[16:21:52.560] getGlobalsAndPackages() ... DONE
[16:21:52.560] resolve() on list ...
[16:21:52.560]  recursive: 0
[16:21:52.560]  length: 3
[16:21:52.560] 
[16:21:52.561] run() for ‘Future’ ...
[16:21:52.561] - state: ‘created’
[16:21:52.561] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.565] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.566]   - Field: ‘label’
[16:21:52.566]   - Field: ‘local’
[16:21:52.566]   - Field: ‘owner’
[16:21:52.566]   - Field: ‘envir’
[16:21:52.566]   - Field: ‘workers’
[16:21:52.567]   - Field: ‘packages’
[16:21:52.567]   - Field: ‘gc’
[16:21:52.567]   - Field: ‘job’
[16:21:52.567]   - Field: ‘conditions’
[16:21:52.570]   - Field: ‘expr’
[16:21:52.571]   - Field: ‘uuid’
[16:21:52.571]   - Field: ‘seed’
[16:21:52.571]   - Field: ‘version’
[16:21:52.572]   - Field: ‘result’
[16:21:52.572]   - Field: ‘asynchronous’
[16:21:52.572]   - Field: ‘calls’
[16:21:52.572]   - Field: ‘globals’
[16:21:52.573]   - Field: ‘stdout’
[16:21:52.573]   - Field: ‘earlySignal’
[16:21:52.573]   - Field: ‘lazy’
[16:21:52.573]   - Field: ‘state’
[16:21:52.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.574] - Launch lazy future ...
[16:21:52.574] Packages needed by the future expression (n = 0): <none>
[16:21:52.574] Packages needed by future strategies (n = 0): <none>
[16:21:52.575] {
[16:21:52.575]     {
[16:21:52.575]         {
[16:21:52.575]             ...future.startTime <- base::Sys.time()
[16:21:52.575]             {
[16:21:52.575]                 {
[16:21:52.575]                   {
[16:21:52.575]                     {
[16:21:52.575]                       base::local({
[16:21:52.575]                         has_future <- base::requireNamespace("future", 
[16:21:52.575]                           quietly = TRUE)
[16:21:52.575]                         if (has_future) {
[16:21:52.575]                           ns <- base::getNamespace("future")
[16:21:52.575]                           version <- ns[[".package"]][["version"]]
[16:21:52.575]                           if (is.null(version)) 
[16:21:52.575]                             version <- utils::packageVersion("future")
[16:21:52.575]                         }
[16:21:52.575]                         else {
[16:21:52.575]                           version <- NULL
[16:21:52.575]                         }
[16:21:52.575]                         if (!has_future || version < "1.8.0") {
[16:21:52.575]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.575]                             "", base::R.version$version.string), 
[16:21:52.575]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.575]                               "release", "version")], collapse = " "), 
[16:21:52.575]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.575]                             info)
[16:21:52.575]                           info <- base::paste(info, collapse = "; ")
[16:21:52.575]                           if (!has_future) {
[16:21:52.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.575]                               info)
[16:21:52.575]                           }
[16:21:52.575]                           else {
[16:21:52.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.575]                               info, version)
[16:21:52.575]                           }
[16:21:52.575]                           base::stop(msg)
[16:21:52.575]                         }
[16:21:52.575]                       })
[16:21:52.575]                     }
[16:21:52.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.575]                     base::options(mc.cores = 1L)
[16:21:52.575]                   }
[16:21:52.575]                   ...future.strategy.old <- future::plan("list")
[16:21:52.575]                   options(future.plan = NULL)
[16:21:52.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.575]                 }
[16:21:52.575]                 ...future.workdir <- getwd()
[16:21:52.575]             }
[16:21:52.575]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.575]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.575]         }
[16:21:52.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.575]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.575]             base::names(...future.oldOptions))
[16:21:52.575]     }
[16:21:52.575]     if (FALSE) {
[16:21:52.575]     }
[16:21:52.575]     else {
[16:21:52.575]         if (TRUE) {
[16:21:52.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.575]                 open = "w")
[16:21:52.575]         }
[16:21:52.575]         else {
[16:21:52.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.575]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.575]         }
[16:21:52.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.575]             base::sink(type = "output", split = FALSE)
[16:21:52.575]             base::close(...future.stdout)
[16:21:52.575]         }, add = TRUE)
[16:21:52.575]     }
[16:21:52.575]     ...future.frame <- base::sys.nframe()
[16:21:52.575]     ...future.conditions <- base::list()
[16:21:52.575]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.575]     if (FALSE) {
[16:21:52.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.575]     }
[16:21:52.575]     ...future.result <- base::tryCatch({
[16:21:52.575]         base::withCallingHandlers({
[16:21:52.575]             ...future.value <- base::withVisible(base::local({
[16:21:52.575]                 withCallingHandlers({
[16:21:52.575]                   {
[16:21:52.575]                     Sys.sleep(0.1)
[16:21:52.575]                     kk
[16:21:52.575]                   }
[16:21:52.575]                 }, immediateCondition = function(cond) {
[16:21:52.575]                   save_rds <- function (object, pathname, ...) 
[16:21:52.575]                   {
[16:21:52.575]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.575]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.575]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.575]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.575]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.575]                         fi_tmp[["mtime"]])
[16:21:52.575]                     }
[16:21:52.575]                     tryCatch({
[16:21:52.575]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.575]                     }, error = function(ex) {
[16:21:52.575]                       msg <- conditionMessage(ex)
[16:21:52.575]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.575]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.575]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.575]                         fi_tmp[["mtime"]], msg)
[16:21:52.575]                       ex$message <- msg
[16:21:52.575]                       stop(ex)
[16:21:52.575]                     })
[16:21:52.575]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.575]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.575]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.575]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.575]                       fi <- file.info(pathname)
[16:21:52.575]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.575]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.575]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.575]                         fi[["size"]], fi[["mtime"]])
[16:21:52.575]                       stop(msg)
[16:21:52.575]                     }
[16:21:52.575]                     invisible(pathname)
[16:21:52.575]                   }
[16:21:52.575]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.575]                     rootPath = tempdir()) 
[16:21:52.575]                   {
[16:21:52.575]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.575]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.575]                       tmpdir = path, fileext = ".rds")
[16:21:52.575]                     save_rds(obj, file)
[16:21:52.575]                   }
[16:21:52.575]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.575]                   {
[16:21:52.575]                     inherits <- base::inherits
[16:21:52.575]                     invokeRestart <- base::invokeRestart
[16:21:52.575]                     is.null <- base::is.null
[16:21:52.575]                     muffled <- FALSE
[16:21:52.575]                     if (inherits(cond, "message")) {
[16:21:52.575]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.575]                       if (muffled) 
[16:21:52.575]                         invokeRestart("muffleMessage")
[16:21:52.575]                     }
[16:21:52.575]                     else if (inherits(cond, "warning")) {
[16:21:52.575]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.575]                       if (muffled) 
[16:21:52.575]                         invokeRestart("muffleWarning")
[16:21:52.575]                     }
[16:21:52.575]                     else if (inherits(cond, "condition")) {
[16:21:52.575]                       if (!is.null(pattern)) {
[16:21:52.575]                         computeRestarts <- base::computeRestarts
[16:21:52.575]                         grepl <- base::grepl
[16:21:52.575]                         restarts <- computeRestarts(cond)
[16:21:52.575]                         for (restart in restarts) {
[16:21:52.575]                           name <- restart$name
[16:21:52.575]                           if (is.null(name)) 
[16:21:52.575]                             next
[16:21:52.575]                           if (!grepl(pattern, name)) 
[16:21:52.575]                             next
[16:21:52.575]                           invokeRestart(restart)
[16:21:52.575]                           muffled <- TRUE
[16:21:52.575]                           break
[16:21:52.575]                         }
[16:21:52.575]                       }
[16:21:52.575]                     }
[16:21:52.575]                     invisible(muffled)
[16:21:52.575]                   }
[16:21:52.575]                   muffleCondition(cond)
[16:21:52.575]                 })
[16:21:52.575]             }))
[16:21:52.575]             future::FutureResult(value = ...future.value$value, 
[16:21:52.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.575]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.575]                     ...future.globalenv.names))
[16:21:52.575]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.575]         }, condition = base::local({
[16:21:52.575]             c <- base::c
[16:21:52.575]             inherits <- base::inherits
[16:21:52.575]             invokeRestart <- base::invokeRestart
[16:21:52.575]             length <- base::length
[16:21:52.575]             list <- base::list
[16:21:52.575]             seq.int <- base::seq.int
[16:21:52.575]             signalCondition <- base::signalCondition
[16:21:52.575]             sys.calls <- base::sys.calls
[16:21:52.575]             `[[` <- base::`[[`
[16:21:52.575]             `+` <- base::`+`
[16:21:52.575]             `<<-` <- base::`<<-`
[16:21:52.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.575]                   3L)]
[16:21:52.575]             }
[16:21:52.575]             function(cond) {
[16:21:52.575]                 is_error <- inherits(cond, "error")
[16:21:52.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.575]                   NULL)
[16:21:52.575]                 if (is_error) {
[16:21:52.575]                   sessionInformation <- function() {
[16:21:52.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.575]                       search = base::search(), system = base::Sys.info())
[16:21:52.575]                   }
[16:21:52.575]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.575]                     cond$call), session = sessionInformation(), 
[16:21:52.575]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.575]                   signalCondition(cond)
[16:21:52.575]                 }
[16:21:52.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.575]                 "immediateCondition"))) {
[16:21:52.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.575]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.575]                   if (TRUE && !signal) {
[16:21:52.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.575]                     {
[16:21:52.575]                       inherits <- base::inherits
[16:21:52.575]                       invokeRestart <- base::invokeRestart
[16:21:52.575]                       is.null <- base::is.null
[16:21:52.575]                       muffled <- FALSE
[16:21:52.575]                       if (inherits(cond, "message")) {
[16:21:52.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.575]                         if (muffled) 
[16:21:52.575]                           invokeRestart("muffleMessage")
[16:21:52.575]                       }
[16:21:52.575]                       else if (inherits(cond, "warning")) {
[16:21:52.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.575]                         if (muffled) 
[16:21:52.575]                           invokeRestart("muffleWarning")
[16:21:52.575]                       }
[16:21:52.575]                       else if (inherits(cond, "condition")) {
[16:21:52.575]                         if (!is.null(pattern)) {
[16:21:52.575]                           computeRestarts <- base::computeRestarts
[16:21:52.575]                           grepl <- base::grepl
[16:21:52.575]                           restarts <- computeRestarts(cond)
[16:21:52.575]                           for (restart in restarts) {
[16:21:52.575]                             name <- restart$name
[16:21:52.575]                             if (is.null(name)) 
[16:21:52.575]                               next
[16:21:52.575]                             if (!grepl(pattern, name)) 
[16:21:52.575]                               next
[16:21:52.575]                             invokeRestart(restart)
[16:21:52.575]                             muffled <- TRUE
[16:21:52.575]                             break
[16:21:52.575]                           }
[16:21:52.575]                         }
[16:21:52.575]                       }
[16:21:52.575]                       invisible(muffled)
[16:21:52.575]                     }
[16:21:52.575]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.575]                   }
[16:21:52.575]                 }
[16:21:52.575]                 else {
[16:21:52.575]                   if (TRUE) {
[16:21:52.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.575]                     {
[16:21:52.575]                       inherits <- base::inherits
[16:21:52.575]                       invokeRestart <- base::invokeRestart
[16:21:52.575]                       is.null <- base::is.null
[16:21:52.575]                       muffled <- FALSE
[16:21:52.575]                       if (inherits(cond, "message")) {
[16:21:52.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.575]                         if (muffled) 
[16:21:52.575]                           invokeRestart("muffleMessage")
[16:21:52.575]                       }
[16:21:52.575]                       else if (inherits(cond, "warning")) {
[16:21:52.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.575]                         if (muffled) 
[16:21:52.575]                           invokeRestart("muffleWarning")
[16:21:52.575]                       }
[16:21:52.575]                       else if (inherits(cond, "condition")) {
[16:21:52.575]                         if (!is.null(pattern)) {
[16:21:52.575]                           computeRestarts <- base::computeRestarts
[16:21:52.575]                           grepl <- base::grepl
[16:21:52.575]                           restarts <- computeRestarts(cond)
[16:21:52.575]                           for (restart in restarts) {
[16:21:52.575]                             name <- restart$name
[16:21:52.575]                             if (is.null(name)) 
[16:21:52.575]                               next
[16:21:52.575]                             if (!grepl(pattern, name)) 
[16:21:52.575]                               next
[16:21:52.575]                             invokeRestart(restart)
[16:21:52.575]                             muffled <- TRUE
[16:21:52.575]                             break
[16:21:52.575]                           }
[16:21:52.575]                         }
[16:21:52.575]                       }
[16:21:52.575]                       invisible(muffled)
[16:21:52.575]                     }
[16:21:52.575]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.575]                   }
[16:21:52.575]                 }
[16:21:52.575]             }
[16:21:52.575]         }))
[16:21:52.575]     }, error = function(ex) {
[16:21:52.575]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.575]                 ...future.rng), started = ...future.startTime, 
[16:21:52.575]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.575]             version = "1.8"), class = "FutureResult")
[16:21:52.575]     }, finally = {
[16:21:52.575]         if (!identical(...future.workdir, getwd())) 
[16:21:52.575]             setwd(...future.workdir)
[16:21:52.575]         {
[16:21:52.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.575]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.575]             }
[16:21:52.575]             base::options(...future.oldOptions)
[16:21:52.575]             if (.Platform$OS.type == "windows") {
[16:21:52.575]                 old_names <- names(...future.oldEnvVars)
[16:21:52.575]                 envs <- base::Sys.getenv()
[16:21:52.575]                 names <- names(envs)
[16:21:52.575]                 common <- intersect(names, old_names)
[16:21:52.575]                 added <- setdiff(names, old_names)
[16:21:52.575]                 removed <- setdiff(old_names, names)
[16:21:52.575]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.575]                   envs[common]]
[16:21:52.575]                 NAMES <- toupper(changed)
[16:21:52.575]                 args <- list()
[16:21:52.575]                 for (kk in seq_along(NAMES)) {
[16:21:52.575]                   name <- changed[[kk]]
[16:21:52.575]                   NAME <- NAMES[[kk]]
[16:21:52.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.575]                     next
[16:21:52.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.575]                 }
[16:21:52.575]                 NAMES <- toupper(added)
[16:21:52.575]                 for (kk in seq_along(NAMES)) {
[16:21:52.575]                   name <- added[[kk]]
[16:21:52.575]                   NAME <- NAMES[[kk]]
[16:21:52.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.575]                     next
[16:21:52.575]                   args[[name]] <- ""
[16:21:52.575]                 }
[16:21:52.575]                 NAMES <- toupper(removed)
[16:21:52.575]                 for (kk in seq_along(NAMES)) {
[16:21:52.575]                   name <- removed[[kk]]
[16:21:52.575]                   NAME <- NAMES[[kk]]
[16:21:52.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.575]                     next
[16:21:52.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.575]                 }
[16:21:52.575]                 if (length(args) > 0) 
[16:21:52.575]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.575]             }
[16:21:52.575]             else {
[16:21:52.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.575]             }
[16:21:52.575]             {
[16:21:52.575]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.575]                   0L) {
[16:21:52.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.575]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.575]                   base::options(opts)
[16:21:52.575]                 }
[16:21:52.575]                 {
[16:21:52.575]                   {
[16:21:52.575]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.575]                     NULL
[16:21:52.575]                   }
[16:21:52.575]                   options(future.plan = NULL)
[16:21:52.575]                   if (is.na(NA_character_)) 
[16:21:52.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.575]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.575]                     .init = FALSE)
[16:21:52.575]                 }
[16:21:52.575]             }
[16:21:52.575]         }
[16:21:52.575]     })
[16:21:52.575]     if (TRUE) {
[16:21:52.575]         base::sink(type = "output", split = FALSE)
[16:21:52.575]         if (TRUE) {
[16:21:52.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.575]         }
[16:21:52.575]         else {
[16:21:52.575]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.575]         }
[16:21:52.575]         base::close(...future.stdout)
[16:21:52.575]         ...future.stdout <- NULL
[16:21:52.575]     }
[16:21:52.575]     ...future.result$conditions <- ...future.conditions
[16:21:52.575]     ...future.result$finished <- base::Sys.time()
[16:21:52.575]     ...future.result
[16:21:52.575] }
[16:21:52.578] assign_globals() ...
[16:21:52.578] List of 1
[16:21:52.578]  $ kk: int 1
[16:21:52.578]  - attr(*, "where")=List of 1
[16:21:52.578]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:52.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:52.578]  - attr(*, "resolved")= logi FALSE
[16:21:52.578]  - attr(*, "total_size")= num 56
[16:21:52.578]  - attr(*, "already-done")= logi TRUE
[16:21:52.583] - copied ‘kk’ to environment
[16:21:52.583] assign_globals() ... done
[16:21:52.583] requestCore(): workers = 2
[16:21:52.583] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.594] result() for MulticoreFuture ...
[16:21:52.595] result() for MulticoreFuture ...
[16:21:52.595] result() for MulticoreFuture ... done
[16:21:52.595] result() for MulticoreFuture ... done
[16:21:52.595] result() for MulticoreFuture ...
[16:21:52.596] result() for MulticoreFuture ... done
[16:21:52.599] MulticoreFuture started
[16:21:52.599] - Launch lazy future ... done
[16:21:52.599] run() for ‘MulticoreFuture’ ... done
[16:21:52.600] plan(): Setting new future strategy stack:
[16:21:52.600] List of future strategies:
[16:21:52.600] 1. sequential:
[16:21:52.600]    - args: function (..., envir = parent.frame())
[16:21:52.600]    - tweaked: FALSE
[16:21:52.600]    - call: NULL
[16:21:52.601] plan(): nbrOfWorkers() = 1
[16:21:52.610] run() for ‘Future’ ...
[16:21:52.610] - state: ‘created’
[16:21:52.611] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.617] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.617] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.617]   - Field: ‘label’
[16:21:52.617]   - Field: ‘local’
[16:21:52.617]   - Field: ‘owner’
[16:21:52.617]   - Field: ‘envir’
[16:21:52.618]   - Field: ‘workers’
[16:21:52.618]   - Field: ‘packages’
[16:21:52.618]   - Field: ‘gc’
[16:21:52.618]   - Field: ‘job’
[16:21:52.618]   - Field: ‘conditions’
[16:21:52.618]   - Field: ‘expr’
[16:21:52.619]   - Field: ‘uuid’
[16:21:52.619]   - Field: ‘seed’
[16:21:52.619]   - Field: ‘version’
[16:21:52.619]   - Field: ‘result’
[16:21:52.619]   - Field: ‘asynchronous’
[16:21:52.619]   - Field: ‘calls’
[16:21:52.620]   - Field: ‘globals’
[16:21:52.620]   - Field: ‘stdout’
[16:21:52.620]   - Field: ‘earlySignal’
[16:21:52.620]   - Field: ‘lazy’
[16:21:52.620]   - Field: ‘state’
[16:21:52.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.621] - Launch lazy future ...
[16:21:52.621] Packages needed by the future expression (n = 0): <none>
[16:21:52.621] Packages needed by future strategies (n = 0): <none>
[16:21:52.622] {
[16:21:52.622]     {
[16:21:52.622]         {
[16:21:52.622]             ...future.startTime <- base::Sys.time()
[16:21:52.622]             {
[16:21:52.622]                 {
[16:21:52.622]                   {
[16:21:52.622]                     {
[16:21:52.622]                       base::local({
[16:21:52.622]                         has_future <- base::requireNamespace("future", 
[16:21:52.622]                           quietly = TRUE)
[16:21:52.622]                         if (has_future) {
[16:21:52.622]                           ns <- base::getNamespace("future")
[16:21:52.622]                           version <- ns[[".package"]][["version"]]
[16:21:52.622]                           if (is.null(version)) 
[16:21:52.622]                             version <- utils::packageVersion("future")
[16:21:52.622]                         }
[16:21:52.622]                         else {
[16:21:52.622]                           version <- NULL
[16:21:52.622]                         }
[16:21:52.622]                         if (!has_future || version < "1.8.0") {
[16:21:52.622]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.622]                             "", base::R.version$version.string), 
[16:21:52.622]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.622]                               "release", "version")], collapse = " "), 
[16:21:52.622]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.622]                             info)
[16:21:52.622]                           info <- base::paste(info, collapse = "; ")
[16:21:52.622]                           if (!has_future) {
[16:21:52.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.622]                               info)
[16:21:52.622]                           }
[16:21:52.622]                           else {
[16:21:52.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.622]                               info, version)
[16:21:52.622]                           }
[16:21:52.622]                           base::stop(msg)
[16:21:52.622]                         }
[16:21:52.622]                       })
[16:21:52.622]                     }
[16:21:52.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.622]                     base::options(mc.cores = 1L)
[16:21:52.622]                   }
[16:21:52.622]                   ...future.strategy.old <- future::plan("list")
[16:21:52.622]                   options(future.plan = NULL)
[16:21:52.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.622]                 }
[16:21:52.622]                 ...future.workdir <- getwd()
[16:21:52.622]             }
[16:21:52.622]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.622]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.622]         }
[16:21:52.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.622]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.622]             base::names(...future.oldOptions))
[16:21:52.622]     }
[16:21:52.622]     if (FALSE) {
[16:21:52.622]     }
[16:21:52.622]     else {
[16:21:52.622]         if (TRUE) {
[16:21:52.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.622]                 open = "w")
[16:21:52.622]         }
[16:21:52.622]         else {
[16:21:52.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.622]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.622]         }
[16:21:52.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.622]             base::sink(type = "output", split = FALSE)
[16:21:52.622]             base::close(...future.stdout)
[16:21:52.622]         }, add = TRUE)
[16:21:52.622]     }
[16:21:52.622]     ...future.frame <- base::sys.nframe()
[16:21:52.622]     ...future.conditions <- base::list()
[16:21:52.622]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.622]     if (FALSE) {
[16:21:52.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.622]     }
[16:21:52.622]     ...future.result <- base::tryCatch({
[16:21:52.622]         base::withCallingHandlers({
[16:21:52.622]             ...future.value <- base::withVisible(base::local({
[16:21:52.622]                 withCallingHandlers({
[16:21:52.622]                   {
[16:21:52.622]                     Sys.sleep(0.1)
[16:21:52.622]                     kk
[16:21:52.622]                   }
[16:21:52.622]                 }, immediateCondition = function(cond) {
[16:21:52.622]                   save_rds <- function (object, pathname, ...) 
[16:21:52.622]                   {
[16:21:52.622]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.622]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.622]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.622]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.622]                         fi_tmp[["mtime"]])
[16:21:52.622]                     }
[16:21:52.622]                     tryCatch({
[16:21:52.622]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.622]                     }, error = function(ex) {
[16:21:52.622]                       msg <- conditionMessage(ex)
[16:21:52.622]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.622]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.622]                         fi_tmp[["mtime"]], msg)
[16:21:52.622]                       ex$message <- msg
[16:21:52.622]                       stop(ex)
[16:21:52.622]                     })
[16:21:52.622]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.622]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.622]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.622]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.622]                       fi <- file.info(pathname)
[16:21:52.622]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.622]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.622]                         fi[["size"]], fi[["mtime"]])
[16:21:52.622]                       stop(msg)
[16:21:52.622]                     }
[16:21:52.622]                     invisible(pathname)
[16:21:52.622]                   }
[16:21:52.622]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.622]                     rootPath = tempdir()) 
[16:21:52.622]                   {
[16:21:52.622]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.622]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.622]                       tmpdir = path, fileext = ".rds")
[16:21:52.622]                     save_rds(obj, file)
[16:21:52.622]                   }
[16:21:52.622]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.622]                   {
[16:21:52.622]                     inherits <- base::inherits
[16:21:52.622]                     invokeRestart <- base::invokeRestart
[16:21:52.622]                     is.null <- base::is.null
[16:21:52.622]                     muffled <- FALSE
[16:21:52.622]                     if (inherits(cond, "message")) {
[16:21:52.622]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.622]                       if (muffled) 
[16:21:52.622]                         invokeRestart("muffleMessage")
[16:21:52.622]                     }
[16:21:52.622]                     else if (inherits(cond, "warning")) {
[16:21:52.622]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.622]                       if (muffled) 
[16:21:52.622]                         invokeRestart("muffleWarning")
[16:21:52.622]                     }
[16:21:52.622]                     else if (inherits(cond, "condition")) {
[16:21:52.622]                       if (!is.null(pattern)) {
[16:21:52.622]                         computeRestarts <- base::computeRestarts
[16:21:52.622]                         grepl <- base::grepl
[16:21:52.622]                         restarts <- computeRestarts(cond)
[16:21:52.622]                         for (restart in restarts) {
[16:21:52.622]                           name <- restart$name
[16:21:52.622]                           if (is.null(name)) 
[16:21:52.622]                             next
[16:21:52.622]                           if (!grepl(pattern, name)) 
[16:21:52.622]                             next
[16:21:52.622]                           invokeRestart(restart)
[16:21:52.622]                           muffled <- TRUE
[16:21:52.622]                           break
[16:21:52.622]                         }
[16:21:52.622]                       }
[16:21:52.622]                     }
[16:21:52.622]                     invisible(muffled)
[16:21:52.622]                   }
[16:21:52.622]                   muffleCondition(cond)
[16:21:52.622]                 })
[16:21:52.622]             }))
[16:21:52.622]             future::FutureResult(value = ...future.value$value, 
[16:21:52.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.622]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.622]                     ...future.globalenv.names))
[16:21:52.622]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.622]         }, condition = base::local({
[16:21:52.622]             c <- base::c
[16:21:52.622]             inherits <- base::inherits
[16:21:52.622]             invokeRestart <- base::invokeRestart
[16:21:52.622]             length <- base::length
[16:21:52.622]             list <- base::list
[16:21:52.622]             seq.int <- base::seq.int
[16:21:52.622]             signalCondition <- base::signalCondition
[16:21:52.622]             sys.calls <- base::sys.calls
[16:21:52.622]             `[[` <- base::`[[`
[16:21:52.622]             `+` <- base::`+`
[16:21:52.622]             `<<-` <- base::`<<-`
[16:21:52.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.622]                   3L)]
[16:21:52.622]             }
[16:21:52.622]             function(cond) {
[16:21:52.622]                 is_error <- inherits(cond, "error")
[16:21:52.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.622]                   NULL)
[16:21:52.622]                 if (is_error) {
[16:21:52.622]                   sessionInformation <- function() {
[16:21:52.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.622]                       search = base::search(), system = base::Sys.info())
[16:21:52.622]                   }
[16:21:52.622]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.622]                     cond$call), session = sessionInformation(), 
[16:21:52.622]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.622]                   signalCondition(cond)
[16:21:52.622]                 }
[16:21:52.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.622]                 "immediateCondition"))) {
[16:21:52.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.622]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.622]                   if (TRUE && !signal) {
[16:21:52.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.622]                     {
[16:21:52.622]                       inherits <- base::inherits
[16:21:52.622]                       invokeRestart <- base::invokeRestart
[16:21:52.622]                       is.null <- base::is.null
[16:21:52.622]                       muffled <- FALSE
[16:21:52.622]                       if (inherits(cond, "message")) {
[16:21:52.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.622]                         if (muffled) 
[16:21:52.622]                           invokeRestart("muffleMessage")
[16:21:52.622]                       }
[16:21:52.622]                       else if (inherits(cond, "warning")) {
[16:21:52.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.622]                         if (muffled) 
[16:21:52.622]                           invokeRestart("muffleWarning")
[16:21:52.622]                       }
[16:21:52.622]                       else if (inherits(cond, "condition")) {
[16:21:52.622]                         if (!is.null(pattern)) {
[16:21:52.622]                           computeRestarts <- base::computeRestarts
[16:21:52.622]                           grepl <- base::grepl
[16:21:52.622]                           restarts <- computeRestarts(cond)
[16:21:52.622]                           for (restart in restarts) {
[16:21:52.622]                             name <- restart$name
[16:21:52.622]                             if (is.null(name)) 
[16:21:52.622]                               next
[16:21:52.622]                             if (!grepl(pattern, name)) 
[16:21:52.622]                               next
[16:21:52.622]                             invokeRestart(restart)
[16:21:52.622]                             muffled <- TRUE
[16:21:52.622]                             break
[16:21:52.622]                           }
[16:21:52.622]                         }
[16:21:52.622]                       }
[16:21:52.622]                       invisible(muffled)
[16:21:52.622]                     }
[16:21:52.622]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.622]                   }
[16:21:52.622]                 }
[16:21:52.622]                 else {
[16:21:52.622]                   if (TRUE) {
[16:21:52.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.622]                     {
[16:21:52.622]                       inherits <- base::inherits
[16:21:52.622]                       invokeRestart <- base::invokeRestart
[16:21:52.622]                       is.null <- base::is.null
[16:21:52.622]                       muffled <- FALSE
[16:21:52.622]                       if (inherits(cond, "message")) {
[16:21:52.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.622]                         if (muffled) 
[16:21:52.622]                           invokeRestart("muffleMessage")
[16:21:52.622]                       }
[16:21:52.622]                       else if (inherits(cond, "warning")) {
[16:21:52.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.622]                         if (muffled) 
[16:21:52.622]                           invokeRestart("muffleWarning")
[16:21:52.622]                       }
[16:21:52.622]                       else if (inherits(cond, "condition")) {
[16:21:52.622]                         if (!is.null(pattern)) {
[16:21:52.622]                           computeRestarts <- base::computeRestarts
[16:21:52.622]                           grepl <- base::grepl
[16:21:52.622]                           restarts <- computeRestarts(cond)
[16:21:52.622]                           for (restart in restarts) {
[16:21:52.622]                             name <- restart$name
[16:21:52.622]                             if (is.null(name)) 
[16:21:52.622]                               next
[16:21:52.622]                             if (!grepl(pattern, name)) 
[16:21:52.622]                               next
[16:21:52.622]                             invokeRestart(restart)
[16:21:52.622]                             muffled <- TRUE
[16:21:52.622]                             break
[16:21:52.622]                           }
[16:21:52.622]                         }
[16:21:52.622]                       }
[16:21:52.622]                       invisible(muffled)
[16:21:52.622]                     }
[16:21:52.622]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.622]                   }
[16:21:52.622]                 }
[16:21:52.622]             }
[16:21:52.622]         }))
[16:21:52.622]     }, error = function(ex) {
[16:21:52.622]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.622]                 ...future.rng), started = ...future.startTime, 
[16:21:52.622]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.622]             version = "1.8"), class = "FutureResult")
[16:21:52.622]     }, finally = {
[16:21:52.622]         if (!identical(...future.workdir, getwd())) 
[16:21:52.622]             setwd(...future.workdir)
[16:21:52.622]         {
[16:21:52.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.622]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.622]             }
[16:21:52.622]             base::options(...future.oldOptions)
[16:21:52.622]             if (.Platform$OS.type == "windows") {
[16:21:52.622]                 old_names <- names(...future.oldEnvVars)
[16:21:52.622]                 envs <- base::Sys.getenv()
[16:21:52.622]                 names <- names(envs)
[16:21:52.622]                 common <- intersect(names, old_names)
[16:21:52.622]                 added <- setdiff(names, old_names)
[16:21:52.622]                 removed <- setdiff(old_names, names)
[16:21:52.622]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.622]                   envs[common]]
[16:21:52.622]                 NAMES <- toupper(changed)
[16:21:52.622]                 args <- list()
[16:21:52.622]                 for (kk in seq_along(NAMES)) {
[16:21:52.622]                   name <- changed[[kk]]
[16:21:52.622]                   NAME <- NAMES[[kk]]
[16:21:52.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.622]                     next
[16:21:52.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.622]                 }
[16:21:52.622]                 NAMES <- toupper(added)
[16:21:52.622]                 for (kk in seq_along(NAMES)) {
[16:21:52.622]                   name <- added[[kk]]
[16:21:52.622]                   NAME <- NAMES[[kk]]
[16:21:52.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.622]                     next
[16:21:52.622]                   args[[name]] <- ""
[16:21:52.622]                 }
[16:21:52.622]                 NAMES <- toupper(removed)
[16:21:52.622]                 for (kk in seq_along(NAMES)) {
[16:21:52.622]                   name <- removed[[kk]]
[16:21:52.622]                   NAME <- NAMES[[kk]]
[16:21:52.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.622]                     next
[16:21:52.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.622]                 }
[16:21:52.622]                 if (length(args) > 0) 
[16:21:52.622]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.622]             }
[16:21:52.622]             else {
[16:21:52.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.622]             }
[16:21:52.622]             {
[16:21:52.622]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.622]                   0L) {
[16:21:52.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.622]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.622]                   base::options(opts)
[16:21:52.622]                 }
[16:21:52.622]                 {
[16:21:52.622]                   {
[16:21:52.622]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.622]                     NULL
[16:21:52.622]                   }
[16:21:52.622]                   options(future.plan = NULL)
[16:21:52.622]                   if (is.na(NA_character_)) 
[16:21:52.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.622]                     .init = FALSE)
[16:21:52.622]                 }
[16:21:52.622]             }
[16:21:52.622]         }
[16:21:52.622]     })
[16:21:52.622]     if (TRUE) {
[16:21:52.622]         base::sink(type = "output", split = FALSE)
[16:21:52.622]         if (TRUE) {
[16:21:52.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.622]         }
[16:21:52.622]         else {
[16:21:52.622]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.622]         }
[16:21:52.622]         base::close(...future.stdout)
[16:21:52.622]         ...future.stdout <- NULL
[16:21:52.622]     }
[16:21:52.622]     ...future.result$conditions <- ...future.conditions
[16:21:52.622]     ...future.result$finished <- base::Sys.time()
[16:21:52.622]     ...future.result
[16:21:52.622] }
[16:21:52.626] assign_globals() ...
[16:21:52.626] List of 1
[16:21:52.626]  $ kk: int 2
[16:21:52.626]  - attr(*, "where")=List of 1
[16:21:52.626]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:52.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:52.626]  - attr(*, "resolved")= logi FALSE
[16:21:52.626]  - attr(*, "total_size")= num 56
[16:21:52.626]  - attr(*, "already-done")= logi TRUE
[16:21:52.630] - copied ‘kk’ to environment
[16:21:52.630] assign_globals() ... done
[16:21:52.630] requestCore(): workers = 2
[16:21:52.631] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.641] result() for MulticoreFuture ...
[16:21:52.642] result() for MulticoreFuture ...
[16:21:52.642] result() for MulticoreFuture ... done
[16:21:52.643] result() for MulticoreFuture ... done
[16:21:52.643] result() for MulticoreFuture ...
[16:21:52.643] result() for MulticoreFuture ... done
[16:21:52.646] MulticoreFuture started
[16:21:52.646] - Launch lazy future ... done
[16:21:52.647] run() for ‘MulticoreFuture’ ... done
[16:21:52.647] plan(): Setting new future strategy stack:
[16:21:52.647] List of future strategies:
[16:21:52.647] 1. sequential:
[16:21:52.647]    - args: function (..., envir = parent.frame())
[16:21:52.647]    - tweaked: FALSE
[16:21:52.647]    - call: NULL
[16:21:52.648] plan(): nbrOfWorkers() = 1
[16:21:52.657] run() for ‘Future’ ...
[16:21:52.658] - state: ‘created’
[16:21:52.658] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.664] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.664]   - Field: ‘label’
[16:21:52.664]   - Field: ‘local’
[16:21:52.664]   - Field: ‘owner’
[16:21:52.664]   - Field: ‘envir’
[16:21:52.665]   - Field: ‘workers’
[16:21:52.665]   - Field: ‘packages’
[16:21:52.665]   - Field: ‘gc’
[16:21:52.665]   - Field: ‘job’
[16:21:52.665]   - Field: ‘conditions’
[16:21:52.665]   - Field: ‘expr’
[16:21:52.666]   - Field: ‘uuid’
[16:21:52.666]   - Field: ‘seed’
[16:21:52.666]   - Field: ‘version’
[16:21:52.666]   - Field: ‘result’
[16:21:52.666]   - Field: ‘asynchronous’
[16:21:52.666]   - Field: ‘calls’
[16:21:52.666]   - Field: ‘globals’
[16:21:52.667]   - Field: ‘stdout’
[16:21:52.667]   - Field: ‘earlySignal’
[16:21:52.667]   - Field: ‘lazy’
[16:21:52.667]   - Field: ‘state’
[16:21:52.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.667] - Launch lazy future ...
[16:21:52.668] Packages needed by the future expression (n = 0): <none>
[16:21:52.668] Packages needed by future strategies (n = 0): <none>
[16:21:52.669] {
[16:21:52.669]     {
[16:21:52.669]         {
[16:21:52.669]             ...future.startTime <- base::Sys.time()
[16:21:52.669]             {
[16:21:52.669]                 {
[16:21:52.669]                   {
[16:21:52.669]                     {
[16:21:52.669]                       base::local({
[16:21:52.669]                         has_future <- base::requireNamespace("future", 
[16:21:52.669]                           quietly = TRUE)
[16:21:52.669]                         if (has_future) {
[16:21:52.669]                           ns <- base::getNamespace("future")
[16:21:52.669]                           version <- ns[[".package"]][["version"]]
[16:21:52.669]                           if (is.null(version)) 
[16:21:52.669]                             version <- utils::packageVersion("future")
[16:21:52.669]                         }
[16:21:52.669]                         else {
[16:21:52.669]                           version <- NULL
[16:21:52.669]                         }
[16:21:52.669]                         if (!has_future || version < "1.8.0") {
[16:21:52.669]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.669]                             "", base::R.version$version.string), 
[16:21:52.669]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.669]                               "release", "version")], collapse = " "), 
[16:21:52.669]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.669]                             info)
[16:21:52.669]                           info <- base::paste(info, collapse = "; ")
[16:21:52.669]                           if (!has_future) {
[16:21:52.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.669]                               info)
[16:21:52.669]                           }
[16:21:52.669]                           else {
[16:21:52.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.669]                               info, version)
[16:21:52.669]                           }
[16:21:52.669]                           base::stop(msg)
[16:21:52.669]                         }
[16:21:52.669]                       })
[16:21:52.669]                     }
[16:21:52.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.669]                     base::options(mc.cores = 1L)
[16:21:52.669]                   }
[16:21:52.669]                   ...future.strategy.old <- future::plan("list")
[16:21:52.669]                   options(future.plan = NULL)
[16:21:52.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.669]                 }
[16:21:52.669]                 ...future.workdir <- getwd()
[16:21:52.669]             }
[16:21:52.669]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.669]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.669]         }
[16:21:52.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.669]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.669]             base::names(...future.oldOptions))
[16:21:52.669]     }
[16:21:52.669]     if (FALSE) {
[16:21:52.669]     }
[16:21:52.669]     else {
[16:21:52.669]         if (TRUE) {
[16:21:52.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.669]                 open = "w")
[16:21:52.669]         }
[16:21:52.669]         else {
[16:21:52.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.669]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.669]         }
[16:21:52.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.669]             base::sink(type = "output", split = FALSE)
[16:21:52.669]             base::close(...future.stdout)
[16:21:52.669]         }, add = TRUE)
[16:21:52.669]     }
[16:21:52.669]     ...future.frame <- base::sys.nframe()
[16:21:52.669]     ...future.conditions <- base::list()
[16:21:52.669]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.669]     if (FALSE) {
[16:21:52.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.669]     }
[16:21:52.669]     ...future.result <- base::tryCatch({
[16:21:52.669]         base::withCallingHandlers({
[16:21:52.669]             ...future.value <- base::withVisible(base::local({
[16:21:52.669]                 withCallingHandlers({
[16:21:52.669]                   {
[16:21:52.669]                     Sys.sleep(0.1)
[16:21:52.669]                     kk
[16:21:52.669]                   }
[16:21:52.669]                 }, immediateCondition = function(cond) {
[16:21:52.669]                   save_rds <- function (object, pathname, ...) 
[16:21:52.669]                   {
[16:21:52.669]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.669]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.669]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.669]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.669]                         fi_tmp[["mtime"]])
[16:21:52.669]                     }
[16:21:52.669]                     tryCatch({
[16:21:52.669]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.669]                     }, error = function(ex) {
[16:21:52.669]                       msg <- conditionMessage(ex)
[16:21:52.669]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.669]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.669]                         fi_tmp[["mtime"]], msg)
[16:21:52.669]                       ex$message <- msg
[16:21:52.669]                       stop(ex)
[16:21:52.669]                     })
[16:21:52.669]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.669]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.669]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.669]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.669]                       fi <- file.info(pathname)
[16:21:52.669]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.669]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.669]                         fi[["size"]], fi[["mtime"]])
[16:21:52.669]                       stop(msg)
[16:21:52.669]                     }
[16:21:52.669]                     invisible(pathname)
[16:21:52.669]                   }
[16:21:52.669]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.669]                     rootPath = tempdir()) 
[16:21:52.669]                   {
[16:21:52.669]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.669]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.669]                       tmpdir = path, fileext = ".rds")
[16:21:52.669]                     save_rds(obj, file)
[16:21:52.669]                   }
[16:21:52.669]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.669]                   {
[16:21:52.669]                     inherits <- base::inherits
[16:21:52.669]                     invokeRestart <- base::invokeRestart
[16:21:52.669]                     is.null <- base::is.null
[16:21:52.669]                     muffled <- FALSE
[16:21:52.669]                     if (inherits(cond, "message")) {
[16:21:52.669]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.669]                       if (muffled) 
[16:21:52.669]                         invokeRestart("muffleMessage")
[16:21:52.669]                     }
[16:21:52.669]                     else if (inherits(cond, "warning")) {
[16:21:52.669]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.669]                       if (muffled) 
[16:21:52.669]                         invokeRestart("muffleWarning")
[16:21:52.669]                     }
[16:21:52.669]                     else if (inherits(cond, "condition")) {
[16:21:52.669]                       if (!is.null(pattern)) {
[16:21:52.669]                         computeRestarts <- base::computeRestarts
[16:21:52.669]                         grepl <- base::grepl
[16:21:52.669]                         restarts <- computeRestarts(cond)
[16:21:52.669]                         for (restart in restarts) {
[16:21:52.669]                           name <- restart$name
[16:21:52.669]                           if (is.null(name)) 
[16:21:52.669]                             next
[16:21:52.669]                           if (!grepl(pattern, name)) 
[16:21:52.669]                             next
[16:21:52.669]                           invokeRestart(restart)
[16:21:52.669]                           muffled <- TRUE
[16:21:52.669]                           break
[16:21:52.669]                         }
[16:21:52.669]                       }
[16:21:52.669]                     }
[16:21:52.669]                     invisible(muffled)
[16:21:52.669]                   }
[16:21:52.669]                   muffleCondition(cond)
[16:21:52.669]                 })
[16:21:52.669]             }))
[16:21:52.669]             future::FutureResult(value = ...future.value$value, 
[16:21:52.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.669]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.669]                     ...future.globalenv.names))
[16:21:52.669]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.669]         }, condition = base::local({
[16:21:52.669]             c <- base::c
[16:21:52.669]             inherits <- base::inherits
[16:21:52.669]             invokeRestart <- base::invokeRestart
[16:21:52.669]             length <- base::length
[16:21:52.669]             list <- base::list
[16:21:52.669]             seq.int <- base::seq.int
[16:21:52.669]             signalCondition <- base::signalCondition
[16:21:52.669]             sys.calls <- base::sys.calls
[16:21:52.669]             `[[` <- base::`[[`
[16:21:52.669]             `+` <- base::`+`
[16:21:52.669]             `<<-` <- base::`<<-`
[16:21:52.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.669]                   3L)]
[16:21:52.669]             }
[16:21:52.669]             function(cond) {
[16:21:52.669]                 is_error <- inherits(cond, "error")
[16:21:52.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.669]                   NULL)
[16:21:52.669]                 if (is_error) {
[16:21:52.669]                   sessionInformation <- function() {
[16:21:52.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.669]                       search = base::search(), system = base::Sys.info())
[16:21:52.669]                   }
[16:21:52.669]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.669]                     cond$call), session = sessionInformation(), 
[16:21:52.669]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.669]                   signalCondition(cond)
[16:21:52.669]                 }
[16:21:52.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.669]                 "immediateCondition"))) {
[16:21:52.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.669]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.669]                   if (TRUE && !signal) {
[16:21:52.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.669]                     {
[16:21:52.669]                       inherits <- base::inherits
[16:21:52.669]                       invokeRestart <- base::invokeRestart
[16:21:52.669]                       is.null <- base::is.null
[16:21:52.669]                       muffled <- FALSE
[16:21:52.669]                       if (inherits(cond, "message")) {
[16:21:52.669]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.669]                         if (muffled) 
[16:21:52.669]                           invokeRestart("muffleMessage")
[16:21:52.669]                       }
[16:21:52.669]                       else if (inherits(cond, "warning")) {
[16:21:52.669]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.669]                         if (muffled) 
[16:21:52.669]                           invokeRestart("muffleWarning")
[16:21:52.669]                       }
[16:21:52.669]                       else if (inherits(cond, "condition")) {
[16:21:52.669]                         if (!is.null(pattern)) {
[16:21:52.669]                           computeRestarts <- base::computeRestarts
[16:21:52.669]                           grepl <- base::grepl
[16:21:52.669]                           restarts <- computeRestarts(cond)
[16:21:52.669]                           for (restart in restarts) {
[16:21:52.669]                             name <- restart$name
[16:21:52.669]                             if (is.null(name)) 
[16:21:52.669]                               next
[16:21:52.669]                             if (!grepl(pattern, name)) 
[16:21:52.669]                               next
[16:21:52.669]                             invokeRestart(restart)
[16:21:52.669]                             muffled <- TRUE
[16:21:52.669]                             break
[16:21:52.669]                           }
[16:21:52.669]                         }
[16:21:52.669]                       }
[16:21:52.669]                       invisible(muffled)
[16:21:52.669]                     }
[16:21:52.669]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.669]                   }
[16:21:52.669]                 }
[16:21:52.669]                 else {
[16:21:52.669]                   if (TRUE) {
[16:21:52.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.669]                     {
[16:21:52.669]                       inherits <- base::inherits
[16:21:52.669]                       invokeRestart <- base::invokeRestart
[16:21:52.669]                       is.null <- base::is.null
[16:21:52.669]                       muffled <- FALSE
[16:21:52.669]                       if (inherits(cond, "message")) {
[16:21:52.669]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.669]                         if (muffled) 
[16:21:52.669]                           invokeRestart("muffleMessage")
[16:21:52.669]                       }
[16:21:52.669]                       else if (inherits(cond, "warning")) {
[16:21:52.669]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.669]                         if (muffled) 
[16:21:52.669]                           invokeRestart("muffleWarning")
[16:21:52.669]                       }
[16:21:52.669]                       else if (inherits(cond, "condition")) {
[16:21:52.669]                         if (!is.null(pattern)) {
[16:21:52.669]                           computeRestarts <- base::computeRestarts
[16:21:52.669]                           grepl <- base::grepl
[16:21:52.669]                           restarts <- computeRestarts(cond)
[16:21:52.669]                           for (restart in restarts) {
[16:21:52.669]                             name <- restart$name
[16:21:52.669]                             if (is.null(name)) 
[16:21:52.669]                               next
[16:21:52.669]                             if (!grepl(pattern, name)) 
[16:21:52.669]                               next
[16:21:52.669]                             invokeRestart(restart)
[16:21:52.669]                             muffled <- TRUE
[16:21:52.669]                             break
[16:21:52.669]                           }
[16:21:52.669]                         }
[16:21:52.669]                       }
[16:21:52.669]                       invisible(muffled)
[16:21:52.669]                     }
[16:21:52.669]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.669]                   }
[16:21:52.669]                 }
[16:21:52.669]             }
[16:21:52.669]         }))
[16:21:52.669]     }, error = function(ex) {
[16:21:52.669]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.669]                 ...future.rng), started = ...future.startTime, 
[16:21:52.669]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.669]             version = "1.8"), class = "FutureResult")
[16:21:52.669]     }, finally = {
[16:21:52.669]         if (!identical(...future.workdir, getwd())) 
[16:21:52.669]             setwd(...future.workdir)
[16:21:52.669]         {
[16:21:52.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.669]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.669]             }
[16:21:52.669]             base::options(...future.oldOptions)
[16:21:52.669]             if (.Platform$OS.type == "windows") {
[16:21:52.669]                 old_names <- names(...future.oldEnvVars)
[16:21:52.669]                 envs <- base::Sys.getenv()
[16:21:52.669]                 names <- names(envs)
[16:21:52.669]                 common <- intersect(names, old_names)
[16:21:52.669]                 added <- setdiff(names, old_names)
[16:21:52.669]                 removed <- setdiff(old_names, names)
[16:21:52.669]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.669]                   envs[common]]
[16:21:52.669]                 NAMES <- toupper(changed)
[16:21:52.669]                 args <- list()
[16:21:52.669]                 for (kk in seq_along(NAMES)) {
[16:21:52.669]                   name <- changed[[kk]]
[16:21:52.669]                   NAME <- NAMES[[kk]]
[16:21:52.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.669]                     next
[16:21:52.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.669]                 }
[16:21:52.669]                 NAMES <- toupper(added)
[16:21:52.669]                 for (kk in seq_along(NAMES)) {
[16:21:52.669]                   name <- added[[kk]]
[16:21:52.669]                   NAME <- NAMES[[kk]]
[16:21:52.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.669]                     next
[16:21:52.669]                   args[[name]] <- ""
[16:21:52.669]                 }
[16:21:52.669]                 NAMES <- toupper(removed)
[16:21:52.669]                 for (kk in seq_along(NAMES)) {
[16:21:52.669]                   name <- removed[[kk]]
[16:21:52.669]                   NAME <- NAMES[[kk]]
[16:21:52.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.669]                     next
[16:21:52.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.669]                 }
[16:21:52.669]                 if (length(args) > 0) 
[16:21:52.669]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.669]             }
[16:21:52.669]             else {
[16:21:52.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.669]             }
[16:21:52.669]             {
[16:21:52.669]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.669]                   0L) {
[16:21:52.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.669]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.669]                   base::options(opts)
[16:21:52.669]                 }
[16:21:52.669]                 {
[16:21:52.669]                   {
[16:21:52.669]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.669]                     NULL
[16:21:52.669]                   }
[16:21:52.669]                   options(future.plan = NULL)
[16:21:52.669]                   if (is.na(NA_character_)) 
[16:21:52.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.669]                     .init = FALSE)
[16:21:52.669]                 }
[16:21:52.669]             }
[16:21:52.669]         }
[16:21:52.669]     })
[16:21:52.669]     if (TRUE) {
[16:21:52.669]         base::sink(type = "output", split = FALSE)
[16:21:52.669]         if (TRUE) {
[16:21:52.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.669]         }
[16:21:52.669]         else {
[16:21:52.669]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.669]         }
[16:21:52.669]         base::close(...future.stdout)
[16:21:52.669]         ...future.stdout <- NULL
[16:21:52.669]     }
[16:21:52.669]     ...future.result$conditions <- ...future.conditions
[16:21:52.669]     ...future.result$finished <- base::Sys.time()
[16:21:52.669]     ...future.result
[16:21:52.669] }
[16:21:52.672] assign_globals() ...
[16:21:52.672] List of 1
[16:21:52.672]  $ kk: int 3
[16:21:52.672]  - attr(*, "where")=List of 1
[16:21:52.672]   ..$ kk:<environment: R_EmptyEnv> 
[16:21:52.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:21:52.672]  - attr(*, "resolved")= logi FALSE
[16:21:52.672]  - attr(*, "total_size")= num 56
[16:21:52.672]  - attr(*, "already-done")= logi TRUE
[16:21:52.683] - copied ‘kk’ to environment
[16:21:52.683] assign_globals() ... done
[16:21:52.683] requestCore(): workers = 2
[16:21:52.684] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.704] plan(): Setting new future strategy stack:
[16:21:52.704] List of future strategies:
[16:21:52.704] 1. multicore:
[16:21:52.704]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.704]    - tweaked: FALSE
[16:21:52.704]    - call: plan(strategy)
[16:21:52.709] plan(): nbrOfWorkers() = 2
[16:21:52.715] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[16:21:52.726] result() for MulticoreFuture ...
[16:21:52.727] result() for MulticoreFuture ...
[16:21:52.727] result() for MulticoreFuture ... done
[16:21:52.727] result() for MulticoreFuture ... done
[16:21:52.727] result() for MulticoreFuture ...
[16:21:52.728] result() for MulticoreFuture ... done
[16:21:52.730] MulticoreFuture started
[16:21:52.731] - Launch lazy future ... done
[16:21:52.731] run() for ‘MulticoreFuture’ ... done
[16:21:52.732] plan(): Setting new future strategy stack:
[16:21:52.732] List of future strategies:
[16:21:52.732] 1. sequential:
[16:21:52.732]    - args: function (..., envir = parent.frame())
[16:21:52.732]    - tweaked: FALSE
[16:21:52.732]    - call: NULL
[16:21:52.734] plan(): nbrOfWorkers() = 1
[16:21:52.750] plan(): Setting new future strategy stack:
[16:21:52.751] List of future strategies:
[16:21:52.751] 1. multicore:
[16:21:52.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.751]    - tweaked: FALSE
[16:21:52.751]    - call: plan(strategy)
[16:21:52.752] Future #1
[16:21:52.753]  length: 2 (resolved future 1)
[16:21:52.755] plan(): nbrOfWorkers() = 2
[16:21:52.756] Future #2
[16:21:52.756]  length: 1 (resolved future 2)
[16:21:52.836] plan(): Setting new future strategy stack:
[16:21:52.837] List of future strategies:
[16:21:52.837] 1. multicore:
[16:21:52.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.837]    - tweaked: FALSE
[16:21:52.837]    - call: plan(strategy)
[16:21:52.842] plan(): nbrOfWorkers() = 2
[16:21:52.843] Future #3
[16:21:52.843]  length: 0 (resolved future 3)
[16:21:52.843] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:21:52.845] resolve() on environment ...
[16:21:52.845]  recursive: 0
[16:21:52.846]  elements: [2] ‘a’, ‘b’
[16:21:52.846]  length: 1 (resolved future 1)
[16:21:52.846]  length: 0 (resolved future 2)
[16:21:52.846] resolve() on environment ... DONE
[16:21:52.847] getGlobalsAndPackages() ...
[16:21:52.847] Searching for globals...
[16:21:52.848] 
[16:21:52.848] Searching for globals ... DONE
[16:21:52.848] - globals: [0] <none>
[16:21:52.848] getGlobalsAndPackages() ... DONE
[16:21:52.849] run() for ‘Future’ ...
[16:21:52.849] - state: ‘created’
[16:21:52.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.854] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.854]   - Field: ‘label’
[16:21:52.854]   - Field: ‘local’
[16:21:52.855]   - Field: ‘owner’
[16:21:52.855]   - Field: ‘envir’
[16:21:52.855]   - Field: ‘workers’
[16:21:52.855]   - Field: ‘packages’
[16:21:52.855]   - Field: ‘gc’
[16:21:52.855]   - Field: ‘job’
[16:21:52.855]   - Field: ‘conditions’
[16:21:52.856]   - Field: ‘expr’
[16:21:52.856]   - Field: ‘uuid’
[16:21:52.856]   - Field: ‘seed’
[16:21:52.856]   - Field: ‘version’
[16:21:52.856]   - Field: ‘result’
[16:21:52.856]   - Field: ‘asynchronous’
[16:21:52.857]   - Field: ‘calls’
[16:21:52.857]   - Field: ‘globals’
[16:21:52.857]   - Field: ‘stdout’
[16:21:52.857]   - Field: ‘earlySignal’
[16:21:52.857]   - Field: ‘lazy’
[16:21:52.857]   - Field: ‘state’
[16:21:52.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.858] - Launch lazy future ...
[16:21:52.858] Packages needed by the future expression (n = 0): <none>
[16:21:52.858] Packages needed by future strategies (n = 0): <none>
[16:21:52.859] {
[16:21:52.859]     {
[16:21:52.859]         {
[16:21:52.859]             ...future.startTime <- base::Sys.time()
[16:21:52.859]             {
[16:21:52.859]                 {
[16:21:52.859]                   {
[16:21:52.859]                     {
[16:21:52.859]                       base::local({
[16:21:52.859]                         has_future <- base::requireNamespace("future", 
[16:21:52.859]                           quietly = TRUE)
[16:21:52.859]                         if (has_future) {
[16:21:52.859]                           ns <- base::getNamespace("future")
[16:21:52.859]                           version <- ns[[".package"]][["version"]]
[16:21:52.859]                           if (is.null(version)) 
[16:21:52.859]                             version <- utils::packageVersion("future")
[16:21:52.859]                         }
[16:21:52.859]                         else {
[16:21:52.859]                           version <- NULL
[16:21:52.859]                         }
[16:21:52.859]                         if (!has_future || version < "1.8.0") {
[16:21:52.859]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.859]                             "", base::R.version$version.string), 
[16:21:52.859]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.859]                               "release", "version")], collapse = " "), 
[16:21:52.859]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.859]                             info)
[16:21:52.859]                           info <- base::paste(info, collapse = "; ")
[16:21:52.859]                           if (!has_future) {
[16:21:52.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.859]                               info)
[16:21:52.859]                           }
[16:21:52.859]                           else {
[16:21:52.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.859]                               info, version)
[16:21:52.859]                           }
[16:21:52.859]                           base::stop(msg)
[16:21:52.859]                         }
[16:21:52.859]                       })
[16:21:52.859]                     }
[16:21:52.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.859]                     base::options(mc.cores = 1L)
[16:21:52.859]                   }
[16:21:52.859]                   ...future.strategy.old <- future::plan("list")
[16:21:52.859]                   options(future.plan = NULL)
[16:21:52.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.859]                 }
[16:21:52.859]                 ...future.workdir <- getwd()
[16:21:52.859]             }
[16:21:52.859]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.859]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.859]         }
[16:21:52.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.859]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.859]             base::names(...future.oldOptions))
[16:21:52.859]     }
[16:21:52.859]     if (FALSE) {
[16:21:52.859]     }
[16:21:52.859]     else {
[16:21:52.859]         if (TRUE) {
[16:21:52.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.859]                 open = "w")
[16:21:52.859]         }
[16:21:52.859]         else {
[16:21:52.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.859]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.859]         }
[16:21:52.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.859]             base::sink(type = "output", split = FALSE)
[16:21:52.859]             base::close(...future.stdout)
[16:21:52.859]         }, add = TRUE)
[16:21:52.859]     }
[16:21:52.859]     ...future.frame <- base::sys.nframe()
[16:21:52.859]     ...future.conditions <- base::list()
[16:21:52.859]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.859]     if (FALSE) {
[16:21:52.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.859]     }
[16:21:52.859]     ...future.result <- base::tryCatch({
[16:21:52.859]         base::withCallingHandlers({
[16:21:52.859]             ...future.value <- base::withVisible(base::local({
[16:21:52.859]                 withCallingHandlers({
[16:21:52.859]                   1
[16:21:52.859]                 }, immediateCondition = function(cond) {
[16:21:52.859]                   save_rds <- function (object, pathname, ...) 
[16:21:52.859]                   {
[16:21:52.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.859]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.859]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.859]                         fi_tmp[["mtime"]])
[16:21:52.859]                     }
[16:21:52.859]                     tryCatch({
[16:21:52.859]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.859]                     }, error = function(ex) {
[16:21:52.859]                       msg <- conditionMessage(ex)
[16:21:52.859]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.859]                         fi_tmp[["mtime"]], msg)
[16:21:52.859]                       ex$message <- msg
[16:21:52.859]                       stop(ex)
[16:21:52.859]                     })
[16:21:52.859]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.859]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.859]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.859]                       fi <- file.info(pathname)
[16:21:52.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.859]                         fi[["size"]], fi[["mtime"]])
[16:21:52.859]                       stop(msg)
[16:21:52.859]                     }
[16:21:52.859]                     invisible(pathname)
[16:21:52.859]                   }
[16:21:52.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.859]                     rootPath = tempdir()) 
[16:21:52.859]                   {
[16:21:52.859]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.859]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.859]                       tmpdir = path, fileext = ".rds")
[16:21:52.859]                     save_rds(obj, file)
[16:21:52.859]                   }
[16:21:52.859]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.859]                   {
[16:21:52.859]                     inherits <- base::inherits
[16:21:52.859]                     invokeRestart <- base::invokeRestart
[16:21:52.859]                     is.null <- base::is.null
[16:21:52.859]                     muffled <- FALSE
[16:21:52.859]                     if (inherits(cond, "message")) {
[16:21:52.859]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.859]                       if (muffled) 
[16:21:52.859]                         invokeRestart("muffleMessage")
[16:21:52.859]                     }
[16:21:52.859]                     else if (inherits(cond, "warning")) {
[16:21:52.859]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.859]                       if (muffled) 
[16:21:52.859]                         invokeRestart("muffleWarning")
[16:21:52.859]                     }
[16:21:52.859]                     else if (inherits(cond, "condition")) {
[16:21:52.859]                       if (!is.null(pattern)) {
[16:21:52.859]                         computeRestarts <- base::computeRestarts
[16:21:52.859]                         grepl <- base::grepl
[16:21:52.859]                         restarts <- computeRestarts(cond)
[16:21:52.859]                         for (restart in restarts) {
[16:21:52.859]                           name <- restart$name
[16:21:52.859]                           if (is.null(name)) 
[16:21:52.859]                             next
[16:21:52.859]                           if (!grepl(pattern, name)) 
[16:21:52.859]                             next
[16:21:52.859]                           invokeRestart(restart)
[16:21:52.859]                           muffled <- TRUE
[16:21:52.859]                           break
[16:21:52.859]                         }
[16:21:52.859]                       }
[16:21:52.859]                     }
[16:21:52.859]                     invisible(muffled)
[16:21:52.859]                   }
[16:21:52.859]                   muffleCondition(cond)
[16:21:52.859]                 })
[16:21:52.859]             }))
[16:21:52.859]             future::FutureResult(value = ...future.value$value, 
[16:21:52.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.859]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.859]                     ...future.globalenv.names))
[16:21:52.859]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.859]         }, condition = base::local({
[16:21:52.859]             c <- base::c
[16:21:52.859]             inherits <- base::inherits
[16:21:52.859]             invokeRestart <- base::invokeRestart
[16:21:52.859]             length <- base::length
[16:21:52.859]             list <- base::list
[16:21:52.859]             seq.int <- base::seq.int
[16:21:52.859]             signalCondition <- base::signalCondition
[16:21:52.859]             sys.calls <- base::sys.calls
[16:21:52.859]             `[[` <- base::`[[`
[16:21:52.859]             `+` <- base::`+`
[16:21:52.859]             `<<-` <- base::`<<-`
[16:21:52.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.859]                   3L)]
[16:21:52.859]             }
[16:21:52.859]             function(cond) {
[16:21:52.859]                 is_error <- inherits(cond, "error")
[16:21:52.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.859]                   NULL)
[16:21:52.859]                 if (is_error) {
[16:21:52.859]                   sessionInformation <- function() {
[16:21:52.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.859]                       search = base::search(), system = base::Sys.info())
[16:21:52.859]                   }
[16:21:52.859]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.859]                     cond$call), session = sessionInformation(), 
[16:21:52.859]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.859]                   signalCondition(cond)
[16:21:52.859]                 }
[16:21:52.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.859]                 "immediateCondition"))) {
[16:21:52.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.859]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.859]                   if (TRUE && !signal) {
[16:21:52.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.859]                     {
[16:21:52.859]                       inherits <- base::inherits
[16:21:52.859]                       invokeRestart <- base::invokeRestart
[16:21:52.859]                       is.null <- base::is.null
[16:21:52.859]                       muffled <- FALSE
[16:21:52.859]                       if (inherits(cond, "message")) {
[16:21:52.859]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.859]                         if (muffled) 
[16:21:52.859]                           invokeRestart("muffleMessage")
[16:21:52.859]                       }
[16:21:52.859]                       else if (inherits(cond, "warning")) {
[16:21:52.859]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.859]                         if (muffled) 
[16:21:52.859]                           invokeRestart("muffleWarning")
[16:21:52.859]                       }
[16:21:52.859]                       else if (inherits(cond, "condition")) {
[16:21:52.859]                         if (!is.null(pattern)) {
[16:21:52.859]                           computeRestarts <- base::computeRestarts
[16:21:52.859]                           grepl <- base::grepl
[16:21:52.859]                           restarts <- computeRestarts(cond)
[16:21:52.859]                           for (restart in restarts) {
[16:21:52.859]                             name <- restart$name
[16:21:52.859]                             if (is.null(name)) 
[16:21:52.859]                               next
[16:21:52.859]                             if (!grepl(pattern, name)) 
[16:21:52.859]                               next
[16:21:52.859]                             invokeRestart(restart)
[16:21:52.859]                             muffled <- TRUE
[16:21:52.859]                             break
[16:21:52.859]                           }
[16:21:52.859]                         }
[16:21:52.859]                       }
[16:21:52.859]                       invisible(muffled)
[16:21:52.859]                     }
[16:21:52.859]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.859]                   }
[16:21:52.859]                 }
[16:21:52.859]                 else {
[16:21:52.859]                   if (TRUE) {
[16:21:52.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.859]                     {
[16:21:52.859]                       inherits <- base::inherits
[16:21:52.859]                       invokeRestart <- base::invokeRestart
[16:21:52.859]                       is.null <- base::is.null
[16:21:52.859]                       muffled <- FALSE
[16:21:52.859]                       if (inherits(cond, "message")) {
[16:21:52.859]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.859]                         if (muffled) 
[16:21:52.859]                           invokeRestart("muffleMessage")
[16:21:52.859]                       }
[16:21:52.859]                       else if (inherits(cond, "warning")) {
[16:21:52.859]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.859]                         if (muffled) 
[16:21:52.859]                           invokeRestart("muffleWarning")
[16:21:52.859]                       }
[16:21:52.859]                       else if (inherits(cond, "condition")) {
[16:21:52.859]                         if (!is.null(pattern)) {
[16:21:52.859]                           computeRestarts <- base::computeRestarts
[16:21:52.859]                           grepl <- base::grepl
[16:21:52.859]                           restarts <- computeRestarts(cond)
[16:21:52.859]                           for (restart in restarts) {
[16:21:52.859]                             name <- restart$name
[16:21:52.859]                             if (is.null(name)) 
[16:21:52.859]                               next
[16:21:52.859]                             if (!grepl(pattern, name)) 
[16:21:52.859]                               next
[16:21:52.859]                             invokeRestart(restart)
[16:21:52.859]                             muffled <- TRUE
[16:21:52.859]                             break
[16:21:52.859]                           }
[16:21:52.859]                         }
[16:21:52.859]                       }
[16:21:52.859]                       invisible(muffled)
[16:21:52.859]                     }
[16:21:52.859]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.859]                   }
[16:21:52.859]                 }
[16:21:52.859]             }
[16:21:52.859]         }))
[16:21:52.859]     }, error = function(ex) {
[16:21:52.859]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.859]                 ...future.rng), started = ...future.startTime, 
[16:21:52.859]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.859]             version = "1.8"), class = "FutureResult")
[16:21:52.859]     }, finally = {
[16:21:52.859]         if (!identical(...future.workdir, getwd())) 
[16:21:52.859]             setwd(...future.workdir)
[16:21:52.859]         {
[16:21:52.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.859]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.859]             }
[16:21:52.859]             base::options(...future.oldOptions)
[16:21:52.859]             if (.Platform$OS.type == "windows") {
[16:21:52.859]                 old_names <- names(...future.oldEnvVars)
[16:21:52.859]                 envs <- base::Sys.getenv()
[16:21:52.859]                 names <- names(envs)
[16:21:52.859]                 common <- intersect(names, old_names)
[16:21:52.859]                 added <- setdiff(names, old_names)
[16:21:52.859]                 removed <- setdiff(old_names, names)
[16:21:52.859]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.859]                   envs[common]]
[16:21:52.859]                 NAMES <- toupper(changed)
[16:21:52.859]                 args <- list()
[16:21:52.859]                 for (kk in seq_along(NAMES)) {
[16:21:52.859]                   name <- changed[[kk]]
[16:21:52.859]                   NAME <- NAMES[[kk]]
[16:21:52.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.859]                     next
[16:21:52.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.859]                 }
[16:21:52.859]                 NAMES <- toupper(added)
[16:21:52.859]                 for (kk in seq_along(NAMES)) {
[16:21:52.859]                   name <- added[[kk]]
[16:21:52.859]                   NAME <- NAMES[[kk]]
[16:21:52.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.859]                     next
[16:21:52.859]                   args[[name]] <- ""
[16:21:52.859]                 }
[16:21:52.859]                 NAMES <- toupper(removed)
[16:21:52.859]                 for (kk in seq_along(NAMES)) {
[16:21:52.859]                   name <- removed[[kk]]
[16:21:52.859]                   NAME <- NAMES[[kk]]
[16:21:52.859]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.859]                     next
[16:21:52.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.859]                 }
[16:21:52.859]                 if (length(args) > 0) 
[16:21:52.859]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.859]             }
[16:21:52.859]             else {
[16:21:52.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.859]             }
[16:21:52.859]             {
[16:21:52.859]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.859]                   0L) {
[16:21:52.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.859]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.859]                   base::options(opts)
[16:21:52.859]                 }
[16:21:52.859]                 {
[16:21:52.859]                   {
[16:21:52.859]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.859]                     NULL
[16:21:52.859]                   }
[16:21:52.859]                   options(future.plan = NULL)
[16:21:52.859]                   if (is.na(NA_character_)) 
[16:21:52.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.859]                     .init = FALSE)
[16:21:52.859]                 }
[16:21:52.859]             }
[16:21:52.859]         }
[16:21:52.859]     })
[16:21:52.859]     if (TRUE) {
[16:21:52.859]         base::sink(type = "output", split = FALSE)
[16:21:52.859]         if (TRUE) {
[16:21:52.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.859]         }
[16:21:52.859]         else {
[16:21:52.859]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.859]         }
[16:21:52.859]         base::close(...future.stdout)
[16:21:52.859]         ...future.stdout <- NULL
[16:21:52.859]     }
[16:21:52.859]     ...future.result$conditions <- ...future.conditions
[16:21:52.859]     ...future.result$finished <- base::Sys.time()
[16:21:52.859]     ...future.result
[16:21:52.859] }
[16:21:52.863] requestCore(): workers = 2
[16:21:52.863] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.874] result() for MulticoreFuture ...
[16:21:52.875] result() for MulticoreFuture ...
[16:21:52.875] result() for MulticoreFuture ... done
[16:21:52.875] result() for MulticoreFuture ... done
[16:21:52.875] result() for MulticoreFuture ...
[16:21:52.875] result() for MulticoreFuture ... done
[16:21:52.878] MulticoreFuture started
[16:21:52.878] - Launch lazy future ... done
[16:21:52.878] run() for ‘MulticoreFuture’ ... done
[16:21:52.879] getGlobalsAndPackages() ...
[16:21:52.879] Searching for globals...
[16:21:52.879] plan(): Setting new future strategy stack:
[16:21:52.880] 
[16:21:52.879] List of future strategies:
[16:21:52.879] 1. sequential:
[16:21:52.879]    - args: function (..., envir = parent.frame())
[16:21:52.879]    - tweaked: FALSE
[16:21:52.879]    - call: NULL
[16:21:52.881] Searching for globals ... DONE
[16:21:52.881] plan(): nbrOfWorkers() = 1
[16:21:52.881] - globals: [0] <none>
[16:21:52.881] getGlobalsAndPackages() ... DONE
[16:21:52.882] run() for ‘Future’ ...
[16:21:52.882] - state: ‘created’
[16:21:52.882] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.884] plan(): Setting new future strategy stack:
[16:21:52.884] List of future strategies:
[16:21:52.884] 1. multicore:
[16:21:52.884]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.884]    - tweaked: FALSE
[16:21:52.884]    - call: plan(strategy)
[16:21:52.889] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.889] plan(): nbrOfWorkers() = 2
[16:21:52.889]   - Field: ‘label’
[16:21:52.889]   - Field: ‘local’
[16:21:52.889]   - Field: ‘owner’
[16:21:52.889]   - Field: ‘envir’
[16:21:52.890]   - Field: ‘workers’
[16:21:52.890]   - Field: ‘packages’
[16:21:52.890]   - Field: ‘gc’
[16:21:52.890]   - Field: ‘job’
[16:21:52.890]   - Field: ‘conditions’
[16:21:52.890]   - Field: ‘expr’
[16:21:52.890]   - Field: ‘uuid’
[16:21:52.891]   - Field: ‘seed’
[16:21:52.891]   - Field: ‘version’
[16:21:52.891]   - Field: ‘result’
[16:21:52.891]   - Field: ‘asynchronous’
[16:21:52.891]   - Field: ‘calls’
[16:21:52.891]   - Field: ‘globals’
[16:21:52.892]   - Field: ‘stdout’
[16:21:52.892]   - Field: ‘earlySignal’
[16:21:52.892]   - Field: ‘lazy’
[16:21:52.892]   - Field: ‘state’
[16:21:52.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.892] - Launch lazy future ...
[16:21:52.893] Packages needed by the future expression (n = 0): <none>
[16:21:52.893] Packages needed by future strategies (n = 0): <none>
[16:21:52.894] {
[16:21:52.894]     {
[16:21:52.894]         {
[16:21:52.894]             ...future.startTime <- base::Sys.time()
[16:21:52.894]             {
[16:21:52.894]                 {
[16:21:52.894]                   {
[16:21:52.894]                     {
[16:21:52.894]                       base::local({
[16:21:52.894]                         has_future <- base::requireNamespace("future", 
[16:21:52.894]                           quietly = TRUE)
[16:21:52.894]                         if (has_future) {
[16:21:52.894]                           ns <- base::getNamespace("future")
[16:21:52.894]                           version <- ns[[".package"]][["version"]]
[16:21:52.894]                           if (is.null(version)) 
[16:21:52.894]                             version <- utils::packageVersion("future")
[16:21:52.894]                         }
[16:21:52.894]                         else {
[16:21:52.894]                           version <- NULL
[16:21:52.894]                         }
[16:21:52.894]                         if (!has_future || version < "1.8.0") {
[16:21:52.894]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.894]                             "", base::R.version$version.string), 
[16:21:52.894]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.894]                               "release", "version")], collapse = " "), 
[16:21:52.894]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.894]                             info)
[16:21:52.894]                           info <- base::paste(info, collapse = "; ")
[16:21:52.894]                           if (!has_future) {
[16:21:52.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.894]                               info)
[16:21:52.894]                           }
[16:21:52.894]                           else {
[16:21:52.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.894]                               info, version)
[16:21:52.894]                           }
[16:21:52.894]                           base::stop(msg)
[16:21:52.894]                         }
[16:21:52.894]                       })
[16:21:52.894]                     }
[16:21:52.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.894]                     base::options(mc.cores = 1L)
[16:21:52.894]                   }
[16:21:52.894]                   ...future.strategy.old <- future::plan("list")
[16:21:52.894]                   options(future.plan = NULL)
[16:21:52.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.894]                 }
[16:21:52.894]                 ...future.workdir <- getwd()
[16:21:52.894]             }
[16:21:52.894]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.894]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.894]         }
[16:21:52.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.894]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.894]             base::names(...future.oldOptions))
[16:21:52.894]     }
[16:21:52.894]     if (FALSE) {
[16:21:52.894]     }
[16:21:52.894]     else {
[16:21:52.894]         if (TRUE) {
[16:21:52.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.894]                 open = "w")
[16:21:52.894]         }
[16:21:52.894]         else {
[16:21:52.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.894]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.894]         }
[16:21:52.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.894]             base::sink(type = "output", split = FALSE)
[16:21:52.894]             base::close(...future.stdout)
[16:21:52.894]         }, add = TRUE)
[16:21:52.894]     }
[16:21:52.894]     ...future.frame <- base::sys.nframe()
[16:21:52.894]     ...future.conditions <- base::list()
[16:21:52.894]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.894]     if (FALSE) {
[16:21:52.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.894]     }
[16:21:52.894]     ...future.result <- base::tryCatch({
[16:21:52.894]         base::withCallingHandlers({
[16:21:52.894]             ...future.value <- base::withVisible(base::local({
[16:21:52.894]                 withCallingHandlers({
[16:21:52.894]                   2
[16:21:52.894]                 }, immediateCondition = function(cond) {
[16:21:52.894]                   save_rds <- function (object, pathname, ...) 
[16:21:52.894]                   {
[16:21:52.894]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.894]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.894]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.894]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.894]                         fi_tmp[["mtime"]])
[16:21:52.894]                     }
[16:21:52.894]                     tryCatch({
[16:21:52.894]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.894]                     }, error = function(ex) {
[16:21:52.894]                       msg <- conditionMessage(ex)
[16:21:52.894]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.894]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.894]                         fi_tmp[["mtime"]], msg)
[16:21:52.894]                       ex$message <- msg
[16:21:52.894]                       stop(ex)
[16:21:52.894]                     })
[16:21:52.894]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.894]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.894]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.894]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.894]                       fi <- file.info(pathname)
[16:21:52.894]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.894]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.894]                         fi[["size"]], fi[["mtime"]])
[16:21:52.894]                       stop(msg)
[16:21:52.894]                     }
[16:21:52.894]                     invisible(pathname)
[16:21:52.894]                   }
[16:21:52.894]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.894]                     rootPath = tempdir()) 
[16:21:52.894]                   {
[16:21:52.894]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.894]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.894]                       tmpdir = path, fileext = ".rds")
[16:21:52.894]                     save_rds(obj, file)
[16:21:52.894]                   }
[16:21:52.894]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.894]                   {
[16:21:52.894]                     inherits <- base::inherits
[16:21:52.894]                     invokeRestart <- base::invokeRestart
[16:21:52.894]                     is.null <- base::is.null
[16:21:52.894]                     muffled <- FALSE
[16:21:52.894]                     if (inherits(cond, "message")) {
[16:21:52.894]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.894]                       if (muffled) 
[16:21:52.894]                         invokeRestart("muffleMessage")
[16:21:52.894]                     }
[16:21:52.894]                     else if (inherits(cond, "warning")) {
[16:21:52.894]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.894]                       if (muffled) 
[16:21:52.894]                         invokeRestart("muffleWarning")
[16:21:52.894]                     }
[16:21:52.894]                     else if (inherits(cond, "condition")) {
[16:21:52.894]                       if (!is.null(pattern)) {
[16:21:52.894]                         computeRestarts <- base::computeRestarts
[16:21:52.894]                         grepl <- base::grepl
[16:21:52.894]                         restarts <- computeRestarts(cond)
[16:21:52.894]                         for (restart in restarts) {
[16:21:52.894]                           name <- restart$name
[16:21:52.894]                           if (is.null(name)) 
[16:21:52.894]                             next
[16:21:52.894]                           if (!grepl(pattern, name)) 
[16:21:52.894]                             next
[16:21:52.894]                           invokeRestart(restart)
[16:21:52.894]                           muffled <- TRUE
[16:21:52.894]                           break
[16:21:52.894]                         }
[16:21:52.894]                       }
[16:21:52.894]                     }
[16:21:52.894]                     invisible(muffled)
[16:21:52.894]                   }
[16:21:52.894]                   muffleCondition(cond)
[16:21:52.894]                 })
[16:21:52.894]             }))
[16:21:52.894]             future::FutureResult(value = ...future.value$value, 
[16:21:52.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.894]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.894]                     ...future.globalenv.names))
[16:21:52.894]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.894]         }, condition = base::local({
[16:21:52.894]             c <- base::c
[16:21:52.894]             inherits <- base::inherits
[16:21:52.894]             invokeRestart <- base::invokeRestart
[16:21:52.894]             length <- base::length
[16:21:52.894]             list <- base::list
[16:21:52.894]             seq.int <- base::seq.int
[16:21:52.894]             signalCondition <- base::signalCondition
[16:21:52.894]             sys.calls <- base::sys.calls
[16:21:52.894]             `[[` <- base::`[[`
[16:21:52.894]             `+` <- base::`+`
[16:21:52.894]             `<<-` <- base::`<<-`
[16:21:52.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.894]                   3L)]
[16:21:52.894]             }
[16:21:52.894]             function(cond) {
[16:21:52.894]                 is_error <- inherits(cond, "error")
[16:21:52.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.894]                   NULL)
[16:21:52.894]                 if (is_error) {
[16:21:52.894]                   sessionInformation <- function() {
[16:21:52.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.894]                       search = base::search(), system = base::Sys.info())
[16:21:52.894]                   }
[16:21:52.894]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.894]                     cond$call), session = sessionInformation(), 
[16:21:52.894]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.894]                   signalCondition(cond)
[16:21:52.894]                 }
[16:21:52.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.894]                 "immediateCondition"))) {
[16:21:52.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.894]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.894]                   if (TRUE && !signal) {
[16:21:52.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.894]                     {
[16:21:52.894]                       inherits <- base::inherits
[16:21:52.894]                       invokeRestart <- base::invokeRestart
[16:21:52.894]                       is.null <- base::is.null
[16:21:52.894]                       muffled <- FALSE
[16:21:52.894]                       if (inherits(cond, "message")) {
[16:21:52.894]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.894]                         if (muffled) 
[16:21:52.894]                           invokeRestart("muffleMessage")
[16:21:52.894]                       }
[16:21:52.894]                       else if (inherits(cond, "warning")) {
[16:21:52.894]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.894]                         if (muffled) 
[16:21:52.894]                           invokeRestart("muffleWarning")
[16:21:52.894]                       }
[16:21:52.894]                       else if (inherits(cond, "condition")) {
[16:21:52.894]                         if (!is.null(pattern)) {
[16:21:52.894]                           computeRestarts <- base::computeRestarts
[16:21:52.894]                           grepl <- base::grepl
[16:21:52.894]                           restarts <- computeRestarts(cond)
[16:21:52.894]                           for (restart in restarts) {
[16:21:52.894]                             name <- restart$name
[16:21:52.894]                             if (is.null(name)) 
[16:21:52.894]                               next
[16:21:52.894]                             if (!grepl(pattern, name)) 
[16:21:52.894]                               next
[16:21:52.894]                             invokeRestart(restart)
[16:21:52.894]                             muffled <- TRUE
[16:21:52.894]                             break
[16:21:52.894]                           }
[16:21:52.894]                         }
[16:21:52.894]                       }
[16:21:52.894]                       invisible(muffled)
[16:21:52.894]                     }
[16:21:52.894]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.894]                   }
[16:21:52.894]                 }
[16:21:52.894]                 else {
[16:21:52.894]                   if (TRUE) {
[16:21:52.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.894]                     {
[16:21:52.894]                       inherits <- base::inherits
[16:21:52.894]                       invokeRestart <- base::invokeRestart
[16:21:52.894]                       is.null <- base::is.null
[16:21:52.894]                       muffled <- FALSE
[16:21:52.894]                       if (inherits(cond, "message")) {
[16:21:52.894]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.894]                         if (muffled) 
[16:21:52.894]                           invokeRestart("muffleMessage")
[16:21:52.894]                       }
[16:21:52.894]                       else if (inherits(cond, "warning")) {
[16:21:52.894]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.894]                         if (muffled) 
[16:21:52.894]                           invokeRestart("muffleWarning")
[16:21:52.894]                       }
[16:21:52.894]                       else if (inherits(cond, "condition")) {
[16:21:52.894]                         if (!is.null(pattern)) {
[16:21:52.894]                           computeRestarts <- base::computeRestarts
[16:21:52.894]                           grepl <- base::grepl
[16:21:52.894]                           restarts <- computeRestarts(cond)
[16:21:52.894]                           for (restart in restarts) {
[16:21:52.894]                             name <- restart$name
[16:21:52.894]                             if (is.null(name)) 
[16:21:52.894]                               next
[16:21:52.894]                             if (!grepl(pattern, name)) 
[16:21:52.894]                               next
[16:21:52.894]                             invokeRestart(restart)
[16:21:52.894]                             muffled <- TRUE
[16:21:52.894]                             break
[16:21:52.894]                           }
[16:21:52.894]                         }
[16:21:52.894]                       }
[16:21:52.894]                       invisible(muffled)
[16:21:52.894]                     }
[16:21:52.894]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.894]                   }
[16:21:52.894]                 }
[16:21:52.894]             }
[16:21:52.894]         }))
[16:21:52.894]     }, error = function(ex) {
[16:21:52.894]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.894]                 ...future.rng), started = ...future.startTime, 
[16:21:52.894]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.894]             version = "1.8"), class = "FutureResult")
[16:21:52.894]     }, finally = {
[16:21:52.894]         if (!identical(...future.workdir, getwd())) 
[16:21:52.894]             setwd(...future.workdir)
[16:21:52.894]         {
[16:21:52.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.894]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.894]             }
[16:21:52.894]             base::options(...future.oldOptions)
[16:21:52.894]             if (.Platform$OS.type == "windows") {
[16:21:52.894]                 old_names <- names(...future.oldEnvVars)
[16:21:52.894]                 envs <- base::Sys.getenv()
[16:21:52.894]                 names <- names(envs)
[16:21:52.894]                 common <- intersect(names, old_names)
[16:21:52.894]                 added <- setdiff(names, old_names)
[16:21:52.894]                 removed <- setdiff(old_names, names)
[16:21:52.894]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.894]                   envs[common]]
[16:21:52.894]                 NAMES <- toupper(changed)
[16:21:52.894]                 args <- list()
[16:21:52.894]                 for (kk in seq_along(NAMES)) {
[16:21:52.894]                   name <- changed[[kk]]
[16:21:52.894]                   NAME <- NAMES[[kk]]
[16:21:52.894]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.894]                     next
[16:21:52.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.894]                 }
[16:21:52.894]                 NAMES <- toupper(added)
[16:21:52.894]                 for (kk in seq_along(NAMES)) {
[16:21:52.894]                   name <- added[[kk]]
[16:21:52.894]                   NAME <- NAMES[[kk]]
[16:21:52.894]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.894]                     next
[16:21:52.894]                   args[[name]] <- ""
[16:21:52.894]                 }
[16:21:52.894]                 NAMES <- toupper(removed)
[16:21:52.894]                 for (kk in seq_along(NAMES)) {
[16:21:52.894]                   name <- removed[[kk]]
[16:21:52.894]                   NAME <- NAMES[[kk]]
[16:21:52.894]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.894]                     next
[16:21:52.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.894]                 }
[16:21:52.894]                 if (length(args) > 0) 
[16:21:52.894]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.894]             }
[16:21:52.894]             else {
[16:21:52.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.894]             }
[16:21:52.894]             {
[16:21:52.894]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.894]                   0L) {
[16:21:52.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.894]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.894]                   base::options(opts)
[16:21:52.894]                 }
[16:21:52.894]                 {
[16:21:52.894]                   {
[16:21:52.894]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.894]                     NULL
[16:21:52.894]                   }
[16:21:52.894]                   options(future.plan = NULL)
[16:21:52.894]                   if (is.na(NA_character_)) 
[16:21:52.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.894]                     .init = FALSE)
[16:21:52.894]                 }
[16:21:52.894]             }
[16:21:52.894]         }
[16:21:52.894]     })
[16:21:52.894]     if (TRUE) {
[16:21:52.894]         base::sink(type = "output", split = FALSE)
[16:21:52.894]         if (TRUE) {
[16:21:52.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.894]         }
[16:21:52.894]         else {
[16:21:52.894]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.894]         }
[16:21:52.894]         base::close(...future.stdout)
[16:21:52.894]         ...future.stdout <- NULL
[16:21:52.894]     }
[16:21:52.894]     ...future.result$conditions <- ...future.conditions
[16:21:52.894]     ...future.result$finished <- base::Sys.time()
[16:21:52.894]     ...future.result
[16:21:52.894] }
[16:21:52.898] requestCore(): workers = 2
[16:21:52.898] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.909] result() for MulticoreFuture ...
[16:21:52.910] result() for MulticoreFuture ...
[16:21:52.910] result() for MulticoreFuture ... done
[16:21:52.910] result() for MulticoreFuture ... done
[16:21:52.910] result() for MulticoreFuture ...
[16:21:52.911] result() for MulticoreFuture ... done
[16:21:52.914] MulticoreFuture started
[16:21:52.919] - Launch lazy future ... done
[16:21:52.920] plan(): Setting new future strategy stack:
[16:21:52.920] run() for ‘MulticoreFuture’ ... done
[16:21:52.920] List of future strategies:
[16:21:52.920] 1. sequential:
[16:21:52.920]    - args: function (..., envir = parent.frame())
[16:21:52.920]    - tweaked: FALSE
[16:21:52.920]    - call: NULL
[16:21:52.922] plan(): nbrOfWorkers() = 1
[16:21:52.922] resolve() on environment ...
[16:21:52.923]  recursive: 0
[16:21:52.925] plan(): Setting new future strategy stack:
[16:21:52.925]  elements: [3] ‘a’, ‘b’, ‘c’
[16:21:52.925] List of future strategies:
[16:21:52.925] 1. multicore:
[16:21:52.925]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.925]    - tweaked: FALSE
[16:21:52.925]    - call: plan(strategy)
[16:21:52.926] Future #1
[16:21:52.926]  length: 2 (resolved future 1)
[16:21:52.931] plan(): nbrOfWorkers() = 2
[16:21:52.931] Future #2
[16:21:52.931]  length: 1 (resolved future 2)
[16:21:52.932]  length: 0 (resolved future 3)
[16:21:52.932] resolve() on environment ... DONE
[16:21:52.933] getGlobalsAndPackages() ...
[16:21:52.934] Searching for globals...
[16:21:52.935] - globals found: [1] ‘{’
[16:21:52.935] Searching for globals ... DONE
[16:21:52.935] Resolving globals: FALSE
[16:21:52.936] 
[16:21:52.936] 
[16:21:52.937] getGlobalsAndPackages() ... DONE
[16:21:52.937] run() for ‘Future’ ...
[16:21:52.937] - state: ‘created’
[16:21:52.937] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.942]   - Field: ‘label’
[16:21:52.943]   - Field: ‘local’
[16:21:52.943]   - Field: ‘owner’
[16:21:52.943]   - Field: ‘envir’
[16:21:52.943]   - Field: ‘workers’
[16:21:52.943]   - Field: ‘packages’
[16:21:52.943]   - Field: ‘gc’
[16:21:52.943]   - Field: ‘job’
[16:21:52.944]   - Field: ‘conditions’
[16:21:52.944]   - Field: ‘expr’
[16:21:52.944]   - Field: ‘uuid’
[16:21:52.944]   - Field: ‘seed’
[16:21:52.944]   - Field: ‘version’
[16:21:52.944]   - Field: ‘result’
[16:21:52.944]   - Field: ‘asynchronous’
[16:21:52.945]   - Field: ‘calls’
[16:21:52.945]   - Field: ‘globals’
[16:21:52.945]   - Field: ‘stdout’
[16:21:52.945]   - Field: ‘earlySignal’
[16:21:52.945]   - Field: ‘lazy’
[16:21:52.945]   - Field: ‘state’
[16:21:52.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.946] - Launch lazy future ...
[16:21:52.946] Packages needed by the future expression (n = 0): <none>
[16:21:52.946] Packages needed by future strategies (n = 0): <none>
[16:21:52.947] {
[16:21:52.947]     {
[16:21:52.947]         {
[16:21:52.947]             ...future.startTime <- base::Sys.time()
[16:21:52.947]             {
[16:21:52.947]                 {
[16:21:52.947]                   {
[16:21:52.947]                     {
[16:21:52.947]                       base::local({
[16:21:52.947]                         has_future <- base::requireNamespace("future", 
[16:21:52.947]                           quietly = TRUE)
[16:21:52.947]                         if (has_future) {
[16:21:52.947]                           ns <- base::getNamespace("future")
[16:21:52.947]                           version <- ns[[".package"]][["version"]]
[16:21:52.947]                           if (is.null(version)) 
[16:21:52.947]                             version <- utils::packageVersion("future")
[16:21:52.947]                         }
[16:21:52.947]                         else {
[16:21:52.947]                           version <- NULL
[16:21:52.947]                         }
[16:21:52.947]                         if (!has_future || version < "1.8.0") {
[16:21:52.947]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.947]                             "", base::R.version$version.string), 
[16:21:52.947]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.947]                               "release", "version")], collapse = " "), 
[16:21:52.947]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.947]                             info)
[16:21:52.947]                           info <- base::paste(info, collapse = "; ")
[16:21:52.947]                           if (!has_future) {
[16:21:52.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.947]                               info)
[16:21:52.947]                           }
[16:21:52.947]                           else {
[16:21:52.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.947]                               info, version)
[16:21:52.947]                           }
[16:21:52.947]                           base::stop(msg)
[16:21:52.947]                         }
[16:21:52.947]                       })
[16:21:52.947]                     }
[16:21:52.947]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.947]                     base::options(mc.cores = 1L)
[16:21:52.947]                   }
[16:21:52.947]                   ...future.strategy.old <- future::plan("list")
[16:21:52.947]                   options(future.plan = NULL)
[16:21:52.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.947]                 }
[16:21:52.947]                 ...future.workdir <- getwd()
[16:21:52.947]             }
[16:21:52.947]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.947]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.947]         }
[16:21:52.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.947]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.947]             base::names(...future.oldOptions))
[16:21:52.947]     }
[16:21:52.947]     if (FALSE) {
[16:21:52.947]     }
[16:21:52.947]     else {
[16:21:52.947]         if (TRUE) {
[16:21:52.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.947]                 open = "w")
[16:21:52.947]         }
[16:21:52.947]         else {
[16:21:52.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.947]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.947]         }
[16:21:52.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.947]             base::sink(type = "output", split = FALSE)
[16:21:52.947]             base::close(...future.stdout)
[16:21:52.947]         }, add = TRUE)
[16:21:52.947]     }
[16:21:52.947]     ...future.frame <- base::sys.nframe()
[16:21:52.947]     ...future.conditions <- base::list()
[16:21:52.947]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.947]     if (FALSE) {
[16:21:52.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.947]     }
[16:21:52.947]     ...future.result <- base::tryCatch({
[16:21:52.947]         base::withCallingHandlers({
[16:21:52.947]             ...future.value <- base::withVisible(base::local({
[16:21:52.947]                 withCallingHandlers({
[16:21:52.947]                   {
[16:21:52.947]                     1
[16:21:52.947]                   }
[16:21:52.947]                 }, immediateCondition = function(cond) {
[16:21:52.947]                   save_rds <- function (object, pathname, ...) 
[16:21:52.947]                   {
[16:21:52.947]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.947]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.947]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.947]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.947]                         fi_tmp[["mtime"]])
[16:21:52.947]                     }
[16:21:52.947]                     tryCatch({
[16:21:52.947]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.947]                     }, error = function(ex) {
[16:21:52.947]                       msg <- conditionMessage(ex)
[16:21:52.947]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.947]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.947]                         fi_tmp[["mtime"]], msg)
[16:21:52.947]                       ex$message <- msg
[16:21:52.947]                       stop(ex)
[16:21:52.947]                     })
[16:21:52.947]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.947]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.947]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.947]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.947]                       fi <- file.info(pathname)
[16:21:52.947]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.947]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.947]                         fi[["size"]], fi[["mtime"]])
[16:21:52.947]                       stop(msg)
[16:21:52.947]                     }
[16:21:52.947]                     invisible(pathname)
[16:21:52.947]                   }
[16:21:52.947]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.947]                     rootPath = tempdir()) 
[16:21:52.947]                   {
[16:21:52.947]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.947]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.947]                       tmpdir = path, fileext = ".rds")
[16:21:52.947]                     save_rds(obj, file)
[16:21:52.947]                   }
[16:21:52.947]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.947]                   {
[16:21:52.947]                     inherits <- base::inherits
[16:21:52.947]                     invokeRestart <- base::invokeRestart
[16:21:52.947]                     is.null <- base::is.null
[16:21:52.947]                     muffled <- FALSE
[16:21:52.947]                     if (inherits(cond, "message")) {
[16:21:52.947]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.947]                       if (muffled) 
[16:21:52.947]                         invokeRestart("muffleMessage")
[16:21:52.947]                     }
[16:21:52.947]                     else if (inherits(cond, "warning")) {
[16:21:52.947]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.947]                       if (muffled) 
[16:21:52.947]                         invokeRestart("muffleWarning")
[16:21:52.947]                     }
[16:21:52.947]                     else if (inherits(cond, "condition")) {
[16:21:52.947]                       if (!is.null(pattern)) {
[16:21:52.947]                         computeRestarts <- base::computeRestarts
[16:21:52.947]                         grepl <- base::grepl
[16:21:52.947]                         restarts <- computeRestarts(cond)
[16:21:52.947]                         for (restart in restarts) {
[16:21:52.947]                           name <- restart$name
[16:21:52.947]                           if (is.null(name)) 
[16:21:52.947]                             next
[16:21:52.947]                           if (!grepl(pattern, name)) 
[16:21:52.947]                             next
[16:21:52.947]                           invokeRestart(restart)
[16:21:52.947]                           muffled <- TRUE
[16:21:52.947]                           break
[16:21:52.947]                         }
[16:21:52.947]                       }
[16:21:52.947]                     }
[16:21:52.947]                     invisible(muffled)
[16:21:52.947]                   }
[16:21:52.947]                   muffleCondition(cond)
[16:21:52.947]                 })
[16:21:52.947]             }))
[16:21:52.947]             future::FutureResult(value = ...future.value$value, 
[16:21:52.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.947]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.947]                     ...future.globalenv.names))
[16:21:52.947]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.947]         }, condition = base::local({
[16:21:52.947]             c <- base::c
[16:21:52.947]             inherits <- base::inherits
[16:21:52.947]             invokeRestart <- base::invokeRestart
[16:21:52.947]             length <- base::length
[16:21:52.947]             list <- base::list
[16:21:52.947]             seq.int <- base::seq.int
[16:21:52.947]             signalCondition <- base::signalCondition
[16:21:52.947]             sys.calls <- base::sys.calls
[16:21:52.947]             `[[` <- base::`[[`
[16:21:52.947]             `+` <- base::`+`
[16:21:52.947]             `<<-` <- base::`<<-`
[16:21:52.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.947]                   3L)]
[16:21:52.947]             }
[16:21:52.947]             function(cond) {
[16:21:52.947]                 is_error <- inherits(cond, "error")
[16:21:52.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.947]                   NULL)
[16:21:52.947]                 if (is_error) {
[16:21:52.947]                   sessionInformation <- function() {
[16:21:52.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.947]                       search = base::search(), system = base::Sys.info())
[16:21:52.947]                   }
[16:21:52.947]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.947]                     cond$call), session = sessionInformation(), 
[16:21:52.947]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.947]                   signalCondition(cond)
[16:21:52.947]                 }
[16:21:52.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.947]                 "immediateCondition"))) {
[16:21:52.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.947]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.947]                   if (TRUE && !signal) {
[16:21:52.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.947]                     {
[16:21:52.947]                       inherits <- base::inherits
[16:21:52.947]                       invokeRestart <- base::invokeRestart
[16:21:52.947]                       is.null <- base::is.null
[16:21:52.947]                       muffled <- FALSE
[16:21:52.947]                       if (inherits(cond, "message")) {
[16:21:52.947]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.947]                         if (muffled) 
[16:21:52.947]                           invokeRestart("muffleMessage")
[16:21:52.947]                       }
[16:21:52.947]                       else if (inherits(cond, "warning")) {
[16:21:52.947]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.947]                         if (muffled) 
[16:21:52.947]                           invokeRestart("muffleWarning")
[16:21:52.947]                       }
[16:21:52.947]                       else if (inherits(cond, "condition")) {
[16:21:52.947]                         if (!is.null(pattern)) {
[16:21:52.947]                           computeRestarts <- base::computeRestarts
[16:21:52.947]                           grepl <- base::grepl
[16:21:52.947]                           restarts <- computeRestarts(cond)
[16:21:52.947]                           for (restart in restarts) {
[16:21:52.947]                             name <- restart$name
[16:21:52.947]                             if (is.null(name)) 
[16:21:52.947]                               next
[16:21:52.947]                             if (!grepl(pattern, name)) 
[16:21:52.947]                               next
[16:21:52.947]                             invokeRestart(restart)
[16:21:52.947]                             muffled <- TRUE
[16:21:52.947]                             break
[16:21:52.947]                           }
[16:21:52.947]                         }
[16:21:52.947]                       }
[16:21:52.947]                       invisible(muffled)
[16:21:52.947]                     }
[16:21:52.947]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.947]                   }
[16:21:52.947]                 }
[16:21:52.947]                 else {
[16:21:52.947]                   if (TRUE) {
[16:21:52.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.947]                     {
[16:21:52.947]                       inherits <- base::inherits
[16:21:52.947]                       invokeRestart <- base::invokeRestart
[16:21:52.947]                       is.null <- base::is.null
[16:21:52.947]                       muffled <- FALSE
[16:21:52.947]                       if (inherits(cond, "message")) {
[16:21:52.947]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.947]                         if (muffled) 
[16:21:52.947]                           invokeRestart("muffleMessage")
[16:21:52.947]                       }
[16:21:52.947]                       else if (inherits(cond, "warning")) {
[16:21:52.947]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.947]                         if (muffled) 
[16:21:52.947]                           invokeRestart("muffleWarning")
[16:21:52.947]                       }
[16:21:52.947]                       else if (inherits(cond, "condition")) {
[16:21:52.947]                         if (!is.null(pattern)) {
[16:21:52.947]                           computeRestarts <- base::computeRestarts
[16:21:52.947]                           grepl <- base::grepl
[16:21:52.947]                           restarts <- computeRestarts(cond)
[16:21:52.947]                           for (restart in restarts) {
[16:21:52.947]                             name <- restart$name
[16:21:52.947]                             if (is.null(name)) 
[16:21:52.947]                               next
[16:21:52.947]                             if (!grepl(pattern, name)) 
[16:21:52.947]                               next
[16:21:52.947]                             invokeRestart(restart)
[16:21:52.947]                             muffled <- TRUE
[16:21:52.947]                             break
[16:21:52.947]                           }
[16:21:52.947]                         }
[16:21:52.947]                       }
[16:21:52.947]                       invisible(muffled)
[16:21:52.947]                     }
[16:21:52.947]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.947]                   }
[16:21:52.947]                 }
[16:21:52.947]             }
[16:21:52.947]         }))
[16:21:52.947]     }, error = function(ex) {
[16:21:52.947]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.947]                 ...future.rng), started = ...future.startTime, 
[16:21:52.947]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.947]             version = "1.8"), class = "FutureResult")
[16:21:52.947]     }, finally = {
[16:21:52.947]         if (!identical(...future.workdir, getwd())) 
[16:21:52.947]             setwd(...future.workdir)
[16:21:52.947]         {
[16:21:52.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.947]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.947]             }
[16:21:52.947]             base::options(...future.oldOptions)
[16:21:52.947]             if (.Platform$OS.type == "windows") {
[16:21:52.947]                 old_names <- names(...future.oldEnvVars)
[16:21:52.947]                 envs <- base::Sys.getenv()
[16:21:52.947]                 names <- names(envs)
[16:21:52.947]                 common <- intersect(names, old_names)
[16:21:52.947]                 added <- setdiff(names, old_names)
[16:21:52.947]                 removed <- setdiff(old_names, names)
[16:21:52.947]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.947]                   envs[common]]
[16:21:52.947]                 NAMES <- toupper(changed)
[16:21:52.947]                 args <- list()
[16:21:52.947]                 for (kk in seq_along(NAMES)) {
[16:21:52.947]                   name <- changed[[kk]]
[16:21:52.947]                   NAME <- NAMES[[kk]]
[16:21:52.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.947]                     next
[16:21:52.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.947]                 }
[16:21:52.947]                 NAMES <- toupper(added)
[16:21:52.947]                 for (kk in seq_along(NAMES)) {
[16:21:52.947]                   name <- added[[kk]]
[16:21:52.947]                   NAME <- NAMES[[kk]]
[16:21:52.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.947]                     next
[16:21:52.947]                   args[[name]] <- ""
[16:21:52.947]                 }
[16:21:52.947]                 NAMES <- toupper(removed)
[16:21:52.947]                 for (kk in seq_along(NAMES)) {
[16:21:52.947]                   name <- removed[[kk]]
[16:21:52.947]                   NAME <- NAMES[[kk]]
[16:21:52.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.947]                     next
[16:21:52.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.947]                 }
[16:21:52.947]                 if (length(args) > 0) 
[16:21:52.947]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.947]             }
[16:21:52.947]             else {
[16:21:52.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.947]             }
[16:21:52.947]             {
[16:21:52.947]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.947]                   0L) {
[16:21:52.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.947]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.947]                   base::options(opts)
[16:21:52.947]                 }
[16:21:52.947]                 {
[16:21:52.947]                   {
[16:21:52.947]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.947]                     NULL
[16:21:52.947]                   }
[16:21:52.947]                   options(future.plan = NULL)
[16:21:52.947]                   if (is.na(NA_character_)) 
[16:21:52.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.947]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.947]                     .init = FALSE)
[16:21:52.947]                 }
[16:21:52.947]             }
[16:21:52.947]         }
[16:21:52.947]     })
[16:21:52.947]     if (TRUE) {
[16:21:52.947]         base::sink(type = "output", split = FALSE)
[16:21:52.947]         if (TRUE) {
[16:21:52.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.947]         }
[16:21:52.947]         else {
[16:21:52.947]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.947]         }
[16:21:52.947]         base::close(...future.stdout)
[16:21:52.947]         ...future.stdout <- NULL
[16:21:52.947]     }
[16:21:52.947]     ...future.result$conditions <- ...future.conditions
[16:21:52.947]     ...future.result$finished <- base::Sys.time()
[16:21:52.947]     ...future.result
[16:21:52.947] }
[16:21:52.950] requestCore(): workers = 2
[16:21:52.950] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.961] result() for MulticoreFuture ...
[16:21:52.961] result() for MulticoreFuture ...
[16:21:52.962] result() for MulticoreFuture ... done
[16:21:52.962] result() for MulticoreFuture ... done
[16:21:52.962] result() for MulticoreFuture ...
[16:21:52.962] result() for MulticoreFuture ... done
[16:21:52.965] MulticoreFuture started
[16:21:52.965] - Launch lazy future ... done
[16:21:52.965] run() for ‘MulticoreFuture’ ... done
[16:21:52.966] plan(): Setting new future strategy stack:
[16:21:52.967] getGlobalsAndPackages() ...
[16:21:52.967] Searching for globals...
[16:21:52.966] List of future strategies:
[16:21:52.966] 1. sequential:
[16:21:52.966]    - args: function (..., envir = parent.frame())
[16:21:52.966]    - tweaked: FALSE
[16:21:52.966]    - call: NULL
[16:21:52.968] plan(): nbrOfWorkers() = 1
[16:21:52.969] - globals found: [1] ‘{’
[16:21:52.969] Searching for globals ... DONE
[16:21:52.970] Resolving globals: FALSE
[16:21:52.970] 
[16:21:52.971] 
[16:21:52.971] plan(): Setting new future strategy stack:
[16:21:52.971] getGlobalsAndPackages() ... DONE
[16:21:52.971] List of future strategies:
[16:21:52.971] 1. multicore:
[16:21:52.971]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:52.971]    - tweaked: FALSE
[16:21:52.971]    - call: plan(strategy)
[16:21:52.971] run() for ‘Future’ ...
[16:21:52.972] - state: ‘created’
[16:21:52.972] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:52.977] plan(): nbrOfWorkers() = 2
[16:21:52.978] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:52.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:52.978]   - Field: ‘label’
[16:21:52.978]   - Field: ‘local’
[16:21:52.979]   - Field: ‘owner’
[16:21:52.979]   - Field: ‘envir’
[16:21:52.979]   - Field: ‘workers’
[16:21:52.979]   - Field: ‘packages’
[16:21:52.979]   - Field: ‘gc’
[16:21:52.979]   - Field: ‘job’
[16:21:52.979]   - Field: ‘conditions’
[16:21:52.980]   - Field: ‘expr’
[16:21:52.980]   - Field: ‘uuid’
[16:21:52.980]   - Field: ‘seed’
[16:21:52.980]   - Field: ‘version’
[16:21:52.980]   - Field: ‘result’
[16:21:52.980]   - Field: ‘asynchronous’
[16:21:52.980]   - Field: ‘calls’
[16:21:52.981]   - Field: ‘globals’
[16:21:52.981]   - Field: ‘stdout’
[16:21:52.981]   - Field: ‘earlySignal’
[16:21:52.981]   - Field: ‘lazy’
[16:21:52.981]   - Field: ‘state’
[16:21:52.981] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:52.981] - Launch lazy future ...
[16:21:52.982] Packages needed by the future expression (n = 0): <none>
[16:21:52.982] Packages needed by future strategies (n = 0): <none>
[16:21:52.983] {
[16:21:52.983]     {
[16:21:52.983]         {
[16:21:52.983]             ...future.startTime <- base::Sys.time()
[16:21:52.983]             {
[16:21:52.983]                 {
[16:21:52.983]                   {
[16:21:52.983]                     {
[16:21:52.983]                       base::local({
[16:21:52.983]                         has_future <- base::requireNamespace("future", 
[16:21:52.983]                           quietly = TRUE)
[16:21:52.983]                         if (has_future) {
[16:21:52.983]                           ns <- base::getNamespace("future")
[16:21:52.983]                           version <- ns[[".package"]][["version"]]
[16:21:52.983]                           if (is.null(version)) 
[16:21:52.983]                             version <- utils::packageVersion("future")
[16:21:52.983]                         }
[16:21:52.983]                         else {
[16:21:52.983]                           version <- NULL
[16:21:52.983]                         }
[16:21:52.983]                         if (!has_future || version < "1.8.0") {
[16:21:52.983]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:52.983]                             "", base::R.version$version.string), 
[16:21:52.983]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:52.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:52.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:52.983]                               "release", "version")], collapse = " "), 
[16:21:52.983]                             hostname = base::Sys.info()[["nodename"]])
[16:21:52.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:52.983]                             info)
[16:21:52.983]                           info <- base::paste(info, collapse = "; ")
[16:21:52.983]                           if (!has_future) {
[16:21:52.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:52.983]                               info)
[16:21:52.983]                           }
[16:21:52.983]                           else {
[16:21:52.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:52.983]                               info, version)
[16:21:52.983]                           }
[16:21:52.983]                           base::stop(msg)
[16:21:52.983]                         }
[16:21:52.983]                       })
[16:21:52.983]                     }
[16:21:52.983]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:52.983]                     base::options(mc.cores = 1L)
[16:21:52.983]                   }
[16:21:52.983]                   ...future.strategy.old <- future::plan("list")
[16:21:52.983]                   options(future.plan = NULL)
[16:21:52.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:52.983]                 }
[16:21:52.983]                 ...future.workdir <- getwd()
[16:21:52.983]             }
[16:21:52.983]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:52.983]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:52.983]         }
[16:21:52.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:52.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:52.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:52.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:52.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:52.983]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:52.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:52.983]             base::names(...future.oldOptions))
[16:21:52.983]     }
[16:21:52.983]     if (FALSE) {
[16:21:52.983]     }
[16:21:52.983]     else {
[16:21:52.983]         if (TRUE) {
[16:21:52.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:52.983]                 open = "w")
[16:21:52.983]         }
[16:21:52.983]         else {
[16:21:52.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:52.983]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:52.983]         }
[16:21:52.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:52.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:52.983]             base::sink(type = "output", split = FALSE)
[16:21:52.983]             base::close(...future.stdout)
[16:21:52.983]         }, add = TRUE)
[16:21:52.983]     }
[16:21:52.983]     ...future.frame <- base::sys.nframe()
[16:21:52.983]     ...future.conditions <- base::list()
[16:21:52.983]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:52.983]     if (FALSE) {
[16:21:52.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:52.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:52.983]     }
[16:21:52.983]     ...future.result <- base::tryCatch({
[16:21:52.983]         base::withCallingHandlers({
[16:21:52.983]             ...future.value <- base::withVisible(base::local({
[16:21:52.983]                 withCallingHandlers({
[16:21:52.983]                   {
[16:21:52.983]                     2
[16:21:52.983]                   }
[16:21:52.983]                 }, immediateCondition = function(cond) {
[16:21:52.983]                   save_rds <- function (object, pathname, ...) 
[16:21:52.983]                   {
[16:21:52.983]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:52.983]                     if (file_test("-f", pathname_tmp)) {
[16:21:52.983]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.983]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:52.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.983]                         fi_tmp[["mtime"]])
[16:21:52.983]                     }
[16:21:52.983]                     tryCatch({
[16:21:52.983]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:52.983]                     }, error = function(ex) {
[16:21:52.983]                       msg <- conditionMessage(ex)
[16:21:52.983]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.983]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:52.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.983]                         fi_tmp[["mtime"]], msg)
[16:21:52.983]                       ex$message <- msg
[16:21:52.983]                       stop(ex)
[16:21:52.983]                     })
[16:21:52.983]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:52.983]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:52.983]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:52.983]                       fi_tmp <- file.info(pathname_tmp)
[16:21:52.983]                       fi <- file.info(pathname)
[16:21:52.983]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:52.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:52.983]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:52.983]                         fi[["size"]], fi[["mtime"]])
[16:21:52.983]                       stop(msg)
[16:21:52.983]                     }
[16:21:52.983]                     invisible(pathname)
[16:21:52.983]                   }
[16:21:52.983]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:52.983]                     rootPath = tempdir()) 
[16:21:52.983]                   {
[16:21:52.983]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:52.983]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:52.983]                       tmpdir = path, fileext = ".rds")
[16:21:52.983]                     save_rds(obj, file)
[16:21:52.983]                   }
[16:21:52.983]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:52.983]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.983]                   {
[16:21:52.983]                     inherits <- base::inherits
[16:21:52.983]                     invokeRestart <- base::invokeRestart
[16:21:52.983]                     is.null <- base::is.null
[16:21:52.983]                     muffled <- FALSE
[16:21:52.983]                     if (inherits(cond, "message")) {
[16:21:52.983]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:52.983]                       if (muffled) 
[16:21:52.983]                         invokeRestart("muffleMessage")
[16:21:52.983]                     }
[16:21:52.983]                     else if (inherits(cond, "warning")) {
[16:21:52.983]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:52.983]                       if (muffled) 
[16:21:52.983]                         invokeRestart("muffleWarning")
[16:21:52.983]                     }
[16:21:52.983]                     else if (inherits(cond, "condition")) {
[16:21:52.983]                       if (!is.null(pattern)) {
[16:21:52.983]                         computeRestarts <- base::computeRestarts
[16:21:52.983]                         grepl <- base::grepl
[16:21:52.983]                         restarts <- computeRestarts(cond)
[16:21:52.983]                         for (restart in restarts) {
[16:21:52.983]                           name <- restart$name
[16:21:52.983]                           if (is.null(name)) 
[16:21:52.983]                             next
[16:21:52.983]                           if (!grepl(pattern, name)) 
[16:21:52.983]                             next
[16:21:52.983]                           invokeRestart(restart)
[16:21:52.983]                           muffled <- TRUE
[16:21:52.983]                           break
[16:21:52.983]                         }
[16:21:52.983]                       }
[16:21:52.983]                     }
[16:21:52.983]                     invisible(muffled)
[16:21:52.983]                   }
[16:21:52.983]                   muffleCondition(cond)
[16:21:52.983]                 })
[16:21:52.983]             }))
[16:21:52.983]             future::FutureResult(value = ...future.value$value, 
[16:21:52.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.983]                   ...future.rng), globalenv = if (FALSE) 
[16:21:52.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:52.983]                     ...future.globalenv.names))
[16:21:52.983]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:52.983]         }, condition = base::local({
[16:21:52.983]             c <- base::c
[16:21:52.983]             inherits <- base::inherits
[16:21:52.983]             invokeRestart <- base::invokeRestart
[16:21:52.983]             length <- base::length
[16:21:52.983]             list <- base::list
[16:21:52.983]             seq.int <- base::seq.int
[16:21:52.983]             signalCondition <- base::signalCondition
[16:21:52.983]             sys.calls <- base::sys.calls
[16:21:52.983]             `[[` <- base::`[[`
[16:21:52.983]             `+` <- base::`+`
[16:21:52.983]             `<<-` <- base::`<<-`
[16:21:52.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:52.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:52.983]                   3L)]
[16:21:52.983]             }
[16:21:52.983]             function(cond) {
[16:21:52.983]                 is_error <- inherits(cond, "error")
[16:21:52.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:52.983]                   NULL)
[16:21:52.983]                 if (is_error) {
[16:21:52.983]                   sessionInformation <- function() {
[16:21:52.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:52.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:52.983]                       search = base::search(), system = base::Sys.info())
[16:21:52.983]                   }
[16:21:52.983]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:52.983]                     cond$call), session = sessionInformation(), 
[16:21:52.983]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:52.983]                   signalCondition(cond)
[16:21:52.983]                 }
[16:21:52.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:52.983]                 "immediateCondition"))) {
[16:21:52.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:52.983]                   ...future.conditions[[length(...future.conditions) + 
[16:21:52.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:52.983]                   if (TRUE && !signal) {
[16:21:52.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.983]                     {
[16:21:52.983]                       inherits <- base::inherits
[16:21:52.983]                       invokeRestart <- base::invokeRestart
[16:21:52.983]                       is.null <- base::is.null
[16:21:52.983]                       muffled <- FALSE
[16:21:52.983]                       if (inherits(cond, "message")) {
[16:21:52.983]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.983]                         if (muffled) 
[16:21:52.983]                           invokeRestart("muffleMessage")
[16:21:52.983]                       }
[16:21:52.983]                       else if (inherits(cond, "warning")) {
[16:21:52.983]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.983]                         if (muffled) 
[16:21:52.983]                           invokeRestart("muffleWarning")
[16:21:52.983]                       }
[16:21:52.983]                       else if (inherits(cond, "condition")) {
[16:21:52.983]                         if (!is.null(pattern)) {
[16:21:52.983]                           computeRestarts <- base::computeRestarts
[16:21:52.983]                           grepl <- base::grepl
[16:21:52.983]                           restarts <- computeRestarts(cond)
[16:21:52.983]                           for (restart in restarts) {
[16:21:52.983]                             name <- restart$name
[16:21:52.983]                             if (is.null(name)) 
[16:21:52.983]                               next
[16:21:52.983]                             if (!grepl(pattern, name)) 
[16:21:52.983]                               next
[16:21:52.983]                             invokeRestart(restart)
[16:21:52.983]                             muffled <- TRUE
[16:21:52.983]                             break
[16:21:52.983]                           }
[16:21:52.983]                         }
[16:21:52.983]                       }
[16:21:52.983]                       invisible(muffled)
[16:21:52.983]                     }
[16:21:52.983]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.983]                   }
[16:21:52.983]                 }
[16:21:52.983]                 else {
[16:21:52.983]                   if (TRUE) {
[16:21:52.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:52.983]                     {
[16:21:52.983]                       inherits <- base::inherits
[16:21:52.983]                       invokeRestart <- base::invokeRestart
[16:21:52.983]                       is.null <- base::is.null
[16:21:52.983]                       muffled <- FALSE
[16:21:52.983]                       if (inherits(cond, "message")) {
[16:21:52.983]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:52.983]                         if (muffled) 
[16:21:52.983]                           invokeRestart("muffleMessage")
[16:21:52.983]                       }
[16:21:52.983]                       else if (inherits(cond, "warning")) {
[16:21:52.983]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:52.983]                         if (muffled) 
[16:21:52.983]                           invokeRestart("muffleWarning")
[16:21:52.983]                       }
[16:21:52.983]                       else if (inherits(cond, "condition")) {
[16:21:52.983]                         if (!is.null(pattern)) {
[16:21:52.983]                           computeRestarts <- base::computeRestarts
[16:21:52.983]                           grepl <- base::grepl
[16:21:52.983]                           restarts <- computeRestarts(cond)
[16:21:52.983]                           for (restart in restarts) {
[16:21:52.983]                             name <- restart$name
[16:21:52.983]                             if (is.null(name)) 
[16:21:52.983]                               next
[16:21:52.983]                             if (!grepl(pattern, name)) 
[16:21:52.983]                               next
[16:21:52.983]                             invokeRestart(restart)
[16:21:52.983]                             muffled <- TRUE
[16:21:52.983]                             break
[16:21:52.983]                           }
[16:21:52.983]                         }
[16:21:52.983]                       }
[16:21:52.983]                       invisible(muffled)
[16:21:52.983]                     }
[16:21:52.983]                     muffleCondition(cond, pattern = "^muffle")
[16:21:52.983]                   }
[16:21:52.983]                 }
[16:21:52.983]             }
[16:21:52.983]         }))
[16:21:52.983]     }, error = function(ex) {
[16:21:52.983]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:52.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:52.983]                 ...future.rng), started = ...future.startTime, 
[16:21:52.983]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:52.983]             version = "1.8"), class = "FutureResult")
[16:21:52.983]     }, finally = {
[16:21:52.983]         if (!identical(...future.workdir, getwd())) 
[16:21:52.983]             setwd(...future.workdir)
[16:21:52.983]         {
[16:21:52.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:52.983]                 ...future.oldOptions$nwarnings <- NULL
[16:21:52.983]             }
[16:21:52.983]             base::options(...future.oldOptions)
[16:21:52.983]             if (.Platform$OS.type == "windows") {
[16:21:52.983]                 old_names <- names(...future.oldEnvVars)
[16:21:52.983]                 envs <- base::Sys.getenv()
[16:21:52.983]                 names <- names(envs)
[16:21:52.983]                 common <- intersect(names, old_names)
[16:21:52.983]                 added <- setdiff(names, old_names)
[16:21:52.983]                 removed <- setdiff(old_names, names)
[16:21:52.983]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:52.983]                   envs[common]]
[16:21:52.983]                 NAMES <- toupper(changed)
[16:21:52.983]                 args <- list()
[16:21:52.983]                 for (kk in seq_along(NAMES)) {
[16:21:52.983]                   name <- changed[[kk]]
[16:21:52.983]                   NAME <- NAMES[[kk]]
[16:21:52.983]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.983]                     next
[16:21:52.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.983]                 }
[16:21:52.983]                 NAMES <- toupper(added)
[16:21:52.983]                 for (kk in seq_along(NAMES)) {
[16:21:52.983]                   name <- added[[kk]]
[16:21:52.983]                   NAME <- NAMES[[kk]]
[16:21:52.983]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.983]                     next
[16:21:52.983]                   args[[name]] <- ""
[16:21:52.983]                 }
[16:21:52.983]                 NAMES <- toupper(removed)
[16:21:52.983]                 for (kk in seq_along(NAMES)) {
[16:21:52.983]                   name <- removed[[kk]]
[16:21:52.983]                   NAME <- NAMES[[kk]]
[16:21:52.983]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:52.983]                     next
[16:21:52.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:52.983]                 }
[16:21:52.983]                 if (length(args) > 0) 
[16:21:52.983]                   base::do.call(base::Sys.setenv, args = args)
[16:21:52.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:52.983]             }
[16:21:52.983]             else {
[16:21:52.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:52.983]             }
[16:21:52.983]             {
[16:21:52.983]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:52.983]                   0L) {
[16:21:52.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:52.983]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:52.983]                   base::options(opts)
[16:21:52.983]                 }
[16:21:52.983]                 {
[16:21:52.983]                   {
[16:21:52.983]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:52.983]                     NULL
[16:21:52.983]                   }
[16:21:52.983]                   options(future.plan = NULL)
[16:21:52.983]                   if (is.na(NA_character_)) 
[16:21:52.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:52.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:52.983]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:52.983]                     .init = FALSE)
[16:21:52.983]                 }
[16:21:52.983]             }
[16:21:52.983]         }
[16:21:52.983]     })
[16:21:52.983]     if (TRUE) {
[16:21:52.983]         base::sink(type = "output", split = FALSE)
[16:21:52.983]         if (TRUE) {
[16:21:52.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:52.983]         }
[16:21:52.983]         else {
[16:21:52.983]             ...future.result["stdout"] <- base::list(NULL)
[16:21:52.983]         }
[16:21:52.983]         base::close(...future.stdout)
[16:21:52.983]         ...future.stdout <- NULL
[16:21:52.983]     }
[16:21:52.983]     ...future.result$conditions <- ...future.conditions
[16:21:52.983]     ...future.result$finished <- base::Sys.time()
[16:21:52.983]     ...future.result
[16:21:52.983] }
[16:21:52.986] requestCore(): workers = 2
[16:21:52.987] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:52.997] result() for MulticoreFuture ...
[16:21:52.998] result() for MulticoreFuture ...
[16:21:52.998] result() for MulticoreFuture ... done
[16:21:52.999] result() for MulticoreFuture ... done
[16:21:52.999] result() for MulticoreFuture ...
[16:21:52.999] result() for MulticoreFuture ... done
[16:21:53.001] MulticoreFuture started
[16:21:53.002] - Launch lazy future ... done
[16:21:53.002] run() for ‘MulticoreFuture’ ... done
[16:21:53.003] plan(): Setting new future strategy stack:
[16:21:53.003] List of future strategies:
[16:21:53.003] 1. sequential:
[16:21:53.003]    - args: function (..., envir = parent.frame())
[16:21:53.003]    - tweaked: FALSE
[16:21:53.003]    - call: NULL
[16:21:53.004] resolve() on environment ...
[16:21:53.004] plan(): nbrOfWorkers() = 1
[16:21:53.004]  recursive: 0
[16:21:53.005]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:21:53.006] Future #1
[16:21:53.006]  length: 2 (resolved future 1)
[16:21:53.007] plan(): Setting new future strategy stack:
[16:21:53.007] List of future strategies:
[16:21:53.007] 1. multicore:
[16:21:53.007]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.007]    - tweaked: FALSE
[16:21:53.007]    - call: plan(strategy)
[16:21:53.012] plan(): nbrOfWorkers() = 2
[16:21:53.012] Future #2
[16:21:53.013]  length: 1 (resolved future 2)
[16:21:53.013]  length: 0 (resolved future 3)
[16:21:53.013] resolve() on environment ... DONE
[16:21:53.014] getGlobalsAndPackages() ...
[16:21:53.014] Searching for globals...
[16:21:53.020] - globals found: [1] ‘{’
[16:21:53.021] Searching for globals ... DONE
[16:21:53.021] Resolving globals: FALSE
[16:21:53.022] 
[16:21:53.022] 
[16:21:53.023] getGlobalsAndPackages() ... DONE
[16:21:53.023] run() for ‘Future’ ...
[16:21:53.024] - state: ‘created’
[16:21:53.024] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.028] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.029]   - Field: ‘label’
[16:21:53.029]   - Field: ‘local’
[16:21:53.029]   - Field: ‘owner’
[16:21:53.029]   - Field: ‘envir’
[16:21:53.030]   - Field: ‘workers’
[16:21:53.030]   - Field: ‘packages’
[16:21:53.030]   - Field: ‘gc’
[16:21:53.030]   - Field: ‘job’
[16:21:53.030]   - Field: ‘conditions’
[16:21:53.030]   - Field: ‘expr’
[16:21:53.031]   - Field: ‘uuid’
[16:21:53.031]   - Field: ‘seed’
[16:21:53.031]   - Field: ‘version’
[16:21:53.031]   - Field: ‘result’
[16:21:53.031]   - Field: ‘asynchronous’
[16:21:53.032]   - Field: ‘calls’
[16:21:53.032]   - Field: ‘globals’
[16:21:53.032]   - Field: ‘stdout’
[16:21:53.032]   - Field: ‘earlySignal’
[16:21:53.032]   - Field: ‘lazy’
[16:21:53.032]   - Field: ‘state’
[16:21:53.033] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.033] - Launch lazy future ...
[16:21:53.033] Packages needed by the future expression (n = 0): <none>
[16:21:53.033] Packages needed by future strategies (n = 0): <none>
[16:21:53.034] {
[16:21:53.034]     {
[16:21:53.034]         {
[16:21:53.034]             ...future.startTime <- base::Sys.time()
[16:21:53.034]             {
[16:21:53.034]                 {
[16:21:53.034]                   {
[16:21:53.034]                     {
[16:21:53.034]                       base::local({
[16:21:53.034]                         has_future <- base::requireNamespace("future", 
[16:21:53.034]                           quietly = TRUE)
[16:21:53.034]                         if (has_future) {
[16:21:53.034]                           ns <- base::getNamespace("future")
[16:21:53.034]                           version <- ns[[".package"]][["version"]]
[16:21:53.034]                           if (is.null(version)) 
[16:21:53.034]                             version <- utils::packageVersion("future")
[16:21:53.034]                         }
[16:21:53.034]                         else {
[16:21:53.034]                           version <- NULL
[16:21:53.034]                         }
[16:21:53.034]                         if (!has_future || version < "1.8.0") {
[16:21:53.034]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.034]                             "", base::R.version$version.string), 
[16:21:53.034]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.034]                               "release", "version")], collapse = " "), 
[16:21:53.034]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.034]                             info)
[16:21:53.034]                           info <- base::paste(info, collapse = "; ")
[16:21:53.034]                           if (!has_future) {
[16:21:53.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.034]                               info)
[16:21:53.034]                           }
[16:21:53.034]                           else {
[16:21:53.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.034]                               info, version)
[16:21:53.034]                           }
[16:21:53.034]                           base::stop(msg)
[16:21:53.034]                         }
[16:21:53.034]                       })
[16:21:53.034]                     }
[16:21:53.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.034]                     base::options(mc.cores = 1L)
[16:21:53.034]                   }
[16:21:53.034]                   ...future.strategy.old <- future::plan("list")
[16:21:53.034]                   options(future.plan = NULL)
[16:21:53.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.034]                 }
[16:21:53.034]                 ...future.workdir <- getwd()
[16:21:53.034]             }
[16:21:53.034]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.034]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.034]         }
[16:21:53.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.034]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.034]             base::names(...future.oldOptions))
[16:21:53.034]     }
[16:21:53.034]     if (FALSE) {
[16:21:53.034]     }
[16:21:53.034]     else {
[16:21:53.034]         if (TRUE) {
[16:21:53.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.034]                 open = "w")
[16:21:53.034]         }
[16:21:53.034]         else {
[16:21:53.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.034]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.034]         }
[16:21:53.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.034]             base::sink(type = "output", split = FALSE)
[16:21:53.034]             base::close(...future.stdout)
[16:21:53.034]         }, add = TRUE)
[16:21:53.034]     }
[16:21:53.034]     ...future.frame <- base::sys.nframe()
[16:21:53.034]     ...future.conditions <- base::list()
[16:21:53.034]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.034]     if (FALSE) {
[16:21:53.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.034]     }
[16:21:53.034]     ...future.result <- base::tryCatch({
[16:21:53.034]         base::withCallingHandlers({
[16:21:53.034]             ...future.value <- base::withVisible(base::local({
[16:21:53.034]                 withCallingHandlers({
[16:21:53.034]                   {
[16:21:53.034]                     1
[16:21:53.034]                   }
[16:21:53.034]                 }, immediateCondition = function(cond) {
[16:21:53.034]                   save_rds <- function (object, pathname, ...) 
[16:21:53.034]                   {
[16:21:53.034]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.034]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.034]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.034]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.034]                         fi_tmp[["mtime"]])
[16:21:53.034]                     }
[16:21:53.034]                     tryCatch({
[16:21:53.034]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.034]                     }, error = function(ex) {
[16:21:53.034]                       msg <- conditionMessage(ex)
[16:21:53.034]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.034]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.034]                         fi_tmp[["mtime"]], msg)
[16:21:53.034]                       ex$message <- msg
[16:21:53.034]                       stop(ex)
[16:21:53.034]                     })
[16:21:53.034]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.034]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.034]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.034]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.034]                       fi <- file.info(pathname)
[16:21:53.034]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.034]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.034]                         fi[["size"]], fi[["mtime"]])
[16:21:53.034]                       stop(msg)
[16:21:53.034]                     }
[16:21:53.034]                     invisible(pathname)
[16:21:53.034]                   }
[16:21:53.034]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.034]                     rootPath = tempdir()) 
[16:21:53.034]                   {
[16:21:53.034]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.034]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.034]                       tmpdir = path, fileext = ".rds")
[16:21:53.034]                     save_rds(obj, file)
[16:21:53.034]                   }
[16:21:53.034]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.034]                   {
[16:21:53.034]                     inherits <- base::inherits
[16:21:53.034]                     invokeRestart <- base::invokeRestart
[16:21:53.034]                     is.null <- base::is.null
[16:21:53.034]                     muffled <- FALSE
[16:21:53.034]                     if (inherits(cond, "message")) {
[16:21:53.034]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.034]                       if (muffled) 
[16:21:53.034]                         invokeRestart("muffleMessage")
[16:21:53.034]                     }
[16:21:53.034]                     else if (inherits(cond, "warning")) {
[16:21:53.034]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.034]                       if (muffled) 
[16:21:53.034]                         invokeRestart("muffleWarning")
[16:21:53.034]                     }
[16:21:53.034]                     else if (inherits(cond, "condition")) {
[16:21:53.034]                       if (!is.null(pattern)) {
[16:21:53.034]                         computeRestarts <- base::computeRestarts
[16:21:53.034]                         grepl <- base::grepl
[16:21:53.034]                         restarts <- computeRestarts(cond)
[16:21:53.034]                         for (restart in restarts) {
[16:21:53.034]                           name <- restart$name
[16:21:53.034]                           if (is.null(name)) 
[16:21:53.034]                             next
[16:21:53.034]                           if (!grepl(pattern, name)) 
[16:21:53.034]                             next
[16:21:53.034]                           invokeRestart(restart)
[16:21:53.034]                           muffled <- TRUE
[16:21:53.034]                           break
[16:21:53.034]                         }
[16:21:53.034]                       }
[16:21:53.034]                     }
[16:21:53.034]                     invisible(muffled)
[16:21:53.034]                   }
[16:21:53.034]                   muffleCondition(cond)
[16:21:53.034]                 })
[16:21:53.034]             }))
[16:21:53.034]             future::FutureResult(value = ...future.value$value, 
[16:21:53.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.034]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.034]                     ...future.globalenv.names))
[16:21:53.034]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.034]         }, condition = base::local({
[16:21:53.034]             c <- base::c
[16:21:53.034]             inherits <- base::inherits
[16:21:53.034]             invokeRestart <- base::invokeRestart
[16:21:53.034]             length <- base::length
[16:21:53.034]             list <- base::list
[16:21:53.034]             seq.int <- base::seq.int
[16:21:53.034]             signalCondition <- base::signalCondition
[16:21:53.034]             sys.calls <- base::sys.calls
[16:21:53.034]             `[[` <- base::`[[`
[16:21:53.034]             `+` <- base::`+`
[16:21:53.034]             `<<-` <- base::`<<-`
[16:21:53.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.034]                   3L)]
[16:21:53.034]             }
[16:21:53.034]             function(cond) {
[16:21:53.034]                 is_error <- inherits(cond, "error")
[16:21:53.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.034]                   NULL)
[16:21:53.034]                 if (is_error) {
[16:21:53.034]                   sessionInformation <- function() {
[16:21:53.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.034]                       search = base::search(), system = base::Sys.info())
[16:21:53.034]                   }
[16:21:53.034]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.034]                     cond$call), session = sessionInformation(), 
[16:21:53.034]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.034]                   signalCondition(cond)
[16:21:53.034]                 }
[16:21:53.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.034]                 "immediateCondition"))) {
[16:21:53.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.034]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.034]                   if (TRUE && !signal) {
[16:21:53.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.034]                     {
[16:21:53.034]                       inherits <- base::inherits
[16:21:53.034]                       invokeRestart <- base::invokeRestart
[16:21:53.034]                       is.null <- base::is.null
[16:21:53.034]                       muffled <- FALSE
[16:21:53.034]                       if (inherits(cond, "message")) {
[16:21:53.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.034]                         if (muffled) 
[16:21:53.034]                           invokeRestart("muffleMessage")
[16:21:53.034]                       }
[16:21:53.034]                       else if (inherits(cond, "warning")) {
[16:21:53.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.034]                         if (muffled) 
[16:21:53.034]                           invokeRestart("muffleWarning")
[16:21:53.034]                       }
[16:21:53.034]                       else if (inherits(cond, "condition")) {
[16:21:53.034]                         if (!is.null(pattern)) {
[16:21:53.034]                           computeRestarts <- base::computeRestarts
[16:21:53.034]                           grepl <- base::grepl
[16:21:53.034]                           restarts <- computeRestarts(cond)
[16:21:53.034]                           for (restart in restarts) {
[16:21:53.034]                             name <- restart$name
[16:21:53.034]                             if (is.null(name)) 
[16:21:53.034]                               next
[16:21:53.034]                             if (!grepl(pattern, name)) 
[16:21:53.034]                               next
[16:21:53.034]                             invokeRestart(restart)
[16:21:53.034]                             muffled <- TRUE
[16:21:53.034]                             break
[16:21:53.034]                           }
[16:21:53.034]                         }
[16:21:53.034]                       }
[16:21:53.034]                       invisible(muffled)
[16:21:53.034]                     }
[16:21:53.034]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.034]                   }
[16:21:53.034]                 }
[16:21:53.034]                 else {
[16:21:53.034]                   if (TRUE) {
[16:21:53.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.034]                     {
[16:21:53.034]                       inherits <- base::inherits
[16:21:53.034]                       invokeRestart <- base::invokeRestart
[16:21:53.034]                       is.null <- base::is.null
[16:21:53.034]                       muffled <- FALSE
[16:21:53.034]                       if (inherits(cond, "message")) {
[16:21:53.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.034]                         if (muffled) 
[16:21:53.034]                           invokeRestart("muffleMessage")
[16:21:53.034]                       }
[16:21:53.034]                       else if (inherits(cond, "warning")) {
[16:21:53.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.034]                         if (muffled) 
[16:21:53.034]                           invokeRestart("muffleWarning")
[16:21:53.034]                       }
[16:21:53.034]                       else if (inherits(cond, "condition")) {
[16:21:53.034]                         if (!is.null(pattern)) {
[16:21:53.034]                           computeRestarts <- base::computeRestarts
[16:21:53.034]                           grepl <- base::grepl
[16:21:53.034]                           restarts <- computeRestarts(cond)
[16:21:53.034]                           for (restart in restarts) {
[16:21:53.034]                             name <- restart$name
[16:21:53.034]                             if (is.null(name)) 
[16:21:53.034]                               next
[16:21:53.034]                             if (!grepl(pattern, name)) 
[16:21:53.034]                               next
[16:21:53.034]                             invokeRestart(restart)
[16:21:53.034]                             muffled <- TRUE
[16:21:53.034]                             break
[16:21:53.034]                           }
[16:21:53.034]                         }
[16:21:53.034]                       }
[16:21:53.034]                       invisible(muffled)
[16:21:53.034]                     }
[16:21:53.034]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.034]                   }
[16:21:53.034]                 }
[16:21:53.034]             }
[16:21:53.034]         }))
[16:21:53.034]     }, error = function(ex) {
[16:21:53.034]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.034]                 ...future.rng), started = ...future.startTime, 
[16:21:53.034]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.034]             version = "1.8"), class = "FutureResult")
[16:21:53.034]     }, finally = {
[16:21:53.034]         if (!identical(...future.workdir, getwd())) 
[16:21:53.034]             setwd(...future.workdir)
[16:21:53.034]         {
[16:21:53.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.034]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.034]             }
[16:21:53.034]             base::options(...future.oldOptions)
[16:21:53.034]             if (.Platform$OS.type == "windows") {
[16:21:53.034]                 old_names <- names(...future.oldEnvVars)
[16:21:53.034]                 envs <- base::Sys.getenv()
[16:21:53.034]                 names <- names(envs)
[16:21:53.034]                 common <- intersect(names, old_names)
[16:21:53.034]                 added <- setdiff(names, old_names)
[16:21:53.034]                 removed <- setdiff(old_names, names)
[16:21:53.034]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.034]                   envs[common]]
[16:21:53.034]                 NAMES <- toupper(changed)
[16:21:53.034]                 args <- list()
[16:21:53.034]                 for (kk in seq_along(NAMES)) {
[16:21:53.034]                   name <- changed[[kk]]
[16:21:53.034]                   NAME <- NAMES[[kk]]
[16:21:53.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.034]                     next
[16:21:53.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.034]                 }
[16:21:53.034]                 NAMES <- toupper(added)
[16:21:53.034]                 for (kk in seq_along(NAMES)) {
[16:21:53.034]                   name <- added[[kk]]
[16:21:53.034]                   NAME <- NAMES[[kk]]
[16:21:53.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.034]                     next
[16:21:53.034]                   args[[name]] <- ""
[16:21:53.034]                 }
[16:21:53.034]                 NAMES <- toupper(removed)
[16:21:53.034]                 for (kk in seq_along(NAMES)) {
[16:21:53.034]                   name <- removed[[kk]]
[16:21:53.034]                   NAME <- NAMES[[kk]]
[16:21:53.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.034]                     next
[16:21:53.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.034]                 }
[16:21:53.034]                 if (length(args) > 0) 
[16:21:53.034]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.034]             }
[16:21:53.034]             else {
[16:21:53.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.034]             }
[16:21:53.034]             {
[16:21:53.034]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.034]                   0L) {
[16:21:53.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.034]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.034]                   base::options(opts)
[16:21:53.034]                 }
[16:21:53.034]                 {
[16:21:53.034]                   {
[16:21:53.034]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.034]                     NULL
[16:21:53.034]                   }
[16:21:53.034]                   options(future.plan = NULL)
[16:21:53.034]                   if (is.na(NA_character_)) 
[16:21:53.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.034]                     .init = FALSE)
[16:21:53.034]                 }
[16:21:53.034]             }
[16:21:53.034]         }
[16:21:53.034]     })
[16:21:53.034]     if (TRUE) {
[16:21:53.034]         base::sink(type = "output", split = FALSE)
[16:21:53.034]         if (TRUE) {
[16:21:53.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.034]         }
[16:21:53.034]         else {
[16:21:53.034]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.034]         }
[16:21:53.034]         base::close(...future.stdout)
[16:21:53.034]         ...future.stdout <- NULL
[16:21:53.034]     }
[16:21:53.034]     ...future.result$conditions <- ...future.conditions
[16:21:53.034]     ...future.result$finished <- base::Sys.time()
[16:21:53.034]     ...future.result
[16:21:53.034] }
[16:21:53.037] requestCore(): workers = 2
[16:21:53.037] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.048] result() for MulticoreFuture ...
[16:21:53.048] result() for MulticoreFuture ...
[16:21:53.049] result() for MulticoreFuture ... done
[16:21:53.049] result() for MulticoreFuture ... done
[16:21:53.049] result() for MulticoreFuture ...
[16:21:53.049] result() for MulticoreFuture ... done
[16:21:53.051] MulticoreFuture started
[16:21:53.052] - Launch lazy future ... done
[16:21:53.052] run() for ‘MulticoreFuture’ ... done
[16:21:53.053] plan(): Setting new future strategy stack:
[16:21:53.053] getGlobalsAndPackages() ...
[16:21:53.054] Searching for globals...
[16:21:53.053] List of future strategies:
[16:21:53.053] 1. sequential:
[16:21:53.053]    - args: function (..., envir = parent.frame())
[16:21:53.053]    - tweaked: FALSE
[16:21:53.053]    - call: NULL
[16:21:53.054] plan(): nbrOfWorkers() = 1
[16:21:53.056] - globals found: [1] ‘{’
[16:21:53.056] Searching for globals ... DONE
[16:21:53.056] Resolving globals: FALSE
[16:21:53.057] 
[16:21:53.057] plan(): Setting new future strategy stack:
[16:21:53.057] 
[16:21:53.058] getGlobalsAndPackages() ... DONE
[16:21:53.058] List of future strategies:
[16:21:53.058] 1. multicore:
[16:21:53.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.058]    - tweaked: FALSE
[16:21:53.058]    - call: plan(strategy)
[16:21:53.058] run() for ‘Future’ ...
[16:21:53.059] - state: ‘created’
[16:21:53.059] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.064] plan(): nbrOfWorkers() = 2
[16:21:53.064] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.064]   - Field: ‘label’
[16:21:53.065]   - Field: ‘local’
[16:21:53.065]   - Field: ‘owner’
[16:21:53.065]   - Field: ‘envir’
[16:21:53.065]   - Field: ‘workers’
[16:21:53.065]   - Field: ‘packages’
[16:21:53.065]   - Field: ‘gc’
[16:21:53.066]   - Field: ‘job’
[16:21:53.066]   - Field: ‘conditions’
[16:21:53.066]   - Field: ‘expr’
[16:21:53.066]   - Field: ‘uuid’
[16:21:53.066]   - Field: ‘seed’
[16:21:53.066]   - Field: ‘version’
[16:21:53.067]   - Field: ‘result’
[16:21:53.067]   - Field: ‘asynchronous’
[16:21:53.067]   - Field: ‘calls’
[16:21:53.067]   - Field: ‘globals’
[16:21:53.067]   - Field: ‘stdout’
[16:21:53.067]   - Field: ‘earlySignal’
[16:21:53.067]   - Field: ‘lazy’
[16:21:53.068]   - Field: ‘state’
[16:21:53.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.068] - Launch lazy future ...
[16:21:53.068] Packages needed by the future expression (n = 0): <none>
[16:21:53.068] Packages needed by future strategies (n = 0): <none>
[16:21:53.069] {
[16:21:53.069]     {
[16:21:53.069]         {
[16:21:53.069]             ...future.startTime <- base::Sys.time()
[16:21:53.069]             {
[16:21:53.069]                 {
[16:21:53.069]                   {
[16:21:53.069]                     {
[16:21:53.069]                       base::local({
[16:21:53.069]                         has_future <- base::requireNamespace("future", 
[16:21:53.069]                           quietly = TRUE)
[16:21:53.069]                         if (has_future) {
[16:21:53.069]                           ns <- base::getNamespace("future")
[16:21:53.069]                           version <- ns[[".package"]][["version"]]
[16:21:53.069]                           if (is.null(version)) 
[16:21:53.069]                             version <- utils::packageVersion("future")
[16:21:53.069]                         }
[16:21:53.069]                         else {
[16:21:53.069]                           version <- NULL
[16:21:53.069]                         }
[16:21:53.069]                         if (!has_future || version < "1.8.0") {
[16:21:53.069]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.069]                             "", base::R.version$version.string), 
[16:21:53.069]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.069]                               "release", "version")], collapse = " "), 
[16:21:53.069]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.069]                             info)
[16:21:53.069]                           info <- base::paste(info, collapse = "; ")
[16:21:53.069]                           if (!has_future) {
[16:21:53.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.069]                               info)
[16:21:53.069]                           }
[16:21:53.069]                           else {
[16:21:53.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.069]                               info, version)
[16:21:53.069]                           }
[16:21:53.069]                           base::stop(msg)
[16:21:53.069]                         }
[16:21:53.069]                       })
[16:21:53.069]                     }
[16:21:53.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.069]                     base::options(mc.cores = 1L)
[16:21:53.069]                   }
[16:21:53.069]                   ...future.strategy.old <- future::plan("list")
[16:21:53.069]                   options(future.plan = NULL)
[16:21:53.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.069]                 }
[16:21:53.069]                 ...future.workdir <- getwd()
[16:21:53.069]             }
[16:21:53.069]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.069]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.069]         }
[16:21:53.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.069]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.069]             base::names(...future.oldOptions))
[16:21:53.069]     }
[16:21:53.069]     if (FALSE) {
[16:21:53.069]     }
[16:21:53.069]     else {
[16:21:53.069]         if (TRUE) {
[16:21:53.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.069]                 open = "w")
[16:21:53.069]         }
[16:21:53.069]         else {
[16:21:53.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.069]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.069]         }
[16:21:53.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.069]             base::sink(type = "output", split = FALSE)
[16:21:53.069]             base::close(...future.stdout)
[16:21:53.069]         }, add = TRUE)
[16:21:53.069]     }
[16:21:53.069]     ...future.frame <- base::sys.nframe()
[16:21:53.069]     ...future.conditions <- base::list()
[16:21:53.069]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.069]     if (FALSE) {
[16:21:53.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.069]     }
[16:21:53.069]     ...future.result <- base::tryCatch({
[16:21:53.069]         base::withCallingHandlers({
[16:21:53.069]             ...future.value <- base::withVisible(base::local({
[16:21:53.069]                 withCallingHandlers({
[16:21:53.069]                   {
[16:21:53.069]                     2
[16:21:53.069]                   }
[16:21:53.069]                 }, immediateCondition = function(cond) {
[16:21:53.069]                   save_rds <- function (object, pathname, ...) 
[16:21:53.069]                   {
[16:21:53.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.069]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.069]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.069]                         fi_tmp[["mtime"]])
[16:21:53.069]                     }
[16:21:53.069]                     tryCatch({
[16:21:53.069]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.069]                     }, error = function(ex) {
[16:21:53.069]                       msg <- conditionMessage(ex)
[16:21:53.069]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.069]                         fi_tmp[["mtime"]], msg)
[16:21:53.069]                       ex$message <- msg
[16:21:53.069]                       stop(ex)
[16:21:53.069]                     })
[16:21:53.069]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.069]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.069]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.069]                       fi <- file.info(pathname)
[16:21:53.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.069]                         fi[["size"]], fi[["mtime"]])
[16:21:53.069]                       stop(msg)
[16:21:53.069]                     }
[16:21:53.069]                     invisible(pathname)
[16:21:53.069]                   }
[16:21:53.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.069]                     rootPath = tempdir()) 
[16:21:53.069]                   {
[16:21:53.069]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.069]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.069]                       tmpdir = path, fileext = ".rds")
[16:21:53.069]                     save_rds(obj, file)
[16:21:53.069]                   }
[16:21:53.069]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.069]                   {
[16:21:53.069]                     inherits <- base::inherits
[16:21:53.069]                     invokeRestart <- base::invokeRestart
[16:21:53.069]                     is.null <- base::is.null
[16:21:53.069]                     muffled <- FALSE
[16:21:53.069]                     if (inherits(cond, "message")) {
[16:21:53.069]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.069]                       if (muffled) 
[16:21:53.069]                         invokeRestart("muffleMessage")
[16:21:53.069]                     }
[16:21:53.069]                     else if (inherits(cond, "warning")) {
[16:21:53.069]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.069]                       if (muffled) 
[16:21:53.069]                         invokeRestart("muffleWarning")
[16:21:53.069]                     }
[16:21:53.069]                     else if (inherits(cond, "condition")) {
[16:21:53.069]                       if (!is.null(pattern)) {
[16:21:53.069]                         computeRestarts <- base::computeRestarts
[16:21:53.069]                         grepl <- base::grepl
[16:21:53.069]                         restarts <- computeRestarts(cond)
[16:21:53.069]                         for (restart in restarts) {
[16:21:53.069]                           name <- restart$name
[16:21:53.069]                           if (is.null(name)) 
[16:21:53.069]                             next
[16:21:53.069]                           if (!grepl(pattern, name)) 
[16:21:53.069]                             next
[16:21:53.069]                           invokeRestart(restart)
[16:21:53.069]                           muffled <- TRUE
[16:21:53.069]                           break
[16:21:53.069]                         }
[16:21:53.069]                       }
[16:21:53.069]                     }
[16:21:53.069]                     invisible(muffled)
[16:21:53.069]                   }
[16:21:53.069]                   muffleCondition(cond)
[16:21:53.069]                 })
[16:21:53.069]             }))
[16:21:53.069]             future::FutureResult(value = ...future.value$value, 
[16:21:53.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.069]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.069]                     ...future.globalenv.names))
[16:21:53.069]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.069]         }, condition = base::local({
[16:21:53.069]             c <- base::c
[16:21:53.069]             inherits <- base::inherits
[16:21:53.069]             invokeRestart <- base::invokeRestart
[16:21:53.069]             length <- base::length
[16:21:53.069]             list <- base::list
[16:21:53.069]             seq.int <- base::seq.int
[16:21:53.069]             signalCondition <- base::signalCondition
[16:21:53.069]             sys.calls <- base::sys.calls
[16:21:53.069]             `[[` <- base::`[[`
[16:21:53.069]             `+` <- base::`+`
[16:21:53.069]             `<<-` <- base::`<<-`
[16:21:53.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.069]                   3L)]
[16:21:53.069]             }
[16:21:53.069]             function(cond) {
[16:21:53.069]                 is_error <- inherits(cond, "error")
[16:21:53.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.069]                   NULL)
[16:21:53.069]                 if (is_error) {
[16:21:53.069]                   sessionInformation <- function() {
[16:21:53.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.069]                       search = base::search(), system = base::Sys.info())
[16:21:53.069]                   }
[16:21:53.069]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.069]                     cond$call), session = sessionInformation(), 
[16:21:53.069]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.069]                   signalCondition(cond)
[16:21:53.069]                 }
[16:21:53.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.069]                 "immediateCondition"))) {
[16:21:53.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.069]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.069]                   if (TRUE && !signal) {
[16:21:53.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.069]                     {
[16:21:53.069]                       inherits <- base::inherits
[16:21:53.069]                       invokeRestart <- base::invokeRestart
[16:21:53.069]                       is.null <- base::is.null
[16:21:53.069]                       muffled <- FALSE
[16:21:53.069]                       if (inherits(cond, "message")) {
[16:21:53.069]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.069]                         if (muffled) 
[16:21:53.069]                           invokeRestart("muffleMessage")
[16:21:53.069]                       }
[16:21:53.069]                       else if (inherits(cond, "warning")) {
[16:21:53.069]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.069]                         if (muffled) 
[16:21:53.069]                           invokeRestart("muffleWarning")
[16:21:53.069]                       }
[16:21:53.069]                       else if (inherits(cond, "condition")) {
[16:21:53.069]                         if (!is.null(pattern)) {
[16:21:53.069]                           computeRestarts <- base::computeRestarts
[16:21:53.069]                           grepl <- base::grepl
[16:21:53.069]                           restarts <- computeRestarts(cond)
[16:21:53.069]                           for (restart in restarts) {
[16:21:53.069]                             name <- restart$name
[16:21:53.069]                             if (is.null(name)) 
[16:21:53.069]                               next
[16:21:53.069]                             if (!grepl(pattern, name)) 
[16:21:53.069]                               next
[16:21:53.069]                             invokeRestart(restart)
[16:21:53.069]                             muffled <- TRUE
[16:21:53.069]                             break
[16:21:53.069]                           }
[16:21:53.069]                         }
[16:21:53.069]                       }
[16:21:53.069]                       invisible(muffled)
[16:21:53.069]                     }
[16:21:53.069]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.069]                   }
[16:21:53.069]                 }
[16:21:53.069]                 else {
[16:21:53.069]                   if (TRUE) {
[16:21:53.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.069]                     {
[16:21:53.069]                       inherits <- base::inherits
[16:21:53.069]                       invokeRestart <- base::invokeRestart
[16:21:53.069]                       is.null <- base::is.null
[16:21:53.069]                       muffled <- FALSE
[16:21:53.069]                       if (inherits(cond, "message")) {
[16:21:53.069]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.069]                         if (muffled) 
[16:21:53.069]                           invokeRestart("muffleMessage")
[16:21:53.069]                       }
[16:21:53.069]                       else if (inherits(cond, "warning")) {
[16:21:53.069]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.069]                         if (muffled) 
[16:21:53.069]                           invokeRestart("muffleWarning")
[16:21:53.069]                       }
[16:21:53.069]                       else if (inherits(cond, "condition")) {
[16:21:53.069]                         if (!is.null(pattern)) {
[16:21:53.069]                           computeRestarts <- base::computeRestarts
[16:21:53.069]                           grepl <- base::grepl
[16:21:53.069]                           restarts <- computeRestarts(cond)
[16:21:53.069]                           for (restart in restarts) {
[16:21:53.069]                             name <- restart$name
[16:21:53.069]                             if (is.null(name)) 
[16:21:53.069]                               next
[16:21:53.069]                             if (!grepl(pattern, name)) 
[16:21:53.069]                               next
[16:21:53.069]                             invokeRestart(restart)
[16:21:53.069]                             muffled <- TRUE
[16:21:53.069]                             break
[16:21:53.069]                           }
[16:21:53.069]                         }
[16:21:53.069]                       }
[16:21:53.069]                       invisible(muffled)
[16:21:53.069]                     }
[16:21:53.069]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.069]                   }
[16:21:53.069]                 }
[16:21:53.069]             }
[16:21:53.069]         }))
[16:21:53.069]     }, error = function(ex) {
[16:21:53.069]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.069]                 ...future.rng), started = ...future.startTime, 
[16:21:53.069]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.069]             version = "1.8"), class = "FutureResult")
[16:21:53.069]     }, finally = {
[16:21:53.069]         if (!identical(...future.workdir, getwd())) 
[16:21:53.069]             setwd(...future.workdir)
[16:21:53.069]         {
[16:21:53.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.069]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.069]             }
[16:21:53.069]             base::options(...future.oldOptions)
[16:21:53.069]             if (.Platform$OS.type == "windows") {
[16:21:53.069]                 old_names <- names(...future.oldEnvVars)
[16:21:53.069]                 envs <- base::Sys.getenv()
[16:21:53.069]                 names <- names(envs)
[16:21:53.069]                 common <- intersect(names, old_names)
[16:21:53.069]                 added <- setdiff(names, old_names)
[16:21:53.069]                 removed <- setdiff(old_names, names)
[16:21:53.069]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.069]                   envs[common]]
[16:21:53.069]                 NAMES <- toupper(changed)
[16:21:53.069]                 args <- list()
[16:21:53.069]                 for (kk in seq_along(NAMES)) {
[16:21:53.069]                   name <- changed[[kk]]
[16:21:53.069]                   NAME <- NAMES[[kk]]
[16:21:53.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.069]                     next
[16:21:53.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.069]                 }
[16:21:53.069]                 NAMES <- toupper(added)
[16:21:53.069]                 for (kk in seq_along(NAMES)) {
[16:21:53.069]                   name <- added[[kk]]
[16:21:53.069]                   NAME <- NAMES[[kk]]
[16:21:53.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.069]                     next
[16:21:53.069]                   args[[name]] <- ""
[16:21:53.069]                 }
[16:21:53.069]                 NAMES <- toupper(removed)
[16:21:53.069]                 for (kk in seq_along(NAMES)) {
[16:21:53.069]                   name <- removed[[kk]]
[16:21:53.069]                   NAME <- NAMES[[kk]]
[16:21:53.069]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.069]                     next
[16:21:53.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.069]                 }
[16:21:53.069]                 if (length(args) > 0) 
[16:21:53.069]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.069]             }
[16:21:53.069]             else {
[16:21:53.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.069]             }
[16:21:53.069]             {
[16:21:53.069]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.069]                   0L) {
[16:21:53.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.069]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.069]                   base::options(opts)
[16:21:53.069]                 }
[16:21:53.069]                 {
[16:21:53.069]                   {
[16:21:53.069]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.069]                     NULL
[16:21:53.069]                   }
[16:21:53.069]                   options(future.plan = NULL)
[16:21:53.069]                   if (is.na(NA_character_)) 
[16:21:53.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.069]                     .init = FALSE)
[16:21:53.069]                 }
[16:21:53.069]             }
[16:21:53.069]         }
[16:21:53.069]     })
[16:21:53.069]     if (TRUE) {
[16:21:53.069]         base::sink(type = "output", split = FALSE)
[16:21:53.069]         if (TRUE) {
[16:21:53.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.069]         }
[16:21:53.069]         else {
[16:21:53.069]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.069]         }
[16:21:53.069]         base::close(...future.stdout)
[16:21:53.069]         ...future.stdout <- NULL
[16:21:53.069]     }
[16:21:53.069]     ...future.result$conditions <- ...future.conditions
[16:21:53.069]     ...future.result$finished <- base::Sys.time()
[16:21:53.069]     ...future.result
[16:21:53.069] }
[16:21:53.073] requestCore(): workers = 2
[16:21:53.073] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.084] result() for MulticoreFuture ...
[16:21:53.085] result() for MulticoreFuture ...
[16:21:53.085] result() for MulticoreFuture ... done
[16:21:53.085] result() for MulticoreFuture ... done
[16:21:53.085] result() for MulticoreFuture ...
[16:21:53.086] result() for MulticoreFuture ... done
[16:21:53.089] MulticoreFuture started
[16:21:53.089] - Launch lazy future ... done
[16:21:53.089] run() for ‘MulticoreFuture’ ... done
[16:21:53.090] plan(): Setting new future strategy stack:
[16:21:53.090] List of future strategies:
[16:21:53.090] 1. sequential:
[16:21:53.090]    - args: function (..., envir = parent.frame())
[16:21:53.090]    - tweaked: FALSE
[16:21:53.090]    - call: NULL
[16:21:53.091] resolve() on environment ...
[16:21:53.091] plan(): nbrOfWorkers() = 1
[16:21:53.091]  recursive: 0
[16:21:53.092]  elements: [3] ‘a’
[16:21:53.093] Future #1
[16:21:53.093]  length: 2 (resolved future 1)
[16:21:53.093] plan(): Setting new future strategy stack:
[16:21:53.094] List of future strategies:
[16:21:53.094] 1. multicore:
[16:21:53.094]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.094]    - tweaked: FALSE
[16:21:53.094]    - call: plan(strategy)
[16:21:53.099] plan(): nbrOfWorkers() = 2
[16:21:53.099] Future #2
[16:21:53.099]  length: 1 (resolved future 2)
[16:21:53.100]  length: 0 (resolved future 3)
[16:21:53.100] resolve() on environment ... DONE
[16:21:53.101] resolve() on environment ...
[16:21:53.101]  recursive: 0
[16:21:53.102]  elements: [3] ‘b’
[16:21:53.102] Future #1
[16:21:53.102]  length: 2 (resolved future 1)
[16:21:53.103] Future #2
[16:21:53.103]  length: 1 (resolved future 2)
[16:21:53.103]  length: 0 (resolved future 3)
[16:21:53.103] resolve() on environment ... DONE
[16:21:53.104] resolve() on environment ...
[16:21:53.104]  recursive: 0
[16:21:53.105]  elements: [3] ‘c’
[16:21:53.105] Future #1
[16:21:53.105]  length: 2 (resolved future 1)
[16:21:53.110] Future #2
[16:21:53.110]  length: 1 (resolved future 2)
[16:21:53.111]  length: 0 (resolved future 3)
[16:21:53.111] resolve() on environment ... DONE
[16:21:53.113] resolve() on environment ...
[16:21:53.113]  recursive: 0
[16:21:53.114]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:21:53.115] Future #1
[16:21:53.115] result() for MulticoreFuture ...
[16:21:53.116] result() for MulticoreFuture ...
[16:21:53.116] result() for MulticoreFuture ... done
[16:21:53.117] result() for MulticoreFuture ... done
[16:21:53.117] result() for MulticoreFuture ...
[16:21:53.117] result() for MulticoreFuture ... done
[16:21:53.117]  length: 2 (resolved future 1)
[16:21:53.118] Future #2
[16:21:53.118] result() for MulticoreFuture ...
[16:21:53.119] result() for MulticoreFuture ...
[16:21:53.119] result() for MulticoreFuture ... done
[16:21:53.119] result() for MulticoreFuture ... done
[16:21:53.120] result() for MulticoreFuture ...
[16:21:53.120] result() for MulticoreFuture ... done
[16:21:53.120]  length: 1 (resolved future 2)
[16:21:53.120]  length: 0 (resolved future 3)
[16:21:53.120] resolve() on environment ... DONE
[16:21:53.121] resolve() on environment ...
[16:21:53.121]  recursive: 99
[16:21:53.122]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:21:53.122] Future #1
[16:21:53.122] result() for MulticoreFuture ...
[16:21:53.122] result() for MulticoreFuture ... done
[16:21:53.123] result() for MulticoreFuture ...
[16:21:53.123] result() for MulticoreFuture ... done
[16:21:53.123] A MulticoreFuture was resolved
[16:21:53.123]  length: 2 (resolved future 1)
[16:21:53.123] Future #2
[16:21:53.123] result() for MulticoreFuture ...
[16:21:53.123] result() for MulticoreFuture ... done
[16:21:53.123] result() for MulticoreFuture ...
[16:21:53.123] result() for MulticoreFuture ... done
[16:21:53.124] A MulticoreFuture was resolved
[16:21:53.124]  length: 1 (resolved future 2)
[16:21:53.124]  length: 0 (resolved future 3)
[16:21:53.124] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:21:53.125] resolve() on list environment ...
[16:21:53.125]  recursive: 0
[16:21:53.126]  length: 2
[16:21:53.126]  elements: ‘a’, ‘b’
[16:21:53.126]  length: 1 (resolved future 1)
[16:21:53.126]  length: 0 (resolved future 2)
[16:21:53.126] resolve() on list environment ... DONE
[16:21:53.126] getGlobalsAndPackages() ...
[16:21:53.126] Searching for globals...
[16:21:53.127] 
[16:21:53.127] Searching for globals ... DONE
[16:21:53.127] - globals: [0] <none>
[16:21:53.127] getGlobalsAndPackages() ... DONE
[16:21:53.127] run() for ‘Future’ ...
[16:21:53.127] - state: ‘created’
[16:21:53.128] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.132] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.132]   - Field: ‘label’
[16:21:53.132]   - Field: ‘local’
[16:21:53.132]   - Field: ‘owner’
[16:21:53.132]   - Field: ‘envir’
[16:21:53.132]   - Field: ‘workers’
[16:21:53.133]   - Field: ‘packages’
[16:21:53.133]   - Field: ‘gc’
[16:21:53.133]   - Field: ‘job’
[16:21:53.133]   - Field: ‘conditions’
[16:21:53.133]   - Field: ‘expr’
[16:21:53.133]   - Field: ‘uuid’
[16:21:53.133]   - Field: ‘seed’
[16:21:53.133]   - Field: ‘version’
[16:21:53.133]   - Field: ‘result’
[16:21:53.133]   - Field: ‘asynchronous’
[16:21:53.134]   - Field: ‘calls’
[16:21:53.134]   - Field: ‘globals’
[16:21:53.134]   - Field: ‘stdout’
[16:21:53.134]   - Field: ‘earlySignal’
[16:21:53.134]   - Field: ‘lazy’
[16:21:53.134]   - Field: ‘state’
[16:21:53.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.134] - Launch lazy future ...
[16:21:53.135] Packages needed by the future expression (n = 0): <none>
[16:21:53.135] Packages needed by future strategies (n = 0): <none>
[16:21:53.135] {
[16:21:53.135]     {
[16:21:53.135]         {
[16:21:53.135]             ...future.startTime <- base::Sys.time()
[16:21:53.135]             {
[16:21:53.135]                 {
[16:21:53.135]                   {
[16:21:53.135]                     {
[16:21:53.135]                       base::local({
[16:21:53.135]                         has_future <- base::requireNamespace("future", 
[16:21:53.135]                           quietly = TRUE)
[16:21:53.135]                         if (has_future) {
[16:21:53.135]                           ns <- base::getNamespace("future")
[16:21:53.135]                           version <- ns[[".package"]][["version"]]
[16:21:53.135]                           if (is.null(version)) 
[16:21:53.135]                             version <- utils::packageVersion("future")
[16:21:53.135]                         }
[16:21:53.135]                         else {
[16:21:53.135]                           version <- NULL
[16:21:53.135]                         }
[16:21:53.135]                         if (!has_future || version < "1.8.0") {
[16:21:53.135]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.135]                             "", base::R.version$version.string), 
[16:21:53.135]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.135]                               "release", "version")], collapse = " "), 
[16:21:53.135]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.135]                             info)
[16:21:53.135]                           info <- base::paste(info, collapse = "; ")
[16:21:53.135]                           if (!has_future) {
[16:21:53.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.135]                               info)
[16:21:53.135]                           }
[16:21:53.135]                           else {
[16:21:53.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.135]                               info, version)
[16:21:53.135]                           }
[16:21:53.135]                           base::stop(msg)
[16:21:53.135]                         }
[16:21:53.135]                       })
[16:21:53.135]                     }
[16:21:53.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.135]                     base::options(mc.cores = 1L)
[16:21:53.135]                   }
[16:21:53.135]                   ...future.strategy.old <- future::plan("list")
[16:21:53.135]                   options(future.plan = NULL)
[16:21:53.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.135]                 }
[16:21:53.135]                 ...future.workdir <- getwd()
[16:21:53.135]             }
[16:21:53.135]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.135]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.135]         }
[16:21:53.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.135]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.135]             base::names(...future.oldOptions))
[16:21:53.135]     }
[16:21:53.135]     if (FALSE) {
[16:21:53.135]     }
[16:21:53.135]     else {
[16:21:53.135]         if (TRUE) {
[16:21:53.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.135]                 open = "w")
[16:21:53.135]         }
[16:21:53.135]         else {
[16:21:53.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.135]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.135]         }
[16:21:53.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.135]             base::sink(type = "output", split = FALSE)
[16:21:53.135]             base::close(...future.stdout)
[16:21:53.135]         }, add = TRUE)
[16:21:53.135]     }
[16:21:53.135]     ...future.frame <- base::sys.nframe()
[16:21:53.135]     ...future.conditions <- base::list()
[16:21:53.135]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.135]     if (FALSE) {
[16:21:53.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.135]     }
[16:21:53.135]     ...future.result <- base::tryCatch({
[16:21:53.135]         base::withCallingHandlers({
[16:21:53.135]             ...future.value <- base::withVisible(base::local({
[16:21:53.135]                 withCallingHandlers({
[16:21:53.135]                   1
[16:21:53.135]                 }, immediateCondition = function(cond) {
[16:21:53.135]                   save_rds <- function (object, pathname, ...) 
[16:21:53.135]                   {
[16:21:53.135]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.135]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.135]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.135]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.135]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.135]                         fi_tmp[["mtime"]])
[16:21:53.135]                     }
[16:21:53.135]                     tryCatch({
[16:21:53.135]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.135]                     }, error = function(ex) {
[16:21:53.135]                       msg <- conditionMessage(ex)
[16:21:53.135]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.135]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.135]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.135]                         fi_tmp[["mtime"]], msg)
[16:21:53.135]                       ex$message <- msg
[16:21:53.135]                       stop(ex)
[16:21:53.135]                     })
[16:21:53.135]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.135]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.135]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.135]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.135]                       fi <- file.info(pathname)
[16:21:53.135]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.135]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.135]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.135]                         fi[["size"]], fi[["mtime"]])
[16:21:53.135]                       stop(msg)
[16:21:53.135]                     }
[16:21:53.135]                     invisible(pathname)
[16:21:53.135]                   }
[16:21:53.135]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.135]                     rootPath = tempdir()) 
[16:21:53.135]                   {
[16:21:53.135]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.135]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.135]                       tmpdir = path, fileext = ".rds")
[16:21:53.135]                     save_rds(obj, file)
[16:21:53.135]                   }
[16:21:53.135]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.135]                   {
[16:21:53.135]                     inherits <- base::inherits
[16:21:53.135]                     invokeRestart <- base::invokeRestart
[16:21:53.135]                     is.null <- base::is.null
[16:21:53.135]                     muffled <- FALSE
[16:21:53.135]                     if (inherits(cond, "message")) {
[16:21:53.135]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.135]                       if (muffled) 
[16:21:53.135]                         invokeRestart("muffleMessage")
[16:21:53.135]                     }
[16:21:53.135]                     else if (inherits(cond, "warning")) {
[16:21:53.135]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.135]                       if (muffled) 
[16:21:53.135]                         invokeRestart("muffleWarning")
[16:21:53.135]                     }
[16:21:53.135]                     else if (inherits(cond, "condition")) {
[16:21:53.135]                       if (!is.null(pattern)) {
[16:21:53.135]                         computeRestarts <- base::computeRestarts
[16:21:53.135]                         grepl <- base::grepl
[16:21:53.135]                         restarts <- computeRestarts(cond)
[16:21:53.135]                         for (restart in restarts) {
[16:21:53.135]                           name <- restart$name
[16:21:53.135]                           if (is.null(name)) 
[16:21:53.135]                             next
[16:21:53.135]                           if (!grepl(pattern, name)) 
[16:21:53.135]                             next
[16:21:53.135]                           invokeRestart(restart)
[16:21:53.135]                           muffled <- TRUE
[16:21:53.135]                           break
[16:21:53.135]                         }
[16:21:53.135]                       }
[16:21:53.135]                     }
[16:21:53.135]                     invisible(muffled)
[16:21:53.135]                   }
[16:21:53.135]                   muffleCondition(cond)
[16:21:53.135]                 })
[16:21:53.135]             }))
[16:21:53.135]             future::FutureResult(value = ...future.value$value, 
[16:21:53.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.135]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.135]                     ...future.globalenv.names))
[16:21:53.135]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.135]         }, condition = base::local({
[16:21:53.135]             c <- base::c
[16:21:53.135]             inherits <- base::inherits
[16:21:53.135]             invokeRestart <- base::invokeRestart
[16:21:53.135]             length <- base::length
[16:21:53.135]             list <- base::list
[16:21:53.135]             seq.int <- base::seq.int
[16:21:53.135]             signalCondition <- base::signalCondition
[16:21:53.135]             sys.calls <- base::sys.calls
[16:21:53.135]             `[[` <- base::`[[`
[16:21:53.135]             `+` <- base::`+`
[16:21:53.135]             `<<-` <- base::`<<-`
[16:21:53.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.135]                   3L)]
[16:21:53.135]             }
[16:21:53.135]             function(cond) {
[16:21:53.135]                 is_error <- inherits(cond, "error")
[16:21:53.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.135]                   NULL)
[16:21:53.135]                 if (is_error) {
[16:21:53.135]                   sessionInformation <- function() {
[16:21:53.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.135]                       search = base::search(), system = base::Sys.info())
[16:21:53.135]                   }
[16:21:53.135]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.135]                     cond$call), session = sessionInformation(), 
[16:21:53.135]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.135]                   signalCondition(cond)
[16:21:53.135]                 }
[16:21:53.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.135]                 "immediateCondition"))) {
[16:21:53.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.135]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.135]                   if (TRUE && !signal) {
[16:21:53.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.135]                     {
[16:21:53.135]                       inherits <- base::inherits
[16:21:53.135]                       invokeRestart <- base::invokeRestart
[16:21:53.135]                       is.null <- base::is.null
[16:21:53.135]                       muffled <- FALSE
[16:21:53.135]                       if (inherits(cond, "message")) {
[16:21:53.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.135]                         if (muffled) 
[16:21:53.135]                           invokeRestart("muffleMessage")
[16:21:53.135]                       }
[16:21:53.135]                       else if (inherits(cond, "warning")) {
[16:21:53.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.135]                         if (muffled) 
[16:21:53.135]                           invokeRestart("muffleWarning")
[16:21:53.135]                       }
[16:21:53.135]                       else if (inherits(cond, "condition")) {
[16:21:53.135]                         if (!is.null(pattern)) {
[16:21:53.135]                           computeRestarts <- base::computeRestarts
[16:21:53.135]                           grepl <- base::grepl
[16:21:53.135]                           restarts <- computeRestarts(cond)
[16:21:53.135]                           for (restart in restarts) {
[16:21:53.135]                             name <- restart$name
[16:21:53.135]                             if (is.null(name)) 
[16:21:53.135]                               next
[16:21:53.135]                             if (!grepl(pattern, name)) 
[16:21:53.135]                               next
[16:21:53.135]                             invokeRestart(restart)
[16:21:53.135]                             muffled <- TRUE
[16:21:53.135]                             break
[16:21:53.135]                           }
[16:21:53.135]                         }
[16:21:53.135]                       }
[16:21:53.135]                       invisible(muffled)
[16:21:53.135]                     }
[16:21:53.135]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.135]                   }
[16:21:53.135]                 }
[16:21:53.135]                 else {
[16:21:53.135]                   if (TRUE) {
[16:21:53.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.135]                     {
[16:21:53.135]                       inherits <- base::inherits
[16:21:53.135]                       invokeRestart <- base::invokeRestart
[16:21:53.135]                       is.null <- base::is.null
[16:21:53.135]                       muffled <- FALSE
[16:21:53.135]                       if (inherits(cond, "message")) {
[16:21:53.135]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.135]                         if (muffled) 
[16:21:53.135]                           invokeRestart("muffleMessage")
[16:21:53.135]                       }
[16:21:53.135]                       else if (inherits(cond, "warning")) {
[16:21:53.135]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.135]                         if (muffled) 
[16:21:53.135]                           invokeRestart("muffleWarning")
[16:21:53.135]                       }
[16:21:53.135]                       else if (inherits(cond, "condition")) {
[16:21:53.135]                         if (!is.null(pattern)) {
[16:21:53.135]                           computeRestarts <- base::computeRestarts
[16:21:53.135]                           grepl <- base::grepl
[16:21:53.135]                           restarts <- computeRestarts(cond)
[16:21:53.135]                           for (restart in restarts) {
[16:21:53.135]                             name <- restart$name
[16:21:53.135]                             if (is.null(name)) 
[16:21:53.135]                               next
[16:21:53.135]                             if (!grepl(pattern, name)) 
[16:21:53.135]                               next
[16:21:53.135]                             invokeRestart(restart)
[16:21:53.135]                             muffled <- TRUE
[16:21:53.135]                             break
[16:21:53.135]                           }
[16:21:53.135]                         }
[16:21:53.135]                       }
[16:21:53.135]                       invisible(muffled)
[16:21:53.135]                     }
[16:21:53.135]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.135]                   }
[16:21:53.135]                 }
[16:21:53.135]             }
[16:21:53.135]         }))
[16:21:53.135]     }, error = function(ex) {
[16:21:53.135]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.135]                 ...future.rng), started = ...future.startTime, 
[16:21:53.135]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.135]             version = "1.8"), class = "FutureResult")
[16:21:53.135]     }, finally = {
[16:21:53.135]         if (!identical(...future.workdir, getwd())) 
[16:21:53.135]             setwd(...future.workdir)
[16:21:53.135]         {
[16:21:53.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.135]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.135]             }
[16:21:53.135]             base::options(...future.oldOptions)
[16:21:53.135]             if (.Platform$OS.type == "windows") {
[16:21:53.135]                 old_names <- names(...future.oldEnvVars)
[16:21:53.135]                 envs <- base::Sys.getenv()
[16:21:53.135]                 names <- names(envs)
[16:21:53.135]                 common <- intersect(names, old_names)
[16:21:53.135]                 added <- setdiff(names, old_names)
[16:21:53.135]                 removed <- setdiff(old_names, names)
[16:21:53.135]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.135]                   envs[common]]
[16:21:53.135]                 NAMES <- toupper(changed)
[16:21:53.135]                 args <- list()
[16:21:53.135]                 for (kk in seq_along(NAMES)) {
[16:21:53.135]                   name <- changed[[kk]]
[16:21:53.135]                   NAME <- NAMES[[kk]]
[16:21:53.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.135]                     next
[16:21:53.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.135]                 }
[16:21:53.135]                 NAMES <- toupper(added)
[16:21:53.135]                 for (kk in seq_along(NAMES)) {
[16:21:53.135]                   name <- added[[kk]]
[16:21:53.135]                   NAME <- NAMES[[kk]]
[16:21:53.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.135]                     next
[16:21:53.135]                   args[[name]] <- ""
[16:21:53.135]                 }
[16:21:53.135]                 NAMES <- toupper(removed)
[16:21:53.135]                 for (kk in seq_along(NAMES)) {
[16:21:53.135]                   name <- removed[[kk]]
[16:21:53.135]                   NAME <- NAMES[[kk]]
[16:21:53.135]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.135]                     next
[16:21:53.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.135]                 }
[16:21:53.135]                 if (length(args) > 0) 
[16:21:53.135]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.135]             }
[16:21:53.135]             else {
[16:21:53.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.135]             }
[16:21:53.135]             {
[16:21:53.135]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.135]                   0L) {
[16:21:53.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.135]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.135]                   base::options(opts)
[16:21:53.135]                 }
[16:21:53.135]                 {
[16:21:53.135]                   {
[16:21:53.135]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.135]                     NULL
[16:21:53.135]                   }
[16:21:53.135]                   options(future.plan = NULL)
[16:21:53.135]                   if (is.na(NA_character_)) 
[16:21:53.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.135]                     .init = FALSE)
[16:21:53.135]                 }
[16:21:53.135]             }
[16:21:53.135]         }
[16:21:53.135]     })
[16:21:53.135]     if (TRUE) {
[16:21:53.135]         base::sink(type = "output", split = FALSE)
[16:21:53.135]         if (TRUE) {
[16:21:53.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.135]         }
[16:21:53.135]         else {
[16:21:53.135]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.135]         }
[16:21:53.135]         base::close(...future.stdout)
[16:21:53.135]         ...future.stdout <- NULL
[16:21:53.135]     }
[16:21:53.135]     ...future.result$conditions <- ...future.conditions
[16:21:53.135]     ...future.result$finished <- base::Sys.time()
[16:21:53.135]     ...future.result
[16:21:53.135] }
[16:21:53.138] requestCore(): workers = 2
[16:21:53.139] MulticoreFuture started
[16:21:53.140] - Launch lazy future ... done
[16:21:53.140] run() for ‘MulticoreFuture’ ... done
[16:21:53.140] getGlobalsAndPackages() ...
[16:21:53.141] Searching for globals...
[16:21:53.141] plan(): Setting new future strategy stack:
[16:21:53.141] 
[16:21:53.141] List of future strategies:
[16:21:53.141] 1. sequential:
[16:21:53.141]    - args: function (..., envir = parent.frame())
[16:21:53.141]    - tweaked: FALSE
[16:21:53.141]    - call: NULL
[16:21:53.142] Searching for globals ... DONE
[16:21:53.142] - globals: [0] <none>
[16:21:53.142] plan(): nbrOfWorkers() = 1
[16:21:53.142] getGlobalsAndPackages() ... DONE
[16:21:53.142] run() for ‘Future’ ...
[16:21:53.143] - state: ‘created’
[16:21:53.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.144] plan(): Setting new future strategy stack:
[16:21:53.144] List of future strategies:
[16:21:53.144] 1. multicore:
[16:21:53.144]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.144]    - tweaked: FALSE
[16:21:53.144]    - call: plan(strategy)
[16:21:53.148] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.148]   - Field: ‘label’
[16:21:53.148] plan(): nbrOfWorkers() = 2
[16:21:53.149]   - Field: ‘local’
[16:21:53.149]   - Field: ‘owner’
[16:21:53.149]   - Field: ‘envir’
[16:21:53.149]   - Field: ‘workers’
[16:21:53.149]   - Field: ‘packages’
[16:21:53.149]   - Field: ‘gc’
[16:21:53.149]   - Field: ‘job’
[16:21:53.150]   - Field: ‘conditions’
[16:21:53.150]   - Field: ‘expr’
[16:21:53.150]   - Field: ‘uuid’
[16:21:53.150]   - Field: ‘seed’
[16:21:53.150]   - Field: ‘version’
[16:21:53.150]   - Field: ‘result’
[16:21:53.150]   - Field: ‘asynchronous’
[16:21:53.151]   - Field: ‘calls’
[16:21:53.151]   - Field: ‘globals’
[16:21:53.151]   - Field: ‘stdout’
[16:21:53.151]   - Field: ‘earlySignal’
[16:21:53.151]   - Field: ‘lazy’
[16:21:53.151]   - Field: ‘state’
[16:21:53.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.152] - Launch lazy future ...
[16:21:53.152] Packages needed by the future expression (n = 0): <none>
[16:21:53.152] Packages needed by future strategies (n = 0): <none>
[16:21:53.153] {
[16:21:53.153]     {
[16:21:53.153]         {
[16:21:53.153]             ...future.startTime <- base::Sys.time()
[16:21:53.153]             {
[16:21:53.153]                 {
[16:21:53.153]                   {
[16:21:53.153]                     {
[16:21:53.153]                       base::local({
[16:21:53.153]                         has_future <- base::requireNamespace("future", 
[16:21:53.153]                           quietly = TRUE)
[16:21:53.153]                         if (has_future) {
[16:21:53.153]                           ns <- base::getNamespace("future")
[16:21:53.153]                           version <- ns[[".package"]][["version"]]
[16:21:53.153]                           if (is.null(version)) 
[16:21:53.153]                             version <- utils::packageVersion("future")
[16:21:53.153]                         }
[16:21:53.153]                         else {
[16:21:53.153]                           version <- NULL
[16:21:53.153]                         }
[16:21:53.153]                         if (!has_future || version < "1.8.0") {
[16:21:53.153]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.153]                             "", base::R.version$version.string), 
[16:21:53.153]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.153]                               "release", "version")], collapse = " "), 
[16:21:53.153]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.153]                             info)
[16:21:53.153]                           info <- base::paste(info, collapse = "; ")
[16:21:53.153]                           if (!has_future) {
[16:21:53.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.153]                               info)
[16:21:53.153]                           }
[16:21:53.153]                           else {
[16:21:53.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.153]                               info, version)
[16:21:53.153]                           }
[16:21:53.153]                           base::stop(msg)
[16:21:53.153]                         }
[16:21:53.153]                       })
[16:21:53.153]                     }
[16:21:53.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.153]                     base::options(mc.cores = 1L)
[16:21:53.153]                   }
[16:21:53.153]                   ...future.strategy.old <- future::plan("list")
[16:21:53.153]                   options(future.plan = NULL)
[16:21:53.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.153]                 }
[16:21:53.153]                 ...future.workdir <- getwd()
[16:21:53.153]             }
[16:21:53.153]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.153]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.153]         }
[16:21:53.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.153]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.153]             base::names(...future.oldOptions))
[16:21:53.153]     }
[16:21:53.153]     if (FALSE) {
[16:21:53.153]     }
[16:21:53.153]     else {
[16:21:53.153]         if (TRUE) {
[16:21:53.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.153]                 open = "w")
[16:21:53.153]         }
[16:21:53.153]         else {
[16:21:53.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.153]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.153]         }
[16:21:53.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.153]             base::sink(type = "output", split = FALSE)
[16:21:53.153]             base::close(...future.stdout)
[16:21:53.153]         }, add = TRUE)
[16:21:53.153]     }
[16:21:53.153]     ...future.frame <- base::sys.nframe()
[16:21:53.153]     ...future.conditions <- base::list()
[16:21:53.153]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.153]     if (FALSE) {
[16:21:53.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.153]     }
[16:21:53.153]     ...future.result <- base::tryCatch({
[16:21:53.153]         base::withCallingHandlers({
[16:21:53.153]             ...future.value <- base::withVisible(base::local({
[16:21:53.153]                 withCallingHandlers({
[16:21:53.153]                   2
[16:21:53.153]                 }, immediateCondition = function(cond) {
[16:21:53.153]                   save_rds <- function (object, pathname, ...) 
[16:21:53.153]                   {
[16:21:53.153]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.153]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.153]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.153]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.153]                         fi_tmp[["mtime"]])
[16:21:53.153]                     }
[16:21:53.153]                     tryCatch({
[16:21:53.153]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.153]                     }, error = function(ex) {
[16:21:53.153]                       msg <- conditionMessage(ex)
[16:21:53.153]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.153]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.153]                         fi_tmp[["mtime"]], msg)
[16:21:53.153]                       ex$message <- msg
[16:21:53.153]                       stop(ex)
[16:21:53.153]                     })
[16:21:53.153]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.153]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.153]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.153]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.153]                       fi <- file.info(pathname)
[16:21:53.153]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.153]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.153]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.153]                         fi[["size"]], fi[["mtime"]])
[16:21:53.153]                       stop(msg)
[16:21:53.153]                     }
[16:21:53.153]                     invisible(pathname)
[16:21:53.153]                   }
[16:21:53.153]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.153]                     rootPath = tempdir()) 
[16:21:53.153]                   {
[16:21:53.153]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.153]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.153]                       tmpdir = path, fileext = ".rds")
[16:21:53.153]                     save_rds(obj, file)
[16:21:53.153]                   }
[16:21:53.153]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.153]                   {
[16:21:53.153]                     inherits <- base::inherits
[16:21:53.153]                     invokeRestart <- base::invokeRestart
[16:21:53.153]                     is.null <- base::is.null
[16:21:53.153]                     muffled <- FALSE
[16:21:53.153]                     if (inherits(cond, "message")) {
[16:21:53.153]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.153]                       if (muffled) 
[16:21:53.153]                         invokeRestart("muffleMessage")
[16:21:53.153]                     }
[16:21:53.153]                     else if (inherits(cond, "warning")) {
[16:21:53.153]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.153]                       if (muffled) 
[16:21:53.153]                         invokeRestart("muffleWarning")
[16:21:53.153]                     }
[16:21:53.153]                     else if (inherits(cond, "condition")) {
[16:21:53.153]                       if (!is.null(pattern)) {
[16:21:53.153]                         computeRestarts <- base::computeRestarts
[16:21:53.153]                         grepl <- base::grepl
[16:21:53.153]                         restarts <- computeRestarts(cond)
[16:21:53.153]                         for (restart in restarts) {
[16:21:53.153]                           name <- restart$name
[16:21:53.153]                           if (is.null(name)) 
[16:21:53.153]                             next
[16:21:53.153]                           if (!grepl(pattern, name)) 
[16:21:53.153]                             next
[16:21:53.153]                           invokeRestart(restart)
[16:21:53.153]                           muffled <- TRUE
[16:21:53.153]                           break
[16:21:53.153]                         }
[16:21:53.153]                       }
[16:21:53.153]                     }
[16:21:53.153]                     invisible(muffled)
[16:21:53.153]                   }
[16:21:53.153]                   muffleCondition(cond)
[16:21:53.153]                 })
[16:21:53.153]             }))
[16:21:53.153]             future::FutureResult(value = ...future.value$value, 
[16:21:53.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.153]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.153]                     ...future.globalenv.names))
[16:21:53.153]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.153]         }, condition = base::local({
[16:21:53.153]             c <- base::c
[16:21:53.153]             inherits <- base::inherits
[16:21:53.153]             invokeRestart <- base::invokeRestart
[16:21:53.153]             length <- base::length
[16:21:53.153]             list <- base::list
[16:21:53.153]             seq.int <- base::seq.int
[16:21:53.153]             signalCondition <- base::signalCondition
[16:21:53.153]             sys.calls <- base::sys.calls
[16:21:53.153]             `[[` <- base::`[[`
[16:21:53.153]             `+` <- base::`+`
[16:21:53.153]             `<<-` <- base::`<<-`
[16:21:53.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.153]                   3L)]
[16:21:53.153]             }
[16:21:53.153]             function(cond) {
[16:21:53.153]                 is_error <- inherits(cond, "error")
[16:21:53.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.153]                   NULL)
[16:21:53.153]                 if (is_error) {
[16:21:53.153]                   sessionInformation <- function() {
[16:21:53.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.153]                       search = base::search(), system = base::Sys.info())
[16:21:53.153]                   }
[16:21:53.153]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.153]                     cond$call), session = sessionInformation(), 
[16:21:53.153]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.153]                   signalCondition(cond)
[16:21:53.153]                 }
[16:21:53.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.153]                 "immediateCondition"))) {
[16:21:53.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.153]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.153]                   if (TRUE && !signal) {
[16:21:53.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.153]                     {
[16:21:53.153]                       inherits <- base::inherits
[16:21:53.153]                       invokeRestart <- base::invokeRestart
[16:21:53.153]                       is.null <- base::is.null
[16:21:53.153]                       muffled <- FALSE
[16:21:53.153]                       if (inherits(cond, "message")) {
[16:21:53.153]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.153]                         if (muffled) 
[16:21:53.153]                           invokeRestart("muffleMessage")
[16:21:53.153]                       }
[16:21:53.153]                       else if (inherits(cond, "warning")) {
[16:21:53.153]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.153]                         if (muffled) 
[16:21:53.153]                           invokeRestart("muffleWarning")
[16:21:53.153]                       }
[16:21:53.153]                       else if (inherits(cond, "condition")) {
[16:21:53.153]                         if (!is.null(pattern)) {
[16:21:53.153]                           computeRestarts <- base::computeRestarts
[16:21:53.153]                           grepl <- base::grepl
[16:21:53.153]                           restarts <- computeRestarts(cond)
[16:21:53.153]                           for (restart in restarts) {
[16:21:53.153]                             name <- restart$name
[16:21:53.153]                             if (is.null(name)) 
[16:21:53.153]                               next
[16:21:53.153]                             if (!grepl(pattern, name)) 
[16:21:53.153]                               next
[16:21:53.153]                             invokeRestart(restart)
[16:21:53.153]                             muffled <- TRUE
[16:21:53.153]                             break
[16:21:53.153]                           }
[16:21:53.153]                         }
[16:21:53.153]                       }
[16:21:53.153]                       invisible(muffled)
[16:21:53.153]                     }
[16:21:53.153]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.153]                   }
[16:21:53.153]                 }
[16:21:53.153]                 else {
[16:21:53.153]                   if (TRUE) {
[16:21:53.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.153]                     {
[16:21:53.153]                       inherits <- base::inherits
[16:21:53.153]                       invokeRestart <- base::invokeRestart
[16:21:53.153]                       is.null <- base::is.null
[16:21:53.153]                       muffled <- FALSE
[16:21:53.153]                       if (inherits(cond, "message")) {
[16:21:53.153]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.153]                         if (muffled) 
[16:21:53.153]                           invokeRestart("muffleMessage")
[16:21:53.153]                       }
[16:21:53.153]                       else if (inherits(cond, "warning")) {
[16:21:53.153]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.153]                         if (muffled) 
[16:21:53.153]                           invokeRestart("muffleWarning")
[16:21:53.153]                       }
[16:21:53.153]                       else if (inherits(cond, "condition")) {
[16:21:53.153]                         if (!is.null(pattern)) {
[16:21:53.153]                           computeRestarts <- base::computeRestarts
[16:21:53.153]                           grepl <- base::grepl
[16:21:53.153]                           restarts <- computeRestarts(cond)
[16:21:53.153]                           for (restart in restarts) {
[16:21:53.153]                             name <- restart$name
[16:21:53.153]                             if (is.null(name)) 
[16:21:53.153]                               next
[16:21:53.153]                             if (!grepl(pattern, name)) 
[16:21:53.153]                               next
[16:21:53.153]                             invokeRestart(restart)
[16:21:53.153]                             muffled <- TRUE
[16:21:53.153]                             break
[16:21:53.153]                           }
[16:21:53.153]                         }
[16:21:53.153]                       }
[16:21:53.153]                       invisible(muffled)
[16:21:53.153]                     }
[16:21:53.153]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.153]                   }
[16:21:53.153]                 }
[16:21:53.153]             }
[16:21:53.153]         }))
[16:21:53.153]     }, error = function(ex) {
[16:21:53.153]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.153]                 ...future.rng), started = ...future.startTime, 
[16:21:53.153]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.153]             version = "1.8"), class = "FutureResult")
[16:21:53.153]     }, finally = {
[16:21:53.153]         if (!identical(...future.workdir, getwd())) 
[16:21:53.153]             setwd(...future.workdir)
[16:21:53.153]         {
[16:21:53.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.153]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.153]             }
[16:21:53.153]             base::options(...future.oldOptions)
[16:21:53.153]             if (.Platform$OS.type == "windows") {
[16:21:53.153]                 old_names <- names(...future.oldEnvVars)
[16:21:53.153]                 envs <- base::Sys.getenv()
[16:21:53.153]                 names <- names(envs)
[16:21:53.153]                 common <- intersect(names, old_names)
[16:21:53.153]                 added <- setdiff(names, old_names)
[16:21:53.153]                 removed <- setdiff(old_names, names)
[16:21:53.153]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.153]                   envs[common]]
[16:21:53.153]                 NAMES <- toupper(changed)
[16:21:53.153]                 args <- list()
[16:21:53.153]                 for (kk in seq_along(NAMES)) {
[16:21:53.153]                   name <- changed[[kk]]
[16:21:53.153]                   NAME <- NAMES[[kk]]
[16:21:53.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.153]                     next
[16:21:53.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.153]                 }
[16:21:53.153]                 NAMES <- toupper(added)
[16:21:53.153]                 for (kk in seq_along(NAMES)) {
[16:21:53.153]                   name <- added[[kk]]
[16:21:53.153]                   NAME <- NAMES[[kk]]
[16:21:53.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.153]                     next
[16:21:53.153]                   args[[name]] <- ""
[16:21:53.153]                 }
[16:21:53.153]                 NAMES <- toupper(removed)
[16:21:53.153]                 for (kk in seq_along(NAMES)) {
[16:21:53.153]                   name <- removed[[kk]]
[16:21:53.153]                   NAME <- NAMES[[kk]]
[16:21:53.153]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.153]                     next
[16:21:53.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.153]                 }
[16:21:53.153]                 if (length(args) > 0) 
[16:21:53.153]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.153]             }
[16:21:53.153]             else {
[16:21:53.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.153]             }
[16:21:53.153]             {
[16:21:53.153]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.153]                   0L) {
[16:21:53.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.153]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.153]                   base::options(opts)
[16:21:53.153]                 }
[16:21:53.153]                 {
[16:21:53.153]                   {
[16:21:53.153]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.153]                     NULL
[16:21:53.153]                   }
[16:21:53.153]                   options(future.plan = NULL)
[16:21:53.153]                   if (is.na(NA_character_)) 
[16:21:53.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.153]                     .init = FALSE)
[16:21:53.153]                 }
[16:21:53.153]             }
[16:21:53.153]         }
[16:21:53.153]     })
[16:21:53.153]     if (TRUE) {
[16:21:53.153]         base::sink(type = "output", split = FALSE)
[16:21:53.153]         if (TRUE) {
[16:21:53.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.153]         }
[16:21:53.153]         else {
[16:21:53.153]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.153]         }
[16:21:53.153]         base::close(...future.stdout)
[16:21:53.153]         ...future.stdout <- NULL
[16:21:53.153]     }
[16:21:53.153]     ...future.result$conditions <- ...future.conditions
[16:21:53.153]     ...future.result$finished <- base::Sys.time()
[16:21:53.153]     ...future.result
[16:21:53.153] }
[16:21:53.156] requestCore(): workers = 2
[16:21:53.158] MulticoreFuture started
[16:21:53.159] - Launch lazy future ... done
[16:21:53.159] run() for ‘MulticoreFuture’ ... done
[16:21:53.160] plan(): Setting new future strategy stack:
[16:21:53.160] List of future strategies:
[16:21:53.160] 1. sequential:
[16:21:53.160]    - args: function (..., envir = parent.frame())
[16:21:53.160]    - tweaked: FALSE
[16:21:53.160]    - call: NULL
[16:21:53.165] plan(): nbrOfWorkers() = 1
[16:21:53.166] resolve() on list environment ...
[16:21:53.166]  recursive: 0
[16:21:53.168] plan(): Setting new future strategy stack:
[16:21:53.169]  length: 3
[16:21:53.168] List of future strategies:
[16:21:53.168] 1. multicore:
[16:21:53.168]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.168]    - tweaked: FALSE
[16:21:53.168]    - call: plan(strategy)
[16:21:53.169]  elements: ‘a’, ‘b’, ‘c’
[16:21:53.170] Future #1
[16:21:53.170]  length: 2 (resolved future 1)
[16:21:53.174] plan(): nbrOfWorkers() = 2
[16:21:53.175] Future #2
[16:21:53.175]  length: 1 (resolved future 2)
[16:21:53.175]  length: 0 (resolved future 3)
[16:21:53.175] resolve() on list environment ... DONE
[16:21:53.177] getGlobalsAndPackages() ...
[16:21:53.177] Searching for globals...
[16:21:53.178] - globals found: [1] ‘{’
[16:21:53.178] Searching for globals ... DONE
[16:21:53.179] Resolving globals: FALSE
[16:21:53.179] 
[16:21:53.179] 
[16:21:53.180] getGlobalsAndPackages() ... DONE
[16:21:53.180] run() for ‘Future’ ...
[16:21:53.180] - state: ‘created’
[16:21:53.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.185] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.185]   - Field: ‘label’
[16:21:53.185]   - Field: ‘local’
[16:21:53.186]   - Field: ‘owner’
[16:21:53.186]   - Field: ‘envir’
[16:21:53.186]   - Field: ‘workers’
[16:21:53.186]   - Field: ‘packages’
[16:21:53.186]   - Field: ‘gc’
[16:21:53.186]   - Field: ‘job’
[16:21:53.187]   - Field: ‘conditions’
[16:21:53.187]   - Field: ‘expr’
[16:21:53.187]   - Field: ‘uuid’
[16:21:53.187]   - Field: ‘seed’
[16:21:53.187]   - Field: ‘version’
[16:21:53.187]   - Field: ‘result’
[16:21:53.187]   - Field: ‘asynchronous’
[16:21:53.187]   - Field: ‘calls’
[16:21:53.188]   - Field: ‘globals’
[16:21:53.188]   - Field: ‘stdout’
[16:21:53.188]   - Field: ‘earlySignal’
[16:21:53.188]   - Field: ‘lazy’
[16:21:53.188]   - Field: ‘state’
[16:21:53.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.188] - Launch lazy future ...
[16:21:53.189] Packages needed by the future expression (n = 0): <none>
[16:21:53.189] Packages needed by future strategies (n = 0): <none>
[16:21:53.190] {
[16:21:53.190]     {
[16:21:53.190]         {
[16:21:53.190]             ...future.startTime <- base::Sys.time()
[16:21:53.190]             {
[16:21:53.190]                 {
[16:21:53.190]                   {
[16:21:53.190]                     {
[16:21:53.190]                       base::local({
[16:21:53.190]                         has_future <- base::requireNamespace("future", 
[16:21:53.190]                           quietly = TRUE)
[16:21:53.190]                         if (has_future) {
[16:21:53.190]                           ns <- base::getNamespace("future")
[16:21:53.190]                           version <- ns[[".package"]][["version"]]
[16:21:53.190]                           if (is.null(version)) 
[16:21:53.190]                             version <- utils::packageVersion("future")
[16:21:53.190]                         }
[16:21:53.190]                         else {
[16:21:53.190]                           version <- NULL
[16:21:53.190]                         }
[16:21:53.190]                         if (!has_future || version < "1.8.0") {
[16:21:53.190]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.190]                             "", base::R.version$version.string), 
[16:21:53.190]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.190]                               "release", "version")], collapse = " "), 
[16:21:53.190]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.190]                             info)
[16:21:53.190]                           info <- base::paste(info, collapse = "; ")
[16:21:53.190]                           if (!has_future) {
[16:21:53.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.190]                               info)
[16:21:53.190]                           }
[16:21:53.190]                           else {
[16:21:53.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.190]                               info, version)
[16:21:53.190]                           }
[16:21:53.190]                           base::stop(msg)
[16:21:53.190]                         }
[16:21:53.190]                       })
[16:21:53.190]                     }
[16:21:53.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.190]                     base::options(mc.cores = 1L)
[16:21:53.190]                   }
[16:21:53.190]                   ...future.strategy.old <- future::plan("list")
[16:21:53.190]                   options(future.plan = NULL)
[16:21:53.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.190]                 }
[16:21:53.190]                 ...future.workdir <- getwd()
[16:21:53.190]             }
[16:21:53.190]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.190]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.190]         }
[16:21:53.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.190]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.190]             base::names(...future.oldOptions))
[16:21:53.190]     }
[16:21:53.190]     if (FALSE) {
[16:21:53.190]     }
[16:21:53.190]     else {
[16:21:53.190]         if (TRUE) {
[16:21:53.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.190]                 open = "w")
[16:21:53.190]         }
[16:21:53.190]         else {
[16:21:53.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.190]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.190]         }
[16:21:53.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.190]             base::sink(type = "output", split = FALSE)
[16:21:53.190]             base::close(...future.stdout)
[16:21:53.190]         }, add = TRUE)
[16:21:53.190]     }
[16:21:53.190]     ...future.frame <- base::sys.nframe()
[16:21:53.190]     ...future.conditions <- base::list()
[16:21:53.190]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.190]     if (FALSE) {
[16:21:53.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.190]     }
[16:21:53.190]     ...future.result <- base::tryCatch({
[16:21:53.190]         base::withCallingHandlers({
[16:21:53.190]             ...future.value <- base::withVisible(base::local({
[16:21:53.190]                 withCallingHandlers({
[16:21:53.190]                   {
[16:21:53.190]                     1
[16:21:53.190]                   }
[16:21:53.190]                 }, immediateCondition = function(cond) {
[16:21:53.190]                   save_rds <- function (object, pathname, ...) 
[16:21:53.190]                   {
[16:21:53.190]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.190]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.190]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.190]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.190]                         fi_tmp[["mtime"]])
[16:21:53.190]                     }
[16:21:53.190]                     tryCatch({
[16:21:53.190]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.190]                     }, error = function(ex) {
[16:21:53.190]                       msg <- conditionMessage(ex)
[16:21:53.190]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.190]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.190]                         fi_tmp[["mtime"]], msg)
[16:21:53.190]                       ex$message <- msg
[16:21:53.190]                       stop(ex)
[16:21:53.190]                     })
[16:21:53.190]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.190]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.190]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.190]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.190]                       fi <- file.info(pathname)
[16:21:53.190]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.190]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.190]                         fi[["size"]], fi[["mtime"]])
[16:21:53.190]                       stop(msg)
[16:21:53.190]                     }
[16:21:53.190]                     invisible(pathname)
[16:21:53.190]                   }
[16:21:53.190]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.190]                     rootPath = tempdir()) 
[16:21:53.190]                   {
[16:21:53.190]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.190]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.190]                       tmpdir = path, fileext = ".rds")
[16:21:53.190]                     save_rds(obj, file)
[16:21:53.190]                   }
[16:21:53.190]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.190]                   {
[16:21:53.190]                     inherits <- base::inherits
[16:21:53.190]                     invokeRestart <- base::invokeRestart
[16:21:53.190]                     is.null <- base::is.null
[16:21:53.190]                     muffled <- FALSE
[16:21:53.190]                     if (inherits(cond, "message")) {
[16:21:53.190]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.190]                       if (muffled) 
[16:21:53.190]                         invokeRestart("muffleMessage")
[16:21:53.190]                     }
[16:21:53.190]                     else if (inherits(cond, "warning")) {
[16:21:53.190]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.190]                       if (muffled) 
[16:21:53.190]                         invokeRestart("muffleWarning")
[16:21:53.190]                     }
[16:21:53.190]                     else if (inherits(cond, "condition")) {
[16:21:53.190]                       if (!is.null(pattern)) {
[16:21:53.190]                         computeRestarts <- base::computeRestarts
[16:21:53.190]                         grepl <- base::grepl
[16:21:53.190]                         restarts <- computeRestarts(cond)
[16:21:53.190]                         for (restart in restarts) {
[16:21:53.190]                           name <- restart$name
[16:21:53.190]                           if (is.null(name)) 
[16:21:53.190]                             next
[16:21:53.190]                           if (!grepl(pattern, name)) 
[16:21:53.190]                             next
[16:21:53.190]                           invokeRestart(restart)
[16:21:53.190]                           muffled <- TRUE
[16:21:53.190]                           break
[16:21:53.190]                         }
[16:21:53.190]                       }
[16:21:53.190]                     }
[16:21:53.190]                     invisible(muffled)
[16:21:53.190]                   }
[16:21:53.190]                   muffleCondition(cond)
[16:21:53.190]                 })
[16:21:53.190]             }))
[16:21:53.190]             future::FutureResult(value = ...future.value$value, 
[16:21:53.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.190]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.190]                     ...future.globalenv.names))
[16:21:53.190]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.190]         }, condition = base::local({
[16:21:53.190]             c <- base::c
[16:21:53.190]             inherits <- base::inherits
[16:21:53.190]             invokeRestart <- base::invokeRestart
[16:21:53.190]             length <- base::length
[16:21:53.190]             list <- base::list
[16:21:53.190]             seq.int <- base::seq.int
[16:21:53.190]             signalCondition <- base::signalCondition
[16:21:53.190]             sys.calls <- base::sys.calls
[16:21:53.190]             `[[` <- base::`[[`
[16:21:53.190]             `+` <- base::`+`
[16:21:53.190]             `<<-` <- base::`<<-`
[16:21:53.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.190]                   3L)]
[16:21:53.190]             }
[16:21:53.190]             function(cond) {
[16:21:53.190]                 is_error <- inherits(cond, "error")
[16:21:53.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.190]                   NULL)
[16:21:53.190]                 if (is_error) {
[16:21:53.190]                   sessionInformation <- function() {
[16:21:53.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.190]                       search = base::search(), system = base::Sys.info())
[16:21:53.190]                   }
[16:21:53.190]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.190]                     cond$call), session = sessionInformation(), 
[16:21:53.190]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.190]                   signalCondition(cond)
[16:21:53.190]                 }
[16:21:53.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.190]                 "immediateCondition"))) {
[16:21:53.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.190]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.190]                   if (TRUE && !signal) {
[16:21:53.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.190]                     {
[16:21:53.190]                       inherits <- base::inherits
[16:21:53.190]                       invokeRestart <- base::invokeRestart
[16:21:53.190]                       is.null <- base::is.null
[16:21:53.190]                       muffled <- FALSE
[16:21:53.190]                       if (inherits(cond, "message")) {
[16:21:53.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.190]                         if (muffled) 
[16:21:53.190]                           invokeRestart("muffleMessage")
[16:21:53.190]                       }
[16:21:53.190]                       else if (inherits(cond, "warning")) {
[16:21:53.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.190]                         if (muffled) 
[16:21:53.190]                           invokeRestart("muffleWarning")
[16:21:53.190]                       }
[16:21:53.190]                       else if (inherits(cond, "condition")) {
[16:21:53.190]                         if (!is.null(pattern)) {
[16:21:53.190]                           computeRestarts <- base::computeRestarts
[16:21:53.190]                           grepl <- base::grepl
[16:21:53.190]                           restarts <- computeRestarts(cond)
[16:21:53.190]                           for (restart in restarts) {
[16:21:53.190]                             name <- restart$name
[16:21:53.190]                             if (is.null(name)) 
[16:21:53.190]                               next
[16:21:53.190]                             if (!grepl(pattern, name)) 
[16:21:53.190]                               next
[16:21:53.190]                             invokeRestart(restart)
[16:21:53.190]                             muffled <- TRUE
[16:21:53.190]                             break
[16:21:53.190]                           }
[16:21:53.190]                         }
[16:21:53.190]                       }
[16:21:53.190]                       invisible(muffled)
[16:21:53.190]                     }
[16:21:53.190]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.190]                   }
[16:21:53.190]                 }
[16:21:53.190]                 else {
[16:21:53.190]                   if (TRUE) {
[16:21:53.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.190]                     {
[16:21:53.190]                       inherits <- base::inherits
[16:21:53.190]                       invokeRestart <- base::invokeRestart
[16:21:53.190]                       is.null <- base::is.null
[16:21:53.190]                       muffled <- FALSE
[16:21:53.190]                       if (inherits(cond, "message")) {
[16:21:53.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.190]                         if (muffled) 
[16:21:53.190]                           invokeRestart("muffleMessage")
[16:21:53.190]                       }
[16:21:53.190]                       else if (inherits(cond, "warning")) {
[16:21:53.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.190]                         if (muffled) 
[16:21:53.190]                           invokeRestart("muffleWarning")
[16:21:53.190]                       }
[16:21:53.190]                       else if (inherits(cond, "condition")) {
[16:21:53.190]                         if (!is.null(pattern)) {
[16:21:53.190]                           computeRestarts <- base::computeRestarts
[16:21:53.190]                           grepl <- base::grepl
[16:21:53.190]                           restarts <- computeRestarts(cond)
[16:21:53.190]                           for (restart in restarts) {
[16:21:53.190]                             name <- restart$name
[16:21:53.190]                             if (is.null(name)) 
[16:21:53.190]                               next
[16:21:53.190]                             if (!grepl(pattern, name)) 
[16:21:53.190]                               next
[16:21:53.190]                             invokeRestart(restart)
[16:21:53.190]                             muffled <- TRUE
[16:21:53.190]                             break
[16:21:53.190]                           }
[16:21:53.190]                         }
[16:21:53.190]                       }
[16:21:53.190]                       invisible(muffled)
[16:21:53.190]                     }
[16:21:53.190]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.190]                   }
[16:21:53.190]                 }
[16:21:53.190]             }
[16:21:53.190]         }))
[16:21:53.190]     }, error = function(ex) {
[16:21:53.190]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.190]                 ...future.rng), started = ...future.startTime, 
[16:21:53.190]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.190]             version = "1.8"), class = "FutureResult")
[16:21:53.190]     }, finally = {
[16:21:53.190]         if (!identical(...future.workdir, getwd())) 
[16:21:53.190]             setwd(...future.workdir)
[16:21:53.190]         {
[16:21:53.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.190]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.190]             }
[16:21:53.190]             base::options(...future.oldOptions)
[16:21:53.190]             if (.Platform$OS.type == "windows") {
[16:21:53.190]                 old_names <- names(...future.oldEnvVars)
[16:21:53.190]                 envs <- base::Sys.getenv()
[16:21:53.190]                 names <- names(envs)
[16:21:53.190]                 common <- intersect(names, old_names)
[16:21:53.190]                 added <- setdiff(names, old_names)
[16:21:53.190]                 removed <- setdiff(old_names, names)
[16:21:53.190]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.190]                   envs[common]]
[16:21:53.190]                 NAMES <- toupper(changed)
[16:21:53.190]                 args <- list()
[16:21:53.190]                 for (kk in seq_along(NAMES)) {
[16:21:53.190]                   name <- changed[[kk]]
[16:21:53.190]                   NAME <- NAMES[[kk]]
[16:21:53.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.190]                     next
[16:21:53.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.190]                 }
[16:21:53.190]                 NAMES <- toupper(added)
[16:21:53.190]                 for (kk in seq_along(NAMES)) {
[16:21:53.190]                   name <- added[[kk]]
[16:21:53.190]                   NAME <- NAMES[[kk]]
[16:21:53.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.190]                     next
[16:21:53.190]                   args[[name]] <- ""
[16:21:53.190]                 }
[16:21:53.190]                 NAMES <- toupper(removed)
[16:21:53.190]                 for (kk in seq_along(NAMES)) {
[16:21:53.190]                   name <- removed[[kk]]
[16:21:53.190]                   NAME <- NAMES[[kk]]
[16:21:53.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.190]                     next
[16:21:53.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.190]                 }
[16:21:53.190]                 if (length(args) > 0) 
[16:21:53.190]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.190]             }
[16:21:53.190]             else {
[16:21:53.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.190]             }
[16:21:53.190]             {
[16:21:53.190]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.190]                   0L) {
[16:21:53.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.190]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.190]                   base::options(opts)
[16:21:53.190]                 }
[16:21:53.190]                 {
[16:21:53.190]                   {
[16:21:53.190]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.190]                     NULL
[16:21:53.190]                   }
[16:21:53.190]                   options(future.plan = NULL)
[16:21:53.190]                   if (is.na(NA_character_)) 
[16:21:53.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.190]                     .init = FALSE)
[16:21:53.190]                 }
[16:21:53.190]             }
[16:21:53.190]         }
[16:21:53.190]     })
[16:21:53.190]     if (TRUE) {
[16:21:53.190]         base::sink(type = "output", split = FALSE)
[16:21:53.190]         if (TRUE) {
[16:21:53.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.190]         }
[16:21:53.190]         else {
[16:21:53.190]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.190]         }
[16:21:53.190]         base::close(...future.stdout)
[16:21:53.190]         ...future.stdout <- NULL
[16:21:53.190]     }
[16:21:53.190]     ...future.result$conditions <- ...future.conditions
[16:21:53.190]     ...future.result$finished <- base::Sys.time()
[16:21:53.190]     ...future.result
[16:21:53.190] }
[16:21:53.192] requestCore(): workers = 2
[16:21:53.193] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.203] result() for MulticoreFuture ...
[16:21:53.204] result() for MulticoreFuture ...
[16:21:53.204] result() for MulticoreFuture ... done
[16:21:53.204] result() for MulticoreFuture ... done
[16:21:53.205] result() for MulticoreFuture ...
[16:21:53.205] result() for MulticoreFuture ... done
[16:21:53.208] MulticoreFuture started
[16:21:53.208] - Launch lazy future ... done
[16:21:53.208] run() for ‘MulticoreFuture’ ... done
[16:21:53.209] plan(): Setting new future strategy stack:
[16:21:53.209] getGlobalsAndPackages() ...
[16:21:53.209] List of future strategies:
[16:21:53.209] 1. sequential:
[16:21:53.209]    - args: function (..., envir = parent.frame())
[16:21:53.209]    - tweaked: FALSE
[16:21:53.209]    - call: NULL
[16:21:53.210] Searching for globals...
[16:21:53.210] plan(): nbrOfWorkers() = 1
[16:21:53.211] - globals found: [1] ‘{’
[16:21:53.211] Searching for globals ... DONE
[16:21:53.211] Resolving globals: FALSE
[16:21:53.212] plan(): Setting new future strategy stack:
[16:21:53.212] 
[16:21:53.212] 
[16:21:53.212] getGlobalsAndPackages() ... DONE
[16:21:53.212] List of future strategies:
[16:21:53.212] 1. multicore:
[16:21:53.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.212]    - tweaked: FALSE
[16:21:53.212]    - call: plan(strategy)
[16:21:53.213] run() for ‘Future’ ...
[16:21:53.213] - state: ‘created’
[16:21:53.213] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.217] plan(): nbrOfWorkers() = 2
[16:21:53.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.218]   - Field: ‘label’
[16:21:53.218]   - Field: ‘local’
[16:21:53.218]   - Field: ‘owner’
[16:21:53.219]   - Field: ‘envir’
[16:21:53.219]   - Field: ‘workers’
[16:21:53.219]   - Field: ‘packages’
[16:21:53.219]   - Field: ‘gc’
[16:21:53.219]   - Field: ‘job’
[16:21:53.219]   - Field: ‘conditions’
[16:21:53.219]   - Field: ‘expr’
[16:21:53.220]   - Field: ‘uuid’
[16:21:53.220]   - Field: ‘seed’
[16:21:53.220]   - Field: ‘version’
[16:21:53.220]   - Field: ‘result’
[16:21:53.220]   - Field: ‘asynchronous’
[16:21:53.220]   - Field: ‘calls’
[16:21:53.220]   - Field: ‘globals’
[16:21:53.221]   - Field: ‘stdout’
[16:21:53.221]   - Field: ‘earlySignal’
[16:21:53.221]   - Field: ‘lazy’
[16:21:53.221]   - Field: ‘state’
[16:21:53.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.221] - Launch lazy future ...
[16:21:53.222] Packages needed by the future expression (n = 0): <none>
[16:21:53.222] Packages needed by future strategies (n = 0): <none>
[16:21:53.223] {
[16:21:53.223]     {
[16:21:53.223]         {
[16:21:53.223]             ...future.startTime <- base::Sys.time()
[16:21:53.223]             {
[16:21:53.223]                 {
[16:21:53.223]                   {
[16:21:53.223]                     {
[16:21:53.223]                       base::local({
[16:21:53.223]                         has_future <- base::requireNamespace("future", 
[16:21:53.223]                           quietly = TRUE)
[16:21:53.223]                         if (has_future) {
[16:21:53.223]                           ns <- base::getNamespace("future")
[16:21:53.223]                           version <- ns[[".package"]][["version"]]
[16:21:53.223]                           if (is.null(version)) 
[16:21:53.223]                             version <- utils::packageVersion("future")
[16:21:53.223]                         }
[16:21:53.223]                         else {
[16:21:53.223]                           version <- NULL
[16:21:53.223]                         }
[16:21:53.223]                         if (!has_future || version < "1.8.0") {
[16:21:53.223]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.223]                             "", base::R.version$version.string), 
[16:21:53.223]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.223]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.223]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.223]                               "release", "version")], collapse = " "), 
[16:21:53.223]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.223]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.223]                             info)
[16:21:53.223]                           info <- base::paste(info, collapse = "; ")
[16:21:53.223]                           if (!has_future) {
[16:21:53.223]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.223]                               info)
[16:21:53.223]                           }
[16:21:53.223]                           else {
[16:21:53.223]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.223]                               info, version)
[16:21:53.223]                           }
[16:21:53.223]                           base::stop(msg)
[16:21:53.223]                         }
[16:21:53.223]                       })
[16:21:53.223]                     }
[16:21:53.223]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.223]                     base::options(mc.cores = 1L)
[16:21:53.223]                   }
[16:21:53.223]                   ...future.strategy.old <- future::plan("list")
[16:21:53.223]                   options(future.plan = NULL)
[16:21:53.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.223]                 }
[16:21:53.223]                 ...future.workdir <- getwd()
[16:21:53.223]             }
[16:21:53.223]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.223]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.223]         }
[16:21:53.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.223]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.223]             base::names(...future.oldOptions))
[16:21:53.223]     }
[16:21:53.223]     if (FALSE) {
[16:21:53.223]     }
[16:21:53.223]     else {
[16:21:53.223]         if (TRUE) {
[16:21:53.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.223]                 open = "w")
[16:21:53.223]         }
[16:21:53.223]         else {
[16:21:53.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.223]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.223]         }
[16:21:53.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.223]             base::sink(type = "output", split = FALSE)
[16:21:53.223]             base::close(...future.stdout)
[16:21:53.223]         }, add = TRUE)
[16:21:53.223]     }
[16:21:53.223]     ...future.frame <- base::sys.nframe()
[16:21:53.223]     ...future.conditions <- base::list()
[16:21:53.223]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.223]     if (FALSE) {
[16:21:53.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.223]     }
[16:21:53.223]     ...future.result <- base::tryCatch({
[16:21:53.223]         base::withCallingHandlers({
[16:21:53.223]             ...future.value <- base::withVisible(base::local({
[16:21:53.223]                 withCallingHandlers({
[16:21:53.223]                   {
[16:21:53.223]                     2
[16:21:53.223]                   }
[16:21:53.223]                 }, immediateCondition = function(cond) {
[16:21:53.223]                   save_rds <- function (object, pathname, ...) 
[16:21:53.223]                   {
[16:21:53.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.223]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.223]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.223]                         fi_tmp[["mtime"]])
[16:21:53.223]                     }
[16:21:53.223]                     tryCatch({
[16:21:53.223]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.223]                     }, error = function(ex) {
[16:21:53.223]                       msg <- conditionMessage(ex)
[16:21:53.223]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.223]                         fi_tmp[["mtime"]], msg)
[16:21:53.223]                       ex$message <- msg
[16:21:53.223]                       stop(ex)
[16:21:53.223]                     })
[16:21:53.223]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.223]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.223]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.223]                       fi <- file.info(pathname)
[16:21:53.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.223]                         fi[["size"]], fi[["mtime"]])
[16:21:53.223]                       stop(msg)
[16:21:53.223]                     }
[16:21:53.223]                     invisible(pathname)
[16:21:53.223]                   }
[16:21:53.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.223]                     rootPath = tempdir()) 
[16:21:53.223]                   {
[16:21:53.223]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.223]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.223]                       tmpdir = path, fileext = ".rds")
[16:21:53.223]                     save_rds(obj, file)
[16:21:53.223]                   }
[16:21:53.223]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.223]                   {
[16:21:53.223]                     inherits <- base::inherits
[16:21:53.223]                     invokeRestart <- base::invokeRestart
[16:21:53.223]                     is.null <- base::is.null
[16:21:53.223]                     muffled <- FALSE
[16:21:53.223]                     if (inherits(cond, "message")) {
[16:21:53.223]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.223]                       if (muffled) 
[16:21:53.223]                         invokeRestart("muffleMessage")
[16:21:53.223]                     }
[16:21:53.223]                     else if (inherits(cond, "warning")) {
[16:21:53.223]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.223]                       if (muffled) 
[16:21:53.223]                         invokeRestart("muffleWarning")
[16:21:53.223]                     }
[16:21:53.223]                     else if (inherits(cond, "condition")) {
[16:21:53.223]                       if (!is.null(pattern)) {
[16:21:53.223]                         computeRestarts <- base::computeRestarts
[16:21:53.223]                         grepl <- base::grepl
[16:21:53.223]                         restarts <- computeRestarts(cond)
[16:21:53.223]                         for (restart in restarts) {
[16:21:53.223]                           name <- restart$name
[16:21:53.223]                           if (is.null(name)) 
[16:21:53.223]                             next
[16:21:53.223]                           if (!grepl(pattern, name)) 
[16:21:53.223]                             next
[16:21:53.223]                           invokeRestart(restart)
[16:21:53.223]                           muffled <- TRUE
[16:21:53.223]                           break
[16:21:53.223]                         }
[16:21:53.223]                       }
[16:21:53.223]                     }
[16:21:53.223]                     invisible(muffled)
[16:21:53.223]                   }
[16:21:53.223]                   muffleCondition(cond)
[16:21:53.223]                 })
[16:21:53.223]             }))
[16:21:53.223]             future::FutureResult(value = ...future.value$value, 
[16:21:53.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.223]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.223]                     ...future.globalenv.names))
[16:21:53.223]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.223]         }, condition = base::local({
[16:21:53.223]             c <- base::c
[16:21:53.223]             inherits <- base::inherits
[16:21:53.223]             invokeRestart <- base::invokeRestart
[16:21:53.223]             length <- base::length
[16:21:53.223]             list <- base::list
[16:21:53.223]             seq.int <- base::seq.int
[16:21:53.223]             signalCondition <- base::signalCondition
[16:21:53.223]             sys.calls <- base::sys.calls
[16:21:53.223]             `[[` <- base::`[[`
[16:21:53.223]             `+` <- base::`+`
[16:21:53.223]             `<<-` <- base::`<<-`
[16:21:53.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.223]                   3L)]
[16:21:53.223]             }
[16:21:53.223]             function(cond) {
[16:21:53.223]                 is_error <- inherits(cond, "error")
[16:21:53.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.223]                   NULL)
[16:21:53.223]                 if (is_error) {
[16:21:53.223]                   sessionInformation <- function() {
[16:21:53.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.223]                       search = base::search(), system = base::Sys.info())
[16:21:53.223]                   }
[16:21:53.223]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.223]                     cond$call), session = sessionInformation(), 
[16:21:53.223]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.223]                   signalCondition(cond)
[16:21:53.223]                 }
[16:21:53.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.223]                 "immediateCondition"))) {
[16:21:53.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.223]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.223]                   if (TRUE && !signal) {
[16:21:53.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.223]                     {
[16:21:53.223]                       inherits <- base::inherits
[16:21:53.223]                       invokeRestart <- base::invokeRestart
[16:21:53.223]                       is.null <- base::is.null
[16:21:53.223]                       muffled <- FALSE
[16:21:53.223]                       if (inherits(cond, "message")) {
[16:21:53.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.223]                         if (muffled) 
[16:21:53.223]                           invokeRestart("muffleMessage")
[16:21:53.223]                       }
[16:21:53.223]                       else if (inherits(cond, "warning")) {
[16:21:53.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.223]                         if (muffled) 
[16:21:53.223]                           invokeRestart("muffleWarning")
[16:21:53.223]                       }
[16:21:53.223]                       else if (inherits(cond, "condition")) {
[16:21:53.223]                         if (!is.null(pattern)) {
[16:21:53.223]                           computeRestarts <- base::computeRestarts
[16:21:53.223]                           grepl <- base::grepl
[16:21:53.223]                           restarts <- computeRestarts(cond)
[16:21:53.223]                           for (restart in restarts) {
[16:21:53.223]                             name <- restart$name
[16:21:53.223]                             if (is.null(name)) 
[16:21:53.223]                               next
[16:21:53.223]                             if (!grepl(pattern, name)) 
[16:21:53.223]                               next
[16:21:53.223]                             invokeRestart(restart)
[16:21:53.223]                             muffled <- TRUE
[16:21:53.223]                             break
[16:21:53.223]                           }
[16:21:53.223]                         }
[16:21:53.223]                       }
[16:21:53.223]                       invisible(muffled)
[16:21:53.223]                     }
[16:21:53.223]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.223]                   }
[16:21:53.223]                 }
[16:21:53.223]                 else {
[16:21:53.223]                   if (TRUE) {
[16:21:53.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.223]                     {
[16:21:53.223]                       inherits <- base::inherits
[16:21:53.223]                       invokeRestart <- base::invokeRestart
[16:21:53.223]                       is.null <- base::is.null
[16:21:53.223]                       muffled <- FALSE
[16:21:53.223]                       if (inherits(cond, "message")) {
[16:21:53.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.223]                         if (muffled) 
[16:21:53.223]                           invokeRestart("muffleMessage")
[16:21:53.223]                       }
[16:21:53.223]                       else if (inherits(cond, "warning")) {
[16:21:53.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.223]                         if (muffled) 
[16:21:53.223]                           invokeRestart("muffleWarning")
[16:21:53.223]                       }
[16:21:53.223]                       else if (inherits(cond, "condition")) {
[16:21:53.223]                         if (!is.null(pattern)) {
[16:21:53.223]                           computeRestarts <- base::computeRestarts
[16:21:53.223]                           grepl <- base::grepl
[16:21:53.223]                           restarts <- computeRestarts(cond)
[16:21:53.223]                           for (restart in restarts) {
[16:21:53.223]                             name <- restart$name
[16:21:53.223]                             if (is.null(name)) 
[16:21:53.223]                               next
[16:21:53.223]                             if (!grepl(pattern, name)) 
[16:21:53.223]                               next
[16:21:53.223]                             invokeRestart(restart)
[16:21:53.223]                             muffled <- TRUE
[16:21:53.223]                             break
[16:21:53.223]                           }
[16:21:53.223]                         }
[16:21:53.223]                       }
[16:21:53.223]                       invisible(muffled)
[16:21:53.223]                     }
[16:21:53.223]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.223]                   }
[16:21:53.223]                 }
[16:21:53.223]             }
[16:21:53.223]         }))
[16:21:53.223]     }, error = function(ex) {
[16:21:53.223]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.223]                 ...future.rng), started = ...future.startTime, 
[16:21:53.223]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.223]             version = "1.8"), class = "FutureResult")
[16:21:53.223]     }, finally = {
[16:21:53.223]         if (!identical(...future.workdir, getwd())) 
[16:21:53.223]             setwd(...future.workdir)
[16:21:53.223]         {
[16:21:53.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.223]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.223]             }
[16:21:53.223]             base::options(...future.oldOptions)
[16:21:53.223]             if (.Platform$OS.type == "windows") {
[16:21:53.223]                 old_names <- names(...future.oldEnvVars)
[16:21:53.223]                 envs <- base::Sys.getenv()
[16:21:53.223]                 names <- names(envs)
[16:21:53.223]                 common <- intersect(names, old_names)
[16:21:53.223]                 added <- setdiff(names, old_names)
[16:21:53.223]                 removed <- setdiff(old_names, names)
[16:21:53.223]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.223]                   envs[common]]
[16:21:53.223]                 NAMES <- toupper(changed)
[16:21:53.223]                 args <- list()
[16:21:53.223]                 for (kk in seq_along(NAMES)) {
[16:21:53.223]                   name <- changed[[kk]]
[16:21:53.223]                   NAME <- NAMES[[kk]]
[16:21:53.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.223]                     next
[16:21:53.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.223]                 }
[16:21:53.223]                 NAMES <- toupper(added)
[16:21:53.223]                 for (kk in seq_along(NAMES)) {
[16:21:53.223]                   name <- added[[kk]]
[16:21:53.223]                   NAME <- NAMES[[kk]]
[16:21:53.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.223]                     next
[16:21:53.223]                   args[[name]] <- ""
[16:21:53.223]                 }
[16:21:53.223]                 NAMES <- toupper(removed)
[16:21:53.223]                 for (kk in seq_along(NAMES)) {
[16:21:53.223]                   name <- removed[[kk]]
[16:21:53.223]                   NAME <- NAMES[[kk]]
[16:21:53.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.223]                     next
[16:21:53.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.223]                 }
[16:21:53.223]                 if (length(args) > 0) 
[16:21:53.223]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.223]             }
[16:21:53.223]             else {
[16:21:53.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.223]             }
[16:21:53.223]             {
[16:21:53.223]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.223]                   0L) {
[16:21:53.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.223]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.223]                   base::options(opts)
[16:21:53.223]                 }
[16:21:53.223]                 {
[16:21:53.223]                   {
[16:21:53.223]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.223]                     NULL
[16:21:53.223]                   }
[16:21:53.223]                   options(future.plan = NULL)
[16:21:53.223]                   if (is.na(NA_character_)) 
[16:21:53.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.223]                     .init = FALSE)
[16:21:53.223]                 }
[16:21:53.223]             }
[16:21:53.223]         }
[16:21:53.223]     })
[16:21:53.223]     if (TRUE) {
[16:21:53.223]         base::sink(type = "output", split = FALSE)
[16:21:53.223]         if (TRUE) {
[16:21:53.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.223]         }
[16:21:53.223]         else {
[16:21:53.223]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.223]         }
[16:21:53.223]         base::close(...future.stdout)
[16:21:53.223]         ...future.stdout <- NULL
[16:21:53.223]     }
[16:21:53.223]     ...future.result$conditions <- ...future.conditions
[16:21:53.223]     ...future.result$finished <- base::Sys.time()
[16:21:53.223]     ...future.result
[16:21:53.223] }
[16:21:53.226] requestCore(): workers = 2
[16:21:53.226] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.237] result() for MulticoreFuture ...
[16:21:53.238] result() for MulticoreFuture ...
[16:21:53.238] result() for MulticoreFuture ... done
[16:21:53.239] result() for MulticoreFuture ... done
[16:21:53.239] result() for MulticoreFuture ...
[16:21:53.239] result() for MulticoreFuture ... done
[16:21:53.242] MulticoreFuture started
[16:21:53.242] - Launch lazy future ... done
[16:21:53.242] run() for ‘MulticoreFuture’ ... done
[16:21:53.243] plan(): Setting new future strategy stack:
[16:21:53.244] resolve() on list environment ...
[16:21:53.243] List of future strategies:
[16:21:53.243] 1. sequential:
[16:21:53.243]    - args: function (..., envir = parent.frame())
[16:21:53.243]    - tweaked: FALSE
[16:21:53.243]    - call: NULL
[16:21:53.244]  recursive: 0
[16:21:53.244] plan(): nbrOfWorkers() = 1
[16:21:53.245]  length: 3
[16:21:53.245]  elements: ‘a’, ‘b’, ‘c’
[16:21:53.245] Future #1
[16:21:53.246]  length: 2 (resolved future 1)
[16:21:53.246] plan(): Setting new future strategy stack:
[16:21:53.246] List of future strategies:
[16:21:53.246] 1. multicore:
[16:21:53.246]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.246]    - tweaked: FALSE
[16:21:53.246]    - call: plan(strategy)
[16:21:53.256]  length: 1 (resolved future 3)
[16:21:53.256] plan(): nbrOfWorkers() = 2
[16:21:53.267] Future #2
[16:21:53.271]  length: 0 (resolved future 2)
[16:21:53.271] resolve() on list environment ... DONE
[16:21:53.273] getGlobalsAndPackages() ...
[16:21:53.273] Searching for globals...
[16:21:53.275] - globals found: [1] ‘{’
[16:21:53.276] Searching for globals ... DONE
[16:21:53.276] Resolving globals: FALSE
[16:21:53.276] 
[16:21:53.277] 
[16:21:53.277] getGlobalsAndPackages() ... DONE
[16:21:53.277] run() for ‘Future’ ...
[16:21:53.278] - state: ‘created’
[16:21:53.278] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.283]   - Field: ‘label’
[16:21:53.283]   - Field: ‘local’
[16:21:53.283]   - Field: ‘owner’
[16:21:53.284]   - Field: ‘envir’
[16:21:53.284]   - Field: ‘workers’
[16:21:53.284]   - Field: ‘packages’
[16:21:53.284]   - Field: ‘gc’
[16:21:53.284]   - Field: ‘job’
[16:21:53.285]   - Field: ‘conditions’
[16:21:53.285]   - Field: ‘expr’
[16:21:53.285]   - Field: ‘uuid’
[16:21:53.285]   - Field: ‘seed’
[16:21:53.285]   - Field: ‘version’
[16:21:53.285]   - Field: ‘result’
[16:21:53.285]   - Field: ‘asynchronous’
[16:21:53.286]   - Field: ‘calls’
[16:21:53.286]   - Field: ‘globals’
[16:21:53.286]   - Field: ‘stdout’
[16:21:53.286]   - Field: ‘earlySignal’
[16:21:53.286]   - Field: ‘lazy’
[16:21:53.286]   - Field: ‘state’
[16:21:53.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.287] - Launch lazy future ...
[16:21:53.287] Packages needed by the future expression (n = 0): <none>
[16:21:53.287] Packages needed by future strategies (n = 0): <none>
[16:21:53.288] {
[16:21:53.288]     {
[16:21:53.288]         {
[16:21:53.288]             ...future.startTime <- base::Sys.time()
[16:21:53.288]             {
[16:21:53.288]                 {
[16:21:53.288]                   {
[16:21:53.288]                     {
[16:21:53.288]                       base::local({
[16:21:53.288]                         has_future <- base::requireNamespace("future", 
[16:21:53.288]                           quietly = TRUE)
[16:21:53.288]                         if (has_future) {
[16:21:53.288]                           ns <- base::getNamespace("future")
[16:21:53.288]                           version <- ns[[".package"]][["version"]]
[16:21:53.288]                           if (is.null(version)) 
[16:21:53.288]                             version <- utils::packageVersion("future")
[16:21:53.288]                         }
[16:21:53.288]                         else {
[16:21:53.288]                           version <- NULL
[16:21:53.288]                         }
[16:21:53.288]                         if (!has_future || version < "1.8.0") {
[16:21:53.288]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.288]                             "", base::R.version$version.string), 
[16:21:53.288]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.288]                               "release", "version")], collapse = " "), 
[16:21:53.288]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.288]                             info)
[16:21:53.288]                           info <- base::paste(info, collapse = "; ")
[16:21:53.288]                           if (!has_future) {
[16:21:53.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.288]                               info)
[16:21:53.288]                           }
[16:21:53.288]                           else {
[16:21:53.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.288]                               info, version)
[16:21:53.288]                           }
[16:21:53.288]                           base::stop(msg)
[16:21:53.288]                         }
[16:21:53.288]                       })
[16:21:53.288]                     }
[16:21:53.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.288]                     base::options(mc.cores = 1L)
[16:21:53.288]                   }
[16:21:53.288]                   ...future.strategy.old <- future::plan("list")
[16:21:53.288]                   options(future.plan = NULL)
[16:21:53.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.288]                 }
[16:21:53.288]                 ...future.workdir <- getwd()
[16:21:53.288]             }
[16:21:53.288]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.288]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.288]         }
[16:21:53.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.288]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.288]             base::names(...future.oldOptions))
[16:21:53.288]     }
[16:21:53.288]     if (FALSE) {
[16:21:53.288]     }
[16:21:53.288]     else {
[16:21:53.288]         if (TRUE) {
[16:21:53.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.288]                 open = "w")
[16:21:53.288]         }
[16:21:53.288]         else {
[16:21:53.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.288]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.288]         }
[16:21:53.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.288]             base::sink(type = "output", split = FALSE)
[16:21:53.288]             base::close(...future.stdout)
[16:21:53.288]         }, add = TRUE)
[16:21:53.288]     }
[16:21:53.288]     ...future.frame <- base::sys.nframe()
[16:21:53.288]     ...future.conditions <- base::list()
[16:21:53.288]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.288]     if (FALSE) {
[16:21:53.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.288]     }
[16:21:53.288]     ...future.result <- base::tryCatch({
[16:21:53.288]         base::withCallingHandlers({
[16:21:53.288]             ...future.value <- base::withVisible(base::local({
[16:21:53.288]                 withCallingHandlers({
[16:21:53.288]                   {
[16:21:53.288]                     1
[16:21:53.288]                   }
[16:21:53.288]                 }, immediateCondition = function(cond) {
[16:21:53.288]                   save_rds <- function (object, pathname, ...) 
[16:21:53.288]                   {
[16:21:53.288]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.288]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.288]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.288]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.288]                         fi_tmp[["mtime"]])
[16:21:53.288]                     }
[16:21:53.288]                     tryCatch({
[16:21:53.288]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.288]                     }, error = function(ex) {
[16:21:53.288]                       msg <- conditionMessage(ex)
[16:21:53.288]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.288]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.288]                         fi_tmp[["mtime"]], msg)
[16:21:53.288]                       ex$message <- msg
[16:21:53.288]                       stop(ex)
[16:21:53.288]                     })
[16:21:53.288]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.288]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.288]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.288]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.288]                       fi <- file.info(pathname)
[16:21:53.288]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.288]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.288]                         fi[["size"]], fi[["mtime"]])
[16:21:53.288]                       stop(msg)
[16:21:53.288]                     }
[16:21:53.288]                     invisible(pathname)
[16:21:53.288]                   }
[16:21:53.288]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.288]                     rootPath = tempdir()) 
[16:21:53.288]                   {
[16:21:53.288]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.288]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.288]                       tmpdir = path, fileext = ".rds")
[16:21:53.288]                     save_rds(obj, file)
[16:21:53.288]                   }
[16:21:53.288]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.288]                   {
[16:21:53.288]                     inherits <- base::inherits
[16:21:53.288]                     invokeRestart <- base::invokeRestart
[16:21:53.288]                     is.null <- base::is.null
[16:21:53.288]                     muffled <- FALSE
[16:21:53.288]                     if (inherits(cond, "message")) {
[16:21:53.288]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.288]                       if (muffled) 
[16:21:53.288]                         invokeRestart("muffleMessage")
[16:21:53.288]                     }
[16:21:53.288]                     else if (inherits(cond, "warning")) {
[16:21:53.288]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.288]                       if (muffled) 
[16:21:53.288]                         invokeRestart("muffleWarning")
[16:21:53.288]                     }
[16:21:53.288]                     else if (inherits(cond, "condition")) {
[16:21:53.288]                       if (!is.null(pattern)) {
[16:21:53.288]                         computeRestarts <- base::computeRestarts
[16:21:53.288]                         grepl <- base::grepl
[16:21:53.288]                         restarts <- computeRestarts(cond)
[16:21:53.288]                         for (restart in restarts) {
[16:21:53.288]                           name <- restart$name
[16:21:53.288]                           if (is.null(name)) 
[16:21:53.288]                             next
[16:21:53.288]                           if (!grepl(pattern, name)) 
[16:21:53.288]                             next
[16:21:53.288]                           invokeRestart(restart)
[16:21:53.288]                           muffled <- TRUE
[16:21:53.288]                           break
[16:21:53.288]                         }
[16:21:53.288]                       }
[16:21:53.288]                     }
[16:21:53.288]                     invisible(muffled)
[16:21:53.288]                   }
[16:21:53.288]                   muffleCondition(cond)
[16:21:53.288]                 })
[16:21:53.288]             }))
[16:21:53.288]             future::FutureResult(value = ...future.value$value, 
[16:21:53.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.288]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.288]                     ...future.globalenv.names))
[16:21:53.288]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.288]         }, condition = base::local({
[16:21:53.288]             c <- base::c
[16:21:53.288]             inherits <- base::inherits
[16:21:53.288]             invokeRestart <- base::invokeRestart
[16:21:53.288]             length <- base::length
[16:21:53.288]             list <- base::list
[16:21:53.288]             seq.int <- base::seq.int
[16:21:53.288]             signalCondition <- base::signalCondition
[16:21:53.288]             sys.calls <- base::sys.calls
[16:21:53.288]             `[[` <- base::`[[`
[16:21:53.288]             `+` <- base::`+`
[16:21:53.288]             `<<-` <- base::`<<-`
[16:21:53.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.288]                   3L)]
[16:21:53.288]             }
[16:21:53.288]             function(cond) {
[16:21:53.288]                 is_error <- inherits(cond, "error")
[16:21:53.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.288]                   NULL)
[16:21:53.288]                 if (is_error) {
[16:21:53.288]                   sessionInformation <- function() {
[16:21:53.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.288]                       search = base::search(), system = base::Sys.info())
[16:21:53.288]                   }
[16:21:53.288]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.288]                     cond$call), session = sessionInformation(), 
[16:21:53.288]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.288]                   signalCondition(cond)
[16:21:53.288]                 }
[16:21:53.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.288]                 "immediateCondition"))) {
[16:21:53.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.288]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.288]                   if (TRUE && !signal) {
[16:21:53.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.288]                     {
[16:21:53.288]                       inherits <- base::inherits
[16:21:53.288]                       invokeRestart <- base::invokeRestart
[16:21:53.288]                       is.null <- base::is.null
[16:21:53.288]                       muffled <- FALSE
[16:21:53.288]                       if (inherits(cond, "message")) {
[16:21:53.288]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.288]                         if (muffled) 
[16:21:53.288]                           invokeRestart("muffleMessage")
[16:21:53.288]                       }
[16:21:53.288]                       else if (inherits(cond, "warning")) {
[16:21:53.288]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.288]                         if (muffled) 
[16:21:53.288]                           invokeRestart("muffleWarning")
[16:21:53.288]                       }
[16:21:53.288]                       else if (inherits(cond, "condition")) {
[16:21:53.288]                         if (!is.null(pattern)) {
[16:21:53.288]                           computeRestarts <- base::computeRestarts
[16:21:53.288]                           grepl <- base::grepl
[16:21:53.288]                           restarts <- computeRestarts(cond)
[16:21:53.288]                           for (restart in restarts) {
[16:21:53.288]                             name <- restart$name
[16:21:53.288]                             if (is.null(name)) 
[16:21:53.288]                               next
[16:21:53.288]                             if (!grepl(pattern, name)) 
[16:21:53.288]                               next
[16:21:53.288]                             invokeRestart(restart)
[16:21:53.288]                             muffled <- TRUE
[16:21:53.288]                             break
[16:21:53.288]                           }
[16:21:53.288]                         }
[16:21:53.288]                       }
[16:21:53.288]                       invisible(muffled)
[16:21:53.288]                     }
[16:21:53.288]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.288]                   }
[16:21:53.288]                 }
[16:21:53.288]                 else {
[16:21:53.288]                   if (TRUE) {
[16:21:53.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.288]                     {
[16:21:53.288]                       inherits <- base::inherits
[16:21:53.288]                       invokeRestart <- base::invokeRestart
[16:21:53.288]                       is.null <- base::is.null
[16:21:53.288]                       muffled <- FALSE
[16:21:53.288]                       if (inherits(cond, "message")) {
[16:21:53.288]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.288]                         if (muffled) 
[16:21:53.288]                           invokeRestart("muffleMessage")
[16:21:53.288]                       }
[16:21:53.288]                       else if (inherits(cond, "warning")) {
[16:21:53.288]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.288]                         if (muffled) 
[16:21:53.288]                           invokeRestart("muffleWarning")
[16:21:53.288]                       }
[16:21:53.288]                       else if (inherits(cond, "condition")) {
[16:21:53.288]                         if (!is.null(pattern)) {
[16:21:53.288]                           computeRestarts <- base::computeRestarts
[16:21:53.288]                           grepl <- base::grepl
[16:21:53.288]                           restarts <- computeRestarts(cond)
[16:21:53.288]                           for (restart in restarts) {
[16:21:53.288]                             name <- restart$name
[16:21:53.288]                             if (is.null(name)) 
[16:21:53.288]                               next
[16:21:53.288]                             if (!grepl(pattern, name)) 
[16:21:53.288]                               next
[16:21:53.288]                             invokeRestart(restart)
[16:21:53.288]                             muffled <- TRUE
[16:21:53.288]                             break
[16:21:53.288]                           }
[16:21:53.288]                         }
[16:21:53.288]                       }
[16:21:53.288]                       invisible(muffled)
[16:21:53.288]                     }
[16:21:53.288]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.288]                   }
[16:21:53.288]                 }
[16:21:53.288]             }
[16:21:53.288]         }))
[16:21:53.288]     }, error = function(ex) {
[16:21:53.288]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.288]                 ...future.rng), started = ...future.startTime, 
[16:21:53.288]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.288]             version = "1.8"), class = "FutureResult")
[16:21:53.288]     }, finally = {
[16:21:53.288]         if (!identical(...future.workdir, getwd())) 
[16:21:53.288]             setwd(...future.workdir)
[16:21:53.288]         {
[16:21:53.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.288]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.288]             }
[16:21:53.288]             base::options(...future.oldOptions)
[16:21:53.288]             if (.Platform$OS.type == "windows") {
[16:21:53.288]                 old_names <- names(...future.oldEnvVars)
[16:21:53.288]                 envs <- base::Sys.getenv()
[16:21:53.288]                 names <- names(envs)
[16:21:53.288]                 common <- intersect(names, old_names)
[16:21:53.288]                 added <- setdiff(names, old_names)
[16:21:53.288]                 removed <- setdiff(old_names, names)
[16:21:53.288]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.288]                   envs[common]]
[16:21:53.288]                 NAMES <- toupper(changed)
[16:21:53.288]                 args <- list()
[16:21:53.288]                 for (kk in seq_along(NAMES)) {
[16:21:53.288]                   name <- changed[[kk]]
[16:21:53.288]                   NAME <- NAMES[[kk]]
[16:21:53.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.288]                     next
[16:21:53.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.288]                 }
[16:21:53.288]                 NAMES <- toupper(added)
[16:21:53.288]                 for (kk in seq_along(NAMES)) {
[16:21:53.288]                   name <- added[[kk]]
[16:21:53.288]                   NAME <- NAMES[[kk]]
[16:21:53.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.288]                     next
[16:21:53.288]                   args[[name]] <- ""
[16:21:53.288]                 }
[16:21:53.288]                 NAMES <- toupper(removed)
[16:21:53.288]                 for (kk in seq_along(NAMES)) {
[16:21:53.288]                   name <- removed[[kk]]
[16:21:53.288]                   NAME <- NAMES[[kk]]
[16:21:53.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.288]                     next
[16:21:53.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.288]                 }
[16:21:53.288]                 if (length(args) > 0) 
[16:21:53.288]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.288]             }
[16:21:53.288]             else {
[16:21:53.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.288]             }
[16:21:53.288]             {
[16:21:53.288]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.288]                   0L) {
[16:21:53.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.288]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.288]                   base::options(opts)
[16:21:53.288]                 }
[16:21:53.288]                 {
[16:21:53.288]                   {
[16:21:53.288]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.288]                     NULL
[16:21:53.288]                   }
[16:21:53.288]                   options(future.plan = NULL)
[16:21:53.288]                   if (is.na(NA_character_)) 
[16:21:53.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.288]                     .init = FALSE)
[16:21:53.288]                 }
[16:21:53.288]             }
[16:21:53.288]         }
[16:21:53.288]     })
[16:21:53.288]     if (TRUE) {
[16:21:53.288]         base::sink(type = "output", split = FALSE)
[16:21:53.288]         if (TRUE) {
[16:21:53.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.288]         }
[16:21:53.288]         else {
[16:21:53.288]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.288]         }
[16:21:53.288]         base::close(...future.stdout)
[16:21:53.288]         ...future.stdout <- NULL
[16:21:53.288]     }
[16:21:53.288]     ...future.result$conditions <- ...future.conditions
[16:21:53.288]     ...future.result$finished <- base::Sys.time()
[16:21:53.288]     ...future.result
[16:21:53.288] }
[16:21:53.290] requestCore(): workers = 2
[16:21:53.291] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.301] result() for MulticoreFuture ...
[16:21:53.302] result() for MulticoreFuture ...
[16:21:53.302] result() for MulticoreFuture ... done
[16:21:53.302] result() for MulticoreFuture ... done
[16:21:53.303] result() for MulticoreFuture ...
[16:21:53.303] result() for MulticoreFuture ... done
[16:21:53.305] MulticoreFuture started
[16:21:53.305] - Launch lazy future ... done
[16:21:53.306] run() for ‘MulticoreFuture’ ... done
[16:21:53.306] plan(): Setting new future strategy stack:
[16:21:53.307] getGlobalsAndPackages() ...
[16:21:53.307] Searching for globals...
[16:21:53.307] List of future strategies:
[16:21:53.307] 1. sequential:
[16:21:53.307]    - args: function (..., envir = parent.frame())
[16:21:53.307]    - tweaked: FALSE
[16:21:53.307]    - call: NULL
[16:21:53.308] plan(): nbrOfWorkers() = 1
[16:21:53.310] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:21:53.311] Searching for globals ... DONE
[16:21:53.311] plan(): Setting new future strategy stack:
[16:21:53.311] Resolving globals: FALSE
[16:21:53.311] List of future strategies:
[16:21:53.311] 1. multicore:
[16:21:53.311]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.311]    - tweaked: FALSE
[16:21:53.311]    - call: plan(strategy)
[16:21:53.312] 
[16:21:53.312] 
[16:21:53.312] getGlobalsAndPackages() ... DONE
[16:21:53.313] run() for ‘Future’ ...
[16:21:53.313] - state: ‘created’
[16:21:53.314] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.317] plan(): nbrOfWorkers() = 2
[16:21:53.318] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.319]   - Field: ‘label’
[16:21:53.319]   - Field: ‘local’
[16:21:53.319]   - Field: ‘owner’
[16:21:53.319]   - Field: ‘envir’
[16:21:53.319]   - Field: ‘workers’
[16:21:53.319]   - Field: ‘packages’
[16:21:53.320]   - Field: ‘gc’
[16:21:53.320]   - Field: ‘job’
[16:21:53.320]   - Field: ‘conditions’
[16:21:53.320]   - Field: ‘expr’
[16:21:53.320]   - Field: ‘uuid’
[16:21:53.320]   - Field: ‘seed’
[16:21:53.320]   - Field: ‘version’
[16:21:53.321]   - Field: ‘result’
[16:21:53.321]   - Field: ‘asynchronous’
[16:21:53.321]   - Field: ‘calls’
[16:21:53.321]   - Field: ‘globals’
[16:21:53.321]   - Field: ‘stdout’
[16:21:53.321]   - Field: ‘earlySignal’
[16:21:53.321]   - Field: ‘lazy’
[16:21:53.322]   - Field: ‘state’
[16:21:53.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.322] - Launch lazy future ...
[16:21:53.322] Packages needed by the future expression (n = 0): <none>
[16:21:53.322] Packages needed by future strategies (n = 0): <none>
[16:21:53.323] {
[16:21:53.323]     {
[16:21:53.323]         {
[16:21:53.323]             ...future.startTime <- base::Sys.time()
[16:21:53.323]             {
[16:21:53.323]                 {
[16:21:53.323]                   {
[16:21:53.323]                     {
[16:21:53.323]                       base::local({
[16:21:53.323]                         has_future <- base::requireNamespace("future", 
[16:21:53.323]                           quietly = TRUE)
[16:21:53.323]                         if (has_future) {
[16:21:53.323]                           ns <- base::getNamespace("future")
[16:21:53.323]                           version <- ns[[".package"]][["version"]]
[16:21:53.323]                           if (is.null(version)) 
[16:21:53.323]                             version <- utils::packageVersion("future")
[16:21:53.323]                         }
[16:21:53.323]                         else {
[16:21:53.323]                           version <- NULL
[16:21:53.323]                         }
[16:21:53.323]                         if (!has_future || version < "1.8.0") {
[16:21:53.323]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.323]                             "", base::R.version$version.string), 
[16:21:53.323]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.323]                               "release", "version")], collapse = " "), 
[16:21:53.323]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.323]                             info)
[16:21:53.323]                           info <- base::paste(info, collapse = "; ")
[16:21:53.323]                           if (!has_future) {
[16:21:53.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.323]                               info)
[16:21:53.323]                           }
[16:21:53.323]                           else {
[16:21:53.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.323]                               info, version)
[16:21:53.323]                           }
[16:21:53.323]                           base::stop(msg)
[16:21:53.323]                         }
[16:21:53.323]                       })
[16:21:53.323]                     }
[16:21:53.323]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.323]                     base::options(mc.cores = 1L)
[16:21:53.323]                   }
[16:21:53.323]                   ...future.strategy.old <- future::plan("list")
[16:21:53.323]                   options(future.plan = NULL)
[16:21:53.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.323]                 }
[16:21:53.323]                 ...future.workdir <- getwd()
[16:21:53.323]             }
[16:21:53.323]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.323]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.323]         }
[16:21:53.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.323]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.323]             base::names(...future.oldOptions))
[16:21:53.323]     }
[16:21:53.323]     if (FALSE) {
[16:21:53.323]     }
[16:21:53.323]     else {
[16:21:53.323]         if (TRUE) {
[16:21:53.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.323]                 open = "w")
[16:21:53.323]         }
[16:21:53.323]         else {
[16:21:53.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.323]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.323]         }
[16:21:53.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.323]             base::sink(type = "output", split = FALSE)
[16:21:53.323]             base::close(...future.stdout)
[16:21:53.323]         }, add = TRUE)
[16:21:53.323]     }
[16:21:53.323]     ...future.frame <- base::sys.nframe()
[16:21:53.323]     ...future.conditions <- base::list()
[16:21:53.323]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.323]     if (FALSE) {
[16:21:53.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.323]     }
[16:21:53.323]     ...future.result <- base::tryCatch({
[16:21:53.323]         base::withCallingHandlers({
[16:21:53.323]             ...future.value <- base::withVisible(base::local({
[16:21:53.323]                 withCallingHandlers({
[16:21:53.323]                   {
[16:21:53.323]                     Sys.sleep(0.5)
[16:21:53.323]                     2
[16:21:53.323]                   }
[16:21:53.323]                 }, immediateCondition = function(cond) {
[16:21:53.323]                   save_rds <- function (object, pathname, ...) 
[16:21:53.323]                   {
[16:21:53.323]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.323]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.323]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.323]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.323]                         fi_tmp[["mtime"]])
[16:21:53.323]                     }
[16:21:53.323]                     tryCatch({
[16:21:53.323]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.323]                     }, error = function(ex) {
[16:21:53.323]                       msg <- conditionMessage(ex)
[16:21:53.323]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.323]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.323]                         fi_tmp[["mtime"]], msg)
[16:21:53.323]                       ex$message <- msg
[16:21:53.323]                       stop(ex)
[16:21:53.323]                     })
[16:21:53.323]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.323]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.323]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.323]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.323]                       fi <- file.info(pathname)
[16:21:53.323]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.323]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.323]                         fi[["size"]], fi[["mtime"]])
[16:21:53.323]                       stop(msg)
[16:21:53.323]                     }
[16:21:53.323]                     invisible(pathname)
[16:21:53.323]                   }
[16:21:53.323]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.323]                     rootPath = tempdir()) 
[16:21:53.323]                   {
[16:21:53.323]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.323]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.323]                       tmpdir = path, fileext = ".rds")
[16:21:53.323]                     save_rds(obj, file)
[16:21:53.323]                   }
[16:21:53.323]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.323]                   {
[16:21:53.323]                     inherits <- base::inherits
[16:21:53.323]                     invokeRestart <- base::invokeRestart
[16:21:53.323]                     is.null <- base::is.null
[16:21:53.323]                     muffled <- FALSE
[16:21:53.323]                     if (inherits(cond, "message")) {
[16:21:53.323]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.323]                       if (muffled) 
[16:21:53.323]                         invokeRestart("muffleMessage")
[16:21:53.323]                     }
[16:21:53.323]                     else if (inherits(cond, "warning")) {
[16:21:53.323]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.323]                       if (muffled) 
[16:21:53.323]                         invokeRestart("muffleWarning")
[16:21:53.323]                     }
[16:21:53.323]                     else if (inherits(cond, "condition")) {
[16:21:53.323]                       if (!is.null(pattern)) {
[16:21:53.323]                         computeRestarts <- base::computeRestarts
[16:21:53.323]                         grepl <- base::grepl
[16:21:53.323]                         restarts <- computeRestarts(cond)
[16:21:53.323]                         for (restart in restarts) {
[16:21:53.323]                           name <- restart$name
[16:21:53.323]                           if (is.null(name)) 
[16:21:53.323]                             next
[16:21:53.323]                           if (!grepl(pattern, name)) 
[16:21:53.323]                             next
[16:21:53.323]                           invokeRestart(restart)
[16:21:53.323]                           muffled <- TRUE
[16:21:53.323]                           break
[16:21:53.323]                         }
[16:21:53.323]                       }
[16:21:53.323]                     }
[16:21:53.323]                     invisible(muffled)
[16:21:53.323]                   }
[16:21:53.323]                   muffleCondition(cond)
[16:21:53.323]                 })
[16:21:53.323]             }))
[16:21:53.323]             future::FutureResult(value = ...future.value$value, 
[16:21:53.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.323]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.323]                     ...future.globalenv.names))
[16:21:53.323]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.323]         }, condition = base::local({
[16:21:53.323]             c <- base::c
[16:21:53.323]             inherits <- base::inherits
[16:21:53.323]             invokeRestart <- base::invokeRestart
[16:21:53.323]             length <- base::length
[16:21:53.323]             list <- base::list
[16:21:53.323]             seq.int <- base::seq.int
[16:21:53.323]             signalCondition <- base::signalCondition
[16:21:53.323]             sys.calls <- base::sys.calls
[16:21:53.323]             `[[` <- base::`[[`
[16:21:53.323]             `+` <- base::`+`
[16:21:53.323]             `<<-` <- base::`<<-`
[16:21:53.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.323]                   3L)]
[16:21:53.323]             }
[16:21:53.323]             function(cond) {
[16:21:53.323]                 is_error <- inherits(cond, "error")
[16:21:53.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.323]                   NULL)
[16:21:53.323]                 if (is_error) {
[16:21:53.323]                   sessionInformation <- function() {
[16:21:53.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.323]                       search = base::search(), system = base::Sys.info())
[16:21:53.323]                   }
[16:21:53.323]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.323]                     cond$call), session = sessionInformation(), 
[16:21:53.323]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.323]                   signalCondition(cond)
[16:21:53.323]                 }
[16:21:53.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.323]                 "immediateCondition"))) {
[16:21:53.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.323]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.323]                   if (TRUE && !signal) {
[16:21:53.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.323]                     {
[16:21:53.323]                       inherits <- base::inherits
[16:21:53.323]                       invokeRestart <- base::invokeRestart
[16:21:53.323]                       is.null <- base::is.null
[16:21:53.323]                       muffled <- FALSE
[16:21:53.323]                       if (inherits(cond, "message")) {
[16:21:53.323]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.323]                         if (muffled) 
[16:21:53.323]                           invokeRestart("muffleMessage")
[16:21:53.323]                       }
[16:21:53.323]                       else if (inherits(cond, "warning")) {
[16:21:53.323]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.323]                         if (muffled) 
[16:21:53.323]                           invokeRestart("muffleWarning")
[16:21:53.323]                       }
[16:21:53.323]                       else if (inherits(cond, "condition")) {
[16:21:53.323]                         if (!is.null(pattern)) {
[16:21:53.323]                           computeRestarts <- base::computeRestarts
[16:21:53.323]                           grepl <- base::grepl
[16:21:53.323]                           restarts <- computeRestarts(cond)
[16:21:53.323]                           for (restart in restarts) {
[16:21:53.323]                             name <- restart$name
[16:21:53.323]                             if (is.null(name)) 
[16:21:53.323]                               next
[16:21:53.323]                             if (!grepl(pattern, name)) 
[16:21:53.323]                               next
[16:21:53.323]                             invokeRestart(restart)
[16:21:53.323]                             muffled <- TRUE
[16:21:53.323]                             break
[16:21:53.323]                           }
[16:21:53.323]                         }
[16:21:53.323]                       }
[16:21:53.323]                       invisible(muffled)
[16:21:53.323]                     }
[16:21:53.323]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.323]                   }
[16:21:53.323]                 }
[16:21:53.323]                 else {
[16:21:53.323]                   if (TRUE) {
[16:21:53.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.323]                     {
[16:21:53.323]                       inherits <- base::inherits
[16:21:53.323]                       invokeRestart <- base::invokeRestart
[16:21:53.323]                       is.null <- base::is.null
[16:21:53.323]                       muffled <- FALSE
[16:21:53.323]                       if (inherits(cond, "message")) {
[16:21:53.323]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.323]                         if (muffled) 
[16:21:53.323]                           invokeRestart("muffleMessage")
[16:21:53.323]                       }
[16:21:53.323]                       else if (inherits(cond, "warning")) {
[16:21:53.323]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.323]                         if (muffled) 
[16:21:53.323]                           invokeRestart("muffleWarning")
[16:21:53.323]                       }
[16:21:53.323]                       else if (inherits(cond, "condition")) {
[16:21:53.323]                         if (!is.null(pattern)) {
[16:21:53.323]                           computeRestarts <- base::computeRestarts
[16:21:53.323]                           grepl <- base::grepl
[16:21:53.323]                           restarts <- computeRestarts(cond)
[16:21:53.323]                           for (restart in restarts) {
[16:21:53.323]                             name <- restart$name
[16:21:53.323]                             if (is.null(name)) 
[16:21:53.323]                               next
[16:21:53.323]                             if (!grepl(pattern, name)) 
[16:21:53.323]                               next
[16:21:53.323]                             invokeRestart(restart)
[16:21:53.323]                             muffled <- TRUE
[16:21:53.323]                             break
[16:21:53.323]                           }
[16:21:53.323]                         }
[16:21:53.323]                       }
[16:21:53.323]                       invisible(muffled)
[16:21:53.323]                     }
[16:21:53.323]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.323]                   }
[16:21:53.323]                 }
[16:21:53.323]             }
[16:21:53.323]         }))
[16:21:53.323]     }, error = function(ex) {
[16:21:53.323]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.323]                 ...future.rng), started = ...future.startTime, 
[16:21:53.323]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.323]             version = "1.8"), class = "FutureResult")
[16:21:53.323]     }, finally = {
[16:21:53.323]         if (!identical(...future.workdir, getwd())) 
[16:21:53.323]             setwd(...future.workdir)
[16:21:53.323]         {
[16:21:53.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.323]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.323]             }
[16:21:53.323]             base::options(...future.oldOptions)
[16:21:53.323]             if (.Platform$OS.type == "windows") {
[16:21:53.323]                 old_names <- names(...future.oldEnvVars)
[16:21:53.323]                 envs <- base::Sys.getenv()
[16:21:53.323]                 names <- names(envs)
[16:21:53.323]                 common <- intersect(names, old_names)
[16:21:53.323]                 added <- setdiff(names, old_names)
[16:21:53.323]                 removed <- setdiff(old_names, names)
[16:21:53.323]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.323]                   envs[common]]
[16:21:53.323]                 NAMES <- toupper(changed)
[16:21:53.323]                 args <- list()
[16:21:53.323]                 for (kk in seq_along(NAMES)) {
[16:21:53.323]                   name <- changed[[kk]]
[16:21:53.323]                   NAME <- NAMES[[kk]]
[16:21:53.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.323]                     next
[16:21:53.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.323]                 }
[16:21:53.323]                 NAMES <- toupper(added)
[16:21:53.323]                 for (kk in seq_along(NAMES)) {
[16:21:53.323]                   name <- added[[kk]]
[16:21:53.323]                   NAME <- NAMES[[kk]]
[16:21:53.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.323]                     next
[16:21:53.323]                   args[[name]] <- ""
[16:21:53.323]                 }
[16:21:53.323]                 NAMES <- toupper(removed)
[16:21:53.323]                 for (kk in seq_along(NAMES)) {
[16:21:53.323]                   name <- removed[[kk]]
[16:21:53.323]                   NAME <- NAMES[[kk]]
[16:21:53.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.323]                     next
[16:21:53.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.323]                 }
[16:21:53.323]                 if (length(args) > 0) 
[16:21:53.323]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.323]             }
[16:21:53.323]             else {
[16:21:53.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.323]             }
[16:21:53.323]             {
[16:21:53.323]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.323]                   0L) {
[16:21:53.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.323]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.323]                   base::options(opts)
[16:21:53.323]                 }
[16:21:53.323]                 {
[16:21:53.323]                   {
[16:21:53.323]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.323]                     NULL
[16:21:53.323]                   }
[16:21:53.323]                   options(future.plan = NULL)
[16:21:53.323]                   if (is.na(NA_character_)) 
[16:21:53.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.323]                     .init = FALSE)
[16:21:53.323]                 }
[16:21:53.323]             }
[16:21:53.323]         }
[16:21:53.323]     })
[16:21:53.323]     if (TRUE) {
[16:21:53.323]         base::sink(type = "output", split = FALSE)
[16:21:53.323]         if (TRUE) {
[16:21:53.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.323]         }
[16:21:53.323]         else {
[16:21:53.323]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.323]         }
[16:21:53.323]         base::close(...future.stdout)
[16:21:53.323]         ...future.stdout <- NULL
[16:21:53.323]     }
[16:21:53.323]     ...future.result$conditions <- ...future.conditions
[16:21:53.323]     ...future.result$finished <- base::Sys.time()
[16:21:53.323]     ...future.result
[16:21:53.323] }
[16:21:53.327] requestCore(): workers = 2
[16:21:53.327] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.338] result() for MulticoreFuture ...
[16:21:53.339] result() for MulticoreFuture ...
[16:21:53.339] result() for MulticoreFuture ... done
[16:21:53.339] result() for MulticoreFuture ... done
[16:21:53.339] result() for MulticoreFuture ...
[16:21:53.339] result() for MulticoreFuture ... done
[16:21:53.341] MulticoreFuture started
[16:21:53.342] - Launch lazy future ... done
[16:21:53.342] run() for ‘MulticoreFuture’ ... done
[16:21:53.343] plan(): Setting new future strategy stack:
[16:21:53.343] getGlobalsAndPackages() ...
[16:21:53.344] Searching for globals...
[16:21:53.343] List of future strategies:
[16:21:53.343] 1. sequential:
[16:21:53.343]    - args: function (..., envir = parent.frame())
[16:21:53.343]    - tweaked: FALSE
[16:21:53.343]    - call: NULL
[16:21:53.344] plan(): nbrOfWorkers() = 1
[16:21:53.346] - globals found: [1] ‘{’
[16:21:53.346] Searching for globals ... DONE
[16:21:53.346] Resolving globals: FALSE
[16:21:53.347] 
[16:21:53.347] 
[16:21:53.347] getGlobalsAndPackages() ... DONE
[16:21:53.348] run() for ‘Future’ ...
[16:21:53.348] - state: ‘created’
[16:21:53.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:21:53.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:53.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:21:53.361]   - Field: ‘label’
[16:21:53.361]   - Field: ‘local’
[16:21:53.362]   - Field: ‘owner’
[16:21:53.362]   - Field: ‘envir’
[16:21:53.362]   - Field: ‘workers’
[16:21:53.363]   - Field: ‘packages’
[16:21:53.363]   - Field: ‘gc’
[16:21:53.364]   - Field: ‘job’
[16:21:53.364]   - Field: ‘conditions’
[16:21:53.365]   - Field: ‘expr’
[16:21:53.365]   - Field: ‘uuid’
[16:21:53.365]   - Field: ‘seed’
[16:21:53.366]   - Field: ‘version’
[16:21:53.366]   - Field: ‘result’
[16:21:53.366]   - Field: ‘asynchronous’
[16:21:53.366]   - Field: ‘calls’
[16:21:53.367]   - Field: ‘globals’
[16:21:53.367]   - Field: ‘stdout’
[16:21:53.367]   - Field: ‘earlySignal’
[16:21:53.367]   - Field: ‘lazy’
[16:21:53.368]   - Field: ‘state’
[16:21:53.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:21:53.368] - Launch lazy future ...
[16:21:53.369] Packages needed by the future expression (n = 0): <none>
[16:21:53.369] Packages needed by future strategies (n = 0): <none>
[16:21:53.370] {
[16:21:53.370]     {
[16:21:53.370]         {
[16:21:53.370]             ...future.startTime <- base::Sys.time()
[16:21:53.370]             {
[16:21:53.370]                 {
[16:21:53.370]                   {
[16:21:53.370]                     {
[16:21:53.370]                       base::local({
[16:21:53.370]                         has_future <- base::requireNamespace("future", 
[16:21:53.370]                           quietly = TRUE)
[16:21:53.370]                         if (has_future) {
[16:21:53.370]                           ns <- base::getNamespace("future")
[16:21:53.370]                           version <- ns[[".package"]][["version"]]
[16:21:53.370]                           if (is.null(version)) 
[16:21:53.370]                             version <- utils::packageVersion("future")
[16:21:53.370]                         }
[16:21:53.370]                         else {
[16:21:53.370]                           version <- NULL
[16:21:53.370]                         }
[16:21:53.370]                         if (!has_future || version < "1.8.0") {
[16:21:53.370]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:53.370]                             "", base::R.version$version.string), 
[16:21:53.370]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:53.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:53.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:53.370]                               "release", "version")], collapse = " "), 
[16:21:53.370]                             hostname = base::Sys.info()[["nodename"]])
[16:21:53.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:53.370]                             info)
[16:21:53.370]                           info <- base::paste(info, collapse = "; ")
[16:21:53.370]                           if (!has_future) {
[16:21:53.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:53.370]                               info)
[16:21:53.370]                           }
[16:21:53.370]                           else {
[16:21:53.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:53.370]                               info, version)
[16:21:53.370]                           }
[16:21:53.370]                           base::stop(msg)
[16:21:53.370]                         }
[16:21:53.370]                       })
[16:21:53.370]                     }
[16:21:53.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:53.370]                     base::options(mc.cores = 1L)
[16:21:53.370]                   }
[16:21:53.370]                   ...future.strategy.old <- future::plan("list")
[16:21:53.370]                   options(future.plan = NULL)
[16:21:53.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:53.370]                 }
[16:21:53.370]                 ...future.workdir <- getwd()
[16:21:53.370]             }
[16:21:53.370]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:53.370]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:53.370]         }
[16:21:53.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:53.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:53.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:53.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:53.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:53.370]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:53.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:53.370]             base::names(...future.oldOptions))
[16:21:53.370]     }
[16:21:53.370]     if (FALSE) {
[16:21:53.370]     }
[16:21:53.370]     else {
[16:21:53.370]         if (TRUE) {
[16:21:53.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:53.370]                 open = "w")
[16:21:53.370]         }
[16:21:53.370]         else {
[16:21:53.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:53.370]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:53.370]         }
[16:21:53.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:53.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:53.370]             base::sink(type = "output", split = FALSE)
[16:21:53.370]             base::close(...future.stdout)
[16:21:53.370]         }, add = TRUE)
[16:21:53.370]     }
[16:21:53.370]     ...future.frame <- base::sys.nframe()
[16:21:53.370]     ...future.conditions <- base::list()
[16:21:53.370]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:53.370]     if (FALSE) {
[16:21:53.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:53.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:53.370]     }
[16:21:53.370]     ...future.result <- base::tryCatch({
[16:21:53.370]         base::withCallingHandlers({
[16:21:53.370]             ...future.value <- base::withVisible(base::local({
[16:21:53.370]                 withCallingHandlers({
[16:21:53.370]                   {
[16:21:53.370]                     3
[16:21:53.370]                   }
[16:21:53.370]                 }, immediateCondition = function(cond) {
[16:21:53.370]                   save_rds <- function (object, pathname, ...) 
[16:21:53.370]                   {
[16:21:53.370]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:21:53.370]                     if (file_test("-f", pathname_tmp)) {
[16:21:53.370]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.370]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:21:53.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.370]                         fi_tmp[["mtime"]])
[16:21:53.370]                     }
[16:21:53.370]                     tryCatch({
[16:21:53.370]                       saveRDS(object, file = pathname_tmp, ...)
[16:21:53.370]                     }, error = function(ex) {
[16:21:53.370]                       msg <- conditionMessage(ex)
[16:21:53.370]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.370]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:21:53.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.370]                         fi_tmp[["mtime"]], msg)
[16:21:53.370]                       ex$message <- msg
[16:21:53.370]                       stop(ex)
[16:21:53.370]                     })
[16:21:53.370]                     stopifnot(file_test("-f", pathname_tmp))
[16:21:53.370]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:21:53.370]                     if (!res || file_test("-f", pathname_tmp)) {
[16:21:53.370]                       fi_tmp <- file.info(pathname_tmp)
[16:21:53.370]                       fi <- file.info(pathname)
[16:21:53.370]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:21:53.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:21:53.370]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:21:53.370]                         fi[["size"]], fi[["mtime"]])
[16:21:53.370]                       stop(msg)
[16:21:53.370]                     }
[16:21:53.370]                     invisible(pathname)
[16:21:53.370]                   }
[16:21:53.370]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:21:53.370]                     rootPath = tempdir()) 
[16:21:53.370]                   {
[16:21:53.370]                     obj <- list(time = Sys.time(), condition = cond)
[16:21:53.370]                     file <- tempfile(pattern = class(cond)[1], 
[16:21:53.370]                       tmpdir = path, fileext = ".rds")
[16:21:53.370]                     save_rds(obj, file)
[16:21:53.370]                   }
[16:21:53.370]                   saveImmediateCondition(cond, path = "/tmp/Rtmp79OOvS/.future/immediateConditions")
[16:21:53.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.370]                   {
[16:21:53.370]                     inherits <- base::inherits
[16:21:53.370]                     invokeRestart <- base::invokeRestart
[16:21:53.370]                     is.null <- base::is.null
[16:21:53.370]                     muffled <- FALSE
[16:21:53.370]                     if (inherits(cond, "message")) {
[16:21:53.370]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:53.370]                       if (muffled) 
[16:21:53.370]                         invokeRestart("muffleMessage")
[16:21:53.370]                     }
[16:21:53.370]                     else if (inherits(cond, "warning")) {
[16:21:53.370]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:53.370]                       if (muffled) 
[16:21:53.370]                         invokeRestart("muffleWarning")
[16:21:53.370]                     }
[16:21:53.370]                     else if (inherits(cond, "condition")) {
[16:21:53.370]                       if (!is.null(pattern)) {
[16:21:53.370]                         computeRestarts <- base::computeRestarts
[16:21:53.370]                         grepl <- base::grepl
[16:21:53.370]                         restarts <- computeRestarts(cond)
[16:21:53.370]                         for (restart in restarts) {
[16:21:53.370]                           name <- restart$name
[16:21:53.370]                           if (is.null(name)) 
[16:21:53.370]                             next
[16:21:53.370]                           if (!grepl(pattern, name)) 
[16:21:53.370]                             next
[16:21:53.370]                           invokeRestart(restart)
[16:21:53.370]                           muffled <- TRUE
[16:21:53.370]                           break
[16:21:53.370]                         }
[16:21:53.370]                       }
[16:21:53.370]                     }
[16:21:53.370]                     invisible(muffled)
[16:21:53.370]                   }
[16:21:53.370]                   muffleCondition(cond)
[16:21:53.370]                 })
[16:21:53.370]             }))
[16:21:53.370]             future::FutureResult(value = ...future.value$value, 
[16:21:53.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.370]                   ...future.rng), globalenv = if (FALSE) 
[16:21:53.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:53.370]                     ...future.globalenv.names))
[16:21:53.370]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:53.370]         }, condition = base::local({
[16:21:53.370]             c <- base::c
[16:21:53.370]             inherits <- base::inherits
[16:21:53.370]             invokeRestart <- base::invokeRestart
[16:21:53.370]             length <- base::length
[16:21:53.370]             list <- base::list
[16:21:53.370]             seq.int <- base::seq.int
[16:21:53.370]             signalCondition <- base::signalCondition
[16:21:53.370]             sys.calls <- base::sys.calls
[16:21:53.370]             `[[` <- base::`[[`
[16:21:53.370]             `+` <- base::`+`
[16:21:53.370]             `<<-` <- base::`<<-`
[16:21:53.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:53.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:53.370]                   3L)]
[16:21:53.370]             }
[16:21:53.370]             function(cond) {
[16:21:53.370]                 is_error <- inherits(cond, "error")
[16:21:53.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:53.370]                   NULL)
[16:21:53.370]                 if (is_error) {
[16:21:53.370]                   sessionInformation <- function() {
[16:21:53.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:53.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:53.370]                       search = base::search(), system = base::Sys.info())
[16:21:53.370]                   }
[16:21:53.370]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:53.370]                     cond$call), session = sessionInformation(), 
[16:21:53.370]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:53.370]                   signalCondition(cond)
[16:21:53.370]                 }
[16:21:53.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:53.370]                 "immediateCondition"))) {
[16:21:53.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:53.370]                   ...future.conditions[[length(...future.conditions) + 
[16:21:53.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:53.370]                   if (TRUE && !signal) {
[16:21:53.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.370]                     {
[16:21:53.370]                       inherits <- base::inherits
[16:21:53.370]                       invokeRestart <- base::invokeRestart
[16:21:53.370]                       is.null <- base::is.null
[16:21:53.370]                       muffled <- FALSE
[16:21:53.370]                       if (inherits(cond, "message")) {
[16:21:53.370]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.370]                         if (muffled) 
[16:21:53.370]                           invokeRestart("muffleMessage")
[16:21:53.370]                       }
[16:21:53.370]                       else if (inherits(cond, "warning")) {
[16:21:53.370]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.370]                         if (muffled) 
[16:21:53.370]                           invokeRestart("muffleWarning")
[16:21:53.370]                       }
[16:21:53.370]                       else if (inherits(cond, "condition")) {
[16:21:53.370]                         if (!is.null(pattern)) {
[16:21:53.370]                           computeRestarts <- base::computeRestarts
[16:21:53.370]                           grepl <- base::grepl
[16:21:53.370]                           restarts <- computeRestarts(cond)
[16:21:53.370]                           for (restart in restarts) {
[16:21:53.370]                             name <- restart$name
[16:21:53.370]                             if (is.null(name)) 
[16:21:53.370]                               next
[16:21:53.370]                             if (!grepl(pattern, name)) 
[16:21:53.370]                               next
[16:21:53.370]                             invokeRestart(restart)
[16:21:53.370]                             muffled <- TRUE
[16:21:53.370]                             break
[16:21:53.370]                           }
[16:21:53.370]                         }
[16:21:53.370]                       }
[16:21:53.370]                       invisible(muffled)
[16:21:53.370]                     }
[16:21:53.370]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.370]                   }
[16:21:53.370]                 }
[16:21:53.370]                 else {
[16:21:53.370]                   if (TRUE) {
[16:21:53.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:53.370]                     {
[16:21:53.370]                       inherits <- base::inherits
[16:21:53.370]                       invokeRestart <- base::invokeRestart
[16:21:53.370]                       is.null <- base::is.null
[16:21:53.370]                       muffled <- FALSE
[16:21:53.370]                       if (inherits(cond, "message")) {
[16:21:53.370]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:53.370]                         if (muffled) 
[16:21:53.370]                           invokeRestart("muffleMessage")
[16:21:53.370]                       }
[16:21:53.370]                       else if (inherits(cond, "warning")) {
[16:21:53.370]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:53.370]                         if (muffled) 
[16:21:53.370]                           invokeRestart("muffleWarning")
[16:21:53.370]                       }
[16:21:53.370]                       else if (inherits(cond, "condition")) {
[16:21:53.370]                         if (!is.null(pattern)) {
[16:21:53.370]                           computeRestarts <- base::computeRestarts
[16:21:53.370]                           grepl <- base::grepl
[16:21:53.370]                           restarts <- computeRestarts(cond)
[16:21:53.370]                           for (restart in restarts) {
[16:21:53.370]                             name <- restart$name
[16:21:53.370]                             if (is.null(name)) 
[16:21:53.370]                               next
[16:21:53.370]                             if (!grepl(pattern, name)) 
[16:21:53.370]                               next
[16:21:53.370]                             invokeRestart(restart)
[16:21:53.370]                             muffled <- TRUE
[16:21:53.370]                             break
[16:21:53.370]                           }
[16:21:53.370]                         }
[16:21:53.370]                       }
[16:21:53.370]                       invisible(muffled)
[16:21:53.370]                     }
[16:21:53.370]                     muffleCondition(cond, pattern = "^muffle")
[16:21:53.370]                   }
[16:21:53.370]                 }
[16:21:53.370]             }
[16:21:53.370]         }))
[16:21:53.370]     }, error = function(ex) {
[16:21:53.370]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:53.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:53.370]                 ...future.rng), started = ...future.startTime, 
[16:21:53.370]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:53.370]             version = "1.8"), class = "FutureResult")
[16:21:53.370]     }, finally = {
[16:21:53.370]         if (!identical(...future.workdir, getwd())) 
[16:21:53.370]             setwd(...future.workdir)
[16:21:53.370]         {
[16:21:53.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:53.370]                 ...future.oldOptions$nwarnings <- NULL
[16:21:53.370]             }
[16:21:53.370]             base::options(...future.oldOptions)
[16:21:53.370]             if (.Platform$OS.type == "windows") {
[16:21:53.370]                 old_names <- names(...future.oldEnvVars)
[16:21:53.370]                 envs <- base::Sys.getenv()
[16:21:53.370]                 names <- names(envs)
[16:21:53.370]                 common <- intersect(names, old_names)
[16:21:53.370]                 added <- setdiff(names, old_names)
[16:21:53.370]                 removed <- setdiff(old_names, names)
[16:21:53.370]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:53.370]                   envs[common]]
[16:21:53.370]                 NAMES <- toupper(changed)
[16:21:53.370]                 args <- list()
[16:21:53.370]                 for (kk in seq_along(NAMES)) {
[16:21:53.370]                   name <- changed[[kk]]
[16:21:53.370]                   NAME <- NAMES[[kk]]
[16:21:53.370]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.370]                     next
[16:21:53.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.370]                 }
[16:21:53.370]                 NAMES <- toupper(added)
[16:21:53.370]                 for (kk in seq_along(NAMES)) {
[16:21:53.370]                   name <- added[[kk]]
[16:21:53.370]                   NAME <- NAMES[[kk]]
[16:21:53.370]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.370]                     next
[16:21:53.370]                   args[[name]] <- ""
[16:21:53.370]                 }
[16:21:53.370]                 NAMES <- toupper(removed)
[16:21:53.370]                 for (kk in seq_along(NAMES)) {
[16:21:53.370]                   name <- removed[[kk]]
[16:21:53.370]                   NAME <- NAMES[[kk]]
[16:21:53.370]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:53.370]                     next
[16:21:53.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:53.370]                 }
[16:21:53.370]                 if (length(args) > 0) 
[16:21:53.370]                   base::do.call(base::Sys.setenv, args = args)
[16:21:53.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:53.370]             }
[16:21:53.370]             else {
[16:21:53.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:53.370]             }
[16:21:53.370]             {
[16:21:53.370]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:53.370]                   0L) {
[16:21:53.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:53.370]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:53.370]                   base::options(opts)
[16:21:53.370]                 }
[16:21:53.370]                 {
[16:21:53.370]                   {
[16:21:53.370]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:53.370]                     NULL
[16:21:53.370]                   }
[16:21:53.370]                   options(future.plan = NULL)
[16:21:53.370]                   if (is.na(NA_character_)) 
[16:21:53.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:53.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:53.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:53.370]                     .init = FALSE)
[16:21:53.370]                 }
[16:21:53.370]             }
[16:21:53.370]         }
[16:21:53.370]     })
[16:21:53.370]     if (TRUE) {
[16:21:53.370]         base::sink(type = "output", split = FALSE)
[16:21:53.370]         if (TRUE) {
[16:21:53.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:53.370]         }
[16:21:53.370]         else {
[16:21:53.370]             ...future.result["stdout"] <- base::list(NULL)
[16:21:53.370]         }
[16:21:53.370]         base::close(...future.stdout)
[16:21:53.370]         ...future.stdout <- NULL
[16:21:53.370]     }
[16:21:53.370]     ...future.result$conditions <- ...future.conditions
[16:21:53.370]     ...future.result$finished <- base::Sys.time()
[16:21:53.370]     ...future.result
[16:21:53.370] }
[16:21:53.373] requestCore(): workers = 2
[16:21:53.373] Poll #1 (0): usedCores() = 2, workers = 2
[16:21:53.384] result() for MulticoreFuture ...
[16:21:53.387] result() for MulticoreFuture ...
[16:21:53.388] result() for MulticoreFuture ... done
[16:21:53.388] result() for MulticoreFuture ... done
[16:21:53.388] result() for MulticoreFuture ...
[16:21:53.388] result() for MulticoreFuture ... done
[16:21:53.391] MulticoreFuture started
[16:21:53.392] - Launch lazy future ... done
[16:21:53.398] plan(): Setting new future strategy stack:
[16:21:53.392] run() for ‘MulticoreFuture’ ... done
[16:21:53.399] List of future strategies:
[16:21:53.399] 1. sequential:
[16:21:53.399]    - args: function (..., envir = parent.frame())
[16:21:53.399]    - tweaked: FALSE
[16:21:53.399]    - call: NULL
[16:21:53.400] plan(): nbrOfWorkers() = 1
[16:21:53.401] resolve() on list environment ...
[16:21:53.401]  recursive: 0
[16:21:53.403] plan(): Setting new future strategy stack:
[16:21:53.403]  length: 4
[16:21:53.404]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:53.404] Future #1
[16:21:53.403] List of future strategies:
[16:21:53.403] 1. multicore:
[16:21:53.403]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.403]    - tweaked: FALSE
[16:21:53.403]    - call: plan(strategy)
[16:21:53.404]  length: 3 (resolved future 1)
[16:21:53.409] plan(): nbrOfWorkers() = 2
[16:21:53.415] Future #3
[16:21:53.415]  length: 2 (resolved future 3)
[16:21:53.416]  length: 1 (resolved future 4)
[16:21:53.848] plan(): Setting new future strategy stack:
[16:21:53.848] List of future strategies:
[16:21:53.848] 1. multicore:
[16:21:53.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:21:53.848]    - tweaked: FALSE
[16:21:53.848]    - call: plan(strategy)
[16:21:53.853] plan(): nbrOfWorkers() = 2
[16:21:53.855] Future #2
[16:21:53.855]  length: 0 (resolved future 2)
[16:21:53.856] resolve() on list environment ... DONE
[16:21:53.856] resolve() on list environment ...
[16:21:53.856]  recursive: 0
[16:21:53.858]  length: 4
[16:21:53.858]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:53.858] Future #1
[16:21:53.858]  length: 3 (resolved future 1)
[16:21:53.858] Future #2
[16:21:53.859]  length: 2 (resolved future 2)
[16:21:53.859] Future #3
[16:21:53.859]  length: 1 (resolved future 3)
[16:21:53.859]  length: 0 (resolved future 4)
[16:21:53.859] resolve() on list environment ... DONE
[16:21:53.860] resolve() on list environment ...
[16:21:53.861]  recursive: 0
[16:21:53.862]  length: 4
[16:21:53.862]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:53.862] Future #1
[16:21:53.862]  length: 3 (resolved future 1)
[16:21:53.862] Future #2
[16:21:53.863]  length: 2 (resolved future 2)
[16:21:53.863] Future #3
[16:21:53.863]  length: 1 (resolved future 3)
[16:21:53.863]  length: 0 (resolved future 4)
[16:21:53.863] resolve() on list environment ... DONE
[16:21:53.864] resolve() on list environment ...
[16:21:53.864]  recursive: 0
[16:21:53.865]  length: 4
[16:21:53.865]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:53.865] Future #1
[16:21:53.865]  length: 3 (resolved future 1)
[16:21:53.866] Future #2
[16:21:53.866]  length: 2 (resolved future 2)
[16:21:53.866] Future #3
[16:21:53.866]  length: 1 (resolved future 3)
[16:21:53.867]  length: 0 (resolved future 4)
[16:21:53.867] resolve() on list environment ... DONE
[16:21:53.867] resolve() on list environment ...
[16:21:53.868]  recursive: 0
[16:21:53.868]  length: 4
[16:21:53.869]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:53.869] Future #1
[16:21:53.869] result() for MulticoreFuture ...
[16:21:53.869] result() for MulticoreFuture ... done
[16:21:53.869] result() for MulticoreFuture ...
[16:21:53.869] result() for MulticoreFuture ... done
[16:21:53.870]  length: 3 (resolved future 1)
[16:21:53.870] Future #2
[16:21:53.870] result() for MulticoreFuture ...
[16:21:53.871] result() for MulticoreFuture ...
[16:21:53.871] result() for MulticoreFuture ... done
[16:21:53.871] result() for MulticoreFuture ... done
[16:21:53.871] result() for MulticoreFuture ...
[16:21:53.872] result() for MulticoreFuture ... done
[16:21:53.872]  length: 2 (resolved future 2)
[16:21:53.872] Future #3
[16:21:53.872] result() for MulticoreFuture ...
[16:21:53.873] result() for MulticoreFuture ...
[16:21:53.876] result() for MulticoreFuture ... done
[16:21:53.877] result() for MulticoreFuture ... done
[16:21:53.877] result() for MulticoreFuture ...
[16:21:53.877] result() for MulticoreFuture ... done
[16:21:53.877]  length: 1 (resolved future 3)
[16:21:53.877]  length: 0 (resolved future 4)
[16:21:53.878] resolve() on list environment ... DONE
[16:21:53.878] resolve() on list environment ...
[16:21:53.879]  recursive: 99
[16:21:53.879]  length: 4
[16:21:53.879]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:21:53.880] Future #1
[16:21:53.880] result() for MulticoreFuture ...
[16:21:53.880] result() for MulticoreFuture ... done
[16:21:53.880] result() for MulticoreFuture ...
[16:21:53.880] result() for MulticoreFuture ... done
[16:21:53.880] A MulticoreFuture was resolved
[16:21:53.880]  length: 3 (resolved future 1)
[16:21:53.881] Future #2
[16:21:53.881] result() for MulticoreFuture ...
[16:21:53.881] result() for MulticoreFuture ... done
[16:21:53.881] result() for MulticoreFuture ...
[16:21:53.881] result() for MulticoreFuture ... done
[16:21:53.881] A MulticoreFuture was resolved
[16:21:53.881]  length: 2 (resolved future 2)
[16:21:53.882] Future #3
[16:21:53.882] result() for MulticoreFuture ...
[16:21:53.882] result() for MulticoreFuture ... done
[16:21:53.882] result() for MulticoreFuture ...
[16:21:53.882] result() for MulticoreFuture ... done
[16:21:53.882] A MulticoreFuture was resolved
[16:21:53.882]  length: 1 (resolved future 3)
[16:21:53.883]  length: 0 (resolved future 4)
[16:21:53.883] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[16:21:53.883] plan(): Setting new future strategy stack:
[16:21:53.884] List of future strategies:
[16:21:53.884] 1. multisession:
[16:21:53.884]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:53.884]    - tweaked: FALSE
[16:21:53.884]    - call: plan(strategy)
[16:21:53.884] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:21:53.884] multisession:
[16:21:53.884] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:21:53.884] - tweaked: FALSE
[16:21:53.884] - call: plan(strategy)
[16:21:53.890] getGlobalsAndPackages() ...
[16:21:53.891] Not searching for globals
[16:21:53.891] - globals: [0] <none>
[16:21:53.891] getGlobalsAndPackages() ... DONE
[16:21:53.891] [local output] makeClusterPSOCK() ...
[16:21:53.936] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:21:53.938] [local output] Base port: 11758
[16:21:53.938] [local output] Getting setup options for 2 cluster nodes ...
[16:21:53.938] [local output]  - Node 1 of 2 ...
[16:21:53.938] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:53.939] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp79OOvS/worker.rank=1.parallelly.parent=88155.1585b51eb8d8a.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp79OOvS/worker.rank=1.parallelly.parent=88155.1585b51eb8d8a.pid")'’
[16:21:54.128] - Possible to infer worker's PID: TRUE
[16:21:54.129] [local output] Rscript port: 11758

[16:21:54.129] [local output]  - Node 2 of 2 ...
[16:21:54.130] [local output] localMachine=TRUE => revtunnel=FALSE

[16:21:54.130] [local output] Rscript port: 11758

[16:21:54.130] [local output] Getting setup options for 2 cluster nodes ... done
[16:21:54.131] [local output]  - Parallel setup requested for some PSOCK nodes
[16:21:54.131] [local output] Setting up PSOCK nodes in parallel
[16:21:54.131] List of 36
[16:21:54.131]  $ worker          : chr "localhost"
[16:21:54.131]   ..- attr(*, "localhost")= logi TRUE
[16:21:54.131]  $ master          : chr "localhost"
[16:21:54.131]  $ port            : int 11758
[16:21:54.131]  $ connectTimeout  : num 120
[16:21:54.131]  $ timeout         : num 2592000
[16:21:54.131]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:21:54.131]  $ homogeneous     : logi TRUE
[16:21:54.131]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:21:54.131]  $ rscript_envs    : NULL
[16:21:54.131]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:54.131]  $ rscript_startup : NULL
[16:21:54.131]  $ rscript_sh      : chr "sh"
[16:21:54.131]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:54.131]  $ methods         : logi TRUE
[16:21:54.131]  $ socketOptions   : chr "no-delay"
[16:21:54.131]  $ useXDR          : logi FALSE
[16:21:54.131]  $ outfile         : chr "/dev/null"
[16:21:54.131]  $ renice          : int NA
[16:21:54.131]  $ rshcmd          : NULL
[16:21:54.131]  $ user            : chr(0) 
[16:21:54.131]  $ revtunnel       : logi FALSE
[16:21:54.131]  $ rshlogfile      : NULL
[16:21:54.131]  $ rshopts         : chr(0) 
[16:21:54.131]  $ rank            : int 1
[16:21:54.131]  $ manual          : logi FALSE
[16:21:54.131]  $ dryrun          : logi FALSE
[16:21:54.131]  $ quiet           : logi FALSE
[16:21:54.131]  $ setup_strategy  : chr "parallel"
[16:21:54.131]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:54.131]  $ pidfile         : chr "/tmp/Rtmp79OOvS/worker.rank=1.parallelly.parent=88155.1585b51eb8d8a.pid"
[16:21:54.131]  $ rshcmd_label    : NULL
[16:21:54.131]  $ rsh_call        : NULL
[16:21:54.131]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:21:54.131]  $ localMachine    : logi TRUE
[16:21:54.131]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:21:54.131]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:21:54.131]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:21:54.131]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:21:54.131]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:21:54.131]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:21:54.131]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:21:54.131]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:21:54.131]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:21:54.131]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:21:54.131]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:21:54.131]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:21:54.131]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:21:54.131]  $ arguments       :List of 28
[16:21:54.131]   ..$ worker          : chr "localhost"
[16:21:54.131]   ..$ master          : NULL
[16:21:54.131]   ..$ port            : int 11758
[16:21:54.131]   ..$ connectTimeout  : num 120
[16:21:54.131]   ..$ timeout         : num 2592000
[16:21:54.131]   ..$ rscript         : NULL
[16:21:54.131]   ..$ homogeneous     : NULL
[16:21:54.131]   ..$ rscript_args    : NULL
[16:21:54.131]   ..$ rscript_envs    : NULL
[16:21:54.131]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:21:54.131]   ..$ rscript_startup : NULL
[16:21:54.131]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:21:54.131]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:21:54.131]   ..$ methods         : logi TRUE
[16:21:54.131]   ..$ socketOptions   : chr "no-delay"
[16:21:54.131]   ..$ useXDR          : logi FALSE
[16:21:54.131]   ..$ outfile         : chr "/dev/null"
[16:21:54.131]   ..$ renice          : int NA
[16:21:54.131]   ..$ rshcmd          : NULL
[16:21:54.131]   ..$ user            : NULL
[16:21:54.131]   ..$ revtunnel       : logi NA
[16:21:54.131]   ..$ rshlogfile      : NULL
[16:21:54.131]   ..$ rshopts         : NULL
[16:21:54.131]   ..$ rank            : int 1
[16:21:54.131]   ..$ manual          : logi FALSE
[16:21:54.131]   ..$ dryrun          : logi FALSE
[16:21:54.131]   ..$ quiet           : logi FALSE
[16:21:54.131]   ..$ setup_strategy  : chr "parallel"
[16:21:54.131]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:21:54.148] [local output] System call to launch all workers:
[16:21:54.148] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp79OOvS/worker.rank=1.parallelly.parent=88155.1585b51eb8d8a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11758 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:21:54.148] [local output] Starting PSOCK main server
[16:21:54.154] [local output] Workers launched
[16:21:54.154] [local output] Waiting for workers to connect back
[16:21:54.154]  - [local output] 0 workers out of 2 ready
[16:21:54.399]  - [local output] 0 workers out of 2 ready
[16:21:54.399]  - [local output] 1 workers out of 2 ready
[16:21:54.400]  - [local output] 1 workers out of 2 ready
[16:21:54.400]  - [local output] 2 workers out of 2 ready
[16:21:54.400] [local output] Launching of workers completed
[16:21:54.401] [local output] Collecting session information from workers
[16:21:54.401] [local output]  - Worker #1 of 2
[16:21:54.402] [local output]  - Worker #2 of 2
[16:21:54.402] [local output] makeClusterPSOCK() ... done
[16:21:54.413] Packages needed by the future expression (n = 0): <none>
[16:21:54.413] Packages needed by future strategies (n = 0): <none>
[16:21:54.414] {
[16:21:54.414]     {
[16:21:54.414]         {
[16:21:54.414]             ...future.startTime <- base::Sys.time()
[16:21:54.414]             {
[16:21:54.414]                 {
[16:21:54.414]                   {
[16:21:54.414]                     {
[16:21:54.414]                       base::local({
[16:21:54.414]                         has_future <- base::requireNamespace("future", 
[16:21:54.414]                           quietly = TRUE)
[16:21:54.414]                         if (has_future) {
[16:21:54.414]                           ns <- base::getNamespace("future")
[16:21:54.414]                           version <- ns[[".package"]][["version"]]
[16:21:54.414]                           if (is.null(version)) 
[16:21:54.414]                             version <- utils::packageVersion("future")
[16:21:54.414]                         }
[16:21:54.414]                         else {
[16:21:54.414]                           version <- NULL
[16:21:54.414]                         }
[16:21:54.414]                         if (!has_future || version < "1.8.0") {
[16:21:54.414]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:54.414]                             "", base::R.version$version.string), 
[16:21:54.414]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:54.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:54.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:54.414]                               "release", "version")], collapse = " "), 
[16:21:54.414]                             hostname = base::Sys.info()[["nodename"]])
[16:21:54.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:54.414]                             info)
[16:21:54.414]                           info <- base::paste(info, collapse = "; ")
[16:21:54.414]                           if (!has_future) {
[16:21:54.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:54.414]                               info)
[16:21:54.414]                           }
[16:21:54.414]                           else {
[16:21:54.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:54.414]                               info, version)
[16:21:54.414]                           }
[16:21:54.414]                           base::stop(msg)
[16:21:54.414]                         }
[16:21:54.414]                       })
[16:21:54.414]                     }
[16:21:54.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:54.414]                     base::options(mc.cores = 1L)
[16:21:54.414]                   }
[16:21:54.414]                   ...future.strategy.old <- future::plan("list")
[16:21:54.414]                   options(future.plan = NULL)
[16:21:54.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:54.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:54.414]                 }
[16:21:54.414]                 ...future.workdir <- getwd()
[16:21:54.414]             }
[16:21:54.414]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:54.414]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:54.414]         }
[16:21:54.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:54.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:54.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:54.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:54.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:54.414]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:54.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:54.414]             base::names(...future.oldOptions))
[16:21:54.414]     }
[16:21:54.414]     if (FALSE) {
[16:21:54.414]     }
[16:21:54.414]     else {
[16:21:54.414]         if (TRUE) {
[16:21:54.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:54.414]                 open = "w")
[16:21:54.414]         }
[16:21:54.414]         else {
[16:21:54.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:54.414]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:54.414]         }
[16:21:54.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:54.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:54.414]             base::sink(type = "output", split = FALSE)
[16:21:54.414]             base::close(...future.stdout)
[16:21:54.414]         }, add = TRUE)
[16:21:54.414]     }
[16:21:54.414]     ...future.frame <- base::sys.nframe()
[16:21:54.414]     ...future.conditions <- base::list()
[16:21:54.414]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:54.414]     if (FALSE) {
[16:21:54.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:54.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:54.414]     }
[16:21:54.414]     ...future.result <- base::tryCatch({
[16:21:54.414]         base::withCallingHandlers({
[16:21:54.414]             ...future.value <- base::withVisible(base::local({
[16:21:54.414]                 ...future.makeSendCondition <- base::local({
[16:21:54.414]                   sendCondition <- NULL
[16:21:54.414]                   function(frame = 1L) {
[16:21:54.414]                     if (is.function(sendCondition)) 
[16:21:54.414]                       return(sendCondition)
[16:21:54.414]                     ns <- getNamespace("parallel")
[16:21:54.414]                     if (exists("sendData", mode = "function", 
[16:21:54.414]                       envir = ns)) {
[16:21:54.414]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:54.414]                         envir = ns)
[16:21:54.414]                       envir <- sys.frame(frame)
[16:21:54.414]                       master <- NULL
[16:21:54.414]                       while (!identical(envir, .GlobalEnv) && 
[16:21:54.414]                         !identical(envir, emptyenv())) {
[16:21:54.414]                         if (exists("master", mode = "list", envir = envir, 
[16:21:54.414]                           inherits = FALSE)) {
[16:21:54.414]                           master <- get("master", mode = "list", 
[16:21:54.414]                             envir = envir, inherits = FALSE)
[16:21:54.414]                           if (inherits(master, c("SOCKnode", 
[16:21:54.414]                             "SOCK0node"))) {
[16:21:54.414]                             sendCondition <<- function(cond) {
[16:21:54.414]                               data <- list(type = "VALUE", value = cond, 
[16:21:54.414]                                 success = TRUE)
[16:21:54.414]                               parallel_sendData(master, data)
[16:21:54.414]                             }
[16:21:54.414]                             return(sendCondition)
[16:21:54.414]                           }
[16:21:54.414]                         }
[16:21:54.414]                         frame <- frame + 1L
[16:21:54.414]                         envir <- sys.frame(frame)
[16:21:54.414]                       }
[16:21:54.414]                     }
[16:21:54.414]                     sendCondition <<- function(cond) NULL
[16:21:54.414]                   }
[16:21:54.414]                 })
[16:21:54.414]                 withCallingHandlers({
[16:21:54.414]                   NA
[16:21:54.414]                 }, immediateCondition = function(cond) {
[16:21:54.414]                   sendCondition <- ...future.makeSendCondition()
[16:21:54.414]                   sendCondition(cond)
[16:21:54.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:54.414]                   {
[16:21:54.414]                     inherits <- base::inherits
[16:21:54.414]                     invokeRestart <- base::invokeRestart
[16:21:54.414]                     is.null <- base::is.null
[16:21:54.414]                     muffled <- FALSE
[16:21:54.414]                     if (inherits(cond, "message")) {
[16:21:54.414]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:54.414]                       if (muffled) 
[16:21:54.414]                         invokeRestart("muffleMessage")
[16:21:54.414]                     }
[16:21:54.414]                     else if (inherits(cond, "warning")) {
[16:21:54.414]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:54.414]                       if (muffled) 
[16:21:54.414]                         invokeRestart("muffleWarning")
[16:21:54.414]                     }
[16:21:54.414]                     else if (inherits(cond, "condition")) {
[16:21:54.414]                       if (!is.null(pattern)) {
[16:21:54.414]                         computeRestarts <- base::computeRestarts
[16:21:54.414]                         grepl <- base::grepl
[16:21:54.414]                         restarts <- computeRestarts(cond)
[16:21:54.414]                         for (restart in restarts) {
[16:21:54.414]                           name <- restart$name
[16:21:54.414]                           if (is.null(name)) 
[16:21:54.414]                             next
[16:21:54.414]                           if (!grepl(pattern, name)) 
[16:21:54.414]                             next
[16:21:54.414]                           invokeRestart(restart)
[16:21:54.414]                           muffled <- TRUE
[16:21:54.414]                           break
[16:21:54.414]                         }
[16:21:54.414]                       }
[16:21:54.414]                     }
[16:21:54.414]                     invisible(muffled)
[16:21:54.414]                   }
[16:21:54.414]                   muffleCondition(cond)
[16:21:54.414]                 })
[16:21:54.414]             }))
[16:21:54.414]             future::FutureResult(value = ...future.value$value, 
[16:21:54.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:54.414]                   ...future.rng), globalenv = if (FALSE) 
[16:21:54.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:54.414]                     ...future.globalenv.names))
[16:21:54.414]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:54.414]         }, condition = base::local({
[16:21:54.414]             c <- base::c
[16:21:54.414]             inherits <- base::inherits
[16:21:54.414]             invokeRestart <- base::invokeRestart
[16:21:54.414]             length <- base::length
[16:21:54.414]             list <- base::list
[16:21:54.414]             seq.int <- base::seq.int
[16:21:54.414]             signalCondition <- base::signalCondition
[16:21:54.414]             sys.calls <- base::sys.calls
[16:21:54.414]             `[[` <- base::`[[`
[16:21:54.414]             `+` <- base::`+`
[16:21:54.414]             `<<-` <- base::`<<-`
[16:21:54.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:54.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:54.414]                   3L)]
[16:21:54.414]             }
[16:21:54.414]             function(cond) {
[16:21:54.414]                 is_error <- inherits(cond, "error")
[16:21:54.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:54.414]                   NULL)
[16:21:54.414]                 if (is_error) {
[16:21:54.414]                   sessionInformation <- function() {
[16:21:54.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:54.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:54.414]                       search = base::search(), system = base::Sys.info())
[16:21:54.414]                   }
[16:21:54.414]                   ...future.conditions[[length(...future.conditions) + 
[16:21:54.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:54.414]                     cond$call), session = sessionInformation(), 
[16:21:54.414]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:54.414]                   signalCondition(cond)
[16:21:54.414]                 }
[16:21:54.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:54.414]                 "immediateCondition"))) {
[16:21:54.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:54.414]                   ...future.conditions[[length(...future.conditions) + 
[16:21:54.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:54.414]                   if (TRUE && !signal) {
[16:21:54.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:54.414]                     {
[16:21:54.414]                       inherits <- base::inherits
[16:21:54.414]                       invokeRestart <- base::invokeRestart
[16:21:54.414]                       is.null <- base::is.null
[16:21:54.414]                       muffled <- FALSE
[16:21:54.414]                       if (inherits(cond, "message")) {
[16:21:54.414]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:54.414]                         if (muffled) 
[16:21:54.414]                           invokeRestart("muffleMessage")
[16:21:54.414]                       }
[16:21:54.414]                       else if (inherits(cond, "warning")) {
[16:21:54.414]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:54.414]                         if (muffled) 
[16:21:54.414]                           invokeRestart("muffleWarning")
[16:21:54.414]                       }
[16:21:54.414]                       else if (inherits(cond, "condition")) {
[16:21:54.414]                         if (!is.null(pattern)) {
[16:21:54.414]                           computeRestarts <- base::computeRestarts
[16:21:54.414]                           grepl <- base::grepl
[16:21:54.414]                           restarts <- computeRestarts(cond)
[16:21:54.414]                           for (restart in restarts) {
[16:21:54.414]                             name <- restart$name
[16:21:54.414]                             if (is.null(name)) 
[16:21:54.414]                               next
[16:21:54.414]                             if (!grepl(pattern, name)) 
[16:21:54.414]                               next
[16:21:54.414]                             invokeRestart(restart)
[16:21:54.414]                             muffled <- TRUE
[16:21:54.414]                             break
[16:21:54.414]                           }
[16:21:54.414]                         }
[16:21:54.414]                       }
[16:21:54.414]                       invisible(muffled)
[16:21:54.414]                     }
[16:21:54.414]                     muffleCondition(cond, pattern = "^muffle")
[16:21:54.414]                   }
[16:21:54.414]                 }
[16:21:54.414]                 else {
[16:21:54.414]                   if (TRUE) {
[16:21:54.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:54.414]                     {
[16:21:54.414]                       inherits <- base::inherits
[16:21:54.414]                       invokeRestart <- base::invokeRestart
[16:21:54.414]                       is.null <- base::is.null
[16:21:54.414]                       muffled <- FALSE
[16:21:54.414]                       if (inherits(cond, "message")) {
[16:21:54.414]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:54.414]                         if (muffled) 
[16:21:54.414]                           invokeRestart("muffleMessage")
[16:21:54.414]                       }
[16:21:54.414]                       else if (inherits(cond, "warning")) {
[16:21:54.414]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:54.414]                         if (muffled) 
[16:21:54.414]                           invokeRestart("muffleWarning")
[16:21:54.414]                       }
[16:21:54.414]                       else if (inherits(cond, "condition")) {
[16:21:54.414]                         if (!is.null(pattern)) {
[16:21:54.414]                           computeRestarts <- base::computeRestarts
[16:21:54.414]                           grepl <- base::grepl
[16:21:54.414]                           restarts <- computeRestarts(cond)
[16:21:54.414]                           for (restart in restarts) {
[16:21:54.414]                             name <- restart$name
[16:21:54.414]                             if (is.null(name)) 
[16:21:54.414]                               next
[16:21:54.414]                             if (!grepl(pattern, name)) 
[16:21:54.414]                               next
[16:21:54.414]                             invokeRestart(restart)
[16:21:54.414]                             muffled <- TRUE
[16:21:54.414]                             break
[16:21:54.414]                           }
[16:21:54.414]                         }
[16:21:54.414]                       }
[16:21:54.414]                       invisible(muffled)
[16:21:54.414]                     }
[16:21:54.414]                     muffleCondition(cond, pattern = "^muffle")
[16:21:54.414]                   }
[16:21:54.414]                 }
[16:21:54.414]             }
[16:21:54.414]         }))
[16:21:54.414]     }, error = function(ex) {
[16:21:54.414]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:54.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:54.414]                 ...future.rng), started = ...future.startTime, 
[16:21:54.414]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:54.414]             version = "1.8"), class = "FutureResult")
[16:21:54.414]     }, finally = {
[16:21:54.414]         if (!identical(...future.workdir, getwd())) 
[16:21:54.414]             setwd(...future.workdir)
[16:21:54.414]         {
[16:21:54.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:54.414]                 ...future.oldOptions$nwarnings <- NULL
[16:21:54.414]             }
[16:21:54.414]             base::options(...future.oldOptions)
[16:21:54.414]             if (.Platform$OS.type == "windows") {
[16:21:54.414]                 old_names <- names(...future.oldEnvVars)
[16:21:54.414]                 envs <- base::Sys.getenv()
[16:21:54.414]                 names <- names(envs)
[16:21:54.414]                 common <- intersect(names, old_names)
[16:21:54.414]                 added <- setdiff(names, old_names)
[16:21:54.414]                 removed <- setdiff(old_names, names)
[16:21:54.414]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:54.414]                   envs[common]]
[16:21:54.414]                 NAMES <- toupper(changed)
[16:21:54.414]                 args <- list()
[16:21:54.414]                 for (kk in seq_along(NAMES)) {
[16:21:54.414]                   name <- changed[[kk]]
[16:21:54.414]                   NAME <- NAMES[[kk]]
[16:21:54.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:54.414]                     next
[16:21:54.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:54.414]                 }
[16:21:54.414]                 NAMES <- toupper(added)
[16:21:54.414]                 for (kk in seq_along(NAMES)) {
[16:21:54.414]                   name <- added[[kk]]
[16:21:54.414]                   NAME <- NAMES[[kk]]
[16:21:54.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:54.414]                     next
[16:21:54.414]                   args[[name]] <- ""
[16:21:54.414]                 }
[16:21:54.414]                 NAMES <- toupper(removed)
[16:21:54.414]                 for (kk in seq_along(NAMES)) {
[16:21:54.414]                   name <- removed[[kk]]
[16:21:54.414]                   NAME <- NAMES[[kk]]
[16:21:54.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:54.414]                     next
[16:21:54.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:54.414]                 }
[16:21:54.414]                 if (length(args) > 0) 
[16:21:54.414]                   base::do.call(base::Sys.setenv, args = args)
[16:21:54.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:54.414]             }
[16:21:54.414]             else {
[16:21:54.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:54.414]             }
[16:21:54.414]             {
[16:21:54.414]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:54.414]                   0L) {
[16:21:54.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:54.414]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:54.414]                   base::options(opts)
[16:21:54.414]                 }
[16:21:54.414]                 {
[16:21:54.414]                   {
[16:21:54.414]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:54.414]                     NULL
[16:21:54.414]                   }
[16:21:54.414]                   options(future.plan = NULL)
[16:21:54.414]                   if (is.na(NA_character_)) 
[16:21:54.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:54.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:54.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:54.414]                     .init = FALSE)
[16:21:54.414]                 }
[16:21:54.414]             }
[16:21:54.414]         }
[16:21:54.414]     })
[16:21:54.414]     if (TRUE) {
[16:21:54.414]         base::sink(type = "output", split = FALSE)
[16:21:54.414]         if (TRUE) {
[16:21:54.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:54.414]         }
[16:21:54.414]         else {
[16:21:54.414]             ...future.result["stdout"] <- base::list(NULL)
[16:21:54.414]         }
[16:21:54.414]         base::close(...future.stdout)
[16:21:54.414]         ...future.stdout <- NULL
[16:21:54.414]     }
[16:21:54.414]     ...future.result$conditions <- ...future.conditions
[16:21:54.414]     ...future.result$finished <- base::Sys.time()
[16:21:54.414]     ...future.result
[16:21:54.414] }
[16:21:54.467] MultisessionFuture started
[16:21:54.467] result() for ClusterFuture ...
[16:21:54.468] receiveMessageFromWorker() for ClusterFuture ...
[16:21:54.468] - Validating connection of MultisessionFuture
[16:21:54.500] - received message: FutureResult
[16:21:54.500] - Received FutureResult
[16:21:54.500] - Erased future from FutureRegistry
[16:21:54.500] result() for ClusterFuture ...
[16:21:54.501] - result already collected: FutureResult
[16:21:54.501] result() for ClusterFuture ... done
[16:21:54.501] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:54.501] result() for ClusterFuture ... done
[16:21:54.501] result() for ClusterFuture ...
[16:21:54.501] - result already collected: FutureResult
[16:21:54.501] result() for ClusterFuture ... done
[16:21:54.501] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:21:54.505] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[16:21:54.509] getGlobalsAndPackages() ...
[16:21:54.509] Searching for globals...
[16:21:54.511] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:54.511] Searching for globals ... DONE
[16:21:54.511] Resolving globals: FALSE
[16:21:54.511] 
[16:21:54.511] 
[16:21:54.511] getGlobalsAndPackages() ... DONE
[16:21:54.512] run() for ‘Future’ ...
[16:21:54.512] - state: ‘created’
[16:21:54.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:54.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:54.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:54.526]   - Field: ‘node’
[16:21:54.527]   - Field: ‘label’
[16:21:54.527]   - Field: ‘local’
[16:21:54.527]   - Field: ‘owner’
[16:21:54.527]   - Field: ‘envir’
[16:21:54.527]   - Field: ‘workers’
[16:21:54.527]   - Field: ‘packages’
[16:21:54.527]   - Field: ‘gc’
[16:21:54.527]   - Field: ‘conditions’
[16:21:54.527]   - Field: ‘persistent’
[16:21:54.528]   - Field: ‘expr’
[16:21:54.528]   - Field: ‘uuid’
[16:21:54.528]   - Field: ‘seed’
[16:21:54.528]   - Field: ‘version’
[16:21:54.528]   - Field: ‘result’
[16:21:54.528]   - Field: ‘asynchronous’
[16:21:54.528]   - Field: ‘calls’
[16:21:54.528]   - Field: ‘globals’
[16:21:54.528]   - Field: ‘stdout’
[16:21:54.529]   - Field: ‘earlySignal’
[16:21:54.529]   - Field: ‘lazy’
[16:21:54.529]   - Field: ‘state’
[16:21:54.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:54.529] - Launch lazy future ...
[16:21:54.529] Packages needed by the future expression (n = 0): <none>
[16:21:54.530] Packages needed by future strategies (n = 0): <none>
[16:21:54.530] {
[16:21:54.530]     {
[16:21:54.530]         {
[16:21:54.530]             ...future.startTime <- base::Sys.time()
[16:21:54.530]             {
[16:21:54.530]                 {
[16:21:54.530]                   {
[16:21:54.530]                     {
[16:21:54.530]                       base::local({
[16:21:54.530]                         has_future <- base::requireNamespace("future", 
[16:21:54.530]                           quietly = TRUE)
[16:21:54.530]                         if (has_future) {
[16:21:54.530]                           ns <- base::getNamespace("future")
[16:21:54.530]                           version <- ns[[".package"]][["version"]]
[16:21:54.530]                           if (is.null(version)) 
[16:21:54.530]                             version <- utils::packageVersion("future")
[16:21:54.530]                         }
[16:21:54.530]                         else {
[16:21:54.530]                           version <- NULL
[16:21:54.530]                         }
[16:21:54.530]                         if (!has_future || version < "1.8.0") {
[16:21:54.530]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:54.530]                             "", base::R.version$version.string), 
[16:21:54.530]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:54.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:54.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:54.530]                               "release", "version")], collapse = " "), 
[16:21:54.530]                             hostname = base::Sys.info()[["nodename"]])
[16:21:54.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:54.530]                             info)
[16:21:54.530]                           info <- base::paste(info, collapse = "; ")
[16:21:54.530]                           if (!has_future) {
[16:21:54.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:54.530]                               info)
[16:21:54.530]                           }
[16:21:54.530]                           else {
[16:21:54.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:54.530]                               info, version)
[16:21:54.530]                           }
[16:21:54.530]                           base::stop(msg)
[16:21:54.530]                         }
[16:21:54.530]                       })
[16:21:54.530]                     }
[16:21:54.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:54.530]                     base::options(mc.cores = 1L)
[16:21:54.530]                   }
[16:21:54.530]                   ...future.strategy.old <- future::plan("list")
[16:21:54.530]                   options(future.plan = NULL)
[16:21:54.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:54.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:54.530]                 }
[16:21:54.530]                 ...future.workdir <- getwd()
[16:21:54.530]             }
[16:21:54.530]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:54.530]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:54.530]         }
[16:21:54.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:54.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:54.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:54.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:54.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:54.530]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:54.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:54.530]             base::names(...future.oldOptions))
[16:21:54.530]     }
[16:21:54.530]     if (FALSE) {
[16:21:54.530]     }
[16:21:54.530]     else {
[16:21:54.530]         if (TRUE) {
[16:21:54.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:54.530]                 open = "w")
[16:21:54.530]         }
[16:21:54.530]         else {
[16:21:54.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:54.530]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:54.530]         }
[16:21:54.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:54.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:54.530]             base::sink(type = "output", split = FALSE)
[16:21:54.530]             base::close(...future.stdout)
[16:21:54.530]         }, add = TRUE)
[16:21:54.530]     }
[16:21:54.530]     ...future.frame <- base::sys.nframe()
[16:21:54.530]     ...future.conditions <- base::list()
[16:21:54.530]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:54.530]     if (FALSE) {
[16:21:54.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:54.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:54.530]     }
[16:21:54.530]     ...future.result <- base::tryCatch({
[16:21:54.530]         base::withCallingHandlers({
[16:21:54.530]             ...future.value <- base::withVisible(base::local({
[16:21:54.530]                 ...future.makeSendCondition <- base::local({
[16:21:54.530]                   sendCondition <- NULL
[16:21:54.530]                   function(frame = 1L) {
[16:21:54.530]                     if (is.function(sendCondition)) 
[16:21:54.530]                       return(sendCondition)
[16:21:54.530]                     ns <- getNamespace("parallel")
[16:21:54.530]                     if (exists("sendData", mode = "function", 
[16:21:54.530]                       envir = ns)) {
[16:21:54.530]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:54.530]                         envir = ns)
[16:21:54.530]                       envir <- sys.frame(frame)
[16:21:54.530]                       master <- NULL
[16:21:54.530]                       while (!identical(envir, .GlobalEnv) && 
[16:21:54.530]                         !identical(envir, emptyenv())) {
[16:21:54.530]                         if (exists("master", mode = "list", envir = envir, 
[16:21:54.530]                           inherits = FALSE)) {
[16:21:54.530]                           master <- get("master", mode = "list", 
[16:21:54.530]                             envir = envir, inherits = FALSE)
[16:21:54.530]                           if (inherits(master, c("SOCKnode", 
[16:21:54.530]                             "SOCK0node"))) {
[16:21:54.530]                             sendCondition <<- function(cond) {
[16:21:54.530]                               data <- list(type = "VALUE", value = cond, 
[16:21:54.530]                                 success = TRUE)
[16:21:54.530]                               parallel_sendData(master, data)
[16:21:54.530]                             }
[16:21:54.530]                             return(sendCondition)
[16:21:54.530]                           }
[16:21:54.530]                         }
[16:21:54.530]                         frame <- frame + 1L
[16:21:54.530]                         envir <- sys.frame(frame)
[16:21:54.530]                       }
[16:21:54.530]                     }
[16:21:54.530]                     sendCondition <<- function(cond) NULL
[16:21:54.530]                   }
[16:21:54.530]                 })
[16:21:54.530]                 withCallingHandlers({
[16:21:54.530]                   {
[16:21:54.530]                     Sys.sleep(0.5)
[16:21:54.530]                     list(a = 1, b = 42L)
[16:21:54.530]                   }
[16:21:54.530]                 }, immediateCondition = function(cond) {
[16:21:54.530]                   sendCondition <- ...future.makeSendCondition()
[16:21:54.530]                   sendCondition(cond)
[16:21:54.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:54.530]                   {
[16:21:54.530]                     inherits <- base::inherits
[16:21:54.530]                     invokeRestart <- base::invokeRestart
[16:21:54.530]                     is.null <- base::is.null
[16:21:54.530]                     muffled <- FALSE
[16:21:54.530]                     if (inherits(cond, "message")) {
[16:21:54.530]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:54.530]                       if (muffled) 
[16:21:54.530]                         invokeRestart("muffleMessage")
[16:21:54.530]                     }
[16:21:54.530]                     else if (inherits(cond, "warning")) {
[16:21:54.530]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:54.530]                       if (muffled) 
[16:21:54.530]                         invokeRestart("muffleWarning")
[16:21:54.530]                     }
[16:21:54.530]                     else if (inherits(cond, "condition")) {
[16:21:54.530]                       if (!is.null(pattern)) {
[16:21:54.530]                         computeRestarts <- base::computeRestarts
[16:21:54.530]                         grepl <- base::grepl
[16:21:54.530]                         restarts <- computeRestarts(cond)
[16:21:54.530]                         for (restart in restarts) {
[16:21:54.530]                           name <- restart$name
[16:21:54.530]                           if (is.null(name)) 
[16:21:54.530]                             next
[16:21:54.530]                           if (!grepl(pattern, name)) 
[16:21:54.530]                             next
[16:21:54.530]                           invokeRestart(restart)
[16:21:54.530]                           muffled <- TRUE
[16:21:54.530]                           break
[16:21:54.530]                         }
[16:21:54.530]                       }
[16:21:54.530]                     }
[16:21:54.530]                     invisible(muffled)
[16:21:54.530]                   }
[16:21:54.530]                   muffleCondition(cond)
[16:21:54.530]                 })
[16:21:54.530]             }))
[16:21:54.530]             future::FutureResult(value = ...future.value$value, 
[16:21:54.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:54.530]                   ...future.rng), globalenv = if (FALSE) 
[16:21:54.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:54.530]                     ...future.globalenv.names))
[16:21:54.530]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:54.530]         }, condition = base::local({
[16:21:54.530]             c <- base::c
[16:21:54.530]             inherits <- base::inherits
[16:21:54.530]             invokeRestart <- base::invokeRestart
[16:21:54.530]             length <- base::length
[16:21:54.530]             list <- base::list
[16:21:54.530]             seq.int <- base::seq.int
[16:21:54.530]             signalCondition <- base::signalCondition
[16:21:54.530]             sys.calls <- base::sys.calls
[16:21:54.530]             `[[` <- base::`[[`
[16:21:54.530]             `+` <- base::`+`
[16:21:54.530]             `<<-` <- base::`<<-`
[16:21:54.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:54.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:54.530]                   3L)]
[16:21:54.530]             }
[16:21:54.530]             function(cond) {
[16:21:54.530]                 is_error <- inherits(cond, "error")
[16:21:54.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:54.530]                   NULL)
[16:21:54.530]                 if (is_error) {
[16:21:54.530]                   sessionInformation <- function() {
[16:21:54.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:54.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:54.530]                       search = base::search(), system = base::Sys.info())
[16:21:54.530]                   }
[16:21:54.530]                   ...future.conditions[[length(...future.conditions) + 
[16:21:54.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:54.530]                     cond$call), session = sessionInformation(), 
[16:21:54.530]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:54.530]                   signalCondition(cond)
[16:21:54.530]                 }
[16:21:54.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:54.530]                 "immediateCondition"))) {
[16:21:54.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:54.530]                   ...future.conditions[[length(...future.conditions) + 
[16:21:54.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:54.530]                   if (TRUE && !signal) {
[16:21:54.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:54.530]                     {
[16:21:54.530]                       inherits <- base::inherits
[16:21:54.530]                       invokeRestart <- base::invokeRestart
[16:21:54.530]                       is.null <- base::is.null
[16:21:54.530]                       muffled <- FALSE
[16:21:54.530]                       if (inherits(cond, "message")) {
[16:21:54.530]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:54.530]                         if (muffled) 
[16:21:54.530]                           invokeRestart("muffleMessage")
[16:21:54.530]                       }
[16:21:54.530]                       else if (inherits(cond, "warning")) {
[16:21:54.530]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:54.530]                         if (muffled) 
[16:21:54.530]                           invokeRestart("muffleWarning")
[16:21:54.530]                       }
[16:21:54.530]                       else if (inherits(cond, "condition")) {
[16:21:54.530]                         if (!is.null(pattern)) {
[16:21:54.530]                           computeRestarts <- base::computeRestarts
[16:21:54.530]                           grepl <- base::grepl
[16:21:54.530]                           restarts <- computeRestarts(cond)
[16:21:54.530]                           for (restart in restarts) {
[16:21:54.530]                             name <- restart$name
[16:21:54.530]                             if (is.null(name)) 
[16:21:54.530]                               next
[16:21:54.530]                             if (!grepl(pattern, name)) 
[16:21:54.530]                               next
[16:21:54.530]                             invokeRestart(restart)
[16:21:54.530]                             muffled <- TRUE
[16:21:54.530]                             break
[16:21:54.530]                           }
[16:21:54.530]                         }
[16:21:54.530]                       }
[16:21:54.530]                       invisible(muffled)
[16:21:54.530]                     }
[16:21:54.530]                     muffleCondition(cond, pattern = "^muffle")
[16:21:54.530]                   }
[16:21:54.530]                 }
[16:21:54.530]                 else {
[16:21:54.530]                   if (TRUE) {
[16:21:54.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:54.530]                     {
[16:21:54.530]                       inherits <- base::inherits
[16:21:54.530]                       invokeRestart <- base::invokeRestart
[16:21:54.530]                       is.null <- base::is.null
[16:21:54.530]                       muffled <- FALSE
[16:21:54.530]                       if (inherits(cond, "message")) {
[16:21:54.530]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:54.530]                         if (muffled) 
[16:21:54.530]                           invokeRestart("muffleMessage")
[16:21:54.530]                       }
[16:21:54.530]                       else if (inherits(cond, "warning")) {
[16:21:54.530]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:54.530]                         if (muffled) 
[16:21:54.530]                           invokeRestart("muffleWarning")
[16:21:54.530]                       }
[16:21:54.530]                       else if (inherits(cond, "condition")) {
[16:21:54.530]                         if (!is.null(pattern)) {
[16:21:54.530]                           computeRestarts <- base::computeRestarts
[16:21:54.530]                           grepl <- base::grepl
[16:21:54.530]                           restarts <- computeRestarts(cond)
[16:21:54.530]                           for (restart in restarts) {
[16:21:54.530]                             name <- restart$name
[16:21:54.530]                             if (is.null(name)) 
[16:21:54.530]                               next
[16:21:54.530]                             if (!grepl(pattern, name)) 
[16:21:54.530]                               next
[16:21:54.530]                             invokeRestart(restart)
[16:21:54.530]                             muffled <- TRUE
[16:21:54.530]                             break
[16:21:54.530]                           }
[16:21:54.530]                         }
[16:21:54.530]                       }
[16:21:54.530]                       invisible(muffled)
[16:21:54.530]                     }
[16:21:54.530]                     muffleCondition(cond, pattern = "^muffle")
[16:21:54.530]                   }
[16:21:54.530]                 }
[16:21:54.530]             }
[16:21:54.530]         }))
[16:21:54.530]     }, error = function(ex) {
[16:21:54.530]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:54.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:54.530]                 ...future.rng), started = ...future.startTime, 
[16:21:54.530]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:54.530]             version = "1.8"), class = "FutureResult")
[16:21:54.530]     }, finally = {
[16:21:54.530]         if (!identical(...future.workdir, getwd())) 
[16:21:54.530]             setwd(...future.workdir)
[16:21:54.530]         {
[16:21:54.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:54.530]                 ...future.oldOptions$nwarnings <- NULL
[16:21:54.530]             }
[16:21:54.530]             base::options(...future.oldOptions)
[16:21:54.530]             if (.Platform$OS.type == "windows") {
[16:21:54.530]                 old_names <- names(...future.oldEnvVars)
[16:21:54.530]                 envs <- base::Sys.getenv()
[16:21:54.530]                 names <- names(envs)
[16:21:54.530]                 common <- intersect(names, old_names)
[16:21:54.530]                 added <- setdiff(names, old_names)
[16:21:54.530]                 removed <- setdiff(old_names, names)
[16:21:54.530]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:54.530]                   envs[common]]
[16:21:54.530]                 NAMES <- toupper(changed)
[16:21:54.530]                 args <- list()
[16:21:54.530]                 for (kk in seq_along(NAMES)) {
[16:21:54.530]                   name <- changed[[kk]]
[16:21:54.530]                   NAME <- NAMES[[kk]]
[16:21:54.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:54.530]                     next
[16:21:54.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:54.530]                 }
[16:21:54.530]                 NAMES <- toupper(added)
[16:21:54.530]                 for (kk in seq_along(NAMES)) {
[16:21:54.530]                   name <- added[[kk]]
[16:21:54.530]                   NAME <- NAMES[[kk]]
[16:21:54.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:54.530]                     next
[16:21:54.530]                   args[[name]] <- ""
[16:21:54.530]                 }
[16:21:54.530]                 NAMES <- toupper(removed)
[16:21:54.530]                 for (kk in seq_along(NAMES)) {
[16:21:54.530]                   name <- removed[[kk]]
[16:21:54.530]                   NAME <- NAMES[[kk]]
[16:21:54.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:54.530]                     next
[16:21:54.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:54.530]                 }
[16:21:54.530]                 if (length(args) > 0) 
[16:21:54.530]                   base::do.call(base::Sys.setenv, args = args)
[16:21:54.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:54.530]             }
[16:21:54.530]             else {
[16:21:54.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:54.530]             }
[16:21:54.530]             {
[16:21:54.530]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:54.530]                   0L) {
[16:21:54.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:54.530]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:54.530]                   base::options(opts)
[16:21:54.530]                 }
[16:21:54.530]                 {
[16:21:54.530]                   {
[16:21:54.530]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:54.530]                     NULL
[16:21:54.530]                   }
[16:21:54.530]                   options(future.plan = NULL)
[16:21:54.530]                   if (is.na(NA_character_)) 
[16:21:54.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:54.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:54.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:54.530]                     .init = FALSE)
[16:21:54.530]                 }
[16:21:54.530]             }
[16:21:54.530]         }
[16:21:54.530]     })
[16:21:54.530]     if (TRUE) {
[16:21:54.530]         base::sink(type = "output", split = FALSE)
[16:21:54.530]         if (TRUE) {
[16:21:54.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:54.530]         }
[16:21:54.530]         else {
[16:21:54.530]             ...future.result["stdout"] <- base::list(NULL)
[16:21:54.530]         }
[16:21:54.530]         base::close(...future.stdout)
[16:21:54.530]         ...future.stdout <- NULL
[16:21:54.530]     }
[16:21:54.530]     ...future.result$conditions <- ...future.conditions
[16:21:54.530]     ...future.result$finished <- base::Sys.time()
[16:21:54.530]     ...future.result
[16:21:54.530] }
[16:21:54.533] MultisessionFuture started
[16:21:54.533] - Launch lazy future ... done
[16:21:54.534] run() for ‘MultisessionFuture’ ... done
[16:21:55.039] receiveMessageFromWorker() for ClusterFuture ...
[16:21:55.039] - Validating connection of MultisessionFuture
[16:21:55.040] - received message: FutureResult
[16:21:55.040] - Received FutureResult
[16:21:55.040] - Erased future from FutureRegistry
[16:21:55.040] result() for ClusterFuture ...
[16:21:55.040] - result already collected: FutureResult
[16:21:55.040] result() for ClusterFuture ... done
[16:21:55.041] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:55.041] A MultisessionFuture was resolved (result was not collected)
[16:21:55.041] getGlobalsAndPackages() ...
[16:21:55.041] Searching for globals...
[16:21:55.042] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:55.043] Searching for globals ... DONE
[16:21:55.043] Resolving globals: FALSE
[16:21:55.043] 
[16:21:55.043] 
[16:21:55.043] getGlobalsAndPackages() ... DONE
[16:21:55.044] run() for ‘Future’ ...
[16:21:55.044] - state: ‘created’
[16:21:55.044] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:55.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:55.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:55.059]   - Field: ‘node’
[16:21:55.059]   - Field: ‘label’
[16:21:55.059]   - Field: ‘local’
[16:21:55.059]   - Field: ‘owner’
[16:21:55.059]   - Field: ‘envir’
[16:21:55.059]   - Field: ‘workers’
[16:21:55.059]   - Field: ‘packages’
[16:21:55.060]   - Field: ‘gc’
[16:21:55.060]   - Field: ‘conditions’
[16:21:55.060]   - Field: ‘persistent’
[16:21:55.060]   - Field: ‘expr’
[16:21:55.060]   - Field: ‘uuid’
[16:21:55.060]   - Field: ‘seed’
[16:21:55.060]   - Field: ‘version’
[16:21:55.060]   - Field: ‘result’
[16:21:55.061]   - Field: ‘asynchronous’
[16:21:55.061]   - Field: ‘calls’
[16:21:55.061]   - Field: ‘globals’
[16:21:55.061]   - Field: ‘stdout’
[16:21:55.061]   - Field: ‘earlySignal’
[16:21:55.061]   - Field: ‘lazy’
[16:21:55.061]   - Field: ‘state’
[16:21:55.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:55.062] - Launch lazy future ...
[16:21:55.062] Packages needed by the future expression (n = 0): <none>
[16:21:55.062] Packages needed by future strategies (n = 0): <none>
[16:21:55.062] {
[16:21:55.062]     {
[16:21:55.062]         {
[16:21:55.062]             ...future.startTime <- base::Sys.time()
[16:21:55.062]             {
[16:21:55.062]                 {
[16:21:55.062]                   {
[16:21:55.062]                     {
[16:21:55.062]                       base::local({
[16:21:55.062]                         has_future <- base::requireNamespace("future", 
[16:21:55.062]                           quietly = TRUE)
[16:21:55.062]                         if (has_future) {
[16:21:55.062]                           ns <- base::getNamespace("future")
[16:21:55.062]                           version <- ns[[".package"]][["version"]]
[16:21:55.062]                           if (is.null(version)) 
[16:21:55.062]                             version <- utils::packageVersion("future")
[16:21:55.062]                         }
[16:21:55.062]                         else {
[16:21:55.062]                           version <- NULL
[16:21:55.062]                         }
[16:21:55.062]                         if (!has_future || version < "1.8.0") {
[16:21:55.062]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:55.062]                             "", base::R.version$version.string), 
[16:21:55.062]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:55.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:55.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:55.062]                               "release", "version")], collapse = " "), 
[16:21:55.062]                             hostname = base::Sys.info()[["nodename"]])
[16:21:55.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:55.062]                             info)
[16:21:55.062]                           info <- base::paste(info, collapse = "; ")
[16:21:55.062]                           if (!has_future) {
[16:21:55.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:55.062]                               info)
[16:21:55.062]                           }
[16:21:55.062]                           else {
[16:21:55.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:55.062]                               info, version)
[16:21:55.062]                           }
[16:21:55.062]                           base::stop(msg)
[16:21:55.062]                         }
[16:21:55.062]                       })
[16:21:55.062]                     }
[16:21:55.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:55.062]                     base::options(mc.cores = 1L)
[16:21:55.062]                   }
[16:21:55.062]                   ...future.strategy.old <- future::plan("list")
[16:21:55.062]                   options(future.plan = NULL)
[16:21:55.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:55.062]                 }
[16:21:55.062]                 ...future.workdir <- getwd()
[16:21:55.062]             }
[16:21:55.062]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:55.062]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:55.062]         }
[16:21:55.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:55.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:55.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:55.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:55.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:55.062]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:55.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:55.062]             base::names(...future.oldOptions))
[16:21:55.062]     }
[16:21:55.062]     if (FALSE) {
[16:21:55.062]     }
[16:21:55.062]     else {
[16:21:55.062]         if (TRUE) {
[16:21:55.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:55.062]                 open = "w")
[16:21:55.062]         }
[16:21:55.062]         else {
[16:21:55.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:55.062]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:55.062]         }
[16:21:55.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:55.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:55.062]             base::sink(type = "output", split = FALSE)
[16:21:55.062]             base::close(...future.stdout)
[16:21:55.062]         }, add = TRUE)
[16:21:55.062]     }
[16:21:55.062]     ...future.frame <- base::sys.nframe()
[16:21:55.062]     ...future.conditions <- base::list()
[16:21:55.062]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:55.062]     if (FALSE) {
[16:21:55.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:55.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:55.062]     }
[16:21:55.062]     ...future.result <- base::tryCatch({
[16:21:55.062]         base::withCallingHandlers({
[16:21:55.062]             ...future.value <- base::withVisible(base::local({
[16:21:55.062]                 ...future.makeSendCondition <- base::local({
[16:21:55.062]                   sendCondition <- NULL
[16:21:55.062]                   function(frame = 1L) {
[16:21:55.062]                     if (is.function(sendCondition)) 
[16:21:55.062]                       return(sendCondition)
[16:21:55.062]                     ns <- getNamespace("parallel")
[16:21:55.062]                     if (exists("sendData", mode = "function", 
[16:21:55.062]                       envir = ns)) {
[16:21:55.062]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:55.062]                         envir = ns)
[16:21:55.062]                       envir <- sys.frame(frame)
[16:21:55.062]                       master <- NULL
[16:21:55.062]                       while (!identical(envir, .GlobalEnv) && 
[16:21:55.062]                         !identical(envir, emptyenv())) {
[16:21:55.062]                         if (exists("master", mode = "list", envir = envir, 
[16:21:55.062]                           inherits = FALSE)) {
[16:21:55.062]                           master <- get("master", mode = "list", 
[16:21:55.062]                             envir = envir, inherits = FALSE)
[16:21:55.062]                           if (inherits(master, c("SOCKnode", 
[16:21:55.062]                             "SOCK0node"))) {
[16:21:55.062]                             sendCondition <<- function(cond) {
[16:21:55.062]                               data <- list(type = "VALUE", value = cond, 
[16:21:55.062]                                 success = TRUE)
[16:21:55.062]                               parallel_sendData(master, data)
[16:21:55.062]                             }
[16:21:55.062]                             return(sendCondition)
[16:21:55.062]                           }
[16:21:55.062]                         }
[16:21:55.062]                         frame <- frame + 1L
[16:21:55.062]                         envir <- sys.frame(frame)
[16:21:55.062]                       }
[16:21:55.062]                     }
[16:21:55.062]                     sendCondition <<- function(cond) NULL
[16:21:55.062]                   }
[16:21:55.062]                 })
[16:21:55.062]                 withCallingHandlers({
[16:21:55.062]                   {
[16:21:55.062]                     Sys.sleep(0.5)
[16:21:55.062]                     list(a = 1, b = 42L)
[16:21:55.062]                   }
[16:21:55.062]                 }, immediateCondition = function(cond) {
[16:21:55.062]                   sendCondition <- ...future.makeSendCondition()
[16:21:55.062]                   sendCondition(cond)
[16:21:55.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.062]                   {
[16:21:55.062]                     inherits <- base::inherits
[16:21:55.062]                     invokeRestart <- base::invokeRestart
[16:21:55.062]                     is.null <- base::is.null
[16:21:55.062]                     muffled <- FALSE
[16:21:55.062]                     if (inherits(cond, "message")) {
[16:21:55.062]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:55.062]                       if (muffled) 
[16:21:55.062]                         invokeRestart("muffleMessage")
[16:21:55.062]                     }
[16:21:55.062]                     else if (inherits(cond, "warning")) {
[16:21:55.062]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:55.062]                       if (muffled) 
[16:21:55.062]                         invokeRestart("muffleWarning")
[16:21:55.062]                     }
[16:21:55.062]                     else if (inherits(cond, "condition")) {
[16:21:55.062]                       if (!is.null(pattern)) {
[16:21:55.062]                         computeRestarts <- base::computeRestarts
[16:21:55.062]                         grepl <- base::grepl
[16:21:55.062]                         restarts <- computeRestarts(cond)
[16:21:55.062]                         for (restart in restarts) {
[16:21:55.062]                           name <- restart$name
[16:21:55.062]                           if (is.null(name)) 
[16:21:55.062]                             next
[16:21:55.062]                           if (!grepl(pattern, name)) 
[16:21:55.062]                             next
[16:21:55.062]                           invokeRestart(restart)
[16:21:55.062]                           muffled <- TRUE
[16:21:55.062]                           break
[16:21:55.062]                         }
[16:21:55.062]                       }
[16:21:55.062]                     }
[16:21:55.062]                     invisible(muffled)
[16:21:55.062]                   }
[16:21:55.062]                   muffleCondition(cond)
[16:21:55.062]                 })
[16:21:55.062]             }))
[16:21:55.062]             future::FutureResult(value = ...future.value$value, 
[16:21:55.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.062]                   ...future.rng), globalenv = if (FALSE) 
[16:21:55.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:55.062]                     ...future.globalenv.names))
[16:21:55.062]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:55.062]         }, condition = base::local({
[16:21:55.062]             c <- base::c
[16:21:55.062]             inherits <- base::inherits
[16:21:55.062]             invokeRestart <- base::invokeRestart
[16:21:55.062]             length <- base::length
[16:21:55.062]             list <- base::list
[16:21:55.062]             seq.int <- base::seq.int
[16:21:55.062]             signalCondition <- base::signalCondition
[16:21:55.062]             sys.calls <- base::sys.calls
[16:21:55.062]             `[[` <- base::`[[`
[16:21:55.062]             `+` <- base::`+`
[16:21:55.062]             `<<-` <- base::`<<-`
[16:21:55.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:55.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:55.062]                   3L)]
[16:21:55.062]             }
[16:21:55.062]             function(cond) {
[16:21:55.062]                 is_error <- inherits(cond, "error")
[16:21:55.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:55.062]                   NULL)
[16:21:55.062]                 if (is_error) {
[16:21:55.062]                   sessionInformation <- function() {
[16:21:55.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:55.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:55.062]                       search = base::search(), system = base::Sys.info())
[16:21:55.062]                   }
[16:21:55.062]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:55.062]                     cond$call), session = sessionInformation(), 
[16:21:55.062]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:55.062]                   signalCondition(cond)
[16:21:55.062]                 }
[16:21:55.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:55.062]                 "immediateCondition"))) {
[16:21:55.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:55.062]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:55.062]                   if (TRUE && !signal) {
[16:21:55.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.062]                     {
[16:21:55.062]                       inherits <- base::inherits
[16:21:55.062]                       invokeRestart <- base::invokeRestart
[16:21:55.062]                       is.null <- base::is.null
[16:21:55.062]                       muffled <- FALSE
[16:21:55.062]                       if (inherits(cond, "message")) {
[16:21:55.062]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.062]                         if (muffled) 
[16:21:55.062]                           invokeRestart("muffleMessage")
[16:21:55.062]                       }
[16:21:55.062]                       else if (inherits(cond, "warning")) {
[16:21:55.062]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.062]                         if (muffled) 
[16:21:55.062]                           invokeRestart("muffleWarning")
[16:21:55.062]                       }
[16:21:55.062]                       else if (inherits(cond, "condition")) {
[16:21:55.062]                         if (!is.null(pattern)) {
[16:21:55.062]                           computeRestarts <- base::computeRestarts
[16:21:55.062]                           grepl <- base::grepl
[16:21:55.062]                           restarts <- computeRestarts(cond)
[16:21:55.062]                           for (restart in restarts) {
[16:21:55.062]                             name <- restart$name
[16:21:55.062]                             if (is.null(name)) 
[16:21:55.062]                               next
[16:21:55.062]                             if (!grepl(pattern, name)) 
[16:21:55.062]                               next
[16:21:55.062]                             invokeRestart(restart)
[16:21:55.062]                             muffled <- TRUE
[16:21:55.062]                             break
[16:21:55.062]                           }
[16:21:55.062]                         }
[16:21:55.062]                       }
[16:21:55.062]                       invisible(muffled)
[16:21:55.062]                     }
[16:21:55.062]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.062]                   }
[16:21:55.062]                 }
[16:21:55.062]                 else {
[16:21:55.062]                   if (TRUE) {
[16:21:55.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.062]                     {
[16:21:55.062]                       inherits <- base::inherits
[16:21:55.062]                       invokeRestart <- base::invokeRestart
[16:21:55.062]                       is.null <- base::is.null
[16:21:55.062]                       muffled <- FALSE
[16:21:55.062]                       if (inherits(cond, "message")) {
[16:21:55.062]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.062]                         if (muffled) 
[16:21:55.062]                           invokeRestart("muffleMessage")
[16:21:55.062]                       }
[16:21:55.062]                       else if (inherits(cond, "warning")) {
[16:21:55.062]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.062]                         if (muffled) 
[16:21:55.062]                           invokeRestart("muffleWarning")
[16:21:55.062]                       }
[16:21:55.062]                       else if (inherits(cond, "condition")) {
[16:21:55.062]                         if (!is.null(pattern)) {
[16:21:55.062]                           computeRestarts <- base::computeRestarts
[16:21:55.062]                           grepl <- base::grepl
[16:21:55.062]                           restarts <- computeRestarts(cond)
[16:21:55.062]                           for (restart in restarts) {
[16:21:55.062]                             name <- restart$name
[16:21:55.062]                             if (is.null(name)) 
[16:21:55.062]                               next
[16:21:55.062]                             if (!grepl(pattern, name)) 
[16:21:55.062]                               next
[16:21:55.062]                             invokeRestart(restart)
[16:21:55.062]                             muffled <- TRUE
[16:21:55.062]                             break
[16:21:55.062]                           }
[16:21:55.062]                         }
[16:21:55.062]                       }
[16:21:55.062]                       invisible(muffled)
[16:21:55.062]                     }
[16:21:55.062]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.062]                   }
[16:21:55.062]                 }
[16:21:55.062]             }
[16:21:55.062]         }))
[16:21:55.062]     }, error = function(ex) {
[16:21:55.062]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:55.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.062]                 ...future.rng), started = ...future.startTime, 
[16:21:55.062]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:55.062]             version = "1.8"), class = "FutureResult")
[16:21:55.062]     }, finally = {
[16:21:55.062]         if (!identical(...future.workdir, getwd())) 
[16:21:55.062]             setwd(...future.workdir)
[16:21:55.062]         {
[16:21:55.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:55.062]                 ...future.oldOptions$nwarnings <- NULL
[16:21:55.062]             }
[16:21:55.062]             base::options(...future.oldOptions)
[16:21:55.062]             if (.Platform$OS.type == "windows") {
[16:21:55.062]                 old_names <- names(...future.oldEnvVars)
[16:21:55.062]                 envs <- base::Sys.getenv()
[16:21:55.062]                 names <- names(envs)
[16:21:55.062]                 common <- intersect(names, old_names)
[16:21:55.062]                 added <- setdiff(names, old_names)
[16:21:55.062]                 removed <- setdiff(old_names, names)
[16:21:55.062]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:55.062]                   envs[common]]
[16:21:55.062]                 NAMES <- toupper(changed)
[16:21:55.062]                 args <- list()
[16:21:55.062]                 for (kk in seq_along(NAMES)) {
[16:21:55.062]                   name <- changed[[kk]]
[16:21:55.062]                   NAME <- NAMES[[kk]]
[16:21:55.062]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.062]                     next
[16:21:55.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.062]                 }
[16:21:55.062]                 NAMES <- toupper(added)
[16:21:55.062]                 for (kk in seq_along(NAMES)) {
[16:21:55.062]                   name <- added[[kk]]
[16:21:55.062]                   NAME <- NAMES[[kk]]
[16:21:55.062]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.062]                     next
[16:21:55.062]                   args[[name]] <- ""
[16:21:55.062]                 }
[16:21:55.062]                 NAMES <- toupper(removed)
[16:21:55.062]                 for (kk in seq_along(NAMES)) {
[16:21:55.062]                   name <- removed[[kk]]
[16:21:55.062]                   NAME <- NAMES[[kk]]
[16:21:55.062]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.062]                     next
[16:21:55.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.062]                 }
[16:21:55.062]                 if (length(args) > 0) 
[16:21:55.062]                   base::do.call(base::Sys.setenv, args = args)
[16:21:55.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:55.062]             }
[16:21:55.062]             else {
[16:21:55.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:55.062]             }
[16:21:55.062]             {
[16:21:55.062]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:55.062]                   0L) {
[16:21:55.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:55.062]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:55.062]                   base::options(opts)
[16:21:55.062]                 }
[16:21:55.062]                 {
[16:21:55.062]                   {
[16:21:55.062]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:55.062]                     NULL
[16:21:55.062]                   }
[16:21:55.062]                   options(future.plan = NULL)
[16:21:55.062]                   if (is.na(NA_character_)) 
[16:21:55.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:55.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:55.062]                     .init = FALSE)
[16:21:55.062]                 }
[16:21:55.062]             }
[16:21:55.062]         }
[16:21:55.062]     })
[16:21:55.062]     if (TRUE) {
[16:21:55.062]         base::sink(type = "output", split = FALSE)
[16:21:55.062]         if (TRUE) {
[16:21:55.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:55.062]         }
[16:21:55.062]         else {
[16:21:55.062]             ...future.result["stdout"] <- base::list(NULL)
[16:21:55.062]         }
[16:21:55.062]         base::close(...future.stdout)
[16:21:55.062]         ...future.stdout <- NULL
[16:21:55.062]     }
[16:21:55.062]     ...future.result$conditions <- ...future.conditions
[16:21:55.062]     ...future.result$finished <- base::Sys.time()
[16:21:55.062]     ...future.result
[16:21:55.062] }
[16:21:55.066] MultisessionFuture started
[16:21:55.066] - Launch lazy future ... done
[16:21:55.066] run() for ‘MultisessionFuture’ ... done
[16:21:55.568] receiveMessageFromWorker() for ClusterFuture ...
[16:21:55.569] - Validating connection of MultisessionFuture
[16:21:55.569] - received message: FutureResult
[16:21:55.569] - Received FutureResult
[16:21:55.569] - Erased future from FutureRegistry
[16:21:55.569] result() for ClusterFuture ...
[16:21:55.570] - result already collected: FutureResult
[16:21:55.570] result() for ClusterFuture ... done
[16:21:55.570] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:55.570] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:21:55.570] getGlobalsAndPackages() ...
[16:21:55.570] Searching for globals...
[16:21:55.571] - globals found: [2] ‘list’, ‘stop’
[16:21:55.571] Searching for globals ... DONE
[16:21:55.571] Resolving globals: FALSE
[16:21:55.572] 
[16:21:55.572] 
[16:21:55.572] getGlobalsAndPackages() ... DONE
[16:21:55.572] run() for ‘Future’ ...
[16:21:55.572] - state: ‘created’
[16:21:55.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:55.589] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:55.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:55.589]   - Field: ‘node’
[16:21:55.590]   - Field: ‘label’
[16:21:55.590]   - Field: ‘local’
[16:21:55.590]   - Field: ‘owner’
[16:21:55.590]   - Field: ‘envir’
[16:21:55.590]   - Field: ‘workers’
[16:21:55.590]   - Field: ‘packages’
[16:21:55.590]   - Field: ‘gc’
[16:21:55.590]   - Field: ‘conditions’
[16:21:55.590]   - Field: ‘persistent’
[16:21:55.590]   - Field: ‘expr’
[16:21:55.590]   - Field: ‘uuid’
[16:21:55.591]   - Field: ‘seed’
[16:21:55.591]   - Field: ‘version’
[16:21:55.591]   - Field: ‘result’
[16:21:55.591]   - Field: ‘asynchronous’
[16:21:55.591]   - Field: ‘calls’
[16:21:55.591]   - Field: ‘globals’
[16:21:55.591]   - Field: ‘stdout’
[16:21:55.591]   - Field: ‘earlySignal’
[16:21:55.591]   - Field: ‘lazy’
[16:21:55.591]   - Field: ‘state’
[16:21:55.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:55.591] - Launch lazy future ...
[16:21:55.592] Packages needed by the future expression (n = 0): <none>
[16:21:55.592] Packages needed by future strategies (n = 0): <none>
[16:21:55.592] {
[16:21:55.592]     {
[16:21:55.592]         {
[16:21:55.592]             ...future.startTime <- base::Sys.time()
[16:21:55.592]             {
[16:21:55.592]                 {
[16:21:55.592]                   {
[16:21:55.592]                     {
[16:21:55.592]                       base::local({
[16:21:55.592]                         has_future <- base::requireNamespace("future", 
[16:21:55.592]                           quietly = TRUE)
[16:21:55.592]                         if (has_future) {
[16:21:55.592]                           ns <- base::getNamespace("future")
[16:21:55.592]                           version <- ns[[".package"]][["version"]]
[16:21:55.592]                           if (is.null(version)) 
[16:21:55.592]                             version <- utils::packageVersion("future")
[16:21:55.592]                         }
[16:21:55.592]                         else {
[16:21:55.592]                           version <- NULL
[16:21:55.592]                         }
[16:21:55.592]                         if (!has_future || version < "1.8.0") {
[16:21:55.592]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:55.592]                             "", base::R.version$version.string), 
[16:21:55.592]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:55.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:55.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:55.592]                               "release", "version")], collapse = " "), 
[16:21:55.592]                             hostname = base::Sys.info()[["nodename"]])
[16:21:55.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:55.592]                             info)
[16:21:55.592]                           info <- base::paste(info, collapse = "; ")
[16:21:55.592]                           if (!has_future) {
[16:21:55.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:55.592]                               info)
[16:21:55.592]                           }
[16:21:55.592]                           else {
[16:21:55.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:55.592]                               info, version)
[16:21:55.592]                           }
[16:21:55.592]                           base::stop(msg)
[16:21:55.592]                         }
[16:21:55.592]                       })
[16:21:55.592]                     }
[16:21:55.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:55.592]                     base::options(mc.cores = 1L)
[16:21:55.592]                   }
[16:21:55.592]                   ...future.strategy.old <- future::plan("list")
[16:21:55.592]                   options(future.plan = NULL)
[16:21:55.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:55.592]                 }
[16:21:55.592]                 ...future.workdir <- getwd()
[16:21:55.592]             }
[16:21:55.592]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:55.592]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:55.592]         }
[16:21:55.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:55.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:55.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:55.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:55.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:55.592]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:55.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:55.592]             base::names(...future.oldOptions))
[16:21:55.592]     }
[16:21:55.592]     if (FALSE) {
[16:21:55.592]     }
[16:21:55.592]     else {
[16:21:55.592]         if (TRUE) {
[16:21:55.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:55.592]                 open = "w")
[16:21:55.592]         }
[16:21:55.592]         else {
[16:21:55.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:55.592]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:55.592]         }
[16:21:55.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:55.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:55.592]             base::sink(type = "output", split = FALSE)
[16:21:55.592]             base::close(...future.stdout)
[16:21:55.592]         }, add = TRUE)
[16:21:55.592]     }
[16:21:55.592]     ...future.frame <- base::sys.nframe()
[16:21:55.592]     ...future.conditions <- base::list()
[16:21:55.592]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:55.592]     if (FALSE) {
[16:21:55.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:55.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:55.592]     }
[16:21:55.592]     ...future.result <- base::tryCatch({
[16:21:55.592]         base::withCallingHandlers({
[16:21:55.592]             ...future.value <- base::withVisible(base::local({
[16:21:55.592]                 ...future.makeSendCondition <- base::local({
[16:21:55.592]                   sendCondition <- NULL
[16:21:55.592]                   function(frame = 1L) {
[16:21:55.592]                     if (is.function(sendCondition)) 
[16:21:55.592]                       return(sendCondition)
[16:21:55.592]                     ns <- getNamespace("parallel")
[16:21:55.592]                     if (exists("sendData", mode = "function", 
[16:21:55.592]                       envir = ns)) {
[16:21:55.592]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:55.592]                         envir = ns)
[16:21:55.592]                       envir <- sys.frame(frame)
[16:21:55.592]                       master <- NULL
[16:21:55.592]                       while (!identical(envir, .GlobalEnv) && 
[16:21:55.592]                         !identical(envir, emptyenv())) {
[16:21:55.592]                         if (exists("master", mode = "list", envir = envir, 
[16:21:55.592]                           inherits = FALSE)) {
[16:21:55.592]                           master <- get("master", mode = "list", 
[16:21:55.592]                             envir = envir, inherits = FALSE)
[16:21:55.592]                           if (inherits(master, c("SOCKnode", 
[16:21:55.592]                             "SOCK0node"))) {
[16:21:55.592]                             sendCondition <<- function(cond) {
[16:21:55.592]                               data <- list(type = "VALUE", value = cond, 
[16:21:55.592]                                 success = TRUE)
[16:21:55.592]                               parallel_sendData(master, data)
[16:21:55.592]                             }
[16:21:55.592]                             return(sendCondition)
[16:21:55.592]                           }
[16:21:55.592]                         }
[16:21:55.592]                         frame <- frame + 1L
[16:21:55.592]                         envir <- sys.frame(frame)
[16:21:55.592]                       }
[16:21:55.592]                     }
[16:21:55.592]                     sendCondition <<- function(cond) NULL
[16:21:55.592]                   }
[16:21:55.592]                 })
[16:21:55.592]                 withCallingHandlers({
[16:21:55.592]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:55.592]                 }, immediateCondition = function(cond) {
[16:21:55.592]                   sendCondition <- ...future.makeSendCondition()
[16:21:55.592]                   sendCondition(cond)
[16:21:55.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.592]                   {
[16:21:55.592]                     inherits <- base::inherits
[16:21:55.592]                     invokeRestart <- base::invokeRestart
[16:21:55.592]                     is.null <- base::is.null
[16:21:55.592]                     muffled <- FALSE
[16:21:55.592]                     if (inherits(cond, "message")) {
[16:21:55.592]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:55.592]                       if (muffled) 
[16:21:55.592]                         invokeRestart("muffleMessage")
[16:21:55.592]                     }
[16:21:55.592]                     else if (inherits(cond, "warning")) {
[16:21:55.592]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:55.592]                       if (muffled) 
[16:21:55.592]                         invokeRestart("muffleWarning")
[16:21:55.592]                     }
[16:21:55.592]                     else if (inherits(cond, "condition")) {
[16:21:55.592]                       if (!is.null(pattern)) {
[16:21:55.592]                         computeRestarts <- base::computeRestarts
[16:21:55.592]                         grepl <- base::grepl
[16:21:55.592]                         restarts <- computeRestarts(cond)
[16:21:55.592]                         for (restart in restarts) {
[16:21:55.592]                           name <- restart$name
[16:21:55.592]                           if (is.null(name)) 
[16:21:55.592]                             next
[16:21:55.592]                           if (!grepl(pattern, name)) 
[16:21:55.592]                             next
[16:21:55.592]                           invokeRestart(restart)
[16:21:55.592]                           muffled <- TRUE
[16:21:55.592]                           break
[16:21:55.592]                         }
[16:21:55.592]                       }
[16:21:55.592]                     }
[16:21:55.592]                     invisible(muffled)
[16:21:55.592]                   }
[16:21:55.592]                   muffleCondition(cond)
[16:21:55.592]                 })
[16:21:55.592]             }))
[16:21:55.592]             future::FutureResult(value = ...future.value$value, 
[16:21:55.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.592]                   ...future.rng), globalenv = if (FALSE) 
[16:21:55.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:55.592]                     ...future.globalenv.names))
[16:21:55.592]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:55.592]         }, condition = base::local({
[16:21:55.592]             c <- base::c
[16:21:55.592]             inherits <- base::inherits
[16:21:55.592]             invokeRestart <- base::invokeRestart
[16:21:55.592]             length <- base::length
[16:21:55.592]             list <- base::list
[16:21:55.592]             seq.int <- base::seq.int
[16:21:55.592]             signalCondition <- base::signalCondition
[16:21:55.592]             sys.calls <- base::sys.calls
[16:21:55.592]             `[[` <- base::`[[`
[16:21:55.592]             `+` <- base::`+`
[16:21:55.592]             `<<-` <- base::`<<-`
[16:21:55.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:55.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:55.592]                   3L)]
[16:21:55.592]             }
[16:21:55.592]             function(cond) {
[16:21:55.592]                 is_error <- inherits(cond, "error")
[16:21:55.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:55.592]                   NULL)
[16:21:55.592]                 if (is_error) {
[16:21:55.592]                   sessionInformation <- function() {
[16:21:55.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:55.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:55.592]                       search = base::search(), system = base::Sys.info())
[16:21:55.592]                   }
[16:21:55.592]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:55.592]                     cond$call), session = sessionInformation(), 
[16:21:55.592]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:55.592]                   signalCondition(cond)
[16:21:55.592]                 }
[16:21:55.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:55.592]                 "immediateCondition"))) {
[16:21:55.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:55.592]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:55.592]                   if (TRUE && !signal) {
[16:21:55.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.592]                     {
[16:21:55.592]                       inherits <- base::inherits
[16:21:55.592]                       invokeRestart <- base::invokeRestart
[16:21:55.592]                       is.null <- base::is.null
[16:21:55.592]                       muffled <- FALSE
[16:21:55.592]                       if (inherits(cond, "message")) {
[16:21:55.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.592]                         if (muffled) 
[16:21:55.592]                           invokeRestart("muffleMessage")
[16:21:55.592]                       }
[16:21:55.592]                       else if (inherits(cond, "warning")) {
[16:21:55.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.592]                         if (muffled) 
[16:21:55.592]                           invokeRestart("muffleWarning")
[16:21:55.592]                       }
[16:21:55.592]                       else if (inherits(cond, "condition")) {
[16:21:55.592]                         if (!is.null(pattern)) {
[16:21:55.592]                           computeRestarts <- base::computeRestarts
[16:21:55.592]                           grepl <- base::grepl
[16:21:55.592]                           restarts <- computeRestarts(cond)
[16:21:55.592]                           for (restart in restarts) {
[16:21:55.592]                             name <- restart$name
[16:21:55.592]                             if (is.null(name)) 
[16:21:55.592]                               next
[16:21:55.592]                             if (!grepl(pattern, name)) 
[16:21:55.592]                               next
[16:21:55.592]                             invokeRestart(restart)
[16:21:55.592]                             muffled <- TRUE
[16:21:55.592]                             break
[16:21:55.592]                           }
[16:21:55.592]                         }
[16:21:55.592]                       }
[16:21:55.592]                       invisible(muffled)
[16:21:55.592]                     }
[16:21:55.592]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.592]                   }
[16:21:55.592]                 }
[16:21:55.592]                 else {
[16:21:55.592]                   if (TRUE) {
[16:21:55.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.592]                     {
[16:21:55.592]                       inherits <- base::inherits
[16:21:55.592]                       invokeRestart <- base::invokeRestart
[16:21:55.592]                       is.null <- base::is.null
[16:21:55.592]                       muffled <- FALSE
[16:21:55.592]                       if (inherits(cond, "message")) {
[16:21:55.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.592]                         if (muffled) 
[16:21:55.592]                           invokeRestart("muffleMessage")
[16:21:55.592]                       }
[16:21:55.592]                       else if (inherits(cond, "warning")) {
[16:21:55.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.592]                         if (muffled) 
[16:21:55.592]                           invokeRestart("muffleWarning")
[16:21:55.592]                       }
[16:21:55.592]                       else if (inherits(cond, "condition")) {
[16:21:55.592]                         if (!is.null(pattern)) {
[16:21:55.592]                           computeRestarts <- base::computeRestarts
[16:21:55.592]                           grepl <- base::grepl
[16:21:55.592]                           restarts <- computeRestarts(cond)
[16:21:55.592]                           for (restart in restarts) {
[16:21:55.592]                             name <- restart$name
[16:21:55.592]                             if (is.null(name)) 
[16:21:55.592]                               next
[16:21:55.592]                             if (!grepl(pattern, name)) 
[16:21:55.592]                               next
[16:21:55.592]                             invokeRestart(restart)
[16:21:55.592]                             muffled <- TRUE
[16:21:55.592]                             break
[16:21:55.592]                           }
[16:21:55.592]                         }
[16:21:55.592]                       }
[16:21:55.592]                       invisible(muffled)
[16:21:55.592]                     }
[16:21:55.592]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.592]                   }
[16:21:55.592]                 }
[16:21:55.592]             }
[16:21:55.592]         }))
[16:21:55.592]     }, error = function(ex) {
[16:21:55.592]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:55.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.592]                 ...future.rng), started = ...future.startTime, 
[16:21:55.592]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:55.592]             version = "1.8"), class = "FutureResult")
[16:21:55.592]     }, finally = {
[16:21:55.592]         if (!identical(...future.workdir, getwd())) 
[16:21:55.592]             setwd(...future.workdir)
[16:21:55.592]         {
[16:21:55.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:55.592]                 ...future.oldOptions$nwarnings <- NULL
[16:21:55.592]             }
[16:21:55.592]             base::options(...future.oldOptions)
[16:21:55.592]             if (.Platform$OS.type == "windows") {
[16:21:55.592]                 old_names <- names(...future.oldEnvVars)
[16:21:55.592]                 envs <- base::Sys.getenv()
[16:21:55.592]                 names <- names(envs)
[16:21:55.592]                 common <- intersect(names, old_names)
[16:21:55.592]                 added <- setdiff(names, old_names)
[16:21:55.592]                 removed <- setdiff(old_names, names)
[16:21:55.592]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:55.592]                   envs[common]]
[16:21:55.592]                 NAMES <- toupper(changed)
[16:21:55.592]                 args <- list()
[16:21:55.592]                 for (kk in seq_along(NAMES)) {
[16:21:55.592]                   name <- changed[[kk]]
[16:21:55.592]                   NAME <- NAMES[[kk]]
[16:21:55.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.592]                     next
[16:21:55.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.592]                 }
[16:21:55.592]                 NAMES <- toupper(added)
[16:21:55.592]                 for (kk in seq_along(NAMES)) {
[16:21:55.592]                   name <- added[[kk]]
[16:21:55.592]                   NAME <- NAMES[[kk]]
[16:21:55.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.592]                     next
[16:21:55.592]                   args[[name]] <- ""
[16:21:55.592]                 }
[16:21:55.592]                 NAMES <- toupper(removed)
[16:21:55.592]                 for (kk in seq_along(NAMES)) {
[16:21:55.592]                   name <- removed[[kk]]
[16:21:55.592]                   NAME <- NAMES[[kk]]
[16:21:55.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.592]                     next
[16:21:55.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.592]                 }
[16:21:55.592]                 if (length(args) > 0) 
[16:21:55.592]                   base::do.call(base::Sys.setenv, args = args)
[16:21:55.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:55.592]             }
[16:21:55.592]             else {
[16:21:55.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:55.592]             }
[16:21:55.592]             {
[16:21:55.592]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:55.592]                   0L) {
[16:21:55.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:55.592]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:55.592]                   base::options(opts)
[16:21:55.592]                 }
[16:21:55.592]                 {
[16:21:55.592]                   {
[16:21:55.592]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:55.592]                     NULL
[16:21:55.592]                   }
[16:21:55.592]                   options(future.plan = NULL)
[16:21:55.592]                   if (is.na(NA_character_)) 
[16:21:55.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:55.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:55.592]                     .init = FALSE)
[16:21:55.592]                 }
[16:21:55.592]             }
[16:21:55.592]         }
[16:21:55.592]     })
[16:21:55.592]     if (TRUE) {
[16:21:55.592]         base::sink(type = "output", split = FALSE)
[16:21:55.592]         if (TRUE) {
[16:21:55.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:55.592]         }
[16:21:55.592]         else {
[16:21:55.592]             ...future.result["stdout"] <- base::list(NULL)
[16:21:55.592]         }
[16:21:55.592]         base::close(...future.stdout)
[16:21:55.592]         ...future.stdout <- NULL
[16:21:55.592]     }
[16:21:55.592]     ...future.result$conditions <- ...future.conditions
[16:21:55.592]     ...future.result$finished <- base::Sys.time()
[16:21:55.592]     ...future.result
[16:21:55.592] }
[16:21:55.595] MultisessionFuture started
[16:21:55.595] - Launch lazy future ... done
[16:21:55.595] run() for ‘MultisessionFuture’ ... done
[16:21:55.597] receiveMessageFromWorker() for ClusterFuture ...
[16:21:55.597] - Validating connection of MultisessionFuture
[16:21:55.598] - received message: FutureResult
[16:21:55.598] - Received FutureResult
[16:21:55.598] - Erased future from FutureRegistry
[16:21:55.598] result() for ClusterFuture ...
[16:21:55.598] - result already collected: FutureResult
[16:21:55.598] result() for ClusterFuture ... done
[16:21:55.598] signalConditions() ...
[16:21:55.598]  - include = ‘immediateCondition’
[16:21:55.598]  - exclude = 
[16:21:55.599]  - resignal = FALSE
[16:21:55.599]  - Number of conditions: 1
[16:21:55.599] signalConditions() ... done
[16:21:55.599] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:55.599] A MultisessionFuture was resolved (result was not collected)
[16:21:55.599] getGlobalsAndPackages() ...
[16:21:55.599] Searching for globals...
[16:21:55.600] - globals found: [2] ‘list’, ‘stop’
[16:21:55.600] Searching for globals ... DONE
[16:21:55.600] Resolving globals: FALSE
[16:21:55.600] 
[16:21:55.600] 
[16:21:55.600] getGlobalsAndPackages() ... DONE
[16:21:55.601] run() for ‘Future’ ...
[16:21:55.601] - state: ‘created’
[16:21:55.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:55.614] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:55.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:55.614]   - Field: ‘node’
[16:21:55.614]   - Field: ‘label’
[16:21:55.615]   - Field: ‘local’
[16:21:55.615]   - Field: ‘owner’
[16:21:55.615]   - Field: ‘envir’
[16:21:55.615]   - Field: ‘workers’
[16:21:55.615]   - Field: ‘packages’
[16:21:55.615]   - Field: ‘gc’
[16:21:55.615]   - Field: ‘conditions’
[16:21:55.615]   - Field: ‘persistent’
[16:21:55.615]   - Field: ‘expr’
[16:21:55.615]   - Field: ‘uuid’
[16:21:55.615]   - Field: ‘seed’
[16:21:55.615]   - Field: ‘version’
[16:21:55.616]   - Field: ‘result’
[16:21:55.616]   - Field: ‘asynchronous’
[16:21:55.616]   - Field: ‘calls’
[16:21:55.616]   - Field: ‘globals’
[16:21:55.616]   - Field: ‘stdout’
[16:21:55.616]   - Field: ‘earlySignal’
[16:21:55.616]   - Field: ‘lazy’
[16:21:55.616]   - Field: ‘state’
[16:21:55.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:55.616] - Launch lazy future ...
[16:21:55.617] Packages needed by the future expression (n = 0): <none>
[16:21:55.617] Packages needed by future strategies (n = 0): <none>
[16:21:55.617] {
[16:21:55.617]     {
[16:21:55.617]         {
[16:21:55.617]             ...future.startTime <- base::Sys.time()
[16:21:55.617]             {
[16:21:55.617]                 {
[16:21:55.617]                   {
[16:21:55.617]                     {
[16:21:55.617]                       base::local({
[16:21:55.617]                         has_future <- base::requireNamespace("future", 
[16:21:55.617]                           quietly = TRUE)
[16:21:55.617]                         if (has_future) {
[16:21:55.617]                           ns <- base::getNamespace("future")
[16:21:55.617]                           version <- ns[[".package"]][["version"]]
[16:21:55.617]                           if (is.null(version)) 
[16:21:55.617]                             version <- utils::packageVersion("future")
[16:21:55.617]                         }
[16:21:55.617]                         else {
[16:21:55.617]                           version <- NULL
[16:21:55.617]                         }
[16:21:55.617]                         if (!has_future || version < "1.8.0") {
[16:21:55.617]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:55.617]                             "", base::R.version$version.string), 
[16:21:55.617]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:55.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:55.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:55.617]                               "release", "version")], collapse = " "), 
[16:21:55.617]                             hostname = base::Sys.info()[["nodename"]])
[16:21:55.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:55.617]                             info)
[16:21:55.617]                           info <- base::paste(info, collapse = "; ")
[16:21:55.617]                           if (!has_future) {
[16:21:55.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:55.617]                               info)
[16:21:55.617]                           }
[16:21:55.617]                           else {
[16:21:55.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:55.617]                               info, version)
[16:21:55.617]                           }
[16:21:55.617]                           base::stop(msg)
[16:21:55.617]                         }
[16:21:55.617]                       })
[16:21:55.617]                     }
[16:21:55.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:55.617]                     base::options(mc.cores = 1L)
[16:21:55.617]                   }
[16:21:55.617]                   ...future.strategy.old <- future::plan("list")
[16:21:55.617]                   options(future.plan = NULL)
[16:21:55.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:55.617]                 }
[16:21:55.617]                 ...future.workdir <- getwd()
[16:21:55.617]             }
[16:21:55.617]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:55.617]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:55.617]         }
[16:21:55.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:55.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:55.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:55.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:55.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:55.617]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:55.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:55.617]             base::names(...future.oldOptions))
[16:21:55.617]     }
[16:21:55.617]     if (FALSE) {
[16:21:55.617]     }
[16:21:55.617]     else {
[16:21:55.617]         if (TRUE) {
[16:21:55.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:55.617]                 open = "w")
[16:21:55.617]         }
[16:21:55.617]         else {
[16:21:55.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:55.617]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:55.617]         }
[16:21:55.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:55.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:55.617]             base::sink(type = "output", split = FALSE)
[16:21:55.617]             base::close(...future.stdout)
[16:21:55.617]         }, add = TRUE)
[16:21:55.617]     }
[16:21:55.617]     ...future.frame <- base::sys.nframe()
[16:21:55.617]     ...future.conditions <- base::list()
[16:21:55.617]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:55.617]     if (FALSE) {
[16:21:55.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:55.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:55.617]     }
[16:21:55.617]     ...future.result <- base::tryCatch({
[16:21:55.617]         base::withCallingHandlers({
[16:21:55.617]             ...future.value <- base::withVisible(base::local({
[16:21:55.617]                 ...future.makeSendCondition <- base::local({
[16:21:55.617]                   sendCondition <- NULL
[16:21:55.617]                   function(frame = 1L) {
[16:21:55.617]                     if (is.function(sendCondition)) 
[16:21:55.617]                       return(sendCondition)
[16:21:55.617]                     ns <- getNamespace("parallel")
[16:21:55.617]                     if (exists("sendData", mode = "function", 
[16:21:55.617]                       envir = ns)) {
[16:21:55.617]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:55.617]                         envir = ns)
[16:21:55.617]                       envir <- sys.frame(frame)
[16:21:55.617]                       master <- NULL
[16:21:55.617]                       while (!identical(envir, .GlobalEnv) && 
[16:21:55.617]                         !identical(envir, emptyenv())) {
[16:21:55.617]                         if (exists("master", mode = "list", envir = envir, 
[16:21:55.617]                           inherits = FALSE)) {
[16:21:55.617]                           master <- get("master", mode = "list", 
[16:21:55.617]                             envir = envir, inherits = FALSE)
[16:21:55.617]                           if (inherits(master, c("SOCKnode", 
[16:21:55.617]                             "SOCK0node"))) {
[16:21:55.617]                             sendCondition <<- function(cond) {
[16:21:55.617]                               data <- list(type = "VALUE", value = cond, 
[16:21:55.617]                                 success = TRUE)
[16:21:55.617]                               parallel_sendData(master, data)
[16:21:55.617]                             }
[16:21:55.617]                             return(sendCondition)
[16:21:55.617]                           }
[16:21:55.617]                         }
[16:21:55.617]                         frame <- frame + 1L
[16:21:55.617]                         envir <- sys.frame(frame)
[16:21:55.617]                       }
[16:21:55.617]                     }
[16:21:55.617]                     sendCondition <<- function(cond) NULL
[16:21:55.617]                   }
[16:21:55.617]                 })
[16:21:55.617]                 withCallingHandlers({
[16:21:55.617]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:55.617]                 }, immediateCondition = function(cond) {
[16:21:55.617]                   sendCondition <- ...future.makeSendCondition()
[16:21:55.617]                   sendCondition(cond)
[16:21:55.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.617]                   {
[16:21:55.617]                     inherits <- base::inherits
[16:21:55.617]                     invokeRestart <- base::invokeRestart
[16:21:55.617]                     is.null <- base::is.null
[16:21:55.617]                     muffled <- FALSE
[16:21:55.617]                     if (inherits(cond, "message")) {
[16:21:55.617]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:55.617]                       if (muffled) 
[16:21:55.617]                         invokeRestart("muffleMessage")
[16:21:55.617]                     }
[16:21:55.617]                     else if (inherits(cond, "warning")) {
[16:21:55.617]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:55.617]                       if (muffled) 
[16:21:55.617]                         invokeRestart("muffleWarning")
[16:21:55.617]                     }
[16:21:55.617]                     else if (inherits(cond, "condition")) {
[16:21:55.617]                       if (!is.null(pattern)) {
[16:21:55.617]                         computeRestarts <- base::computeRestarts
[16:21:55.617]                         grepl <- base::grepl
[16:21:55.617]                         restarts <- computeRestarts(cond)
[16:21:55.617]                         for (restart in restarts) {
[16:21:55.617]                           name <- restart$name
[16:21:55.617]                           if (is.null(name)) 
[16:21:55.617]                             next
[16:21:55.617]                           if (!grepl(pattern, name)) 
[16:21:55.617]                             next
[16:21:55.617]                           invokeRestart(restart)
[16:21:55.617]                           muffled <- TRUE
[16:21:55.617]                           break
[16:21:55.617]                         }
[16:21:55.617]                       }
[16:21:55.617]                     }
[16:21:55.617]                     invisible(muffled)
[16:21:55.617]                   }
[16:21:55.617]                   muffleCondition(cond)
[16:21:55.617]                 })
[16:21:55.617]             }))
[16:21:55.617]             future::FutureResult(value = ...future.value$value, 
[16:21:55.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.617]                   ...future.rng), globalenv = if (FALSE) 
[16:21:55.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:55.617]                     ...future.globalenv.names))
[16:21:55.617]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:55.617]         }, condition = base::local({
[16:21:55.617]             c <- base::c
[16:21:55.617]             inherits <- base::inherits
[16:21:55.617]             invokeRestart <- base::invokeRestart
[16:21:55.617]             length <- base::length
[16:21:55.617]             list <- base::list
[16:21:55.617]             seq.int <- base::seq.int
[16:21:55.617]             signalCondition <- base::signalCondition
[16:21:55.617]             sys.calls <- base::sys.calls
[16:21:55.617]             `[[` <- base::`[[`
[16:21:55.617]             `+` <- base::`+`
[16:21:55.617]             `<<-` <- base::`<<-`
[16:21:55.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:55.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:55.617]                   3L)]
[16:21:55.617]             }
[16:21:55.617]             function(cond) {
[16:21:55.617]                 is_error <- inherits(cond, "error")
[16:21:55.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:55.617]                   NULL)
[16:21:55.617]                 if (is_error) {
[16:21:55.617]                   sessionInformation <- function() {
[16:21:55.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:55.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:55.617]                       search = base::search(), system = base::Sys.info())
[16:21:55.617]                   }
[16:21:55.617]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:55.617]                     cond$call), session = sessionInformation(), 
[16:21:55.617]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:55.617]                   signalCondition(cond)
[16:21:55.617]                 }
[16:21:55.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:55.617]                 "immediateCondition"))) {
[16:21:55.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:55.617]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:55.617]                   if (TRUE && !signal) {
[16:21:55.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.617]                     {
[16:21:55.617]                       inherits <- base::inherits
[16:21:55.617]                       invokeRestart <- base::invokeRestart
[16:21:55.617]                       is.null <- base::is.null
[16:21:55.617]                       muffled <- FALSE
[16:21:55.617]                       if (inherits(cond, "message")) {
[16:21:55.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.617]                         if (muffled) 
[16:21:55.617]                           invokeRestart("muffleMessage")
[16:21:55.617]                       }
[16:21:55.617]                       else if (inherits(cond, "warning")) {
[16:21:55.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.617]                         if (muffled) 
[16:21:55.617]                           invokeRestart("muffleWarning")
[16:21:55.617]                       }
[16:21:55.617]                       else if (inherits(cond, "condition")) {
[16:21:55.617]                         if (!is.null(pattern)) {
[16:21:55.617]                           computeRestarts <- base::computeRestarts
[16:21:55.617]                           grepl <- base::grepl
[16:21:55.617]                           restarts <- computeRestarts(cond)
[16:21:55.617]                           for (restart in restarts) {
[16:21:55.617]                             name <- restart$name
[16:21:55.617]                             if (is.null(name)) 
[16:21:55.617]                               next
[16:21:55.617]                             if (!grepl(pattern, name)) 
[16:21:55.617]                               next
[16:21:55.617]                             invokeRestart(restart)
[16:21:55.617]                             muffled <- TRUE
[16:21:55.617]                             break
[16:21:55.617]                           }
[16:21:55.617]                         }
[16:21:55.617]                       }
[16:21:55.617]                       invisible(muffled)
[16:21:55.617]                     }
[16:21:55.617]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.617]                   }
[16:21:55.617]                 }
[16:21:55.617]                 else {
[16:21:55.617]                   if (TRUE) {
[16:21:55.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.617]                     {
[16:21:55.617]                       inherits <- base::inherits
[16:21:55.617]                       invokeRestart <- base::invokeRestart
[16:21:55.617]                       is.null <- base::is.null
[16:21:55.617]                       muffled <- FALSE
[16:21:55.617]                       if (inherits(cond, "message")) {
[16:21:55.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.617]                         if (muffled) 
[16:21:55.617]                           invokeRestart("muffleMessage")
[16:21:55.617]                       }
[16:21:55.617]                       else if (inherits(cond, "warning")) {
[16:21:55.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.617]                         if (muffled) 
[16:21:55.617]                           invokeRestart("muffleWarning")
[16:21:55.617]                       }
[16:21:55.617]                       else if (inherits(cond, "condition")) {
[16:21:55.617]                         if (!is.null(pattern)) {
[16:21:55.617]                           computeRestarts <- base::computeRestarts
[16:21:55.617]                           grepl <- base::grepl
[16:21:55.617]                           restarts <- computeRestarts(cond)
[16:21:55.617]                           for (restart in restarts) {
[16:21:55.617]                             name <- restart$name
[16:21:55.617]                             if (is.null(name)) 
[16:21:55.617]                               next
[16:21:55.617]                             if (!grepl(pattern, name)) 
[16:21:55.617]                               next
[16:21:55.617]                             invokeRestart(restart)
[16:21:55.617]                             muffled <- TRUE
[16:21:55.617]                             break
[16:21:55.617]                           }
[16:21:55.617]                         }
[16:21:55.617]                       }
[16:21:55.617]                       invisible(muffled)
[16:21:55.617]                     }
[16:21:55.617]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.617]                   }
[16:21:55.617]                 }
[16:21:55.617]             }
[16:21:55.617]         }))
[16:21:55.617]     }, error = function(ex) {
[16:21:55.617]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:55.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.617]                 ...future.rng), started = ...future.startTime, 
[16:21:55.617]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:55.617]             version = "1.8"), class = "FutureResult")
[16:21:55.617]     }, finally = {
[16:21:55.617]         if (!identical(...future.workdir, getwd())) 
[16:21:55.617]             setwd(...future.workdir)
[16:21:55.617]         {
[16:21:55.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:55.617]                 ...future.oldOptions$nwarnings <- NULL
[16:21:55.617]             }
[16:21:55.617]             base::options(...future.oldOptions)
[16:21:55.617]             if (.Platform$OS.type == "windows") {
[16:21:55.617]                 old_names <- names(...future.oldEnvVars)
[16:21:55.617]                 envs <- base::Sys.getenv()
[16:21:55.617]                 names <- names(envs)
[16:21:55.617]                 common <- intersect(names, old_names)
[16:21:55.617]                 added <- setdiff(names, old_names)
[16:21:55.617]                 removed <- setdiff(old_names, names)
[16:21:55.617]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:55.617]                   envs[common]]
[16:21:55.617]                 NAMES <- toupper(changed)
[16:21:55.617]                 args <- list()
[16:21:55.617]                 for (kk in seq_along(NAMES)) {
[16:21:55.617]                   name <- changed[[kk]]
[16:21:55.617]                   NAME <- NAMES[[kk]]
[16:21:55.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.617]                     next
[16:21:55.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.617]                 }
[16:21:55.617]                 NAMES <- toupper(added)
[16:21:55.617]                 for (kk in seq_along(NAMES)) {
[16:21:55.617]                   name <- added[[kk]]
[16:21:55.617]                   NAME <- NAMES[[kk]]
[16:21:55.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.617]                     next
[16:21:55.617]                   args[[name]] <- ""
[16:21:55.617]                 }
[16:21:55.617]                 NAMES <- toupper(removed)
[16:21:55.617]                 for (kk in seq_along(NAMES)) {
[16:21:55.617]                   name <- removed[[kk]]
[16:21:55.617]                   NAME <- NAMES[[kk]]
[16:21:55.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.617]                     next
[16:21:55.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.617]                 }
[16:21:55.617]                 if (length(args) > 0) 
[16:21:55.617]                   base::do.call(base::Sys.setenv, args = args)
[16:21:55.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:55.617]             }
[16:21:55.617]             else {
[16:21:55.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:55.617]             }
[16:21:55.617]             {
[16:21:55.617]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:55.617]                   0L) {
[16:21:55.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:55.617]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:55.617]                   base::options(opts)
[16:21:55.617]                 }
[16:21:55.617]                 {
[16:21:55.617]                   {
[16:21:55.617]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:55.617]                     NULL
[16:21:55.617]                   }
[16:21:55.617]                   options(future.plan = NULL)
[16:21:55.617]                   if (is.na(NA_character_)) 
[16:21:55.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:55.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:55.617]                     .init = FALSE)
[16:21:55.617]                 }
[16:21:55.617]             }
[16:21:55.617]         }
[16:21:55.617]     })
[16:21:55.617]     if (TRUE) {
[16:21:55.617]         base::sink(type = "output", split = FALSE)
[16:21:55.617]         if (TRUE) {
[16:21:55.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:55.617]         }
[16:21:55.617]         else {
[16:21:55.617]             ...future.result["stdout"] <- base::list(NULL)
[16:21:55.617]         }
[16:21:55.617]         base::close(...future.stdout)
[16:21:55.617]         ...future.stdout <- NULL
[16:21:55.617]     }
[16:21:55.617]     ...future.result$conditions <- ...future.conditions
[16:21:55.617]     ...future.result$finished <- base::Sys.time()
[16:21:55.617]     ...future.result
[16:21:55.617] }
[16:21:55.620] MultisessionFuture started
[16:21:55.620] - Launch lazy future ... done
[16:21:55.620] run() for ‘MultisessionFuture’ ... done
[16:21:55.621] receiveMessageFromWorker() for ClusterFuture ...
[16:21:55.621] - Validating connection of MultisessionFuture
[16:21:55.622] - received message: FutureResult
[16:21:55.622] - Received FutureResult
[16:21:55.622] - Erased future from FutureRegistry
[16:21:55.622] result() for ClusterFuture ...
[16:21:55.622] - result already collected: FutureResult
[16:21:55.622] result() for ClusterFuture ... done
[16:21:55.622] signalConditions() ...
[16:21:55.623]  - include = ‘immediateCondition’
[16:21:55.623]  - exclude = 
[16:21:55.623]  - resignal = FALSE
[16:21:55.623]  - Number of conditions: 1
[16:21:55.623] signalConditions() ... done
[16:21:55.623] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:55.623] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[16:21:55.623] getGlobalsAndPackages() ...
[16:21:55.623] Searching for globals...
[16:21:55.624] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:55.625] Searching for globals ... DONE
[16:21:55.625] Resolving globals: FALSE
[16:21:55.625] 
[16:21:55.625] 
[16:21:55.625] getGlobalsAndPackages() ... DONE
[16:21:55.625] run() for ‘Future’ ...
[16:21:55.625] - state: ‘created’
[16:21:55.626] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:55.641] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:55.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:55.641]   - Field: ‘node’
[16:21:55.641]   - Field: ‘label’
[16:21:55.641]   - Field: ‘local’
[16:21:55.641]   - Field: ‘owner’
[16:21:55.641]   - Field: ‘envir’
[16:21:55.641]   - Field: ‘workers’
[16:21:55.641]   - Field: ‘packages’
[16:21:55.642]   - Field: ‘gc’
[16:21:55.642]   - Field: ‘conditions’
[16:21:55.642]   - Field: ‘persistent’
[16:21:55.642]   - Field: ‘expr’
[16:21:55.642]   - Field: ‘uuid’
[16:21:55.642]   - Field: ‘seed’
[16:21:55.642]   - Field: ‘version’
[16:21:55.642]   - Field: ‘result’
[16:21:55.642]   - Field: ‘asynchronous’
[16:21:55.642]   - Field: ‘calls’
[16:21:55.642]   - Field: ‘globals’
[16:21:55.643]   - Field: ‘stdout’
[16:21:55.643]   - Field: ‘earlySignal’
[16:21:55.643]   - Field: ‘lazy’
[16:21:55.643]   - Field: ‘state’
[16:21:55.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:55.643] - Launch lazy future ...
[16:21:55.643] Packages needed by the future expression (n = 0): <none>
[16:21:55.643] Packages needed by future strategies (n = 0): <none>
[16:21:55.644] {
[16:21:55.644]     {
[16:21:55.644]         {
[16:21:55.644]             ...future.startTime <- base::Sys.time()
[16:21:55.644]             {
[16:21:55.644]                 {
[16:21:55.644]                   {
[16:21:55.644]                     {
[16:21:55.644]                       base::local({
[16:21:55.644]                         has_future <- base::requireNamespace("future", 
[16:21:55.644]                           quietly = TRUE)
[16:21:55.644]                         if (has_future) {
[16:21:55.644]                           ns <- base::getNamespace("future")
[16:21:55.644]                           version <- ns[[".package"]][["version"]]
[16:21:55.644]                           if (is.null(version)) 
[16:21:55.644]                             version <- utils::packageVersion("future")
[16:21:55.644]                         }
[16:21:55.644]                         else {
[16:21:55.644]                           version <- NULL
[16:21:55.644]                         }
[16:21:55.644]                         if (!has_future || version < "1.8.0") {
[16:21:55.644]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:55.644]                             "", base::R.version$version.string), 
[16:21:55.644]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:55.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:55.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:55.644]                               "release", "version")], collapse = " "), 
[16:21:55.644]                             hostname = base::Sys.info()[["nodename"]])
[16:21:55.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:55.644]                             info)
[16:21:55.644]                           info <- base::paste(info, collapse = "; ")
[16:21:55.644]                           if (!has_future) {
[16:21:55.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:55.644]                               info)
[16:21:55.644]                           }
[16:21:55.644]                           else {
[16:21:55.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:55.644]                               info, version)
[16:21:55.644]                           }
[16:21:55.644]                           base::stop(msg)
[16:21:55.644]                         }
[16:21:55.644]                       })
[16:21:55.644]                     }
[16:21:55.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:55.644]                     base::options(mc.cores = 1L)
[16:21:55.644]                   }
[16:21:55.644]                   ...future.strategy.old <- future::plan("list")
[16:21:55.644]                   options(future.plan = NULL)
[16:21:55.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:55.644]                 }
[16:21:55.644]                 ...future.workdir <- getwd()
[16:21:55.644]             }
[16:21:55.644]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:55.644]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:55.644]         }
[16:21:55.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:55.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:55.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:55.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:55.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:55.644]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:55.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:55.644]             base::names(...future.oldOptions))
[16:21:55.644]     }
[16:21:55.644]     if (FALSE) {
[16:21:55.644]     }
[16:21:55.644]     else {
[16:21:55.644]         if (TRUE) {
[16:21:55.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:55.644]                 open = "w")
[16:21:55.644]         }
[16:21:55.644]         else {
[16:21:55.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:55.644]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:55.644]         }
[16:21:55.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:55.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:55.644]             base::sink(type = "output", split = FALSE)
[16:21:55.644]             base::close(...future.stdout)
[16:21:55.644]         }, add = TRUE)
[16:21:55.644]     }
[16:21:55.644]     ...future.frame <- base::sys.nframe()
[16:21:55.644]     ...future.conditions <- base::list()
[16:21:55.644]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:55.644]     if (FALSE) {
[16:21:55.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:55.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:55.644]     }
[16:21:55.644]     ...future.result <- base::tryCatch({
[16:21:55.644]         base::withCallingHandlers({
[16:21:55.644]             ...future.value <- base::withVisible(base::local({
[16:21:55.644]                 ...future.makeSendCondition <- base::local({
[16:21:55.644]                   sendCondition <- NULL
[16:21:55.644]                   function(frame = 1L) {
[16:21:55.644]                     if (is.function(sendCondition)) 
[16:21:55.644]                       return(sendCondition)
[16:21:55.644]                     ns <- getNamespace("parallel")
[16:21:55.644]                     if (exists("sendData", mode = "function", 
[16:21:55.644]                       envir = ns)) {
[16:21:55.644]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:55.644]                         envir = ns)
[16:21:55.644]                       envir <- sys.frame(frame)
[16:21:55.644]                       master <- NULL
[16:21:55.644]                       while (!identical(envir, .GlobalEnv) && 
[16:21:55.644]                         !identical(envir, emptyenv())) {
[16:21:55.644]                         if (exists("master", mode = "list", envir = envir, 
[16:21:55.644]                           inherits = FALSE)) {
[16:21:55.644]                           master <- get("master", mode = "list", 
[16:21:55.644]                             envir = envir, inherits = FALSE)
[16:21:55.644]                           if (inherits(master, c("SOCKnode", 
[16:21:55.644]                             "SOCK0node"))) {
[16:21:55.644]                             sendCondition <<- function(cond) {
[16:21:55.644]                               data <- list(type = "VALUE", value = cond, 
[16:21:55.644]                                 success = TRUE)
[16:21:55.644]                               parallel_sendData(master, data)
[16:21:55.644]                             }
[16:21:55.644]                             return(sendCondition)
[16:21:55.644]                           }
[16:21:55.644]                         }
[16:21:55.644]                         frame <- frame + 1L
[16:21:55.644]                         envir <- sys.frame(frame)
[16:21:55.644]                       }
[16:21:55.644]                     }
[16:21:55.644]                     sendCondition <<- function(cond) NULL
[16:21:55.644]                   }
[16:21:55.644]                 })
[16:21:55.644]                 withCallingHandlers({
[16:21:55.644]                   {
[16:21:55.644]                     Sys.sleep(0.5)
[16:21:55.644]                     list(a = 1, b = 42L)
[16:21:55.644]                   }
[16:21:55.644]                 }, immediateCondition = function(cond) {
[16:21:55.644]                   sendCondition <- ...future.makeSendCondition()
[16:21:55.644]                   sendCondition(cond)
[16:21:55.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.644]                   {
[16:21:55.644]                     inherits <- base::inherits
[16:21:55.644]                     invokeRestart <- base::invokeRestart
[16:21:55.644]                     is.null <- base::is.null
[16:21:55.644]                     muffled <- FALSE
[16:21:55.644]                     if (inherits(cond, "message")) {
[16:21:55.644]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:55.644]                       if (muffled) 
[16:21:55.644]                         invokeRestart("muffleMessage")
[16:21:55.644]                     }
[16:21:55.644]                     else if (inherits(cond, "warning")) {
[16:21:55.644]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:55.644]                       if (muffled) 
[16:21:55.644]                         invokeRestart("muffleWarning")
[16:21:55.644]                     }
[16:21:55.644]                     else if (inherits(cond, "condition")) {
[16:21:55.644]                       if (!is.null(pattern)) {
[16:21:55.644]                         computeRestarts <- base::computeRestarts
[16:21:55.644]                         grepl <- base::grepl
[16:21:55.644]                         restarts <- computeRestarts(cond)
[16:21:55.644]                         for (restart in restarts) {
[16:21:55.644]                           name <- restart$name
[16:21:55.644]                           if (is.null(name)) 
[16:21:55.644]                             next
[16:21:55.644]                           if (!grepl(pattern, name)) 
[16:21:55.644]                             next
[16:21:55.644]                           invokeRestart(restart)
[16:21:55.644]                           muffled <- TRUE
[16:21:55.644]                           break
[16:21:55.644]                         }
[16:21:55.644]                       }
[16:21:55.644]                     }
[16:21:55.644]                     invisible(muffled)
[16:21:55.644]                   }
[16:21:55.644]                   muffleCondition(cond)
[16:21:55.644]                 })
[16:21:55.644]             }))
[16:21:55.644]             future::FutureResult(value = ...future.value$value, 
[16:21:55.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.644]                   ...future.rng), globalenv = if (FALSE) 
[16:21:55.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:55.644]                     ...future.globalenv.names))
[16:21:55.644]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:55.644]         }, condition = base::local({
[16:21:55.644]             c <- base::c
[16:21:55.644]             inherits <- base::inherits
[16:21:55.644]             invokeRestart <- base::invokeRestart
[16:21:55.644]             length <- base::length
[16:21:55.644]             list <- base::list
[16:21:55.644]             seq.int <- base::seq.int
[16:21:55.644]             signalCondition <- base::signalCondition
[16:21:55.644]             sys.calls <- base::sys.calls
[16:21:55.644]             `[[` <- base::`[[`
[16:21:55.644]             `+` <- base::`+`
[16:21:55.644]             `<<-` <- base::`<<-`
[16:21:55.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:55.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:55.644]                   3L)]
[16:21:55.644]             }
[16:21:55.644]             function(cond) {
[16:21:55.644]                 is_error <- inherits(cond, "error")
[16:21:55.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:55.644]                   NULL)
[16:21:55.644]                 if (is_error) {
[16:21:55.644]                   sessionInformation <- function() {
[16:21:55.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:55.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:55.644]                       search = base::search(), system = base::Sys.info())
[16:21:55.644]                   }
[16:21:55.644]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:55.644]                     cond$call), session = sessionInformation(), 
[16:21:55.644]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:55.644]                   signalCondition(cond)
[16:21:55.644]                 }
[16:21:55.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:55.644]                 "immediateCondition"))) {
[16:21:55.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:55.644]                   ...future.conditions[[length(...future.conditions) + 
[16:21:55.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:55.644]                   if (TRUE && !signal) {
[16:21:55.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.644]                     {
[16:21:55.644]                       inherits <- base::inherits
[16:21:55.644]                       invokeRestart <- base::invokeRestart
[16:21:55.644]                       is.null <- base::is.null
[16:21:55.644]                       muffled <- FALSE
[16:21:55.644]                       if (inherits(cond, "message")) {
[16:21:55.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.644]                         if (muffled) 
[16:21:55.644]                           invokeRestart("muffleMessage")
[16:21:55.644]                       }
[16:21:55.644]                       else if (inherits(cond, "warning")) {
[16:21:55.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.644]                         if (muffled) 
[16:21:55.644]                           invokeRestart("muffleWarning")
[16:21:55.644]                       }
[16:21:55.644]                       else if (inherits(cond, "condition")) {
[16:21:55.644]                         if (!is.null(pattern)) {
[16:21:55.644]                           computeRestarts <- base::computeRestarts
[16:21:55.644]                           grepl <- base::grepl
[16:21:55.644]                           restarts <- computeRestarts(cond)
[16:21:55.644]                           for (restart in restarts) {
[16:21:55.644]                             name <- restart$name
[16:21:55.644]                             if (is.null(name)) 
[16:21:55.644]                               next
[16:21:55.644]                             if (!grepl(pattern, name)) 
[16:21:55.644]                               next
[16:21:55.644]                             invokeRestart(restart)
[16:21:55.644]                             muffled <- TRUE
[16:21:55.644]                             break
[16:21:55.644]                           }
[16:21:55.644]                         }
[16:21:55.644]                       }
[16:21:55.644]                       invisible(muffled)
[16:21:55.644]                     }
[16:21:55.644]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.644]                   }
[16:21:55.644]                 }
[16:21:55.644]                 else {
[16:21:55.644]                   if (TRUE) {
[16:21:55.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:55.644]                     {
[16:21:55.644]                       inherits <- base::inherits
[16:21:55.644]                       invokeRestart <- base::invokeRestart
[16:21:55.644]                       is.null <- base::is.null
[16:21:55.644]                       muffled <- FALSE
[16:21:55.644]                       if (inherits(cond, "message")) {
[16:21:55.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:55.644]                         if (muffled) 
[16:21:55.644]                           invokeRestart("muffleMessage")
[16:21:55.644]                       }
[16:21:55.644]                       else if (inherits(cond, "warning")) {
[16:21:55.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:55.644]                         if (muffled) 
[16:21:55.644]                           invokeRestart("muffleWarning")
[16:21:55.644]                       }
[16:21:55.644]                       else if (inherits(cond, "condition")) {
[16:21:55.644]                         if (!is.null(pattern)) {
[16:21:55.644]                           computeRestarts <- base::computeRestarts
[16:21:55.644]                           grepl <- base::grepl
[16:21:55.644]                           restarts <- computeRestarts(cond)
[16:21:55.644]                           for (restart in restarts) {
[16:21:55.644]                             name <- restart$name
[16:21:55.644]                             if (is.null(name)) 
[16:21:55.644]                               next
[16:21:55.644]                             if (!grepl(pattern, name)) 
[16:21:55.644]                               next
[16:21:55.644]                             invokeRestart(restart)
[16:21:55.644]                             muffled <- TRUE
[16:21:55.644]                             break
[16:21:55.644]                           }
[16:21:55.644]                         }
[16:21:55.644]                       }
[16:21:55.644]                       invisible(muffled)
[16:21:55.644]                     }
[16:21:55.644]                     muffleCondition(cond, pattern = "^muffle")
[16:21:55.644]                   }
[16:21:55.644]                 }
[16:21:55.644]             }
[16:21:55.644]         }))
[16:21:55.644]     }, error = function(ex) {
[16:21:55.644]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:55.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:55.644]                 ...future.rng), started = ...future.startTime, 
[16:21:55.644]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:55.644]             version = "1.8"), class = "FutureResult")
[16:21:55.644]     }, finally = {
[16:21:55.644]         if (!identical(...future.workdir, getwd())) 
[16:21:55.644]             setwd(...future.workdir)
[16:21:55.644]         {
[16:21:55.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:55.644]                 ...future.oldOptions$nwarnings <- NULL
[16:21:55.644]             }
[16:21:55.644]             base::options(...future.oldOptions)
[16:21:55.644]             if (.Platform$OS.type == "windows") {
[16:21:55.644]                 old_names <- names(...future.oldEnvVars)
[16:21:55.644]                 envs <- base::Sys.getenv()
[16:21:55.644]                 names <- names(envs)
[16:21:55.644]                 common <- intersect(names, old_names)
[16:21:55.644]                 added <- setdiff(names, old_names)
[16:21:55.644]                 removed <- setdiff(old_names, names)
[16:21:55.644]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:55.644]                   envs[common]]
[16:21:55.644]                 NAMES <- toupper(changed)
[16:21:55.644]                 args <- list()
[16:21:55.644]                 for (kk in seq_along(NAMES)) {
[16:21:55.644]                   name <- changed[[kk]]
[16:21:55.644]                   NAME <- NAMES[[kk]]
[16:21:55.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.644]                     next
[16:21:55.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.644]                 }
[16:21:55.644]                 NAMES <- toupper(added)
[16:21:55.644]                 for (kk in seq_along(NAMES)) {
[16:21:55.644]                   name <- added[[kk]]
[16:21:55.644]                   NAME <- NAMES[[kk]]
[16:21:55.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.644]                     next
[16:21:55.644]                   args[[name]] <- ""
[16:21:55.644]                 }
[16:21:55.644]                 NAMES <- toupper(removed)
[16:21:55.644]                 for (kk in seq_along(NAMES)) {
[16:21:55.644]                   name <- removed[[kk]]
[16:21:55.644]                   NAME <- NAMES[[kk]]
[16:21:55.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:55.644]                     next
[16:21:55.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:55.644]                 }
[16:21:55.644]                 if (length(args) > 0) 
[16:21:55.644]                   base::do.call(base::Sys.setenv, args = args)
[16:21:55.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:55.644]             }
[16:21:55.644]             else {
[16:21:55.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:55.644]             }
[16:21:55.644]             {
[16:21:55.644]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:55.644]                   0L) {
[16:21:55.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:55.644]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:55.644]                   base::options(opts)
[16:21:55.644]                 }
[16:21:55.644]                 {
[16:21:55.644]                   {
[16:21:55.644]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:55.644]                     NULL
[16:21:55.644]                   }
[16:21:55.644]                   options(future.plan = NULL)
[16:21:55.644]                   if (is.na(NA_character_)) 
[16:21:55.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:55.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:55.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:55.644]                     .init = FALSE)
[16:21:55.644]                 }
[16:21:55.644]             }
[16:21:55.644]         }
[16:21:55.644]     })
[16:21:55.644]     if (TRUE) {
[16:21:55.644]         base::sink(type = "output", split = FALSE)
[16:21:55.644]         if (TRUE) {
[16:21:55.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:55.644]         }
[16:21:55.644]         else {
[16:21:55.644]             ...future.result["stdout"] <- base::list(NULL)
[16:21:55.644]         }
[16:21:55.644]         base::close(...future.stdout)
[16:21:55.644]         ...future.stdout <- NULL
[16:21:55.644]     }
[16:21:55.644]     ...future.result$conditions <- ...future.conditions
[16:21:55.644]     ...future.result$finished <- base::Sys.time()
[16:21:55.644]     ...future.result
[16:21:55.644] }
[16:21:55.646] MultisessionFuture started
[16:21:55.647] - Launch lazy future ... done
[16:21:55.647] run() for ‘MultisessionFuture’ ... done
[16:21:56.149] receiveMessageFromWorker() for ClusterFuture ...
[16:21:56.149] - Validating connection of MultisessionFuture
[16:21:56.149] - received message: FutureResult
[16:21:56.150] - Received FutureResult
[16:21:56.150] - Erased future from FutureRegistry
[16:21:56.150] result() for ClusterFuture ...
[16:21:56.150] - result already collected: FutureResult
[16:21:56.150] result() for ClusterFuture ... done
[16:21:56.150] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:56.150] A MultisessionFuture was resolved (result was not collected)
[16:21:56.150] getGlobalsAndPackages() ...
[16:21:56.150] Searching for globals...
[16:21:56.152] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:56.152] Searching for globals ... DONE
[16:21:56.152] Resolving globals: FALSE
[16:21:56.152] 
[16:21:56.152] 
[16:21:56.152] getGlobalsAndPackages() ... DONE
[16:21:56.153] run() for ‘Future’ ...
[16:21:56.153] - state: ‘created’
[16:21:56.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:56.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:56.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:56.167]   - Field: ‘node’
[16:21:56.167]   - Field: ‘label’
[16:21:56.167]   - Field: ‘local’
[16:21:56.167]   - Field: ‘owner’
[16:21:56.168]   - Field: ‘envir’
[16:21:56.168]   - Field: ‘workers’
[16:21:56.168]   - Field: ‘packages’
[16:21:56.168]   - Field: ‘gc’
[16:21:56.168]   - Field: ‘conditions’
[16:21:56.168]   - Field: ‘persistent’
[16:21:56.168]   - Field: ‘expr’
[16:21:56.168]   - Field: ‘uuid’
[16:21:56.168]   - Field: ‘seed’
[16:21:56.168]   - Field: ‘version’
[16:21:56.169]   - Field: ‘result’
[16:21:56.169]   - Field: ‘asynchronous’
[16:21:56.169]   - Field: ‘calls’
[16:21:56.169]   - Field: ‘globals’
[16:21:56.169]   - Field: ‘stdout’
[16:21:56.169]   - Field: ‘earlySignal’
[16:21:56.169]   - Field: ‘lazy’
[16:21:56.169]   - Field: ‘state’
[16:21:56.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:56.169] - Launch lazy future ...
[16:21:56.170] Packages needed by the future expression (n = 0): <none>
[16:21:56.170] Packages needed by future strategies (n = 0): <none>
[16:21:56.170] {
[16:21:56.170]     {
[16:21:56.170]         {
[16:21:56.170]             ...future.startTime <- base::Sys.time()
[16:21:56.170]             {
[16:21:56.170]                 {
[16:21:56.170]                   {
[16:21:56.170]                     {
[16:21:56.170]                       base::local({
[16:21:56.170]                         has_future <- base::requireNamespace("future", 
[16:21:56.170]                           quietly = TRUE)
[16:21:56.170]                         if (has_future) {
[16:21:56.170]                           ns <- base::getNamespace("future")
[16:21:56.170]                           version <- ns[[".package"]][["version"]]
[16:21:56.170]                           if (is.null(version)) 
[16:21:56.170]                             version <- utils::packageVersion("future")
[16:21:56.170]                         }
[16:21:56.170]                         else {
[16:21:56.170]                           version <- NULL
[16:21:56.170]                         }
[16:21:56.170]                         if (!has_future || version < "1.8.0") {
[16:21:56.170]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:56.170]                             "", base::R.version$version.string), 
[16:21:56.170]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:56.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:56.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:56.170]                               "release", "version")], collapse = " "), 
[16:21:56.170]                             hostname = base::Sys.info()[["nodename"]])
[16:21:56.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:56.170]                             info)
[16:21:56.170]                           info <- base::paste(info, collapse = "; ")
[16:21:56.170]                           if (!has_future) {
[16:21:56.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:56.170]                               info)
[16:21:56.170]                           }
[16:21:56.170]                           else {
[16:21:56.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:56.170]                               info, version)
[16:21:56.170]                           }
[16:21:56.170]                           base::stop(msg)
[16:21:56.170]                         }
[16:21:56.170]                       })
[16:21:56.170]                     }
[16:21:56.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:56.170]                     base::options(mc.cores = 1L)
[16:21:56.170]                   }
[16:21:56.170]                   ...future.strategy.old <- future::plan("list")
[16:21:56.170]                   options(future.plan = NULL)
[16:21:56.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:56.170]                 }
[16:21:56.170]                 ...future.workdir <- getwd()
[16:21:56.170]             }
[16:21:56.170]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:56.170]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:56.170]         }
[16:21:56.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:56.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:56.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:56.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:56.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:56.170]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:56.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:56.170]             base::names(...future.oldOptions))
[16:21:56.170]     }
[16:21:56.170]     if (FALSE) {
[16:21:56.170]     }
[16:21:56.170]     else {
[16:21:56.170]         if (TRUE) {
[16:21:56.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:56.170]                 open = "w")
[16:21:56.170]         }
[16:21:56.170]         else {
[16:21:56.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:56.170]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:56.170]         }
[16:21:56.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:56.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:56.170]             base::sink(type = "output", split = FALSE)
[16:21:56.170]             base::close(...future.stdout)
[16:21:56.170]         }, add = TRUE)
[16:21:56.170]     }
[16:21:56.170]     ...future.frame <- base::sys.nframe()
[16:21:56.170]     ...future.conditions <- base::list()
[16:21:56.170]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:56.170]     if (FALSE) {
[16:21:56.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:56.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:56.170]     }
[16:21:56.170]     ...future.result <- base::tryCatch({
[16:21:56.170]         base::withCallingHandlers({
[16:21:56.170]             ...future.value <- base::withVisible(base::local({
[16:21:56.170]                 ...future.makeSendCondition <- base::local({
[16:21:56.170]                   sendCondition <- NULL
[16:21:56.170]                   function(frame = 1L) {
[16:21:56.170]                     if (is.function(sendCondition)) 
[16:21:56.170]                       return(sendCondition)
[16:21:56.170]                     ns <- getNamespace("parallel")
[16:21:56.170]                     if (exists("sendData", mode = "function", 
[16:21:56.170]                       envir = ns)) {
[16:21:56.170]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:56.170]                         envir = ns)
[16:21:56.170]                       envir <- sys.frame(frame)
[16:21:56.170]                       master <- NULL
[16:21:56.170]                       while (!identical(envir, .GlobalEnv) && 
[16:21:56.170]                         !identical(envir, emptyenv())) {
[16:21:56.170]                         if (exists("master", mode = "list", envir = envir, 
[16:21:56.170]                           inherits = FALSE)) {
[16:21:56.170]                           master <- get("master", mode = "list", 
[16:21:56.170]                             envir = envir, inherits = FALSE)
[16:21:56.170]                           if (inherits(master, c("SOCKnode", 
[16:21:56.170]                             "SOCK0node"))) {
[16:21:56.170]                             sendCondition <<- function(cond) {
[16:21:56.170]                               data <- list(type = "VALUE", value = cond, 
[16:21:56.170]                                 success = TRUE)
[16:21:56.170]                               parallel_sendData(master, data)
[16:21:56.170]                             }
[16:21:56.170]                             return(sendCondition)
[16:21:56.170]                           }
[16:21:56.170]                         }
[16:21:56.170]                         frame <- frame + 1L
[16:21:56.170]                         envir <- sys.frame(frame)
[16:21:56.170]                       }
[16:21:56.170]                     }
[16:21:56.170]                     sendCondition <<- function(cond) NULL
[16:21:56.170]                   }
[16:21:56.170]                 })
[16:21:56.170]                 withCallingHandlers({
[16:21:56.170]                   {
[16:21:56.170]                     Sys.sleep(0.5)
[16:21:56.170]                     list(a = 1, b = 42L)
[16:21:56.170]                   }
[16:21:56.170]                 }, immediateCondition = function(cond) {
[16:21:56.170]                   sendCondition <- ...future.makeSendCondition()
[16:21:56.170]                   sendCondition(cond)
[16:21:56.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.170]                   {
[16:21:56.170]                     inherits <- base::inherits
[16:21:56.170]                     invokeRestart <- base::invokeRestart
[16:21:56.170]                     is.null <- base::is.null
[16:21:56.170]                     muffled <- FALSE
[16:21:56.170]                     if (inherits(cond, "message")) {
[16:21:56.170]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:56.170]                       if (muffled) 
[16:21:56.170]                         invokeRestart("muffleMessage")
[16:21:56.170]                     }
[16:21:56.170]                     else if (inherits(cond, "warning")) {
[16:21:56.170]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:56.170]                       if (muffled) 
[16:21:56.170]                         invokeRestart("muffleWarning")
[16:21:56.170]                     }
[16:21:56.170]                     else if (inherits(cond, "condition")) {
[16:21:56.170]                       if (!is.null(pattern)) {
[16:21:56.170]                         computeRestarts <- base::computeRestarts
[16:21:56.170]                         grepl <- base::grepl
[16:21:56.170]                         restarts <- computeRestarts(cond)
[16:21:56.170]                         for (restart in restarts) {
[16:21:56.170]                           name <- restart$name
[16:21:56.170]                           if (is.null(name)) 
[16:21:56.170]                             next
[16:21:56.170]                           if (!grepl(pattern, name)) 
[16:21:56.170]                             next
[16:21:56.170]                           invokeRestart(restart)
[16:21:56.170]                           muffled <- TRUE
[16:21:56.170]                           break
[16:21:56.170]                         }
[16:21:56.170]                       }
[16:21:56.170]                     }
[16:21:56.170]                     invisible(muffled)
[16:21:56.170]                   }
[16:21:56.170]                   muffleCondition(cond)
[16:21:56.170]                 })
[16:21:56.170]             }))
[16:21:56.170]             future::FutureResult(value = ...future.value$value, 
[16:21:56.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.170]                   ...future.rng), globalenv = if (FALSE) 
[16:21:56.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:56.170]                     ...future.globalenv.names))
[16:21:56.170]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:56.170]         }, condition = base::local({
[16:21:56.170]             c <- base::c
[16:21:56.170]             inherits <- base::inherits
[16:21:56.170]             invokeRestart <- base::invokeRestart
[16:21:56.170]             length <- base::length
[16:21:56.170]             list <- base::list
[16:21:56.170]             seq.int <- base::seq.int
[16:21:56.170]             signalCondition <- base::signalCondition
[16:21:56.170]             sys.calls <- base::sys.calls
[16:21:56.170]             `[[` <- base::`[[`
[16:21:56.170]             `+` <- base::`+`
[16:21:56.170]             `<<-` <- base::`<<-`
[16:21:56.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:56.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:56.170]                   3L)]
[16:21:56.170]             }
[16:21:56.170]             function(cond) {
[16:21:56.170]                 is_error <- inherits(cond, "error")
[16:21:56.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:56.170]                   NULL)
[16:21:56.170]                 if (is_error) {
[16:21:56.170]                   sessionInformation <- function() {
[16:21:56.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:56.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:56.170]                       search = base::search(), system = base::Sys.info())
[16:21:56.170]                   }
[16:21:56.170]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:56.170]                     cond$call), session = sessionInformation(), 
[16:21:56.170]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:56.170]                   signalCondition(cond)
[16:21:56.170]                 }
[16:21:56.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:56.170]                 "immediateCondition"))) {
[16:21:56.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:56.170]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:56.170]                   if (TRUE && !signal) {
[16:21:56.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.170]                     {
[16:21:56.170]                       inherits <- base::inherits
[16:21:56.170]                       invokeRestart <- base::invokeRestart
[16:21:56.170]                       is.null <- base::is.null
[16:21:56.170]                       muffled <- FALSE
[16:21:56.170]                       if (inherits(cond, "message")) {
[16:21:56.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.170]                         if (muffled) 
[16:21:56.170]                           invokeRestart("muffleMessage")
[16:21:56.170]                       }
[16:21:56.170]                       else if (inherits(cond, "warning")) {
[16:21:56.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.170]                         if (muffled) 
[16:21:56.170]                           invokeRestart("muffleWarning")
[16:21:56.170]                       }
[16:21:56.170]                       else if (inherits(cond, "condition")) {
[16:21:56.170]                         if (!is.null(pattern)) {
[16:21:56.170]                           computeRestarts <- base::computeRestarts
[16:21:56.170]                           grepl <- base::grepl
[16:21:56.170]                           restarts <- computeRestarts(cond)
[16:21:56.170]                           for (restart in restarts) {
[16:21:56.170]                             name <- restart$name
[16:21:56.170]                             if (is.null(name)) 
[16:21:56.170]                               next
[16:21:56.170]                             if (!grepl(pattern, name)) 
[16:21:56.170]                               next
[16:21:56.170]                             invokeRestart(restart)
[16:21:56.170]                             muffled <- TRUE
[16:21:56.170]                             break
[16:21:56.170]                           }
[16:21:56.170]                         }
[16:21:56.170]                       }
[16:21:56.170]                       invisible(muffled)
[16:21:56.170]                     }
[16:21:56.170]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.170]                   }
[16:21:56.170]                 }
[16:21:56.170]                 else {
[16:21:56.170]                   if (TRUE) {
[16:21:56.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.170]                     {
[16:21:56.170]                       inherits <- base::inherits
[16:21:56.170]                       invokeRestart <- base::invokeRestart
[16:21:56.170]                       is.null <- base::is.null
[16:21:56.170]                       muffled <- FALSE
[16:21:56.170]                       if (inherits(cond, "message")) {
[16:21:56.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.170]                         if (muffled) 
[16:21:56.170]                           invokeRestart("muffleMessage")
[16:21:56.170]                       }
[16:21:56.170]                       else if (inherits(cond, "warning")) {
[16:21:56.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.170]                         if (muffled) 
[16:21:56.170]                           invokeRestart("muffleWarning")
[16:21:56.170]                       }
[16:21:56.170]                       else if (inherits(cond, "condition")) {
[16:21:56.170]                         if (!is.null(pattern)) {
[16:21:56.170]                           computeRestarts <- base::computeRestarts
[16:21:56.170]                           grepl <- base::grepl
[16:21:56.170]                           restarts <- computeRestarts(cond)
[16:21:56.170]                           for (restart in restarts) {
[16:21:56.170]                             name <- restart$name
[16:21:56.170]                             if (is.null(name)) 
[16:21:56.170]                               next
[16:21:56.170]                             if (!grepl(pattern, name)) 
[16:21:56.170]                               next
[16:21:56.170]                             invokeRestart(restart)
[16:21:56.170]                             muffled <- TRUE
[16:21:56.170]                             break
[16:21:56.170]                           }
[16:21:56.170]                         }
[16:21:56.170]                       }
[16:21:56.170]                       invisible(muffled)
[16:21:56.170]                     }
[16:21:56.170]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.170]                   }
[16:21:56.170]                 }
[16:21:56.170]             }
[16:21:56.170]         }))
[16:21:56.170]     }, error = function(ex) {
[16:21:56.170]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:56.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.170]                 ...future.rng), started = ...future.startTime, 
[16:21:56.170]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:56.170]             version = "1.8"), class = "FutureResult")
[16:21:56.170]     }, finally = {
[16:21:56.170]         if (!identical(...future.workdir, getwd())) 
[16:21:56.170]             setwd(...future.workdir)
[16:21:56.170]         {
[16:21:56.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:56.170]                 ...future.oldOptions$nwarnings <- NULL
[16:21:56.170]             }
[16:21:56.170]             base::options(...future.oldOptions)
[16:21:56.170]             if (.Platform$OS.type == "windows") {
[16:21:56.170]                 old_names <- names(...future.oldEnvVars)
[16:21:56.170]                 envs <- base::Sys.getenv()
[16:21:56.170]                 names <- names(envs)
[16:21:56.170]                 common <- intersect(names, old_names)
[16:21:56.170]                 added <- setdiff(names, old_names)
[16:21:56.170]                 removed <- setdiff(old_names, names)
[16:21:56.170]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:56.170]                   envs[common]]
[16:21:56.170]                 NAMES <- toupper(changed)
[16:21:56.170]                 args <- list()
[16:21:56.170]                 for (kk in seq_along(NAMES)) {
[16:21:56.170]                   name <- changed[[kk]]
[16:21:56.170]                   NAME <- NAMES[[kk]]
[16:21:56.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.170]                     next
[16:21:56.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.170]                 }
[16:21:56.170]                 NAMES <- toupper(added)
[16:21:56.170]                 for (kk in seq_along(NAMES)) {
[16:21:56.170]                   name <- added[[kk]]
[16:21:56.170]                   NAME <- NAMES[[kk]]
[16:21:56.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.170]                     next
[16:21:56.170]                   args[[name]] <- ""
[16:21:56.170]                 }
[16:21:56.170]                 NAMES <- toupper(removed)
[16:21:56.170]                 for (kk in seq_along(NAMES)) {
[16:21:56.170]                   name <- removed[[kk]]
[16:21:56.170]                   NAME <- NAMES[[kk]]
[16:21:56.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.170]                     next
[16:21:56.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.170]                 }
[16:21:56.170]                 if (length(args) > 0) 
[16:21:56.170]                   base::do.call(base::Sys.setenv, args = args)
[16:21:56.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:56.170]             }
[16:21:56.170]             else {
[16:21:56.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:56.170]             }
[16:21:56.170]             {
[16:21:56.170]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:56.170]                   0L) {
[16:21:56.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:56.170]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:56.170]                   base::options(opts)
[16:21:56.170]                 }
[16:21:56.170]                 {
[16:21:56.170]                   {
[16:21:56.170]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:56.170]                     NULL
[16:21:56.170]                   }
[16:21:56.170]                   options(future.plan = NULL)
[16:21:56.170]                   if (is.na(NA_character_)) 
[16:21:56.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:56.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:56.170]                     .init = FALSE)
[16:21:56.170]                 }
[16:21:56.170]             }
[16:21:56.170]         }
[16:21:56.170]     })
[16:21:56.170]     if (TRUE) {
[16:21:56.170]         base::sink(type = "output", split = FALSE)
[16:21:56.170]         if (TRUE) {
[16:21:56.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:56.170]         }
[16:21:56.170]         else {
[16:21:56.170]             ...future.result["stdout"] <- base::list(NULL)
[16:21:56.170]         }
[16:21:56.170]         base::close(...future.stdout)
[16:21:56.170]         ...future.stdout <- NULL
[16:21:56.170]     }
[16:21:56.170]     ...future.result$conditions <- ...future.conditions
[16:21:56.170]     ...future.result$finished <- base::Sys.time()
[16:21:56.170]     ...future.result
[16:21:56.170] }
[16:21:56.173] MultisessionFuture started
[16:21:56.173] - Launch lazy future ... done
[16:21:56.173] run() for ‘MultisessionFuture’ ... done
[16:21:56.676] receiveMessageFromWorker() for ClusterFuture ...
[16:21:56.676] - Validating connection of MultisessionFuture
[16:21:56.676] - received message: FutureResult
[16:21:56.676] - Received FutureResult
[16:21:56.677] - Erased future from FutureRegistry
[16:21:56.677] result() for ClusterFuture ...
[16:21:56.677] - result already collected: FutureResult
[16:21:56.677] result() for ClusterFuture ... done
[16:21:56.677] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:56.677] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:21:56.677] getGlobalsAndPackages() ...
[16:21:56.677] Searching for globals...
[16:21:56.678] - globals found: [2] ‘list’, ‘stop’
[16:21:56.678] Searching for globals ... DONE
[16:21:56.678] Resolving globals: FALSE
[16:21:56.679] 
[16:21:56.679] 
[16:21:56.679] getGlobalsAndPackages() ... DONE
[16:21:56.679] run() for ‘Future’ ...
[16:21:56.679] - state: ‘created’
[16:21:56.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:56.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:56.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:56.694]   - Field: ‘node’
[16:21:56.694]   - Field: ‘label’
[16:21:56.694]   - Field: ‘local’
[16:21:56.694]   - Field: ‘owner’
[16:21:56.694]   - Field: ‘envir’
[16:21:56.694]   - Field: ‘workers’
[16:21:56.694]   - Field: ‘packages’
[16:21:56.695]   - Field: ‘gc’
[16:21:56.695]   - Field: ‘conditions’
[16:21:56.695]   - Field: ‘persistent’
[16:21:56.695]   - Field: ‘expr’
[16:21:56.695]   - Field: ‘uuid’
[16:21:56.695]   - Field: ‘seed’
[16:21:56.695]   - Field: ‘version’
[16:21:56.695]   - Field: ‘result’
[16:21:56.695]   - Field: ‘asynchronous’
[16:21:56.695]   - Field: ‘calls’
[16:21:56.695]   - Field: ‘globals’
[16:21:56.696]   - Field: ‘stdout’
[16:21:56.696]   - Field: ‘earlySignal’
[16:21:56.696]   - Field: ‘lazy’
[16:21:56.696]   - Field: ‘state’
[16:21:56.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:56.696] - Launch lazy future ...
[16:21:56.696] Packages needed by the future expression (n = 0): <none>
[16:21:56.696] Packages needed by future strategies (n = 0): <none>
[16:21:56.697] {
[16:21:56.697]     {
[16:21:56.697]         {
[16:21:56.697]             ...future.startTime <- base::Sys.time()
[16:21:56.697]             {
[16:21:56.697]                 {
[16:21:56.697]                   {
[16:21:56.697]                     {
[16:21:56.697]                       base::local({
[16:21:56.697]                         has_future <- base::requireNamespace("future", 
[16:21:56.697]                           quietly = TRUE)
[16:21:56.697]                         if (has_future) {
[16:21:56.697]                           ns <- base::getNamespace("future")
[16:21:56.697]                           version <- ns[[".package"]][["version"]]
[16:21:56.697]                           if (is.null(version)) 
[16:21:56.697]                             version <- utils::packageVersion("future")
[16:21:56.697]                         }
[16:21:56.697]                         else {
[16:21:56.697]                           version <- NULL
[16:21:56.697]                         }
[16:21:56.697]                         if (!has_future || version < "1.8.0") {
[16:21:56.697]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:56.697]                             "", base::R.version$version.string), 
[16:21:56.697]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:56.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:56.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:56.697]                               "release", "version")], collapse = " "), 
[16:21:56.697]                             hostname = base::Sys.info()[["nodename"]])
[16:21:56.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:56.697]                             info)
[16:21:56.697]                           info <- base::paste(info, collapse = "; ")
[16:21:56.697]                           if (!has_future) {
[16:21:56.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:56.697]                               info)
[16:21:56.697]                           }
[16:21:56.697]                           else {
[16:21:56.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:56.697]                               info, version)
[16:21:56.697]                           }
[16:21:56.697]                           base::stop(msg)
[16:21:56.697]                         }
[16:21:56.697]                       })
[16:21:56.697]                     }
[16:21:56.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:56.697]                     base::options(mc.cores = 1L)
[16:21:56.697]                   }
[16:21:56.697]                   ...future.strategy.old <- future::plan("list")
[16:21:56.697]                   options(future.plan = NULL)
[16:21:56.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:56.697]                 }
[16:21:56.697]                 ...future.workdir <- getwd()
[16:21:56.697]             }
[16:21:56.697]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:56.697]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:56.697]         }
[16:21:56.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:56.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:56.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:56.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:56.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:56.697]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:56.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:56.697]             base::names(...future.oldOptions))
[16:21:56.697]     }
[16:21:56.697]     if (FALSE) {
[16:21:56.697]     }
[16:21:56.697]     else {
[16:21:56.697]         if (TRUE) {
[16:21:56.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:56.697]                 open = "w")
[16:21:56.697]         }
[16:21:56.697]         else {
[16:21:56.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:56.697]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:56.697]         }
[16:21:56.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:56.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:56.697]             base::sink(type = "output", split = FALSE)
[16:21:56.697]             base::close(...future.stdout)
[16:21:56.697]         }, add = TRUE)
[16:21:56.697]     }
[16:21:56.697]     ...future.frame <- base::sys.nframe()
[16:21:56.697]     ...future.conditions <- base::list()
[16:21:56.697]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:56.697]     if (FALSE) {
[16:21:56.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:56.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:56.697]     }
[16:21:56.697]     ...future.result <- base::tryCatch({
[16:21:56.697]         base::withCallingHandlers({
[16:21:56.697]             ...future.value <- base::withVisible(base::local({
[16:21:56.697]                 ...future.makeSendCondition <- base::local({
[16:21:56.697]                   sendCondition <- NULL
[16:21:56.697]                   function(frame = 1L) {
[16:21:56.697]                     if (is.function(sendCondition)) 
[16:21:56.697]                       return(sendCondition)
[16:21:56.697]                     ns <- getNamespace("parallel")
[16:21:56.697]                     if (exists("sendData", mode = "function", 
[16:21:56.697]                       envir = ns)) {
[16:21:56.697]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:56.697]                         envir = ns)
[16:21:56.697]                       envir <- sys.frame(frame)
[16:21:56.697]                       master <- NULL
[16:21:56.697]                       while (!identical(envir, .GlobalEnv) && 
[16:21:56.697]                         !identical(envir, emptyenv())) {
[16:21:56.697]                         if (exists("master", mode = "list", envir = envir, 
[16:21:56.697]                           inherits = FALSE)) {
[16:21:56.697]                           master <- get("master", mode = "list", 
[16:21:56.697]                             envir = envir, inherits = FALSE)
[16:21:56.697]                           if (inherits(master, c("SOCKnode", 
[16:21:56.697]                             "SOCK0node"))) {
[16:21:56.697]                             sendCondition <<- function(cond) {
[16:21:56.697]                               data <- list(type = "VALUE", value = cond, 
[16:21:56.697]                                 success = TRUE)
[16:21:56.697]                               parallel_sendData(master, data)
[16:21:56.697]                             }
[16:21:56.697]                             return(sendCondition)
[16:21:56.697]                           }
[16:21:56.697]                         }
[16:21:56.697]                         frame <- frame + 1L
[16:21:56.697]                         envir <- sys.frame(frame)
[16:21:56.697]                       }
[16:21:56.697]                     }
[16:21:56.697]                     sendCondition <<- function(cond) NULL
[16:21:56.697]                   }
[16:21:56.697]                 })
[16:21:56.697]                 withCallingHandlers({
[16:21:56.697]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:56.697]                 }, immediateCondition = function(cond) {
[16:21:56.697]                   sendCondition <- ...future.makeSendCondition()
[16:21:56.697]                   sendCondition(cond)
[16:21:56.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.697]                   {
[16:21:56.697]                     inherits <- base::inherits
[16:21:56.697]                     invokeRestart <- base::invokeRestart
[16:21:56.697]                     is.null <- base::is.null
[16:21:56.697]                     muffled <- FALSE
[16:21:56.697]                     if (inherits(cond, "message")) {
[16:21:56.697]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:56.697]                       if (muffled) 
[16:21:56.697]                         invokeRestart("muffleMessage")
[16:21:56.697]                     }
[16:21:56.697]                     else if (inherits(cond, "warning")) {
[16:21:56.697]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:56.697]                       if (muffled) 
[16:21:56.697]                         invokeRestart("muffleWarning")
[16:21:56.697]                     }
[16:21:56.697]                     else if (inherits(cond, "condition")) {
[16:21:56.697]                       if (!is.null(pattern)) {
[16:21:56.697]                         computeRestarts <- base::computeRestarts
[16:21:56.697]                         grepl <- base::grepl
[16:21:56.697]                         restarts <- computeRestarts(cond)
[16:21:56.697]                         for (restart in restarts) {
[16:21:56.697]                           name <- restart$name
[16:21:56.697]                           if (is.null(name)) 
[16:21:56.697]                             next
[16:21:56.697]                           if (!grepl(pattern, name)) 
[16:21:56.697]                             next
[16:21:56.697]                           invokeRestart(restart)
[16:21:56.697]                           muffled <- TRUE
[16:21:56.697]                           break
[16:21:56.697]                         }
[16:21:56.697]                       }
[16:21:56.697]                     }
[16:21:56.697]                     invisible(muffled)
[16:21:56.697]                   }
[16:21:56.697]                   muffleCondition(cond)
[16:21:56.697]                 })
[16:21:56.697]             }))
[16:21:56.697]             future::FutureResult(value = ...future.value$value, 
[16:21:56.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.697]                   ...future.rng), globalenv = if (FALSE) 
[16:21:56.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:56.697]                     ...future.globalenv.names))
[16:21:56.697]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:56.697]         }, condition = base::local({
[16:21:56.697]             c <- base::c
[16:21:56.697]             inherits <- base::inherits
[16:21:56.697]             invokeRestart <- base::invokeRestart
[16:21:56.697]             length <- base::length
[16:21:56.697]             list <- base::list
[16:21:56.697]             seq.int <- base::seq.int
[16:21:56.697]             signalCondition <- base::signalCondition
[16:21:56.697]             sys.calls <- base::sys.calls
[16:21:56.697]             `[[` <- base::`[[`
[16:21:56.697]             `+` <- base::`+`
[16:21:56.697]             `<<-` <- base::`<<-`
[16:21:56.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:56.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:56.697]                   3L)]
[16:21:56.697]             }
[16:21:56.697]             function(cond) {
[16:21:56.697]                 is_error <- inherits(cond, "error")
[16:21:56.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:56.697]                   NULL)
[16:21:56.697]                 if (is_error) {
[16:21:56.697]                   sessionInformation <- function() {
[16:21:56.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:56.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:56.697]                       search = base::search(), system = base::Sys.info())
[16:21:56.697]                   }
[16:21:56.697]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:56.697]                     cond$call), session = sessionInformation(), 
[16:21:56.697]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:56.697]                   signalCondition(cond)
[16:21:56.697]                 }
[16:21:56.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:56.697]                 "immediateCondition"))) {
[16:21:56.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:56.697]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:56.697]                   if (TRUE && !signal) {
[16:21:56.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.697]                     {
[16:21:56.697]                       inherits <- base::inherits
[16:21:56.697]                       invokeRestart <- base::invokeRestart
[16:21:56.697]                       is.null <- base::is.null
[16:21:56.697]                       muffled <- FALSE
[16:21:56.697]                       if (inherits(cond, "message")) {
[16:21:56.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.697]                         if (muffled) 
[16:21:56.697]                           invokeRestart("muffleMessage")
[16:21:56.697]                       }
[16:21:56.697]                       else if (inherits(cond, "warning")) {
[16:21:56.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.697]                         if (muffled) 
[16:21:56.697]                           invokeRestart("muffleWarning")
[16:21:56.697]                       }
[16:21:56.697]                       else if (inherits(cond, "condition")) {
[16:21:56.697]                         if (!is.null(pattern)) {
[16:21:56.697]                           computeRestarts <- base::computeRestarts
[16:21:56.697]                           grepl <- base::grepl
[16:21:56.697]                           restarts <- computeRestarts(cond)
[16:21:56.697]                           for (restart in restarts) {
[16:21:56.697]                             name <- restart$name
[16:21:56.697]                             if (is.null(name)) 
[16:21:56.697]                               next
[16:21:56.697]                             if (!grepl(pattern, name)) 
[16:21:56.697]                               next
[16:21:56.697]                             invokeRestart(restart)
[16:21:56.697]                             muffled <- TRUE
[16:21:56.697]                             break
[16:21:56.697]                           }
[16:21:56.697]                         }
[16:21:56.697]                       }
[16:21:56.697]                       invisible(muffled)
[16:21:56.697]                     }
[16:21:56.697]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.697]                   }
[16:21:56.697]                 }
[16:21:56.697]                 else {
[16:21:56.697]                   if (TRUE) {
[16:21:56.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.697]                     {
[16:21:56.697]                       inherits <- base::inherits
[16:21:56.697]                       invokeRestart <- base::invokeRestart
[16:21:56.697]                       is.null <- base::is.null
[16:21:56.697]                       muffled <- FALSE
[16:21:56.697]                       if (inherits(cond, "message")) {
[16:21:56.697]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.697]                         if (muffled) 
[16:21:56.697]                           invokeRestart("muffleMessage")
[16:21:56.697]                       }
[16:21:56.697]                       else if (inherits(cond, "warning")) {
[16:21:56.697]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.697]                         if (muffled) 
[16:21:56.697]                           invokeRestart("muffleWarning")
[16:21:56.697]                       }
[16:21:56.697]                       else if (inherits(cond, "condition")) {
[16:21:56.697]                         if (!is.null(pattern)) {
[16:21:56.697]                           computeRestarts <- base::computeRestarts
[16:21:56.697]                           grepl <- base::grepl
[16:21:56.697]                           restarts <- computeRestarts(cond)
[16:21:56.697]                           for (restart in restarts) {
[16:21:56.697]                             name <- restart$name
[16:21:56.697]                             if (is.null(name)) 
[16:21:56.697]                               next
[16:21:56.697]                             if (!grepl(pattern, name)) 
[16:21:56.697]                               next
[16:21:56.697]                             invokeRestart(restart)
[16:21:56.697]                             muffled <- TRUE
[16:21:56.697]                             break
[16:21:56.697]                           }
[16:21:56.697]                         }
[16:21:56.697]                       }
[16:21:56.697]                       invisible(muffled)
[16:21:56.697]                     }
[16:21:56.697]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.697]                   }
[16:21:56.697]                 }
[16:21:56.697]             }
[16:21:56.697]         }))
[16:21:56.697]     }, error = function(ex) {
[16:21:56.697]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:56.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.697]                 ...future.rng), started = ...future.startTime, 
[16:21:56.697]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:56.697]             version = "1.8"), class = "FutureResult")
[16:21:56.697]     }, finally = {
[16:21:56.697]         if (!identical(...future.workdir, getwd())) 
[16:21:56.697]             setwd(...future.workdir)
[16:21:56.697]         {
[16:21:56.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:56.697]                 ...future.oldOptions$nwarnings <- NULL
[16:21:56.697]             }
[16:21:56.697]             base::options(...future.oldOptions)
[16:21:56.697]             if (.Platform$OS.type == "windows") {
[16:21:56.697]                 old_names <- names(...future.oldEnvVars)
[16:21:56.697]                 envs <- base::Sys.getenv()
[16:21:56.697]                 names <- names(envs)
[16:21:56.697]                 common <- intersect(names, old_names)
[16:21:56.697]                 added <- setdiff(names, old_names)
[16:21:56.697]                 removed <- setdiff(old_names, names)
[16:21:56.697]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:56.697]                   envs[common]]
[16:21:56.697]                 NAMES <- toupper(changed)
[16:21:56.697]                 args <- list()
[16:21:56.697]                 for (kk in seq_along(NAMES)) {
[16:21:56.697]                   name <- changed[[kk]]
[16:21:56.697]                   NAME <- NAMES[[kk]]
[16:21:56.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.697]                     next
[16:21:56.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.697]                 }
[16:21:56.697]                 NAMES <- toupper(added)
[16:21:56.697]                 for (kk in seq_along(NAMES)) {
[16:21:56.697]                   name <- added[[kk]]
[16:21:56.697]                   NAME <- NAMES[[kk]]
[16:21:56.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.697]                     next
[16:21:56.697]                   args[[name]] <- ""
[16:21:56.697]                 }
[16:21:56.697]                 NAMES <- toupper(removed)
[16:21:56.697]                 for (kk in seq_along(NAMES)) {
[16:21:56.697]                   name <- removed[[kk]]
[16:21:56.697]                   NAME <- NAMES[[kk]]
[16:21:56.697]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.697]                     next
[16:21:56.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.697]                 }
[16:21:56.697]                 if (length(args) > 0) 
[16:21:56.697]                   base::do.call(base::Sys.setenv, args = args)
[16:21:56.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:56.697]             }
[16:21:56.697]             else {
[16:21:56.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:56.697]             }
[16:21:56.697]             {
[16:21:56.697]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:56.697]                   0L) {
[16:21:56.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:56.697]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:56.697]                   base::options(opts)
[16:21:56.697]                 }
[16:21:56.697]                 {
[16:21:56.697]                   {
[16:21:56.697]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:56.697]                     NULL
[16:21:56.697]                   }
[16:21:56.697]                   options(future.plan = NULL)
[16:21:56.697]                   if (is.na(NA_character_)) 
[16:21:56.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:56.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:56.697]                     .init = FALSE)
[16:21:56.697]                 }
[16:21:56.697]             }
[16:21:56.697]         }
[16:21:56.697]     })
[16:21:56.697]     if (TRUE) {
[16:21:56.697]         base::sink(type = "output", split = FALSE)
[16:21:56.697]         if (TRUE) {
[16:21:56.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:56.697]         }
[16:21:56.697]         else {
[16:21:56.697]             ...future.result["stdout"] <- base::list(NULL)
[16:21:56.697]         }
[16:21:56.697]         base::close(...future.stdout)
[16:21:56.697]         ...future.stdout <- NULL
[16:21:56.697]     }
[16:21:56.697]     ...future.result$conditions <- ...future.conditions
[16:21:56.697]     ...future.result$finished <- base::Sys.time()
[16:21:56.697]     ...future.result
[16:21:56.697] }
[16:21:56.700] MultisessionFuture started
[16:21:56.700] - Launch lazy future ... done
[16:21:56.700] run() for ‘MultisessionFuture’ ... done
[16:21:56.702] receiveMessageFromWorker() for ClusterFuture ...
[16:21:56.702] - Validating connection of MultisessionFuture
[16:21:56.702] - received message: FutureResult
[16:21:56.703] - Received FutureResult
[16:21:56.703] - Erased future from FutureRegistry
[16:21:56.703] result() for ClusterFuture ...
[16:21:56.703] - result already collected: FutureResult
[16:21:56.703] result() for ClusterFuture ... done
[16:21:56.703] signalConditions() ...
[16:21:56.703]  - include = ‘immediateCondition’
[16:21:56.703]  - exclude = 
[16:21:56.703]  - resignal = FALSE
[16:21:56.703]  - Number of conditions: 1
[16:21:56.704] signalConditions() ... done
[16:21:56.704] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:56.704] A MultisessionFuture was resolved (result was not collected)
[16:21:56.704] getGlobalsAndPackages() ...
[16:21:56.704] Searching for globals...
[16:21:56.705] - globals found: [2] ‘list’, ‘stop’
[16:21:56.705] Searching for globals ... DONE
[16:21:56.705] Resolving globals: FALSE
[16:21:56.705] 
[16:21:56.705] 
[16:21:56.705] getGlobalsAndPackages() ... DONE
[16:21:56.706] run() for ‘Future’ ...
[16:21:56.706] - state: ‘created’
[16:21:56.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:56.720] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:56.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:56.721]   - Field: ‘node’
[16:21:56.721]   - Field: ‘label’
[16:21:56.721]   - Field: ‘local’
[16:21:56.721]   - Field: ‘owner’
[16:21:56.721]   - Field: ‘envir’
[16:21:56.721]   - Field: ‘workers’
[16:21:56.721]   - Field: ‘packages’
[16:21:56.721]   - Field: ‘gc’
[16:21:56.721]   - Field: ‘conditions’
[16:21:56.721]   - Field: ‘persistent’
[16:21:56.722]   - Field: ‘expr’
[16:21:56.722]   - Field: ‘uuid’
[16:21:56.722]   - Field: ‘seed’
[16:21:56.722]   - Field: ‘version’
[16:21:56.722]   - Field: ‘result’
[16:21:56.722]   - Field: ‘asynchronous’
[16:21:56.722]   - Field: ‘calls’
[16:21:56.722]   - Field: ‘globals’
[16:21:56.722]   - Field: ‘stdout’
[16:21:56.722]   - Field: ‘earlySignal’
[16:21:56.722]   - Field: ‘lazy’
[16:21:56.722]   - Field: ‘state’
[16:21:56.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:56.723] - Launch lazy future ...
[16:21:56.723] Packages needed by the future expression (n = 0): <none>
[16:21:56.723] Packages needed by future strategies (n = 0): <none>
[16:21:56.723] {
[16:21:56.723]     {
[16:21:56.723]         {
[16:21:56.723]             ...future.startTime <- base::Sys.time()
[16:21:56.723]             {
[16:21:56.723]                 {
[16:21:56.723]                   {
[16:21:56.723]                     {
[16:21:56.723]                       base::local({
[16:21:56.723]                         has_future <- base::requireNamespace("future", 
[16:21:56.723]                           quietly = TRUE)
[16:21:56.723]                         if (has_future) {
[16:21:56.723]                           ns <- base::getNamespace("future")
[16:21:56.723]                           version <- ns[[".package"]][["version"]]
[16:21:56.723]                           if (is.null(version)) 
[16:21:56.723]                             version <- utils::packageVersion("future")
[16:21:56.723]                         }
[16:21:56.723]                         else {
[16:21:56.723]                           version <- NULL
[16:21:56.723]                         }
[16:21:56.723]                         if (!has_future || version < "1.8.0") {
[16:21:56.723]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:56.723]                             "", base::R.version$version.string), 
[16:21:56.723]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:56.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:56.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:56.723]                               "release", "version")], collapse = " "), 
[16:21:56.723]                             hostname = base::Sys.info()[["nodename"]])
[16:21:56.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:56.723]                             info)
[16:21:56.723]                           info <- base::paste(info, collapse = "; ")
[16:21:56.723]                           if (!has_future) {
[16:21:56.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:56.723]                               info)
[16:21:56.723]                           }
[16:21:56.723]                           else {
[16:21:56.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:56.723]                               info, version)
[16:21:56.723]                           }
[16:21:56.723]                           base::stop(msg)
[16:21:56.723]                         }
[16:21:56.723]                       })
[16:21:56.723]                     }
[16:21:56.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:56.723]                     base::options(mc.cores = 1L)
[16:21:56.723]                   }
[16:21:56.723]                   ...future.strategy.old <- future::plan("list")
[16:21:56.723]                   options(future.plan = NULL)
[16:21:56.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:56.723]                 }
[16:21:56.723]                 ...future.workdir <- getwd()
[16:21:56.723]             }
[16:21:56.723]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:56.723]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:56.723]         }
[16:21:56.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:56.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:56.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:56.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:56.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:56.723]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:56.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:56.723]             base::names(...future.oldOptions))
[16:21:56.723]     }
[16:21:56.723]     if (FALSE) {
[16:21:56.723]     }
[16:21:56.723]     else {
[16:21:56.723]         if (TRUE) {
[16:21:56.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:56.723]                 open = "w")
[16:21:56.723]         }
[16:21:56.723]         else {
[16:21:56.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:56.723]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:56.723]         }
[16:21:56.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:56.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:56.723]             base::sink(type = "output", split = FALSE)
[16:21:56.723]             base::close(...future.stdout)
[16:21:56.723]         }, add = TRUE)
[16:21:56.723]     }
[16:21:56.723]     ...future.frame <- base::sys.nframe()
[16:21:56.723]     ...future.conditions <- base::list()
[16:21:56.723]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:56.723]     if (FALSE) {
[16:21:56.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:56.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:56.723]     }
[16:21:56.723]     ...future.result <- base::tryCatch({
[16:21:56.723]         base::withCallingHandlers({
[16:21:56.723]             ...future.value <- base::withVisible(base::local({
[16:21:56.723]                 ...future.makeSendCondition <- base::local({
[16:21:56.723]                   sendCondition <- NULL
[16:21:56.723]                   function(frame = 1L) {
[16:21:56.723]                     if (is.function(sendCondition)) 
[16:21:56.723]                       return(sendCondition)
[16:21:56.723]                     ns <- getNamespace("parallel")
[16:21:56.723]                     if (exists("sendData", mode = "function", 
[16:21:56.723]                       envir = ns)) {
[16:21:56.723]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:56.723]                         envir = ns)
[16:21:56.723]                       envir <- sys.frame(frame)
[16:21:56.723]                       master <- NULL
[16:21:56.723]                       while (!identical(envir, .GlobalEnv) && 
[16:21:56.723]                         !identical(envir, emptyenv())) {
[16:21:56.723]                         if (exists("master", mode = "list", envir = envir, 
[16:21:56.723]                           inherits = FALSE)) {
[16:21:56.723]                           master <- get("master", mode = "list", 
[16:21:56.723]                             envir = envir, inherits = FALSE)
[16:21:56.723]                           if (inherits(master, c("SOCKnode", 
[16:21:56.723]                             "SOCK0node"))) {
[16:21:56.723]                             sendCondition <<- function(cond) {
[16:21:56.723]                               data <- list(type = "VALUE", value = cond, 
[16:21:56.723]                                 success = TRUE)
[16:21:56.723]                               parallel_sendData(master, data)
[16:21:56.723]                             }
[16:21:56.723]                             return(sendCondition)
[16:21:56.723]                           }
[16:21:56.723]                         }
[16:21:56.723]                         frame <- frame + 1L
[16:21:56.723]                         envir <- sys.frame(frame)
[16:21:56.723]                       }
[16:21:56.723]                     }
[16:21:56.723]                     sendCondition <<- function(cond) NULL
[16:21:56.723]                   }
[16:21:56.723]                 })
[16:21:56.723]                 withCallingHandlers({
[16:21:56.723]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:56.723]                 }, immediateCondition = function(cond) {
[16:21:56.723]                   sendCondition <- ...future.makeSendCondition()
[16:21:56.723]                   sendCondition(cond)
[16:21:56.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.723]                   {
[16:21:56.723]                     inherits <- base::inherits
[16:21:56.723]                     invokeRestart <- base::invokeRestart
[16:21:56.723]                     is.null <- base::is.null
[16:21:56.723]                     muffled <- FALSE
[16:21:56.723]                     if (inherits(cond, "message")) {
[16:21:56.723]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:56.723]                       if (muffled) 
[16:21:56.723]                         invokeRestart("muffleMessage")
[16:21:56.723]                     }
[16:21:56.723]                     else if (inherits(cond, "warning")) {
[16:21:56.723]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:56.723]                       if (muffled) 
[16:21:56.723]                         invokeRestart("muffleWarning")
[16:21:56.723]                     }
[16:21:56.723]                     else if (inherits(cond, "condition")) {
[16:21:56.723]                       if (!is.null(pattern)) {
[16:21:56.723]                         computeRestarts <- base::computeRestarts
[16:21:56.723]                         grepl <- base::grepl
[16:21:56.723]                         restarts <- computeRestarts(cond)
[16:21:56.723]                         for (restart in restarts) {
[16:21:56.723]                           name <- restart$name
[16:21:56.723]                           if (is.null(name)) 
[16:21:56.723]                             next
[16:21:56.723]                           if (!grepl(pattern, name)) 
[16:21:56.723]                             next
[16:21:56.723]                           invokeRestart(restart)
[16:21:56.723]                           muffled <- TRUE
[16:21:56.723]                           break
[16:21:56.723]                         }
[16:21:56.723]                       }
[16:21:56.723]                     }
[16:21:56.723]                     invisible(muffled)
[16:21:56.723]                   }
[16:21:56.723]                   muffleCondition(cond)
[16:21:56.723]                 })
[16:21:56.723]             }))
[16:21:56.723]             future::FutureResult(value = ...future.value$value, 
[16:21:56.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.723]                   ...future.rng), globalenv = if (FALSE) 
[16:21:56.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:56.723]                     ...future.globalenv.names))
[16:21:56.723]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:56.723]         }, condition = base::local({
[16:21:56.723]             c <- base::c
[16:21:56.723]             inherits <- base::inherits
[16:21:56.723]             invokeRestart <- base::invokeRestart
[16:21:56.723]             length <- base::length
[16:21:56.723]             list <- base::list
[16:21:56.723]             seq.int <- base::seq.int
[16:21:56.723]             signalCondition <- base::signalCondition
[16:21:56.723]             sys.calls <- base::sys.calls
[16:21:56.723]             `[[` <- base::`[[`
[16:21:56.723]             `+` <- base::`+`
[16:21:56.723]             `<<-` <- base::`<<-`
[16:21:56.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:56.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:56.723]                   3L)]
[16:21:56.723]             }
[16:21:56.723]             function(cond) {
[16:21:56.723]                 is_error <- inherits(cond, "error")
[16:21:56.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:56.723]                   NULL)
[16:21:56.723]                 if (is_error) {
[16:21:56.723]                   sessionInformation <- function() {
[16:21:56.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:56.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:56.723]                       search = base::search(), system = base::Sys.info())
[16:21:56.723]                   }
[16:21:56.723]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:56.723]                     cond$call), session = sessionInformation(), 
[16:21:56.723]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:56.723]                   signalCondition(cond)
[16:21:56.723]                 }
[16:21:56.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:56.723]                 "immediateCondition"))) {
[16:21:56.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:56.723]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:56.723]                   if (TRUE && !signal) {
[16:21:56.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.723]                     {
[16:21:56.723]                       inherits <- base::inherits
[16:21:56.723]                       invokeRestart <- base::invokeRestart
[16:21:56.723]                       is.null <- base::is.null
[16:21:56.723]                       muffled <- FALSE
[16:21:56.723]                       if (inherits(cond, "message")) {
[16:21:56.723]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.723]                         if (muffled) 
[16:21:56.723]                           invokeRestart("muffleMessage")
[16:21:56.723]                       }
[16:21:56.723]                       else if (inherits(cond, "warning")) {
[16:21:56.723]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.723]                         if (muffled) 
[16:21:56.723]                           invokeRestart("muffleWarning")
[16:21:56.723]                       }
[16:21:56.723]                       else if (inherits(cond, "condition")) {
[16:21:56.723]                         if (!is.null(pattern)) {
[16:21:56.723]                           computeRestarts <- base::computeRestarts
[16:21:56.723]                           grepl <- base::grepl
[16:21:56.723]                           restarts <- computeRestarts(cond)
[16:21:56.723]                           for (restart in restarts) {
[16:21:56.723]                             name <- restart$name
[16:21:56.723]                             if (is.null(name)) 
[16:21:56.723]                               next
[16:21:56.723]                             if (!grepl(pattern, name)) 
[16:21:56.723]                               next
[16:21:56.723]                             invokeRestart(restart)
[16:21:56.723]                             muffled <- TRUE
[16:21:56.723]                             break
[16:21:56.723]                           }
[16:21:56.723]                         }
[16:21:56.723]                       }
[16:21:56.723]                       invisible(muffled)
[16:21:56.723]                     }
[16:21:56.723]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.723]                   }
[16:21:56.723]                 }
[16:21:56.723]                 else {
[16:21:56.723]                   if (TRUE) {
[16:21:56.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.723]                     {
[16:21:56.723]                       inherits <- base::inherits
[16:21:56.723]                       invokeRestart <- base::invokeRestart
[16:21:56.723]                       is.null <- base::is.null
[16:21:56.723]                       muffled <- FALSE
[16:21:56.723]                       if (inherits(cond, "message")) {
[16:21:56.723]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.723]                         if (muffled) 
[16:21:56.723]                           invokeRestart("muffleMessage")
[16:21:56.723]                       }
[16:21:56.723]                       else if (inherits(cond, "warning")) {
[16:21:56.723]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.723]                         if (muffled) 
[16:21:56.723]                           invokeRestart("muffleWarning")
[16:21:56.723]                       }
[16:21:56.723]                       else if (inherits(cond, "condition")) {
[16:21:56.723]                         if (!is.null(pattern)) {
[16:21:56.723]                           computeRestarts <- base::computeRestarts
[16:21:56.723]                           grepl <- base::grepl
[16:21:56.723]                           restarts <- computeRestarts(cond)
[16:21:56.723]                           for (restart in restarts) {
[16:21:56.723]                             name <- restart$name
[16:21:56.723]                             if (is.null(name)) 
[16:21:56.723]                               next
[16:21:56.723]                             if (!grepl(pattern, name)) 
[16:21:56.723]                               next
[16:21:56.723]                             invokeRestart(restart)
[16:21:56.723]                             muffled <- TRUE
[16:21:56.723]                             break
[16:21:56.723]                           }
[16:21:56.723]                         }
[16:21:56.723]                       }
[16:21:56.723]                       invisible(muffled)
[16:21:56.723]                     }
[16:21:56.723]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.723]                   }
[16:21:56.723]                 }
[16:21:56.723]             }
[16:21:56.723]         }))
[16:21:56.723]     }, error = function(ex) {
[16:21:56.723]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:56.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.723]                 ...future.rng), started = ...future.startTime, 
[16:21:56.723]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:56.723]             version = "1.8"), class = "FutureResult")
[16:21:56.723]     }, finally = {
[16:21:56.723]         if (!identical(...future.workdir, getwd())) 
[16:21:56.723]             setwd(...future.workdir)
[16:21:56.723]         {
[16:21:56.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:56.723]                 ...future.oldOptions$nwarnings <- NULL
[16:21:56.723]             }
[16:21:56.723]             base::options(...future.oldOptions)
[16:21:56.723]             if (.Platform$OS.type == "windows") {
[16:21:56.723]                 old_names <- names(...future.oldEnvVars)
[16:21:56.723]                 envs <- base::Sys.getenv()
[16:21:56.723]                 names <- names(envs)
[16:21:56.723]                 common <- intersect(names, old_names)
[16:21:56.723]                 added <- setdiff(names, old_names)
[16:21:56.723]                 removed <- setdiff(old_names, names)
[16:21:56.723]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:56.723]                   envs[common]]
[16:21:56.723]                 NAMES <- toupper(changed)
[16:21:56.723]                 args <- list()
[16:21:56.723]                 for (kk in seq_along(NAMES)) {
[16:21:56.723]                   name <- changed[[kk]]
[16:21:56.723]                   NAME <- NAMES[[kk]]
[16:21:56.723]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.723]                     next
[16:21:56.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.723]                 }
[16:21:56.723]                 NAMES <- toupper(added)
[16:21:56.723]                 for (kk in seq_along(NAMES)) {
[16:21:56.723]                   name <- added[[kk]]
[16:21:56.723]                   NAME <- NAMES[[kk]]
[16:21:56.723]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.723]                     next
[16:21:56.723]                   args[[name]] <- ""
[16:21:56.723]                 }
[16:21:56.723]                 NAMES <- toupper(removed)
[16:21:56.723]                 for (kk in seq_along(NAMES)) {
[16:21:56.723]                   name <- removed[[kk]]
[16:21:56.723]                   NAME <- NAMES[[kk]]
[16:21:56.723]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.723]                     next
[16:21:56.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.723]                 }
[16:21:56.723]                 if (length(args) > 0) 
[16:21:56.723]                   base::do.call(base::Sys.setenv, args = args)
[16:21:56.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:56.723]             }
[16:21:56.723]             else {
[16:21:56.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:56.723]             }
[16:21:56.723]             {
[16:21:56.723]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:56.723]                   0L) {
[16:21:56.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:56.723]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:56.723]                   base::options(opts)
[16:21:56.723]                 }
[16:21:56.723]                 {
[16:21:56.723]                   {
[16:21:56.723]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:56.723]                     NULL
[16:21:56.723]                   }
[16:21:56.723]                   options(future.plan = NULL)
[16:21:56.723]                   if (is.na(NA_character_)) 
[16:21:56.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:56.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:56.723]                     .init = FALSE)
[16:21:56.723]                 }
[16:21:56.723]             }
[16:21:56.723]         }
[16:21:56.723]     })
[16:21:56.723]     if (TRUE) {
[16:21:56.723]         base::sink(type = "output", split = FALSE)
[16:21:56.723]         if (TRUE) {
[16:21:56.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:56.723]         }
[16:21:56.723]         else {
[16:21:56.723]             ...future.result["stdout"] <- base::list(NULL)
[16:21:56.723]         }
[16:21:56.723]         base::close(...future.stdout)
[16:21:56.723]         ...future.stdout <- NULL
[16:21:56.723]     }
[16:21:56.723]     ...future.result$conditions <- ...future.conditions
[16:21:56.723]     ...future.result$finished <- base::Sys.time()
[16:21:56.723]     ...future.result
[16:21:56.723] }
[16:21:56.727] MultisessionFuture started
[16:21:56.730] - Launch lazy future ... done
[16:21:56.730] run() for ‘MultisessionFuture’ ... done
[16:21:56.731] receiveMessageFromWorker() for ClusterFuture ...
[16:21:56.731] - Validating connection of MultisessionFuture
[16:21:56.731] - received message: FutureResult
[16:21:56.731] - Received FutureResult
[16:21:56.731] - Erased future from FutureRegistry
[16:21:56.731] result() for ClusterFuture ...
[16:21:56.732] - result already collected: FutureResult
[16:21:56.732] result() for ClusterFuture ... done
[16:21:56.732] signalConditions() ...
[16:21:56.732]  - include = ‘immediateCondition’
[16:21:56.732]  - exclude = 
[16:21:56.732]  - resignal = FALSE
[16:21:56.732]  - Number of conditions: 1
[16:21:56.732] signalConditions() ... done
[16:21:56.732] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:56.732] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[16:21:56.733] getGlobalsAndPackages() ...
[16:21:56.733] Searching for globals...
[16:21:56.734] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:56.734] Searching for globals ... DONE
[16:21:56.734] Resolving globals: FALSE
[16:21:56.734] 
[16:21:56.734] 
[16:21:56.735] getGlobalsAndPackages() ... DONE
[16:21:56.735] run() for ‘Future’ ...
[16:21:56.735] - state: ‘created’
[16:21:56.735] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:56.749] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:56.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:56.749]   - Field: ‘node’
[16:21:56.749]   - Field: ‘label’
[16:21:56.749]   - Field: ‘local’
[16:21:56.749]   - Field: ‘owner’
[16:21:56.749]   - Field: ‘envir’
[16:21:56.749]   - Field: ‘workers’
[16:21:56.749]   - Field: ‘packages’
[16:21:56.750]   - Field: ‘gc’
[16:21:56.750]   - Field: ‘conditions’
[16:21:56.750]   - Field: ‘persistent’
[16:21:56.750]   - Field: ‘expr’
[16:21:56.750]   - Field: ‘uuid’
[16:21:56.750]   - Field: ‘seed’
[16:21:56.750]   - Field: ‘version’
[16:21:56.750]   - Field: ‘result’
[16:21:56.750]   - Field: ‘asynchronous’
[16:21:56.750]   - Field: ‘calls’
[16:21:56.750]   - Field: ‘globals’
[16:21:56.751]   - Field: ‘stdout’
[16:21:56.751]   - Field: ‘earlySignal’
[16:21:56.751]   - Field: ‘lazy’
[16:21:56.751]   - Field: ‘state’
[16:21:56.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:56.751] - Launch lazy future ...
[16:21:56.751] Packages needed by the future expression (n = 0): <none>
[16:21:56.751] Packages needed by future strategies (n = 0): <none>
[16:21:56.752] {
[16:21:56.752]     {
[16:21:56.752]         {
[16:21:56.752]             ...future.startTime <- base::Sys.time()
[16:21:56.752]             {
[16:21:56.752]                 {
[16:21:56.752]                   {
[16:21:56.752]                     {
[16:21:56.752]                       base::local({
[16:21:56.752]                         has_future <- base::requireNamespace("future", 
[16:21:56.752]                           quietly = TRUE)
[16:21:56.752]                         if (has_future) {
[16:21:56.752]                           ns <- base::getNamespace("future")
[16:21:56.752]                           version <- ns[[".package"]][["version"]]
[16:21:56.752]                           if (is.null(version)) 
[16:21:56.752]                             version <- utils::packageVersion("future")
[16:21:56.752]                         }
[16:21:56.752]                         else {
[16:21:56.752]                           version <- NULL
[16:21:56.752]                         }
[16:21:56.752]                         if (!has_future || version < "1.8.0") {
[16:21:56.752]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:56.752]                             "", base::R.version$version.string), 
[16:21:56.752]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:56.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:56.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:56.752]                               "release", "version")], collapse = " "), 
[16:21:56.752]                             hostname = base::Sys.info()[["nodename"]])
[16:21:56.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:56.752]                             info)
[16:21:56.752]                           info <- base::paste(info, collapse = "; ")
[16:21:56.752]                           if (!has_future) {
[16:21:56.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:56.752]                               info)
[16:21:56.752]                           }
[16:21:56.752]                           else {
[16:21:56.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:56.752]                               info, version)
[16:21:56.752]                           }
[16:21:56.752]                           base::stop(msg)
[16:21:56.752]                         }
[16:21:56.752]                       })
[16:21:56.752]                     }
[16:21:56.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:56.752]                     base::options(mc.cores = 1L)
[16:21:56.752]                   }
[16:21:56.752]                   ...future.strategy.old <- future::plan("list")
[16:21:56.752]                   options(future.plan = NULL)
[16:21:56.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:56.752]                 }
[16:21:56.752]                 ...future.workdir <- getwd()
[16:21:56.752]             }
[16:21:56.752]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:56.752]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:56.752]         }
[16:21:56.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:56.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:56.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:56.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:56.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:56.752]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:56.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:56.752]             base::names(...future.oldOptions))
[16:21:56.752]     }
[16:21:56.752]     if (FALSE) {
[16:21:56.752]     }
[16:21:56.752]     else {
[16:21:56.752]         if (TRUE) {
[16:21:56.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:56.752]                 open = "w")
[16:21:56.752]         }
[16:21:56.752]         else {
[16:21:56.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:56.752]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:56.752]         }
[16:21:56.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:56.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:56.752]             base::sink(type = "output", split = FALSE)
[16:21:56.752]             base::close(...future.stdout)
[16:21:56.752]         }, add = TRUE)
[16:21:56.752]     }
[16:21:56.752]     ...future.frame <- base::sys.nframe()
[16:21:56.752]     ...future.conditions <- base::list()
[16:21:56.752]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:56.752]     if (FALSE) {
[16:21:56.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:56.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:56.752]     }
[16:21:56.752]     ...future.result <- base::tryCatch({
[16:21:56.752]         base::withCallingHandlers({
[16:21:56.752]             ...future.value <- base::withVisible(base::local({
[16:21:56.752]                 ...future.makeSendCondition <- base::local({
[16:21:56.752]                   sendCondition <- NULL
[16:21:56.752]                   function(frame = 1L) {
[16:21:56.752]                     if (is.function(sendCondition)) 
[16:21:56.752]                       return(sendCondition)
[16:21:56.752]                     ns <- getNamespace("parallel")
[16:21:56.752]                     if (exists("sendData", mode = "function", 
[16:21:56.752]                       envir = ns)) {
[16:21:56.752]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:56.752]                         envir = ns)
[16:21:56.752]                       envir <- sys.frame(frame)
[16:21:56.752]                       master <- NULL
[16:21:56.752]                       while (!identical(envir, .GlobalEnv) && 
[16:21:56.752]                         !identical(envir, emptyenv())) {
[16:21:56.752]                         if (exists("master", mode = "list", envir = envir, 
[16:21:56.752]                           inherits = FALSE)) {
[16:21:56.752]                           master <- get("master", mode = "list", 
[16:21:56.752]                             envir = envir, inherits = FALSE)
[16:21:56.752]                           if (inherits(master, c("SOCKnode", 
[16:21:56.752]                             "SOCK0node"))) {
[16:21:56.752]                             sendCondition <<- function(cond) {
[16:21:56.752]                               data <- list(type = "VALUE", value = cond, 
[16:21:56.752]                                 success = TRUE)
[16:21:56.752]                               parallel_sendData(master, data)
[16:21:56.752]                             }
[16:21:56.752]                             return(sendCondition)
[16:21:56.752]                           }
[16:21:56.752]                         }
[16:21:56.752]                         frame <- frame + 1L
[16:21:56.752]                         envir <- sys.frame(frame)
[16:21:56.752]                       }
[16:21:56.752]                     }
[16:21:56.752]                     sendCondition <<- function(cond) NULL
[16:21:56.752]                   }
[16:21:56.752]                 })
[16:21:56.752]                 withCallingHandlers({
[16:21:56.752]                   {
[16:21:56.752]                     Sys.sleep(0.5)
[16:21:56.752]                     list(a = 1, b = 42L)
[16:21:56.752]                   }
[16:21:56.752]                 }, immediateCondition = function(cond) {
[16:21:56.752]                   sendCondition <- ...future.makeSendCondition()
[16:21:56.752]                   sendCondition(cond)
[16:21:56.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.752]                   {
[16:21:56.752]                     inherits <- base::inherits
[16:21:56.752]                     invokeRestart <- base::invokeRestart
[16:21:56.752]                     is.null <- base::is.null
[16:21:56.752]                     muffled <- FALSE
[16:21:56.752]                     if (inherits(cond, "message")) {
[16:21:56.752]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:56.752]                       if (muffled) 
[16:21:56.752]                         invokeRestart("muffleMessage")
[16:21:56.752]                     }
[16:21:56.752]                     else if (inherits(cond, "warning")) {
[16:21:56.752]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:56.752]                       if (muffled) 
[16:21:56.752]                         invokeRestart("muffleWarning")
[16:21:56.752]                     }
[16:21:56.752]                     else if (inherits(cond, "condition")) {
[16:21:56.752]                       if (!is.null(pattern)) {
[16:21:56.752]                         computeRestarts <- base::computeRestarts
[16:21:56.752]                         grepl <- base::grepl
[16:21:56.752]                         restarts <- computeRestarts(cond)
[16:21:56.752]                         for (restart in restarts) {
[16:21:56.752]                           name <- restart$name
[16:21:56.752]                           if (is.null(name)) 
[16:21:56.752]                             next
[16:21:56.752]                           if (!grepl(pattern, name)) 
[16:21:56.752]                             next
[16:21:56.752]                           invokeRestart(restart)
[16:21:56.752]                           muffled <- TRUE
[16:21:56.752]                           break
[16:21:56.752]                         }
[16:21:56.752]                       }
[16:21:56.752]                     }
[16:21:56.752]                     invisible(muffled)
[16:21:56.752]                   }
[16:21:56.752]                   muffleCondition(cond)
[16:21:56.752]                 })
[16:21:56.752]             }))
[16:21:56.752]             future::FutureResult(value = ...future.value$value, 
[16:21:56.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.752]                   ...future.rng), globalenv = if (FALSE) 
[16:21:56.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:56.752]                     ...future.globalenv.names))
[16:21:56.752]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:56.752]         }, condition = base::local({
[16:21:56.752]             c <- base::c
[16:21:56.752]             inherits <- base::inherits
[16:21:56.752]             invokeRestart <- base::invokeRestart
[16:21:56.752]             length <- base::length
[16:21:56.752]             list <- base::list
[16:21:56.752]             seq.int <- base::seq.int
[16:21:56.752]             signalCondition <- base::signalCondition
[16:21:56.752]             sys.calls <- base::sys.calls
[16:21:56.752]             `[[` <- base::`[[`
[16:21:56.752]             `+` <- base::`+`
[16:21:56.752]             `<<-` <- base::`<<-`
[16:21:56.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:56.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:56.752]                   3L)]
[16:21:56.752]             }
[16:21:56.752]             function(cond) {
[16:21:56.752]                 is_error <- inherits(cond, "error")
[16:21:56.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:56.752]                   NULL)
[16:21:56.752]                 if (is_error) {
[16:21:56.752]                   sessionInformation <- function() {
[16:21:56.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:56.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:56.752]                       search = base::search(), system = base::Sys.info())
[16:21:56.752]                   }
[16:21:56.752]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:56.752]                     cond$call), session = sessionInformation(), 
[16:21:56.752]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:56.752]                   signalCondition(cond)
[16:21:56.752]                 }
[16:21:56.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:56.752]                 "immediateCondition"))) {
[16:21:56.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:56.752]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:56.752]                   if (TRUE && !signal) {
[16:21:56.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.752]                     {
[16:21:56.752]                       inherits <- base::inherits
[16:21:56.752]                       invokeRestart <- base::invokeRestart
[16:21:56.752]                       is.null <- base::is.null
[16:21:56.752]                       muffled <- FALSE
[16:21:56.752]                       if (inherits(cond, "message")) {
[16:21:56.752]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.752]                         if (muffled) 
[16:21:56.752]                           invokeRestart("muffleMessage")
[16:21:56.752]                       }
[16:21:56.752]                       else if (inherits(cond, "warning")) {
[16:21:56.752]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.752]                         if (muffled) 
[16:21:56.752]                           invokeRestart("muffleWarning")
[16:21:56.752]                       }
[16:21:56.752]                       else if (inherits(cond, "condition")) {
[16:21:56.752]                         if (!is.null(pattern)) {
[16:21:56.752]                           computeRestarts <- base::computeRestarts
[16:21:56.752]                           grepl <- base::grepl
[16:21:56.752]                           restarts <- computeRestarts(cond)
[16:21:56.752]                           for (restart in restarts) {
[16:21:56.752]                             name <- restart$name
[16:21:56.752]                             if (is.null(name)) 
[16:21:56.752]                               next
[16:21:56.752]                             if (!grepl(pattern, name)) 
[16:21:56.752]                               next
[16:21:56.752]                             invokeRestart(restart)
[16:21:56.752]                             muffled <- TRUE
[16:21:56.752]                             break
[16:21:56.752]                           }
[16:21:56.752]                         }
[16:21:56.752]                       }
[16:21:56.752]                       invisible(muffled)
[16:21:56.752]                     }
[16:21:56.752]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.752]                   }
[16:21:56.752]                 }
[16:21:56.752]                 else {
[16:21:56.752]                   if (TRUE) {
[16:21:56.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.752]                     {
[16:21:56.752]                       inherits <- base::inherits
[16:21:56.752]                       invokeRestart <- base::invokeRestart
[16:21:56.752]                       is.null <- base::is.null
[16:21:56.752]                       muffled <- FALSE
[16:21:56.752]                       if (inherits(cond, "message")) {
[16:21:56.752]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.752]                         if (muffled) 
[16:21:56.752]                           invokeRestart("muffleMessage")
[16:21:56.752]                       }
[16:21:56.752]                       else if (inherits(cond, "warning")) {
[16:21:56.752]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.752]                         if (muffled) 
[16:21:56.752]                           invokeRestart("muffleWarning")
[16:21:56.752]                       }
[16:21:56.752]                       else if (inherits(cond, "condition")) {
[16:21:56.752]                         if (!is.null(pattern)) {
[16:21:56.752]                           computeRestarts <- base::computeRestarts
[16:21:56.752]                           grepl <- base::grepl
[16:21:56.752]                           restarts <- computeRestarts(cond)
[16:21:56.752]                           for (restart in restarts) {
[16:21:56.752]                             name <- restart$name
[16:21:56.752]                             if (is.null(name)) 
[16:21:56.752]                               next
[16:21:56.752]                             if (!grepl(pattern, name)) 
[16:21:56.752]                               next
[16:21:56.752]                             invokeRestart(restart)
[16:21:56.752]                             muffled <- TRUE
[16:21:56.752]                             break
[16:21:56.752]                           }
[16:21:56.752]                         }
[16:21:56.752]                       }
[16:21:56.752]                       invisible(muffled)
[16:21:56.752]                     }
[16:21:56.752]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.752]                   }
[16:21:56.752]                 }
[16:21:56.752]             }
[16:21:56.752]         }))
[16:21:56.752]     }, error = function(ex) {
[16:21:56.752]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:56.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.752]                 ...future.rng), started = ...future.startTime, 
[16:21:56.752]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:56.752]             version = "1.8"), class = "FutureResult")
[16:21:56.752]     }, finally = {
[16:21:56.752]         if (!identical(...future.workdir, getwd())) 
[16:21:56.752]             setwd(...future.workdir)
[16:21:56.752]         {
[16:21:56.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:56.752]                 ...future.oldOptions$nwarnings <- NULL
[16:21:56.752]             }
[16:21:56.752]             base::options(...future.oldOptions)
[16:21:56.752]             if (.Platform$OS.type == "windows") {
[16:21:56.752]                 old_names <- names(...future.oldEnvVars)
[16:21:56.752]                 envs <- base::Sys.getenv()
[16:21:56.752]                 names <- names(envs)
[16:21:56.752]                 common <- intersect(names, old_names)
[16:21:56.752]                 added <- setdiff(names, old_names)
[16:21:56.752]                 removed <- setdiff(old_names, names)
[16:21:56.752]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:56.752]                   envs[common]]
[16:21:56.752]                 NAMES <- toupper(changed)
[16:21:56.752]                 args <- list()
[16:21:56.752]                 for (kk in seq_along(NAMES)) {
[16:21:56.752]                   name <- changed[[kk]]
[16:21:56.752]                   NAME <- NAMES[[kk]]
[16:21:56.752]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.752]                     next
[16:21:56.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.752]                 }
[16:21:56.752]                 NAMES <- toupper(added)
[16:21:56.752]                 for (kk in seq_along(NAMES)) {
[16:21:56.752]                   name <- added[[kk]]
[16:21:56.752]                   NAME <- NAMES[[kk]]
[16:21:56.752]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.752]                     next
[16:21:56.752]                   args[[name]] <- ""
[16:21:56.752]                 }
[16:21:56.752]                 NAMES <- toupper(removed)
[16:21:56.752]                 for (kk in seq_along(NAMES)) {
[16:21:56.752]                   name <- removed[[kk]]
[16:21:56.752]                   NAME <- NAMES[[kk]]
[16:21:56.752]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.752]                     next
[16:21:56.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.752]                 }
[16:21:56.752]                 if (length(args) > 0) 
[16:21:56.752]                   base::do.call(base::Sys.setenv, args = args)
[16:21:56.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:56.752]             }
[16:21:56.752]             else {
[16:21:56.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:56.752]             }
[16:21:56.752]             {
[16:21:56.752]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:56.752]                   0L) {
[16:21:56.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:56.752]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:56.752]                   base::options(opts)
[16:21:56.752]                 }
[16:21:56.752]                 {
[16:21:56.752]                   {
[16:21:56.752]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:56.752]                     NULL
[16:21:56.752]                   }
[16:21:56.752]                   options(future.plan = NULL)
[16:21:56.752]                   if (is.na(NA_character_)) 
[16:21:56.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:56.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:56.752]                     .init = FALSE)
[16:21:56.752]                 }
[16:21:56.752]             }
[16:21:56.752]         }
[16:21:56.752]     })
[16:21:56.752]     if (TRUE) {
[16:21:56.752]         base::sink(type = "output", split = FALSE)
[16:21:56.752]         if (TRUE) {
[16:21:56.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:56.752]         }
[16:21:56.752]         else {
[16:21:56.752]             ...future.result["stdout"] <- base::list(NULL)
[16:21:56.752]         }
[16:21:56.752]         base::close(...future.stdout)
[16:21:56.752]         ...future.stdout <- NULL
[16:21:56.752]     }
[16:21:56.752]     ...future.result$conditions <- ...future.conditions
[16:21:56.752]     ...future.result$finished <- base::Sys.time()
[16:21:56.752]     ...future.result
[16:21:56.752] }
[16:21:56.755] MultisessionFuture started
[16:21:56.755] - Launch lazy future ... done
[16:21:56.755] run() for ‘MultisessionFuture’ ... done
[16:21:56.755] getGlobalsAndPackages() ...
[16:21:56.755] Searching for globals...
[16:21:56.757] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:56.757] Searching for globals ... DONE
[16:21:56.757] Resolving globals: FALSE
[16:21:56.757] 
[16:21:56.757] 
[16:21:56.757] getGlobalsAndPackages() ... DONE
- w/ exception ...
[16:21:56.758] getGlobalsAndPackages() ...
[16:21:56.758] Searching for globals...
[16:21:56.758] - globals found: [2] ‘list’, ‘stop’
[16:21:56.759] Searching for globals ... DONE
[16:21:56.759] Resolving globals: FALSE
[16:21:56.759] 
[16:21:56.759] 
[16:21:56.759] getGlobalsAndPackages() ... DONE
[16:21:56.759] run() for ‘Future’ ...
[16:21:56.759] - state: ‘created’
[16:21:56.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:56.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:56.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:56.773]   - Field: ‘node’
[16:21:56.774]   - Field: ‘label’
[16:21:56.774]   - Field: ‘local’
[16:21:56.774]   - Field: ‘owner’
[16:21:56.774]   - Field: ‘envir’
[16:21:56.774]   - Field: ‘workers’
[16:21:56.774]   - Field: ‘packages’
[16:21:56.774]   - Field: ‘gc’
[16:21:56.774]   - Field: ‘conditions’
[16:21:56.774]   - Field: ‘persistent’
[16:21:56.774]   - Field: ‘expr’
[16:21:56.774]   - Field: ‘uuid’
[16:21:56.775]   - Field: ‘seed’
[16:21:56.775]   - Field: ‘version’
[16:21:56.775]   - Field: ‘result’
[16:21:56.775]   - Field: ‘asynchronous’
[16:21:56.775]   - Field: ‘calls’
[16:21:56.775]   - Field: ‘globals’
[16:21:56.775]   - Field: ‘stdout’
[16:21:56.775]   - Field: ‘earlySignal’
[16:21:56.775]   - Field: ‘lazy’
[16:21:56.775]   - Field: ‘state’
[16:21:56.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:56.776] - Launch lazy future ...
[16:21:56.776] Packages needed by the future expression (n = 0): <none>
[16:21:56.776] Packages needed by future strategies (n = 0): <none>
[16:21:56.776] {
[16:21:56.776]     {
[16:21:56.776]         {
[16:21:56.776]             ...future.startTime <- base::Sys.time()
[16:21:56.776]             {
[16:21:56.776]                 {
[16:21:56.776]                   {
[16:21:56.776]                     {
[16:21:56.776]                       base::local({
[16:21:56.776]                         has_future <- base::requireNamespace("future", 
[16:21:56.776]                           quietly = TRUE)
[16:21:56.776]                         if (has_future) {
[16:21:56.776]                           ns <- base::getNamespace("future")
[16:21:56.776]                           version <- ns[[".package"]][["version"]]
[16:21:56.776]                           if (is.null(version)) 
[16:21:56.776]                             version <- utils::packageVersion("future")
[16:21:56.776]                         }
[16:21:56.776]                         else {
[16:21:56.776]                           version <- NULL
[16:21:56.776]                         }
[16:21:56.776]                         if (!has_future || version < "1.8.0") {
[16:21:56.776]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:56.776]                             "", base::R.version$version.string), 
[16:21:56.776]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:56.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:56.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:56.776]                               "release", "version")], collapse = " "), 
[16:21:56.776]                             hostname = base::Sys.info()[["nodename"]])
[16:21:56.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:56.776]                             info)
[16:21:56.776]                           info <- base::paste(info, collapse = "; ")
[16:21:56.776]                           if (!has_future) {
[16:21:56.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:56.776]                               info)
[16:21:56.776]                           }
[16:21:56.776]                           else {
[16:21:56.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:56.776]                               info, version)
[16:21:56.776]                           }
[16:21:56.776]                           base::stop(msg)
[16:21:56.776]                         }
[16:21:56.776]                       })
[16:21:56.776]                     }
[16:21:56.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:56.776]                     base::options(mc.cores = 1L)
[16:21:56.776]                   }
[16:21:56.776]                   ...future.strategy.old <- future::plan("list")
[16:21:56.776]                   options(future.plan = NULL)
[16:21:56.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:56.776]                 }
[16:21:56.776]                 ...future.workdir <- getwd()
[16:21:56.776]             }
[16:21:56.776]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:56.776]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:56.776]         }
[16:21:56.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:56.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:56.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:56.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:56.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:56.776]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:56.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:56.776]             base::names(...future.oldOptions))
[16:21:56.776]     }
[16:21:56.776]     if (FALSE) {
[16:21:56.776]     }
[16:21:56.776]     else {
[16:21:56.776]         if (TRUE) {
[16:21:56.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:56.776]                 open = "w")
[16:21:56.776]         }
[16:21:56.776]         else {
[16:21:56.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:56.776]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:56.776]         }
[16:21:56.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:56.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:56.776]             base::sink(type = "output", split = FALSE)
[16:21:56.776]             base::close(...future.stdout)
[16:21:56.776]         }, add = TRUE)
[16:21:56.776]     }
[16:21:56.776]     ...future.frame <- base::sys.nframe()
[16:21:56.776]     ...future.conditions <- base::list()
[16:21:56.776]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:56.776]     if (FALSE) {
[16:21:56.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:56.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:56.776]     }
[16:21:56.776]     ...future.result <- base::tryCatch({
[16:21:56.776]         base::withCallingHandlers({
[16:21:56.776]             ...future.value <- base::withVisible(base::local({
[16:21:56.776]                 ...future.makeSendCondition <- base::local({
[16:21:56.776]                   sendCondition <- NULL
[16:21:56.776]                   function(frame = 1L) {
[16:21:56.776]                     if (is.function(sendCondition)) 
[16:21:56.776]                       return(sendCondition)
[16:21:56.776]                     ns <- getNamespace("parallel")
[16:21:56.776]                     if (exists("sendData", mode = "function", 
[16:21:56.776]                       envir = ns)) {
[16:21:56.776]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:56.776]                         envir = ns)
[16:21:56.776]                       envir <- sys.frame(frame)
[16:21:56.776]                       master <- NULL
[16:21:56.776]                       while (!identical(envir, .GlobalEnv) && 
[16:21:56.776]                         !identical(envir, emptyenv())) {
[16:21:56.776]                         if (exists("master", mode = "list", envir = envir, 
[16:21:56.776]                           inherits = FALSE)) {
[16:21:56.776]                           master <- get("master", mode = "list", 
[16:21:56.776]                             envir = envir, inherits = FALSE)
[16:21:56.776]                           if (inherits(master, c("SOCKnode", 
[16:21:56.776]                             "SOCK0node"))) {
[16:21:56.776]                             sendCondition <<- function(cond) {
[16:21:56.776]                               data <- list(type = "VALUE", value = cond, 
[16:21:56.776]                                 success = TRUE)
[16:21:56.776]                               parallel_sendData(master, data)
[16:21:56.776]                             }
[16:21:56.776]                             return(sendCondition)
[16:21:56.776]                           }
[16:21:56.776]                         }
[16:21:56.776]                         frame <- frame + 1L
[16:21:56.776]                         envir <- sys.frame(frame)
[16:21:56.776]                       }
[16:21:56.776]                     }
[16:21:56.776]                     sendCondition <<- function(cond) NULL
[16:21:56.776]                   }
[16:21:56.776]                 })
[16:21:56.776]                 withCallingHandlers({
[16:21:56.776]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:56.776]                 }, immediateCondition = function(cond) {
[16:21:56.776]                   sendCondition <- ...future.makeSendCondition()
[16:21:56.776]                   sendCondition(cond)
[16:21:56.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.776]                   {
[16:21:56.776]                     inherits <- base::inherits
[16:21:56.776]                     invokeRestart <- base::invokeRestart
[16:21:56.776]                     is.null <- base::is.null
[16:21:56.776]                     muffled <- FALSE
[16:21:56.776]                     if (inherits(cond, "message")) {
[16:21:56.776]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:56.776]                       if (muffled) 
[16:21:56.776]                         invokeRestart("muffleMessage")
[16:21:56.776]                     }
[16:21:56.776]                     else if (inherits(cond, "warning")) {
[16:21:56.776]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:56.776]                       if (muffled) 
[16:21:56.776]                         invokeRestart("muffleWarning")
[16:21:56.776]                     }
[16:21:56.776]                     else if (inherits(cond, "condition")) {
[16:21:56.776]                       if (!is.null(pattern)) {
[16:21:56.776]                         computeRestarts <- base::computeRestarts
[16:21:56.776]                         grepl <- base::grepl
[16:21:56.776]                         restarts <- computeRestarts(cond)
[16:21:56.776]                         for (restart in restarts) {
[16:21:56.776]                           name <- restart$name
[16:21:56.776]                           if (is.null(name)) 
[16:21:56.776]                             next
[16:21:56.776]                           if (!grepl(pattern, name)) 
[16:21:56.776]                             next
[16:21:56.776]                           invokeRestart(restart)
[16:21:56.776]                           muffled <- TRUE
[16:21:56.776]                           break
[16:21:56.776]                         }
[16:21:56.776]                       }
[16:21:56.776]                     }
[16:21:56.776]                     invisible(muffled)
[16:21:56.776]                   }
[16:21:56.776]                   muffleCondition(cond)
[16:21:56.776]                 })
[16:21:56.776]             }))
[16:21:56.776]             future::FutureResult(value = ...future.value$value, 
[16:21:56.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.776]                   ...future.rng), globalenv = if (FALSE) 
[16:21:56.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:56.776]                     ...future.globalenv.names))
[16:21:56.776]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:56.776]         }, condition = base::local({
[16:21:56.776]             c <- base::c
[16:21:56.776]             inherits <- base::inherits
[16:21:56.776]             invokeRestart <- base::invokeRestart
[16:21:56.776]             length <- base::length
[16:21:56.776]             list <- base::list
[16:21:56.776]             seq.int <- base::seq.int
[16:21:56.776]             signalCondition <- base::signalCondition
[16:21:56.776]             sys.calls <- base::sys.calls
[16:21:56.776]             `[[` <- base::`[[`
[16:21:56.776]             `+` <- base::`+`
[16:21:56.776]             `<<-` <- base::`<<-`
[16:21:56.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:56.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:56.776]                   3L)]
[16:21:56.776]             }
[16:21:56.776]             function(cond) {
[16:21:56.776]                 is_error <- inherits(cond, "error")
[16:21:56.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:56.776]                   NULL)
[16:21:56.776]                 if (is_error) {
[16:21:56.776]                   sessionInformation <- function() {
[16:21:56.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:56.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:56.776]                       search = base::search(), system = base::Sys.info())
[16:21:56.776]                   }
[16:21:56.776]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:56.776]                     cond$call), session = sessionInformation(), 
[16:21:56.776]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:56.776]                   signalCondition(cond)
[16:21:56.776]                 }
[16:21:56.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:56.776]                 "immediateCondition"))) {
[16:21:56.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:56.776]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:56.776]                   if (TRUE && !signal) {
[16:21:56.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.776]                     {
[16:21:56.776]                       inherits <- base::inherits
[16:21:56.776]                       invokeRestart <- base::invokeRestart
[16:21:56.776]                       is.null <- base::is.null
[16:21:56.776]                       muffled <- FALSE
[16:21:56.776]                       if (inherits(cond, "message")) {
[16:21:56.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.776]                         if (muffled) 
[16:21:56.776]                           invokeRestart("muffleMessage")
[16:21:56.776]                       }
[16:21:56.776]                       else if (inherits(cond, "warning")) {
[16:21:56.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.776]                         if (muffled) 
[16:21:56.776]                           invokeRestart("muffleWarning")
[16:21:56.776]                       }
[16:21:56.776]                       else if (inherits(cond, "condition")) {
[16:21:56.776]                         if (!is.null(pattern)) {
[16:21:56.776]                           computeRestarts <- base::computeRestarts
[16:21:56.776]                           grepl <- base::grepl
[16:21:56.776]                           restarts <- computeRestarts(cond)
[16:21:56.776]                           for (restart in restarts) {
[16:21:56.776]                             name <- restart$name
[16:21:56.776]                             if (is.null(name)) 
[16:21:56.776]                               next
[16:21:56.776]                             if (!grepl(pattern, name)) 
[16:21:56.776]                               next
[16:21:56.776]                             invokeRestart(restart)
[16:21:56.776]                             muffled <- TRUE
[16:21:56.776]                             break
[16:21:56.776]                           }
[16:21:56.776]                         }
[16:21:56.776]                       }
[16:21:56.776]                       invisible(muffled)
[16:21:56.776]                     }
[16:21:56.776]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.776]                   }
[16:21:56.776]                 }
[16:21:56.776]                 else {
[16:21:56.776]                   if (TRUE) {
[16:21:56.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.776]                     {
[16:21:56.776]                       inherits <- base::inherits
[16:21:56.776]                       invokeRestart <- base::invokeRestart
[16:21:56.776]                       is.null <- base::is.null
[16:21:56.776]                       muffled <- FALSE
[16:21:56.776]                       if (inherits(cond, "message")) {
[16:21:56.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.776]                         if (muffled) 
[16:21:56.776]                           invokeRestart("muffleMessage")
[16:21:56.776]                       }
[16:21:56.776]                       else if (inherits(cond, "warning")) {
[16:21:56.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.776]                         if (muffled) 
[16:21:56.776]                           invokeRestart("muffleWarning")
[16:21:56.776]                       }
[16:21:56.776]                       else if (inherits(cond, "condition")) {
[16:21:56.776]                         if (!is.null(pattern)) {
[16:21:56.776]                           computeRestarts <- base::computeRestarts
[16:21:56.776]                           grepl <- base::grepl
[16:21:56.776]                           restarts <- computeRestarts(cond)
[16:21:56.776]                           for (restart in restarts) {
[16:21:56.776]                             name <- restart$name
[16:21:56.776]                             if (is.null(name)) 
[16:21:56.776]                               next
[16:21:56.776]                             if (!grepl(pattern, name)) 
[16:21:56.776]                               next
[16:21:56.776]                             invokeRestart(restart)
[16:21:56.776]                             muffled <- TRUE
[16:21:56.776]                             break
[16:21:56.776]                           }
[16:21:56.776]                         }
[16:21:56.776]                       }
[16:21:56.776]                       invisible(muffled)
[16:21:56.776]                     }
[16:21:56.776]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.776]                   }
[16:21:56.776]                 }
[16:21:56.776]             }
[16:21:56.776]         }))
[16:21:56.776]     }, error = function(ex) {
[16:21:56.776]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:56.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.776]                 ...future.rng), started = ...future.startTime, 
[16:21:56.776]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:56.776]             version = "1.8"), class = "FutureResult")
[16:21:56.776]     }, finally = {
[16:21:56.776]         if (!identical(...future.workdir, getwd())) 
[16:21:56.776]             setwd(...future.workdir)
[16:21:56.776]         {
[16:21:56.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:56.776]                 ...future.oldOptions$nwarnings <- NULL
[16:21:56.776]             }
[16:21:56.776]             base::options(...future.oldOptions)
[16:21:56.776]             if (.Platform$OS.type == "windows") {
[16:21:56.776]                 old_names <- names(...future.oldEnvVars)
[16:21:56.776]                 envs <- base::Sys.getenv()
[16:21:56.776]                 names <- names(envs)
[16:21:56.776]                 common <- intersect(names, old_names)
[16:21:56.776]                 added <- setdiff(names, old_names)
[16:21:56.776]                 removed <- setdiff(old_names, names)
[16:21:56.776]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:56.776]                   envs[common]]
[16:21:56.776]                 NAMES <- toupper(changed)
[16:21:56.776]                 args <- list()
[16:21:56.776]                 for (kk in seq_along(NAMES)) {
[16:21:56.776]                   name <- changed[[kk]]
[16:21:56.776]                   NAME <- NAMES[[kk]]
[16:21:56.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.776]                     next
[16:21:56.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.776]                 }
[16:21:56.776]                 NAMES <- toupper(added)
[16:21:56.776]                 for (kk in seq_along(NAMES)) {
[16:21:56.776]                   name <- added[[kk]]
[16:21:56.776]                   NAME <- NAMES[[kk]]
[16:21:56.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.776]                     next
[16:21:56.776]                   args[[name]] <- ""
[16:21:56.776]                 }
[16:21:56.776]                 NAMES <- toupper(removed)
[16:21:56.776]                 for (kk in seq_along(NAMES)) {
[16:21:56.776]                   name <- removed[[kk]]
[16:21:56.776]                   NAME <- NAMES[[kk]]
[16:21:56.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.776]                     next
[16:21:56.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.776]                 }
[16:21:56.776]                 if (length(args) > 0) 
[16:21:56.776]                   base::do.call(base::Sys.setenv, args = args)
[16:21:56.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:56.776]             }
[16:21:56.776]             else {
[16:21:56.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:56.776]             }
[16:21:56.776]             {
[16:21:56.776]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:56.776]                   0L) {
[16:21:56.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:56.776]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:56.776]                   base::options(opts)
[16:21:56.776]                 }
[16:21:56.776]                 {
[16:21:56.776]                   {
[16:21:56.776]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:56.776]                     NULL
[16:21:56.776]                   }
[16:21:56.776]                   options(future.plan = NULL)
[16:21:56.776]                   if (is.na(NA_character_)) 
[16:21:56.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:56.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:56.776]                     .init = FALSE)
[16:21:56.776]                 }
[16:21:56.776]             }
[16:21:56.776]         }
[16:21:56.776]     })
[16:21:56.776]     if (TRUE) {
[16:21:56.776]         base::sink(type = "output", split = FALSE)
[16:21:56.776]         if (TRUE) {
[16:21:56.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:56.776]         }
[16:21:56.776]         else {
[16:21:56.776]             ...future.result["stdout"] <- base::list(NULL)
[16:21:56.776]         }
[16:21:56.776]         base::close(...future.stdout)
[16:21:56.776]         ...future.stdout <- NULL
[16:21:56.776]     }
[16:21:56.776]     ...future.result$conditions <- ...future.conditions
[16:21:56.776]     ...future.result$finished <- base::Sys.time()
[16:21:56.776]     ...future.result
[16:21:56.776] }
[16:21:56.829] MultisessionFuture started
[16:21:56.829] - Launch lazy future ... done
[16:21:56.829] run() for ‘MultisessionFuture’ ... done
[16:21:56.830] getGlobalsAndPackages() ...
[16:21:56.830] Searching for globals...
[16:21:56.831] - globals found: [2] ‘list’, ‘stop’
[16:21:56.831] Searching for globals ... DONE
[16:21:56.831] Resolving globals: FALSE
[16:21:56.832] 
[16:21:56.832] 
[16:21:56.832] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[16:21:56.833] getGlobalsAndPackages() ...
[16:21:56.833] Searching for globals...
[16:21:56.835] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:56.835] Searching for globals ... DONE
[16:21:56.835] Resolving globals: FALSE
[16:21:56.835] 
[16:21:56.835] 
[16:21:56.836] getGlobalsAndPackages() ... DONE
[16:21:56.836] run() for ‘Future’ ...
[16:21:56.836] - state: ‘created’
[16:21:56.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:56.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:56.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:56.851]   - Field: ‘node’
[16:21:56.851]   - Field: ‘label’
[16:21:56.851]   - Field: ‘local’
[16:21:56.851]   - Field: ‘owner’
[16:21:56.851]   - Field: ‘envir’
[16:21:56.851]   - Field: ‘workers’
[16:21:56.851]   - Field: ‘packages’
[16:21:56.851]   - Field: ‘gc’
[16:21:56.851]   - Field: ‘conditions’
[16:21:56.852]   - Field: ‘persistent’
[16:21:56.852]   - Field: ‘expr’
[16:21:56.852]   - Field: ‘uuid’
[16:21:56.852]   - Field: ‘seed’
[16:21:56.852]   - Field: ‘version’
[16:21:56.852]   - Field: ‘result’
[16:21:56.852]   - Field: ‘asynchronous’
[16:21:56.852]   - Field: ‘calls’
[16:21:56.852]   - Field: ‘globals’
[16:21:56.852]   - Field: ‘stdout’
[16:21:56.853]   - Field: ‘earlySignal’
[16:21:56.853]   - Field: ‘lazy’
[16:21:56.853]   - Field: ‘state’
[16:21:56.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:56.853] - Launch lazy future ...
[16:21:56.853] Packages needed by the future expression (n = 0): <none>
[16:21:56.853] Packages needed by future strategies (n = 0): <none>
[16:21:56.854] {
[16:21:56.854]     {
[16:21:56.854]         {
[16:21:56.854]             ...future.startTime <- base::Sys.time()
[16:21:56.854]             {
[16:21:56.854]                 {
[16:21:56.854]                   {
[16:21:56.854]                     {
[16:21:56.854]                       base::local({
[16:21:56.854]                         has_future <- base::requireNamespace("future", 
[16:21:56.854]                           quietly = TRUE)
[16:21:56.854]                         if (has_future) {
[16:21:56.854]                           ns <- base::getNamespace("future")
[16:21:56.854]                           version <- ns[[".package"]][["version"]]
[16:21:56.854]                           if (is.null(version)) 
[16:21:56.854]                             version <- utils::packageVersion("future")
[16:21:56.854]                         }
[16:21:56.854]                         else {
[16:21:56.854]                           version <- NULL
[16:21:56.854]                         }
[16:21:56.854]                         if (!has_future || version < "1.8.0") {
[16:21:56.854]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:56.854]                             "", base::R.version$version.string), 
[16:21:56.854]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:56.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:56.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:56.854]                               "release", "version")], collapse = " "), 
[16:21:56.854]                             hostname = base::Sys.info()[["nodename"]])
[16:21:56.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:56.854]                             info)
[16:21:56.854]                           info <- base::paste(info, collapse = "; ")
[16:21:56.854]                           if (!has_future) {
[16:21:56.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:56.854]                               info)
[16:21:56.854]                           }
[16:21:56.854]                           else {
[16:21:56.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:56.854]                               info, version)
[16:21:56.854]                           }
[16:21:56.854]                           base::stop(msg)
[16:21:56.854]                         }
[16:21:56.854]                       })
[16:21:56.854]                     }
[16:21:56.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:56.854]                     base::options(mc.cores = 1L)
[16:21:56.854]                   }
[16:21:56.854]                   ...future.strategy.old <- future::plan("list")
[16:21:56.854]                   options(future.plan = NULL)
[16:21:56.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:56.854]                 }
[16:21:56.854]                 ...future.workdir <- getwd()
[16:21:56.854]             }
[16:21:56.854]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:56.854]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:56.854]         }
[16:21:56.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:56.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:56.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:56.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:56.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:56.854]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:56.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:56.854]             base::names(...future.oldOptions))
[16:21:56.854]     }
[16:21:56.854]     if (FALSE) {
[16:21:56.854]     }
[16:21:56.854]     else {
[16:21:56.854]         if (TRUE) {
[16:21:56.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:56.854]                 open = "w")
[16:21:56.854]         }
[16:21:56.854]         else {
[16:21:56.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:56.854]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:56.854]         }
[16:21:56.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:56.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:56.854]             base::sink(type = "output", split = FALSE)
[16:21:56.854]             base::close(...future.stdout)
[16:21:56.854]         }, add = TRUE)
[16:21:56.854]     }
[16:21:56.854]     ...future.frame <- base::sys.nframe()
[16:21:56.854]     ...future.conditions <- base::list()
[16:21:56.854]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:56.854]     if (FALSE) {
[16:21:56.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:56.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:56.854]     }
[16:21:56.854]     ...future.result <- base::tryCatch({
[16:21:56.854]         base::withCallingHandlers({
[16:21:56.854]             ...future.value <- base::withVisible(base::local({
[16:21:56.854]                 ...future.makeSendCondition <- base::local({
[16:21:56.854]                   sendCondition <- NULL
[16:21:56.854]                   function(frame = 1L) {
[16:21:56.854]                     if (is.function(sendCondition)) 
[16:21:56.854]                       return(sendCondition)
[16:21:56.854]                     ns <- getNamespace("parallel")
[16:21:56.854]                     if (exists("sendData", mode = "function", 
[16:21:56.854]                       envir = ns)) {
[16:21:56.854]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:56.854]                         envir = ns)
[16:21:56.854]                       envir <- sys.frame(frame)
[16:21:56.854]                       master <- NULL
[16:21:56.854]                       while (!identical(envir, .GlobalEnv) && 
[16:21:56.854]                         !identical(envir, emptyenv())) {
[16:21:56.854]                         if (exists("master", mode = "list", envir = envir, 
[16:21:56.854]                           inherits = FALSE)) {
[16:21:56.854]                           master <- get("master", mode = "list", 
[16:21:56.854]                             envir = envir, inherits = FALSE)
[16:21:56.854]                           if (inherits(master, c("SOCKnode", 
[16:21:56.854]                             "SOCK0node"))) {
[16:21:56.854]                             sendCondition <<- function(cond) {
[16:21:56.854]                               data <- list(type = "VALUE", value = cond, 
[16:21:56.854]                                 success = TRUE)
[16:21:56.854]                               parallel_sendData(master, data)
[16:21:56.854]                             }
[16:21:56.854]                             return(sendCondition)
[16:21:56.854]                           }
[16:21:56.854]                         }
[16:21:56.854]                         frame <- frame + 1L
[16:21:56.854]                         envir <- sys.frame(frame)
[16:21:56.854]                       }
[16:21:56.854]                     }
[16:21:56.854]                     sendCondition <<- function(cond) NULL
[16:21:56.854]                   }
[16:21:56.854]                 })
[16:21:56.854]                 withCallingHandlers({
[16:21:56.854]                   {
[16:21:56.854]                     Sys.sleep(0.5)
[16:21:56.854]                     list(a = 1, b = 42L)
[16:21:56.854]                   }
[16:21:56.854]                 }, immediateCondition = function(cond) {
[16:21:56.854]                   sendCondition <- ...future.makeSendCondition()
[16:21:56.854]                   sendCondition(cond)
[16:21:56.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.854]                   {
[16:21:56.854]                     inherits <- base::inherits
[16:21:56.854]                     invokeRestart <- base::invokeRestart
[16:21:56.854]                     is.null <- base::is.null
[16:21:56.854]                     muffled <- FALSE
[16:21:56.854]                     if (inherits(cond, "message")) {
[16:21:56.854]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:56.854]                       if (muffled) 
[16:21:56.854]                         invokeRestart("muffleMessage")
[16:21:56.854]                     }
[16:21:56.854]                     else if (inherits(cond, "warning")) {
[16:21:56.854]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:56.854]                       if (muffled) 
[16:21:56.854]                         invokeRestart("muffleWarning")
[16:21:56.854]                     }
[16:21:56.854]                     else if (inherits(cond, "condition")) {
[16:21:56.854]                       if (!is.null(pattern)) {
[16:21:56.854]                         computeRestarts <- base::computeRestarts
[16:21:56.854]                         grepl <- base::grepl
[16:21:56.854]                         restarts <- computeRestarts(cond)
[16:21:56.854]                         for (restart in restarts) {
[16:21:56.854]                           name <- restart$name
[16:21:56.854]                           if (is.null(name)) 
[16:21:56.854]                             next
[16:21:56.854]                           if (!grepl(pattern, name)) 
[16:21:56.854]                             next
[16:21:56.854]                           invokeRestart(restart)
[16:21:56.854]                           muffled <- TRUE
[16:21:56.854]                           break
[16:21:56.854]                         }
[16:21:56.854]                       }
[16:21:56.854]                     }
[16:21:56.854]                     invisible(muffled)
[16:21:56.854]                   }
[16:21:56.854]                   muffleCondition(cond)
[16:21:56.854]                 })
[16:21:56.854]             }))
[16:21:56.854]             future::FutureResult(value = ...future.value$value, 
[16:21:56.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.854]                   ...future.rng), globalenv = if (FALSE) 
[16:21:56.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:56.854]                     ...future.globalenv.names))
[16:21:56.854]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:56.854]         }, condition = base::local({
[16:21:56.854]             c <- base::c
[16:21:56.854]             inherits <- base::inherits
[16:21:56.854]             invokeRestart <- base::invokeRestart
[16:21:56.854]             length <- base::length
[16:21:56.854]             list <- base::list
[16:21:56.854]             seq.int <- base::seq.int
[16:21:56.854]             signalCondition <- base::signalCondition
[16:21:56.854]             sys.calls <- base::sys.calls
[16:21:56.854]             `[[` <- base::`[[`
[16:21:56.854]             `+` <- base::`+`
[16:21:56.854]             `<<-` <- base::`<<-`
[16:21:56.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:56.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:56.854]                   3L)]
[16:21:56.854]             }
[16:21:56.854]             function(cond) {
[16:21:56.854]                 is_error <- inherits(cond, "error")
[16:21:56.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:56.854]                   NULL)
[16:21:56.854]                 if (is_error) {
[16:21:56.854]                   sessionInformation <- function() {
[16:21:56.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:56.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:56.854]                       search = base::search(), system = base::Sys.info())
[16:21:56.854]                   }
[16:21:56.854]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:56.854]                     cond$call), session = sessionInformation(), 
[16:21:56.854]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:56.854]                   signalCondition(cond)
[16:21:56.854]                 }
[16:21:56.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:56.854]                 "immediateCondition"))) {
[16:21:56.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:56.854]                   ...future.conditions[[length(...future.conditions) + 
[16:21:56.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:56.854]                   if (TRUE && !signal) {
[16:21:56.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.854]                     {
[16:21:56.854]                       inherits <- base::inherits
[16:21:56.854]                       invokeRestart <- base::invokeRestart
[16:21:56.854]                       is.null <- base::is.null
[16:21:56.854]                       muffled <- FALSE
[16:21:56.854]                       if (inherits(cond, "message")) {
[16:21:56.854]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.854]                         if (muffled) 
[16:21:56.854]                           invokeRestart("muffleMessage")
[16:21:56.854]                       }
[16:21:56.854]                       else if (inherits(cond, "warning")) {
[16:21:56.854]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.854]                         if (muffled) 
[16:21:56.854]                           invokeRestart("muffleWarning")
[16:21:56.854]                       }
[16:21:56.854]                       else if (inherits(cond, "condition")) {
[16:21:56.854]                         if (!is.null(pattern)) {
[16:21:56.854]                           computeRestarts <- base::computeRestarts
[16:21:56.854]                           grepl <- base::grepl
[16:21:56.854]                           restarts <- computeRestarts(cond)
[16:21:56.854]                           for (restart in restarts) {
[16:21:56.854]                             name <- restart$name
[16:21:56.854]                             if (is.null(name)) 
[16:21:56.854]                               next
[16:21:56.854]                             if (!grepl(pattern, name)) 
[16:21:56.854]                               next
[16:21:56.854]                             invokeRestart(restart)
[16:21:56.854]                             muffled <- TRUE
[16:21:56.854]                             break
[16:21:56.854]                           }
[16:21:56.854]                         }
[16:21:56.854]                       }
[16:21:56.854]                       invisible(muffled)
[16:21:56.854]                     }
[16:21:56.854]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.854]                   }
[16:21:56.854]                 }
[16:21:56.854]                 else {
[16:21:56.854]                   if (TRUE) {
[16:21:56.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:56.854]                     {
[16:21:56.854]                       inherits <- base::inherits
[16:21:56.854]                       invokeRestart <- base::invokeRestart
[16:21:56.854]                       is.null <- base::is.null
[16:21:56.854]                       muffled <- FALSE
[16:21:56.854]                       if (inherits(cond, "message")) {
[16:21:56.854]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:56.854]                         if (muffled) 
[16:21:56.854]                           invokeRestart("muffleMessage")
[16:21:56.854]                       }
[16:21:56.854]                       else if (inherits(cond, "warning")) {
[16:21:56.854]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:56.854]                         if (muffled) 
[16:21:56.854]                           invokeRestart("muffleWarning")
[16:21:56.854]                       }
[16:21:56.854]                       else if (inherits(cond, "condition")) {
[16:21:56.854]                         if (!is.null(pattern)) {
[16:21:56.854]                           computeRestarts <- base::computeRestarts
[16:21:56.854]                           grepl <- base::grepl
[16:21:56.854]                           restarts <- computeRestarts(cond)
[16:21:56.854]                           for (restart in restarts) {
[16:21:56.854]                             name <- restart$name
[16:21:56.854]                             if (is.null(name)) 
[16:21:56.854]                               next
[16:21:56.854]                             if (!grepl(pattern, name)) 
[16:21:56.854]                               next
[16:21:56.854]                             invokeRestart(restart)
[16:21:56.854]                             muffled <- TRUE
[16:21:56.854]                             break
[16:21:56.854]                           }
[16:21:56.854]                         }
[16:21:56.854]                       }
[16:21:56.854]                       invisible(muffled)
[16:21:56.854]                     }
[16:21:56.854]                     muffleCondition(cond, pattern = "^muffle")
[16:21:56.854]                   }
[16:21:56.854]                 }
[16:21:56.854]             }
[16:21:56.854]         }))
[16:21:56.854]     }, error = function(ex) {
[16:21:56.854]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:56.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:56.854]                 ...future.rng), started = ...future.startTime, 
[16:21:56.854]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:56.854]             version = "1.8"), class = "FutureResult")
[16:21:56.854]     }, finally = {
[16:21:56.854]         if (!identical(...future.workdir, getwd())) 
[16:21:56.854]             setwd(...future.workdir)
[16:21:56.854]         {
[16:21:56.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:56.854]                 ...future.oldOptions$nwarnings <- NULL
[16:21:56.854]             }
[16:21:56.854]             base::options(...future.oldOptions)
[16:21:56.854]             if (.Platform$OS.type == "windows") {
[16:21:56.854]                 old_names <- names(...future.oldEnvVars)
[16:21:56.854]                 envs <- base::Sys.getenv()
[16:21:56.854]                 names <- names(envs)
[16:21:56.854]                 common <- intersect(names, old_names)
[16:21:56.854]                 added <- setdiff(names, old_names)
[16:21:56.854]                 removed <- setdiff(old_names, names)
[16:21:56.854]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:56.854]                   envs[common]]
[16:21:56.854]                 NAMES <- toupper(changed)
[16:21:56.854]                 args <- list()
[16:21:56.854]                 for (kk in seq_along(NAMES)) {
[16:21:56.854]                   name <- changed[[kk]]
[16:21:56.854]                   NAME <- NAMES[[kk]]
[16:21:56.854]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.854]                     next
[16:21:56.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.854]                 }
[16:21:56.854]                 NAMES <- toupper(added)
[16:21:56.854]                 for (kk in seq_along(NAMES)) {
[16:21:56.854]                   name <- added[[kk]]
[16:21:56.854]                   NAME <- NAMES[[kk]]
[16:21:56.854]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.854]                     next
[16:21:56.854]                   args[[name]] <- ""
[16:21:56.854]                 }
[16:21:56.854]                 NAMES <- toupper(removed)
[16:21:56.854]                 for (kk in seq_along(NAMES)) {
[16:21:56.854]                   name <- removed[[kk]]
[16:21:56.854]                   NAME <- NAMES[[kk]]
[16:21:56.854]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:56.854]                     next
[16:21:56.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:56.854]                 }
[16:21:56.854]                 if (length(args) > 0) 
[16:21:56.854]                   base::do.call(base::Sys.setenv, args = args)
[16:21:56.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:56.854]             }
[16:21:56.854]             else {
[16:21:56.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:56.854]             }
[16:21:56.854]             {
[16:21:56.854]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:56.854]                   0L) {
[16:21:56.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:56.854]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:56.854]                   base::options(opts)
[16:21:56.854]                 }
[16:21:56.854]                 {
[16:21:56.854]                   {
[16:21:56.854]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:56.854]                     NULL
[16:21:56.854]                   }
[16:21:56.854]                   options(future.plan = NULL)
[16:21:56.854]                   if (is.na(NA_character_)) 
[16:21:56.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:56.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:56.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:56.854]                     .init = FALSE)
[16:21:56.854]                 }
[16:21:56.854]             }
[16:21:56.854]         }
[16:21:56.854]     })
[16:21:56.854]     if (TRUE) {
[16:21:56.854]         base::sink(type = "output", split = FALSE)
[16:21:56.854]         if (TRUE) {
[16:21:56.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:56.854]         }
[16:21:56.854]         else {
[16:21:56.854]             ...future.result["stdout"] <- base::list(NULL)
[16:21:56.854]         }
[16:21:56.854]         base::close(...future.stdout)
[16:21:56.854]         ...future.stdout <- NULL
[16:21:56.854]     }
[16:21:56.854]     ...future.result$conditions <- ...future.conditions
[16:21:56.854]     ...future.result$finished <- base::Sys.time()
[16:21:56.854]     ...future.result
[16:21:56.854] }
[16:21:56.856] Poll #1 (0): usedNodes() = 2, workers = 2
[16:21:56.877] receiveMessageFromWorker() for ClusterFuture ...
[16:21:56.877] - Validating connection of MultisessionFuture
[16:21:56.878] - received message: FutureResult
[16:21:56.878] - Received FutureResult
[16:21:56.878] - Erased future from FutureRegistry
[16:21:56.878] result() for ClusterFuture ...
[16:21:56.878] - result already collected: FutureResult
[16:21:56.878] result() for ClusterFuture ... done
[16:21:56.878] signalConditions() ...
[16:21:56.878]  - include = ‘immediateCondition’
[16:21:56.878]  - exclude = 
[16:21:56.879]  - resignal = FALSE
[16:21:56.879]  - Number of conditions: 1
[16:21:56.879] signalConditions() ... done
[16:21:56.879] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:56.879] result() for ClusterFuture ...
[16:21:56.879] - result already collected: FutureResult
[16:21:56.879] result() for ClusterFuture ... done
[16:21:56.879] result() for ClusterFuture ...
[16:21:56.879] - result already collected: FutureResult
[16:21:56.879] result() for ClusterFuture ... done
[16:21:56.880] signalConditions() ...
[16:21:56.880]  - include = ‘immediateCondition’
[16:21:56.880]  - exclude = 
[16:21:56.880]  - resignal = FALSE
[16:21:56.880]  - Number of conditions: 1
[16:21:56.880] signalConditions() ... done
[16:21:56.881] MultisessionFuture started
[16:21:56.881] - Launch lazy future ... done
[16:21:56.881] run() for ‘MultisessionFuture’ ... done
[16:21:57.387] receiveMessageFromWorker() for ClusterFuture ...
[16:21:57.387] - Validating connection of MultisessionFuture
[16:21:57.387] - received message: FutureResult
[16:21:57.387] - Received FutureResult
[16:21:57.387] - Erased future from FutureRegistry
[16:21:57.388] result() for ClusterFuture ...
[16:21:57.388] - result already collected: FutureResult
[16:21:57.388] result() for ClusterFuture ... done
[16:21:57.388] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:57.388] A MultisessionFuture was resolved (result was not collected)
[16:21:57.388] getGlobalsAndPackages() ...
[16:21:57.388] Searching for globals...
[16:21:57.389] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:57.389] Searching for globals ... DONE
[16:21:57.390] Resolving globals: FALSE
[16:21:57.390] 
[16:21:57.390] 
[16:21:57.390] getGlobalsAndPackages() ... DONE
[16:21:57.390] run() for ‘Future’ ...
[16:21:57.390] - state: ‘created’
[16:21:57.391] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:57.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:57.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:57.405]   - Field: ‘node’
[16:21:57.405]   - Field: ‘label’
[16:21:57.405]   - Field: ‘local’
[16:21:57.405]   - Field: ‘owner’
[16:21:57.405]   - Field: ‘envir’
[16:21:57.405]   - Field: ‘workers’
[16:21:57.405]   - Field: ‘packages’
[16:21:57.405]   - Field: ‘gc’
[16:21:57.406]   - Field: ‘conditions’
[16:21:57.406]   - Field: ‘persistent’
[16:21:57.406]   - Field: ‘expr’
[16:21:57.406]   - Field: ‘uuid’
[16:21:57.406]   - Field: ‘seed’
[16:21:57.406]   - Field: ‘version’
[16:21:57.406]   - Field: ‘result’
[16:21:57.406]   - Field: ‘asynchronous’
[16:21:57.406]   - Field: ‘calls’
[16:21:57.406]   - Field: ‘globals’
[16:21:57.406]   - Field: ‘stdout’
[16:21:57.407]   - Field: ‘earlySignal’
[16:21:57.407]   - Field: ‘lazy’
[16:21:57.407]   - Field: ‘state’
[16:21:57.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:57.407] - Launch lazy future ...
[16:21:57.407] Packages needed by the future expression (n = 0): <none>
[16:21:57.407] Packages needed by future strategies (n = 0): <none>
[16:21:57.408] {
[16:21:57.408]     {
[16:21:57.408]         {
[16:21:57.408]             ...future.startTime <- base::Sys.time()
[16:21:57.408]             {
[16:21:57.408]                 {
[16:21:57.408]                   {
[16:21:57.408]                     {
[16:21:57.408]                       base::local({
[16:21:57.408]                         has_future <- base::requireNamespace("future", 
[16:21:57.408]                           quietly = TRUE)
[16:21:57.408]                         if (has_future) {
[16:21:57.408]                           ns <- base::getNamespace("future")
[16:21:57.408]                           version <- ns[[".package"]][["version"]]
[16:21:57.408]                           if (is.null(version)) 
[16:21:57.408]                             version <- utils::packageVersion("future")
[16:21:57.408]                         }
[16:21:57.408]                         else {
[16:21:57.408]                           version <- NULL
[16:21:57.408]                         }
[16:21:57.408]                         if (!has_future || version < "1.8.0") {
[16:21:57.408]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:57.408]                             "", base::R.version$version.string), 
[16:21:57.408]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:57.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:57.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:57.408]                               "release", "version")], collapse = " "), 
[16:21:57.408]                             hostname = base::Sys.info()[["nodename"]])
[16:21:57.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:57.408]                             info)
[16:21:57.408]                           info <- base::paste(info, collapse = "; ")
[16:21:57.408]                           if (!has_future) {
[16:21:57.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:57.408]                               info)
[16:21:57.408]                           }
[16:21:57.408]                           else {
[16:21:57.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:57.408]                               info, version)
[16:21:57.408]                           }
[16:21:57.408]                           base::stop(msg)
[16:21:57.408]                         }
[16:21:57.408]                       })
[16:21:57.408]                     }
[16:21:57.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:57.408]                     base::options(mc.cores = 1L)
[16:21:57.408]                   }
[16:21:57.408]                   ...future.strategy.old <- future::plan("list")
[16:21:57.408]                   options(future.plan = NULL)
[16:21:57.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:57.408]                 }
[16:21:57.408]                 ...future.workdir <- getwd()
[16:21:57.408]             }
[16:21:57.408]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:57.408]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:57.408]         }
[16:21:57.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:57.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:57.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:57.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:57.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:57.408]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:57.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:57.408]             base::names(...future.oldOptions))
[16:21:57.408]     }
[16:21:57.408]     if (FALSE) {
[16:21:57.408]     }
[16:21:57.408]     else {
[16:21:57.408]         if (TRUE) {
[16:21:57.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:57.408]                 open = "w")
[16:21:57.408]         }
[16:21:57.408]         else {
[16:21:57.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:57.408]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:57.408]         }
[16:21:57.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:57.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:57.408]             base::sink(type = "output", split = FALSE)
[16:21:57.408]             base::close(...future.stdout)
[16:21:57.408]         }, add = TRUE)
[16:21:57.408]     }
[16:21:57.408]     ...future.frame <- base::sys.nframe()
[16:21:57.408]     ...future.conditions <- base::list()
[16:21:57.408]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:57.408]     if (FALSE) {
[16:21:57.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:57.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:57.408]     }
[16:21:57.408]     ...future.result <- base::tryCatch({
[16:21:57.408]         base::withCallingHandlers({
[16:21:57.408]             ...future.value <- base::withVisible(base::local({
[16:21:57.408]                 ...future.makeSendCondition <- base::local({
[16:21:57.408]                   sendCondition <- NULL
[16:21:57.408]                   function(frame = 1L) {
[16:21:57.408]                     if (is.function(sendCondition)) 
[16:21:57.408]                       return(sendCondition)
[16:21:57.408]                     ns <- getNamespace("parallel")
[16:21:57.408]                     if (exists("sendData", mode = "function", 
[16:21:57.408]                       envir = ns)) {
[16:21:57.408]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:57.408]                         envir = ns)
[16:21:57.408]                       envir <- sys.frame(frame)
[16:21:57.408]                       master <- NULL
[16:21:57.408]                       while (!identical(envir, .GlobalEnv) && 
[16:21:57.408]                         !identical(envir, emptyenv())) {
[16:21:57.408]                         if (exists("master", mode = "list", envir = envir, 
[16:21:57.408]                           inherits = FALSE)) {
[16:21:57.408]                           master <- get("master", mode = "list", 
[16:21:57.408]                             envir = envir, inherits = FALSE)
[16:21:57.408]                           if (inherits(master, c("SOCKnode", 
[16:21:57.408]                             "SOCK0node"))) {
[16:21:57.408]                             sendCondition <<- function(cond) {
[16:21:57.408]                               data <- list(type = "VALUE", value = cond, 
[16:21:57.408]                                 success = TRUE)
[16:21:57.408]                               parallel_sendData(master, data)
[16:21:57.408]                             }
[16:21:57.408]                             return(sendCondition)
[16:21:57.408]                           }
[16:21:57.408]                         }
[16:21:57.408]                         frame <- frame + 1L
[16:21:57.408]                         envir <- sys.frame(frame)
[16:21:57.408]                       }
[16:21:57.408]                     }
[16:21:57.408]                     sendCondition <<- function(cond) NULL
[16:21:57.408]                   }
[16:21:57.408]                 })
[16:21:57.408]                 withCallingHandlers({
[16:21:57.408]                   {
[16:21:57.408]                     Sys.sleep(0.5)
[16:21:57.408]                     list(a = 1, b = 42L)
[16:21:57.408]                   }
[16:21:57.408]                 }, immediateCondition = function(cond) {
[16:21:57.408]                   sendCondition <- ...future.makeSendCondition()
[16:21:57.408]                   sendCondition(cond)
[16:21:57.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.408]                   {
[16:21:57.408]                     inherits <- base::inherits
[16:21:57.408]                     invokeRestart <- base::invokeRestart
[16:21:57.408]                     is.null <- base::is.null
[16:21:57.408]                     muffled <- FALSE
[16:21:57.408]                     if (inherits(cond, "message")) {
[16:21:57.408]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:57.408]                       if (muffled) 
[16:21:57.408]                         invokeRestart("muffleMessage")
[16:21:57.408]                     }
[16:21:57.408]                     else if (inherits(cond, "warning")) {
[16:21:57.408]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:57.408]                       if (muffled) 
[16:21:57.408]                         invokeRestart("muffleWarning")
[16:21:57.408]                     }
[16:21:57.408]                     else if (inherits(cond, "condition")) {
[16:21:57.408]                       if (!is.null(pattern)) {
[16:21:57.408]                         computeRestarts <- base::computeRestarts
[16:21:57.408]                         grepl <- base::grepl
[16:21:57.408]                         restarts <- computeRestarts(cond)
[16:21:57.408]                         for (restart in restarts) {
[16:21:57.408]                           name <- restart$name
[16:21:57.408]                           if (is.null(name)) 
[16:21:57.408]                             next
[16:21:57.408]                           if (!grepl(pattern, name)) 
[16:21:57.408]                             next
[16:21:57.408]                           invokeRestart(restart)
[16:21:57.408]                           muffled <- TRUE
[16:21:57.408]                           break
[16:21:57.408]                         }
[16:21:57.408]                       }
[16:21:57.408]                     }
[16:21:57.408]                     invisible(muffled)
[16:21:57.408]                   }
[16:21:57.408]                   muffleCondition(cond)
[16:21:57.408]                 })
[16:21:57.408]             }))
[16:21:57.408]             future::FutureResult(value = ...future.value$value, 
[16:21:57.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.408]                   ...future.rng), globalenv = if (FALSE) 
[16:21:57.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:57.408]                     ...future.globalenv.names))
[16:21:57.408]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:57.408]         }, condition = base::local({
[16:21:57.408]             c <- base::c
[16:21:57.408]             inherits <- base::inherits
[16:21:57.408]             invokeRestart <- base::invokeRestart
[16:21:57.408]             length <- base::length
[16:21:57.408]             list <- base::list
[16:21:57.408]             seq.int <- base::seq.int
[16:21:57.408]             signalCondition <- base::signalCondition
[16:21:57.408]             sys.calls <- base::sys.calls
[16:21:57.408]             `[[` <- base::`[[`
[16:21:57.408]             `+` <- base::`+`
[16:21:57.408]             `<<-` <- base::`<<-`
[16:21:57.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:57.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:57.408]                   3L)]
[16:21:57.408]             }
[16:21:57.408]             function(cond) {
[16:21:57.408]                 is_error <- inherits(cond, "error")
[16:21:57.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:57.408]                   NULL)
[16:21:57.408]                 if (is_error) {
[16:21:57.408]                   sessionInformation <- function() {
[16:21:57.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:57.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:57.408]                       search = base::search(), system = base::Sys.info())
[16:21:57.408]                   }
[16:21:57.408]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:57.408]                     cond$call), session = sessionInformation(), 
[16:21:57.408]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:57.408]                   signalCondition(cond)
[16:21:57.408]                 }
[16:21:57.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:57.408]                 "immediateCondition"))) {
[16:21:57.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:57.408]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:57.408]                   if (TRUE && !signal) {
[16:21:57.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.408]                     {
[16:21:57.408]                       inherits <- base::inherits
[16:21:57.408]                       invokeRestart <- base::invokeRestart
[16:21:57.408]                       is.null <- base::is.null
[16:21:57.408]                       muffled <- FALSE
[16:21:57.408]                       if (inherits(cond, "message")) {
[16:21:57.408]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.408]                         if (muffled) 
[16:21:57.408]                           invokeRestart("muffleMessage")
[16:21:57.408]                       }
[16:21:57.408]                       else if (inherits(cond, "warning")) {
[16:21:57.408]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.408]                         if (muffled) 
[16:21:57.408]                           invokeRestart("muffleWarning")
[16:21:57.408]                       }
[16:21:57.408]                       else if (inherits(cond, "condition")) {
[16:21:57.408]                         if (!is.null(pattern)) {
[16:21:57.408]                           computeRestarts <- base::computeRestarts
[16:21:57.408]                           grepl <- base::grepl
[16:21:57.408]                           restarts <- computeRestarts(cond)
[16:21:57.408]                           for (restart in restarts) {
[16:21:57.408]                             name <- restart$name
[16:21:57.408]                             if (is.null(name)) 
[16:21:57.408]                               next
[16:21:57.408]                             if (!grepl(pattern, name)) 
[16:21:57.408]                               next
[16:21:57.408]                             invokeRestart(restart)
[16:21:57.408]                             muffled <- TRUE
[16:21:57.408]                             break
[16:21:57.408]                           }
[16:21:57.408]                         }
[16:21:57.408]                       }
[16:21:57.408]                       invisible(muffled)
[16:21:57.408]                     }
[16:21:57.408]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.408]                   }
[16:21:57.408]                 }
[16:21:57.408]                 else {
[16:21:57.408]                   if (TRUE) {
[16:21:57.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.408]                     {
[16:21:57.408]                       inherits <- base::inherits
[16:21:57.408]                       invokeRestart <- base::invokeRestart
[16:21:57.408]                       is.null <- base::is.null
[16:21:57.408]                       muffled <- FALSE
[16:21:57.408]                       if (inherits(cond, "message")) {
[16:21:57.408]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.408]                         if (muffled) 
[16:21:57.408]                           invokeRestart("muffleMessage")
[16:21:57.408]                       }
[16:21:57.408]                       else if (inherits(cond, "warning")) {
[16:21:57.408]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.408]                         if (muffled) 
[16:21:57.408]                           invokeRestart("muffleWarning")
[16:21:57.408]                       }
[16:21:57.408]                       else if (inherits(cond, "condition")) {
[16:21:57.408]                         if (!is.null(pattern)) {
[16:21:57.408]                           computeRestarts <- base::computeRestarts
[16:21:57.408]                           grepl <- base::grepl
[16:21:57.408]                           restarts <- computeRestarts(cond)
[16:21:57.408]                           for (restart in restarts) {
[16:21:57.408]                             name <- restart$name
[16:21:57.408]                             if (is.null(name)) 
[16:21:57.408]                               next
[16:21:57.408]                             if (!grepl(pattern, name)) 
[16:21:57.408]                               next
[16:21:57.408]                             invokeRestart(restart)
[16:21:57.408]                             muffled <- TRUE
[16:21:57.408]                             break
[16:21:57.408]                           }
[16:21:57.408]                         }
[16:21:57.408]                       }
[16:21:57.408]                       invisible(muffled)
[16:21:57.408]                     }
[16:21:57.408]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.408]                   }
[16:21:57.408]                 }
[16:21:57.408]             }
[16:21:57.408]         }))
[16:21:57.408]     }, error = function(ex) {
[16:21:57.408]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:57.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.408]                 ...future.rng), started = ...future.startTime, 
[16:21:57.408]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:57.408]             version = "1.8"), class = "FutureResult")
[16:21:57.408]     }, finally = {
[16:21:57.408]         if (!identical(...future.workdir, getwd())) 
[16:21:57.408]             setwd(...future.workdir)
[16:21:57.408]         {
[16:21:57.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:57.408]                 ...future.oldOptions$nwarnings <- NULL
[16:21:57.408]             }
[16:21:57.408]             base::options(...future.oldOptions)
[16:21:57.408]             if (.Platform$OS.type == "windows") {
[16:21:57.408]                 old_names <- names(...future.oldEnvVars)
[16:21:57.408]                 envs <- base::Sys.getenv()
[16:21:57.408]                 names <- names(envs)
[16:21:57.408]                 common <- intersect(names, old_names)
[16:21:57.408]                 added <- setdiff(names, old_names)
[16:21:57.408]                 removed <- setdiff(old_names, names)
[16:21:57.408]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:57.408]                   envs[common]]
[16:21:57.408]                 NAMES <- toupper(changed)
[16:21:57.408]                 args <- list()
[16:21:57.408]                 for (kk in seq_along(NAMES)) {
[16:21:57.408]                   name <- changed[[kk]]
[16:21:57.408]                   NAME <- NAMES[[kk]]
[16:21:57.408]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.408]                     next
[16:21:57.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.408]                 }
[16:21:57.408]                 NAMES <- toupper(added)
[16:21:57.408]                 for (kk in seq_along(NAMES)) {
[16:21:57.408]                   name <- added[[kk]]
[16:21:57.408]                   NAME <- NAMES[[kk]]
[16:21:57.408]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.408]                     next
[16:21:57.408]                   args[[name]] <- ""
[16:21:57.408]                 }
[16:21:57.408]                 NAMES <- toupper(removed)
[16:21:57.408]                 for (kk in seq_along(NAMES)) {
[16:21:57.408]                   name <- removed[[kk]]
[16:21:57.408]                   NAME <- NAMES[[kk]]
[16:21:57.408]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.408]                     next
[16:21:57.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.408]                 }
[16:21:57.408]                 if (length(args) > 0) 
[16:21:57.408]                   base::do.call(base::Sys.setenv, args = args)
[16:21:57.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:57.408]             }
[16:21:57.408]             else {
[16:21:57.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:57.408]             }
[16:21:57.408]             {
[16:21:57.408]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:57.408]                   0L) {
[16:21:57.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:57.408]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:57.408]                   base::options(opts)
[16:21:57.408]                 }
[16:21:57.408]                 {
[16:21:57.408]                   {
[16:21:57.408]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:57.408]                     NULL
[16:21:57.408]                   }
[16:21:57.408]                   options(future.plan = NULL)
[16:21:57.408]                   if (is.na(NA_character_)) 
[16:21:57.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:57.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:57.408]                     .init = FALSE)
[16:21:57.408]                 }
[16:21:57.408]             }
[16:21:57.408]         }
[16:21:57.408]     })
[16:21:57.408]     if (TRUE) {
[16:21:57.408]         base::sink(type = "output", split = FALSE)
[16:21:57.408]         if (TRUE) {
[16:21:57.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:57.408]         }
[16:21:57.408]         else {
[16:21:57.408]             ...future.result["stdout"] <- base::list(NULL)
[16:21:57.408]         }
[16:21:57.408]         base::close(...future.stdout)
[16:21:57.408]         ...future.stdout <- NULL
[16:21:57.408]     }
[16:21:57.408]     ...future.result$conditions <- ...future.conditions
[16:21:57.408]     ...future.result$finished <- base::Sys.time()
[16:21:57.408]     ...future.result
[16:21:57.408] }
[16:21:57.411] MultisessionFuture started
[16:21:57.411] - Launch lazy future ... done
[16:21:57.411] run() for ‘MultisessionFuture’ ... done
[16:21:57.913] receiveMessageFromWorker() for ClusterFuture ...
[16:21:57.914] - Validating connection of MultisessionFuture
[16:21:57.914] - received message: FutureResult
[16:21:57.914] - Received FutureResult
[16:21:57.914] - Erased future from FutureRegistry
[16:21:57.914] result() for ClusterFuture ...
[16:21:57.914] - result already collected: FutureResult
[16:21:57.914] result() for ClusterFuture ... done
[16:21:57.914] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:57.915] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:21:57.915] getGlobalsAndPackages() ...
[16:21:57.915] Searching for globals...
[16:21:57.916] - globals found: [2] ‘list’, ‘stop’
[16:21:57.916] Searching for globals ... DONE
[16:21:57.916] Resolving globals: FALSE
[16:21:57.916] 
[16:21:57.916] 
[16:21:57.916] getGlobalsAndPackages() ... DONE
[16:21:57.917] run() for ‘Future’ ...
[16:21:57.917] - state: ‘created’
[16:21:57.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:57.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:57.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:57.931]   - Field: ‘node’
[16:21:57.931]   - Field: ‘label’
[16:21:57.931]   - Field: ‘local’
[16:21:57.931]   - Field: ‘owner’
[16:21:57.931]   - Field: ‘envir’
[16:21:57.931]   - Field: ‘workers’
[16:21:57.931]   - Field: ‘packages’
[16:21:57.931]   - Field: ‘gc’
[16:21:57.932]   - Field: ‘conditions’
[16:21:57.932]   - Field: ‘persistent’
[16:21:57.932]   - Field: ‘expr’
[16:21:57.932]   - Field: ‘uuid’
[16:21:57.932]   - Field: ‘seed’
[16:21:57.932]   - Field: ‘version’
[16:21:57.932]   - Field: ‘result’
[16:21:57.932]   - Field: ‘asynchronous’
[16:21:57.932]   - Field: ‘calls’
[16:21:57.932]   - Field: ‘globals’
[16:21:57.933]   - Field: ‘stdout’
[16:21:57.933]   - Field: ‘earlySignal’
[16:21:57.933]   - Field: ‘lazy’
[16:21:57.933]   - Field: ‘state’
[16:21:57.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:57.933] - Launch lazy future ...
[16:21:57.933] Packages needed by the future expression (n = 0): <none>
[16:21:57.933] Packages needed by future strategies (n = 0): <none>
[16:21:57.936] {
[16:21:57.936]     {
[16:21:57.936]         {
[16:21:57.936]             ...future.startTime <- base::Sys.time()
[16:21:57.936]             {
[16:21:57.936]                 {
[16:21:57.936]                   {
[16:21:57.936]                     {
[16:21:57.936]                       base::local({
[16:21:57.936]                         has_future <- base::requireNamespace("future", 
[16:21:57.936]                           quietly = TRUE)
[16:21:57.936]                         if (has_future) {
[16:21:57.936]                           ns <- base::getNamespace("future")
[16:21:57.936]                           version <- ns[[".package"]][["version"]]
[16:21:57.936]                           if (is.null(version)) 
[16:21:57.936]                             version <- utils::packageVersion("future")
[16:21:57.936]                         }
[16:21:57.936]                         else {
[16:21:57.936]                           version <- NULL
[16:21:57.936]                         }
[16:21:57.936]                         if (!has_future || version < "1.8.0") {
[16:21:57.936]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:57.936]                             "", base::R.version$version.string), 
[16:21:57.936]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:57.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:57.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:57.936]                               "release", "version")], collapse = " "), 
[16:21:57.936]                             hostname = base::Sys.info()[["nodename"]])
[16:21:57.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:57.936]                             info)
[16:21:57.936]                           info <- base::paste(info, collapse = "; ")
[16:21:57.936]                           if (!has_future) {
[16:21:57.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:57.936]                               info)
[16:21:57.936]                           }
[16:21:57.936]                           else {
[16:21:57.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:57.936]                               info, version)
[16:21:57.936]                           }
[16:21:57.936]                           base::stop(msg)
[16:21:57.936]                         }
[16:21:57.936]                       })
[16:21:57.936]                     }
[16:21:57.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:57.936]                     base::options(mc.cores = 1L)
[16:21:57.936]                   }
[16:21:57.936]                   ...future.strategy.old <- future::plan("list")
[16:21:57.936]                   options(future.plan = NULL)
[16:21:57.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:57.936]                 }
[16:21:57.936]                 ...future.workdir <- getwd()
[16:21:57.936]             }
[16:21:57.936]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:57.936]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:57.936]         }
[16:21:57.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:57.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:57.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:57.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:57.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:57.936]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:57.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:57.936]             base::names(...future.oldOptions))
[16:21:57.936]     }
[16:21:57.936]     if (FALSE) {
[16:21:57.936]     }
[16:21:57.936]     else {
[16:21:57.936]         if (TRUE) {
[16:21:57.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:57.936]                 open = "w")
[16:21:57.936]         }
[16:21:57.936]         else {
[16:21:57.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:57.936]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:57.936]         }
[16:21:57.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:57.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:57.936]             base::sink(type = "output", split = FALSE)
[16:21:57.936]             base::close(...future.stdout)
[16:21:57.936]         }, add = TRUE)
[16:21:57.936]     }
[16:21:57.936]     ...future.frame <- base::sys.nframe()
[16:21:57.936]     ...future.conditions <- base::list()
[16:21:57.936]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:57.936]     if (FALSE) {
[16:21:57.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:57.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:57.936]     }
[16:21:57.936]     ...future.result <- base::tryCatch({
[16:21:57.936]         base::withCallingHandlers({
[16:21:57.936]             ...future.value <- base::withVisible(base::local({
[16:21:57.936]                 ...future.makeSendCondition <- base::local({
[16:21:57.936]                   sendCondition <- NULL
[16:21:57.936]                   function(frame = 1L) {
[16:21:57.936]                     if (is.function(sendCondition)) 
[16:21:57.936]                       return(sendCondition)
[16:21:57.936]                     ns <- getNamespace("parallel")
[16:21:57.936]                     if (exists("sendData", mode = "function", 
[16:21:57.936]                       envir = ns)) {
[16:21:57.936]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:57.936]                         envir = ns)
[16:21:57.936]                       envir <- sys.frame(frame)
[16:21:57.936]                       master <- NULL
[16:21:57.936]                       while (!identical(envir, .GlobalEnv) && 
[16:21:57.936]                         !identical(envir, emptyenv())) {
[16:21:57.936]                         if (exists("master", mode = "list", envir = envir, 
[16:21:57.936]                           inherits = FALSE)) {
[16:21:57.936]                           master <- get("master", mode = "list", 
[16:21:57.936]                             envir = envir, inherits = FALSE)
[16:21:57.936]                           if (inherits(master, c("SOCKnode", 
[16:21:57.936]                             "SOCK0node"))) {
[16:21:57.936]                             sendCondition <<- function(cond) {
[16:21:57.936]                               data <- list(type = "VALUE", value = cond, 
[16:21:57.936]                                 success = TRUE)
[16:21:57.936]                               parallel_sendData(master, data)
[16:21:57.936]                             }
[16:21:57.936]                             return(sendCondition)
[16:21:57.936]                           }
[16:21:57.936]                         }
[16:21:57.936]                         frame <- frame + 1L
[16:21:57.936]                         envir <- sys.frame(frame)
[16:21:57.936]                       }
[16:21:57.936]                     }
[16:21:57.936]                     sendCondition <<- function(cond) NULL
[16:21:57.936]                   }
[16:21:57.936]                 })
[16:21:57.936]                 withCallingHandlers({
[16:21:57.936]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:57.936]                 }, immediateCondition = function(cond) {
[16:21:57.936]                   sendCondition <- ...future.makeSendCondition()
[16:21:57.936]                   sendCondition(cond)
[16:21:57.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.936]                   {
[16:21:57.936]                     inherits <- base::inherits
[16:21:57.936]                     invokeRestart <- base::invokeRestart
[16:21:57.936]                     is.null <- base::is.null
[16:21:57.936]                     muffled <- FALSE
[16:21:57.936]                     if (inherits(cond, "message")) {
[16:21:57.936]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:57.936]                       if (muffled) 
[16:21:57.936]                         invokeRestart("muffleMessage")
[16:21:57.936]                     }
[16:21:57.936]                     else if (inherits(cond, "warning")) {
[16:21:57.936]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:57.936]                       if (muffled) 
[16:21:57.936]                         invokeRestart("muffleWarning")
[16:21:57.936]                     }
[16:21:57.936]                     else if (inherits(cond, "condition")) {
[16:21:57.936]                       if (!is.null(pattern)) {
[16:21:57.936]                         computeRestarts <- base::computeRestarts
[16:21:57.936]                         grepl <- base::grepl
[16:21:57.936]                         restarts <- computeRestarts(cond)
[16:21:57.936]                         for (restart in restarts) {
[16:21:57.936]                           name <- restart$name
[16:21:57.936]                           if (is.null(name)) 
[16:21:57.936]                             next
[16:21:57.936]                           if (!grepl(pattern, name)) 
[16:21:57.936]                             next
[16:21:57.936]                           invokeRestart(restart)
[16:21:57.936]                           muffled <- TRUE
[16:21:57.936]                           break
[16:21:57.936]                         }
[16:21:57.936]                       }
[16:21:57.936]                     }
[16:21:57.936]                     invisible(muffled)
[16:21:57.936]                   }
[16:21:57.936]                   muffleCondition(cond)
[16:21:57.936]                 })
[16:21:57.936]             }))
[16:21:57.936]             future::FutureResult(value = ...future.value$value, 
[16:21:57.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.936]                   ...future.rng), globalenv = if (FALSE) 
[16:21:57.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:57.936]                     ...future.globalenv.names))
[16:21:57.936]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:57.936]         }, condition = base::local({
[16:21:57.936]             c <- base::c
[16:21:57.936]             inherits <- base::inherits
[16:21:57.936]             invokeRestart <- base::invokeRestart
[16:21:57.936]             length <- base::length
[16:21:57.936]             list <- base::list
[16:21:57.936]             seq.int <- base::seq.int
[16:21:57.936]             signalCondition <- base::signalCondition
[16:21:57.936]             sys.calls <- base::sys.calls
[16:21:57.936]             `[[` <- base::`[[`
[16:21:57.936]             `+` <- base::`+`
[16:21:57.936]             `<<-` <- base::`<<-`
[16:21:57.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:57.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:57.936]                   3L)]
[16:21:57.936]             }
[16:21:57.936]             function(cond) {
[16:21:57.936]                 is_error <- inherits(cond, "error")
[16:21:57.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:57.936]                   NULL)
[16:21:57.936]                 if (is_error) {
[16:21:57.936]                   sessionInformation <- function() {
[16:21:57.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:57.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:57.936]                       search = base::search(), system = base::Sys.info())
[16:21:57.936]                   }
[16:21:57.936]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:57.936]                     cond$call), session = sessionInformation(), 
[16:21:57.936]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:57.936]                   signalCondition(cond)
[16:21:57.936]                 }
[16:21:57.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:57.936]                 "immediateCondition"))) {
[16:21:57.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:57.936]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:57.936]                   if (TRUE && !signal) {
[16:21:57.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.936]                     {
[16:21:57.936]                       inherits <- base::inherits
[16:21:57.936]                       invokeRestart <- base::invokeRestart
[16:21:57.936]                       is.null <- base::is.null
[16:21:57.936]                       muffled <- FALSE
[16:21:57.936]                       if (inherits(cond, "message")) {
[16:21:57.936]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.936]                         if (muffled) 
[16:21:57.936]                           invokeRestart("muffleMessage")
[16:21:57.936]                       }
[16:21:57.936]                       else if (inherits(cond, "warning")) {
[16:21:57.936]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.936]                         if (muffled) 
[16:21:57.936]                           invokeRestart("muffleWarning")
[16:21:57.936]                       }
[16:21:57.936]                       else if (inherits(cond, "condition")) {
[16:21:57.936]                         if (!is.null(pattern)) {
[16:21:57.936]                           computeRestarts <- base::computeRestarts
[16:21:57.936]                           grepl <- base::grepl
[16:21:57.936]                           restarts <- computeRestarts(cond)
[16:21:57.936]                           for (restart in restarts) {
[16:21:57.936]                             name <- restart$name
[16:21:57.936]                             if (is.null(name)) 
[16:21:57.936]                               next
[16:21:57.936]                             if (!grepl(pattern, name)) 
[16:21:57.936]                               next
[16:21:57.936]                             invokeRestart(restart)
[16:21:57.936]                             muffled <- TRUE
[16:21:57.936]                             break
[16:21:57.936]                           }
[16:21:57.936]                         }
[16:21:57.936]                       }
[16:21:57.936]                       invisible(muffled)
[16:21:57.936]                     }
[16:21:57.936]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.936]                   }
[16:21:57.936]                 }
[16:21:57.936]                 else {
[16:21:57.936]                   if (TRUE) {
[16:21:57.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.936]                     {
[16:21:57.936]                       inherits <- base::inherits
[16:21:57.936]                       invokeRestart <- base::invokeRestart
[16:21:57.936]                       is.null <- base::is.null
[16:21:57.936]                       muffled <- FALSE
[16:21:57.936]                       if (inherits(cond, "message")) {
[16:21:57.936]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.936]                         if (muffled) 
[16:21:57.936]                           invokeRestart("muffleMessage")
[16:21:57.936]                       }
[16:21:57.936]                       else if (inherits(cond, "warning")) {
[16:21:57.936]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.936]                         if (muffled) 
[16:21:57.936]                           invokeRestart("muffleWarning")
[16:21:57.936]                       }
[16:21:57.936]                       else if (inherits(cond, "condition")) {
[16:21:57.936]                         if (!is.null(pattern)) {
[16:21:57.936]                           computeRestarts <- base::computeRestarts
[16:21:57.936]                           grepl <- base::grepl
[16:21:57.936]                           restarts <- computeRestarts(cond)
[16:21:57.936]                           for (restart in restarts) {
[16:21:57.936]                             name <- restart$name
[16:21:57.936]                             if (is.null(name)) 
[16:21:57.936]                               next
[16:21:57.936]                             if (!grepl(pattern, name)) 
[16:21:57.936]                               next
[16:21:57.936]                             invokeRestart(restart)
[16:21:57.936]                             muffled <- TRUE
[16:21:57.936]                             break
[16:21:57.936]                           }
[16:21:57.936]                         }
[16:21:57.936]                       }
[16:21:57.936]                       invisible(muffled)
[16:21:57.936]                     }
[16:21:57.936]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.936]                   }
[16:21:57.936]                 }
[16:21:57.936]             }
[16:21:57.936]         }))
[16:21:57.936]     }, error = function(ex) {
[16:21:57.936]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:57.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.936]                 ...future.rng), started = ...future.startTime, 
[16:21:57.936]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:57.936]             version = "1.8"), class = "FutureResult")
[16:21:57.936]     }, finally = {
[16:21:57.936]         if (!identical(...future.workdir, getwd())) 
[16:21:57.936]             setwd(...future.workdir)
[16:21:57.936]         {
[16:21:57.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:57.936]                 ...future.oldOptions$nwarnings <- NULL
[16:21:57.936]             }
[16:21:57.936]             base::options(...future.oldOptions)
[16:21:57.936]             if (.Platform$OS.type == "windows") {
[16:21:57.936]                 old_names <- names(...future.oldEnvVars)
[16:21:57.936]                 envs <- base::Sys.getenv()
[16:21:57.936]                 names <- names(envs)
[16:21:57.936]                 common <- intersect(names, old_names)
[16:21:57.936]                 added <- setdiff(names, old_names)
[16:21:57.936]                 removed <- setdiff(old_names, names)
[16:21:57.936]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:57.936]                   envs[common]]
[16:21:57.936]                 NAMES <- toupper(changed)
[16:21:57.936]                 args <- list()
[16:21:57.936]                 for (kk in seq_along(NAMES)) {
[16:21:57.936]                   name <- changed[[kk]]
[16:21:57.936]                   NAME <- NAMES[[kk]]
[16:21:57.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.936]                     next
[16:21:57.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.936]                 }
[16:21:57.936]                 NAMES <- toupper(added)
[16:21:57.936]                 for (kk in seq_along(NAMES)) {
[16:21:57.936]                   name <- added[[kk]]
[16:21:57.936]                   NAME <- NAMES[[kk]]
[16:21:57.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.936]                     next
[16:21:57.936]                   args[[name]] <- ""
[16:21:57.936]                 }
[16:21:57.936]                 NAMES <- toupper(removed)
[16:21:57.936]                 for (kk in seq_along(NAMES)) {
[16:21:57.936]                   name <- removed[[kk]]
[16:21:57.936]                   NAME <- NAMES[[kk]]
[16:21:57.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.936]                     next
[16:21:57.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.936]                 }
[16:21:57.936]                 if (length(args) > 0) 
[16:21:57.936]                   base::do.call(base::Sys.setenv, args = args)
[16:21:57.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:57.936]             }
[16:21:57.936]             else {
[16:21:57.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:57.936]             }
[16:21:57.936]             {
[16:21:57.936]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:57.936]                   0L) {
[16:21:57.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:57.936]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:57.936]                   base::options(opts)
[16:21:57.936]                 }
[16:21:57.936]                 {
[16:21:57.936]                   {
[16:21:57.936]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:57.936]                     NULL
[16:21:57.936]                   }
[16:21:57.936]                   options(future.plan = NULL)
[16:21:57.936]                   if (is.na(NA_character_)) 
[16:21:57.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:57.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:57.936]                     .init = FALSE)
[16:21:57.936]                 }
[16:21:57.936]             }
[16:21:57.936]         }
[16:21:57.936]     })
[16:21:57.936]     if (TRUE) {
[16:21:57.936]         base::sink(type = "output", split = FALSE)
[16:21:57.936]         if (TRUE) {
[16:21:57.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:57.936]         }
[16:21:57.936]         else {
[16:21:57.936]             ...future.result["stdout"] <- base::list(NULL)
[16:21:57.936]         }
[16:21:57.936]         base::close(...future.stdout)
[16:21:57.936]         ...future.stdout <- NULL
[16:21:57.936]     }
[16:21:57.936]     ...future.result$conditions <- ...future.conditions
[16:21:57.936]     ...future.result$finished <- base::Sys.time()
[16:21:57.936]     ...future.result
[16:21:57.936] }
[16:21:57.939] MultisessionFuture started
[16:21:57.939] - Launch lazy future ... done
[16:21:57.939] run() for ‘MultisessionFuture’ ... done
[16:21:57.941] receiveMessageFromWorker() for ClusterFuture ...
[16:21:57.941] - Validating connection of MultisessionFuture
[16:21:57.942] - received message: FutureResult
[16:21:57.942] - Received FutureResult
[16:21:57.942] - Erased future from FutureRegistry
[16:21:57.942] result() for ClusterFuture ...
[16:21:57.942] - result already collected: FutureResult
[16:21:57.942] result() for ClusterFuture ... done
[16:21:57.942] signalConditions() ...
[16:21:57.942]  - include = ‘immediateCondition’
[16:21:57.942]  - exclude = 
[16:21:57.942]  - resignal = FALSE
[16:21:57.942]  - Number of conditions: 1
[16:21:57.943] signalConditions() ... done
[16:21:57.943] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:57.943] A MultisessionFuture was resolved (result was not collected)
[16:21:57.943] getGlobalsAndPackages() ...
[16:21:57.943] Searching for globals...
[16:21:57.944] - globals found: [2] ‘list’, ‘stop’
[16:21:57.944] Searching for globals ... DONE
[16:21:57.944] Resolving globals: FALSE
[16:21:57.944] 
[16:21:57.944] 
[16:21:57.944] getGlobalsAndPackages() ... DONE
[16:21:57.945] run() for ‘Future’ ...
[16:21:57.945] - state: ‘created’
[16:21:57.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:57.958] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:57.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:57.959]   - Field: ‘node’
[16:21:57.959]   - Field: ‘label’
[16:21:57.959]   - Field: ‘local’
[16:21:57.959]   - Field: ‘owner’
[16:21:57.959]   - Field: ‘envir’
[16:21:57.959]   - Field: ‘workers’
[16:21:57.959]   - Field: ‘packages’
[16:21:57.959]   - Field: ‘gc’
[16:21:57.959]   - Field: ‘conditions’
[16:21:57.959]   - Field: ‘persistent’
[16:21:57.959]   - Field: ‘expr’
[16:21:57.960]   - Field: ‘uuid’
[16:21:57.960]   - Field: ‘seed’
[16:21:57.960]   - Field: ‘version’
[16:21:57.960]   - Field: ‘result’
[16:21:57.960]   - Field: ‘asynchronous’
[16:21:57.960]   - Field: ‘calls’
[16:21:57.960]   - Field: ‘globals’
[16:21:57.960]   - Field: ‘stdout’
[16:21:57.960]   - Field: ‘earlySignal’
[16:21:57.960]   - Field: ‘lazy’
[16:21:57.960]   - Field: ‘state’
[16:21:57.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:57.961] - Launch lazy future ...
[16:21:57.961] Packages needed by the future expression (n = 0): <none>
[16:21:57.961] Packages needed by future strategies (n = 0): <none>
[16:21:57.961] {
[16:21:57.961]     {
[16:21:57.961]         {
[16:21:57.961]             ...future.startTime <- base::Sys.time()
[16:21:57.961]             {
[16:21:57.961]                 {
[16:21:57.961]                   {
[16:21:57.961]                     {
[16:21:57.961]                       base::local({
[16:21:57.961]                         has_future <- base::requireNamespace("future", 
[16:21:57.961]                           quietly = TRUE)
[16:21:57.961]                         if (has_future) {
[16:21:57.961]                           ns <- base::getNamespace("future")
[16:21:57.961]                           version <- ns[[".package"]][["version"]]
[16:21:57.961]                           if (is.null(version)) 
[16:21:57.961]                             version <- utils::packageVersion("future")
[16:21:57.961]                         }
[16:21:57.961]                         else {
[16:21:57.961]                           version <- NULL
[16:21:57.961]                         }
[16:21:57.961]                         if (!has_future || version < "1.8.0") {
[16:21:57.961]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:57.961]                             "", base::R.version$version.string), 
[16:21:57.961]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:57.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:57.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:57.961]                               "release", "version")], collapse = " "), 
[16:21:57.961]                             hostname = base::Sys.info()[["nodename"]])
[16:21:57.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:57.961]                             info)
[16:21:57.961]                           info <- base::paste(info, collapse = "; ")
[16:21:57.961]                           if (!has_future) {
[16:21:57.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:57.961]                               info)
[16:21:57.961]                           }
[16:21:57.961]                           else {
[16:21:57.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:57.961]                               info, version)
[16:21:57.961]                           }
[16:21:57.961]                           base::stop(msg)
[16:21:57.961]                         }
[16:21:57.961]                       })
[16:21:57.961]                     }
[16:21:57.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:57.961]                     base::options(mc.cores = 1L)
[16:21:57.961]                   }
[16:21:57.961]                   ...future.strategy.old <- future::plan("list")
[16:21:57.961]                   options(future.plan = NULL)
[16:21:57.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:57.961]                 }
[16:21:57.961]                 ...future.workdir <- getwd()
[16:21:57.961]             }
[16:21:57.961]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:57.961]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:57.961]         }
[16:21:57.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:57.961]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:57.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:57.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:57.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:57.961]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:57.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:57.961]             base::names(...future.oldOptions))
[16:21:57.961]     }
[16:21:57.961]     if (FALSE) {
[16:21:57.961]     }
[16:21:57.961]     else {
[16:21:57.961]         if (TRUE) {
[16:21:57.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:57.961]                 open = "w")
[16:21:57.961]         }
[16:21:57.961]         else {
[16:21:57.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:57.961]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:57.961]         }
[16:21:57.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:57.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:57.961]             base::sink(type = "output", split = FALSE)
[16:21:57.961]             base::close(...future.stdout)
[16:21:57.961]         }, add = TRUE)
[16:21:57.961]     }
[16:21:57.961]     ...future.frame <- base::sys.nframe()
[16:21:57.961]     ...future.conditions <- base::list()
[16:21:57.961]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:57.961]     if (FALSE) {
[16:21:57.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:57.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:57.961]     }
[16:21:57.961]     ...future.result <- base::tryCatch({
[16:21:57.961]         base::withCallingHandlers({
[16:21:57.961]             ...future.value <- base::withVisible(base::local({
[16:21:57.961]                 ...future.makeSendCondition <- base::local({
[16:21:57.961]                   sendCondition <- NULL
[16:21:57.961]                   function(frame = 1L) {
[16:21:57.961]                     if (is.function(sendCondition)) 
[16:21:57.961]                       return(sendCondition)
[16:21:57.961]                     ns <- getNamespace("parallel")
[16:21:57.961]                     if (exists("sendData", mode = "function", 
[16:21:57.961]                       envir = ns)) {
[16:21:57.961]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:57.961]                         envir = ns)
[16:21:57.961]                       envir <- sys.frame(frame)
[16:21:57.961]                       master <- NULL
[16:21:57.961]                       while (!identical(envir, .GlobalEnv) && 
[16:21:57.961]                         !identical(envir, emptyenv())) {
[16:21:57.961]                         if (exists("master", mode = "list", envir = envir, 
[16:21:57.961]                           inherits = FALSE)) {
[16:21:57.961]                           master <- get("master", mode = "list", 
[16:21:57.961]                             envir = envir, inherits = FALSE)
[16:21:57.961]                           if (inherits(master, c("SOCKnode", 
[16:21:57.961]                             "SOCK0node"))) {
[16:21:57.961]                             sendCondition <<- function(cond) {
[16:21:57.961]                               data <- list(type = "VALUE", value = cond, 
[16:21:57.961]                                 success = TRUE)
[16:21:57.961]                               parallel_sendData(master, data)
[16:21:57.961]                             }
[16:21:57.961]                             return(sendCondition)
[16:21:57.961]                           }
[16:21:57.961]                         }
[16:21:57.961]                         frame <- frame + 1L
[16:21:57.961]                         envir <- sys.frame(frame)
[16:21:57.961]                       }
[16:21:57.961]                     }
[16:21:57.961]                     sendCondition <<- function(cond) NULL
[16:21:57.961]                   }
[16:21:57.961]                 })
[16:21:57.961]                 withCallingHandlers({
[16:21:57.961]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:57.961]                 }, immediateCondition = function(cond) {
[16:21:57.961]                   sendCondition <- ...future.makeSendCondition()
[16:21:57.961]                   sendCondition(cond)
[16:21:57.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.961]                   {
[16:21:57.961]                     inherits <- base::inherits
[16:21:57.961]                     invokeRestart <- base::invokeRestart
[16:21:57.961]                     is.null <- base::is.null
[16:21:57.961]                     muffled <- FALSE
[16:21:57.961]                     if (inherits(cond, "message")) {
[16:21:57.961]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:57.961]                       if (muffled) 
[16:21:57.961]                         invokeRestart("muffleMessage")
[16:21:57.961]                     }
[16:21:57.961]                     else if (inherits(cond, "warning")) {
[16:21:57.961]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:57.961]                       if (muffled) 
[16:21:57.961]                         invokeRestart("muffleWarning")
[16:21:57.961]                     }
[16:21:57.961]                     else if (inherits(cond, "condition")) {
[16:21:57.961]                       if (!is.null(pattern)) {
[16:21:57.961]                         computeRestarts <- base::computeRestarts
[16:21:57.961]                         grepl <- base::grepl
[16:21:57.961]                         restarts <- computeRestarts(cond)
[16:21:57.961]                         for (restart in restarts) {
[16:21:57.961]                           name <- restart$name
[16:21:57.961]                           if (is.null(name)) 
[16:21:57.961]                             next
[16:21:57.961]                           if (!grepl(pattern, name)) 
[16:21:57.961]                             next
[16:21:57.961]                           invokeRestart(restart)
[16:21:57.961]                           muffled <- TRUE
[16:21:57.961]                           break
[16:21:57.961]                         }
[16:21:57.961]                       }
[16:21:57.961]                     }
[16:21:57.961]                     invisible(muffled)
[16:21:57.961]                   }
[16:21:57.961]                   muffleCondition(cond)
[16:21:57.961]                 })
[16:21:57.961]             }))
[16:21:57.961]             future::FutureResult(value = ...future.value$value, 
[16:21:57.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.961]                   ...future.rng), globalenv = if (FALSE) 
[16:21:57.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:57.961]                     ...future.globalenv.names))
[16:21:57.961]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:57.961]         }, condition = base::local({
[16:21:57.961]             c <- base::c
[16:21:57.961]             inherits <- base::inherits
[16:21:57.961]             invokeRestart <- base::invokeRestart
[16:21:57.961]             length <- base::length
[16:21:57.961]             list <- base::list
[16:21:57.961]             seq.int <- base::seq.int
[16:21:57.961]             signalCondition <- base::signalCondition
[16:21:57.961]             sys.calls <- base::sys.calls
[16:21:57.961]             `[[` <- base::`[[`
[16:21:57.961]             `+` <- base::`+`
[16:21:57.961]             `<<-` <- base::`<<-`
[16:21:57.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:57.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:57.961]                   3L)]
[16:21:57.961]             }
[16:21:57.961]             function(cond) {
[16:21:57.961]                 is_error <- inherits(cond, "error")
[16:21:57.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:57.961]                   NULL)
[16:21:57.961]                 if (is_error) {
[16:21:57.961]                   sessionInformation <- function() {
[16:21:57.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:57.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:57.961]                       search = base::search(), system = base::Sys.info())
[16:21:57.961]                   }
[16:21:57.961]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:57.961]                     cond$call), session = sessionInformation(), 
[16:21:57.961]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:57.961]                   signalCondition(cond)
[16:21:57.961]                 }
[16:21:57.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:57.961]                 "immediateCondition"))) {
[16:21:57.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:57.961]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:57.961]                   if (TRUE && !signal) {
[16:21:57.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.961]                     {
[16:21:57.961]                       inherits <- base::inherits
[16:21:57.961]                       invokeRestart <- base::invokeRestart
[16:21:57.961]                       is.null <- base::is.null
[16:21:57.961]                       muffled <- FALSE
[16:21:57.961]                       if (inherits(cond, "message")) {
[16:21:57.961]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.961]                         if (muffled) 
[16:21:57.961]                           invokeRestart("muffleMessage")
[16:21:57.961]                       }
[16:21:57.961]                       else if (inherits(cond, "warning")) {
[16:21:57.961]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.961]                         if (muffled) 
[16:21:57.961]                           invokeRestart("muffleWarning")
[16:21:57.961]                       }
[16:21:57.961]                       else if (inherits(cond, "condition")) {
[16:21:57.961]                         if (!is.null(pattern)) {
[16:21:57.961]                           computeRestarts <- base::computeRestarts
[16:21:57.961]                           grepl <- base::grepl
[16:21:57.961]                           restarts <- computeRestarts(cond)
[16:21:57.961]                           for (restart in restarts) {
[16:21:57.961]                             name <- restart$name
[16:21:57.961]                             if (is.null(name)) 
[16:21:57.961]                               next
[16:21:57.961]                             if (!grepl(pattern, name)) 
[16:21:57.961]                               next
[16:21:57.961]                             invokeRestart(restart)
[16:21:57.961]                             muffled <- TRUE
[16:21:57.961]                             break
[16:21:57.961]                           }
[16:21:57.961]                         }
[16:21:57.961]                       }
[16:21:57.961]                       invisible(muffled)
[16:21:57.961]                     }
[16:21:57.961]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.961]                   }
[16:21:57.961]                 }
[16:21:57.961]                 else {
[16:21:57.961]                   if (TRUE) {
[16:21:57.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.961]                     {
[16:21:57.961]                       inherits <- base::inherits
[16:21:57.961]                       invokeRestart <- base::invokeRestart
[16:21:57.961]                       is.null <- base::is.null
[16:21:57.961]                       muffled <- FALSE
[16:21:57.961]                       if (inherits(cond, "message")) {
[16:21:57.961]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.961]                         if (muffled) 
[16:21:57.961]                           invokeRestart("muffleMessage")
[16:21:57.961]                       }
[16:21:57.961]                       else if (inherits(cond, "warning")) {
[16:21:57.961]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.961]                         if (muffled) 
[16:21:57.961]                           invokeRestart("muffleWarning")
[16:21:57.961]                       }
[16:21:57.961]                       else if (inherits(cond, "condition")) {
[16:21:57.961]                         if (!is.null(pattern)) {
[16:21:57.961]                           computeRestarts <- base::computeRestarts
[16:21:57.961]                           grepl <- base::grepl
[16:21:57.961]                           restarts <- computeRestarts(cond)
[16:21:57.961]                           for (restart in restarts) {
[16:21:57.961]                             name <- restart$name
[16:21:57.961]                             if (is.null(name)) 
[16:21:57.961]                               next
[16:21:57.961]                             if (!grepl(pattern, name)) 
[16:21:57.961]                               next
[16:21:57.961]                             invokeRestart(restart)
[16:21:57.961]                             muffled <- TRUE
[16:21:57.961]                             break
[16:21:57.961]                           }
[16:21:57.961]                         }
[16:21:57.961]                       }
[16:21:57.961]                       invisible(muffled)
[16:21:57.961]                     }
[16:21:57.961]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.961]                   }
[16:21:57.961]                 }
[16:21:57.961]             }
[16:21:57.961]         }))
[16:21:57.961]     }, error = function(ex) {
[16:21:57.961]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:57.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.961]                 ...future.rng), started = ...future.startTime, 
[16:21:57.961]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:57.961]             version = "1.8"), class = "FutureResult")
[16:21:57.961]     }, finally = {
[16:21:57.961]         if (!identical(...future.workdir, getwd())) 
[16:21:57.961]             setwd(...future.workdir)
[16:21:57.961]         {
[16:21:57.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:57.961]                 ...future.oldOptions$nwarnings <- NULL
[16:21:57.961]             }
[16:21:57.961]             base::options(...future.oldOptions)
[16:21:57.961]             if (.Platform$OS.type == "windows") {
[16:21:57.961]                 old_names <- names(...future.oldEnvVars)
[16:21:57.961]                 envs <- base::Sys.getenv()
[16:21:57.961]                 names <- names(envs)
[16:21:57.961]                 common <- intersect(names, old_names)
[16:21:57.961]                 added <- setdiff(names, old_names)
[16:21:57.961]                 removed <- setdiff(old_names, names)
[16:21:57.961]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:57.961]                   envs[common]]
[16:21:57.961]                 NAMES <- toupper(changed)
[16:21:57.961]                 args <- list()
[16:21:57.961]                 for (kk in seq_along(NAMES)) {
[16:21:57.961]                   name <- changed[[kk]]
[16:21:57.961]                   NAME <- NAMES[[kk]]
[16:21:57.961]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.961]                     next
[16:21:57.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.961]                 }
[16:21:57.961]                 NAMES <- toupper(added)
[16:21:57.961]                 for (kk in seq_along(NAMES)) {
[16:21:57.961]                   name <- added[[kk]]
[16:21:57.961]                   NAME <- NAMES[[kk]]
[16:21:57.961]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.961]                     next
[16:21:57.961]                   args[[name]] <- ""
[16:21:57.961]                 }
[16:21:57.961]                 NAMES <- toupper(removed)
[16:21:57.961]                 for (kk in seq_along(NAMES)) {
[16:21:57.961]                   name <- removed[[kk]]
[16:21:57.961]                   NAME <- NAMES[[kk]]
[16:21:57.961]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.961]                     next
[16:21:57.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.961]                 }
[16:21:57.961]                 if (length(args) > 0) 
[16:21:57.961]                   base::do.call(base::Sys.setenv, args = args)
[16:21:57.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:57.961]             }
[16:21:57.961]             else {
[16:21:57.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:57.961]             }
[16:21:57.961]             {
[16:21:57.961]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:57.961]                   0L) {
[16:21:57.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:57.961]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:57.961]                   base::options(opts)
[16:21:57.961]                 }
[16:21:57.961]                 {
[16:21:57.961]                   {
[16:21:57.961]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:57.961]                     NULL
[16:21:57.961]                   }
[16:21:57.961]                   options(future.plan = NULL)
[16:21:57.961]                   if (is.na(NA_character_)) 
[16:21:57.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:57.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:57.961]                     .init = FALSE)
[16:21:57.961]                 }
[16:21:57.961]             }
[16:21:57.961]         }
[16:21:57.961]     })
[16:21:57.961]     if (TRUE) {
[16:21:57.961]         base::sink(type = "output", split = FALSE)
[16:21:57.961]         if (TRUE) {
[16:21:57.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:57.961]         }
[16:21:57.961]         else {
[16:21:57.961]             ...future.result["stdout"] <- base::list(NULL)
[16:21:57.961]         }
[16:21:57.961]         base::close(...future.stdout)
[16:21:57.961]         ...future.stdout <- NULL
[16:21:57.961]     }
[16:21:57.961]     ...future.result$conditions <- ...future.conditions
[16:21:57.961]     ...future.result$finished <- base::Sys.time()
[16:21:57.961]     ...future.result
[16:21:57.961] }
[16:21:57.964] MultisessionFuture started
[16:21:57.964] - Launch lazy future ... done
[16:21:57.964] run() for ‘MultisessionFuture’ ... done
[16:21:57.966] receiveMessageFromWorker() for ClusterFuture ...
[16:21:57.966] - Validating connection of MultisessionFuture
[16:21:57.967] - received message: FutureResult
[16:21:57.967] - Received FutureResult
[16:21:57.967] - Erased future from FutureRegistry
[16:21:57.967] result() for ClusterFuture ...
[16:21:57.967] - result already collected: FutureResult
[16:21:57.967] result() for ClusterFuture ... done
[16:21:57.967] signalConditions() ...
[16:21:57.967]  - include = ‘immediateCondition’
[16:21:57.968]  - exclude = 
[16:21:57.968]  - resignal = FALSE
[16:21:57.968]  - Number of conditions: 1
[16:21:57.968] signalConditions() ... done
[16:21:57.968] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:57.968] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[16:21:57.968] getGlobalsAndPackages() ...
[16:21:57.968] Searching for globals...
[16:21:57.969] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:57.970] Searching for globals ... DONE
[16:21:57.970] Resolving globals: FALSE
[16:21:57.970] 
[16:21:57.970] 
[16:21:57.970] getGlobalsAndPackages() ... DONE
[16:21:57.970] run() for ‘Future’ ...
[16:21:57.970] - state: ‘created’
[16:21:57.971] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:57.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:57.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:57.984]   - Field: ‘node’
[16:21:57.984]   - Field: ‘label’
[16:21:57.985]   - Field: ‘local’
[16:21:57.985]   - Field: ‘owner’
[16:21:57.985]   - Field: ‘envir’
[16:21:57.985]   - Field: ‘workers’
[16:21:57.985]   - Field: ‘packages’
[16:21:57.985]   - Field: ‘gc’
[16:21:57.985]   - Field: ‘conditions’
[16:21:57.985]   - Field: ‘persistent’
[16:21:57.985]   - Field: ‘expr’
[16:21:57.985]   - Field: ‘uuid’
[16:21:57.985]   - Field: ‘seed’
[16:21:57.986]   - Field: ‘version’
[16:21:57.986]   - Field: ‘result’
[16:21:57.986]   - Field: ‘asynchronous’
[16:21:57.986]   - Field: ‘calls’
[16:21:57.986]   - Field: ‘globals’
[16:21:57.986]   - Field: ‘stdout’
[16:21:57.986]   - Field: ‘earlySignal’
[16:21:57.986]   - Field: ‘lazy’
[16:21:57.986]   - Field: ‘state’
[16:21:57.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:57.987] - Launch lazy future ...
[16:21:57.987] Packages needed by the future expression (n = 0): <none>
[16:21:57.987] Packages needed by future strategies (n = 0): <none>
[16:21:57.987] {
[16:21:57.987]     {
[16:21:57.987]         {
[16:21:57.987]             ...future.startTime <- base::Sys.time()
[16:21:57.987]             {
[16:21:57.987]                 {
[16:21:57.987]                   {
[16:21:57.987]                     {
[16:21:57.987]                       base::local({
[16:21:57.987]                         has_future <- base::requireNamespace("future", 
[16:21:57.987]                           quietly = TRUE)
[16:21:57.987]                         if (has_future) {
[16:21:57.987]                           ns <- base::getNamespace("future")
[16:21:57.987]                           version <- ns[[".package"]][["version"]]
[16:21:57.987]                           if (is.null(version)) 
[16:21:57.987]                             version <- utils::packageVersion("future")
[16:21:57.987]                         }
[16:21:57.987]                         else {
[16:21:57.987]                           version <- NULL
[16:21:57.987]                         }
[16:21:57.987]                         if (!has_future || version < "1.8.0") {
[16:21:57.987]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:57.987]                             "", base::R.version$version.string), 
[16:21:57.987]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:57.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:57.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:57.987]                               "release", "version")], collapse = " "), 
[16:21:57.987]                             hostname = base::Sys.info()[["nodename"]])
[16:21:57.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:57.987]                             info)
[16:21:57.987]                           info <- base::paste(info, collapse = "; ")
[16:21:57.987]                           if (!has_future) {
[16:21:57.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:57.987]                               info)
[16:21:57.987]                           }
[16:21:57.987]                           else {
[16:21:57.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:57.987]                               info, version)
[16:21:57.987]                           }
[16:21:57.987]                           base::stop(msg)
[16:21:57.987]                         }
[16:21:57.987]                       })
[16:21:57.987]                     }
[16:21:57.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:57.987]                     base::options(mc.cores = 1L)
[16:21:57.987]                   }
[16:21:57.987]                   ...future.strategy.old <- future::plan("list")
[16:21:57.987]                   options(future.plan = NULL)
[16:21:57.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:57.987]                 }
[16:21:57.987]                 ...future.workdir <- getwd()
[16:21:57.987]             }
[16:21:57.987]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:57.987]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:57.987]         }
[16:21:57.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:57.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:57.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:57.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:57.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:57.987]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:57.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:57.987]             base::names(...future.oldOptions))
[16:21:57.987]     }
[16:21:57.987]     if (FALSE) {
[16:21:57.987]     }
[16:21:57.987]     else {
[16:21:57.987]         if (TRUE) {
[16:21:57.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:57.987]                 open = "w")
[16:21:57.987]         }
[16:21:57.987]         else {
[16:21:57.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:57.987]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:57.987]         }
[16:21:57.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:57.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:57.987]             base::sink(type = "output", split = FALSE)
[16:21:57.987]             base::close(...future.stdout)
[16:21:57.987]         }, add = TRUE)
[16:21:57.987]     }
[16:21:57.987]     ...future.frame <- base::sys.nframe()
[16:21:57.987]     ...future.conditions <- base::list()
[16:21:57.987]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:57.987]     if (FALSE) {
[16:21:57.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:57.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:57.987]     }
[16:21:57.987]     ...future.result <- base::tryCatch({
[16:21:57.987]         base::withCallingHandlers({
[16:21:57.987]             ...future.value <- base::withVisible(base::local({
[16:21:57.987]                 ...future.makeSendCondition <- base::local({
[16:21:57.987]                   sendCondition <- NULL
[16:21:57.987]                   function(frame = 1L) {
[16:21:57.987]                     if (is.function(sendCondition)) 
[16:21:57.987]                       return(sendCondition)
[16:21:57.987]                     ns <- getNamespace("parallel")
[16:21:57.987]                     if (exists("sendData", mode = "function", 
[16:21:57.987]                       envir = ns)) {
[16:21:57.987]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:57.987]                         envir = ns)
[16:21:57.987]                       envir <- sys.frame(frame)
[16:21:57.987]                       master <- NULL
[16:21:57.987]                       while (!identical(envir, .GlobalEnv) && 
[16:21:57.987]                         !identical(envir, emptyenv())) {
[16:21:57.987]                         if (exists("master", mode = "list", envir = envir, 
[16:21:57.987]                           inherits = FALSE)) {
[16:21:57.987]                           master <- get("master", mode = "list", 
[16:21:57.987]                             envir = envir, inherits = FALSE)
[16:21:57.987]                           if (inherits(master, c("SOCKnode", 
[16:21:57.987]                             "SOCK0node"))) {
[16:21:57.987]                             sendCondition <<- function(cond) {
[16:21:57.987]                               data <- list(type = "VALUE", value = cond, 
[16:21:57.987]                                 success = TRUE)
[16:21:57.987]                               parallel_sendData(master, data)
[16:21:57.987]                             }
[16:21:57.987]                             return(sendCondition)
[16:21:57.987]                           }
[16:21:57.987]                         }
[16:21:57.987]                         frame <- frame + 1L
[16:21:57.987]                         envir <- sys.frame(frame)
[16:21:57.987]                       }
[16:21:57.987]                     }
[16:21:57.987]                     sendCondition <<- function(cond) NULL
[16:21:57.987]                   }
[16:21:57.987]                 })
[16:21:57.987]                 withCallingHandlers({
[16:21:57.987]                   {
[16:21:57.987]                     Sys.sleep(0.5)
[16:21:57.987]                     list(a = 1, b = 42L)
[16:21:57.987]                   }
[16:21:57.987]                 }, immediateCondition = function(cond) {
[16:21:57.987]                   sendCondition <- ...future.makeSendCondition()
[16:21:57.987]                   sendCondition(cond)
[16:21:57.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.987]                   {
[16:21:57.987]                     inherits <- base::inherits
[16:21:57.987]                     invokeRestart <- base::invokeRestart
[16:21:57.987]                     is.null <- base::is.null
[16:21:57.987]                     muffled <- FALSE
[16:21:57.987]                     if (inherits(cond, "message")) {
[16:21:57.987]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:57.987]                       if (muffled) 
[16:21:57.987]                         invokeRestart("muffleMessage")
[16:21:57.987]                     }
[16:21:57.987]                     else if (inherits(cond, "warning")) {
[16:21:57.987]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:57.987]                       if (muffled) 
[16:21:57.987]                         invokeRestart("muffleWarning")
[16:21:57.987]                     }
[16:21:57.987]                     else if (inherits(cond, "condition")) {
[16:21:57.987]                       if (!is.null(pattern)) {
[16:21:57.987]                         computeRestarts <- base::computeRestarts
[16:21:57.987]                         grepl <- base::grepl
[16:21:57.987]                         restarts <- computeRestarts(cond)
[16:21:57.987]                         for (restart in restarts) {
[16:21:57.987]                           name <- restart$name
[16:21:57.987]                           if (is.null(name)) 
[16:21:57.987]                             next
[16:21:57.987]                           if (!grepl(pattern, name)) 
[16:21:57.987]                             next
[16:21:57.987]                           invokeRestart(restart)
[16:21:57.987]                           muffled <- TRUE
[16:21:57.987]                           break
[16:21:57.987]                         }
[16:21:57.987]                       }
[16:21:57.987]                     }
[16:21:57.987]                     invisible(muffled)
[16:21:57.987]                   }
[16:21:57.987]                   muffleCondition(cond)
[16:21:57.987]                 })
[16:21:57.987]             }))
[16:21:57.987]             future::FutureResult(value = ...future.value$value, 
[16:21:57.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.987]                   ...future.rng), globalenv = if (FALSE) 
[16:21:57.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:57.987]                     ...future.globalenv.names))
[16:21:57.987]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:57.987]         }, condition = base::local({
[16:21:57.987]             c <- base::c
[16:21:57.987]             inherits <- base::inherits
[16:21:57.987]             invokeRestart <- base::invokeRestart
[16:21:57.987]             length <- base::length
[16:21:57.987]             list <- base::list
[16:21:57.987]             seq.int <- base::seq.int
[16:21:57.987]             signalCondition <- base::signalCondition
[16:21:57.987]             sys.calls <- base::sys.calls
[16:21:57.987]             `[[` <- base::`[[`
[16:21:57.987]             `+` <- base::`+`
[16:21:57.987]             `<<-` <- base::`<<-`
[16:21:57.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:57.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:57.987]                   3L)]
[16:21:57.987]             }
[16:21:57.987]             function(cond) {
[16:21:57.987]                 is_error <- inherits(cond, "error")
[16:21:57.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:57.987]                   NULL)
[16:21:57.987]                 if (is_error) {
[16:21:57.987]                   sessionInformation <- function() {
[16:21:57.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:57.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:57.987]                       search = base::search(), system = base::Sys.info())
[16:21:57.987]                   }
[16:21:57.987]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:57.987]                     cond$call), session = sessionInformation(), 
[16:21:57.987]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:57.987]                   signalCondition(cond)
[16:21:57.987]                 }
[16:21:57.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:57.987]                 "immediateCondition"))) {
[16:21:57.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:57.987]                   ...future.conditions[[length(...future.conditions) + 
[16:21:57.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:57.987]                   if (TRUE && !signal) {
[16:21:57.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.987]                     {
[16:21:57.987]                       inherits <- base::inherits
[16:21:57.987]                       invokeRestart <- base::invokeRestart
[16:21:57.987]                       is.null <- base::is.null
[16:21:57.987]                       muffled <- FALSE
[16:21:57.987]                       if (inherits(cond, "message")) {
[16:21:57.987]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.987]                         if (muffled) 
[16:21:57.987]                           invokeRestart("muffleMessage")
[16:21:57.987]                       }
[16:21:57.987]                       else if (inherits(cond, "warning")) {
[16:21:57.987]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.987]                         if (muffled) 
[16:21:57.987]                           invokeRestart("muffleWarning")
[16:21:57.987]                       }
[16:21:57.987]                       else if (inherits(cond, "condition")) {
[16:21:57.987]                         if (!is.null(pattern)) {
[16:21:57.987]                           computeRestarts <- base::computeRestarts
[16:21:57.987]                           grepl <- base::grepl
[16:21:57.987]                           restarts <- computeRestarts(cond)
[16:21:57.987]                           for (restart in restarts) {
[16:21:57.987]                             name <- restart$name
[16:21:57.987]                             if (is.null(name)) 
[16:21:57.987]                               next
[16:21:57.987]                             if (!grepl(pattern, name)) 
[16:21:57.987]                               next
[16:21:57.987]                             invokeRestart(restart)
[16:21:57.987]                             muffled <- TRUE
[16:21:57.987]                             break
[16:21:57.987]                           }
[16:21:57.987]                         }
[16:21:57.987]                       }
[16:21:57.987]                       invisible(muffled)
[16:21:57.987]                     }
[16:21:57.987]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.987]                   }
[16:21:57.987]                 }
[16:21:57.987]                 else {
[16:21:57.987]                   if (TRUE) {
[16:21:57.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:57.987]                     {
[16:21:57.987]                       inherits <- base::inherits
[16:21:57.987]                       invokeRestart <- base::invokeRestart
[16:21:57.987]                       is.null <- base::is.null
[16:21:57.987]                       muffled <- FALSE
[16:21:57.987]                       if (inherits(cond, "message")) {
[16:21:57.987]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:57.987]                         if (muffled) 
[16:21:57.987]                           invokeRestart("muffleMessage")
[16:21:57.987]                       }
[16:21:57.987]                       else if (inherits(cond, "warning")) {
[16:21:57.987]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:57.987]                         if (muffled) 
[16:21:57.987]                           invokeRestart("muffleWarning")
[16:21:57.987]                       }
[16:21:57.987]                       else if (inherits(cond, "condition")) {
[16:21:57.987]                         if (!is.null(pattern)) {
[16:21:57.987]                           computeRestarts <- base::computeRestarts
[16:21:57.987]                           grepl <- base::grepl
[16:21:57.987]                           restarts <- computeRestarts(cond)
[16:21:57.987]                           for (restart in restarts) {
[16:21:57.987]                             name <- restart$name
[16:21:57.987]                             if (is.null(name)) 
[16:21:57.987]                               next
[16:21:57.987]                             if (!grepl(pattern, name)) 
[16:21:57.987]                               next
[16:21:57.987]                             invokeRestart(restart)
[16:21:57.987]                             muffled <- TRUE
[16:21:57.987]                             break
[16:21:57.987]                           }
[16:21:57.987]                         }
[16:21:57.987]                       }
[16:21:57.987]                       invisible(muffled)
[16:21:57.987]                     }
[16:21:57.987]                     muffleCondition(cond, pattern = "^muffle")
[16:21:57.987]                   }
[16:21:57.987]                 }
[16:21:57.987]             }
[16:21:57.987]         }))
[16:21:57.987]     }, error = function(ex) {
[16:21:57.987]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:57.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:57.987]                 ...future.rng), started = ...future.startTime, 
[16:21:57.987]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:57.987]             version = "1.8"), class = "FutureResult")
[16:21:57.987]     }, finally = {
[16:21:57.987]         if (!identical(...future.workdir, getwd())) 
[16:21:57.987]             setwd(...future.workdir)
[16:21:57.987]         {
[16:21:57.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:57.987]                 ...future.oldOptions$nwarnings <- NULL
[16:21:57.987]             }
[16:21:57.987]             base::options(...future.oldOptions)
[16:21:57.987]             if (.Platform$OS.type == "windows") {
[16:21:57.987]                 old_names <- names(...future.oldEnvVars)
[16:21:57.987]                 envs <- base::Sys.getenv()
[16:21:57.987]                 names <- names(envs)
[16:21:57.987]                 common <- intersect(names, old_names)
[16:21:57.987]                 added <- setdiff(names, old_names)
[16:21:57.987]                 removed <- setdiff(old_names, names)
[16:21:57.987]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:57.987]                   envs[common]]
[16:21:57.987]                 NAMES <- toupper(changed)
[16:21:57.987]                 args <- list()
[16:21:57.987]                 for (kk in seq_along(NAMES)) {
[16:21:57.987]                   name <- changed[[kk]]
[16:21:57.987]                   NAME <- NAMES[[kk]]
[16:21:57.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.987]                     next
[16:21:57.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.987]                 }
[16:21:57.987]                 NAMES <- toupper(added)
[16:21:57.987]                 for (kk in seq_along(NAMES)) {
[16:21:57.987]                   name <- added[[kk]]
[16:21:57.987]                   NAME <- NAMES[[kk]]
[16:21:57.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.987]                     next
[16:21:57.987]                   args[[name]] <- ""
[16:21:57.987]                 }
[16:21:57.987]                 NAMES <- toupper(removed)
[16:21:57.987]                 for (kk in seq_along(NAMES)) {
[16:21:57.987]                   name <- removed[[kk]]
[16:21:57.987]                   NAME <- NAMES[[kk]]
[16:21:57.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:57.987]                     next
[16:21:57.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:57.987]                 }
[16:21:57.987]                 if (length(args) > 0) 
[16:21:57.987]                   base::do.call(base::Sys.setenv, args = args)
[16:21:57.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:57.987]             }
[16:21:57.987]             else {
[16:21:57.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:57.987]             }
[16:21:57.987]             {
[16:21:57.987]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:57.987]                   0L) {
[16:21:57.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:57.987]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:57.987]                   base::options(opts)
[16:21:57.987]                 }
[16:21:57.987]                 {
[16:21:57.987]                   {
[16:21:57.987]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:57.987]                     NULL
[16:21:57.987]                   }
[16:21:57.987]                   options(future.plan = NULL)
[16:21:57.987]                   if (is.na(NA_character_)) 
[16:21:57.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:57.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:57.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:57.987]                     .init = FALSE)
[16:21:57.987]                 }
[16:21:57.987]             }
[16:21:57.987]         }
[16:21:57.987]     })
[16:21:57.987]     if (TRUE) {
[16:21:57.987]         base::sink(type = "output", split = FALSE)
[16:21:57.987]         if (TRUE) {
[16:21:57.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:57.987]         }
[16:21:57.987]         else {
[16:21:57.987]             ...future.result["stdout"] <- base::list(NULL)
[16:21:57.987]         }
[16:21:57.987]         base::close(...future.stdout)
[16:21:57.987]         ...future.stdout <- NULL
[16:21:57.987]     }
[16:21:57.987]     ...future.result$conditions <- ...future.conditions
[16:21:57.987]     ...future.result$finished <- base::Sys.time()
[16:21:57.987]     ...future.result
[16:21:57.987] }
[16:21:57.990] MultisessionFuture started
[16:21:57.990] - Launch lazy future ... done
[16:21:57.990] run() for ‘MultisessionFuture’ ... done
[16:21:58.493] receiveMessageFromWorker() for ClusterFuture ...
[16:21:58.493] - Validating connection of MultisessionFuture
[16:21:58.493] - received message: FutureResult
[16:21:58.493] - Received FutureResult
[16:21:58.494] - Erased future from FutureRegistry
[16:21:58.494] result() for ClusterFuture ...
[16:21:58.494] - result already collected: FutureResult
[16:21:58.494] result() for ClusterFuture ... done
[16:21:58.494] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:58.494] A MultisessionFuture was resolved (result was not collected)
[16:21:58.494] getGlobalsAndPackages() ...
[16:21:58.494] Searching for globals...
[16:21:58.495] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:58.496] Searching for globals ... DONE
[16:21:58.496] Resolving globals: FALSE
[16:21:58.496] 
[16:21:58.496] 
[16:21:58.496] getGlobalsAndPackages() ... DONE
[16:21:58.496] run() for ‘Future’ ...
[16:21:58.497] - state: ‘created’
[16:21:58.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:58.510] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:58.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:58.511]   - Field: ‘node’
[16:21:58.511]   - Field: ‘label’
[16:21:58.511]   - Field: ‘local’
[16:21:58.511]   - Field: ‘owner’
[16:21:58.511]   - Field: ‘envir’
[16:21:58.511]   - Field: ‘workers’
[16:21:58.511]   - Field: ‘packages’
[16:21:58.511]   - Field: ‘gc’
[16:21:58.511]   - Field: ‘conditions’
[16:21:58.511]   - Field: ‘persistent’
[16:21:58.512]   - Field: ‘expr’
[16:21:58.512]   - Field: ‘uuid’
[16:21:58.512]   - Field: ‘seed’
[16:21:58.512]   - Field: ‘version’
[16:21:58.512]   - Field: ‘result’
[16:21:58.512]   - Field: ‘asynchronous’
[16:21:58.512]   - Field: ‘calls’
[16:21:58.512]   - Field: ‘globals’
[16:21:58.512]   - Field: ‘stdout’
[16:21:58.512]   - Field: ‘earlySignal’
[16:21:58.513]   - Field: ‘lazy’
[16:21:58.513]   - Field: ‘state’
[16:21:58.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:58.513] - Launch lazy future ...
[16:21:58.513] Packages needed by the future expression (n = 0): <none>
[16:21:58.513] Packages needed by future strategies (n = 0): <none>
[16:21:58.514] {
[16:21:58.514]     {
[16:21:58.514]         {
[16:21:58.514]             ...future.startTime <- base::Sys.time()
[16:21:58.514]             {
[16:21:58.514]                 {
[16:21:58.514]                   {
[16:21:58.514]                     {
[16:21:58.514]                       base::local({
[16:21:58.514]                         has_future <- base::requireNamespace("future", 
[16:21:58.514]                           quietly = TRUE)
[16:21:58.514]                         if (has_future) {
[16:21:58.514]                           ns <- base::getNamespace("future")
[16:21:58.514]                           version <- ns[[".package"]][["version"]]
[16:21:58.514]                           if (is.null(version)) 
[16:21:58.514]                             version <- utils::packageVersion("future")
[16:21:58.514]                         }
[16:21:58.514]                         else {
[16:21:58.514]                           version <- NULL
[16:21:58.514]                         }
[16:21:58.514]                         if (!has_future || version < "1.8.0") {
[16:21:58.514]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:58.514]                             "", base::R.version$version.string), 
[16:21:58.514]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:58.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:58.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:58.514]                               "release", "version")], collapse = " "), 
[16:21:58.514]                             hostname = base::Sys.info()[["nodename"]])
[16:21:58.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:58.514]                             info)
[16:21:58.514]                           info <- base::paste(info, collapse = "; ")
[16:21:58.514]                           if (!has_future) {
[16:21:58.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:58.514]                               info)
[16:21:58.514]                           }
[16:21:58.514]                           else {
[16:21:58.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:58.514]                               info, version)
[16:21:58.514]                           }
[16:21:58.514]                           base::stop(msg)
[16:21:58.514]                         }
[16:21:58.514]                       })
[16:21:58.514]                     }
[16:21:58.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:58.514]                     base::options(mc.cores = 1L)
[16:21:58.514]                   }
[16:21:58.514]                   ...future.strategy.old <- future::plan("list")
[16:21:58.514]                   options(future.plan = NULL)
[16:21:58.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:58.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:58.514]                 }
[16:21:58.514]                 ...future.workdir <- getwd()
[16:21:58.514]             }
[16:21:58.514]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:58.514]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:58.514]         }
[16:21:58.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:58.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:58.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:58.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:58.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:58.514]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:58.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:58.514]             base::names(...future.oldOptions))
[16:21:58.514]     }
[16:21:58.514]     if (FALSE) {
[16:21:58.514]     }
[16:21:58.514]     else {
[16:21:58.514]         if (TRUE) {
[16:21:58.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:58.514]                 open = "w")
[16:21:58.514]         }
[16:21:58.514]         else {
[16:21:58.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:58.514]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:58.514]         }
[16:21:58.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:58.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:58.514]             base::sink(type = "output", split = FALSE)
[16:21:58.514]             base::close(...future.stdout)
[16:21:58.514]         }, add = TRUE)
[16:21:58.514]     }
[16:21:58.514]     ...future.frame <- base::sys.nframe()
[16:21:58.514]     ...future.conditions <- base::list()
[16:21:58.514]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:58.514]     if (FALSE) {
[16:21:58.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:58.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:58.514]     }
[16:21:58.514]     ...future.result <- base::tryCatch({
[16:21:58.514]         base::withCallingHandlers({
[16:21:58.514]             ...future.value <- base::withVisible(base::local({
[16:21:58.514]                 ...future.makeSendCondition <- base::local({
[16:21:58.514]                   sendCondition <- NULL
[16:21:58.514]                   function(frame = 1L) {
[16:21:58.514]                     if (is.function(sendCondition)) 
[16:21:58.514]                       return(sendCondition)
[16:21:58.514]                     ns <- getNamespace("parallel")
[16:21:58.514]                     if (exists("sendData", mode = "function", 
[16:21:58.514]                       envir = ns)) {
[16:21:58.514]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:58.514]                         envir = ns)
[16:21:58.514]                       envir <- sys.frame(frame)
[16:21:58.514]                       master <- NULL
[16:21:58.514]                       while (!identical(envir, .GlobalEnv) && 
[16:21:58.514]                         !identical(envir, emptyenv())) {
[16:21:58.514]                         if (exists("master", mode = "list", envir = envir, 
[16:21:58.514]                           inherits = FALSE)) {
[16:21:58.514]                           master <- get("master", mode = "list", 
[16:21:58.514]                             envir = envir, inherits = FALSE)
[16:21:58.514]                           if (inherits(master, c("SOCKnode", 
[16:21:58.514]                             "SOCK0node"))) {
[16:21:58.514]                             sendCondition <<- function(cond) {
[16:21:58.514]                               data <- list(type = "VALUE", value = cond, 
[16:21:58.514]                                 success = TRUE)
[16:21:58.514]                               parallel_sendData(master, data)
[16:21:58.514]                             }
[16:21:58.514]                             return(sendCondition)
[16:21:58.514]                           }
[16:21:58.514]                         }
[16:21:58.514]                         frame <- frame + 1L
[16:21:58.514]                         envir <- sys.frame(frame)
[16:21:58.514]                       }
[16:21:58.514]                     }
[16:21:58.514]                     sendCondition <<- function(cond) NULL
[16:21:58.514]                   }
[16:21:58.514]                 })
[16:21:58.514]                 withCallingHandlers({
[16:21:58.514]                   {
[16:21:58.514]                     Sys.sleep(0.5)
[16:21:58.514]                     list(a = 1, b = 42L)
[16:21:58.514]                   }
[16:21:58.514]                 }, immediateCondition = function(cond) {
[16:21:58.514]                   sendCondition <- ...future.makeSendCondition()
[16:21:58.514]                   sendCondition(cond)
[16:21:58.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:58.514]                   {
[16:21:58.514]                     inherits <- base::inherits
[16:21:58.514]                     invokeRestart <- base::invokeRestart
[16:21:58.514]                     is.null <- base::is.null
[16:21:58.514]                     muffled <- FALSE
[16:21:58.514]                     if (inherits(cond, "message")) {
[16:21:58.514]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:58.514]                       if (muffled) 
[16:21:58.514]                         invokeRestart("muffleMessage")
[16:21:58.514]                     }
[16:21:58.514]                     else if (inherits(cond, "warning")) {
[16:21:58.514]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:58.514]                       if (muffled) 
[16:21:58.514]                         invokeRestart("muffleWarning")
[16:21:58.514]                     }
[16:21:58.514]                     else if (inherits(cond, "condition")) {
[16:21:58.514]                       if (!is.null(pattern)) {
[16:21:58.514]                         computeRestarts <- base::computeRestarts
[16:21:58.514]                         grepl <- base::grepl
[16:21:58.514]                         restarts <- computeRestarts(cond)
[16:21:58.514]                         for (restart in restarts) {
[16:21:58.514]                           name <- restart$name
[16:21:58.514]                           if (is.null(name)) 
[16:21:58.514]                             next
[16:21:58.514]                           if (!grepl(pattern, name)) 
[16:21:58.514]                             next
[16:21:58.514]                           invokeRestart(restart)
[16:21:58.514]                           muffled <- TRUE
[16:21:58.514]                           break
[16:21:58.514]                         }
[16:21:58.514]                       }
[16:21:58.514]                     }
[16:21:58.514]                     invisible(muffled)
[16:21:58.514]                   }
[16:21:58.514]                   muffleCondition(cond)
[16:21:58.514]                 })
[16:21:58.514]             }))
[16:21:58.514]             future::FutureResult(value = ...future.value$value, 
[16:21:58.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:58.514]                   ...future.rng), globalenv = if (FALSE) 
[16:21:58.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:58.514]                     ...future.globalenv.names))
[16:21:58.514]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:58.514]         }, condition = base::local({
[16:21:58.514]             c <- base::c
[16:21:58.514]             inherits <- base::inherits
[16:21:58.514]             invokeRestart <- base::invokeRestart
[16:21:58.514]             length <- base::length
[16:21:58.514]             list <- base::list
[16:21:58.514]             seq.int <- base::seq.int
[16:21:58.514]             signalCondition <- base::signalCondition
[16:21:58.514]             sys.calls <- base::sys.calls
[16:21:58.514]             `[[` <- base::`[[`
[16:21:58.514]             `+` <- base::`+`
[16:21:58.514]             `<<-` <- base::`<<-`
[16:21:58.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:58.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:58.514]                   3L)]
[16:21:58.514]             }
[16:21:58.514]             function(cond) {
[16:21:58.514]                 is_error <- inherits(cond, "error")
[16:21:58.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:58.514]                   NULL)
[16:21:58.514]                 if (is_error) {
[16:21:58.514]                   sessionInformation <- function() {
[16:21:58.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:58.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:58.514]                       search = base::search(), system = base::Sys.info())
[16:21:58.514]                   }
[16:21:58.514]                   ...future.conditions[[length(...future.conditions) + 
[16:21:58.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:58.514]                     cond$call), session = sessionInformation(), 
[16:21:58.514]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:58.514]                   signalCondition(cond)
[16:21:58.514]                 }
[16:21:58.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:58.514]                 "immediateCondition"))) {
[16:21:58.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:58.514]                   ...future.conditions[[length(...future.conditions) + 
[16:21:58.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:58.514]                   if (TRUE && !signal) {
[16:21:58.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:58.514]                     {
[16:21:58.514]                       inherits <- base::inherits
[16:21:58.514]                       invokeRestart <- base::invokeRestart
[16:21:58.514]                       is.null <- base::is.null
[16:21:58.514]                       muffled <- FALSE
[16:21:58.514]                       if (inherits(cond, "message")) {
[16:21:58.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:58.514]                         if (muffled) 
[16:21:58.514]                           invokeRestart("muffleMessage")
[16:21:58.514]                       }
[16:21:58.514]                       else if (inherits(cond, "warning")) {
[16:21:58.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:58.514]                         if (muffled) 
[16:21:58.514]                           invokeRestart("muffleWarning")
[16:21:58.514]                       }
[16:21:58.514]                       else if (inherits(cond, "condition")) {
[16:21:58.514]                         if (!is.null(pattern)) {
[16:21:58.514]                           computeRestarts <- base::computeRestarts
[16:21:58.514]                           grepl <- base::grepl
[16:21:58.514]                           restarts <- computeRestarts(cond)
[16:21:58.514]                           for (restart in restarts) {
[16:21:58.514]                             name <- restart$name
[16:21:58.514]                             if (is.null(name)) 
[16:21:58.514]                               next
[16:21:58.514]                             if (!grepl(pattern, name)) 
[16:21:58.514]                               next
[16:21:58.514]                             invokeRestart(restart)
[16:21:58.514]                             muffled <- TRUE
[16:21:58.514]                             break
[16:21:58.514]                           }
[16:21:58.514]                         }
[16:21:58.514]                       }
[16:21:58.514]                       invisible(muffled)
[16:21:58.514]                     }
[16:21:58.514]                     muffleCondition(cond, pattern = "^muffle")
[16:21:58.514]                   }
[16:21:58.514]                 }
[16:21:58.514]                 else {
[16:21:58.514]                   if (TRUE) {
[16:21:58.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:58.514]                     {
[16:21:58.514]                       inherits <- base::inherits
[16:21:58.514]                       invokeRestart <- base::invokeRestart
[16:21:58.514]                       is.null <- base::is.null
[16:21:58.514]                       muffled <- FALSE
[16:21:58.514]                       if (inherits(cond, "message")) {
[16:21:58.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:58.514]                         if (muffled) 
[16:21:58.514]                           invokeRestart("muffleMessage")
[16:21:58.514]                       }
[16:21:58.514]                       else if (inherits(cond, "warning")) {
[16:21:58.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:58.514]                         if (muffled) 
[16:21:58.514]                           invokeRestart("muffleWarning")
[16:21:58.514]                       }
[16:21:58.514]                       else if (inherits(cond, "condition")) {
[16:21:58.514]                         if (!is.null(pattern)) {
[16:21:58.514]                           computeRestarts <- base::computeRestarts
[16:21:58.514]                           grepl <- base::grepl
[16:21:58.514]                           restarts <- computeRestarts(cond)
[16:21:58.514]                           for (restart in restarts) {
[16:21:58.514]                             name <- restart$name
[16:21:58.514]                             if (is.null(name)) 
[16:21:58.514]                               next
[16:21:58.514]                             if (!grepl(pattern, name)) 
[16:21:58.514]                               next
[16:21:58.514]                             invokeRestart(restart)
[16:21:58.514]                             muffled <- TRUE
[16:21:58.514]                             break
[16:21:58.514]                           }
[16:21:58.514]                         }
[16:21:58.514]                       }
[16:21:58.514]                       invisible(muffled)
[16:21:58.514]                     }
[16:21:58.514]                     muffleCondition(cond, pattern = "^muffle")
[16:21:58.514]                   }
[16:21:58.514]                 }
[16:21:58.514]             }
[16:21:58.514]         }))
[16:21:58.514]     }, error = function(ex) {
[16:21:58.514]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:58.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:58.514]                 ...future.rng), started = ...future.startTime, 
[16:21:58.514]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:58.514]             version = "1.8"), class = "FutureResult")
[16:21:58.514]     }, finally = {
[16:21:58.514]         if (!identical(...future.workdir, getwd())) 
[16:21:58.514]             setwd(...future.workdir)
[16:21:58.514]         {
[16:21:58.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:58.514]                 ...future.oldOptions$nwarnings <- NULL
[16:21:58.514]             }
[16:21:58.514]             base::options(...future.oldOptions)
[16:21:58.514]             if (.Platform$OS.type == "windows") {
[16:21:58.514]                 old_names <- names(...future.oldEnvVars)
[16:21:58.514]                 envs <- base::Sys.getenv()
[16:21:58.514]                 names <- names(envs)
[16:21:58.514]                 common <- intersect(names, old_names)
[16:21:58.514]                 added <- setdiff(names, old_names)
[16:21:58.514]                 removed <- setdiff(old_names, names)
[16:21:58.514]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:58.514]                   envs[common]]
[16:21:58.514]                 NAMES <- toupper(changed)
[16:21:58.514]                 args <- list()
[16:21:58.514]                 for (kk in seq_along(NAMES)) {
[16:21:58.514]                   name <- changed[[kk]]
[16:21:58.514]                   NAME <- NAMES[[kk]]
[16:21:58.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:58.514]                     next
[16:21:58.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:58.514]                 }
[16:21:58.514]                 NAMES <- toupper(added)
[16:21:58.514]                 for (kk in seq_along(NAMES)) {
[16:21:58.514]                   name <- added[[kk]]
[16:21:58.514]                   NAME <- NAMES[[kk]]
[16:21:58.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:58.514]                     next
[16:21:58.514]                   args[[name]] <- ""
[16:21:58.514]                 }
[16:21:58.514]                 NAMES <- toupper(removed)
[16:21:58.514]                 for (kk in seq_along(NAMES)) {
[16:21:58.514]                   name <- removed[[kk]]
[16:21:58.514]                   NAME <- NAMES[[kk]]
[16:21:58.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:58.514]                     next
[16:21:58.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:58.514]                 }
[16:21:58.514]                 if (length(args) > 0) 
[16:21:58.514]                   base::do.call(base::Sys.setenv, args = args)
[16:21:58.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:58.514]             }
[16:21:58.514]             else {
[16:21:58.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:58.514]             }
[16:21:58.514]             {
[16:21:58.514]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:58.514]                   0L) {
[16:21:58.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:58.514]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:58.514]                   base::options(opts)
[16:21:58.514]                 }
[16:21:58.514]                 {
[16:21:58.514]                   {
[16:21:58.514]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:58.514]                     NULL
[16:21:58.514]                   }
[16:21:58.514]                   options(future.plan = NULL)
[16:21:58.514]                   if (is.na(NA_character_)) 
[16:21:58.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:58.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:58.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:58.514]                     .init = FALSE)
[16:21:58.514]                 }
[16:21:58.514]             }
[16:21:58.514]         }
[16:21:58.514]     })
[16:21:58.514]     if (TRUE) {
[16:21:58.514]         base::sink(type = "output", split = FALSE)
[16:21:58.514]         if (TRUE) {
[16:21:58.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:58.514]         }
[16:21:58.514]         else {
[16:21:58.514]             ...future.result["stdout"] <- base::list(NULL)
[16:21:58.514]         }
[16:21:58.514]         base::close(...future.stdout)
[16:21:58.514]         ...future.stdout <- NULL
[16:21:58.514]     }
[16:21:58.514]     ...future.result$conditions <- ...future.conditions
[16:21:58.514]     ...future.result$finished <- base::Sys.time()
[16:21:58.514]     ...future.result
[16:21:58.514] }
[16:21:58.517] MultisessionFuture started
[16:21:58.517] - Launch lazy future ... done
[16:21:58.517] run() for ‘MultisessionFuture’ ... done
[16:21:59.019] receiveMessageFromWorker() for ClusterFuture ...
[16:21:59.020] - Validating connection of MultisessionFuture
[16:21:59.020] - received message: FutureResult
[16:21:59.020] - Received FutureResult
[16:21:59.020] - Erased future from FutureRegistry
[16:21:59.020] result() for ClusterFuture ...
[16:21:59.020] - result already collected: FutureResult
[16:21:59.021] result() for ClusterFuture ... done
[16:21:59.021] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:59.021] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:21:59.021] getGlobalsAndPackages() ...
[16:21:59.021] Searching for globals...
[16:21:59.022] - globals found: [2] ‘list’, ‘stop’
[16:21:59.022] Searching for globals ... DONE
[16:21:59.022] Resolving globals: FALSE
[16:21:59.022] 
[16:21:59.022] 
[16:21:59.022] getGlobalsAndPackages() ... DONE
[16:21:59.023] run() for ‘Future’ ...
[16:21:59.023] - state: ‘created’
[16:21:59.023] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:59.037] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:59.037] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:59.037]   - Field: ‘node’
[16:21:59.037]   - Field: ‘label’
[16:21:59.037]   - Field: ‘local’
[16:21:59.037]   - Field: ‘owner’
[16:21:59.037]   - Field: ‘envir’
[16:21:59.038]   - Field: ‘workers’
[16:21:59.038]   - Field: ‘packages’
[16:21:59.038]   - Field: ‘gc’
[16:21:59.038]   - Field: ‘conditions’
[16:21:59.038]   - Field: ‘persistent’
[16:21:59.038]   - Field: ‘expr’
[16:21:59.038]   - Field: ‘uuid’
[16:21:59.038]   - Field: ‘seed’
[16:21:59.038]   - Field: ‘version’
[16:21:59.038]   - Field: ‘result’
[16:21:59.038]   - Field: ‘asynchronous’
[16:21:59.038]   - Field: ‘calls’
[16:21:59.039]   - Field: ‘globals’
[16:21:59.039]   - Field: ‘stdout’
[16:21:59.039]   - Field: ‘earlySignal’
[16:21:59.039]   - Field: ‘lazy’
[16:21:59.039]   - Field: ‘state’
[16:21:59.039] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:59.039] - Launch lazy future ...
[16:21:59.039] Packages needed by the future expression (n = 0): <none>
[16:21:59.040] Packages needed by future strategies (n = 0): <none>
[16:21:59.040] {
[16:21:59.040]     {
[16:21:59.040]         {
[16:21:59.040]             ...future.startTime <- base::Sys.time()
[16:21:59.040]             {
[16:21:59.040]                 {
[16:21:59.040]                   {
[16:21:59.040]                     {
[16:21:59.040]                       base::local({
[16:21:59.040]                         has_future <- base::requireNamespace("future", 
[16:21:59.040]                           quietly = TRUE)
[16:21:59.040]                         if (has_future) {
[16:21:59.040]                           ns <- base::getNamespace("future")
[16:21:59.040]                           version <- ns[[".package"]][["version"]]
[16:21:59.040]                           if (is.null(version)) 
[16:21:59.040]                             version <- utils::packageVersion("future")
[16:21:59.040]                         }
[16:21:59.040]                         else {
[16:21:59.040]                           version <- NULL
[16:21:59.040]                         }
[16:21:59.040]                         if (!has_future || version < "1.8.0") {
[16:21:59.040]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:59.040]                             "", base::R.version$version.string), 
[16:21:59.040]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:59.040]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:59.040]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:59.040]                               "release", "version")], collapse = " "), 
[16:21:59.040]                             hostname = base::Sys.info()[["nodename"]])
[16:21:59.040]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:59.040]                             info)
[16:21:59.040]                           info <- base::paste(info, collapse = "; ")
[16:21:59.040]                           if (!has_future) {
[16:21:59.040]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:59.040]                               info)
[16:21:59.040]                           }
[16:21:59.040]                           else {
[16:21:59.040]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:59.040]                               info, version)
[16:21:59.040]                           }
[16:21:59.040]                           base::stop(msg)
[16:21:59.040]                         }
[16:21:59.040]                       })
[16:21:59.040]                     }
[16:21:59.040]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:59.040]                     base::options(mc.cores = 1L)
[16:21:59.040]                   }
[16:21:59.040]                   ...future.strategy.old <- future::plan("list")
[16:21:59.040]                   options(future.plan = NULL)
[16:21:59.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:59.040]                 }
[16:21:59.040]                 ...future.workdir <- getwd()
[16:21:59.040]             }
[16:21:59.040]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:59.040]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:59.040]         }
[16:21:59.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:59.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:59.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:59.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:59.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:59.040]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:59.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:59.040]             base::names(...future.oldOptions))
[16:21:59.040]     }
[16:21:59.040]     if (FALSE) {
[16:21:59.040]     }
[16:21:59.040]     else {
[16:21:59.040]         if (TRUE) {
[16:21:59.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:59.040]                 open = "w")
[16:21:59.040]         }
[16:21:59.040]         else {
[16:21:59.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:59.040]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:59.040]         }
[16:21:59.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:59.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:59.040]             base::sink(type = "output", split = FALSE)
[16:21:59.040]             base::close(...future.stdout)
[16:21:59.040]         }, add = TRUE)
[16:21:59.040]     }
[16:21:59.040]     ...future.frame <- base::sys.nframe()
[16:21:59.040]     ...future.conditions <- base::list()
[16:21:59.040]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:59.040]     if (FALSE) {
[16:21:59.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:59.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:59.040]     }
[16:21:59.040]     ...future.result <- base::tryCatch({
[16:21:59.040]         base::withCallingHandlers({
[16:21:59.040]             ...future.value <- base::withVisible(base::local({
[16:21:59.040]                 ...future.makeSendCondition <- base::local({
[16:21:59.040]                   sendCondition <- NULL
[16:21:59.040]                   function(frame = 1L) {
[16:21:59.040]                     if (is.function(sendCondition)) 
[16:21:59.040]                       return(sendCondition)
[16:21:59.040]                     ns <- getNamespace("parallel")
[16:21:59.040]                     if (exists("sendData", mode = "function", 
[16:21:59.040]                       envir = ns)) {
[16:21:59.040]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:59.040]                         envir = ns)
[16:21:59.040]                       envir <- sys.frame(frame)
[16:21:59.040]                       master <- NULL
[16:21:59.040]                       while (!identical(envir, .GlobalEnv) && 
[16:21:59.040]                         !identical(envir, emptyenv())) {
[16:21:59.040]                         if (exists("master", mode = "list", envir = envir, 
[16:21:59.040]                           inherits = FALSE)) {
[16:21:59.040]                           master <- get("master", mode = "list", 
[16:21:59.040]                             envir = envir, inherits = FALSE)
[16:21:59.040]                           if (inherits(master, c("SOCKnode", 
[16:21:59.040]                             "SOCK0node"))) {
[16:21:59.040]                             sendCondition <<- function(cond) {
[16:21:59.040]                               data <- list(type = "VALUE", value = cond, 
[16:21:59.040]                                 success = TRUE)
[16:21:59.040]                               parallel_sendData(master, data)
[16:21:59.040]                             }
[16:21:59.040]                             return(sendCondition)
[16:21:59.040]                           }
[16:21:59.040]                         }
[16:21:59.040]                         frame <- frame + 1L
[16:21:59.040]                         envir <- sys.frame(frame)
[16:21:59.040]                       }
[16:21:59.040]                     }
[16:21:59.040]                     sendCondition <<- function(cond) NULL
[16:21:59.040]                   }
[16:21:59.040]                 })
[16:21:59.040]                 withCallingHandlers({
[16:21:59.040]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:59.040]                 }, immediateCondition = function(cond) {
[16:21:59.040]                   sendCondition <- ...future.makeSendCondition()
[16:21:59.040]                   sendCondition(cond)
[16:21:59.040]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.040]                   {
[16:21:59.040]                     inherits <- base::inherits
[16:21:59.040]                     invokeRestart <- base::invokeRestart
[16:21:59.040]                     is.null <- base::is.null
[16:21:59.040]                     muffled <- FALSE
[16:21:59.040]                     if (inherits(cond, "message")) {
[16:21:59.040]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:59.040]                       if (muffled) 
[16:21:59.040]                         invokeRestart("muffleMessage")
[16:21:59.040]                     }
[16:21:59.040]                     else if (inherits(cond, "warning")) {
[16:21:59.040]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:59.040]                       if (muffled) 
[16:21:59.040]                         invokeRestart("muffleWarning")
[16:21:59.040]                     }
[16:21:59.040]                     else if (inherits(cond, "condition")) {
[16:21:59.040]                       if (!is.null(pattern)) {
[16:21:59.040]                         computeRestarts <- base::computeRestarts
[16:21:59.040]                         grepl <- base::grepl
[16:21:59.040]                         restarts <- computeRestarts(cond)
[16:21:59.040]                         for (restart in restarts) {
[16:21:59.040]                           name <- restart$name
[16:21:59.040]                           if (is.null(name)) 
[16:21:59.040]                             next
[16:21:59.040]                           if (!grepl(pattern, name)) 
[16:21:59.040]                             next
[16:21:59.040]                           invokeRestart(restart)
[16:21:59.040]                           muffled <- TRUE
[16:21:59.040]                           break
[16:21:59.040]                         }
[16:21:59.040]                       }
[16:21:59.040]                     }
[16:21:59.040]                     invisible(muffled)
[16:21:59.040]                   }
[16:21:59.040]                   muffleCondition(cond)
[16:21:59.040]                 })
[16:21:59.040]             }))
[16:21:59.040]             future::FutureResult(value = ...future.value$value, 
[16:21:59.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.040]                   ...future.rng), globalenv = if (FALSE) 
[16:21:59.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:59.040]                     ...future.globalenv.names))
[16:21:59.040]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:59.040]         }, condition = base::local({
[16:21:59.040]             c <- base::c
[16:21:59.040]             inherits <- base::inherits
[16:21:59.040]             invokeRestart <- base::invokeRestart
[16:21:59.040]             length <- base::length
[16:21:59.040]             list <- base::list
[16:21:59.040]             seq.int <- base::seq.int
[16:21:59.040]             signalCondition <- base::signalCondition
[16:21:59.040]             sys.calls <- base::sys.calls
[16:21:59.040]             `[[` <- base::`[[`
[16:21:59.040]             `+` <- base::`+`
[16:21:59.040]             `<<-` <- base::`<<-`
[16:21:59.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:59.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:59.040]                   3L)]
[16:21:59.040]             }
[16:21:59.040]             function(cond) {
[16:21:59.040]                 is_error <- inherits(cond, "error")
[16:21:59.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:59.040]                   NULL)
[16:21:59.040]                 if (is_error) {
[16:21:59.040]                   sessionInformation <- function() {
[16:21:59.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:59.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:59.040]                       search = base::search(), system = base::Sys.info())
[16:21:59.040]                   }
[16:21:59.040]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:59.040]                     cond$call), session = sessionInformation(), 
[16:21:59.040]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:59.040]                   signalCondition(cond)
[16:21:59.040]                 }
[16:21:59.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:59.040]                 "immediateCondition"))) {
[16:21:59.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:59.040]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:59.040]                   if (TRUE && !signal) {
[16:21:59.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.040]                     {
[16:21:59.040]                       inherits <- base::inherits
[16:21:59.040]                       invokeRestart <- base::invokeRestart
[16:21:59.040]                       is.null <- base::is.null
[16:21:59.040]                       muffled <- FALSE
[16:21:59.040]                       if (inherits(cond, "message")) {
[16:21:59.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.040]                         if (muffled) 
[16:21:59.040]                           invokeRestart("muffleMessage")
[16:21:59.040]                       }
[16:21:59.040]                       else if (inherits(cond, "warning")) {
[16:21:59.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.040]                         if (muffled) 
[16:21:59.040]                           invokeRestart("muffleWarning")
[16:21:59.040]                       }
[16:21:59.040]                       else if (inherits(cond, "condition")) {
[16:21:59.040]                         if (!is.null(pattern)) {
[16:21:59.040]                           computeRestarts <- base::computeRestarts
[16:21:59.040]                           grepl <- base::grepl
[16:21:59.040]                           restarts <- computeRestarts(cond)
[16:21:59.040]                           for (restart in restarts) {
[16:21:59.040]                             name <- restart$name
[16:21:59.040]                             if (is.null(name)) 
[16:21:59.040]                               next
[16:21:59.040]                             if (!grepl(pattern, name)) 
[16:21:59.040]                               next
[16:21:59.040]                             invokeRestart(restart)
[16:21:59.040]                             muffled <- TRUE
[16:21:59.040]                             break
[16:21:59.040]                           }
[16:21:59.040]                         }
[16:21:59.040]                       }
[16:21:59.040]                       invisible(muffled)
[16:21:59.040]                     }
[16:21:59.040]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.040]                   }
[16:21:59.040]                 }
[16:21:59.040]                 else {
[16:21:59.040]                   if (TRUE) {
[16:21:59.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.040]                     {
[16:21:59.040]                       inherits <- base::inherits
[16:21:59.040]                       invokeRestart <- base::invokeRestart
[16:21:59.040]                       is.null <- base::is.null
[16:21:59.040]                       muffled <- FALSE
[16:21:59.040]                       if (inherits(cond, "message")) {
[16:21:59.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.040]                         if (muffled) 
[16:21:59.040]                           invokeRestart("muffleMessage")
[16:21:59.040]                       }
[16:21:59.040]                       else if (inherits(cond, "warning")) {
[16:21:59.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.040]                         if (muffled) 
[16:21:59.040]                           invokeRestart("muffleWarning")
[16:21:59.040]                       }
[16:21:59.040]                       else if (inherits(cond, "condition")) {
[16:21:59.040]                         if (!is.null(pattern)) {
[16:21:59.040]                           computeRestarts <- base::computeRestarts
[16:21:59.040]                           grepl <- base::grepl
[16:21:59.040]                           restarts <- computeRestarts(cond)
[16:21:59.040]                           for (restart in restarts) {
[16:21:59.040]                             name <- restart$name
[16:21:59.040]                             if (is.null(name)) 
[16:21:59.040]                               next
[16:21:59.040]                             if (!grepl(pattern, name)) 
[16:21:59.040]                               next
[16:21:59.040]                             invokeRestart(restart)
[16:21:59.040]                             muffled <- TRUE
[16:21:59.040]                             break
[16:21:59.040]                           }
[16:21:59.040]                         }
[16:21:59.040]                       }
[16:21:59.040]                       invisible(muffled)
[16:21:59.040]                     }
[16:21:59.040]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.040]                   }
[16:21:59.040]                 }
[16:21:59.040]             }
[16:21:59.040]         }))
[16:21:59.040]     }, error = function(ex) {
[16:21:59.040]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:59.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.040]                 ...future.rng), started = ...future.startTime, 
[16:21:59.040]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:59.040]             version = "1.8"), class = "FutureResult")
[16:21:59.040]     }, finally = {
[16:21:59.040]         if (!identical(...future.workdir, getwd())) 
[16:21:59.040]             setwd(...future.workdir)
[16:21:59.040]         {
[16:21:59.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:59.040]                 ...future.oldOptions$nwarnings <- NULL
[16:21:59.040]             }
[16:21:59.040]             base::options(...future.oldOptions)
[16:21:59.040]             if (.Platform$OS.type == "windows") {
[16:21:59.040]                 old_names <- names(...future.oldEnvVars)
[16:21:59.040]                 envs <- base::Sys.getenv()
[16:21:59.040]                 names <- names(envs)
[16:21:59.040]                 common <- intersect(names, old_names)
[16:21:59.040]                 added <- setdiff(names, old_names)
[16:21:59.040]                 removed <- setdiff(old_names, names)
[16:21:59.040]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:59.040]                   envs[common]]
[16:21:59.040]                 NAMES <- toupper(changed)
[16:21:59.040]                 args <- list()
[16:21:59.040]                 for (kk in seq_along(NAMES)) {
[16:21:59.040]                   name <- changed[[kk]]
[16:21:59.040]                   NAME <- NAMES[[kk]]
[16:21:59.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.040]                     next
[16:21:59.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.040]                 }
[16:21:59.040]                 NAMES <- toupper(added)
[16:21:59.040]                 for (kk in seq_along(NAMES)) {
[16:21:59.040]                   name <- added[[kk]]
[16:21:59.040]                   NAME <- NAMES[[kk]]
[16:21:59.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.040]                     next
[16:21:59.040]                   args[[name]] <- ""
[16:21:59.040]                 }
[16:21:59.040]                 NAMES <- toupper(removed)
[16:21:59.040]                 for (kk in seq_along(NAMES)) {
[16:21:59.040]                   name <- removed[[kk]]
[16:21:59.040]                   NAME <- NAMES[[kk]]
[16:21:59.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.040]                     next
[16:21:59.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.040]                 }
[16:21:59.040]                 if (length(args) > 0) 
[16:21:59.040]                   base::do.call(base::Sys.setenv, args = args)
[16:21:59.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:59.040]             }
[16:21:59.040]             else {
[16:21:59.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:59.040]             }
[16:21:59.040]             {
[16:21:59.040]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:59.040]                   0L) {
[16:21:59.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:59.040]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:59.040]                   base::options(opts)
[16:21:59.040]                 }
[16:21:59.040]                 {
[16:21:59.040]                   {
[16:21:59.040]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:59.040]                     NULL
[16:21:59.040]                   }
[16:21:59.040]                   options(future.plan = NULL)
[16:21:59.040]                   if (is.na(NA_character_)) 
[16:21:59.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:59.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:59.040]                     .init = FALSE)
[16:21:59.040]                 }
[16:21:59.040]             }
[16:21:59.040]         }
[16:21:59.040]     })
[16:21:59.040]     if (TRUE) {
[16:21:59.040]         base::sink(type = "output", split = FALSE)
[16:21:59.040]         if (TRUE) {
[16:21:59.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:59.040]         }
[16:21:59.040]         else {
[16:21:59.040]             ...future.result["stdout"] <- base::list(NULL)
[16:21:59.040]         }
[16:21:59.040]         base::close(...future.stdout)
[16:21:59.040]         ...future.stdout <- NULL
[16:21:59.040]     }
[16:21:59.040]     ...future.result$conditions <- ...future.conditions
[16:21:59.040]     ...future.result$finished <- base::Sys.time()
[16:21:59.040]     ...future.result
[16:21:59.040] }
[16:21:59.043] MultisessionFuture started
[16:21:59.043] - Launch lazy future ... done
[16:21:59.043] run() for ‘MultisessionFuture’ ... done
[16:21:59.045] receiveMessageFromWorker() for ClusterFuture ...
[16:21:59.045] - Validating connection of MultisessionFuture
[16:21:59.046] - received message: FutureResult
[16:21:59.046] - Received FutureResult
[16:21:59.046] - Erased future from FutureRegistry
[16:21:59.046] result() for ClusterFuture ...
[16:21:59.046] - result already collected: FutureResult
[16:21:59.046] result() for ClusterFuture ... done
[16:21:59.046] signalConditions() ...
[16:21:59.046]  - include = ‘immediateCondition’
[16:21:59.047]  - exclude = 
[16:21:59.047]  - resignal = FALSE
[16:21:59.047]  - Number of conditions: 1
[16:21:59.047] signalConditions() ... done
[16:21:59.047] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:59.047] A MultisessionFuture was resolved (result was not collected)
[16:21:59.047] getGlobalsAndPackages() ...
[16:21:59.047] Searching for globals...
[16:21:59.048] - globals found: [2] ‘list’, ‘stop’
[16:21:59.048] Searching for globals ... DONE
[16:21:59.048] Resolving globals: FALSE
[16:21:59.048] 
[16:21:59.049] 
[16:21:59.049] getGlobalsAndPackages() ... DONE
[16:21:59.049] run() for ‘Future’ ...
[16:21:59.049] - state: ‘created’
[16:21:59.049] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:59.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:59.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:59.063]   - Field: ‘node’
[16:21:59.063]   - Field: ‘label’
[16:21:59.063]   - Field: ‘local’
[16:21:59.063]   - Field: ‘owner’
[16:21:59.063]   - Field: ‘envir’
[16:21:59.063]   - Field: ‘workers’
[16:21:59.064]   - Field: ‘packages’
[16:21:59.064]   - Field: ‘gc’
[16:21:59.064]   - Field: ‘conditions’
[16:21:59.064]   - Field: ‘persistent’
[16:21:59.064]   - Field: ‘expr’
[16:21:59.064]   - Field: ‘uuid’
[16:21:59.064]   - Field: ‘seed’
[16:21:59.064]   - Field: ‘version’
[16:21:59.064]   - Field: ‘result’
[16:21:59.064]   - Field: ‘asynchronous’
[16:21:59.064]   - Field: ‘calls’
[16:21:59.065]   - Field: ‘globals’
[16:21:59.065]   - Field: ‘stdout’
[16:21:59.065]   - Field: ‘earlySignal’
[16:21:59.065]   - Field: ‘lazy’
[16:21:59.065]   - Field: ‘state’
[16:21:59.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:59.065] - Launch lazy future ...
[16:21:59.065] Packages needed by the future expression (n = 0): <none>
[16:21:59.065] Packages needed by future strategies (n = 0): <none>
[16:21:59.066] {
[16:21:59.066]     {
[16:21:59.066]         {
[16:21:59.066]             ...future.startTime <- base::Sys.time()
[16:21:59.066]             {
[16:21:59.066]                 {
[16:21:59.066]                   {
[16:21:59.066]                     {
[16:21:59.066]                       base::local({
[16:21:59.066]                         has_future <- base::requireNamespace("future", 
[16:21:59.066]                           quietly = TRUE)
[16:21:59.066]                         if (has_future) {
[16:21:59.066]                           ns <- base::getNamespace("future")
[16:21:59.066]                           version <- ns[[".package"]][["version"]]
[16:21:59.066]                           if (is.null(version)) 
[16:21:59.066]                             version <- utils::packageVersion("future")
[16:21:59.066]                         }
[16:21:59.066]                         else {
[16:21:59.066]                           version <- NULL
[16:21:59.066]                         }
[16:21:59.066]                         if (!has_future || version < "1.8.0") {
[16:21:59.066]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:59.066]                             "", base::R.version$version.string), 
[16:21:59.066]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:59.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:59.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:59.066]                               "release", "version")], collapse = " "), 
[16:21:59.066]                             hostname = base::Sys.info()[["nodename"]])
[16:21:59.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:59.066]                             info)
[16:21:59.066]                           info <- base::paste(info, collapse = "; ")
[16:21:59.066]                           if (!has_future) {
[16:21:59.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:59.066]                               info)
[16:21:59.066]                           }
[16:21:59.066]                           else {
[16:21:59.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:59.066]                               info, version)
[16:21:59.066]                           }
[16:21:59.066]                           base::stop(msg)
[16:21:59.066]                         }
[16:21:59.066]                       })
[16:21:59.066]                     }
[16:21:59.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:59.066]                     base::options(mc.cores = 1L)
[16:21:59.066]                   }
[16:21:59.066]                   ...future.strategy.old <- future::plan("list")
[16:21:59.066]                   options(future.plan = NULL)
[16:21:59.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:59.066]                 }
[16:21:59.066]                 ...future.workdir <- getwd()
[16:21:59.066]             }
[16:21:59.066]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:59.066]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:59.066]         }
[16:21:59.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:59.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:59.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:59.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:59.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:59.066]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:59.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:59.066]             base::names(...future.oldOptions))
[16:21:59.066]     }
[16:21:59.066]     if (FALSE) {
[16:21:59.066]     }
[16:21:59.066]     else {
[16:21:59.066]         if (TRUE) {
[16:21:59.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:59.066]                 open = "w")
[16:21:59.066]         }
[16:21:59.066]         else {
[16:21:59.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:59.066]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:59.066]         }
[16:21:59.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:59.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:59.066]             base::sink(type = "output", split = FALSE)
[16:21:59.066]             base::close(...future.stdout)
[16:21:59.066]         }, add = TRUE)
[16:21:59.066]     }
[16:21:59.066]     ...future.frame <- base::sys.nframe()
[16:21:59.066]     ...future.conditions <- base::list()
[16:21:59.066]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:59.066]     if (FALSE) {
[16:21:59.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:59.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:59.066]     }
[16:21:59.066]     ...future.result <- base::tryCatch({
[16:21:59.066]         base::withCallingHandlers({
[16:21:59.066]             ...future.value <- base::withVisible(base::local({
[16:21:59.066]                 ...future.makeSendCondition <- base::local({
[16:21:59.066]                   sendCondition <- NULL
[16:21:59.066]                   function(frame = 1L) {
[16:21:59.066]                     if (is.function(sendCondition)) 
[16:21:59.066]                       return(sendCondition)
[16:21:59.066]                     ns <- getNamespace("parallel")
[16:21:59.066]                     if (exists("sendData", mode = "function", 
[16:21:59.066]                       envir = ns)) {
[16:21:59.066]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:59.066]                         envir = ns)
[16:21:59.066]                       envir <- sys.frame(frame)
[16:21:59.066]                       master <- NULL
[16:21:59.066]                       while (!identical(envir, .GlobalEnv) && 
[16:21:59.066]                         !identical(envir, emptyenv())) {
[16:21:59.066]                         if (exists("master", mode = "list", envir = envir, 
[16:21:59.066]                           inherits = FALSE)) {
[16:21:59.066]                           master <- get("master", mode = "list", 
[16:21:59.066]                             envir = envir, inherits = FALSE)
[16:21:59.066]                           if (inherits(master, c("SOCKnode", 
[16:21:59.066]                             "SOCK0node"))) {
[16:21:59.066]                             sendCondition <<- function(cond) {
[16:21:59.066]                               data <- list(type = "VALUE", value = cond, 
[16:21:59.066]                                 success = TRUE)
[16:21:59.066]                               parallel_sendData(master, data)
[16:21:59.066]                             }
[16:21:59.066]                             return(sendCondition)
[16:21:59.066]                           }
[16:21:59.066]                         }
[16:21:59.066]                         frame <- frame + 1L
[16:21:59.066]                         envir <- sys.frame(frame)
[16:21:59.066]                       }
[16:21:59.066]                     }
[16:21:59.066]                     sendCondition <<- function(cond) NULL
[16:21:59.066]                   }
[16:21:59.066]                 })
[16:21:59.066]                 withCallingHandlers({
[16:21:59.066]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:21:59.066]                 }, immediateCondition = function(cond) {
[16:21:59.066]                   sendCondition <- ...future.makeSendCondition()
[16:21:59.066]                   sendCondition(cond)
[16:21:59.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.066]                   {
[16:21:59.066]                     inherits <- base::inherits
[16:21:59.066]                     invokeRestart <- base::invokeRestart
[16:21:59.066]                     is.null <- base::is.null
[16:21:59.066]                     muffled <- FALSE
[16:21:59.066]                     if (inherits(cond, "message")) {
[16:21:59.066]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:59.066]                       if (muffled) 
[16:21:59.066]                         invokeRestart("muffleMessage")
[16:21:59.066]                     }
[16:21:59.066]                     else if (inherits(cond, "warning")) {
[16:21:59.066]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:59.066]                       if (muffled) 
[16:21:59.066]                         invokeRestart("muffleWarning")
[16:21:59.066]                     }
[16:21:59.066]                     else if (inherits(cond, "condition")) {
[16:21:59.066]                       if (!is.null(pattern)) {
[16:21:59.066]                         computeRestarts <- base::computeRestarts
[16:21:59.066]                         grepl <- base::grepl
[16:21:59.066]                         restarts <- computeRestarts(cond)
[16:21:59.066]                         for (restart in restarts) {
[16:21:59.066]                           name <- restart$name
[16:21:59.066]                           if (is.null(name)) 
[16:21:59.066]                             next
[16:21:59.066]                           if (!grepl(pattern, name)) 
[16:21:59.066]                             next
[16:21:59.066]                           invokeRestart(restart)
[16:21:59.066]                           muffled <- TRUE
[16:21:59.066]                           break
[16:21:59.066]                         }
[16:21:59.066]                       }
[16:21:59.066]                     }
[16:21:59.066]                     invisible(muffled)
[16:21:59.066]                   }
[16:21:59.066]                   muffleCondition(cond)
[16:21:59.066]                 })
[16:21:59.066]             }))
[16:21:59.066]             future::FutureResult(value = ...future.value$value, 
[16:21:59.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.066]                   ...future.rng), globalenv = if (FALSE) 
[16:21:59.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:59.066]                     ...future.globalenv.names))
[16:21:59.066]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:59.066]         }, condition = base::local({
[16:21:59.066]             c <- base::c
[16:21:59.066]             inherits <- base::inherits
[16:21:59.066]             invokeRestart <- base::invokeRestart
[16:21:59.066]             length <- base::length
[16:21:59.066]             list <- base::list
[16:21:59.066]             seq.int <- base::seq.int
[16:21:59.066]             signalCondition <- base::signalCondition
[16:21:59.066]             sys.calls <- base::sys.calls
[16:21:59.066]             `[[` <- base::`[[`
[16:21:59.066]             `+` <- base::`+`
[16:21:59.066]             `<<-` <- base::`<<-`
[16:21:59.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:59.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:59.066]                   3L)]
[16:21:59.066]             }
[16:21:59.066]             function(cond) {
[16:21:59.066]                 is_error <- inherits(cond, "error")
[16:21:59.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:59.066]                   NULL)
[16:21:59.066]                 if (is_error) {
[16:21:59.066]                   sessionInformation <- function() {
[16:21:59.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:59.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:59.066]                       search = base::search(), system = base::Sys.info())
[16:21:59.066]                   }
[16:21:59.066]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:59.066]                     cond$call), session = sessionInformation(), 
[16:21:59.066]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:59.066]                   signalCondition(cond)
[16:21:59.066]                 }
[16:21:59.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:59.066]                 "immediateCondition"))) {
[16:21:59.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:59.066]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:59.066]                   if (TRUE && !signal) {
[16:21:59.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.066]                     {
[16:21:59.066]                       inherits <- base::inherits
[16:21:59.066]                       invokeRestart <- base::invokeRestart
[16:21:59.066]                       is.null <- base::is.null
[16:21:59.066]                       muffled <- FALSE
[16:21:59.066]                       if (inherits(cond, "message")) {
[16:21:59.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.066]                         if (muffled) 
[16:21:59.066]                           invokeRestart("muffleMessage")
[16:21:59.066]                       }
[16:21:59.066]                       else if (inherits(cond, "warning")) {
[16:21:59.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.066]                         if (muffled) 
[16:21:59.066]                           invokeRestart("muffleWarning")
[16:21:59.066]                       }
[16:21:59.066]                       else if (inherits(cond, "condition")) {
[16:21:59.066]                         if (!is.null(pattern)) {
[16:21:59.066]                           computeRestarts <- base::computeRestarts
[16:21:59.066]                           grepl <- base::grepl
[16:21:59.066]                           restarts <- computeRestarts(cond)
[16:21:59.066]                           for (restart in restarts) {
[16:21:59.066]                             name <- restart$name
[16:21:59.066]                             if (is.null(name)) 
[16:21:59.066]                               next
[16:21:59.066]                             if (!grepl(pattern, name)) 
[16:21:59.066]                               next
[16:21:59.066]                             invokeRestart(restart)
[16:21:59.066]                             muffled <- TRUE
[16:21:59.066]                             break
[16:21:59.066]                           }
[16:21:59.066]                         }
[16:21:59.066]                       }
[16:21:59.066]                       invisible(muffled)
[16:21:59.066]                     }
[16:21:59.066]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.066]                   }
[16:21:59.066]                 }
[16:21:59.066]                 else {
[16:21:59.066]                   if (TRUE) {
[16:21:59.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.066]                     {
[16:21:59.066]                       inherits <- base::inherits
[16:21:59.066]                       invokeRestart <- base::invokeRestart
[16:21:59.066]                       is.null <- base::is.null
[16:21:59.066]                       muffled <- FALSE
[16:21:59.066]                       if (inherits(cond, "message")) {
[16:21:59.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.066]                         if (muffled) 
[16:21:59.066]                           invokeRestart("muffleMessage")
[16:21:59.066]                       }
[16:21:59.066]                       else if (inherits(cond, "warning")) {
[16:21:59.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.066]                         if (muffled) 
[16:21:59.066]                           invokeRestart("muffleWarning")
[16:21:59.066]                       }
[16:21:59.066]                       else if (inherits(cond, "condition")) {
[16:21:59.066]                         if (!is.null(pattern)) {
[16:21:59.066]                           computeRestarts <- base::computeRestarts
[16:21:59.066]                           grepl <- base::grepl
[16:21:59.066]                           restarts <- computeRestarts(cond)
[16:21:59.066]                           for (restart in restarts) {
[16:21:59.066]                             name <- restart$name
[16:21:59.066]                             if (is.null(name)) 
[16:21:59.066]                               next
[16:21:59.066]                             if (!grepl(pattern, name)) 
[16:21:59.066]                               next
[16:21:59.066]                             invokeRestart(restart)
[16:21:59.066]                             muffled <- TRUE
[16:21:59.066]                             break
[16:21:59.066]                           }
[16:21:59.066]                         }
[16:21:59.066]                       }
[16:21:59.066]                       invisible(muffled)
[16:21:59.066]                     }
[16:21:59.066]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.066]                   }
[16:21:59.066]                 }
[16:21:59.066]             }
[16:21:59.066]         }))
[16:21:59.066]     }, error = function(ex) {
[16:21:59.066]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:59.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.066]                 ...future.rng), started = ...future.startTime, 
[16:21:59.066]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:59.066]             version = "1.8"), class = "FutureResult")
[16:21:59.066]     }, finally = {
[16:21:59.066]         if (!identical(...future.workdir, getwd())) 
[16:21:59.066]             setwd(...future.workdir)
[16:21:59.066]         {
[16:21:59.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:59.066]                 ...future.oldOptions$nwarnings <- NULL
[16:21:59.066]             }
[16:21:59.066]             base::options(...future.oldOptions)
[16:21:59.066]             if (.Platform$OS.type == "windows") {
[16:21:59.066]                 old_names <- names(...future.oldEnvVars)
[16:21:59.066]                 envs <- base::Sys.getenv()
[16:21:59.066]                 names <- names(envs)
[16:21:59.066]                 common <- intersect(names, old_names)
[16:21:59.066]                 added <- setdiff(names, old_names)
[16:21:59.066]                 removed <- setdiff(old_names, names)
[16:21:59.066]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:59.066]                   envs[common]]
[16:21:59.066]                 NAMES <- toupper(changed)
[16:21:59.066]                 args <- list()
[16:21:59.066]                 for (kk in seq_along(NAMES)) {
[16:21:59.066]                   name <- changed[[kk]]
[16:21:59.066]                   NAME <- NAMES[[kk]]
[16:21:59.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.066]                     next
[16:21:59.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.066]                 }
[16:21:59.066]                 NAMES <- toupper(added)
[16:21:59.066]                 for (kk in seq_along(NAMES)) {
[16:21:59.066]                   name <- added[[kk]]
[16:21:59.066]                   NAME <- NAMES[[kk]]
[16:21:59.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.066]                     next
[16:21:59.066]                   args[[name]] <- ""
[16:21:59.066]                 }
[16:21:59.066]                 NAMES <- toupper(removed)
[16:21:59.066]                 for (kk in seq_along(NAMES)) {
[16:21:59.066]                   name <- removed[[kk]]
[16:21:59.066]                   NAME <- NAMES[[kk]]
[16:21:59.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.066]                     next
[16:21:59.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.066]                 }
[16:21:59.066]                 if (length(args) > 0) 
[16:21:59.066]                   base::do.call(base::Sys.setenv, args = args)
[16:21:59.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:59.066]             }
[16:21:59.066]             else {
[16:21:59.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:59.066]             }
[16:21:59.066]             {
[16:21:59.066]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:59.066]                   0L) {
[16:21:59.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:59.066]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:59.066]                   base::options(opts)
[16:21:59.066]                 }
[16:21:59.066]                 {
[16:21:59.066]                   {
[16:21:59.066]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:59.066]                     NULL
[16:21:59.066]                   }
[16:21:59.066]                   options(future.plan = NULL)
[16:21:59.066]                   if (is.na(NA_character_)) 
[16:21:59.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:59.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:59.066]                     .init = FALSE)
[16:21:59.066]                 }
[16:21:59.066]             }
[16:21:59.066]         }
[16:21:59.066]     })
[16:21:59.066]     if (TRUE) {
[16:21:59.066]         base::sink(type = "output", split = FALSE)
[16:21:59.066]         if (TRUE) {
[16:21:59.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:59.066]         }
[16:21:59.066]         else {
[16:21:59.066]             ...future.result["stdout"] <- base::list(NULL)
[16:21:59.066]         }
[16:21:59.066]         base::close(...future.stdout)
[16:21:59.066]         ...future.stdout <- NULL
[16:21:59.066]     }
[16:21:59.066]     ...future.result$conditions <- ...future.conditions
[16:21:59.066]     ...future.result$finished <- base::Sys.time()
[16:21:59.066]     ...future.result
[16:21:59.066] }
[16:21:59.069] MultisessionFuture started
[16:21:59.069] - Launch lazy future ... done
[16:21:59.069] run() for ‘MultisessionFuture’ ... done
[16:21:59.071] receiveMessageFromWorker() for ClusterFuture ...
[16:21:59.071] - Validating connection of MultisessionFuture
[16:21:59.071] - received message: FutureResult
[16:21:59.071] - Received FutureResult
[16:21:59.071] - Erased future from FutureRegistry
[16:21:59.071] result() for ClusterFuture ...
[16:21:59.071] - result already collected: FutureResult
[16:21:59.072] result() for ClusterFuture ... done
[16:21:59.072] signalConditions() ...
[16:21:59.072]  - include = ‘immediateCondition’
[16:21:59.072]  - exclude = 
[16:21:59.072]  - resignal = FALSE
[16:21:59.072]  - Number of conditions: 1
[16:21:59.074] signalConditions() ... done
[16:21:59.074] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:59.075] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[16:21:59.075] getGlobalsAndPackages() ...
[16:21:59.075] Searching for globals...
[16:21:59.076] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:59.076] Searching for globals ... DONE
[16:21:59.076] Resolving globals: FALSE
[16:21:59.077] 
[16:21:59.077] 
[16:21:59.077] getGlobalsAndPackages() ... DONE
[16:21:59.077] run() for ‘Future’ ...
[16:21:59.077] - state: ‘created’
[16:21:59.077] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:59.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:59.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:59.091]   - Field: ‘node’
[16:21:59.091]   - Field: ‘label’
[16:21:59.091]   - Field: ‘local’
[16:21:59.091]   - Field: ‘owner’
[16:21:59.091]   - Field: ‘envir’
[16:21:59.091]   - Field: ‘workers’
[16:21:59.092]   - Field: ‘packages’
[16:21:59.092]   - Field: ‘gc’
[16:21:59.092]   - Field: ‘conditions’
[16:21:59.092]   - Field: ‘persistent’
[16:21:59.092]   - Field: ‘expr’
[16:21:59.092]   - Field: ‘uuid’
[16:21:59.092]   - Field: ‘seed’
[16:21:59.092]   - Field: ‘version’
[16:21:59.092]   - Field: ‘result’
[16:21:59.092]   - Field: ‘asynchronous’
[16:21:59.092]   - Field: ‘calls’
[16:21:59.093]   - Field: ‘globals’
[16:21:59.093]   - Field: ‘stdout’
[16:21:59.093]   - Field: ‘earlySignal’
[16:21:59.093]   - Field: ‘lazy’
[16:21:59.093]   - Field: ‘state’
[16:21:59.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:59.093] - Launch lazy future ...
[16:21:59.093] Packages needed by the future expression (n = 0): <none>
[16:21:59.093] Packages needed by future strategies (n = 0): <none>
[16:21:59.094] {
[16:21:59.094]     {
[16:21:59.094]         {
[16:21:59.094]             ...future.startTime <- base::Sys.time()
[16:21:59.094]             {
[16:21:59.094]                 {
[16:21:59.094]                   {
[16:21:59.094]                     {
[16:21:59.094]                       base::local({
[16:21:59.094]                         has_future <- base::requireNamespace("future", 
[16:21:59.094]                           quietly = TRUE)
[16:21:59.094]                         if (has_future) {
[16:21:59.094]                           ns <- base::getNamespace("future")
[16:21:59.094]                           version <- ns[[".package"]][["version"]]
[16:21:59.094]                           if (is.null(version)) 
[16:21:59.094]                             version <- utils::packageVersion("future")
[16:21:59.094]                         }
[16:21:59.094]                         else {
[16:21:59.094]                           version <- NULL
[16:21:59.094]                         }
[16:21:59.094]                         if (!has_future || version < "1.8.0") {
[16:21:59.094]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:59.094]                             "", base::R.version$version.string), 
[16:21:59.094]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:59.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:59.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:59.094]                               "release", "version")], collapse = " "), 
[16:21:59.094]                             hostname = base::Sys.info()[["nodename"]])
[16:21:59.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:59.094]                             info)
[16:21:59.094]                           info <- base::paste(info, collapse = "; ")
[16:21:59.094]                           if (!has_future) {
[16:21:59.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:59.094]                               info)
[16:21:59.094]                           }
[16:21:59.094]                           else {
[16:21:59.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:59.094]                               info, version)
[16:21:59.094]                           }
[16:21:59.094]                           base::stop(msg)
[16:21:59.094]                         }
[16:21:59.094]                       })
[16:21:59.094]                     }
[16:21:59.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:59.094]                     base::options(mc.cores = 1L)
[16:21:59.094]                   }
[16:21:59.094]                   ...future.strategy.old <- future::plan("list")
[16:21:59.094]                   options(future.plan = NULL)
[16:21:59.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:59.094]                 }
[16:21:59.094]                 ...future.workdir <- getwd()
[16:21:59.094]             }
[16:21:59.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:59.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:59.094]         }
[16:21:59.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:59.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:59.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:59.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:59.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:59.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:59.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:59.094]             base::names(...future.oldOptions))
[16:21:59.094]     }
[16:21:59.094]     if (FALSE) {
[16:21:59.094]     }
[16:21:59.094]     else {
[16:21:59.094]         if (TRUE) {
[16:21:59.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:59.094]                 open = "w")
[16:21:59.094]         }
[16:21:59.094]         else {
[16:21:59.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:59.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:59.094]         }
[16:21:59.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:59.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:59.094]             base::sink(type = "output", split = FALSE)
[16:21:59.094]             base::close(...future.stdout)
[16:21:59.094]         }, add = TRUE)
[16:21:59.094]     }
[16:21:59.094]     ...future.frame <- base::sys.nframe()
[16:21:59.094]     ...future.conditions <- base::list()
[16:21:59.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:59.094]     if (FALSE) {
[16:21:59.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:59.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:59.094]     }
[16:21:59.094]     ...future.result <- base::tryCatch({
[16:21:59.094]         base::withCallingHandlers({
[16:21:59.094]             ...future.value <- base::withVisible(base::local({
[16:21:59.094]                 ...future.makeSendCondition <- base::local({
[16:21:59.094]                   sendCondition <- NULL
[16:21:59.094]                   function(frame = 1L) {
[16:21:59.094]                     if (is.function(sendCondition)) 
[16:21:59.094]                       return(sendCondition)
[16:21:59.094]                     ns <- getNamespace("parallel")
[16:21:59.094]                     if (exists("sendData", mode = "function", 
[16:21:59.094]                       envir = ns)) {
[16:21:59.094]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:59.094]                         envir = ns)
[16:21:59.094]                       envir <- sys.frame(frame)
[16:21:59.094]                       master <- NULL
[16:21:59.094]                       while (!identical(envir, .GlobalEnv) && 
[16:21:59.094]                         !identical(envir, emptyenv())) {
[16:21:59.094]                         if (exists("master", mode = "list", envir = envir, 
[16:21:59.094]                           inherits = FALSE)) {
[16:21:59.094]                           master <- get("master", mode = "list", 
[16:21:59.094]                             envir = envir, inherits = FALSE)
[16:21:59.094]                           if (inherits(master, c("SOCKnode", 
[16:21:59.094]                             "SOCK0node"))) {
[16:21:59.094]                             sendCondition <<- function(cond) {
[16:21:59.094]                               data <- list(type = "VALUE", value = cond, 
[16:21:59.094]                                 success = TRUE)
[16:21:59.094]                               parallel_sendData(master, data)
[16:21:59.094]                             }
[16:21:59.094]                             return(sendCondition)
[16:21:59.094]                           }
[16:21:59.094]                         }
[16:21:59.094]                         frame <- frame + 1L
[16:21:59.094]                         envir <- sys.frame(frame)
[16:21:59.094]                       }
[16:21:59.094]                     }
[16:21:59.094]                     sendCondition <<- function(cond) NULL
[16:21:59.094]                   }
[16:21:59.094]                 })
[16:21:59.094]                 withCallingHandlers({
[16:21:59.094]                   {
[16:21:59.094]                     Sys.sleep(0.5)
[16:21:59.094]                     list(a = 1, b = 42L)
[16:21:59.094]                   }
[16:21:59.094]                 }, immediateCondition = function(cond) {
[16:21:59.094]                   sendCondition <- ...future.makeSendCondition()
[16:21:59.094]                   sendCondition(cond)
[16:21:59.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.094]                   {
[16:21:59.094]                     inherits <- base::inherits
[16:21:59.094]                     invokeRestart <- base::invokeRestart
[16:21:59.094]                     is.null <- base::is.null
[16:21:59.094]                     muffled <- FALSE
[16:21:59.094]                     if (inherits(cond, "message")) {
[16:21:59.094]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:59.094]                       if (muffled) 
[16:21:59.094]                         invokeRestart("muffleMessage")
[16:21:59.094]                     }
[16:21:59.094]                     else if (inherits(cond, "warning")) {
[16:21:59.094]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:59.094]                       if (muffled) 
[16:21:59.094]                         invokeRestart("muffleWarning")
[16:21:59.094]                     }
[16:21:59.094]                     else if (inherits(cond, "condition")) {
[16:21:59.094]                       if (!is.null(pattern)) {
[16:21:59.094]                         computeRestarts <- base::computeRestarts
[16:21:59.094]                         grepl <- base::grepl
[16:21:59.094]                         restarts <- computeRestarts(cond)
[16:21:59.094]                         for (restart in restarts) {
[16:21:59.094]                           name <- restart$name
[16:21:59.094]                           if (is.null(name)) 
[16:21:59.094]                             next
[16:21:59.094]                           if (!grepl(pattern, name)) 
[16:21:59.094]                             next
[16:21:59.094]                           invokeRestart(restart)
[16:21:59.094]                           muffled <- TRUE
[16:21:59.094]                           break
[16:21:59.094]                         }
[16:21:59.094]                       }
[16:21:59.094]                     }
[16:21:59.094]                     invisible(muffled)
[16:21:59.094]                   }
[16:21:59.094]                   muffleCondition(cond)
[16:21:59.094]                 })
[16:21:59.094]             }))
[16:21:59.094]             future::FutureResult(value = ...future.value$value, 
[16:21:59.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.094]                   ...future.rng), globalenv = if (FALSE) 
[16:21:59.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:59.094]                     ...future.globalenv.names))
[16:21:59.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:59.094]         }, condition = base::local({
[16:21:59.094]             c <- base::c
[16:21:59.094]             inherits <- base::inherits
[16:21:59.094]             invokeRestart <- base::invokeRestart
[16:21:59.094]             length <- base::length
[16:21:59.094]             list <- base::list
[16:21:59.094]             seq.int <- base::seq.int
[16:21:59.094]             signalCondition <- base::signalCondition
[16:21:59.094]             sys.calls <- base::sys.calls
[16:21:59.094]             `[[` <- base::`[[`
[16:21:59.094]             `+` <- base::`+`
[16:21:59.094]             `<<-` <- base::`<<-`
[16:21:59.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:59.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:59.094]                   3L)]
[16:21:59.094]             }
[16:21:59.094]             function(cond) {
[16:21:59.094]                 is_error <- inherits(cond, "error")
[16:21:59.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:59.094]                   NULL)
[16:21:59.094]                 if (is_error) {
[16:21:59.094]                   sessionInformation <- function() {
[16:21:59.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:59.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:59.094]                       search = base::search(), system = base::Sys.info())
[16:21:59.094]                   }
[16:21:59.094]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:59.094]                     cond$call), session = sessionInformation(), 
[16:21:59.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:59.094]                   signalCondition(cond)
[16:21:59.094]                 }
[16:21:59.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:59.094]                 "immediateCondition"))) {
[16:21:59.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:59.094]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:59.094]                   if (TRUE && !signal) {
[16:21:59.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.094]                     {
[16:21:59.094]                       inherits <- base::inherits
[16:21:59.094]                       invokeRestart <- base::invokeRestart
[16:21:59.094]                       is.null <- base::is.null
[16:21:59.094]                       muffled <- FALSE
[16:21:59.094]                       if (inherits(cond, "message")) {
[16:21:59.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.094]                         if (muffled) 
[16:21:59.094]                           invokeRestart("muffleMessage")
[16:21:59.094]                       }
[16:21:59.094]                       else if (inherits(cond, "warning")) {
[16:21:59.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.094]                         if (muffled) 
[16:21:59.094]                           invokeRestart("muffleWarning")
[16:21:59.094]                       }
[16:21:59.094]                       else if (inherits(cond, "condition")) {
[16:21:59.094]                         if (!is.null(pattern)) {
[16:21:59.094]                           computeRestarts <- base::computeRestarts
[16:21:59.094]                           grepl <- base::grepl
[16:21:59.094]                           restarts <- computeRestarts(cond)
[16:21:59.094]                           for (restart in restarts) {
[16:21:59.094]                             name <- restart$name
[16:21:59.094]                             if (is.null(name)) 
[16:21:59.094]                               next
[16:21:59.094]                             if (!grepl(pattern, name)) 
[16:21:59.094]                               next
[16:21:59.094]                             invokeRestart(restart)
[16:21:59.094]                             muffled <- TRUE
[16:21:59.094]                             break
[16:21:59.094]                           }
[16:21:59.094]                         }
[16:21:59.094]                       }
[16:21:59.094]                       invisible(muffled)
[16:21:59.094]                     }
[16:21:59.094]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.094]                   }
[16:21:59.094]                 }
[16:21:59.094]                 else {
[16:21:59.094]                   if (TRUE) {
[16:21:59.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.094]                     {
[16:21:59.094]                       inherits <- base::inherits
[16:21:59.094]                       invokeRestart <- base::invokeRestart
[16:21:59.094]                       is.null <- base::is.null
[16:21:59.094]                       muffled <- FALSE
[16:21:59.094]                       if (inherits(cond, "message")) {
[16:21:59.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.094]                         if (muffled) 
[16:21:59.094]                           invokeRestart("muffleMessage")
[16:21:59.094]                       }
[16:21:59.094]                       else if (inherits(cond, "warning")) {
[16:21:59.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.094]                         if (muffled) 
[16:21:59.094]                           invokeRestart("muffleWarning")
[16:21:59.094]                       }
[16:21:59.094]                       else if (inherits(cond, "condition")) {
[16:21:59.094]                         if (!is.null(pattern)) {
[16:21:59.094]                           computeRestarts <- base::computeRestarts
[16:21:59.094]                           grepl <- base::grepl
[16:21:59.094]                           restarts <- computeRestarts(cond)
[16:21:59.094]                           for (restart in restarts) {
[16:21:59.094]                             name <- restart$name
[16:21:59.094]                             if (is.null(name)) 
[16:21:59.094]                               next
[16:21:59.094]                             if (!grepl(pattern, name)) 
[16:21:59.094]                               next
[16:21:59.094]                             invokeRestart(restart)
[16:21:59.094]                             muffled <- TRUE
[16:21:59.094]                             break
[16:21:59.094]                           }
[16:21:59.094]                         }
[16:21:59.094]                       }
[16:21:59.094]                       invisible(muffled)
[16:21:59.094]                     }
[16:21:59.094]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.094]                   }
[16:21:59.094]                 }
[16:21:59.094]             }
[16:21:59.094]         }))
[16:21:59.094]     }, error = function(ex) {
[16:21:59.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:59.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.094]                 ...future.rng), started = ...future.startTime, 
[16:21:59.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:59.094]             version = "1.8"), class = "FutureResult")
[16:21:59.094]     }, finally = {
[16:21:59.094]         if (!identical(...future.workdir, getwd())) 
[16:21:59.094]             setwd(...future.workdir)
[16:21:59.094]         {
[16:21:59.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:59.094]                 ...future.oldOptions$nwarnings <- NULL
[16:21:59.094]             }
[16:21:59.094]             base::options(...future.oldOptions)
[16:21:59.094]             if (.Platform$OS.type == "windows") {
[16:21:59.094]                 old_names <- names(...future.oldEnvVars)
[16:21:59.094]                 envs <- base::Sys.getenv()
[16:21:59.094]                 names <- names(envs)
[16:21:59.094]                 common <- intersect(names, old_names)
[16:21:59.094]                 added <- setdiff(names, old_names)
[16:21:59.094]                 removed <- setdiff(old_names, names)
[16:21:59.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:59.094]                   envs[common]]
[16:21:59.094]                 NAMES <- toupper(changed)
[16:21:59.094]                 args <- list()
[16:21:59.094]                 for (kk in seq_along(NAMES)) {
[16:21:59.094]                   name <- changed[[kk]]
[16:21:59.094]                   NAME <- NAMES[[kk]]
[16:21:59.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.094]                     next
[16:21:59.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.094]                 }
[16:21:59.094]                 NAMES <- toupper(added)
[16:21:59.094]                 for (kk in seq_along(NAMES)) {
[16:21:59.094]                   name <- added[[kk]]
[16:21:59.094]                   NAME <- NAMES[[kk]]
[16:21:59.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.094]                     next
[16:21:59.094]                   args[[name]] <- ""
[16:21:59.094]                 }
[16:21:59.094]                 NAMES <- toupper(removed)
[16:21:59.094]                 for (kk in seq_along(NAMES)) {
[16:21:59.094]                   name <- removed[[kk]]
[16:21:59.094]                   NAME <- NAMES[[kk]]
[16:21:59.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.094]                     next
[16:21:59.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.094]                 }
[16:21:59.094]                 if (length(args) > 0) 
[16:21:59.094]                   base::do.call(base::Sys.setenv, args = args)
[16:21:59.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:59.094]             }
[16:21:59.094]             else {
[16:21:59.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:59.094]             }
[16:21:59.094]             {
[16:21:59.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:59.094]                   0L) {
[16:21:59.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:59.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:59.094]                   base::options(opts)
[16:21:59.094]                 }
[16:21:59.094]                 {
[16:21:59.094]                   {
[16:21:59.094]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:59.094]                     NULL
[16:21:59.094]                   }
[16:21:59.094]                   options(future.plan = NULL)
[16:21:59.094]                   if (is.na(NA_character_)) 
[16:21:59.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:59.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:59.094]                     .init = FALSE)
[16:21:59.094]                 }
[16:21:59.094]             }
[16:21:59.094]         }
[16:21:59.094]     })
[16:21:59.094]     if (TRUE) {
[16:21:59.094]         base::sink(type = "output", split = FALSE)
[16:21:59.094]         if (TRUE) {
[16:21:59.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:59.094]         }
[16:21:59.094]         else {
[16:21:59.094]             ...future.result["stdout"] <- base::list(NULL)
[16:21:59.094]         }
[16:21:59.094]         base::close(...future.stdout)
[16:21:59.094]         ...future.stdout <- NULL
[16:21:59.094]     }
[16:21:59.094]     ...future.result$conditions <- ...future.conditions
[16:21:59.094]     ...future.result$finished <- base::Sys.time()
[16:21:59.094]     ...future.result
[16:21:59.094] }
[16:21:59.097] MultisessionFuture started
[16:21:59.097] - Launch lazy future ... done
[16:21:59.097] run() for ‘MultisessionFuture’ ... done
[16:21:59.599] receiveMessageFromWorker() for ClusterFuture ...
[16:21:59.600] - Validating connection of MultisessionFuture
[16:21:59.600] - received message: FutureResult
[16:21:59.600] - Received FutureResult
[16:21:59.600] - Erased future from FutureRegistry
[16:21:59.600] result() for ClusterFuture ...
[16:21:59.600] - result already collected: FutureResult
[16:21:59.600] result() for ClusterFuture ... done
[16:21:59.600] receiveMessageFromWorker() for ClusterFuture ... done
[16:21:59.601] A MultisessionFuture was resolved (result was not collected)
[16:21:59.601] getGlobalsAndPackages() ...
[16:21:59.601] Searching for globals...
[16:21:59.602] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:21:59.602] Searching for globals ... DONE
[16:21:59.602] Resolving globals: FALSE
[16:21:59.602] 
[16:21:59.603] 
[16:21:59.603] getGlobalsAndPackages() ... DONE
[16:21:59.603] run() for ‘Future’ ...
[16:21:59.603] - state: ‘created’
[16:21:59.603] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:21:59.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:21:59.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:21:59.619]   - Field: ‘node’
[16:21:59.619]   - Field: ‘label’
[16:21:59.619]   - Field: ‘local’
[16:21:59.619]   - Field: ‘owner’
[16:21:59.619]   - Field: ‘envir’
[16:21:59.619]   - Field: ‘workers’
[16:21:59.619]   - Field: ‘packages’
[16:21:59.619]   - Field: ‘gc’
[16:21:59.619]   - Field: ‘conditions’
[16:21:59.620]   - Field: ‘persistent’
[16:21:59.620]   - Field: ‘expr’
[16:21:59.620]   - Field: ‘uuid’
[16:21:59.620]   - Field: ‘seed’
[16:21:59.620]   - Field: ‘version’
[16:21:59.620]   - Field: ‘result’
[16:21:59.620]   - Field: ‘asynchronous’
[16:21:59.620]   - Field: ‘calls’
[16:21:59.620]   - Field: ‘globals’
[16:21:59.620]   - Field: ‘stdout’
[16:21:59.621]   - Field: ‘earlySignal’
[16:21:59.621]   - Field: ‘lazy’
[16:21:59.621]   - Field: ‘state’
[16:21:59.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:21:59.621] - Launch lazy future ...
[16:21:59.621] Packages needed by the future expression (n = 0): <none>
[16:21:59.621] Packages needed by future strategies (n = 0): <none>
[16:21:59.622] {
[16:21:59.622]     {
[16:21:59.622]         {
[16:21:59.622]             ...future.startTime <- base::Sys.time()
[16:21:59.622]             {
[16:21:59.622]                 {
[16:21:59.622]                   {
[16:21:59.622]                     {
[16:21:59.622]                       base::local({
[16:21:59.622]                         has_future <- base::requireNamespace("future", 
[16:21:59.622]                           quietly = TRUE)
[16:21:59.622]                         if (has_future) {
[16:21:59.622]                           ns <- base::getNamespace("future")
[16:21:59.622]                           version <- ns[[".package"]][["version"]]
[16:21:59.622]                           if (is.null(version)) 
[16:21:59.622]                             version <- utils::packageVersion("future")
[16:21:59.622]                         }
[16:21:59.622]                         else {
[16:21:59.622]                           version <- NULL
[16:21:59.622]                         }
[16:21:59.622]                         if (!has_future || version < "1.8.0") {
[16:21:59.622]                           info <- base::c(r_version = base::gsub("R version ", 
[16:21:59.622]                             "", base::R.version$version.string), 
[16:21:59.622]                             platform = base::sprintf("%s (%s-bit)", 
[16:21:59.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:21:59.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:21:59.622]                               "release", "version")], collapse = " "), 
[16:21:59.622]                             hostname = base::Sys.info()[["nodename"]])
[16:21:59.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:21:59.622]                             info)
[16:21:59.622]                           info <- base::paste(info, collapse = "; ")
[16:21:59.622]                           if (!has_future) {
[16:21:59.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:21:59.622]                               info)
[16:21:59.622]                           }
[16:21:59.622]                           else {
[16:21:59.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:21:59.622]                               info, version)
[16:21:59.622]                           }
[16:21:59.622]                           base::stop(msg)
[16:21:59.622]                         }
[16:21:59.622]                       })
[16:21:59.622]                     }
[16:21:59.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:21:59.622]                     base::options(mc.cores = 1L)
[16:21:59.622]                   }
[16:21:59.622]                   ...future.strategy.old <- future::plan("list")
[16:21:59.622]                   options(future.plan = NULL)
[16:21:59.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:21:59.622]                 }
[16:21:59.622]                 ...future.workdir <- getwd()
[16:21:59.622]             }
[16:21:59.622]             ...future.oldOptions <- base::as.list(base::.Options)
[16:21:59.622]             ...future.oldEnvVars <- base::Sys.getenv()
[16:21:59.622]         }
[16:21:59.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:21:59.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:21:59.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:21:59.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:21:59.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:21:59.622]             future.stdout.windows.reencode = NULL, width = 80L)
[16:21:59.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:21:59.622]             base::names(...future.oldOptions))
[16:21:59.622]     }
[16:21:59.622]     if (FALSE) {
[16:21:59.622]     }
[16:21:59.622]     else {
[16:21:59.622]         if (TRUE) {
[16:21:59.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:21:59.622]                 open = "w")
[16:21:59.622]         }
[16:21:59.622]         else {
[16:21:59.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:21:59.622]                 windows = "NUL", "/dev/null"), open = "w")
[16:21:59.622]         }
[16:21:59.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:21:59.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:21:59.622]             base::sink(type = "output", split = FALSE)
[16:21:59.622]             base::close(...future.stdout)
[16:21:59.622]         }, add = TRUE)
[16:21:59.622]     }
[16:21:59.622]     ...future.frame <- base::sys.nframe()
[16:21:59.622]     ...future.conditions <- base::list()
[16:21:59.622]     ...future.rng <- base::globalenv()$.Random.seed
[16:21:59.622]     if (FALSE) {
[16:21:59.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:21:59.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:21:59.622]     }
[16:21:59.622]     ...future.result <- base::tryCatch({
[16:21:59.622]         base::withCallingHandlers({
[16:21:59.622]             ...future.value <- base::withVisible(base::local({
[16:21:59.622]                 ...future.makeSendCondition <- base::local({
[16:21:59.622]                   sendCondition <- NULL
[16:21:59.622]                   function(frame = 1L) {
[16:21:59.622]                     if (is.function(sendCondition)) 
[16:21:59.622]                       return(sendCondition)
[16:21:59.622]                     ns <- getNamespace("parallel")
[16:21:59.622]                     if (exists("sendData", mode = "function", 
[16:21:59.622]                       envir = ns)) {
[16:21:59.622]                       parallel_sendData <- get("sendData", mode = "function", 
[16:21:59.622]                         envir = ns)
[16:21:59.622]                       envir <- sys.frame(frame)
[16:21:59.622]                       master <- NULL
[16:21:59.622]                       while (!identical(envir, .GlobalEnv) && 
[16:21:59.622]                         !identical(envir, emptyenv())) {
[16:21:59.622]                         if (exists("master", mode = "list", envir = envir, 
[16:21:59.622]                           inherits = FALSE)) {
[16:21:59.622]                           master <- get("master", mode = "list", 
[16:21:59.622]                             envir = envir, inherits = FALSE)
[16:21:59.622]                           if (inherits(master, c("SOCKnode", 
[16:21:59.622]                             "SOCK0node"))) {
[16:21:59.622]                             sendCondition <<- function(cond) {
[16:21:59.622]                               data <- list(type = "VALUE", value = cond, 
[16:21:59.622]                                 success = TRUE)
[16:21:59.622]                               parallel_sendData(master, data)
[16:21:59.622]                             }
[16:21:59.622]                             return(sendCondition)
[16:21:59.622]                           }
[16:21:59.622]                         }
[16:21:59.622]                         frame <- frame + 1L
[16:21:59.622]                         envir <- sys.frame(frame)
[16:21:59.622]                       }
[16:21:59.622]                     }
[16:21:59.622]                     sendCondition <<- function(cond) NULL
[16:21:59.622]                   }
[16:21:59.622]                 })
[16:21:59.622]                 withCallingHandlers({
[16:21:59.622]                   {
[16:21:59.622]                     Sys.sleep(0.5)
[16:21:59.622]                     list(a = 1, b = 42L)
[16:21:59.622]                   }
[16:21:59.622]                 }, immediateCondition = function(cond) {
[16:21:59.622]                   sendCondition <- ...future.makeSendCondition()
[16:21:59.622]                   sendCondition(cond)
[16:21:59.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.622]                   {
[16:21:59.622]                     inherits <- base::inherits
[16:21:59.622]                     invokeRestart <- base::invokeRestart
[16:21:59.622]                     is.null <- base::is.null
[16:21:59.622]                     muffled <- FALSE
[16:21:59.622]                     if (inherits(cond, "message")) {
[16:21:59.622]                       muffled <- grepl(pattern, "muffleMessage")
[16:21:59.622]                       if (muffled) 
[16:21:59.622]                         invokeRestart("muffleMessage")
[16:21:59.622]                     }
[16:21:59.622]                     else if (inherits(cond, "warning")) {
[16:21:59.622]                       muffled <- grepl(pattern, "muffleWarning")
[16:21:59.622]                       if (muffled) 
[16:21:59.622]                         invokeRestart("muffleWarning")
[16:21:59.622]                     }
[16:21:59.622]                     else if (inherits(cond, "condition")) {
[16:21:59.622]                       if (!is.null(pattern)) {
[16:21:59.622]                         computeRestarts <- base::computeRestarts
[16:21:59.622]                         grepl <- base::grepl
[16:21:59.622]                         restarts <- computeRestarts(cond)
[16:21:59.622]                         for (restart in restarts) {
[16:21:59.622]                           name <- restart$name
[16:21:59.622]                           if (is.null(name)) 
[16:21:59.622]                             next
[16:21:59.622]                           if (!grepl(pattern, name)) 
[16:21:59.622]                             next
[16:21:59.622]                           invokeRestart(restart)
[16:21:59.622]                           muffled <- TRUE
[16:21:59.622]                           break
[16:21:59.622]                         }
[16:21:59.622]                       }
[16:21:59.622]                     }
[16:21:59.622]                     invisible(muffled)
[16:21:59.622]                   }
[16:21:59.622]                   muffleCondition(cond)
[16:21:59.622]                 })
[16:21:59.622]             }))
[16:21:59.622]             future::FutureResult(value = ...future.value$value, 
[16:21:59.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.622]                   ...future.rng), globalenv = if (FALSE) 
[16:21:59.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:21:59.622]                     ...future.globalenv.names))
[16:21:59.622]                 else NULL, started = ...future.startTime, version = "1.8")
[16:21:59.622]         }, condition = base::local({
[16:21:59.622]             c <- base::c
[16:21:59.622]             inherits <- base::inherits
[16:21:59.622]             invokeRestart <- base::invokeRestart
[16:21:59.622]             length <- base::length
[16:21:59.622]             list <- base::list
[16:21:59.622]             seq.int <- base::seq.int
[16:21:59.622]             signalCondition <- base::signalCondition
[16:21:59.622]             sys.calls <- base::sys.calls
[16:21:59.622]             `[[` <- base::`[[`
[16:21:59.622]             `+` <- base::`+`
[16:21:59.622]             `<<-` <- base::`<<-`
[16:21:59.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:21:59.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:21:59.622]                   3L)]
[16:21:59.622]             }
[16:21:59.622]             function(cond) {
[16:21:59.622]                 is_error <- inherits(cond, "error")
[16:21:59.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:21:59.622]                   NULL)
[16:21:59.622]                 if (is_error) {
[16:21:59.622]                   sessionInformation <- function() {
[16:21:59.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:21:59.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:21:59.622]                       search = base::search(), system = base::Sys.info())
[16:21:59.622]                   }
[16:21:59.622]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:21:59.622]                     cond$call), session = sessionInformation(), 
[16:21:59.622]                     timestamp = base::Sys.time(), signaled = 0L)
[16:21:59.622]                   signalCondition(cond)
[16:21:59.622]                 }
[16:21:59.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:21:59.622]                 "immediateCondition"))) {
[16:21:59.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:21:59.622]                   ...future.conditions[[length(...future.conditions) + 
[16:21:59.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:21:59.622]                   if (TRUE && !signal) {
[16:21:59.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.622]                     {
[16:21:59.622]                       inherits <- base::inherits
[16:21:59.622]                       invokeRestart <- base::invokeRestart
[16:21:59.622]                       is.null <- base::is.null
[16:21:59.622]                       muffled <- FALSE
[16:21:59.622]                       if (inherits(cond, "message")) {
[16:21:59.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.622]                         if (muffled) 
[16:21:59.622]                           invokeRestart("muffleMessage")
[16:21:59.622]                       }
[16:21:59.622]                       else if (inherits(cond, "warning")) {
[16:21:59.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.622]                         if (muffled) 
[16:21:59.622]                           invokeRestart("muffleWarning")
[16:21:59.622]                       }
[16:21:59.622]                       else if (inherits(cond, "condition")) {
[16:21:59.622]                         if (!is.null(pattern)) {
[16:21:59.622]                           computeRestarts <- base::computeRestarts
[16:21:59.622]                           grepl <- base::grepl
[16:21:59.622]                           restarts <- computeRestarts(cond)
[16:21:59.622]                           for (restart in restarts) {
[16:21:59.622]                             name <- restart$name
[16:21:59.622]                             if (is.null(name)) 
[16:21:59.622]                               next
[16:21:59.622]                             if (!grepl(pattern, name)) 
[16:21:59.622]                               next
[16:21:59.622]                             invokeRestart(restart)
[16:21:59.622]                             muffled <- TRUE
[16:21:59.622]                             break
[16:21:59.622]                           }
[16:21:59.622]                         }
[16:21:59.622]                       }
[16:21:59.622]                       invisible(muffled)
[16:21:59.622]                     }
[16:21:59.622]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.622]                   }
[16:21:59.622]                 }
[16:21:59.622]                 else {
[16:21:59.622]                   if (TRUE) {
[16:21:59.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:21:59.622]                     {
[16:21:59.622]                       inherits <- base::inherits
[16:21:59.622]                       invokeRestart <- base::invokeRestart
[16:21:59.622]                       is.null <- base::is.null
[16:21:59.622]                       muffled <- FALSE
[16:21:59.622]                       if (inherits(cond, "message")) {
[16:21:59.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:21:59.622]                         if (muffled) 
[16:21:59.622]                           invokeRestart("muffleMessage")
[16:21:59.622]                       }
[16:21:59.622]                       else if (inherits(cond, "warning")) {
[16:21:59.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:21:59.622]                         if (muffled) 
[16:21:59.622]                           invokeRestart("muffleWarning")
[16:21:59.622]                       }
[16:21:59.622]                       else if (inherits(cond, "condition")) {
[16:21:59.622]                         if (!is.null(pattern)) {
[16:21:59.622]                           computeRestarts <- base::computeRestarts
[16:21:59.622]                           grepl <- base::grepl
[16:21:59.622]                           restarts <- computeRestarts(cond)
[16:21:59.622]                           for (restart in restarts) {
[16:21:59.622]                             name <- restart$name
[16:21:59.622]                             if (is.null(name)) 
[16:21:59.622]                               next
[16:21:59.622]                             if (!grepl(pattern, name)) 
[16:21:59.622]                               next
[16:21:59.622]                             invokeRestart(restart)
[16:21:59.622]                             muffled <- TRUE
[16:21:59.622]                             break
[16:21:59.622]                           }
[16:21:59.622]                         }
[16:21:59.622]                       }
[16:21:59.622]                       invisible(muffled)
[16:21:59.622]                     }
[16:21:59.622]                     muffleCondition(cond, pattern = "^muffle")
[16:21:59.622]                   }
[16:21:59.622]                 }
[16:21:59.622]             }
[16:21:59.622]         }))
[16:21:59.622]     }, error = function(ex) {
[16:21:59.622]         base::structure(base::list(value = NULL, visible = NULL, 
[16:21:59.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:21:59.622]                 ...future.rng), started = ...future.startTime, 
[16:21:59.622]             finished = Sys.time(), session_uuid = NA_character_, 
[16:21:59.622]             version = "1.8"), class = "FutureResult")
[16:21:59.622]     }, finally = {
[16:21:59.622]         if (!identical(...future.workdir, getwd())) 
[16:21:59.622]             setwd(...future.workdir)
[16:21:59.622]         {
[16:21:59.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:21:59.622]                 ...future.oldOptions$nwarnings <- NULL
[16:21:59.622]             }
[16:21:59.622]             base::options(...future.oldOptions)
[16:21:59.622]             if (.Platform$OS.type == "windows") {
[16:21:59.622]                 old_names <- names(...future.oldEnvVars)
[16:21:59.622]                 envs <- base::Sys.getenv()
[16:21:59.622]                 names <- names(envs)
[16:21:59.622]                 common <- intersect(names, old_names)
[16:21:59.622]                 added <- setdiff(names, old_names)
[16:21:59.622]                 removed <- setdiff(old_names, names)
[16:21:59.622]                 changed <- common[...future.oldEnvVars[common] != 
[16:21:59.622]                   envs[common]]
[16:21:59.622]                 NAMES <- toupper(changed)
[16:21:59.622]                 args <- list()
[16:21:59.622]                 for (kk in seq_along(NAMES)) {
[16:21:59.622]                   name <- changed[[kk]]
[16:21:59.622]                   NAME <- NAMES[[kk]]
[16:21:59.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.622]                     next
[16:21:59.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.622]                 }
[16:21:59.622]                 NAMES <- toupper(added)
[16:21:59.622]                 for (kk in seq_along(NAMES)) {
[16:21:59.622]                   name <- added[[kk]]
[16:21:59.622]                   NAME <- NAMES[[kk]]
[16:21:59.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.622]                     next
[16:21:59.622]                   args[[name]] <- ""
[16:21:59.622]                 }
[16:21:59.622]                 NAMES <- toupper(removed)
[16:21:59.622]                 for (kk in seq_along(NAMES)) {
[16:21:59.622]                   name <- removed[[kk]]
[16:21:59.622]                   NAME <- NAMES[[kk]]
[16:21:59.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:21:59.622]                     next
[16:21:59.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:21:59.622]                 }
[16:21:59.622]                 if (length(args) > 0) 
[16:21:59.622]                   base::do.call(base::Sys.setenv, args = args)
[16:21:59.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:21:59.622]             }
[16:21:59.622]             else {
[16:21:59.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:21:59.622]             }
[16:21:59.622]             {
[16:21:59.622]                 if (base::length(...future.futureOptionsAdded) > 
[16:21:59.622]                   0L) {
[16:21:59.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:21:59.622]                   base::names(opts) <- ...future.futureOptionsAdded
[16:21:59.622]                   base::options(opts)
[16:21:59.622]                 }
[16:21:59.622]                 {
[16:21:59.622]                   {
[16:21:59.622]                     base::options(mc.cores = ...future.mc.cores.old)
[16:21:59.622]                     NULL
[16:21:59.622]                   }
[16:21:59.622]                   options(future.plan = NULL)
[16:21:59.622]                   if (is.na(NA_character_)) 
[16:21:59.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:21:59.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:21:59.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:21:59.622]                     .init = FALSE)
[16:21:59.622]                 }
[16:21:59.622]             }
[16:21:59.622]         }
[16:21:59.622]     })
[16:21:59.622]     if (TRUE) {
[16:21:59.622]         base::sink(type = "output", split = FALSE)
[16:21:59.622]         if (TRUE) {
[16:21:59.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:21:59.622]         }
[16:21:59.622]         else {
[16:21:59.622]             ...future.result["stdout"] <- base::list(NULL)
[16:21:59.622]         }
[16:21:59.622]         base::close(...future.stdout)
[16:21:59.622]         ...future.stdout <- NULL
[16:21:59.622]     }
[16:21:59.622]     ...future.result$conditions <- ...future.conditions
[16:21:59.622]     ...future.result$finished <- base::Sys.time()
[16:21:59.622]     ...future.result
[16:21:59.622] }
[16:21:59.625] MultisessionFuture started
[16:21:59.625] - Launch lazy future ... done
[16:21:59.625] run() for ‘MultisessionFuture’ ... done
[16:22:00.128] receiveMessageFromWorker() for ClusterFuture ...
[16:22:00.128] - Validating connection of MultisessionFuture
[16:22:00.128] - received message: FutureResult
[16:22:00.128] - Received FutureResult
[16:22:00.128] - Erased future from FutureRegistry
[16:22:00.128] result() for ClusterFuture ...
[16:22:00.128] - result already collected: FutureResult
[16:22:00.129] result() for ClusterFuture ... done
[16:22:00.129] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:00.129] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:22:00.129] getGlobalsAndPackages() ...
[16:22:00.129] Searching for globals...
[16:22:00.130] - globals found: [2] ‘list’, ‘stop’
[16:22:00.130] Searching for globals ... DONE
[16:22:00.130] Resolving globals: FALSE
[16:22:00.130] 
[16:22:00.130] 
[16:22:00.130] getGlobalsAndPackages() ... DONE
[16:22:00.131] run() for ‘Future’ ...
[16:22:00.131] - state: ‘created’
[16:22:00.131] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:00.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:00.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:00.145]   - Field: ‘node’
[16:22:00.145]   - Field: ‘label’
[16:22:00.145]   - Field: ‘local’
[16:22:00.145]   - Field: ‘owner’
[16:22:00.146]   - Field: ‘envir’
[16:22:00.146]   - Field: ‘workers’
[16:22:00.146]   - Field: ‘packages’
[16:22:00.146]   - Field: ‘gc’
[16:22:00.146]   - Field: ‘conditions’
[16:22:00.146]   - Field: ‘persistent’
[16:22:00.146]   - Field: ‘expr’
[16:22:00.146]   - Field: ‘uuid’
[16:22:00.146]   - Field: ‘seed’
[16:22:00.146]   - Field: ‘version’
[16:22:00.146]   - Field: ‘result’
[16:22:00.147]   - Field: ‘asynchronous’
[16:22:00.147]   - Field: ‘calls’
[16:22:00.147]   - Field: ‘globals’
[16:22:00.147]   - Field: ‘stdout’
[16:22:00.147]   - Field: ‘earlySignal’
[16:22:00.147]   - Field: ‘lazy’
[16:22:00.147]   - Field: ‘state’
[16:22:00.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:00.147] - Launch lazy future ...
[16:22:00.148] Packages needed by the future expression (n = 0): <none>
[16:22:00.148] Packages needed by future strategies (n = 0): <none>
[16:22:00.148] {
[16:22:00.148]     {
[16:22:00.148]         {
[16:22:00.148]             ...future.startTime <- base::Sys.time()
[16:22:00.148]             {
[16:22:00.148]                 {
[16:22:00.148]                   {
[16:22:00.148]                     {
[16:22:00.148]                       base::local({
[16:22:00.148]                         has_future <- base::requireNamespace("future", 
[16:22:00.148]                           quietly = TRUE)
[16:22:00.148]                         if (has_future) {
[16:22:00.148]                           ns <- base::getNamespace("future")
[16:22:00.148]                           version <- ns[[".package"]][["version"]]
[16:22:00.148]                           if (is.null(version)) 
[16:22:00.148]                             version <- utils::packageVersion("future")
[16:22:00.148]                         }
[16:22:00.148]                         else {
[16:22:00.148]                           version <- NULL
[16:22:00.148]                         }
[16:22:00.148]                         if (!has_future || version < "1.8.0") {
[16:22:00.148]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:00.148]                             "", base::R.version$version.string), 
[16:22:00.148]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:00.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:00.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:00.148]                               "release", "version")], collapse = " "), 
[16:22:00.148]                             hostname = base::Sys.info()[["nodename"]])
[16:22:00.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:00.148]                             info)
[16:22:00.148]                           info <- base::paste(info, collapse = "; ")
[16:22:00.148]                           if (!has_future) {
[16:22:00.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:00.148]                               info)
[16:22:00.148]                           }
[16:22:00.148]                           else {
[16:22:00.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:00.148]                               info, version)
[16:22:00.148]                           }
[16:22:00.148]                           base::stop(msg)
[16:22:00.148]                         }
[16:22:00.148]                       })
[16:22:00.148]                     }
[16:22:00.148]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:00.148]                     base::options(mc.cores = 1L)
[16:22:00.148]                   }
[16:22:00.148]                   ...future.strategy.old <- future::plan("list")
[16:22:00.148]                   options(future.plan = NULL)
[16:22:00.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:00.148]                 }
[16:22:00.148]                 ...future.workdir <- getwd()
[16:22:00.148]             }
[16:22:00.148]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:00.148]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:00.148]         }
[16:22:00.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:00.148]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:00.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:00.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:00.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:00.148]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:00.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:00.148]             base::names(...future.oldOptions))
[16:22:00.148]     }
[16:22:00.148]     if (FALSE) {
[16:22:00.148]     }
[16:22:00.148]     else {
[16:22:00.148]         if (TRUE) {
[16:22:00.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:00.148]                 open = "w")
[16:22:00.148]         }
[16:22:00.148]         else {
[16:22:00.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:00.148]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:00.148]         }
[16:22:00.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:00.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:00.148]             base::sink(type = "output", split = FALSE)
[16:22:00.148]             base::close(...future.stdout)
[16:22:00.148]         }, add = TRUE)
[16:22:00.148]     }
[16:22:00.148]     ...future.frame <- base::sys.nframe()
[16:22:00.148]     ...future.conditions <- base::list()
[16:22:00.148]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:00.148]     if (FALSE) {
[16:22:00.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:00.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:00.148]     }
[16:22:00.148]     ...future.result <- base::tryCatch({
[16:22:00.148]         base::withCallingHandlers({
[16:22:00.148]             ...future.value <- base::withVisible(base::local({
[16:22:00.148]                 ...future.makeSendCondition <- base::local({
[16:22:00.148]                   sendCondition <- NULL
[16:22:00.148]                   function(frame = 1L) {
[16:22:00.148]                     if (is.function(sendCondition)) 
[16:22:00.148]                       return(sendCondition)
[16:22:00.148]                     ns <- getNamespace("parallel")
[16:22:00.148]                     if (exists("sendData", mode = "function", 
[16:22:00.148]                       envir = ns)) {
[16:22:00.148]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:00.148]                         envir = ns)
[16:22:00.148]                       envir <- sys.frame(frame)
[16:22:00.148]                       master <- NULL
[16:22:00.148]                       while (!identical(envir, .GlobalEnv) && 
[16:22:00.148]                         !identical(envir, emptyenv())) {
[16:22:00.148]                         if (exists("master", mode = "list", envir = envir, 
[16:22:00.148]                           inherits = FALSE)) {
[16:22:00.148]                           master <- get("master", mode = "list", 
[16:22:00.148]                             envir = envir, inherits = FALSE)
[16:22:00.148]                           if (inherits(master, c("SOCKnode", 
[16:22:00.148]                             "SOCK0node"))) {
[16:22:00.148]                             sendCondition <<- function(cond) {
[16:22:00.148]                               data <- list(type = "VALUE", value = cond, 
[16:22:00.148]                                 success = TRUE)
[16:22:00.148]                               parallel_sendData(master, data)
[16:22:00.148]                             }
[16:22:00.148]                             return(sendCondition)
[16:22:00.148]                           }
[16:22:00.148]                         }
[16:22:00.148]                         frame <- frame + 1L
[16:22:00.148]                         envir <- sys.frame(frame)
[16:22:00.148]                       }
[16:22:00.148]                     }
[16:22:00.148]                     sendCondition <<- function(cond) NULL
[16:22:00.148]                   }
[16:22:00.148]                 })
[16:22:00.148]                 withCallingHandlers({
[16:22:00.148]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:00.148]                 }, immediateCondition = function(cond) {
[16:22:00.148]                   sendCondition <- ...future.makeSendCondition()
[16:22:00.148]                   sendCondition(cond)
[16:22:00.148]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.148]                   {
[16:22:00.148]                     inherits <- base::inherits
[16:22:00.148]                     invokeRestart <- base::invokeRestart
[16:22:00.148]                     is.null <- base::is.null
[16:22:00.148]                     muffled <- FALSE
[16:22:00.148]                     if (inherits(cond, "message")) {
[16:22:00.148]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:00.148]                       if (muffled) 
[16:22:00.148]                         invokeRestart("muffleMessage")
[16:22:00.148]                     }
[16:22:00.148]                     else if (inherits(cond, "warning")) {
[16:22:00.148]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:00.148]                       if (muffled) 
[16:22:00.148]                         invokeRestart("muffleWarning")
[16:22:00.148]                     }
[16:22:00.148]                     else if (inherits(cond, "condition")) {
[16:22:00.148]                       if (!is.null(pattern)) {
[16:22:00.148]                         computeRestarts <- base::computeRestarts
[16:22:00.148]                         grepl <- base::grepl
[16:22:00.148]                         restarts <- computeRestarts(cond)
[16:22:00.148]                         for (restart in restarts) {
[16:22:00.148]                           name <- restart$name
[16:22:00.148]                           if (is.null(name)) 
[16:22:00.148]                             next
[16:22:00.148]                           if (!grepl(pattern, name)) 
[16:22:00.148]                             next
[16:22:00.148]                           invokeRestart(restart)
[16:22:00.148]                           muffled <- TRUE
[16:22:00.148]                           break
[16:22:00.148]                         }
[16:22:00.148]                       }
[16:22:00.148]                     }
[16:22:00.148]                     invisible(muffled)
[16:22:00.148]                   }
[16:22:00.148]                   muffleCondition(cond)
[16:22:00.148]                 })
[16:22:00.148]             }))
[16:22:00.148]             future::FutureResult(value = ...future.value$value, 
[16:22:00.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.148]                   ...future.rng), globalenv = if (FALSE) 
[16:22:00.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:00.148]                     ...future.globalenv.names))
[16:22:00.148]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:00.148]         }, condition = base::local({
[16:22:00.148]             c <- base::c
[16:22:00.148]             inherits <- base::inherits
[16:22:00.148]             invokeRestart <- base::invokeRestart
[16:22:00.148]             length <- base::length
[16:22:00.148]             list <- base::list
[16:22:00.148]             seq.int <- base::seq.int
[16:22:00.148]             signalCondition <- base::signalCondition
[16:22:00.148]             sys.calls <- base::sys.calls
[16:22:00.148]             `[[` <- base::`[[`
[16:22:00.148]             `+` <- base::`+`
[16:22:00.148]             `<<-` <- base::`<<-`
[16:22:00.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:00.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:00.148]                   3L)]
[16:22:00.148]             }
[16:22:00.148]             function(cond) {
[16:22:00.148]                 is_error <- inherits(cond, "error")
[16:22:00.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:00.148]                   NULL)
[16:22:00.148]                 if (is_error) {
[16:22:00.148]                   sessionInformation <- function() {
[16:22:00.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:00.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:00.148]                       search = base::search(), system = base::Sys.info())
[16:22:00.148]                   }
[16:22:00.148]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:00.148]                     cond$call), session = sessionInformation(), 
[16:22:00.148]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:00.148]                   signalCondition(cond)
[16:22:00.148]                 }
[16:22:00.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:00.148]                 "immediateCondition"))) {
[16:22:00.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:00.148]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:00.148]                   if (TRUE && !signal) {
[16:22:00.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.148]                     {
[16:22:00.148]                       inherits <- base::inherits
[16:22:00.148]                       invokeRestart <- base::invokeRestart
[16:22:00.148]                       is.null <- base::is.null
[16:22:00.148]                       muffled <- FALSE
[16:22:00.148]                       if (inherits(cond, "message")) {
[16:22:00.148]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.148]                         if (muffled) 
[16:22:00.148]                           invokeRestart("muffleMessage")
[16:22:00.148]                       }
[16:22:00.148]                       else if (inherits(cond, "warning")) {
[16:22:00.148]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.148]                         if (muffled) 
[16:22:00.148]                           invokeRestart("muffleWarning")
[16:22:00.148]                       }
[16:22:00.148]                       else if (inherits(cond, "condition")) {
[16:22:00.148]                         if (!is.null(pattern)) {
[16:22:00.148]                           computeRestarts <- base::computeRestarts
[16:22:00.148]                           grepl <- base::grepl
[16:22:00.148]                           restarts <- computeRestarts(cond)
[16:22:00.148]                           for (restart in restarts) {
[16:22:00.148]                             name <- restart$name
[16:22:00.148]                             if (is.null(name)) 
[16:22:00.148]                               next
[16:22:00.148]                             if (!grepl(pattern, name)) 
[16:22:00.148]                               next
[16:22:00.148]                             invokeRestart(restart)
[16:22:00.148]                             muffled <- TRUE
[16:22:00.148]                             break
[16:22:00.148]                           }
[16:22:00.148]                         }
[16:22:00.148]                       }
[16:22:00.148]                       invisible(muffled)
[16:22:00.148]                     }
[16:22:00.148]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.148]                   }
[16:22:00.148]                 }
[16:22:00.148]                 else {
[16:22:00.148]                   if (TRUE) {
[16:22:00.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.148]                     {
[16:22:00.148]                       inherits <- base::inherits
[16:22:00.148]                       invokeRestart <- base::invokeRestart
[16:22:00.148]                       is.null <- base::is.null
[16:22:00.148]                       muffled <- FALSE
[16:22:00.148]                       if (inherits(cond, "message")) {
[16:22:00.148]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.148]                         if (muffled) 
[16:22:00.148]                           invokeRestart("muffleMessage")
[16:22:00.148]                       }
[16:22:00.148]                       else if (inherits(cond, "warning")) {
[16:22:00.148]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.148]                         if (muffled) 
[16:22:00.148]                           invokeRestart("muffleWarning")
[16:22:00.148]                       }
[16:22:00.148]                       else if (inherits(cond, "condition")) {
[16:22:00.148]                         if (!is.null(pattern)) {
[16:22:00.148]                           computeRestarts <- base::computeRestarts
[16:22:00.148]                           grepl <- base::grepl
[16:22:00.148]                           restarts <- computeRestarts(cond)
[16:22:00.148]                           for (restart in restarts) {
[16:22:00.148]                             name <- restart$name
[16:22:00.148]                             if (is.null(name)) 
[16:22:00.148]                               next
[16:22:00.148]                             if (!grepl(pattern, name)) 
[16:22:00.148]                               next
[16:22:00.148]                             invokeRestart(restart)
[16:22:00.148]                             muffled <- TRUE
[16:22:00.148]                             break
[16:22:00.148]                           }
[16:22:00.148]                         }
[16:22:00.148]                       }
[16:22:00.148]                       invisible(muffled)
[16:22:00.148]                     }
[16:22:00.148]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.148]                   }
[16:22:00.148]                 }
[16:22:00.148]             }
[16:22:00.148]         }))
[16:22:00.148]     }, error = function(ex) {
[16:22:00.148]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:00.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.148]                 ...future.rng), started = ...future.startTime, 
[16:22:00.148]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:00.148]             version = "1.8"), class = "FutureResult")
[16:22:00.148]     }, finally = {
[16:22:00.148]         if (!identical(...future.workdir, getwd())) 
[16:22:00.148]             setwd(...future.workdir)
[16:22:00.148]         {
[16:22:00.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:00.148]                 ...future.oldOptions$nwarnings <- NULL
[16:22:00.148]             }
[16:22:00.148]             base::options(...future.oldOptions)
[16:22:00.148]             if (.Platform$OS.type == "windows") {
[16:22:00.148]                 old_names <- names(...future.oldEnvVars)
[16:22:00.148]                 envs <- base::Sys.getenv()
[16:22:00.148]                 names <- names(envs)
[16:22:00.148]                 common <- intersect(names, old_names)
[16:22:00.148]                 added <- setdiff(names, old_names)
[16:22:00.148]                 removed <- setdiff(old_names, names)
[16:22:00.148]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:00.148]                   envs[common]]
[16:22:00.148]                 NAMES <- toupper(changed)
[16:22:00.148]                 args <- list()
[16:22:00.148]                 for (kk in seq_along(NAMES)) {
[16:22:00.148]                   name <- changed[[kk]]
[16:22:00.148]                   NAME <- NAMES[[kk]]
[16:22:00.148]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.148]                     next
[16:22:00.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.148]                 }
[16:22:00.148]                 NAMES <- toupper(added)
[16:22:00.148]                 for (kk in seq_along(NAMES)) {
[16:22:00.148]                   name <- added[[kk]]
[16:22:00.148]                   NAME <- NAMES[[kk]]
[16:22:00.148]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.148]                     next
[16:22:00.148]                   args[[name]] <- ""
[16:22:00.148]                 }
[16:22:00.148]                 NAMES <- toupper(removed)
[16:22:00.148]                 for (kk in seq_along(NAMES)) {
[16:22:00.148]                   name <- removed[[kk]]
[16:22:00.148]                   NAME <- NAMES[[kk]]
[16:22:00.148]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.148]                     next
[16:22:00.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.148]                 }
[16:22:00.148]                 if (length(args) > 0) 
[16:22:00.148]                   base::do.call(base::Sys.setenv, args = args)
[16:22:00.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:00.148]             }
[16:22:00.148]             else {
[16:22:00.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:00.148]             }
[16:22:00.148]             {
[16:22:00.148]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:00.148]                   0L) {
[16:22:00.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:00.148]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:00.148]                   base::options(opts)
[16:22:00.148]                 }
[16:22:00.148]                 {
[16:22:00.148]                   {
[16:22:00.148]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:00.148]                     NULL
[16:22:00.148]                   }
[16:22:00.148]                   options(future.plan = NULL)
[16:22:00.148]                   if (is.na(NA_character_)) 
[16:22:00.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:00.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:00.148]                     .init = FALSE)
[16:22:00.148]                 }
[16:22:00.148]             }
[16:22:00.148]         }
[16:22:00.148]     })
[16:22:00.148]     if (TRUE) {
[16:22:00.148]         base::sink(type = "output", split = FALSE)
[16:22:00.148]         if (TRUE) {
[16:22:00.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:00.148]         }
[16:22:00.148]         else {
[16:22:00.148]             ...future.result["stdout"] <- base::list(NULL)
[16:22:00.148]         }
[16:22:00.148]         base::close(...future.stdout)
[16:22:00.148]         ...future.stdout <- NULL
[16:22:00.148]     }
[16:22:00.148]     ...future.result$conditions <- ...future.conditions
[16:22:00.148]     ...future.result$finished <- base::Sys.time()
[16:22:00.148]     ...future.result
[16:22:00.148] }
[16:22:00.151] MultisessionFuture started
[16:22:00.151] - Launch lazy future ... done
[16:22:00.151] run() for ‘MultisessionFuture’ ... done
[16:22:00.153] receiveMessageFromWorker() for ClusterFuture ...
[16:22:00.153] - Validating connection of MultisessionFuture
[16:22:00.154] - received message: FutureResult
[16:22:00.154] - Received FutureResult
[16:22:00.154] - Erased future from FutureRegistry
[16:22:00.154] result() for ClusterFuture ...
[16:22:00.154] - result already collected: FutureResult
[16:22:00.154] result() for ClusterFuture ... done
[16:22:00.154] signalConditions() ...
[16:22:00.155]  - include = ‘immediateCondition’
[16:22:00.155]  - exclude = 
[16:22:00.155]  - resignal = FALSE
[16:22:00.155]  - Number of conditions: 1
[16:22:00.155] signalConditions() ... done
[16:22:00.155] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:00.155] A MultisessionFuture was resolved (result was not collected)
[16:22:00.155] getGlobalsAndPackages() ...
[16:22:00.155] Searching for globals...
[16:22:00.156] - globals found: [2] ‘list’, ‘stop’
[16:22:00.156] Searching for globals ... DONE
[16:22:00.156] Resolving globals: FALSE
[16:22:00.157] 
[16:22:00.157] 
[16:22:00.157] getGlobalsAndPackages() ... DONE
[16:22:00.157] run() for ‘Future’ ...
[16:22:00.157] - state: ‘created’
[16:22:00.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:00.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:00.171] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:00.171]   - Field: ‘node’
[16:22:00.171]   - Field: ‘label’
[16:22:00.171]   - Field: ‘local’
[16:22:00.171]   - Field: ‘owner’
[16:22:00.171]   - Field: ‘envir’
[16:22:00.171]   - Field: ‘workers’
[16:22:00.171]   - Field: ‘packages’
[16:22:00.172]   - Field: ‘gc’
[16:22:00.172]   - Field: ‘conditions’
[16:22:00.172]   - Field: ‘persistent’
[16:22:00.172]   - Field: ‘expr’
[16:22:00.172]   - Field: ‘uuid’
[16:22:00.172]   - Field: ‘seed’
[16:22:00.172]   - Field: ‘version’
[16:22:00.172]   - Field: ‘result’
[16:22:00.172]   - Field: ‘asynchronous’
[16:22:00.172]   - Field: ‘calls’
[16:22:00.172]   - Field: ‘globals’
[16:22:00.173]   - Field: ‘stdout’
[16:22:00.173]   - Field: ‘earlySignal’
[16:22:00.173]   - Field: ‘lazy’
[16:22:00.173]   - Field: ‘state’
[16:22:00.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:00.173] - Launch lazy future ...
[16:22:00.173] Packages needed by the future expression (n = 0): <none>
[16:22:00.173] Packages needed by future strategies (n = 0): <none>
[16:22:00.174] {
[16:22:00.174]     {
[16:22:00.174]         {
[16:22:00.174]             ...future.startTime <- base::Sys.time()
[16:22:00.174]             {
[16:22:00.174]                 {
[16:22:00.174]                   {
[16:22:00.174]                     {
[16:22:00.174]                       base::local({
[16:22:00.174]                         has_future <- base::requireNamespace("future", 
[16:22:00.174]                           quietly = TRUE)
[16:22:00.174]                         if (has_future) {
[16:22:00.174]                           ns <- base::getNamespace("future")
[16:22:00.174]                           version <- ns[[".package"]][["version"]]
[16:22:00.174]                           if (is.null(version)) 
[16:22:00.174]                             version <- utils::packageVersion("future")
[16:22:00.174]                         }
[16:22:00.174]                         else {
[16:22:00.174]                           version <- NULL
[16:22:00.174]                         }
[16:22:00.174]                         if (!has_future || version < "1.8.0") {
[16:22:00.174]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:00.174]                             "", base::R.version$version.string), 
[16:22:00.174]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:00.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:00.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:00.174]                               "release", "version")], collapse = " "), 
[16:22:00.174]                             hostname = base::Sys.info()[["nodename"]])
[16:22:00.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:00.174]                             info)
[16:22:00.174]                           info <- base::paste(info, collapse = "; ")
[16:22:00.174]                           if (!has_future) {
[16:22:00.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:00.174]                               info)
[16:22:00.174]                           }
[16:22:00.174]                           else {
[16:22:00.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:00.174]                               info, version)
[16:22:00.174]                           }
[16:22:00.174]                           base::stop(msg)
[16:22:00.174]                         }
[16:22:00.174]                       })
[16:22:00.174]                     }
[16:22:00.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:00.174]                     base::options(mc.cores = 1L)
[16:22:00.174]                   }
[16:22:00.174]                   ...future.strategy.old <- future::plan("list")
[16:22:00.174]                   options(future.plan = NULL)
[16:22:00.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:00.174]                 }
[16:22:00.174]                 ...future.workdir <- getwd()
[16:22:00.174]             }
[16:22:00.174]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:00.174]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:00.174]         }
[16:22:00.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:00.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:00.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:00.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:00.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:00.174]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:00.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:00.174]             base::names(...future.oldOptions))
[16:22:00.174]     }
[16:22:00.174]     if (FALSE) {
[16:22:00.174]     }
[16:22:00.174]     else {
[16:22:00.174]         if (TRUE) {
[16:22:00.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:00.174]                 open = "w")
[16:22:00.174]         }
[16:22:00.174]         else {
[16:22:00.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:00.174]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:00.174]         }
[16:22:00.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:00.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:00.174]             base::sink(type = "output", split = FALSE)
[16:22:00.174]             base::close(...future.stdout)
[16:22:00.174]         }, add = TRUE)
[16:22:00.174]     }
[16:22:00.174]     ...future.frame <- base::sys.nframe()
[16:22:00.174]     ...future.conditions <- base::list()
[16:22:00.174]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:00.174]     if (FALSE) {
[16:22:00.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:00.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:00.174]     }
[16:22:00.174]     ...future.result <- base::tryCatch({
[16:22:00.174]         base::withCallingHandlers({
[16:22:00.174]             ...future.value <- base::withVisible(base::local({
[16:22:00.174]                 ...future.makeSendCondition <- base::local({
[16:22:00.174]                   sendCondition <- NULL
[16:22:00.174]                   function(frame = 1L) {
[16:22:00.174]                     if (is.function(sendCondition)) 
[16:22:00.174]                       return(sendCondition)
[16:22:00.174]                     ns <- getNamespace("parallel")
[16:22:00.174]                     if (exists("sendData", mode = "function", 
[16:22:00.174]                       envir = ns)) {
[16:22:00.174]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:00.174]                         envir = ns)
[16:22:00.174]                       envir <- sys.frame(frame)
[16:22:00.174]                       master <- NULL
[16:22:00.174]                       while (!identical(envir, .GlobalEnv) && 
[16:22:00.174]                         !identical(envir, emptyenv())) {
[16:22:00.174]                         if (exists("master", mode = "list", envir = envir, 
[16:22:00.174]                           inherits = FALSE)) {
[16:22:00.174]                           master <- get("master", mode = "list", 
[16:22:00.174]                             envir = envir, inherits = FALSE)
[16:22:00.174]                           if (inherits(master, c("SOCKnode", 
[16:22:00.174]                             "SOCK0node"))) {
[16:22:00.174]                             sendCondition <<- function(cond) {
[16:22:00.174]                               data <- list(type = "VALUE", value = cond, 
[16:22:00.174]                                 success = TRUE)
[16:22:00.174]                               parallel_sendData(master, data)
[16:22:00.174]                             }
[16:22:00.174]                             return(sendCondition)
[16:22:00.174]                           }
[16:22:00.174]                         }
[16:22:00.174]                         frame <- frame + 1L
[16:22:00.174]                         envir <- sys.frame(frame)
[16:22:00.174]                       }
[16:22:00.174]                     }
[16:22:00.174]                     sendCondition <<- function(cond) NULL
[16:22:00.174]                   }
[16:22:00.174]                 })
[16:22:00.174]                 withCallingHandlers({
[16:22:00.174]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:00.174]                 }, immediateCondition = function(cond) {
[16:22:00.174]                   sendCondition <- ...future.makeSendCondition()
[16:22:00.174]                   sendCondition(cond)
[16:22:00.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.174]                   {
[16:22:00.174]                     inherits <- base::inherits
[16:22:00.174]                     invokeRestart <- base::invokeRestart
[16:22:00.174]                     is.null <- base::is.null
[16:22:00.174]                     muffled <- FALSE
[16:22:00.174]                     if (inherits(cond, "message")) {
[16:22:00.174]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:00.174]                       if (muffled) 
[16:22:00.174]                         invokeRestart("muffleMessage")
[16:22:00.174]                     }
[16:22:00.174]                     else if (inherits(cond, "warning")) {
[16:22:00.174]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:00.174]                       if (muffled) 
[16:22:00.174]                         invokeRestart("muffleWarning")
[16:22:00.174]                     }
[16:22:00.174]                     else if (inherits(cond, "condition")) {
[16:22:00.174]                       if (!is.null(pattern)) {
[16:22:00.174]                         computeRestarts <- base::computeRestarts
[16:22:00.174]                         grepl <- base::grepl
[16:22:00.174]                         restarts <- computeRestarts(cond)
[16:22:00.174]                         for (restart in restarts) {
[16:22:00.174]                           name <- restart$name
[16:22:00.174]                           if (is.null(name)) 
[16:22:00.174]                             next
[16:22:00.174]                           if (!grepl(pattern, name)) 
[16:22:00.174]                             next
[16:22:00.174]                           invokeRestart(restart)
[16:22:00.174]                           muffled <- TRUE
[16:22:00.174]                           break
[16:22:00.174]                         }
[16:22:00.174]                       }
[16:22:00.174]                     }
[16:22:00.174]                     invisible(muffled)
[16:22:00.174]                   }
[16:22:00.174]                   muffleCondition(cond)
[16:22:00.174]                 })
[16:22:00.174]             }))
[16:22:00.174]             future::FutureResult(value = ...future.value$value, 
[16:22:00.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.174]                   ...future.rng), globalenv = if (FALSE) 
[16:22:00.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:00.174]                     ...future.globalenv.names))
[16:22:00.174]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:00.174]         }, condition = base::local({
[16:22:00.174]             c <- base::c
[16:22:00.174]             inherits <- base::inherits
[16:22:00.174]             invokeRestart <- base::invokeRestart
[16:22:00.174]             length <- base::length
[16:22:00.174]             list <- base::list
[16:22:00.174]             seq.int <- base::seq.int
[16:22:00.174]             signalCondition <- base::signalCondition
[16:22:00.174]             sys.calls <- base::sys.calls
[16:22:00.174]             `[[` <- base::`[[`
[16:22:00.174]             `+` <- base::`+`
[16:22:00.174]             `<<-` <- base::`<<-`
[16:22:00.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:00.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:00.174]                   3L)]
[16:22:00.174]             }
[16:22:00.174]             function(cond) {
[16:22:00.174]                 is_error <- inherits(cond, "error")
[16:22:00.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:00.174]                   NULL)
[16:22:00.174]                 if (is_error) {
[16:22:00.174]                   sessionInformation <- function() {
[16:22:00.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:00.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:00.174]                       search = base::search(), system = base::Sys.info())
[16:22:00.174]                   }
[16:22:00.174]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:00.174]                     cond$call), session = sessionInformation(), 
[16:22:00.174]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:00.174]                   signalCondition(cond)
[16:22:00.174]                 }
[16:22:00.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:00.174]                 "immediateCondition"))) {
[16:22:00.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:00.174]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:00.174]                   if (TRUE && !signal) {
[16:22:00.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.174]                     {
[16:22:00.174]                       inherits <- base::inherits
[16:22:00.174]                       invokeRestart <- base::invokeRestart
[16:22:00.174]                       is.null <- base::is.null
[16:22:00.174]                       muffled <- FALSE
[16:22:00.174]                       if (inherits(cond, "message")) {
[16:22:00.174]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.174]                         if (muffled) 
[16:22:00.174]                           invokeRestart("muffleMessage")
[16:22:00.174]                       }
[16:22:00.174]                       else if (inherits(cond, "warning")) {
[16:22:00.174]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.174]                         if (muffled) 
[16:22:00.174]                           invokeRestart("muffleWarning")
[16:22:00.174]                       }
[16:22:00.174]                       else if (inherits(cond, "condition")) {
[16:22:00.174]                         if (!is.null(pattern)) {
[16:22:00.174]                           computeRestarts <- base::computeRestarts
[16:22:00.174]                           grepl <- base::grepl
[16:22:00.174]                           restarts <- computeRestarts(cond)
[16:22:00.174]                           for (restart in restarts) {
[16:22:00.174]                             name <- restart$name
[16:22:00.174]                             if (is.null(name)) 
[16:22:00.174]                               next
[16:22:00.174]                             if (!grepl(pattern, name)) 
[16:22:00.174]                               next
[16:22:00.174]                             invokeRestart(restart)
[16:22:00.174]                             muffled <- TRUE
[16:22:00.174]                             break
[16:22:00.174]                           }
[16:22:00.174]                         }
[16:22:00.174]                       }
[16:22:00.174]                       invisible(muffled)
[16:22:00.174]                     }
[16:22:00.174]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.174]                   }
[16:22:00.174]                 }
[16:22:00.174]                 else {
[16:22:00.174]                   if (TRUE) {
[16:22:00.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.174]                     {
[16:22:00.174]                       inherits <- base::inherits
[16:22:00.174]                       invokeRestart <- base::invokeRestart
[16:22:00.174]                       is.null <- base::is.null
[16:22:00.174]                       muffled <- FALSE
[16:22:00.174]                       if (inherits(cond, "message")) {
[16:22:00.174]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.174]                         if (muffled) 
[16:22:00.174]                           invokeRestart("muffleMessage")
[16:22:00.174]                       }
[16:22:00.174]                       else if (inherits(cond, "warning")) {
[16:22:00.174]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.174]                         if (muffled) 
[16:22:00.174]                           invokeRestart("muffleWarning")
[16:22:00.174]                       }
[16:22:00.174]                       else if (inherits(cond, "condition")) {
[16:22:00.174]                         if (!is.null(pattern)) {
[16:22:00.174]                           computeRestarts <- base::computeRestarts
[16:22:00.174]                           grepl <- base::grepl
[16:22:00.174]                           restarts <- computeRestarts(cond)
[16:22:00.174]                           for (restart in restarts) {
[16:22:00.174]                             name <- restart$name
[16:22:00.174]                             if (is.null(name)) 
[16:22:00.174]                               next
[16:22:00.174]                             if (!grepl(pattern, name)) 
[16:22:00.174]                               next
[16:22:00.174]                             invokeRestart(restart)
[16:22:00.174]                             muffled <- TRUE
[16:22:00.174]                             break
[16:22:00.174]                           }
[16:22:00.174]                         }
[16:22:00.174]                       }
[16:22:00.174]                       invisible(muffled)
[16:22:00.174]                     }
[16:22:00.174]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.174]                   }
[16:22:00.174]                 }
[16:22:00.174]             }
[16:22:00.174]         }))
[16:22:00.174]     }, error = function(ex) {
[16:22:00.174]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:00.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.174]                 ...future.rng), started = ...future.startTime, 
[16:22:00.174]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:00.174]             version = "1.8"), class = "FutureResult")
[16:22:00.174]     }, finally = {
[16:22:00.174]         if (!identical(...future.workdir, getwd())) 
[16:22:00.174]             setwd(...future.workdir)
[16:22:00.174]         {
[16:22:00.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:00.174]                 ...future.oldOptions$nwarnings <- NULL
[16:22:00.174]             }
[16:22:00.174]             base::options(...future.oldOptions)
[16:22:00.174]             if (.Platform$OS.type == "windows") {
[16:22:00.174]                 old_names <- names(...future.oldEnvVars)
[16:22:00.174]                 envs <- base::Sys.getenv()
[16:22:00.174]                 names <- names(envs)
[16:22:00.174]                 common <- intersect(names, old_names)
[16:22:00.174]                 added <- setdiff(names, old_names)
[16:22:00.174]                 removed <- setdiff(old_names, names)
[16:22:00.174]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:00.174]                   envs[common]]
[16:22:00.174]                 NAMES <- toupper(changed)
[16:22:00.174]                 args <- list()
[16:22:00.174]                 for (kk in seq_along(NAMES)) {
[16:22:00.174]                   name <- changed[[kk]]
[16:22:00.174]                   NAME <- NAMES[[kk]]
[16:22:00.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.174]                     next
[16:22:00.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.174]                 }
[16:22:00.174]                 NAMES <- toupper(added)
[16:22:00.174]                 for (kk in seq_along(NAMES)) {
[16:22:00.174]                   name <- added[[kk]]
[16:22:00.174]                   NAME <- NAMES[[kk]]
[16:22:00.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.174]                     next
[16:22:00.174]                   args[[name]] <- ""
[16:22:00.174]                 }
[16:22:00.174]                 NAMES <- toupper(removed)
[16:22:00.174]                 for (kk in seq_along(NAMES)) {
[16:22:00.174]                   name <- removed[[kk]]
[16:22:00.174]                   NAME <- NAMES[[kk]]
[16:22:00.174]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.174]                     next
[16:22:00.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.174]                 }
[16:22:00.174]                 if (length(args) > 0) 
[16:22:00.174]                   base::do.call(base::Sys.setenv, args = args)
[16:22:00.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:00.174]             }
[16:22:00.174]             else {
[16:22:00.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:00.174]             }
[16:22:00.174]             {
[16:22:00.174]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:00.174]                   0L) {
[16:22:00.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:00.174]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:00.174]                   base::options(opts)
[16:22:00.174]                 }
[16:22:00.174]                 {
[16:22:00.174]                   {
[16:22:00.174]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:00.174]                     NULL
[16:22:00.174]                   }
[16:22:00.174]                   options(future.plan = NULL)
[16:22:00.174]                   if (is.na(NA_character_)) 
[16:22:00.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:00.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:00.174]                     .init = FALSE)
[16:22:00.174]                 }
[16:22:00.174]             }
[16:22:00.174]         }
[16:22:00.174]     })
[16:22:00.174]     if (TRUE) {
[16:22:00.174]         base::sink(type = "output", split = FALSE)
[16:22:00.174]         if (TRUE) {
[16:22:00.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:00.174]         }
[16:22:00.174]         else {
[16:22:00.174]             ...future.result["stdout"] <- base::list(NULL)
[16:22:00.174]         }
[16:22:00.174]         base::close(...future.stdout)
[16:22:00.174]         ...future.stdout <- NULL
[16:22:00.174]     }
[16:22:00.174]     ...future.result$conditions <- ...future.conditions
[16:22:00.174]     ...future.result$finished <- base::Sys.time()
[16:22:00.174]     ...future.result
[16:22:00.174] }
[16:22:00.177] MultisessionFuture started
[16:22:00.177] - Launch lazy future ... done
[16:22:00.177] run() for ‘MultisessionFuture’ ... done
[16:22:00.179] receiveMessageFromWorker() for ClusterFuture ...
[16:22:00.179] - Validating connection of MultisessionFuture
[16:22:00.179] - received message: FutureResult
[16:22:00.179] - Received FutureResult
[16:22:00.180] - Erased future from FutureRegistry
[16:22:00.180] result() for ClusterFuture ...
[16:22:00.180] - result already collected: FutureResult
[16:22:00.180] result() for ClusterFuture ... done
[16:22:00.180] signalConditions() ...
[16:22:00.180]  - include = ‘immediateCondition’
[16:22:00.180]  - exclude = 
[16:22:00.180]  - resignal = FALSE
[16:22:00.180]  - Number of conditions: 1
[16:22:00.180] signalConditions() ... done
[16:22:00.180] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:00.181] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[16:22:00.181] getGlobalsAndPackages() ...
[16:22:00.181] Searching for globals...
[16:22:00.182] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:00.182] Searching for globals ... DONE
[16:22:00.182] Resolving globals: FALSE
[16:22:00.182] 
[16:22:00.183] 
[16:22:00.183] getGlobalsAndPackages() ... DONE
[16:22:00.183] run() for ‘Future’ ...
[16:22:00.183] - state: ‘created’
[16:22:00.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:00.196] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:00.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:00.197]   - Field: ‘node’
[16:22:00.197]   - Field: ‘label’
[16:22:00.197]   - Field: ‘local’
[16:22:00.197]   - Field: ‘owner’
[16:22:00.197]   - Field: ‘envir’
[16:22:00.197]   - Field: ‘workers’
[16:22:00.197]   - Field: ‘packages’
[16:22:00.197]   - Field: ‘gc’
[16:22:00.198]   - Field: ‘conditions’
[16:22:00.198]   - Field: ‘persistent’
[16:22:00.198]   - Field: ‘expr’
[16:22:00.198]   - Field: ‘uuid’
[16:22:00.198]   - Field: ‘seed’
[16:22:00.198]   - Field: ‘version’
[16:22:00.198]   - Field: ‘result’
[16:22:00.198]   - Field: ‘asynchronous’
[16:22:00.198]   - Field: ‘calls’
[16:22:00.198]   - Field: ‘globals’
[16:22:00.198]   - Field: ‘stdout’
[16:22:00.198]   - Field: ‘earlySignal’
[16:22:00.199]   - Field: ‘lazy’
[16:22:00.199]   - Field: ‘state’
[16:22:00.199] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:00.199] - Launch lazy future ...
[16:22:00.199] Packages needed by the future expression (n = 0): <none>
[16:22:00.199] Packages needed by future strategies (n = 0): <none>
[16:22:00.200] {
[16:22:00.200]     {
[16:22:00.200]         {
[16:22:00.200]             ...future.startTime <- base::Sys.time()
[16:22:00.200]             {
[16:22:00.200]                 {
[16:22:00.200]                   {
[16:22:00.200]                     {
[16:22:00.200]                       base::local({
[16:22:00.200]                         has_future <- base::requireNamespace("future", 
[16:22:00.200]                           quietly = TRUE)
[16:22:00.200]                         if (has_future) {
[16:22:00.200]                           ns <- base::getNamespace("future")
[16:22:00.200]                           version <- ns[[".package"]][["version"]]
[16:22:00.200]                           if (is.null(version)) 
[16:22:00.200]                             version <- utils::packageVersion("future")
[16:22:00.200]                         }
[16:22:00.200]                         else {
[16:22:00.200]                           version <- NULL
[16:22:00.200]                         }
[16:22:00.200]                         if (!has_future || version < "1.8.0") {
[16:22:00.200]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:00.200]                             "", base::R.version$version.string), 
[16:22:00.200]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:00.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:00.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:00.200]                               "release", "version")], collapse = " "), 
[16:22:00.200]                             hostname = base::Sys.info()[["nodename"]])
[16:22:00.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:00.200]                             info)
[16:22:00.200]                           info <- base::paste(info, collapse = "; ")
[16:22:00.200]                           if (!has_future) {
[16:22:00.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:00.200]                               info)
[16:22:00.200]                           }
[16:22:00.200]                           else {
[16:22:00.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:00.200]                               info, version)
[16:22:00.200]                           }
[16:22:00.200]                           base::stop(msg)
[16:22:00.200]                         }
[16:22:00.200]                       })
[16:22:00.200]                     }
[16:22:00.200]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:00.200]                     base::options(mc.cores = 1L)
[16:22:00.200]                   }
[16:22:00.200]                   ...future.strategy.old <- future::plan("list")
[16:22:00.200]                   options(future.plan = NULL)
[16:22:00.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:00.200]                 }
[16:22:00.200]                 ...future.workdir <- getwd()
[16:22:00.200]             }
[16:22:00.200]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:00.200]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:00.200]         }
[16:22:00.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:00.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:00.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:00.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:00.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:00.200]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:00.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:00.200]             base::names(...future.oldOptions))
[16:22:00.200]     }
[16:22:00.200]     if (FALSE) {
[16:22:00.200]     }
[16:22:00.200]     else {
[16:22:00.200]         if (TRUE) {
[16:22:00.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:00.200]                 open = "w")
[16:22:00.200]         }
[16:22:00.200]         else {
[16:22:00.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:00.200]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:00.200]         }
[16:22:00.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:00.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:00.200]             base::sink(type = "output", split = FALSE)
[16:22:00.200]             base::close(...future.stdout)
[16:22:00.200]         }, add = TRUE)
[16:22:00.200]     }
[16:22:00.200]     ...future.frame <- base::sys.nframe()
[16:22:00.200]     ...future.conditions <- base::list()
[16:22:00.200]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:00.200]     if (FALSE) {
[16:22:00.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:00.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:00.200]     }
[16:22:00.200]     ...future.result <- base::tryCatch({
[16:22:00.200]         base::withCallingHandlers({
[16:22:00.200]             ...future.value <- base::withVisible(base::local({
[16:22:00.200]                 ...future.makeSendCondition <- base::local({
[16:22:00.200]                   sendCondition <- NULL
[16:22:00.200]                   function(frame = 1L) {
[16:22:00.200]                     if (is.function(sendCondition)) 
[16:22:00.200]                       return(sendCondition)
[16:22:00.200]                     ns <- getNamespace("parallel")
[16:22:00.200]                     if (exists("sendData", mode = "function", 
[16:22:00.200]                       envir = ns)) {
[16:22:00.200]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:00.200]                         envir = ns)
[16:22:00.200]                       envir <- sys.frame(frame)
[16:22:00.200]                       master <- NULL
[16:22:00.200]                       while (!identical(envir, .GlobalEnv) && 
[16:22:00.200]                         !identical(envir, emptyenv())) {
[16:22:00.200]                         if (exists("master", mode = "list", envir = envir, 
[16:22:00.200]                           inherits = FALSE)) {
[16:22:00.200]                           master <- get("master", mode = "list", 
[16:22:00.200]                             envir = envir, inherits = FALSE)
[16:22:00.200]                           if (inherits(master, c("SOCKnode", 
[16:22:00.200]                             "SOCK0node"))) {
[16:22:00.200]                             sendCondition <<- function(cond) {
[16:22:00.200]                               data <- list(type = "VALUE", value = cond, 
[16:22:00.200]                                 success = TRUE)
[16:22:00.200]                               parallel_sendData(master, data)
[16:22:00.200]                             }
[16:22:00.200]                             return(sendCondition)
[16:22:00.200]                           }
[16:22:00.200]                         }
[16:22:00.200]                         frame <- frame + 1L
[16:22:00.200]                         envir <- sys.frame(frame)
[16:22:00.200]                       }
[16:22:00.200]                     }
[16:22:00.200]                     sendCondition <<- function(cond) NULL
[16:22:00.200]                   }
[16:22:00.200]                 })
[16:22:00.200]                 withCallingHandlers({
[16:22:00.200]                   {
[16:22:00.200]                     Sys.sleep(0.5)
[16:22:00.200]                     list(a = 1, b = 42L)
[16:22:00.200]                   }
[16:22:00.200]                 }, immediateCondition = function(cond) {
[16:22:00.200]                   sendCondition <- ...future.makeSendCondition()
[16:22:00.200]                   sendCondition(cond)
[16:22:00.200]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.200]                   {
[16:22:00.200]                     inherits <- base::inherits
[16:22:00.200]                     invokeRestart <- base::invokeRestart
[16:22:00.200]                     is.null <- base::is.null
[16:22:00.200]                     muffled <- FALSE
[16:22:00.200]                     if (inherits(cond, "message")) {
[16:22:00.200]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:00.200]                       if (muffled) 
[16:22:00.200]                         invokeRestart("muffleMessage")
[16:22:00.200]                     }
[16:22:00.200]                     else if (inherits(cond, "warning")) {
[16:22:00.200]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:00.200]                       if (muffled) 
[16:22:00.200]                         invokeRestart("muffleWarning")
[16:22:00.200]                     }
[16:22:00.200]                     else if (inherits(cond, "condition")) {
[16:22:00.200]                       if (!is.null(pattern)) {
[16:22:00.200]                         computeRestarts <- base::computeRestarts
[16:22:00.200]                         grepl <- base::grepl
[16:22:00.200]                         restarts <- computeRestarts(cond)
[16:22:00.200]                         for (restart in restarts) {
[16:22:00.200]                           name <- restart$name
[16:22:00.200]                           if (is.null(name)) 
[16:22:00.200]                             next
[16:22:00.200]                           if (!grepl(pattern, name)) 
[16:22:00.200]                             next
[16:22:00.200]                           invokeRestart(restart)
[16:22:00.200]                           muffled <- TRUE
[16:22:00.200]                           break
[16:22:00.200]                         }
[16:22:00.200]                       }
[16:22:00.200]                     }
[16:22:00.200]                     invisible(muffled)
[16:22:00.200]                   }
[16:22:00.200]                   muffleCondition(cond)
[16:22:00.200]                 })
[16:22:00.200]             }))
[16:22:00.200]             future::FutureResult(value = ...future.value$value, 
[16:22:00.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.200]                   ...future.rng), globalenv = if (FALSE) 
[16:22:00.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:00.200]                     ...future.globalenv.names))
[16:22:00.200]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:00.200]         }, condition = base::local({
[16:22:00.200]             c <- base::c
[16:22:00.200]             inherits <- base::inherits
[16:22:00.200]             invokeRestart <- base::invokeRestart
[16:22:00.200]             length <- base::length
[16:22:00.200]             list <- base::list
[16:22:00.200]             seq.int <- base::seq.int
[16:22:00.200]             signalCondition <- base::signalCondition
[16:22:00.200]             sys.calls <- base::sys.calls
[16:22:00.200]             `[[` <- base::`[[`
[16:22:00.200]             `+` <- base::`+`
[16:22:00.200]             `<<-` <- base::`<<-`
[16:22:00.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:00.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:00.200]                   3L)]
[16:22:00.200]             }
[16:22:00.200]             function(cond) {
[16:22:00.200]                 is_error <- inherits(cond, "error")
[16:22:00.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:00.200]                   NULL)
[16:22:00.200]                 if (is_error) {
[16:22:00.200]                   sessionInformation <- function() {
[16:22:00.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:00.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:00.200]                       search = base::search(), system = base::Sys.info())
[16:22:00.200]                   }
[16:22:00.200]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:00.200]                     cond$call), session = sessionInformation(), 
[16:22:00.200]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:00.200]                   signalCondition(cond)
[16:22:00.200]                 }
[16:22:00.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:00.200]                 "immediateCondition"))) {
[16:22:00.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:00.200]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:00.200]                   if (TRUE && !signal) {
[16:22:00.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.200]                     {
[16:22:00.200]                       inherits <- base::inherits
[16:22:00.200]                       invokeRestart <- base::invokeRestart
[16:22:00.200]                       is.null <- base::is.null
[16:22:00.200]                       muffled <- FALSE
[16:22:00.200]                       if (inherits(cond, "message")) {
[16:22:00.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.200]                         if (muffled) 
[16:22:00.200]                           invokeRestart("muffleMessage")
[16:22:00.200]                       }
[16:22:00.200]                       else if (inherits(cond, "warning")) {
[16:22:00.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.200]                         if (muffled) 
[16:22:00.200]                           invokeRestart("muffleWarning")
[16:22:00.200]                       }
[16:22:00.200]                       else if (inherits(cond, "condition")) {
[16:22:00.200]                         if (!is.null(pattern)) {
[16:22:00.200]                           computeRestarts <- base::computeRestarts
[16:22:00.200]                           grepl <- base::grepl
[16:22:00.200]                           restarts <- computeRestarts(cond)
[16:22:00.200]                           for (restart in restarts) {
[16:22:00.200]                             name <- restart$name
[16:22:00.200]                             if (is.null(name)) 
[16:22:00.200]                               next
[16:22:00.200]                             if (!grepl(pattern, name)) 
[16:22:00.200]                               next
[16:22:00.200]                             invokeRestart(restart)
[16:22:00.200]                             muffled <- TRUE
[16:22:00.200]                             break
[16:22:00.200]                           }
[16:22:00.200]                         }
[16:22:00.200]                       }
[16:22:00.200]                       invisible(muffled)
[16:22:00.200]                     }
[16:22:00.200]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.200]                   }
[16:22:00.200]                 }
[16:22:00.200]                 else {
[16:22:00.200]                   if (TRUE) {
[16:22:00.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.200]                     {
[16:22:00.200]                       inherits <- base::inherits
[16:22:00.200]                       invokeRestart <- base::invokeRestart
[16:22:00.200]                       is.null <- base::is.null
[16:22:00.200]                       muffled <- FALSE
[16:22:00.200]                       if (inherits(cond, "message")) {
[16:22:00.200]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.200]                         if (muffled) 
[16:22:00.200]                           invokeRestart("muffleMessage")
[16:22:00.200]                       }
[16:22:00.200]                       else if (inherits(cond, "warning")) {
[16:22:00.200]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.200]                         if (muffled) 
[16:22:00.200]                           invokeRestart("muffleWarning")
[16:22:00.200]                       }
[16:22:00.200]                       else if (inherits(cond, "condition")) {
[16:22:00.200]                         if (!is.null(pattern)) {
[16:22:00.200]                           computeRestarts <- base::computeRestarts
[16:22:00.200]                           grepl <- base::grepl
[16:22:00.200]                           restarts <- computeRestarts(cond)
[16:22:00.200]                           for (restart in restarts) {
[16:22:00.200]                             name <- restart$name
[16:22:00.200]                             if (is.null(name)) 
[16:22:00.200]                               next
[16:22:00.200]                             if (!grepl(pattern, name)) 
[16:22:00.200]                               next
[16:22:00.200]                             invokeRestart(restart)
[16:22:00.200]                             muffled <- TRUE
[16:22:00.200]                             break
[16:22:00.200]                           }
[16:22:00.200]                         }
[16:22:00.200]                       }
[16:22:00.200]                       invisible(muffled)
[16:22:00.200]                     }
[16:22:00.200]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.200]                   }
[16:22:00.200]                 }
[16:22:00.200]             }
[16:22:00.200]         }))
[16:22:00.200]     }, error = function(ex) {
[16:22:00.200]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:00.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.200]                 ...future.rng), started = ...future.startTime, 
[16:22:00.200]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:00.200]             version = "1.8"), class = "FutureResult")
[16:22:00.200]     }, finally = {
[16:22:00.200]         if (!identical(...future.workdir, getwd())) 
[16:22:00.200]             setwd(...future.workdir)
[16:22:00.200]         {
[16:22:00.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:00.200]                 ...future.oldOptions$nwarnings <- NULL
[16:22:00.200]             }
[16:22:00.200]             base::options(...future.oldOptions)
[16:22:00.200]             if (.Platform$OS.type == "windows") {
[16:22:00.200]                 old_names <- names(...future.oldEnvVars)
[16:22:00.200]                 envs <- base::Sys.getenv()
[16:22:00.200]                 names <- names(envs)
[16:22:00.200]                 common <- intersect(names, old_names)
[16:22:00.200]                 added <- setdiff(names, old_names)
[16:22:00.200]                 removed <- setdiff(old_names, names)
[16:22:00.200]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:00.200]                   envs[common]]
[16:22:00.200]                 NAMES <- toupper(changed)
[16:22:00.200]                 args <- list()
[16:22:00.200]                 for (kk in seq_along(NAMES)) {
[16:22:00.200]                   name <- changed[[kk]]
[16:22:00.200]                   NAME <- NAMES[[kk]]
[16:22:00.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.200]                     next
[16:22:00.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.200]                 }
[16:22:00.200]                 NAMES <- toupper(added)
[16:22:00.200]                 for (kk in seq_along(NAMES)) {
[16:22:00.200]                   name <- added[[kk]]
[16:22:00.200]                   NAME <- NAMES[[kk]]
[16:22:00.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.200]                     next
[16:22:00.200]                   args[[name]] <- ""
[16:22:00.200]                 }
[16:22:00.200]                 NAMES <- toupper(removed)
[16:22:00.200]                 for (kk in seq_along(NAMES)) {
[16:22:00.200]                   name <- removed[[kk]]
[16:22:00.200]                   NAME <- NAMES[[kk]]
[16:22:00.200]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.200]                     next
[16:22:00.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.200]                 }
[16:22:00.200]                 if (length(args) > 0) 
[16:22:00.200]                   base::do.call(base::Sys.setenv, args = args)
[16:22:00.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:00.200]             }
[16:22:00.200]             else {
[16:22:00.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:00.200]             }
[16:22:00.200]             {
[16:22:00.200]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:00.200]                   0L) {
[16:22:00.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:00.200]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:00.200]                   base::options(opts)
[16:22:00.200]                 }
[16:22:00.200]                 {
[16:22:00.200]                   {
[16:22:00.200]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:00.200]                     NULL
[16:22:00.200]                   }
[16:22:00.200]                   options(future.plan = NULL)
[16:22:00.200]                   if (is.na(NA_character_)) 
[16:22:00.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:00.200]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:00.200]                     .init = FALSE)
[16:22:00.200]                 }
[16:22:00.200]             }
[16:22:00.200]         }
[16:22:00.200]     })
[16:22:00.200]     if (TRUE) {
[16:22:00.200]         base::sink(type = "output", split = FALSE)
[16:22:00.200]         if (TRUE) {
[16:22:00.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:00.200]         }
[16:22:00.200]         else {
[16:22:00.200]             ...future.result["stdout"] <- base::list(NULL)
[16:22:00.200]         }
[16:22:00.200]         base::close(...future.stdout)
[16:22:00.200]         ...future.stdout <- NULL
[16:22:00.200]     }
[16:22:00.200]     ...future.result$conditions <- ...future.conditions
[16:22:00.200]     ...future.result$finished <- base::Sys.time()
[16:22:00.200]     ...future.result
[16:22:00.200] }
[16:22:00.202] MultisessionFuture started
[16:22:00.202] - Launch lazy future ... done
[16:22:00.203] run() for ‘MultisessionFuture’ ... done
[16:22:00.705] receiveMessageFromWorker() for ClusterFuture ...
[16:22:00.705] - Validating connection of MultisessionFuture
[16:22:00.705] - received message: FutureResult
[16:22:00.705] - Received FutureResult
[16:22:00.706] - Erased future from FutureRegistry
[16:22:00.706] result() for ClusterFuture ...
[16:22:00.706] - result already collected: FutureResult
[16:22:00.706] result() for ClusterFuture ... done
[16:22:00.706] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:00.706] A MultisessionFuture was resolved (result was not collected)
[16:22:00.706] getGlobalsAndPackages() ...
[16:22:00.706] Searching for globals...
[16:22:00.707] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:00.708] Searching for globals ... DONE
[16:22:00.708] Resolving globals: FALSE
[16:22:00.708] 
[16:22:00.708] 
[16:22:00.708] getGlobalsAndPackages() ... DONE
[16:22:00.708] run() for ‘Future’ ...
[16:22:00.709] - state: ‘created’
[16:22:00.709] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:00.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:00.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:00.723]   - Field: ‘node’
[16:22:00.723]   - Field: ‘label’
[16:22:00.723]   - Field: ‘local’
[16:22:00.724]   - Field: ‘owner’
[16:22:00.724]   - Field: ‘envir’
[16:22:00.724]   - Field: ‘workers’
[16:22:00.724]   - Field: ‘packages’
[16:22:00.724]   - Field: ‘gc’
[16:22:00.724]   - Field: ‘conditions’
[16:22:00.724]   - Field: ‘persistent’
[16:22:00.724]   - Field: ‘expr’
[16:22:00.724]   - Field: ‘uuid’
[16:22:00.724]   - Field: ‘seed’
[16:22:00.725]   - Field: ‘version’
[16:22:00.725]   - Field: ‘result’
[16:22:00.725]   - Field: ‘asynchronous’
[16:22:00.725]   - Field: ‘calls’
[16:22:00.725]   - Field: ‘globals’
[16:22:00.725]   - Field: ‘stdout’
[16:22:00.725]   - Field: ‘earlySignal’
[16:22:00.725]   - Field: ‘lazy’
[16:22:00.725]   - Field: ‘state’
[16:22:00.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:00.725] - Launch lazy future ...
[16:22:00.726] Packages needed by the future expression (n = 0): <none>
[16:22:00.726] Packages needed by future strategies (n = 0): <none>
[16:22:00.726] {
[16:22:00.726]     {
[16:22:00.726]         {
[16:22:00.726]             ...future.startTime <- base::Sys.time()
[16:22:00.726]             {
[16:22:00.726]                 {
[16:22:00.726]                   {
[16:22:00.726]                     {
[16:22:00.726]                       base::local({
[16:22:00.726]                         has_future <- base::requireNamespace("future", 
[16:22:00.726]                           quietly = TRUE)
[16:22:00.726]                         if (has_future) {
[16:22:00.726]                           ns <- base::getNamespace("future")
[16:22:00.726]                           version <- ns[[".package"]][["version"]]
[16:22:00.726]                           if (is.null(version)) 
[16:22:00.726]                             version <- utils::packageVersion("future")
[16:22:00.726]                         }
[16:22:00.726]                         else {
[16:22:00.726]                           version <- NULL
[16:22:00.726]                         }
[16:22:00.726]                         if (!has_future || version < "1.8.0") {
[16:22:00.726]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:00.726]                             "", base::R.version$version.string), 
[16:22:00.726]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:00.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:00.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:00.726]                               "release", "version")], collapse = " "), 
[16:22:00.726]                             hostname = base::Sys.info()[["nodename"]])
[16:22:00.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:00.726]                             info)
[16:22:00.726]                           info <- base::paste(info, collapse = "; ")
[16:22:00.726]                           if (!has_future) {
[16:22:00.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:00.726]                               info)
[16:22:00.726]                           }
[16:22:00.726]                           else {
[16:22:00.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:00.726]                               info, version)
[16:22:00.726]                           }
[16:22:00.726]                           base::stop(msg)
[16:22:00.726]                         }
[16:22:00.726]                       })
[16:22:00.726]                     }
[16:22:00.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:00.726]                     base::options(mc.cores = 1L)
[16:22:00.726]                   }
[16:22:00.726]                   ...future.strategy.old <- future::plan("list")
[16:22:00.726]                   options(future.plan = NULL)
[16:22:00.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:00.726]                 }
[16:22:00.726]                 ...future.workdir <- getwd()
[16:22:00.726]             }
[16:22:00.726]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:00.726]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:00.726]         }
[16:22:00.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:00.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:00.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:00.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:00.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:00.726]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:00.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:00.726]             base::names(...future.oldOptions))
[16:22:00.726]     }
[16:22:00.726]     if (FALSE) {
[16:22:00.726]     }
[16:22:00.726]     else {
[16:22:00.726]         if (TRUE) {
[16:22:00.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:00.726]                 open = "w")
[16:22:00.726]         }
[16:22:00.726]         else {
[16:22:00.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:00.726]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:00.726]         }
[16:22:00.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:00.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:00.726]             base::sink(type = "output", split = FALSE)
[16:22:00.726]             base::close(...future.stdout)
[16:22:00.726]         }, add = TRUE)
[16:22:00.726]     }
[16:22:00.726]     ...future.frame <- base::sys.nframe()
[16:22:00.726]     ...future.conditions <- base::list()
[16:22:00.726]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:00.726]     if (FALSE) {
[16:22:00.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:00.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:00.726]     }
[16:22:00.726]     ...future.result <- base::tryCatch({
[16:22:00.726]         base::withCallingHandlers({
[16:22:00.726]             ...future.value <- base::withVisible(base::local({
[16:22:00.726]                 ...future.makeSendCondition <- base::local({
[16:22:00.726]                   sendCondition <- NULL
[16:22:00.726]                   function(frame = 1L) {
[16:22:00.726]                     if (is.function(sendCondition)) 
[16:22:00.726]                       return(sendCondition)
[16:22:00.726]                     ns <- getNamespace("parallel")
[16:22:00.726]                     if (exists("sendData", mode = "function", 
[16:22:00.726]                       envir = ns)) {
[16:22:00.726]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:00.726]                         envir = ns)
[16:22:00.726]                       envir <- sys.frame(frame)
[16:22:00.726]                       master <- NULL
[16:22:00.726]                       while (!identical(envir, .GlobalEnv) && 
[16:22:00.726]                         !identical(envir, emptyenv())) {
[16:22:00.726]                         if (exists("master", mode = "list", envir = envir, 
[16:22:00.726]                           inherits = FALSE)) {
[16:22:00.726]                           master <- get("master", mode = "list", 
[16:22:00.726]                             envir = envir, inherits = FALSE)
[16:22:00.726]                           if (inherits(master, c("SOCKnode", 
[16:22:00.726]                             "SOCK0node"))) {
[16:22:00.726]                             sendCondition <<- function(cond) {
[16:22:00.726]                               data <- list(type = "VALUE", value = cond, 
[16:22:00.726]                                 success = TRUE)
[16:22:00.726]                               parallel_sendData(master, data)
[16:22:00.726]                             }
[16:22:00.726]                             return(sendCondition)
[16:22:00.726]                           }
[16:22:00.726]                         }
[16:22:00.726]                         frame <- frame + 1L
[16:22:00.726]                         envir <- sys.frame(frame)
[16:22:00.726]                       }
[16:22:00.726]                     }
[16:22:00.726]                     sendCondition <<- function(cond) NULL
[16:22:00.726]                   }
[16:22:00.726]                 })
[16:22:00.726]                 withCallingHandlers({
[16:22:00.726]                   {
[16:22:00.726]                     Sys.sleep(0.5)
[16:22:00.726]                     list(a = 1, b = 42L)
[16:22:00.726]                   }
[16:22:00.726]                 }, immediateCondition = function(cond) {
[16:22:00.726]                   sendCondition <- ...future.makeSendCondition()
[16:22:00.726]                   sendCondition(cond)
[16:22:00.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.726]                   {
[16:22:00.726]                     inherits <- base::inherits
[16:22:00.726]                     invokeRestart <- base::invokeRestart
[16:22:00.726]                     is.null <- base::is.null
[16:22:00.726]                     muffled <- FALSE
[16:22:00.726]                     if (inherits(cond, "message")) {
[16:22:00.726]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:00.726]                       if (muffled) 
[16:22:00.726]                         invokeRestart("muffleMessage")
[16:22:00.726]                     }
[16:22:00.726]                     else if (inherits(cond, "warning")) {
[16:22:00.726]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:00.726]                       if (muffled) 
[16:22:00.726]                         invokeRestart("muffleWarning")
[16:22:00.726]                     }
[16:22:00.726]                     else if (inherits(cond, "condition")) {
[16:22:00.726]                       if (!is.null(pattern)) {
[16:22:00.726]                         computeRestarts <- base::computeRestarts
[16:22:00.726]                         grepl <- base::grepl
[16:22:00.726]                         restarts <- computeRestarts(cond)
[16:22:00.726]                         for (restart in restarts) {
[16:22:00.726]                           name <- restart$name
[16:22:00.726]                           if (is.null(name)) 
[16:22:00.726]                             next
[16:22:00.726]                           if (!grepl(pattern, name)) 
[16:22:00.726]                             next
[16:22:00.726]                           invokeRestart(restart)
[16:22:00.726]                           muffled <- TRUE
[16:22:00.726]                           break
[16:22:00.726]                         }
[16:22:00.726]                       }
[16:22:00.726]                     }
[16:22:00.726]                     invisible(muffled)
[16:22:00.726]                   }
[16:22:00.726]                   muffleCondition(cond)
[16:22:00.726]                 })
[16:22:00.726]             }))
[16:22:00.726]             future::FutureResult(value = ...future.value$value, 
[16:22:00.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.726]                   ...future.rng), globalenv = if (FALSE) 
[16:22:00.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:00.726]                     ...future.globalenv.names))
[16:22:00.726]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:00.726]         }, condition = base::local({
[16:22:00.726]             c <- base::c
[16:22:00.726]             inherits <- base::inherits
[16:22:00.726]             invokeRestart <- base::invokeRestart
[16:22:00.726]             length <- base::length
[16:22:00.726]             list <- base::list
[16:22:00.726]             seq.int <- base::seq.int
[16:22:00.726]             signalCondition <- base::signalCondition
[16:22:00.726]             sys.calls <- base::sys.calls
[16:22:00.726]             `[[` <- base::`[[`
[16:22:00.726]             `+` <- base::`+`
[16:22:00.726]             `<<-` <- base::`<<-`
[16:22:00.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:00.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:00.726]                   3L)]
[16:22:00.726]             }
[16:22:00.726]             function(cond) {
[16:22:00.726]                 is_error <- inherits(cond, "error")
[16:22:00.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:00.726]                   NULL)
[16:22:00.726]                 if (is_error) {
[16:22:00.726]                   sessionInformation <- function() {
[16:22:00.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:00.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:00.726]                       search = base::search(), system = base::Sys.info())
[16:22:00.726]                   }
[16:22:00.726]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:00.726]                     cond$call), session = sessionInformation(), 
[16:22:00.726]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:00.726]                   signalCondition(cond)
[16:22:00.726]                 }
[16:22:00.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:00.726]                 "immediateCondition"))) {
[16:22:00.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:00.726]                   ...future.conditions[[length(...future.conditions) + 
[16:22:00.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:00.726]                   if (TRUE && !signal) {
[16:22:00.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.726]                     {
[16:22:00.726]                       inherits <- base::inherits
[16:22:00.726]                       invokeRestart <- base::invokeRestart
[16:22:00.726]                       is.null <- base::is.null
[16:22:00.726]                       muffled <- FALSE
[16:22:00.726]                       if (inherits(cond, "message")) {
[16:22:00.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.726]                         if (muffled) 
[16:22:00.726]                           invokeRestart("muffleMessage")
[16:22:00.726]                       }
[16:22:00.726]                       else if (inherits(cond, "warning")) {
[16:22:00.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.726]                         if (muffled) 
[16:22:00.726]                           invokeRestart("muffleWarning")
[16:22:00.726]                       }
[16:22:00.726]                       else if (inherits(cond, "condition")) {
[16:22:00.726]                         if (!is.null(pattern)) {
[16:22:00.726]                           computeRestarts <- base::computeRestarts
[16:22:00.726]                           grepl <- base::grepl
[16:22:00.726]                           restarts <- computeRestarts(cond)
[16:22:00.726]                           for (restart in restarts) {
[16:22:00.726]                             name <- restart$name
[16:22:00.726]                             if (is.null(name)) 
[16:22:00.726]                               next
[16:22:00.726]                             if (!grepl(pattern, name)) 
[16:22:00.726]                               next
[16:22:00.726]                             invokeRestart(restart)
[16:22:00.726]                             muffled <- TRUE
[16:22:00.726]                             break
[16:22:00.726]                           }
[16:22:00.726]                         }
[16:22:00.726]                       }
[16:22:00.726]                       invisible(muffled)
[16:22:00.726]                     }
[16:22:00.726]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.726]                   }
[16:22:00.726]                 }
[16:22:00.726]                 else {
[16:22:00.726]                   if (TRUE) {
[16:22:00.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:00.726]                     {
[16:22:00.726]                       inherits <- base::inherits
[16:22:00.726]                       invokeRestart <- base::invokeRestart
[16:22:00.726]                       is.null <- base::is.null
[16:22:00.726]                       muffled <- FALSE
[16:22:00.726]                       if (inherits(cond, "message")) {
[16:22:00.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:00.726]                         if (muffled) 
[16:22:00.726]                           invokeRestart("muffleMessage")
[16:22:00.726]                       }
[16:22:00.726]                       else if (inherits(cond, "warning")) {
[16:22:00.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:00.726]                         if (muffled) 
[16:22:00.726]                           invokeRestart("muffleWarning")
[16:22:00.726]                       }
[16:22:00.726]                       else if (inherits(cond, "condition")) {
[16:22:00.726]                         if (!is.null(pattern)) {
[16:22:00.726]                           computeRestarts <- base::computeRestarts
[16:22:00.726]                           grepl <- base::grepl
[16:22:00.726]                           restarts <- computeRestarts(cond)
[16:22:00.726]                           for (restart in restarts) {
[16:22:00.726]                             name <- restart$name
[16:22:00.726]                             if (is.null(name)) 
[16:22:00.726]                               next
[16:22:00.726]                             if (!grepl(pattern, name)) 
[16:22:00.726]                               next
[16:22:00.726]                             invokeRestart(restart)
[16:22:00.726]                             muffled <- TRUE
[16:22:00.726]                             break
[16:22:00.726]                           }
[16:22:00.726]                         }
[16:22:00.726]                       }
[16:22:00.726]                       invisible(muffled)
[16:22:00.726]                     }
[16:22:00.726]                     muffleCondition(cond, pattern = "^muffle")
[16:22:00.726]                   }
[16:22:00.726]                 }
[16:22:00.726]             }
[16:22:00.726]         }))
[16:22:00.726]     }, error = function(ex) {
[16:22:00.726]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:00.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:00.726]                 ...future.rng), started = ...future.startTime, 
[16:22:00.726]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:00.726]             version = "1.8"), class = "FutureResult")
[16:22:00.726]     }, finally = {
[16:22:00.726]         if (!identical(...future.workdir, getwd())) 
[16:22:00.726]             setwd(...future.workdir)
[16:22:00.726]         {
[16:22:00.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:00.726]                 ...future.oldOptions$nwarnings <- NULL
[16:22:00.726]             }
[16:22:00.726]             base::options(...future.oldOptions)
[16:22:00.726]             if (.Platform$OS.type == "windows") {
[16:22:00.726]                 old_names <- names(...future.oldEnvVars)
[16:22:00.726]                 envs <- base::Sys.getenv()
[16:22:00.726]                 names <- names(envs)
[16:22:00.726]                 common <- intersect(names, old_names)
[16:22:00.726]                 added <- setdiff(names, old_names)
[16:22:00.726]                 removed <- setdiff(old_names, names)
[16:22:00.726]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:00.726]                   envs[common]]
[16:22:00.726]                 NAMES <- toupper(changed)
[16:22:00.726]                 args <- list()
[16:22:00.726]                 for (kk in seq_along(NAMES)) {
[16:22:00.726]                   name <- changed[[kk]]
[16:22:00.726]                   NAME <- NAMES[[kk]]
[16:22:00.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.726]                     next
[16:22:00.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.726]                 }
[16:22:00.726]                 NAMES <- toupper(added)
[16:22:00.726]                 for (kk in seq_along(NAMES)) {
[16:22:00.726]                   name <- added[[kk]]
[16:22:00.726]                   NAME <- NAMES[[kk]]
[16:22:00.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.726]                     next
[16:22:00.726]                   args[[name]] <- ""
[16:22:00.726]                 }
[16:22:00.726]                 NAMES <- toupper(removed)
[16:22:00.726]                 for (kk in seq_along(NAMES)) {
[16:22:00.726]                   name <- removed[[kk]]
[16:22:00.726]                   NAME <- NAMES[[kk]]
[16:22:00.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:00.726]                     next
[16:22:00.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:00.726]                 }
[16:22:00.726]                 if (length(args) > 0) 
[16:22:00.726]                   base::do.call(base::Sys.setenv, args = args)
[16:22:00.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:00.726]             }
[16:22:00.726]             else {
[16:22:00.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:00.726]             }
[16:22:00.726]             {
[16:22:00.726]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:00.726]                   0L) {
[16:22:00.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:00.726]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:00.726]                   base::options(opts)
[16:22:00.726]                 }
[16:22:00.726]                 {
[16:22:00.726]                   {
[16:22:00.726]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:00.726]                     NULL
[16:22:00.726]                   }
[16:22:00.726]                   options(future.plan = NULL)
[16:22:00.726]                   if (is.na(NA_character_)) 
[16:22:00.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:00.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:00.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:00.726]                     .init = FALSE)
[16:22:00.726]                 }
[16:22:00.726]             }
[16:22:00.726]         }
[16:22:00.726]     })
[16:22:00.726]     if (TRUE) {
[16:22:00.726]         base::sink(type = "output", split = FALSE)
[16:22:00.726]         if (TRUE) {
[16:22:00.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:00.726]         }
[16:22:00.726]         else {
[16:22:00.726]             ...future.result["stdout"] <- base::list(NULL)
[16:22:00.726]         }
[16:22:00.726]         base::close(...future.stdout)
[16:22:00.726]         ...future.stdout <- NULL
[16:22:00.726]     }
[16:22:00.726]     ...future.result$conditions <- ...future.conditions
[16:22:00.726]     ...future.result$finished <- base::Sys.time()
[16:22:00.726]     ...future.result
[16:22:00.726] }
[16:22:00.729] MultisessionFuture started
[16:22:00.730] - Launch lazy future ... done
[16:22:00.730] run() for ‘MultisessionFuture’ ... done
[16:22:01.232] receiveMessageFromWorker() for ClusterFuture ...
[16:22:01.233] - Validating connection of MultisessionFuture
[16:22:01.233] - received message: FutureResult
[16:22:01.233] - Received FutureResult
[16:22:01.233] - Erased future from FutureRegistry
[16:22:01.233] result() for ClusterFuture ...
[16:22:01.233] - result already collected: FutureResult
[16:22:01.233] result() for ClusterFuture ... done
[16:22:01.233] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:01.234] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:22:01.234] getGlobalsAndPackages() ...
[16:22:01.234] Searching for globals...
[16:22:01.235] - globals found: [2] ‘list’, ‘stop’
[16:22:01.235] Searching for globals ... DONE
[16:22:01.235] Resolving globals: FALSE
[16:22:01.235] 
[16:22:01.235] 
[16:22:01.235] getGlobalsAndPackages() ... DONE
[16:22:01.236] run() for ‘Future’ ...
[16:22:01.236] - state: ‘created’
[16:22:01.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:01.250] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:01.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:01.250]   - Field: ‘node’
[16:22:01.251]   - Field: ‘label’
[16:22:01.251]   - Field: ‘local’
[16:22:01.251]   - Field: ‘owner’
[16:22:01.251]   - Field: ‘envir’
[16:22:01.251]   - Field: ‘workers’
[16:22:01.251]   - Field: ‘packages’
[16:22:01.251]   - Field: ‘gc’
[16:22:01.251]   - Field: ‘conditions’
[16:22:01.251]   - Field: ‘persistent’
[16:22:01.251]   - Field: ‘expr’
[16:22:01.252]   - Field: ‘uuid’
[16:22:01.252]   - Field: ‘seed’
[16:22:01.252]   - Field: ‘version’
[16:22:01.252]   - Field: ‘result’
[16:22:01.252]   - Field: ‘asynchronous’
[16:22:01.252]   - Field: ‘calls’
[16:22:01.252]   - Field: ‘globals’
[16:22:01.252]   - Field: ‘stdout’
[16:22:01.252]   - Field: ‘earlySignal’
[16:22:01.252]   - Field: ‘lazy’
[16:22:01.252]   - Field: ‘state’
[16:22:01.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:01.253] - Launch lazy future ...
[16:22:01.253] Packages needed by the future expression (n = 0): <none>
[16:22:01.253] Packages needed by future strategies (n = 0): <none>
[16:22:01.253] {
[16:22:01.253]     {
[16:22:01.253]         {
[16:22:01.253]             ...future.startTime <- base::Sys.time()
[16:22:01.253]             {
[16:22:01.253]                 {
[16:22:01.253]                   {
[16:22:01.253]                     {
[16:22:01.253]                       base::local({
[16:22:01.253]                         has_future <- base::requireNamespace("future", 
[16:22:01.253]                           quietly = TRUE)
[16:22:01.253]                         if (has_future) {
[16:22:01.253]                           ns <- base::getNamespace("future")
[16:22:01.253]                           version <- ns[[".package"]][["version"]]
[16:22:01.253]                           if (is.null(version)) 
[16:22:01.253]                             version <- utils::packageVersion("future")
[16:22:01.253]                         }
[16:22:01.253]                         else {
[16:22:01.253]                           version <- NULL
[16:22:01.253]                         }
[16:22:01.253]                         if (!has_future || version < "1.8.0") {
[16:22:01.253]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:01.253]                             "", base::R.version$version.string), 
[16:22:01.253]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:01.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:01.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:01.253]                               "release", "version")], collapse = " "), 
[16:22:01.253]                             hostname = base::Sys.info()[["nodename"]])
[16:22:01.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:01.253]                             info)
[16:22:01.253]                           info <- base::paste(info, collapse = "; ")
[16:22:01.253]                           if (!has_future) {
[16:22:01.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:01.253]                               info)
[16:22:01.253]                           }
[16:22:01.253]                           else {
[16:22:01.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:01.253]                               info, version)
[16:22:01.253]                           }
[16:22:01.253]                           base::stop(msg)
[16:22:01.253]                         }
[16:22:01.253]                       })
[16:22:01.253]                     }
[16:22:01.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:01.253]                     base::options(mc.cores = 1L)
[16:22:01.253]                   }
[16:22:01.253]                   ...future.strategy.old <- future::plan("list")
[16:22:01.253]                   options(future.plan = NULL)
[16:22:01.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:01.253]                 }
[16:22:01.253]                 ...future.workdir <- getwd()
[16:22:01.253]             }
[16:22:01.253]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:01.253]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:01.253]         }
[16:22:01.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:01.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:01.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:01.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:01.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:01.253]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:01.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:01.253]             base::names(...future.oldOptions))
[16:22:01.253]     }
[16:22:01.253]     if (FALSE) {
[16:22:01.253]     }
[16:22:01.253]     else {
[16:22:01.253]         if (TRUE) {
[16:22:01.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:01.253]                 open = "w")
[16:22:01.253]         }
[16:22:01.253]         else {
[16:22:01.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:01.253]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:01.253]         }
[16:22:01.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:01.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:01.253]             base::sink(type = "output", split = FALSE)
[16:22:01.253]             base::close(...future.stdout)
[16:22:01.253]         }, add = TRUE)
[16:22:01.253]     }
[16:22:01.253]     ...future.frame <- base::sys.nframe()
[16:22:01.253]     ...future.conditions <- base::list()
[16:22:01.253]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:01.253]     if (FALSE) {
[16:22:01.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:01.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:01.253]     }
[16:22:01.253]     ...future.result <- base::tryCatch({
[16:22:01.253]         base::withCallingHandlers({
[16:22:01.253]             ...future.value <- base::withVisible(base::local({
[16:22:01.253]                 ...future.makeSendCondition <- base::local({
[16:22:01.253]                   sendCondition <- NULL
[16:22:01.253]                   function(frame = 1L) {
[16:22:01.253]                     if (is.function(sendCondition)) 
[16:22:01.253]                       return(sendCondition)
[16:22:01.253]                     ns <- getNamespace("parallel")
[16:22:01.253]                     if (exists("sendData", mode = "function", 
[16:22:01.253]                       envir = ns)) {
[16:22:01.253]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:01.253]                         envir = ns)
[16:22:01.253]                       envir <- sys.frame(frame)
[16:22:01.253]                       master <- NULL
[16:22:01.253]                       while (!identical(envir, .GlobalEnv) && 
[16:22:01.253]                         !identical(envir, emptyenv())) {
[16:22:01.253]                         if (exists("master", mode = "list", envir = envir, 
[16:22:01.253]                           inherits = FALSE)) {
[16:22:01.253]                           master <- get("master", mode = "list", 
[16:22:01.253]                             envir = envir, inherits = FALSE)
[16:22:01.253]                           if (inherits(master, c("SOCKnode", 
[16:22:01.253]                             "SOCK0node"))) {
[16:22:01.253]                             sendCondition <<- function(cond) {
[16:22:01.253]                               data <- list(type = "VALUE", value = cond, 
[16:22:01.253]                                 success = TRUE)
[16:22:01.253]                               parallel_sendData(master, data)
[16:22:01.253]                             }
[16:22:01.253]                             return(sendCondition)
[16:22:01.253]                           }
[16:22:01.253]                         }
[16:22:01.253]                         frame <- frame + 1L
[16:22:01.253]                         envir <- sys.frame(frame)
[16:22:01.253]                       }
[16:22:01.253]                     }
[16:22:01.253]                     sendCondition <<- function(cond) NULL
[16:22:01.253]                   }
[16:22:01.253]                 })
[16:22:01.253]                 withCallingHandlers({
[16:22:01.253]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:01.253]                 }, immediateCondition = function(cond) {
[16:22:01.253]                   sendCondition <- ...future.makeSendCondition()
[16:22:01.253]                   sendCondition(cond)
[16:22:01.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.253]                   {
[16:22:01.253]                     inherits <- base::inherits
[16:22:01.253]                     invokeRestart <- base::invokeRestart
[16:22:01.253]                     is.null <- base::is.null
[16:22:01.253]                     muffled <- FALSE
[16:22:01.253]                     if (inherits(cond, "message")) {
[16:22:01.253]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:01.253]                       if (muffled) 
[16:22:01.253]                         invokeRestart("muffleMessage")
[16:22:01.253]                     }
[16:22:01.253]                     else if (inherits(cond, "warning")) {
[16:22:01.253]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:01.253]                       if (muffled) 
[16:22:01.253]                         invokeRestart("muffleWarning")
[16:22:01.253]                     }
[16:22:01.253]                     else if (inherits(cond, "condition")) {
[16:22:01.253]                       if (!is.null(pattern)) {
[16:22:01.253]                         computeRestarts <- base::computeRestarts
[16:22:01.253]                         grepl <- base::grepl
[16:22:01.253]                         restarts <- computeRestarts(cond)
[16:22:01.253]                         for (restart in restarts) {
[16:22:01.253]                           name <- restart$name
[16:22:01.253]                           if (is.null(name)) 
[16:22:01.253]                             next
[16:22:01.253]                           if (!grepl(pattern, name)) 
[16:22:01.253]                             next
[16:22:01.253]                           invokeRestart(restart)
[16:22:01.253]                           muffled <- TRUE
[16:22:01.253]                           break
[16:22:01.253]                         }
[16:22:01.253]                       }
[16:22:01.253]                     }
[16:22:01.253]                     invisible(muffled)
[16:22:01.253]                   }
[16:22:01.253]                   muffleCondition(cond)
[16:22:01.253]                 })
[16:22:01.253]             }))
[16:22:01.253]             future::FutureResult(value = ...future.value$value, 
[16:22:01.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.253]                   ...future.rng), globalenv = if (FALSE) 
[16:22:01.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:01.253]                     ...future.globalenv.names))
[16:22:01.253]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:01.253]         }, condition = base::local({
[16:22:01.253]             c <- base::c
[16:22:01.253]             inherits <- base::inherits
[16:22:01.253]             invokeRestart <- base::invokeRestart
[16:22:01.253]             length <- base::length
[16:22:01.253]             list <- base::list
[16:22:01.253]             seq.int <- base::seq.int
[16:22:01.253]             signalCondition <- base::signalCondition
[16:22:01.253]             sys.calls <- base::sys.calls
[16:22:01.253]             `[[` <- base::`[[`
[16:22:01.253]             `+` <- base::`+`
[16:22:01.253]             `<<-` <- base::`<<-`
[16:22:01.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:01.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:01.253]                   3L)]
[16:22:01.253]             }
[16:22:01.253]             function(cond) {
[16:22:01.253]                 is_error <- inherits(cond, "error")
[16:22:01.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:01.253]                   NULL)
[16:22:01.253]                 if (is_error) {
[16:22:01.253]                   sessionInformation <- function() {
[16:22:01.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:01.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:01.253]                       search = base::search(), system = base::Sys.info())
[16:22:01.253]                   }
[16:22:01.253]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:01.253]                     cond$call), session = sessionInformation(), 
[16:22:01.253]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:01.253]                   signalCondition(cond)
[16:22:01.253]                 }
[16:22:01.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:01.253]                 "immediateCondition"))) {
[16:22:01.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:01.253]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:01.253]                   if (TRUE && !signal) {
[16:22:01.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.253]                     {
[16:22:01.253]                       inherits <- base::inherits
[16:22:01.253]                       invokeRestart <- base::invokeRestart
[16:22:01.253]                       is.null <- base::is.null
[16:22:01.253]                       muffled <- FALSE
[16:22:01.253]                       if (inherits(cond, "message")) {
[16:22:01.253]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.253]                         if (muffled) 
[16:22:01.253]                           invokeRestart("muffleMessage")
[16:22:01.253]                       }
[16:22:01.253]                       else if (inherits(cond, "warning")) {
[16:22:01.253]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.253]                         if (muffled) 
[16:22:01.253]                           invokeRestart("muffleWarning")
[16:22:01.253]                       }
[16:22:01.253]                       else if (inherits(cond, "condition")) {
[16:22:01.253]                         if (!is.null(pattern)) {
[16:22:01.253]                           computeRestarts <- base::computeRestarts
[16:22:01.253]                           grepl <- base::grepl
[16:22:01.253]                           restarts <- computeRestarts(cond)
[16:22:01.253]                           for (restart in restarts) {
[16:22:01.253]                             name <- restart$name
[16:22:01.253]                             if (is.null(name)) 
[16:22:01.253]                               next
[16:22:01.253]                             if (!grepl(pattern, name)) 
[16:22:01.253]                               next
[16:22:01.253]                             invokeRestart(restart)
[16:22:01.253]                             muffled <- TRUE
[16:22:01.253]                             break
[16:22:01.253]                           }
[16:22:01.253]                         }
[16:22:01.253]                       }
[16:22:01.253]                       invisible(muffled)
[16:22:01.253]                     }
[16:22:01.253]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.253]                   }
[16:22:01.253]                 }
[16:22:01.253]                 else {
[16:22:01.253]                   if (TRUE) {
[16:22:01.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.253]                     {
[16:22:01.253]                       inherits <- base::inherits
[16:22:01.253]                       invokeRestart <- base::invokeRestart
[16:22:01.253]                       is.null <- base::is.null
[16:22:01.253]                       muffled <- FALSE
[16:22:01.253]                       if (inherits(cond, "message")) {
[16:22:01.253]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.253]                         if (muffled) 
[16:22:01.253]                           invokeRestart("muffleMessage")
[16:22:01.253]                       }
[16:22:01.253]                       else if (inherits(cond, "warning")) {
[16:22:01.253]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.253]                         if (muffled) 
[16:22:01.253]                           invokeRestart("muffleWarning")
[16:22:01.253]                       }
[16:22:01.253]                       else if (inherits(cond, "condition")) {
[16:22:01.253]                         if (!is.null(pattern)) {
[16:22:01.253]                           computeRestarts <- base::computeRestarts
[16:22:01.253]                           grepl <- base::grepl
[16:22:01.253]                           restarts <- computeRestarts(cond)
[16:22:01.253]                           for (restart in restarts) {
[16:22:01.253]                             name <- restart$name
[16:22:01.253]                             if (is.null(name)) 
[16:22:01.253]                               next
[16:22:01.253]                             if (!grepl(pattern, name)) 
[16:22:01.253]                               next
[16:22:01.253]                             invokeRestart(restart)
[16:22:01.253]                             muffled <- TRUE
[16:22:01.253]                             break
[16:22:01.253]                           }
[16:22:01.253]                         }
[16:22:01.253]                       }
[16:22:01.253]                       invisible(muffled)
[16:22:01.253]                     }
[16:22:01.253]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.253]                   }
[16:22:01.253]                 }
[16:22:01.253]             }
[16:22:01.253]         }))
[16:22:01.253]     }, error = function(ex) {
[16:22:01.253]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:01.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.253]                 ...future.rng), started = ...future.startTime, 
[16:22:01.253]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:01.253]             version = "1.8"), class = "FutureResult")
[16:22:01.253]     }, finally = {
[16:22:01.253]         if (!identical(...future.workdir, getwd())) 
[16:22:01.253]             setwd(...future.workdir)
[16:22:01.253]         {
[16:22:01.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:01.253]                 ...future.oldOptions$nwarnings <- NULL
[16:22:01.253]             }
[16:22:01.253]             base::options(...future.oldOptions)
[16:22:01.253]             if (.Platform$OS.type == "windows") {
[16:22:01.253]                 old_names <- names(...future.oldEnvVars)
[16:22:01.253]                 envs <- base::Sys.getenv()
[16:22:01.253]                 names <- names(envs)
[16:22:01.253]                 common <- intersect(names, old_names)
[16:22:01.253]                 added <- setdiff(names, old_names)
[16:22:01.253]                 removed <- setdiff(old_names, names)
[16:22:01.253]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:01.253]                   envs[common]]
[16:22:01.253]                 NAMES <- toupper(changed)
[16:22:01.253]                 args <- list()
[16:22:01.253]                 for (kk in seq_along(NAMES)) {
[16:22:01.253]                   name <- changed[[kk]]
[16:22:01.253]                   NAME <- NAMES[[kk]]
[16:22:01.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.253]                     next
[16:22:01.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.253]                 }
[16:22:01.253]                 NAMES <- toupper(added)
[16:22:01.253]                 for (kk in seq_along(NAMES)) {
[16:22:01.253]                   name <- added[[kk]]
[16:22:01.253]                   NAME <- NAMES[[kk]]
[16:22:01.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.253]                     next
[16:22:01.253]                   args[[name]] <- ""
[16:22:01.253]                 }
[16:22:01.253]                 NAMES <- toupper(removed)
[16:22:01.253]                 for (kk in seq_along(NAMES)) {
[16:22:01.253]                   name <- removed[[kk]]
[16:22:01.253]                   NAME <- NAMES[[kk]]
[16:22:01.253]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.253]                     next
[16:22:01.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.253]                 }
[16:22:01.253]                 if (length(args) > 0) 
[16:22:01.253]                   base::do.call(base::Sys.setenv, args = args)
[16:22:01.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:01.253]             }
[16:22:01.253]             else {
[16:22:01.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:01.253]             }
[16:22:01.253]             {
[16:22:01.253]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:01.253]                   0L) {
[16:22:01.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:01.253]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:01.253]                   base::options(opts)
[16:22:01.253]                 }
[16:22:01.253]                 {
[16:22:01.253]                   {
[16:22:01.253]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:01.253]                     NULL
[16:22:01.253]                   }
[16:22:01.253]                   options(future.plan = NULL)
[16:22:01.253]                   if (is.na(NA_character_)) 
[16:22:01.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:01.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:01.253]                     .init = FALSE)
[16:22:01.253]                 }
[16:22:01.253]             }
[16:22:01.253]         }
[16:22:01.253]     })
[16:22:01.253]     if (TRUE) {
[16:22:01.253]         base::sink(type = "output", split = FALSE)
[16:22:01.253]         if (TRUE) {
[16:22:01.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:01.253]         }
[16:22:01.253]         else {
[16:22:01.253]             ...future.result["stdout"] <- base::list(NULL)
[16:22:01.253]         }
[16:22:01.253]         base::close(...future.stdout)
[16:22:01.253]         ...future.stdout <- NULL
[16:22:01.253]     }
[16:22:01.253]     ...future.result$conditions <- ...future.conditions
[16:22:01.253]     ...future.result$finished <- base::Sys.time()
[16:22:01.253]     ...future.result
[16:22:01.253] }
[16:22:01.256] MultisessionFuture started
[16:22:01.257] - Launch lazy future ... done
[16:22:01.257] run() for ‘MultisessionFuture’ ... done
[16:22:01.258] receiveMessageFromWorker() for ClusterFuture ...
[16:22:01.258] - Validating connection of MultisessionFuture
[16:22:01.259] - received message: FutureResult
[16:22:01.259] - Received FutureResult
[16:22:01.259] - Erased future from FutureRegistry
[16:22:01.259] result() for ClusterFuture ...
[16:22:01.259] - result already collected: FutureResult
[16:22:01.259] result() for ClusterFuture ... done
[16:22:01.259] signalConditions() ...
[16:22:01.259]  - include = ‘immediateCondition’
[16:22:01.259]  - exclude = 
[16:22:01.260]  - resignal = FALSE
[16:22:01.260]  - Number of conditions: 1
[16:22:01.260] signalConditions() ... done
[16:22:01.260] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:01.260] A MultisessionFuture was resolved (result was not collected)
[16:22:01.260] getGlobalsAndPackages() ...
[16:22:01.260] Searching for globals...
[16:22:01.261] - globals found: [2] ‘list’, ‘stop’
[16:22:01.261] Searching for globals ... DONE
[16:22:01.261] Resolving globals: FALSE
[16:22:01.261] 
[16:22:01.261] 
[16:22:01.261] getGlobalsAndPackages() ... DONE
[16:22:01.262] run() for ‘Future’ ...
[16:22:01.262] - state: ‘created’
[16:22:01.262] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:01.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:01.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:01.276]   - Field: ‘node’
[16:22:01.276]   - Field: ‘label’
[16:22:01.276]   - Field: ‘local’
[16:22:01.276]   - Field: ‘owner’
[16:22:01.276]   - Field: ‘envir’
[16:22:01.276]   - Field: ‘workers’
[16:22:01.276]   - Field: ‘packages’
[16:22:01.277]   - Field: ‘gc’
[16:22:01.277]   - Field: ‘conditions’
[16:22:01.277]   - Field: ‘persistent’
[16:22:01.277]   - Field: ‘expr’
[16:22:01.277]   - Field: ‘uuid’
[16:22:01.277]   - Field: ‘seed’
[16:22:01.277]   - Field: ‘version’
[16:22:01.277]   - Field: ‘result’
[16:22:01.277]   - Field: ‘asynchronous’
[16:22:01.277]   - Field: ‘calls’
[16:22:01.277]   - Field: ‘globals’
[16:22:01.277]   - Field: ‘stdout’
[16:22:01.278]   - Field: ‘earlySignal’
[16:22:01.278]   - Field: ‘lazy’
[16:22:01.278]   - Field: ‘state’
[16:22:01.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:01.278] - Launch lazy future ...
[16:22:01.278] Packages needed by the future expression (n = 0): <none>
[16:22:01.278] Packages needed by future strategies (n = 0): <none>
[16:22:01.279] {
[16:22:01.279]     {
[16:22:01.279]         {
[16:22:01.279]             ...future.startTime <- base::Sys.time()
[16:22:01.279]             {
[16:22:01.279]                 {
[16:22:01.279]                   {
[16:22:01.279]                     {
[16:22:01.279]                       base::local({
[16:22:01.279]                         has_future <- base::requireNamespace("future", 
[16:22:01.279]                           quietly = TRUE)
[16:22:01.279]                         if (has_future) {
[16:22:01.279]                           ns <- base::getNamespace("future")
[16:22:01.279]                           version <- ns[[".package"]][["version"]]
[16:22:01.279]                           if (is.null(version)) 
[16:22:01.279]                             version <- utils::packageVersion("future")
[16:22:01.279]                         }
[16:22:01.279]                         else {
[16:22:01.279]                           version <- NULL
[16:22:01.279]                         }
[16:22:01.279]                         if (!has_future || version < "1.8.0") {
[16:22:01.279]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:01.279]                             "", base::R.version$version.string), 
[16:22:01.279]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:01.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:01.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:01.279]                               "release", "version")], collapse = " "), 
[16:22:01.279]                             hostname = base::Sys.info()[["nodename"]])
[16:22:01.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:01.279]                             info)
[16:22:01.279]                           info <- base::paste(info, collapse = "; ")
[16:22:01.279]                           if (!has_future) {
[16:22:01.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:01.279]                               info)
[16:22:01.279]                           }
[16:22:01.279]                           else {
[16:22:01.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:01.279]                               info, version)
[16:22:01.279]                           }
[16:22:01.279]                           base::stop(msg)
[16:22:01.279]                         }
[16:22:01.279]                       })
[16:22:01.279]                     }
[16:22:01.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:01.279]                     base::options(mc.cores = 1L)
[16:22:01.279]                   }
[16:22:01.279]                   ...future.strategy.old <- future::plan("list")
[16:22:01.279]                   options(future.plan = NULL)
[16:22:01.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:01.279]                 }
[16:22:01.279]                 ...future.workdir <- getwd()
[16:22:01.279]             }
[16:22:01.279]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:01.279]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:01.279]         }
[16:22:01.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:01.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:01.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:01.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:01.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:01.279]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:01.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:01.279]             base::names(...future.oldOptions))
[16:22:01.279]     }
[16:22:01.279]     if (FALSE) {
[16:22:01.279]     }
[16:22:01.279]     else {
[16:22:01.279]         if (TRUE) {
[16:22:01.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:01.279]                 open = "w")
[16:22:01.279]         }
[16:22:01.279]         else {
[16:22:01.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:01.279]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:01.279]         }
[16:22:01.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:01.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:01.279]             base::sink(type = "output", split = FALSE)
[16:22:01.279]             base::close(...future.stdout)
[16:22:01.279]         }, add = TRUE)
[16:22:01.279]     }
[16:22:01.279]     ...future.frame <- base::sys.nframe()
[16:22:01.279]     ...future.conditions <- base::list()
[16:22:01.279]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:01.279]     if (FALSE) {
[16:22:01.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:01.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:01.279]     }
[16:22:01.279]     ...future.result <- base::tryCatch({
[16:22:01.279]         base::withCallingHandlers({
[16:22:01.279]             ...future.value <- base::withVisible(base::local({
[16:22:01.279]                 ...future.makeSendCondition <- base::local({
[16:22:01.279]                   sendCondition <- NULL
[16:22:01.279]                   function(frame = 1L) {
[16:22:01.279]                     if (is.function(sendCondition)) 
[16:22:01.279]                       return(sendCondition)
[16:22:01.279]                     ns <- getNamespace("parallel")
[16:22:01.279]                     if (exists("sendData", mode = "function", 
[16:22:01.279]                       envir = ns)) {
[16:22:01.279]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:01.279]                         envir = ns)
[16:22:01.279]                       envir <- sys.frame(frame)
[16:22:01.279]                       master <- NULL
[16:22:01.279]                       while (!identical(envir, .GlobalEnv) && 
[16:22:01.279]                         !identical(envir, emptyenv())) {
[16:22:01.279]                         if (exists("master", mode = "list", envir = envir, 
[16:22:01.279]                           inherits = FALSE)) {
[16:22:01.279]                           master <- get("master", mode = "list", 
[16:22:01.279]                             envir = envir, inherits = FALSE)
[16:22:01.279]                           if (inherits(master, c("SOCKnode", 
[16:22:01.279]                             "SOCK0node"))) {
[16:22:01.279]                             sendCondition <<- function(cond) {
[16:22:01.279]                               data <- list(type = "VALUE", value = cond, 
[16:22:01.279]                                 success = TRUE)
[16:22:01.279]                               parallel_sendData(master, data)
[16:22:01.279]                             }
[16:22:01.279]                             return(sendCondition)
[16:22:01.279]                           }
[16:22:01.279]                         }
[16:22:01.279]                         frame <- frame + 1L
[16:22:01.279]                         envir <- sys.frame(frame)
[16:22:01.279]                       }
[16:22:01.279]                     }
[16:22:01.279]                     sendCondition <<- function(cond) NULL
[16:22:01.279]                   }
[16:22:01.279]                 })
[16:22:01.279]                 withCallingHandlers({
[16:22:01.279]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:01.279]                 }, immediateCondition = function(cond) {
[16:22:01.279]                   sendCondition <- ...future.makeSendCondition()
[16:22:01.279]                   sendCondition(cond)
[16:22:01.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.279]                   {
[16:22:01.279]                     inherits <- base::inherits
[16:22:01.279]                     invokeRestart <- base::invokeRestart
[16:22:01.279]                     is.null <- base::is.null
[16:22:01.279]                     muffled <- FALSE
[16:22:01.279]                     if (inherits(cond, "message")) {
[16:22:01.279]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:01.279]                       if (muffled) 
[16:22:01.279]                         invokeRestart("muffleMessage")
[16:22:01.279]                     }
[16:22:01.279]                     else if (inherits(cond, "warning")) {
[16:22:01.279]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:01.279]                       if (muffled) 
[16:22:01.279]                         invokeRestart("muffleWarning")
[16:22:01.279]                     }
[16:22:01.279]                     else if (inherits(cond, "condition")) {
[16:22:01.279]                       if (!is.null(pattern)) {
[16:22:01.279]                         computeRestarts <- base::computeRestarts
[16:22:01.279]                         grepl <- base::grepl
[16:22:01.279]                         restarts <- computeRestarts(cond)
[16:22:01.279]                         for (restart in restarts) {
[16:22:01.279]                           name <- restart$name
[16:22:01.279]                           if (is.null(name)) 
[16:22:01.279]                             next
[16:22:01.279]                           if (!grepl(pattern, name)) 
[16:22:01.279]                             next
[16:22:01.279]                           invokeRestart(restart)
[16:22:01.279]                           muffled <- TRUE
[16:22:01.279]                           break
[16:22:01.279]                         }
[16:22:01.279]                       }
[16:22:01.279]                     }
[16:22:01.279]                     invisible(muffled)
[16:22:01.279]                   }
[16:22:01.279]                   muffleCondition(cond)
[16:22:01.279]                 })
[16:22:01.279]             }))
[16:22:01.279]             future::FutureResult(value = ...future.value$value, 
[16:22:01.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.279]                   ...future.rng), globalenv = if (FALSE) 
[16:22:01.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:01.279]                     ...future.globalenv.names))
[16:22:01.279]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:01.279]         }, condition = base::local({
[16:22:01.279]             c <- base::c
[16:22:01.279]             inherits <- base::inherits
[16:22:01.279]             invokeRestart <- base::invokeRestart
[16:22:01.279]             length <- base::length
[16:22:01.279]             list <- base::list
[16:22:01.279]             seq.int <- base::seq.int
[16:22:01.279]             signalCondition <- base::signalCondition
[16:22:01.279]             sys.calls <- base::sys.calls
[16:22:01.279]             `[[` <- base::`[[`
[16:22:01.279]             `+` <- base::`+`
[16:22:01.279]             `<<-` <- base::`<<-`
[16:22:01.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:01.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:01.279]                   3L)]
[16:22:01.279]             }
[16:22:01.279]             function(cond) {
[16:22:01.279]                 is_error <- inherits(cond, "error")
[16:22:01.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:01.279]                   NULL)
[16:22:01.279]                 if (is_error) {
[16:22:01.279]                   sessionInformation <- function() {
[16:22:01.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:01.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:01.279]                       search = base::search(), system = base::Sys.info())
[16:22:01.279]                   }
[16:22:01.279]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:01.279]                     cond$call), session = sessionInformation(), 
[16:22:01.279]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:01.279]                   signalCondition(cond)
[16:22:01.279]                 }
[16:22:01.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:01.279]                 "immediateCondition"))) {
[16:22:01.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:01.279]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:01.279]                   if (TRUE && !signal) {
[16:22:01.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.279]                     {
[16:22:01.279]                       inherits <- base::inherits
[16:22:01.279]                       invokeRestart <- base::invokeRestart
[16:22:01.279]                       is.null <- base::is.null
[16:22:01.279]                       muffled <- FALSE
[16:22:01.279]                       if (inherits(cond, "message")) {
[16:22:01.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.279]                         if (muffled) 
[16:22:01.279]                           invokeRestart("muffleMessage")
[16:22:01.279]                       }
[16:22:01.279]                       else if (inherits(cond, "warning")) {
[16:22:01.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.279]                         if (muffled) 
[16:22:01.279]                           invokeRestart("muffleWarning")
[16:22:01.279]                       }
[16:22:01.279]                       else if (inherits(cond, "condition")) {
[16:22:01.279]                         if (!is.null(pattern)) {
[16:22:01.279]                           computeRestarts <- base::computeRestarts
[16:22:01.279]                           grepl <- base::grepl
[16:22:01.279]                           restarts <- computeRestarts(cond)
[16:22:01.279]                           for (restart in restarts) {
[16:22:01.279]                             name <- restart$name
[16:22:01.279]                             if (is.null(name)) 
[16:22:01.279]                               next
[16:22:01.279]                             if (!grepl(pattern, name)) 
[16:22:01.279]                               next
[16:22:01.279]                             invokeRestart(restart)
[16:22:01.279]                             muffled <- TRUE
[16:22:01.279]                             break
[16:22:01.279]                           }
[16:22:01.279]                         }
[16:22:01.279]                       }
[16:22:01.279]                       invisible(muffled)
[16:22:01.279]                     }
[16:22:01.279]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.279]                   }
[16:22:01.279]                 }
[16:22:01.279]                 else {
[16:22:01.279]                   if (TRUE) {
[16:22:01.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.279]                     {
[16:22:01.279]                       inherits <- base::inherits
[16:22:01.279]                       invokeRestart <- base::invokeRestart
[16:22:01.279]                       is.null <- base::is.null
[16:22:01.279]                       muffled <- FALSE
[16:22:01.279]                       if (inherits(cond, "message")) {
[16:22:01.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.279]                         if (muffled) 
[16:22:01.279]                           invokeRestart("muffleMessage")
[16:22:01.279]                       }
[16:22:01.279]                       else if (inherits(cond, "warning")) {
[16:22:01.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.279]                         if (muffled) 
[16:22:01.279]                           invokeRestart("muffleWarning")
[16:22:01.279]                       }
[16:22:01.279]                       else if (inherits(cond, "condition")) {
[16:22:01.279]                         if (!is.null(pattern)) {
[16:22:01.279]                           computeRestarts <- base::computeRestarts
[16:22:01.279]                           grepl <- base::grepl
[16:22:01.279]                           restarts <- computeRestarts(cond)
[16:22:01.279]                           for (restart in restarts) {
[16:22:01.279]                             name <- restart$name
[16:22:01.279]                             if (is.null(name)) 
[16:22:01.279]                               next
[16:22:01.279]                             if (!grepl(pattern, name)) 
[16:22:01.279]                               next
[16:22:01.279]                             invokeRestart(restart)
[16:22:01.279]                             muffled <- TRUE
[16:22:01.279]                             break
[16:22:01.279]                           }
[16:22:01.279]                         }
[16:22:01.279]                       }
[16:22:01.279]                       invisible(muffled)
[16:22:01.279]                     }
[16:22:01.279]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.279]                   }
[16:22:01.279]                 }
[16:22:01.279]             }
[16:22:01.279]         }))
[16:22:01.279]     }, error = function(ex) {
[16:22:01.279]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:01.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.279]                 ...future.rng), started = ...future.startTime, 
[16:22:01.279]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:01.279]             version = "1.8"), class = "FutureResult")
[16:22:01.279]     }, finally = {
[16:22:01.279]         if (!identical(...future.workdir, getwd())) 
[16:22:01.279]             setwd(...future.workdir)
[16:22:01.279]         {
[16:22:01.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:01.279]                 ...future.oldOptions$nwarnings <- NULL
[16:22:01.279]             }
[16:22:01.279]             base::options(...future.oldOptions)
[16:22:01.279]             if (.Platform$OS.type == "windows") {
[16:22:01.279]                 old_names <- names(...future.oldEnvVars)
[16:22:01.279]                 envs <- base::Sys.getenv()
[16:22:01.279]                 names <- names(envs)
[16:22:01.279]                 common <- intersect(names, old_names)
[16:22:01.279]                 added <- setdiff(names, old_names)
[16:22:01.279]                 removed <- setdiff(old_names, names)
[16:22:01.279]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:01.279]                   envs[common]]
[16:22:01.279]                 NAMES <- toupper(changed)
[16:22:01.279]                 args <- list()
[16:22:01.279]                 for (kk in seq_along(NAMES)) {
[16:22:01.279]                   name <- changed[[kk]]
[16:22:01.279]                   NAME <- NAMES[[kk]]
[16:22:01.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.279]                     next
[16:22:01.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.279]                 }
[16:22:01.279]                 NAMES <- toupper(added)
[16:22:01.279]                 for (kk in seq_along(NAMES)) {
[16:22:01.279]                   name <- added[[kk]]
[16:22:01.279]                   NAME <- NAMES[[kk]]
[16:22:01.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.279]                     next
[16:22:01.279]                   args[[name]] <- ""
[16:22:01.279]                 }
[16:22:01.279]                 NAMES <- toupper(removed)
[16:22:01.279]                 for (kk in seq_along(NAMES)) {
[16:22:01.279]                   name <- removed[[kk]]
[16:22:01.279]                   NAME <- NAMES[[kk]]
[16:22:01.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.279]                     next
[16:22:01.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.279]                 }
[16:22:01.279]                 if (length(args) > 0) 
[16:22:01.279]                   base::do.call(base::Sys.setenv, args = args)
[16:22:01.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:01.279]             }
[16:22:01.279]             else {
[16:22:01.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:01.279]             }
[16:22:01.279]             {
[16:22:01.279]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:01.279]                   0L) {
[16:22:01.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:01.279]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:01.279]                   base::options(opts)
[16:22:01.279]                 }
[16:22:01.279]                 {
[16:22:01.279]                   {
[16:22:01.279]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:01.279]                     NULL
[16:22:01.279]                   }
[16:22:01.279]                   options(future.plan = NULL)
[16:22:01.279]                   if (is.na(NA_character_)) 
[16:22:01.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:01.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:01.279]                     .init = FALSE)
[16:22:01.279]                 }
[16:22:01.279]             }
[16:22:01.279]         }
[16:22:01.279]     })
[16:22:01.279]     if (TRUE) {
[16:22:01.279]         base::sink(type = "output", split = FALSE)
[16:22:01.279]         if (TRUE) {
[16:22:01.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:01.279]         }
[16:22:01.279]         else {
[16:22:01.279]             ...future.result["stdout"] <- base::list(NULL)
[16:22:01.279]         }
[16:22:01.279]         base::close(...future.stdout)
[16:22:01.279]         ...future.stdout <- NULL
[16:22:01.279]     }
[16:22:01.279]     ...future.result$conditions <- ...future.conditions
[16:22:01.279]     ...future.result$finished <- base::Sys.time()
[16:22:01.279]     ...future.result
[16:22:01.279] }
[16:22:01.282] MultisessionFuture started
[16:22:01.282] - Launch lazy future ... done
[16:22:01.282] run() for ‘MultisessionFuture’ ... done
[16:22:01.283] receiveMessageFromWorker() for ClusterFuture ...
[16:22:01.284] - Validating connection of MultisessionFuture
[16:22:01.284] - received message: FutureResult
[16:22:01.284] - Received FutureResult
[16:22:01.284] - Erased future from FutureRegistry
[16:22:01.285] result() for ClusterFuture ...
[16:22:01.285] - result already collected: FutureResult
[16:22:01.285] result() for ClusterFuture ... done
[16:22:01.285] signalConditions() ...
[16:22:01.285]  - include = ‘immediateCondition’
[16:22:01.285]  - exclude = 
[16:22:01.285]  - resignal = FALSE
[16:22:01.285]  - Number of conditions: 1
[16:22:01.285] signalConditions() ... done
[16:22:01.285] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:01.285] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[16:22:01.286] getGlobalsAndPackages() ...
[16:22:01.286] Searching for globals...
[16:22:01.287] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:01.287] Searching for globals ... DONE
[16:22:01.287] Resolving globals: FALSE
[16:22:01.287] 
[16:22:01.287] 
[16:22:01.288] getGlobalsAndPackages() ... DONE
[16:22:01.288] run() for ‘Future’ ...
[16:22:01.288] - state: ‘created’
[16:22:01.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:01.302] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:01.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:01.302]   - Field: ‘node’
[16:22:01.302]   - Field: ‘label’
[16:22:01.302]   - Field: ‘local’
[16:22:01.302]   - Field: ‘owner’
[16:22:01.302]   - Field: ‘envir’
[16:22:01.302]   - Field: ‘workers’
[16:22:01.303]   - Field: ‘packages’
[16:22:01.303]   - Field: ‘gc’
[16:22:01.303]   - Field: ‘conditions’
[16:22:01.303]   - Field: ‘persistent’
[16:22:01.303]   - Field: ‘expr’
[16:22:01.303]   - Field: ‘uuid’
[16:22:01.303]   - Field: ‘seed’
[16:22:01.303]   - Field: ‘version’
[16:22:01.303]   - Field: ‘result’
[16:22:01.303]   - Field: ‘asynchronous’
[16:22:01.304]   - Field: ‘calls’
[16:22:01.304]   - Field: ‘globals’
[16:22:01.304]   - Field: ‘stdout’
[16:22:01.304]   - Field: ‘earlySignal’
[16:22:01.304]   - Field: ‘lazy’
[16:22:01.304]   - Field: ‘state’
[16:22:01.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:01.304] - Launch lazy future ...
[16:22:01.304] Packages needed by the future expression (n = 0): <none>
[16:22:01.305] Packages needed by future strategies (n = 0): <none>
[16:22:01.305] {
[16:22:01.305]     {
[16:22:01.305]         {
[16:22:01.305]             ...future.startTime <- base::Sys.time()
[16:22:01.305]             {
[16:22:01.305]                 {
[16:22:01.305]                   {
[16:22:01.305]                     {
[16:22:01.305]                       base::local({
[16:22:01.305]                         has_future <- base::requireNamespace("future", 
[16:22:01.305]                           quietly = TRUE)
[16:22:01.305]                         if (has_future) {
[16:22:01.305]                           ns <- base::getNamespace("future")
[16:22:01.305]                           version <- ns[[".package"]][["version"]]
[16:22:01.305]                           if (is.null(version)) 
[16:22:01.305]                             version <- utils::packageVersion("future")
[16:22:01.305]                         }
[16:22:01.305]                         else {
[16:22:01.305]                           version <- NULL
[16:22:01.305]                         }
[16:22:01.305]                         if (!has_future || version < "1.8.0") {
[16:22:01.305]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:01.305]                             "", base::R.version$version.string), 
[16:22:01.305]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:01.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:01.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:01.305]                               "release", "version")], collapse = " "), 
[16:22:01.305]                             hostname = base::Sys.info()[["nodename"]])
[16:22:01.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:01.305]                             info)
[16:22:01.305]                           info <- base::paste(info, collapse = "; ")
[16:22:01.305]                           if (!has_future) {
[16:22:01.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:01.305]                               info)
[16:22:01.305]                           }
[16:22:01.305]                           else {
[16:22:01.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:01.305]                               info, version)
[16:22:01.305]                           }
[16:22:01.305]                           base::stop(msg)
[16:22:01.305]                         }
[16:22:01.305]                       })
[16:22:01.305]                     }
[16:22:01.305]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:01.305]                     base::options(mc.cores = 1L)
[16:22:01.305]                   }
[16:22:01.305]                   ...future.strategy.old <- future::plan("list")
[16:22:01.305]                   options(future.plan = NULL)
[16:22:01.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:01.305]                 }
[16:22:01.305]                 ...future.workdir <- getwd()
[16:22:01.305]             }
[16:22:01.305]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:01.305]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:01.305]         }
[16:22:01.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:01.305]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:01.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:01.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:01.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:01.305]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:01.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:01.305]             base::names(...future.oldOptions))
[16:22:01.305]     }
[16:22:01.305]     if (FALSE) {
[16:22:01.305]     }
[16:22:01.305]     else {
[16:22:01.305]         if (TRUE) {
[16:22:01.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:01.305]                 open = "w")
[16:22:01.305]         }
[16:22:01.305]         else {
[16:22:01.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:01.305]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:01.305]         }
[16:22:01.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:01.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:01.305]             base::sink(type = "output", split = FALSE)
[16:22:01.305]             base::close(...future.stdout)
[16:22:01.305]         }, add = TRUE)
[16:22:01.305]     }
[16:22:01.305]     ...future.frame <- base::sys.nframe()
[16:22:01.305]     ...future.conditions <- base::list()
[16:22:01.305]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:01.305]     if (FALSE) {
[16:22:01.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:01.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:01.305]     }
[16:22:01.305]     ...future.result <- base::tryCatch({
[16:22:01.305]         base::withCallingHandlers({
[16:22:01.305]             ...future.value <- base::withVisible(base::local({
[16:22:01.305]                 ...future.makeSendCondition <- base::local({
[16:22:01.305]                   sendCondition <- NULL
[16:22:01.305]                   function(frame = 1L) {
[16:22:01.305]                     if (is.function(sendCondition)) 
[16:22:01.305]                       return(sendCondition)
[16:22:01.305]                     ns <- getNamespace("parallel")
[16:22:01.305]                     if (exists("sendData", mode = "function", 
[16:22:01.305]                       envir = ns)) {
[16:22:01.305]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:01.305]                         envir = ns)
[16:22:01.305]                       envir <- sys.frame(frame)
[16:22:01.305]                       master <- NULL
[16:22:01.305]                       while (!identical(envir, .GlobalEnv) && 
[16:22:01.305]                         !identical(envir, emptyenv())) {
[16:22:01.305]                         if (exists("master", mode = "list", envir = envir, 
[16:22:01.305]                           inherits = FALSE)) {
[16:22:01.305]                           master <- get("master", mode = "list", 
[16:22:01.305]                             envir = envir, inherits = FALSE)
[16:22:01.305]                           if (inherits(master, c("SOCKnode", 
[16:22:01.305]                             "SOCK0node"))) {
[16:22:01.305]                             sendCondition <<- function(cond) {
[16:22:01.305]                               data <- list(type = "VALUE", value = cond, 
[16:22:01.305]                                 success = TRUE)
[16:22:01.305]                               parallel_sendData(master, data)
[16:22:01.305]                             }
[16:22:01.305]                             return(sendCondition)
[16:22:01.305]                           }
[16:22:01.305]                         }
[16:22:01.305]                         frame <- frame + 1L
[16:22:01.305]                         envir <- sys.frame(frame)
[16:22:01.305]                       }
[16:22:01.305]                     }
[16:22:01.305]                     sendCondition <<- function(cond) NULL
[16:22:01.305]                   }
[16:22:01.305]                 })
[16:22:01.305]                 withCallingHandlers({
[16:22:01.305]                   {
[16:22:01.305]                     Sys.sleep(0.5)
[16:22:01.305]                     list(a = 1, b = 42L)
[16:22:01.305]                   }
[16:22:01.305]                 }, immediateCondition = function(cond) {
[16:22:01.305]                   sendCondition <- ...future.makeSendCondition()
[16:22:01.305]                   sendCondition(cond)
[16:22:01.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.305]                   {
[16:22:01.305]                     inherits <- base::inherits
[16:22:01.305]                     invokeRestart <- base::invokeRestart
[16:22:01.305]                     is.null <- base::is.null
[16:22:01.305]                     muffled <- FALSE
[16:22:01.305]                     if (inherits(cond, "message")) {
[16:22:01.305]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:01.305]                       if (muffled) 
[16:22:01.305]                         invokeRestart("muffleMessage")
[16:22:01.305]                     }
[16:22:01.305]                     else if (inherits(cond, "warning")) {
[16:22:01.305]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:01.305]                       if (muffled) 
[16:22:01.305]                         invokeRestart("muffleWarning")
[16:22:01.305]                     }
[16:22:01.305]                     else if (inherits(cond, "condition")) {
[16:22:01.305]                       if (!is.null(pattern)) {
[16:22:01.305]                         computeRestarts <- base::computeRestarts
[16:22:01.305]                         grepl <- base::grepl
[16:22:01.305]                         restarts <- computeRestarts(cond)
[16:22:01.305]                         for (restart in restarts) {
[16:22:01.305]                           name <- restart$name
[16:22:01.305]                           if (is.null(name)) 
[16:22:01.305]                             next
[16:22:01.305]                           if (!grepl(pattern, name)) 
[16:22:01.305]                             next
[16:22:01.305]                           invokeRestart(restart)
[16:22:01.305]                           muffled <- TRUE
[16:22:01.305]                           break
[16:22:01.305]                         }
[16:22:01.305]                       }
[16:22:01.305]                     }
[16:22:01.305]                     invisible(muffled)
[16:22:01.305]                   }
[16:22:01.305]                   muffleCondition(cond)
[16:22:01.305]                 })
[16:22:01.305]             }))
[16:22:01.305]             future::FutureResult(value = ...future.value$value, 
[16:22:01.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.305]                   ...future.rng), globalenv = if (FALSE) 
[16:22:01.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:01.305]                     ...future.globalenv.names))
[16:22:01.305]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:01.305]         }, condition = base::local({
[16:22:01.305]             c <- base::c
[16:22:01.305]             inherits <- base::inherits
[16:22:01.305]             invokeRestart <- base::invokeRestart
[16:22:01.305]             length <- base::length
[16:22:01.305]             list <- base::list
[16:22:01.305]             seq.int <- base::seq.int
[16:22:01.305]             signalCondition <- base::signalCondition
[16:22:01.305]             sys.calls <- base::sys.calls
[16:22:01.305]             `[[` <- base::`[[`
[16:22:01.305]             `+` <- base::`+`
[16:22:01.305]             `<<-` <- base::`<<-`
[16:22:01.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:01.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:01.305]                   3L)]
[16:22:01.305]             }
[16:22:01.305]             function(cond) {
[16:22:01.305]                 is_error <- inherits(cond, "error")
[16:22:01.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:01.305]                   NULL)
[16:22:01.305]                 if (is_error) {
[16:22:01.305]                   sessionInformation <- function() {
[16:22:01.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:01.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:01.305]                       search = base::search(), system = base::Sys.info())
[16:22:01.305]                   }
[16:22:01.305]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:01.305]                     cond$call), session = sessionInformation(), 
[16:22:01.305]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:01.305]                   signalCondition(cond)
[16:22:01.305]                 }
[16:22:01.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:01.305]                 "immediateCondition"))) {
[16:22:01.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:01.305]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:01.305]                   if (TRUE && !signal) {
[16:22:01.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.305]                     {
[16:22:01.305]                       inherits <- base::inherits
[16:22:01.305]                       invokeRestart <- base::invokeRestart
[16:22:01.305]                       is.null <- base::is.null
[16:22:01.305]                       muffled <- FALSE
[16:22:01.305]                       if (inherits(cond, "message")) {
[16:22:01.305]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.305]                         if (muffled) 
[16:22:01.305]                           invokeRestart("muffleMessage")
[16:22:01.305]                       }
[16:22:01.305]                       else if (inherits(cond, "warning")) {
[16:22:01.305]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.305]                         if (muffled) 
[16:22:01.305]                           invokeRestart("muffleWarning")
[16:22:01.305]                       }
[16:22:01.305]                       else if (inherits(cond, "condition")) {
[16:22:01.305]                         if (!is.null(pattern)) {
[16:22:01.305]                           computeRestarts <- base::computeRestarts
[16:22:01.305]                           grepl <- base::grepl
[16:22:01.305]                           restarts <- computeRestarts(cond)
[16:22:01.305]                           for (restart in restarts) {
[16:22:01.305]                             name <- restart$name
[16:22:01.305]                             if (is.null(name)) 
[16:22:01.305]                               next
[16:22:01.305]                             if (!grepl(pattern, name)) 
[16:22:01.305]                               next
[16:22:01.305]                             invokeRestart(restart)
[16:22:01.305]                             muffled <- TRUE
[16:22:01.305]                             break
[16:22:01.305]                           }
[16:22:01.305]                         }
[16:22:01.305]                       }
[16:22:01.305]                       invisible(muffled)
[16:22:01.305]                     }
[16:22:01.305]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.305]                   }
[16:22:01.305]                 }
[16:22:01.305]                 else {
[16:22:01.305]                   if (TRUE) {
[16:22:01.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.305]                     {
[16:22:01.305]                       inherits <- base::inherits
[16:22:01.305]                       invokeRestart <- base::invokeRestart
[16:22:01.305]                       is.null <- base::is.null
[16:22:01.305]                       muffled <- FALSE
[16:22:01.305]                       if (inherits(cond, "message")) {
[16:22:01.305]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.305]                         if (muffled) 
[16:22:01.305]                           invokeRestart("muffleMessage")
[16:22:01.305]                       }
[16:22:01.305]                       else if (inherits(cond, "warning")) {
[16:22:01.305]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.305]                         if (muffled) 
[16:22:01.305]                           invokeRestart("muffleWarning")
[16:22:01.305]                       }
[16:22:01.305]                       else if (inherits(cond, "condition")) {
[16:22:01.305]                         if (!is.null(pattern)) {
[16:22:01.305]                           computeRestarts <- base::computeRestarts
[16:22:01.305]                           grepl <- base::grepl
[16:22:01.305]                           restarts <- computeRestarts(cond)
[16:22:01.305]                           for (restart in restarts) {
[16:22:01.305]                             name <- restart$name
[16:22:01.305]                             if (is.null(name)) 
[16:22:01.305]                               next
[16:22:01.305]                             if (!grepl(pattern, name)) 
[16:22:01.305]                               next
[16:22:01.305]                             invokeRestart(restart)
[16:22:01.305]                             muffled <- TRUE
[16:22:01.305]                             break
[16:22:01.305]                           }
[16:22:01.305]                         }
[16:22:01.305]                       }
[16:22:01.305]                       invisible(muffled)
[16:22:01.305]                     }
[16:22:01.305]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.305]                   }
[16:22:01.305]                 }
[16:22:01.305]             }
[16:22:01.305]         }))
[16:22:01.305]     }, error = function(ex) {
[16:22:01.305]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:01.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.305]                 ...future.rng), started = ...future.startTime, 
[16:22:01.305]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:01.305]             version = "1.8"), class = "FutureResult")
[16:22:01.305]     }, finally = {
[16:22:01.305]         if (!identical(...future.workdir, getwd())) 
[16:22:01.305]             setwd(...future.workdir)
[16:22:01.305]         {
[16:22:01.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:01.305]                 ...future.oldOptions$nwarnings <- NULL
[16:22:01.305]             }
[16:22:01.305]             base::options(...future.oldOptions)
[16:22:01.305]             if (.Platform$OS.type == "windows") {
[16:22:01.305]                 old_names <- names(...future.oldEnvVars)
[16:22:01.305]                 envs <- base::Sys.getenv()
[16:22:01.305]                 names <- names(envs)
[16:22:01.305]                 common <- intersect(names, old_names)
[16:22:01.305]                 added <- setdiff(names, old_names)
[16:22:01.305]                 removed <- setdiff(old_names, names)
[16:22:01.305]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:01.305]                   envs[common]]
[16:22:01.305]                 NAMES <- toupper(changed)
[16:22:01.305]                 args <- list()
[16:22:01.305]                 for (kk in seq_along(NAMES)) {
[16:22:01.305]                   name <- changed[[kk]]
[16:22:01.305]                   NAME <- NAMES[[kk]]
[16:22:01.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.305]                     next
[16:22:01.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.305]                 }
[16:22:01.305]                 NAMES <- toupper(added)
[16:22:01.305]                 for (kk in seq_along(NAMES)) {
[16:22:01.305]                   name <- added[[kk]]
[16:22:01.305]                   NAME <- NAMES[[kk]]
[16:22:01.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.305]                     next
[16:22:01.305]                   args[[name]] <- ""
[16:22:01.305]                 }
[16:22:01.305]                 NAMES <- toupper(removed)
[16:22:01.305]                 for (kk in seq_along(NAMES)) {
[16:22:01.305]                   name <- removed[[kk]]
[16:22:01.305]                   NAME <- NAMES[[kk]]
[16:22:01.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.305]                     next
[16:22:01.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.305]                 }
[16:22:01.305]                 if (length(args) > 0) 
[16:22:01.305]                   base::do.call(base::Sys.setenv, args = args)
[16:22:01.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:01.305]             }
[16:22:01.305]             else {
[16:22:01.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:01.305]             }
[16:22:01.305]             {
[16:22:01.305]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:01.305]                   0L) {
[16:22:01.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:01.305]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:01.305]                   base::options(opts)
[16:22:01.305]                 }
[16:22:01.305]                 {
[16:22:01.305]                   {
[16:22:01.305]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:01.305]                     NULL
[16:22:01.305]                   }
[16:22:01.305]                   options(future.plan = NULL)
[16:22:01.305]                   if (is.na(NA_character_)) 
[16:22:01.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:01.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:01.305]                     .init = FALSE)
[16:22:01.305]                 }
[16:22:01.305]             }
[16:22:01.305]         }
[16:22:01.305]     })
[16:22:01.305]     if (TRUE) {
[16:22:01.305]         base::sink(type = "output", split = FALSE)
[16:22:01.305]         if (TRUE) {
[16:22:01.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:01.305]         }
[16:22:01.305]         else {
[16:22:01.305]             ...future.result["stdout"] <- base::list(NULL)
[16:22:01.305]         }
[16:22:01.305]         base::close(...future.stdout)
[16:22:01.305]         ...future.stdout <- NULL
[16:22:01.305]     }
[16:22:01.305]     ...future.result$conditions <- ...future.conditions
[16:22:01.305]     ...future.result$finished <- base::Sys.time()
[16:22:01.305]     ...future.result
[16:22:01.305] }
[16:22:01.308] MultisessionFuture started
[16:22:01.308] - Launch lazy future ... done
[16:22:01.308] run() for ‘MultisessionFuture’ ... done
[16:22:01.811] receiveMessageFromWorker() for ClusterFuture ...
[16:22:01.811] - Validating connection of MultisessionFuture
[16:22:01.811] - received message: FutureResult
[16:22:01.811] - Received FutureResult
[16:22:01.811] - Erased future from FutureRegistry
[16:22:01.811] result() for ClusterFuture ...
[16:22:01.812] - result already collected: FutureResult
[16:22:01.812] result() for ClusterFuture ... done
[16:22:01.812] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:01.812] A MultisessionFuture was resolved
[16:22:01.812] getGlobalsAndPackages() ...
[16:22:01.812] Searching for globals...
[16:22:01.813] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:01.813] Searching for globals ... DONE
[16:22:01.813] Resolving globals: FALSE
[16:22:01.814] 
[16:22:01.814] 
[16:22:01.814] getGlobalsAndPackages() ... DONE
[16:22:01.814] run() for ‘Future’ ...
[16:22:01.814] - state: ‘created’
[16:22:01.814] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:01.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:01.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:01.829]   - Field: ‘node’
[16:22:01.829]   - Field: ‘label’
[16:22:01.829]   - Field: ‘local’
[16:22:01.829]   - Field: ‘owner’
[16:22:01.829]   - Field: ‘envir’
[16:22:01.829]   - Field: ‘workers’
[16:22:01.829]   - Field: ‘packages’
[16:22:01.829]   - Field: ‘gc’
[16:22:01.829]   - Field: ‘conditions’
[16:22:01.830]   - Field: ‘persistent’
[16:22:01.830]   - Field: ‘expr’
[16:22:01.830]   - Field: ‘uuid’
[16:22:01.830]   - Field: ‘seed’
[16:22:01.830]   - Field: ‘version’
[16:22:01.830]   - Field: ‘result’
[16:22:01.830]   - Field: ‘asynchronous’
[16:22:01.830]   - Field: ‘calls’
[16:22:01.830]   - Field: ‘globals’
[16:22:01.830]   - Field: ‘stdout’
[16:22:01.830]   - Field: ‘earlySignal’
[16:22:01.831]   - Field: ‘lazy’
[16:22:01.831]   - Field: ‘state’
[16:22:01.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:01.831] - Launch lazy future ...
[16:22:01.831] Packages needed by the future expression (n = 0): <none>
[16:22:01.831] Packages needed by future strategies (n = 0): <none>
[16:22:01.834] {
[16:22:01.834]     {
[16:22:01.834]         {
[16:22:01.834]             ...future.startTime <- base::Sys.time()
[16:22:01.834]             {
[16:22:01.834]                 {
[16:22:01.834]                   {
[16:22:01.834]                     {
[16:22:01.834]                       base::local({
[16:22:01.834]                         has_future <- base::requireNamespace("future", 
[16:22:01.834]                           quietly = TRUE)
[16:22:01.834]                         if (has_future) {
[16:22:01.834]                           ns <- base::getNamespace("future")
[16:22:01.834]                           version <- ns[[".package"]][["version"]]
[16:22:01.834]                           if (is.null(version)) 
[16:22:01.834]                             version <- utils::packageVersion("future")
[16:22:01.834]                         }
[16:22:01.834]                         else {
[16:22:01.834]                           version <- NULL
[16:22:01.834]                         }
[16:22:01.834]                         if (!has_future || version < "1.8.0") {
[16:22:01.834]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:01.834]                             "", base::R.version$version.string), 
[16:22:01.834]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:01.834]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:01.834]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:01.834]                               "release", "version")], collapse = " "), 
[16:22:01.834]                             hostname = base::Sys.info()[["nodename"]])
[16:22:01.834]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:01.834]                             info)
[16:22:01.834]                           info <- base::paste(info, collapse = "; ")
[16:22:01.834]                           if (!has_future) {
[16:22:01.834]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:01.834]                               info)
[16:22:01.834]                           }
[16:22:01.834]                           else {
[16:22:01.834]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:01.834]                               info, version)
[16:22:01.834]                           }
[16:22:01.834]                           base::stop(msg)
[16:22:01.834]                         }
[16:22:01.834]                       })
[16:22:01.834]                     }
[16:22:01.834]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:01.834]                     base::options(mc.cores = 1L)
[16:22:01.834]                   }
[16:22:01.834]                   ...future.strategy.old <- future::plan("list")
[16:22:01.834]                   options(future.plan = NULL)
[16:22:01.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:01.834]                 }
[16:22:01.834]                 ...future.workdir <- getwd()
[16:22:01.834]             }
[16:22:01.834]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:01.834]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:01.834]         }
[16:22:01.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:01.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:01.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:01.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:01.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:01.834]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:01.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:01.834]             base::names(...future.oldOptions))
[16:22:01.834]     }
[16:22:01.834]     if (FALSE) {
[16:22:01.834]     }
[16:22:01.834]     else {
[16:22:01.834]         if (TRUE) {
[16:22:01.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:01.834]                 open = "w")
[16:22:01.834]         }
[16:22:01.834]         else {
[16:22:01.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:01.834]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:01.834]         }
[16:22:01.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:01.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:01.834]             base::sink(type = "output", split = FALSE)
[16:22:01.834]             base::close(...future.stdout)
[16:22:01.834]         }, add = TRUE)
[16:22:01.834]     }
[16:22:01.834]     ...future.frame <- base::sys.nframe()
[16:22:01.834]     ...future.conditions <- base::list()
[16:22:01.834]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:01.834]     if (FALSE) {
[16:22:01.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:01.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:01.834]     }
[16:22:01.834]     ...future.result <- base::tryCatch({
[16:22:01.834]         base::withCallingHandlers({
[16:22:01.834]             ...future.value <- base::withVisible(base::local({
[16:22:01.834]                 ...future.makeSendCondition <- base::local({
[16:22:01.834]                   sendCondition <- NULL
[16:22:01.834]                   function(frame = 1L) {
[16:22:01.834]                     if (is.function(sendCondition)) 
[16:22:01.834]                       return(sendCondition)
[16:22:01.834]                     ns <- getNamespace("parallel")
[16:22:01.834]                     if (exists("sendData", mode = "function", 
[16:22:01.834]                       envir = ns)) {
[16:22:01.834]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:01.834]                         envir = ns)
[16:22:01.834]                       envir <- sys.frame(frame)
[16:22:01.834]                       master <- NULL
[16:22:01.834]                       while (!identical(envir, .GlobalEnv) && 
[16:22:01.834]                         !identical(envir, emptyenv())) {
[16:22:01.834]                         if (exists("master", mode = "list", envir = envir, 
[16:22:01.834]                           inherits = FALSE)) {
[16:22:01.834]                           master <- get("master", mode = "list", 
[16:22:01.834]                             envir = envir, inherits = FALSE)
[16:22:01.834]                           if (inherits(master, c("SOCKnode", 
[16:22:01.834]                             "SOCK0node"))) {
[16:22:01.834]                             sendCondition <<- function(cond) {
[16:22:01.834]                               data <- list(type = "VALUE", value = cond, 
[16:22:01.834]                                 success = TRUE)
[16:22:01.834]                               parallel_sendData(master, data)
[16:22:01.834]                             }
[16:22:01.834]                             return(sendCondition)
[16:22:01.834]                           }
[16:22:01.834]                         }
[16:22:01.834]                         frame <- frame + 1L
[16:22:01.834]                         envir <- sys.frame(frame)
[16:22:01.834]                       }
[16:22:01.834]                     }
[16:22:01.834]                     sendCondition <<- function(cond) NULL
[16:22:01.834]                   }
[16:22:01.834]                 })
[16:22:01.834]                 withCallingHandlers({
[16:22:01.834]                   {
[16:22:01.834]                     Sys.sleep(0.5)
[16:22:01.834]                     list(a = 1, b = 42L)
[16:22:01.834]                   }
[16:22:01.834]                 }, immediateCondition = function(cond) {
[16:22:01.834]                   sendCondition <- ...future.makeSendCondition()
[16:22:01.834]                   sendCondition(cond)
[16:22:01.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.834]                   {
[16:22:01.834]                     inherits <- base::inherits
[16:22:01.834]                     invokeRestart <- base::invokeRestart
[16:22:01.834]                     is.null <- base::is.null
[16:22:01.834]                     muffled <- FALSE
[16:22:01.834]                     if (inherits(cond, "message")) {
[16:22:01.834]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:01.834]                       if (muffled) 
[16:22:01.834]                         invokeRestart("muffleMessage")
[16:22:01.834]                     }
[16:22:01.834]                     else if (inherits(cond, "warning")) {
[16:22:01.834]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:01.834]                       if (muffled) 
[16:22:01.834]                         invokeRestart("muffleWarning")
[16:22:01.834]                     }
[16:22:01.834]                     else if (inherits(cond, "condition")) {
[16:22:01.834]                       if (!is.null(pattern)) {
[16:22:01.834]                         computeRestarts <- base::computeRestarts
[16:22:01.834]                         grepl <- base::grepl
[16:22:01.834]                         restarts <- computeRestarts(cond)
[16:22:01.834]                         for (restart in restarts) {
[16:22:01.834]                           name <- restart$name
[16:22:01.834]                           if (is.null(name)) 
[16:22:01.834]                             next
[16:22:01.834]                           if (!grepl(pattern, name)) 
[16:22:01.834]                             next
[16:22:01.834]                           invokeRestart(restart)
[16:22:01.834]                           muffled <- TRUE
[16:22:01.834]                           break
[16:22:01.834]                         }
[16:22:01.834]                       }
[16:22:01.834]                     }
[16:22:01.834]                     invisible(muffled)
[16:22:01.834]                   }
[16:22:01.834]                   muffleCondition(cond)
[16:22:01.834]                 })
[16:22:01.834]             }))
[16:22:01.834]             future::FutureResult(value = ...future.value$value, 
[16:22:01.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.834]                   ...future.rng), globalenv = if (FALSE) 
[16:22:01.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:01.834]                     ...future.globalenv.names))
[16:22:01.834]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:01.834]         }, condition = base::local({
[16:22:01.834]             c <- base::c
[16:22:01.834]             inherits <- base::inherits
[16:22:01.834]             invokeRestart <- base::invokeRestart
[16:22:01.834]             length <- base::length
[16:22:01.834]             list <- base::list
[16:22:01.834]             seq.int <- base::seq.int
[16:22:01.834]             signalCondition <- base::signalCondition
[16:22:01.834]             sys.calls <- base::sys.calls
[16:22:01.834]             `[[` <- base::`[[`
[16:22:01.834]             `+` <- base::`+`
[16:22:01.834]             `<<-` <- base::`<<-`
[16:22:01.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:01.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:01.834]                   3L)]
[16:22:01.834]             }
[16:22:01.834]             function(cond) {
[16:22:01.834]                 is_error <- inherits(cond, "error")
[16:22:01.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:01.834]                   NULL)
[16:22:01.834]                 if (is_error) {
[16:22:01.834]                   sessionInformation <- function() {
[16:22:01.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:01.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:01.834]                       search = base::search(), system = base::Sys.info())
[16:22:01.834]                   }
[16:22:01.834]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:01.834]                     cond$call), session = sessionInformation(), 
[16:22:01.834]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:01.834]                   signalCondition(cond)
[16:22:01.834]                 }
[16:22:01.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:01.834]                 "immediateCondition"))) {
[16:22:01.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:01.834]                   ...future.conditions[[length(...future.conditions) + 
[16:22:01.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:01.834]                   if (TRUE && !signal) {
[16:22:01.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.834]                     {
[16:22:01.834]                       inherits <- base::inherits
[16:22:01.834]                       invokeRestart <- base::invokeRestart
[16:22:01.834]                       is.null <- base::is.null
[16:22:01.834]                       muffled <- FALSE
[16:22:01.834]                       if (inherits(cond, "message")) {
[16:22:01.834]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.834]                         if (muffled) 
[16:22:01.834]                           invokeRestart("muffleMessage")
[16:22:01.834]                       }
[16:22:01.834]                       else if (inherits(cond, "warning")) {
[16:22:01.834]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.834]                         if (muffled) 
[16:22:01.834]                           invokeRestart("muffleWarning")
[16:22:01.834]                       }
[16:22:01.834]                       else if (inherits(cond, "condition")) {
[16:22:01.834]                         if (!is.null(pattern)) {
[16:22:01.834]                           computeRestarts <- base::computeRestarts
[16:22:01.834]                           grepl <- base::grepl
[16:22:01.834]                           restarts <- computeRestarts(cond)
[16:22:01.834]                           for (restart in restarts) {
[16:22:01.834]                             name <- restart$name
[16:22:01.834]                             if (is.null(name)) 
[16:22:01.834]                               next
[16:22:01.834]                             if (!grepl(pattern, name)) 
[16:22:01.834]                               next
[16:22:01.834]                             invokeRestart(restart)
[16:22:01.834]                             muffled <- TRUE
[16:22:01.834]                             break
[16:22:01.834]                           }
[16:22:01.834]                         }
[16:22:01.834]                       }
[16:22:01.834]                       invisible(muffled)
[16:22:01.834]                     }
[16:22:01.834]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.834]                   }
[16:22:01.834]                 }
[16:22:01.834]                 else {
[16:22:01.834]                   if (TRUE) {
[16:22:01.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:01.834]                     {
[16:22:01.834]                       inherits <- base::inherits
[16:22:01.834]                       invokeRestart <- base::invokeRestart
[16:22:01.834]                       is.null <- base::is.null
[16:22:01.834]                       muffled <- FALSE
[16:22:01.834]                       if (inherits(cond, "message")) {
[16:22:01.834]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:01.834]                         if (muffled) 
[16:22:01.834]                           invokeRestart("muffleMessage")
[16:22:01.834]                       }
[16:22:01.834]                       else if (inherits(cond, "warning")) {
[16:22:01.834]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:01.834]                         if (muffled) 
[16:22:01.834]                           invokeRestart("muffleWarning")
[16:22:01.834]                       }
[16:22:01.834]                       else if (inherits(cond, "condition")) {
[16:22:01.834]                         if (!is.null(pattern)) {
[16:22:01.834]                           computeRestarts <- base::computeRestarts
[16:22:01.834]                           grepl <- base::grepl
[16:22:01.834]                           restarts <- computeRestarts(cond)
[16:22:01.834]                           for (restart in restarts) {
[16:22:01.834]                             name <- restart$name
[16:22:01.834]                             if (is.null(name)) 
[16:22:01.834]                               next
[16:22:01.834]                             if (!grepl(pattern, name)) 
[16:22:01.834]                               next
[16:22:01.834]                             invokeRestart(restart)
[16:22:01.834]                             muffled <- TRUE
[16:22:01.834]                             break
[16:22:01.834]                           }
[16:22:01.834]                         }
[16:22:01.834]                       }
[16:22:01.834]                       invisible(muffled)
[16:22:01.834]                     }
[16:22:01.834]                     muffleCondition(cond, pattern = "^muffle")
[16:22:01.834]                   }
[16:22:01.834]                 }
[16:22:01.834]             }
[16:22:01.834]         }))
[16:22:01.834]     }, error = function(ex) {
[16:22:01.834]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:01.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:01.834]                 ...future.rng), started = ...future.startTime, 
[16:22:01.834]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:01.834]             version = "1.8"), class = "FutureResult")
[16:22:01.834]     }, finally = {
[16:22:01.834]         if (!identical(...future.workdir, getwd())) 
[16:22:01.834]             setwd(...future.workdir)
[16:22:01.834]         {
[16:22:01.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:01.834]                 ...future.oldOptions$nwarnings <- NULL
[16:22:01.834]             }
[16:22:01.834]             base::options(...future.oldOptions)
[16:22:01.834]             if (.Platform$OS.type == "windows") {
[16:22:01.834]                 old_names <- names(...future.oldEnvVars)
[16:22:01.834]                 envs <- base::Sys.getenv()
[16:22:01.834]                 names <- names(envs)
[16:22:01.834]                 common <- intersect(names, old_names)
[16:22:01.834]                 added <- setdiff(names, old_names)
[16:22:01.834]                 removed <- setdiff(old_names, names)
[16:22:01.834]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:01.834]                   envs[common]]
[16:22:01.834]                 NAMES <- toupper(changed)
[16:22:01.834]                 args <- list()
[16:22:01.834]                 for (kk in seq_along(NAMES)) {
[16:22:01.834]                   name <- changed[[kk]]
[16:22:01.834]                   NAME <- NAMES[[kk]]
[16:22:01.834]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.834]                     next
[16:22:01.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.834]                 }
[16:22:01.834]                 NAMES <- toupper(added)
[16:22:01.834]                 for (kk in seq_along(NAMES)) {
[16:22:01.834]                   name <- added[[kk]]
[16:22:01.834]                   NAME <- NAMES[[kk]]
[16:22:01.834]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.834]                     next
[16:22:01.834]                   args[[name]] <- ""
[16:22:01.834]                 }
[16:22:01.834]                 NAMES <- toupper(removed)
[16:22:01.834]                 for (kk in seq_along(NAMES)) {
[16:22:01.834]                   name <- removed[[kk]]
[16:22:01.834]                   NAME <- NAMES[[kk]]
[16:22:01.834]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:01.834]                     next
[16:22:01.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:01.834]                 }
[16:22:01.834]                 if (length(args) > 0) 
[16:22:01.834]                   base::do.call(base::Sys.setenv, args = args)
[16:22:01.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:01.834]             }
[16:22:01.834]             else {
[16:22:01.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:01.834]             }
[16:22:01.834]             {
[16:22:01.834]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:01.834]                   0L) {
[16:22:01.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:01.834]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:01.834]                   base::options(opts)
[16:22:01.834]                 }
[16:22:01.834]                 {
[16:22:01.834]                   {
[16:22:01.834]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:01.834]                     NULL
[16:22:01.834]                   }
[16:22:01.834]                   options(future.plan = NULL)
[16:22:01.834]                   if (is.na(NA_character_)) 
[16:22:01.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:01.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:01.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:01.834]                     .init = FALSE)
[16:22:01.834]                 }
[16:22:01.834]             }
[16:22:01.834]         }
[16:22:01.834]     })
[16:22:01.834]     if (TRUE) {
[16:22:01.834]         base::sink(type = "output", split = FALSE)
[16:22:01.834]         if (TRUE) {
[16:22:01.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:01.834]         }
[16:22:01.834]         else {
[16:22:01.834]             ...future.result["stdout"] <- base::list(NULL)
[16:22:01.834]         }
[16:22:01.834]         base::close(...future.stdout)
[16:22:01.834]         ...future.stdout <- NULL
[16:22:01.834]     }
[16:22:01.834]     ...future.result$conditions <- ...future.conditions
[16:22:01.834]     ...future.result$finished <- base::Sys.time()
[16:22:01.834]     ...future.result
[16:22:01.834] }
[16:22:01.837] MultisessionFuture started
[16:22:01.837] - Launch lazy future ... done
[16:22:01.837] run() for ‘MultisessionFuture’ ... done
[16:22:02.340] receiveMessageFromWorker() for ClusterFuture ...
[16:22:02.340] - Validating connection of MultisessionFuture
[16:22:02.340] - received message: FutureResult
[16:22:02.340] - Received FutureResult
[16:22:02.340] - Erased future from FutureRegistry
[16:22:02.340] result() for ClusterFuture ...
[16:22:02.340] - result already collected: FutureResult
[16:22:02.341] result() for ClusterFuture ... done
[16:22:02.341] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:02.341] A MultisessionFuture was resolved
- w/ exception ...
[16:22:02.341] getGlobalsAndPackages() ...
[16:22:02.341] Searching for globals...
[16:22:02.342] - globals found: [2] ‘list’, ‘stop’
[16:22:02.342] Searching for globals ... DONE
[16:22:02.342] Resolving globals: FALSE
[16:22:02.342] 
[16:22:02.342] 
[16:22:02.342] getGlobalsAndPackages() ... DONE
[16:22:02.343] run() for ‘Future’ ...
[16:22:02.343] - state: ‘created’
[16:22:02.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:02.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:02.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:02.358]   - Field: ‘node’
[16:22:02.358]   - Field: ‘label’
[16:22:02.358]   - Field: ‘local’
[16:22:02.358]   - Field: ‘owner’
[16:22:02.358]   - Field: ‘envir’
[16:22:02.358]   - Field: ‘workers’
[16:22:02.358]   - Field: ‘packages’
[16:22:02.358]   - Field: ‘gc’
[16:22:02.358]   - Field: ‘conditions’
[16:22:02.359]   - Field: ‘persistent’
[16:22:02.359]   - Field: ‘expr’
[16:22:02.359]   - Field: ‘uuid’
[16:22:02.359]   - Field: ‘seed’
[16:22:02.359]   - Field: ‘version’
[16:22:02.359]   - Field: ‘result’
[16:22:02.359]   - Field: ‘asynchronous’
[16:22:02.359]   - Field: ‘calls’
[16:22:02.359]   - Field: ‘globals’
[16:22:02.359]   - Field: ‘stdout’
[16:22:02.359]   - Field: ‘earlySignal’
[16:22:02.360]   - Field: ‘lazy’
[16:22:02.360]   - Field: ‘state’
[16:22:02.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:02.360] - Launch lazy future ...
[16:22:02.360] Packages needed by the future expression (n = 0): <none>
[16:22:02.360] Packages needed by future strategies (n = 0): <none>
[16:22:02.361] {
[16:22:02.361]     {
[16:22:02.361]         {
[16:22:02.361]             ...future.startTime <- base::Sys.time()
[16:22:02.361]             {
[16:22:02.361]                 {
[16:22:02.361]                   {
[16:22:02.361]                     {
[16:22:02.361]                       base::local({
[16:22:02.361]                         has_future <- base::requireNamespace("future", 
[16:22:02.361]                           quietly = TRUE)
[16:22:02.361]                         if (has_future) {
[16:22:02.361]                           ns <- base::getNamespace("future")
[16:22:02.361]                           version <- ns[[".package"]][["version"]]
[16:22:02.361]                           if (is.null(version)) 
[16:22:02.361]                             version <- utils::packageVersion("future")
[16:22:02.361]                         }
[16:22:02.361]                         else {
[16:22:02.361]                           version <- NULL
[16:22:02.361]                         }
[16:22:02.361]                         if (!has_future || version < "1.8.0") {
[16:22:02.361]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:02.361]                             "", base::R.version$version.string), 
[16:22:02.361]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:02.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:02.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:02.361]                               "release", "version")], collapse = " "), 
[16:22:02.361]                             hostname = base::Sys.info()[["nodename"]])
[16:22:02.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:02.361]                             info)
[16:22:02.361]                           info <- base::paste(info, collapse = "; ")
[16:22:02.361]                           if (!has_future) {
[16:22:02.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:02.361]                               info)
[16:22:02.361]                           }
[16:22:02.361]                           else {
[16:22:02.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:02.361]                               info, version)
[16:22:02.361]                           }
[16:22:02.361]                           base::stop(msg)
[16:22:02.361]                         }
[16:22:02.361]                       })
[16:22:02.361]                     }
[16:22:02.361]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:02.361]                     base::options(mc.cores = 1L)
[16:22:02.361]                   }
[16:22:02.361]                   ...future.strategy.old <- future::plan("list")
[16:22:02.361]                   options(future.plan = NULL)
[16:22:02.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:02.361]                 }
[16:22:02.361]                 ...future.workdir <- getwd()
[16:22:02.361]             }
[16:22:02.361]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:02.361]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:02.361]         }
[16:22:02.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:02.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:02.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:02.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:02.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:02.361]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:02.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:02.361]             base::names(...future.oldOptions))
[16:22:02.361]     }
[16:22:02.361]     if (FALSE) {
[16:22:02.361]     }
[16:22:02.361]     else {
[16:22:02.361]         if (TRUE) {
[16:22:02.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:02.361]                 open = "w")
[16:22:02.361]         }
[16:22:02.361]         else {
[16:22:02.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:02.361]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:02.361]         }
[16:22:02.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:02.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:02.361]             base::sink(type = "output", split = FALSE)
[16:22:02.361]             base::close(...future.stdout)
[16:22:02.361]         }, add = TRUE)
[16:22:02.361]     }
[16:22:02.361]     ...future.frame <- base::sys.nframe()
[16:22:02.361]     ...future.conditions <- base::list()
[16:22:02.361]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:02.361]     if (FALSE) {
[16:22:02.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:02.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:02.361]     }
[16:22:02.361]     ...future.result <- base::tryCatch({
[16:22:02.361]         base::withCallingHandlers({
[16:22:02.361]             ...future.value <- base::withVisible(base::local({
[16:22:02.361]                 ...future.makeSendCondition <- base::local({
[16:22:02.361]                   sendCondition <- NULL
[16:22:02.361]                   function(frame = 1L) {
[16:22:02.361]                     if (is.function(sendCondition)) 
[16:22:02.361]                       return(sendCondition)
[16:22:02.361]                     ns <- getNamespace("parallel")
[16:22:02.361]                     if (exists("sendData", mode = "function", 
[16:22:02.361]                       envir = ns)) {
[16:22:02.361]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:02.361]                         envir = ns)
[16:22:02.361]                       envir <- sys.frame(frame)
[16:22:02.361]                       master <- NULL
[16:22:02.361]                       while (!identical(envir, .GlobalEnv) && 
[16:22:02.361]                         !identical(envir, emptyenv())) {
[16:22:02.361]                         if (exists("master", mode = "list", envir = envir, 
[16:22:02.361]                           inherits = FALSE)) {
[16:22:02.361]                           master <- get("master", mode = "list", 
[16:22:02.361]                             envir = envir, inherits = FALSE)
[16:22:02.361]                           if (inherits(master, c("SOCKnode", 
[16:22:02.361]                             "SOCK0node"))) {
[16:22:02.361]                             sendCondition <<- function(cond) {
[16:22:02.361]                               data <- list(type = "VALUE", value = cond, 
[16:22:02.361]                                 success = TRUE)
[16:22:02.361]                               parallel_sendData(master, data)
[16:22:02.361]                             }
[16:22:02.361]                             return(sendCondition)
[16:22:02.361]                           }
[16:22:02.361]                         }
[16:22:02.361]                         frame <- frame + 1L
[16:22:02.361]                         envir <- sys.frame(frame)
[16:22:02.361]                       }
[16:22:02.361]                     }
[16:22:02.361]                     sendCondition <<- function(cond) NULL
[16:22:02.361]                   }
[16:22:02.361]                 })
[16:22:02.361]                 withCallingHandlers({
[16:22:02.361]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:02.361]                 }, immediateCondition = function(cond) {
[16:22:02.361]                   sendCondition <- ...future.makeSendCondition()
[16:22:02.361]                   sendCondition(cond)
[16:22:02.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.361]                   {
[16:22:02.361]                     inherits <- base::inherits
[16:22:02.361]                     invokeRestart <- base::invokeRestart
[16:22:02.361]                     is.null <- base::is.null
[16:22:02.361]                     muffled <- FALSE
[16:22:02.361]                     if (inherits(cond, "message")) {
[16:22:02.361]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:02.361]                       if (muffled) 
[16:22:02.361]                         invokeRestart("muffleMessage")
[16:22:02.361]                     }
[16:22:02.361]                     else if (inherits(cond, "warning")) {
[16:22:02.361]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:02.361]                       if (muffled) 
[16:22:02.361]                         invokeRestart("muffleWarning")
[16:22:02.361]                     }
[16:22:02.361]                     else if (inherits(cond, "condition")) {
[16:22:02.361]                       if (!is.null(pattern)) {
[16:22:02.361]                         computeRestarts <- base::computeRestarts
[16:22:02.361]                         grepl <- base::grepl
[16:22:02.361]                         restarts <- computeRestarts(cond)
[16:22:02.361]                         for (restart in restarts) {
[16:22:02.361]                           name <- restart$name
[16:22:02.361]                           if (is.null(name)) 
[16:22:02.361]                             next
[16:22:02.361]                           if (!grepl(pattern, name)) 
[16:22:02.361]                             next
[16:22:02.361]                           invokeRestart(restart)
[16:22:02.361]                           muffled <- TRUE
[16:22:02.361]                           break
[16:22:02.361]                         }
[16:22:02.361]                       }
[16:22:02.361]                     }
[16:22:02.361]                     invisible(muffled)
[16:22:02.361]                   }
[16:22:02.361]                   muffleCondition(cond)
[16:22:02.361]                 })
[16:22:02.361]             }))
[16:22:02.361]             future::FutureResult(value = ...future.value$value, 
[16:22:02.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.361]                   ...future.rng), globalenv = if (FALSE) 
[16:22:02.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:02.361]                     ...future.globalenv.names))
[16:22:02.361]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:02.361]         }, condition = base::local({
[16:22:02.361]             c <- base::c
[16:22:02.361]             inherits <- base::inherits
[16:22:02.361]             invokeRestart <- base::invokeRestart
[16:22:02.361]             length <- base::length
[16:22:02.361]             list <- base::list
[16:22:02.361]             seq.int <- base::seq.int
[16:22:02.361]             signalCondition <- base::signalCondition
[16:22:02.361]             sys.calls <- base::sys.calls
[16:22:02.361]             `[[` <- base::`[[`
[16:22:02.361]             `+` <- base::`+`
[16:22:02.361]             `<<-` <- base::`<<-`
[16:22:02.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:02.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:02.361]                   3L)]
[16:22:02.361]             }
[16:22:02.361]             function(cond) {
[16:22:02.361]                 is_error <- inherits(cond, "error")
[16:22:02.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:02.361]                   NULL)
[16:22:02.361]                 if (is_error) {
[16:22:02.361]                   sessionInformation <- function() {
[16:22:02.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:02.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:02.361]                       search = base::search(), system = base::Sys.info())
[16:22:02.361]                   }
[16:22:02.361]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:02.361]                     cond$call), session = sessionInformation(), 
[16:22:02.361]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:02.361]                   signalCondition(cond)
[16:22:02.361]                 }
[16:22:02.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:02.361]                 "immediateCondition"))) {
[16:22:02.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:02.361]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:02.361]                   if (TRUE && !signal) {
[16:22:02.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.361]                     {
[16:22:02.361]                       inherits <- base::inherits
[16:22:02.361]                       invokeRestart <- base::invokeRestart
[16:22:02.361]                       is.null <- base::is.null
[16:22:02.361]                       muffled <- FALSE
[16:22:02.361]                       if (inherits(cond, "message")) {
[16:22:02.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.361]                         if (muffled) 
[16:22:02.361]                           invokeRestart("muffleMessage")
[16:22:02.361]                       }
[16:22:02.361]                       else if (inherits(cond, "warning")) {
[16:22:02.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.361]                         if (muffled) 
[16:22:02.361]                           invokeRestart("muffleWarning")
[16:22:02.361]                       }
[16:22:02.361]                       else if (inherits(cond, "condition")) {
[16:22:02.361]                         if (!is.null(pattern)) {
[16:22:02.361]                           computeRestarts <- base::computeRestarts
[16:22:02.361]                           grepl <- base::grepl
[16:22:02.361]                           restarts <- computeRestarts(cond)
[16:22:02.361]                           for (restart in restarts) {
[16:22:02.361]                             name <- restart$name
[16:22:02.361]                             if (is.null(name)) 
[16:22:02.361]                               next
[16:22:02.361]                             if (!grepl(pattern, name)) 
[16:22:02.361]                               next
[16:22:02.361]                             invokeRestart(restart)
[16:22:02.361]                             muffled <- TRUE
[16:22:02.361]                             break
[16:22:02.361]                           }
[16:22:02.361]                         }
[16:22:02.361]                       }
[16:22:02.361]                       invisible(muffled)
[16:22:02.361]                     }
[16:22:02.361]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.361]                   }
[16:22:02.361]                 }
[16:22:02.361]                 else {
[16:22:02.361]                   if (TRUE) {
[16:22:02.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.361]                     {
[16:22:02.361]                       inherits <- base::inherits
[16:22:02.361]                       invokeRestart <- base::invokeRestart
[16:22:02.361]                       is.null <- base::is.null
[16:22:02.361]                       muffled <- FALSE
[16:22:02.361]                       if (inherits(cond, "message")) {
[16:22:02.361]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.361]                         if (muffled) 
[16:22:02.361]                           invokeRestart("muffleMessage")
[16:22:02.361]                       }
[16:22:02.361]                       else if (inherits(cond, "warning")) {
[16:22:02.361]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.361]                         if (muffled) 
[16:22:02.361]                           invokeRestart("muffleWarning")
[16:22:02.361]                       }
[16:22:02.361]                       else if (inherits(cond, "condition")) {
[16:22:02.361]                         if (!is.null(pattern)) {
[16:22:02.361]                           computeRestarts <- base::computeRestarts
[16:22:02.361]                           grepl <- base::grepl
[16:22:02.361]                           restarts <- computeRestarts(cond)
[16:22:02.361]                           for (restart in restarts) {
[16:22:02.361]                             name <- restart$name
[16:22:02.361]                             if (is.null(name)) 
[16:22:02.361]                               next
[16:22:02.361]                             if (!grepl(pattern, name)) 
[16:22:02.361]                               next
[16:22:02.361]                             invokeRestart(restart)
[16:22:02.361]                             muffled <- TRUE
[16:22:02.361]                             break
[16:22:02.361]                           }
[16:22:02.361]                         }
[16:22:02.361]                       }
[16:22:02.361]                       invisible(muffled)
[16:22:02.361]                     }
[16:22:02.361]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.361]                   }
[16:22:02.361]                 }
[16:22:02.361]             }
[16:22:02.361]         }))
[16:22:02.361]     }, error = function(ex) {
[16:22:02.361]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:02.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.361]                 ...future.rng), started = ...future.startTime, 
[16:22:02.361]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:02.361]             version = "1.8"), class = "FutureResult")
[16:22:02.361]     }, finally = {
[16:22:02.361]         if (!identical(...future.workdir, getwd())) 
[16:22:02.361]             setwd(...future.workdir)
[16:22:02.361]         {
[16:22:02.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:02.361]                 ...future.oldOptions$nwarnings <- NULL
[16:22:02.361]             }
[16:22:02.361]             base::options(...future.oldOptions)
[16:22:02.361]             if (.Platform$OS.type == "windows") {
[16:22:02.361]                 old_names <- names(...future.oldEnvVars)
[16:22:02.361]                 envs <- base::Sys.getenv()
[16:22:02.361]                 names <- names(envs)
[16:22:02.361]                 common <- intersect(names, old_names)
[16:22:02.361]                 added <- setdiff(names, old_names)
[16:22:02.361]                 removed <- setdiff(old_names, names)
[16:22:02.361]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:02.361]                   envs[common]]
[16:22:02.361]                 NAMES <- toupper(changed)
[16:22:02.361]                 args <- list()
[16:22:02.361]                 for (kk in seq_along(NAMES)) {
[16:22:02.361]                   name <- changed[[kk]]
[16:22:02.361]                   NAME <- NAMES[[kk]]
[16:22:02.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.361]                     next
[16:22:02.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.361]                 }
[16:22:02.361]                 NAMES <- toupper(added)
[16:22:02.361]                 for (kk in seq_along(NAMES)) {
[16:22:02.361]                   name <- added[[kk]]
[16:22:02.361]                   NAME <- NAMES[[kk]]
[16:22:02.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.361]                     next
[16:22:02.361]                   args[[name]] <- ""
[16:22:02.361]                 }
[16:22:02.361]                 NAMES <- toupper(removed)
[16:22:02.361]                 for (kk in seq_along(NAMES)) {
[16:22:02.361]                   name <- removed[[kk]]
[16:22:02.361]                   NAME <- NAMES[[kk]]
[16:22:02.361]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.361]                     next
[16:22:02.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.361]                 }
[16:22:02.361]                 if (length(args) > 0) 
[16:22:02.361]                   base::do.call(base::Sys.setenv, args = args)
[16:22:02.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:02.361]             }
[16:22:02.361]             else {
[16:22:02.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:02.361]             }
[16:22:02.361]             {
[16:22:02.361]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:02.361]                   0L) {
[16:22:02.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:02.361]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:02.361]                   base::options(opts)
[16:22:02.361]                 }
[16:22:02.361]                 {
[16:22:02.361]                   {
[16:22:02.361]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:02.361]                     NULL
[16:22:02.361]                   }
[16:22:02.361]                   options(future.plan = NULL)
[16:22:02.361]                   if (is.na(NA_character_)) 
[16:22:02.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:02.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:02.361]                     .init = FALSE)
[16:22:02.361]                 }
[16:22:02.361]             }
[16:22:02.361]         }
[16:22:02.361]     })
[16:22:02.361]     if (TRUE) {
[16:22:02.361]         base::sink(type = "output", split = FALSE)
[16:22:02.361]         if (TRUE) {
[16:22:02.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:02.361]         }
[16:22:02.361]         else {
[16:22:02.361]             ...future.result["stdout"] <- base::list(NULL)
[16:22:02.361]         }
[16:22:02.361]         base::close(...future.stdout)
[16:22:02.361]         ...future.stdout <- NULL
[16:22:02.361]     }
[16:22:02.361]     ...future.result$conditions <- ...future.conditions
[16:22:02.361]     ...future.result$finished <- base::Sys.time()
[16:22:02.361]     ...future.result
[16:22:02.361] }
[16:22:02.364] MultisessionFuture started
[16:22:02.364] - Launch lazy future ... done
[16:22:02.364] run() for ‘MultisessionFuture’ ... done
[16:22:02.365] receiveMessageFromWorker() for ClusterFuture ...
[16:22:02.366] - Validating connection of MultisessionFuture
[16:22:02.366] - received message: FutureResult
[16:22:02.366] - Received FutureResult
[16:22:02.366] - Erased future from FutureRegistry
[16:22:02.366] result() for ClusterFuture ...
[16:22:02.366] - result already collected: FutureResult
[16:22:02.366] result() for ClusterFuture ... done
[16:22:02.367] signalConditions() ...
[16:22:02.367]  - include = ‘immediateCondition’
[16:22:02.367]  - exclude = 
[16:22:02.367]  - resignal = FALSE
[16:22:02.367]  - Number of conditions: 1
[16:22:02.367] signalConditions() ... done
[16:22:02.367] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:02.367] A MultisessionFuture was resolved
[16:22:02.367] getGlobalsAndPackages() ...
[16:22:02.367] Searching for globals...
[16:22:02.368] - globals found: [2] ‘list’, ‘stop’
[16:22:02.368] Searching for globals ... DONE
[16:22:02.368] Resolving globals: FALSE
[16:22:02.368] 
[16:22:02.369] 
[16:22:02.369] getGlobalsAndPackages() ... DONE
[16:22:02.369] run() for ‘Future’ ...
[16:22:02.369] - state: ‘created’
[16:22:02.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:02.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:02.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:02.384]   - Field: ‘node’
[16:22:02.384]   - Field: ‘label’
[16:22:02.384]   - Field: ‘local’
[16:22:02.384]   - Field: ‘owner’
[16:22:02.385]   - Field: ‘envir’
[16:22:02.385]   - Field: ‘workers’
[16:22:02.385]   - Field: ‘packages’
[16:22:02.385]   - Field: ‘gc’
[16:22:02.385]   - Field: ‘conditions’
[16:22:02.385]   - Field: ‘persistent’
[16:22:02.385]   - Field: ‘expr’
[16:22:02.385]   - Field: ‘uuid’
[16:22:02.385]   - Field: ‘seed’
[16:22:02.385]   - Field: ‘version’
[16:22:02.385]   - Field: ‘result’
[16:22:02.386]   - Field: ‘asynchronous’
[16:22:02.386]   - Field: ‘calls’
[16:22:02.386]   - Field: ‘globals’
[16:22:02.386]   - Field: ‘stdout’
[16:22:02.386]   - Field: ‘earlySignal’
[16:22:02.386]   - Field: ‘lazy’
[16:22:02.386]   - Field: ‘state’
[16:22:02.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:02.386] - Launch lazy future ...
[16:22:02.387] Packages needed by the future expression (n = 0): <none>
[16:22:02.387] Packages needed by future strategies (n = 0): <none>
[16:22:02.387] {
[16:22:02.387]     {
[16:22:02.387]         {
[16:22:02.387]             ...future.startTime <- base::Sys.time()
[16:22:02.387]             {
[16:22:02.387]                 {
[16:22:02.387]                   {
[16:22:02.387]                     {
[16:22:02.387]                       base::local({
[16:22:02.387]                         has_future <- base::requireNamespace("future", 
[16:22:02.387]                           quietly = TRUE)
[16:22:02.387]                         if (has_future) {
[16:22:02.387]                           ns <- base::getNamespace("future")
[16:22:02.387]                           version <- ns[[".package"]][["version"]]
[16:22:02.387]                           if (is.null(version)) 
[16:22:02.387]                             version <- utils::packageVersion("future")
[16:22:02.387]                         }
[16:22:02.387]                         else {
[16:22:02.387]                           version <- NULL
[16:22:02.387]                         }
[16:22:02.387]                         if (!has_future || version < "1.8.0") {
[16:22:02.387]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:02.387]                             "", base::R.version$version.string), 
[16:22:02.387]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:02.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:02.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:02.387]                               "release", "version")], collapse = " "), 
[16:22:02.387]                             hostname = base::Sys.info()[["nodename"]])
[16:22:02.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:02.387]                             info)
[16:22:02.387]                           info <- base::paste(info, collapse = "; ")
[16:22:02.387]                           if (!has_future) {
[16:22:02.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:02.387]                               info)
[16:22:02.387]                           }
[16:22:02.387]                           else {
[16:22:02.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:02.387]                               info, version)
[16:22:02.387]                           }
[16:22:02.387]                           base::stop(msg)
[16:22:02.387]                         }
[16:22:02.387]                       })
[16:22:02.387]                     }
[16:22:02.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:02.387]                     base::options(mc.cores = 1L)
[16:22:02.387]                   }
[16:22:02.387]                   ...future.strategy.old <- future::plan("list")
[16:22:02.387]                   options(future.plan = NULL)
[16:22:02.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:02.387]                 }
[16:22:02.387]                 ...future.workdir <- getwd()
[16:22:02.387]             }
[16:22:02.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:02.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:02.387]         }
[16:22:02.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:02.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:02.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:02.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:02.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:02.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:02.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:02.387]             base::names(...future.oldOptions))
[16:22:02.387]     }
[16:22:02.387]     if (FALSE) {
[16:22:02.387]     }
[16:22:02.387]     else {
[16:22:02.387]         if (TRUE) {
[16:22:02.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:02.387]                 open = "w")
[16:22:02.387]         }
[16:22:02.387]         else {
[16:22:02.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:02.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:02.387]         }
[16:22:02.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:02.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:02.387]             base::sink(type = "output", split = FALSE)
[16:22:02.387]             base::close(...future.stdout)
[16:22:02.387]         }, add = TRUE)
[16:22:02.387]     }
[16:22:02.387]     ...future.frame <- base::sys.nframe()
[16:22:02.387]     ...future.conditions <- base::list()
[16:22:02.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:02.387]     if (FALSE) {
[16:22:02.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:02.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:02.387]     }
[16:22:02.387]     ...future.result <- base::tryCatch({
[16:22:02.387]         base::withCallingHandlers({
[16:22:02.387]             ...future.value <- base::withVisible(base::local({
[16:22:02.387]                 ...future.makeSendCondition <- base::local({
[16:22:02.387]                   sendCondition <- NULL
[16:22:02.387]                   function(frame = 1L) {
[16:22:02.387]                     if (is.function(sendCondition)) 
[16:22:02.387]                       return(sendCondition)
[16:22:02.387]                     ns <- getNamespace("parallel")
[16:22:02.387]                     if (exists("sendData", mode = "function", 
[16:22:02.387]                       envir = ns)) {
[16:22:02.387]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:02.387]                         envir = ns)
[16:22:02.387]                       envir <- sys.frame(frame)
[16:22:02.387]                       master <- NULL
[16:22:02.387]                       while (!identical(envir, .GlobalEnv) && 
[16:22:02.387]                         !identical(envir, emptyenv())) {
[16:22:02.387]                         if (exists("master", mode = "list", envir = envir, 
[16:22:02.387]                           inherits = FALSE)) {
[16:22:02.387]                           master <- get("master", mode = "list", 
[16:22:02.387]                             envir = envir, inherits = FALSE)
[16:22:02.387]                           if (inherits(master, c("SOCKnode", 
[16:22:02.387]                             "SOCK0node"))) {
[16:22:02.387]                             sendCondition <<- function(cond) {
[16:22:02.387]                               data <- list(type = "VALUE", value = cond, 
[16:22:02.387]                                 success = TRUE)
[16:22:02.387]                               parallel_sendData(master, data)
[16:22:02.387]                             }
[16:22:02.387]                             return(sendCondition)
[16:22:02.387]                           }
[16:22:02.387]                         }
[16:22:02.387]                         frame <- frame + 1L
[16:22:02.387]                         envir <- sys.frame(frame)
[16:22:02.387]                       }
[16:22:02.387]                     }
[16:22:02.387]                     sendCondition <<- function(cond) NULL
[16:22:02.387]                   }
[16:22:02.387]                 })
[16:22:02.387]                 withCallingHandlers({
[16:22:02.387]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:02.387]                 }, immediateCondition = function(cond) {
[16:22:02.387]                   sendCondition <- ...future.makeSendCondition()
[16:22:02.387]                   sendCondition(cond)
[16:22:02.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.387]                   {
[16:22:02.387]                     inherits <- base::inherits
[16:22:02.387]                     invokeRestart <- base::invokeRestart
[16:22:02.387]                     is.null <- base::is.null
[16:22:02.387]                     muffled <- FALSE
[16:22:02.387]                     if (inherits(cond, "message")) {
[16:22:02.387]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:02.387]                       if (muffled) 
[16:22:02.387]                         invokeRestart("muffleMessage")
[16:22:02.387]                     }
[16:22:02.387]                     else if (inherits(cond, "warning")) {
[16:22:02.387]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:02.387]                       if (muffled) 
[16:22:02.387]                         invokeRestart("muffleWarning")
[16:22:02.387]                     }
[16:22:02.387]                     else if (inherits(cond, "condition")) {
[16:22:02.387]                       if (!is.null(pattern)) {
[16:22:02.387]                         computeRestarts <- base::computeRestarts
[16:22:02.387]                         grepl <- base::grepl
[16:22:02.387]                         restarts <- computeRestarts(cond)
[16:22:02.387]                         for (restart in restarts) {
[16:22:02.387]                           name <- restart$name
[16:22:02.387]                           if (is.null(name)) 
[16:22:02.387]                             next
[16:22:02.387]                           if (!grepl(pattern, name)) 
[16:22:02.387]                             next
[16:22:02.387]                           invokeRestart(restart)
[16:22:02.387]                           muffled <- TRUE
[16:22:02.387]                           break
[16:22:02.387]                         }
[16:22:02.387]                       }
[16:22:02.387]                     }
[16:22:02.387]                     invisible(muffled)
[16:22:02.387]                   }
[16:22:02.387]                   muffleCondition(cond)
[16:22:02.387]                 })
[16:22:02.387]             }))
[16:22:02.387]             future::FutureResult(value = ...future.value$value, 
[16:22:02.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.387]                   ...future.rng), globalenv = if (FALSE) 
[16:22:02.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:02.387]                     ...future.globalenv.names))
[16:22:02.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:02.387]         }, condition = base::local({
[16:22:02.387]             c <- base::c
[16:22:02.387]             inherits <- base::inherits
[16:22:02.387]             invokeRestart <- base::invokeRestart
[16:22:02.387]             length <- base::length
[16:22:02.387]             list <- base::list
[16:22:02.387]             seq.int <- base::seq.int
[16:22:02.387]             signalCondition <- base::signalCondition
[16:22:02.387]             sys.calls <- base::sys.calls
[16:22:02.387]             `[[` <- base::`[[`
[16:22:02.387]             `+` <- base::`+`
[16:22:02.387]             `<<-` <- base::`<<-`
[16:22:02.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:02.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:02.387]                   3L)]
[16:22:02.387]             }
[16:22:02.387]             function(cond) {
[16:22:02.387]                 is_error <- inherits(cond, "error")
[16:22:02.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:02.387]                   NULL)
[16:22:02.387]                 if (is_error) {
[16:22:02.387]                   sessionInformation <- function() {
[16:22:02.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:02.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:02.387]                       search = base::search(), system = base::Sys.info())
[16:22:02.387]                   }
[16:22:02.387]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:02.387]                     cond$call), session = sessionInformation(), 
[16:22:02.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:02.387]                   signalCondition(cond)
[16:22:02.387]                 }
[16:22:02.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:02.387]                 "immediateCondition"))) {
[16:22:02.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:02.387]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:02.387]                   if (TRUE && !signal) {
[16:22:02.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.387]                     {
[16:22:02.387]                       inherits <- base::inherits
[16:22:02.387]                       invokeRestart <- base::invokeRestart
[16:22:02.387]                       is.null <- base::is.null
[16:22:02.387]                       muffled <- FALSE
[16:22:02.387]                       if (inherits(cond, "message")) {
[16:22:02.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.387]                         if (muffled) 
[16:22:02.387]                           invokeRestart("muffleMessage")
[16:22:02.387]                       }
[16:22:02.387]                       else if (inherits(cond, "warning")) {
[16:22:02.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.387]                         if (muffled) 
[16:22:02.387]                           invokeRestart("muffleWarning")
[16:22:02.387]                       }
[16:22:02.387]                       else if (inherits(cond, "condition")) {
[16:22:02.387]                         if (!is.null(pattern)) {
[16:22:02.387]                           computeRestarts <- base::computeRestarts
[16:22:02.387]                           grepl <- base::grepl
[16:22:02.387]                           restarts <- computeRestarts(cond)
[16:22:02.387]                           for (restart in restarts) {
[16:22:02.387]                             name <- restart$name
[16:22:02.387]                             if (is.null(name)) 
[16:22:02.387]                               next
[16:22:02.387]                             if (!grepl(pattern, name)) 
[16:22:02.387]                               next
[16:22:02.387]                             invokeRestart(restart)
[16:22:02.387]                             muffled <- TRUE
[16:22:02.387]                             break
[16:22:02.387]                           }
[16:22:02.387]                         }
[16:22:02.387]                       }
[16:22:02.387]                       invisible(muffled)
[16:22:02.387]                     }
[16:22:02.387]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.387]                   }
[16:22:02.387]                 }
[16:22:02.387]                 else {
[16:22:02.387]                   if (TRUE) {
[16:22:02.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.387]                     {
[16:22:02.387]                       inherits <- base::inherits
[16:22:02.387]                       invokeRestart <- base::invokeRestart
[16:22:02.387]                       is.null <- base::is.null
[16:22:02.387]                       muffled <- FALSE
[16:22:02.387]                       if (inherits(cond, "message")) {
[16:22:02.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.387]                         if (muffled) 
[16:22:02.387]                           invokeRestart("muffleMessage")
[16:22:02.387]                       }
[16:22:02.387]                       else if (inherits(cond, "warning")) {
[16:22:02.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.387]                         if (muffled) 
[16:22:02.387]                           invokeRestart("muffleWarning")
[16:22:02.387]                       }
[16:22:02.387]                       else if (inherits(cond, "condition")) {
[16:22:02.387]                         if (!is.null(pattern)) {
[16:22:02.387]                           computeRestarts <- base::computeRestarts
[16:22:02.387]                           grepl <- base::grepl
[16:22:02.387]                           restarts <- computeRestarts(cond)
[16:22:02.387]                           for (restart in restarts) {
[16:22:02.387]                             name <- restart$name
[16:22:02.387]                             if (is.null(name)) 
[16:22:02.387]                               next
[16:22:02.387]                             if (!grepl(pattern, name)) 
[16:22:02.387]                               next
[16:22:02.387]                             invokeRestart(restart)
[16:22:02.387]                             muffled <- TRUE
[16:22:02.387]                             break
[16:22:02.387]                           }
[16:22:02.387]                         }
[16:22:02.387]                       }
[16:22:02.387]                       invisible(muffled)
[16:22:02.387]                     }
[16:22:02.387]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.387]                   }
[16:22:02.387]                 }
[16:22:02.387]             }
[16:22:02.387]         }))
[16:22:02.387]     }, error = function(ex) {
[16:22:02.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:02.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.387]                 ...future.rng), started = ...future.startTime, 
[16:22:02.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:02.387]             version = "1.8"), class = "FutureResult")
[16:22:02.387]     }, finally = {
[16:22:02.387]         if (!identical(...future.workdir, getwd())) 
[16:22:02.387]             setwd(...future.workdir)
[16:22:02.387]         {
[16:22:02.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:02.387]                 ...future.oldOptions$nwarnings <- NULL
[16:22:02.387]             }
[16:22:02.387]             base::options(...future.oldOptions)
[16:22:02.387]             if (.Platform$OS.type == "windows") {
[16:22:02.387]                 old_names <- names(...future.oldEnvVars)
[16:22:02.387]                 envs <- base::Sys.getenv()
[16:22:02.387]                 names <- names(envs)
[16:22:02.387]                 common <- intersect(names, old_names)
[16:22:02.387]                 added <- setdiff(names, old_names)
[16:22:02.387]                 removed <- setdiff(old_names, names)
[16:22:02.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:02.387]                   envs[common]]
[16:22:02.387]                 NAMES <- toupper(changed)
[16:22:02.387]                 args <- list()
[16:22:02.387]                 for (kk in seq_along(NAMES)) {
[16:22:02.387]                   name <- changed[[kk]]
[16:22:02.387]                   NAME <- NAMES[[kk]]
[16:22:02.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.387]                     next
[16:22:02.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.387]                 }
[16:22:02.387]                 NAMES <- toupper(added)
[16:22:02.387]                 for (kk in seq_along(NAMES)) {
[16:22:02.387]                   name <- added[[kk]]
[16:22:02.387]                   NAME <- NAMES[[kk]]
[16:22:02.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.387]                     next
[16:22:02.387]                   args[[name]] <- ""
[16:22:02.387]                 }
[16:22:02.387]                 NAMES <- toupper(removed)
[16:22:02.387]                 for (kk in seq_along(NAMES)) {
[16:22:02.387]                   name <- removed[[kk]]
[16:22:02.387]                   NAME <- NAMES[[kk]]
[16:22:02.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.387]                     next
[16:22:02.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.387]                 }
[16:22:02.387]                 if (length(args) > 0) 
[16:22:02.387]                   base::do.call(base::Sys.setenv, args = args)
[16:22:02.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:02.387]             }
[16:22:02.387]             else {
[16:22:02.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:02.387]             }
[16:22:02.387]             {
[16:22:02.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:02.387]                   0L) {
[16:22:02.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:02.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:02.387]                   base::options(opts)
[16:22:02.387]                 }
[16:22:02.387]                 {
[16:22:02.387]                   {
[16:22:02.387]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:02.387]                     NULL
[16:22:02.387]                   }
[16:22:02.387]                   options(future.plan = NULL)
[16:22:02.387]                   if (is.na(NA_character_)) 
[16:22:02.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:02.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:02.387]                     .init = FALSE)
[16:22:02.387]                 }
[16:22:02.387]             }
[16:22:02.387]         }
[16:22:02.387]     })
[16:22:02.387]     if (TRUE) {
[16:22:02.387]         base::sink(type = "output", split = FALSE)
[16:22:02.387]         if (TRUE) {
[16:22:02.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:02.387]         }
[16:22:02.387]         else {
[16:22:02.387]             ...future.result["stdout"] <- base::list(NULL)
[16:22:02.387]         }
[16:22:02.387]         base::close(...future.stdout)
[16:22:02.387]         ...future.stdout <- NULL
[16:22:02.387]     }
[16:22:02.387]     ...future.result$conditions <- ...future.conditions
[16:22:02.387]     ...future.result$finished <- base::Sys.time()
[16:22:02.387]     ...future.result
[16:22:02.387] }
[16:22:02.390] MultisessionFuture started
[16:22:02.390] - Launch lazy future ... done
[16:22:02.390] run() for ‘MultisessionFuture’ ... done
[16:22:02.392] receiveMessageFromWorker() for ClusterFuture ...
[16:22:02.392] - Validating connection of MultisessionFuture
[16:22:02.392] - received message: FutureResult
[16:22:02.393] - Received FutureResult
[16:22:02.393] - Erased future from FutureRegistry
[16:22:02.393] result() for ClusterFuture ...
[16:22:02.393] - result already collected: FutureResult
[16:22:02.393] result() for ClusterFuture ... done
[16:22:02.393] signalConditions() ...
[16:22:02.393]  - include = ‘immediateCondition’
[16:22:02.393]  - exclude = 
[16:22:02.393]  - resignal = FALSE
[16:22:02.393]  - Number of conditions: 1
[16:22:02.394] signalConditions() ... done
[16:22:02.394] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:02.394] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[16:22:02.394] getGlobalsAndPackages() ...
[16:22:02.394] Searching for globals...
[16:22:02.395] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:02.395] Searching for globals ... DONE
[16:22:02.395] Resolving globals: FALSE
[16:22:02.396] 
[16:22:02.396] 
[16:22:02.396] getGlobalsAndPackages() ... DONE
[16:22:02.396] run() for ‘Future’ ...
[16:22:02.396] - state: ‘created’
[16:22:02.396] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:02.410] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:02.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:02.410]   - Field: ‘node’
[16:22:02.410]   - Field: ‘label’
[16:22:02.410]   - Field: ‘local’
[16:22:02.410]   - Field: ‘owner’
[16:22:02.410]   - Field: ‘envir’
[16:22:02.410]   - Field: ‘workers’
[16:22:02.410]   - Field: ‘packages’
[16:22:02.411]   - Field: ‘gc’
[16:22:02.411]   - Field: ‘conditions’
[16:22:02.411]   - Field: ‘persistent’
[16:22:02.411]   - Field: ‘expr’
[16:22:02.411]   - Field: ‘uuid’
[16:22:02.411]   - Field: ‘seed’
[16:22:02.411]   - Field: ‘version’
[16:22:02.411]   - Field: ‘result’
[16:22:02.411]   - Field: ‘asynchronous’
[16:22:02.411]   - Field: ‘calls’
[16:22:02.411]   - Field: ‘globals’
[16:22:02.412]   - Field: ‘stdout’
[16:22:02.412]   - Field: ‘earlySignal’
[16:22:02.412]   - Field: ‘lazy’
[16:22:02.412]   - Field: ‘state’
[16:22:02.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:02.412] - Launch lazy future ...
[16:22:02.412] Packages needed by the future expression (n = 0): <none>
[16:22:02.412] Packages needed by future strategies (n = 0): <none>
[16:22:02.413] {
[16:22:02.413]     {
[16:22:02.413]         {
[16:22:02.413]             ...future.startTime <- base::Sys.time()
[16:22:02.413]             {
[16:22:02.413]                 {
[16:22:02.413]                   {
[16:22:02.413]                     {
[16:22:02.413]                       base::local({
[16:22:02.413]                         has_future <- base::requireNamespace("future", 
[16:22:02.413]                           quietly = TRUE)
[16:22:02.413]                         if (has_future) {
[16:22:02.413]                           ns <- base::getNamespace("future")
[16:22:02.413]                           version <- ns[[".package"]][["version"]]
[16:22:02.413]                           if (is.null(version)) 
[16:22:02.413]                             version <- utils::packageVersion("future")
[16:22:02.413]                         }
[16:22:02.413]                         else {
[16:22:02.413]                           version <- NULL
[16:22:02.413]                         }
[16:22:02.413]                         if (!has_future || version < "1.8.0") {
[16:22:02.413]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:02.413]                             "", base::R.version$version.string), 
[16:22:02.413]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:02.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:02.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:02.413]                               "release", "version")], collapse = " "), 
[16:22:02.413]                             hostname = base::Sys.info()[["nodename"]])
[16:22:02.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:02.413]                             info)
[16:22:02.413]                           info <- base::paste(info, collapse = "; ")
[16:22:02.413]                           if (!has_future) {
[16:22:02.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:02.413]                               info)
[16:22:02.413]                           }
[16:22:02.413]                           else {
[16:22:02.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:02.413]                               info, version)
[16:22:02.413]                           }
[16:22:02.413]                           base::stop(msg)
[16:22:02.413]                         }
[16:22:02.413]                       })
[16:22:02.413]                     }
[16:22:02.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:02.413]                     base::options(mc.cores = 1L)
[16:22:02.413]                   }
[16:22:02.413]                   ...future.strategy.old <- future::plan("list")
[16:22:02.413]                   options(future.plan = NULL)
[16:22:02.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:02.413]                 }
[16:22:02.413]                 ...future.workdir <- getwd()
[16:22:02.413]             }
[16:22:02.413]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:02.413]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:02.413]         }
[16:22:02.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:02.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:02.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:02.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:02.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:02.413]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:02.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:02.413]             base::names(...future.oldOptions))
[16:22:02.413]     }
[16:22:02.413]     if (FALSE) {
[16:22:02.413]     }
[16:22:02.413]     else {
[16:22:02.413]         if (TRUE) {
[16:22:02.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:02.413]                 open = "w")
[16:22:02.413]         }
[16:22:02.413]         else {
[16:22:02.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:02.413]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:02.413]         }
[16:22:02.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:02.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:02.413]             base::sink(type = "output", split = FALSE)
[16:22:02.413]             base::close(...future.stdout)
[16:22:02.413]         }, add = TRUE)
[16:22:02.413]     }
[16:22:02.413]     ...future.frame <- base::sys.nframe()
[16:22:02.413]     ...future.conditions <- base::list()
[16:22:02.413]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:02.413]     if (FALSE) {
[16:22:02.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:02.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:02.413]     }
[16:22:02.413]     ...future.result <- base::tryCatch({
[16:22:02.413]         base::withCallingHandlers({
[16:22:02.413]             ...future.value <- base::withVisible(base::local({
[16:22:02.413]                 ...future.makeSendCondition <- base::local({
[16:22:02.413]                   sendCondition <- NULL
[16:22:02.413]                   function(frame = 1L) {
[16:22:02.413]                     if (is.function(sendCondition)) 
[16:22:02.413]                       return(sendCondition)
[16:22:02.413]                     ns <- getNamespace("parallel")
[16:22:02.413]                     if (exists("sendData", mode = "function", 
[16:22:02.413]                       envir = ns)) {
[16:22:02.413]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:02.413]                         envir = ns)
[16:22:02.413]                       envir <- sys.frame(frame)
[16:22:02.413]                       master <- NULL
[16:22:02.413]                       while (!identical(envir, .GlobalEnv) && 
[16:22:02.413]                         !identical(envir, emptyenv())) {
[16:22:02.413]                         if (exists("master", mode = "list", envir = envir, 
[16:22:02.413]                           inherits = FALSE)) {
[16:22:02.413]                           master <- get("master", mode = "list", 
[16:22:02.413]                             envir = envir, inherits = FALSE)
[16:22:02.413]                           if (inherits(master, c("SOCKnode", 
[16:22:02.413]                             "SOCK0node"))) {
[16:22:02.413]                             sendCondition <<- function(cond) {
[16:22:02.413]                               data <- list(type = "VALUE", value = cond, 
[16:22:02.413]                                 success = TRUE)
[16:22:02.413]                               parallel_sendData(master, data)
[16:22:02.413]                             }
[16:22:02.413]                             return(sendCondition)
[16:22:02.413]                           }
[16:22:02.413]                         }
[16:22:02.413]                         frame <- frame + 1L
[16:22:02.413]                         envir <- sys.frame(frame)
[16:22:02.413]                       }
[16:22:02.413]                     }
[16:22:02.413]                     sendCondition <<- function(cond) NULL
[16:22:02.413]                   }
[16:22:02.413]                 })
[16:22:02.413]                 withCallingHandlers({
[16:22:02.413]                   {
[16:22:02.413]                     Sys.sleep(0.5)
[16:22:02.413]                     list(a = 1, b = 42L)
[16:22:02.413]                   }
[16:22:02.413]                 }, immediateCondition = function(cond) {
[16:22:02.413]                   sendCondition <- ...future.makeSendCondition()
[16:22:02.413]                   sendCondition(cond)
[16:22:02.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.413]                   {
[16:22:02.413]                     inherits <- base::inherits
[16:22:02.413]                     invokeRestart <- base::invokeRestart
[16:22:02.413]                     is.null <- base::is.null
[16:22:02.413]                     muffled <- FALSE
[16:22:02.413]                     if (inherits(cond, "message")) {
[16:22:02.413]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:02.413]                       if (muffled) 
[16:22:02.413]                         invokeRestart("muffleMessage")
[16:22:02.413]                     }
[16:22:02.413]                     else if (inherits(cond, "warning")) {
[16:22:02.413]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:02.413]                       if (muffled) 
[16:22:02.413]                         invokeRestart("muffleWarning")
[16:22:02.413]                     }
[16:22:02.413]                     else if (inherits(cond, "condition")) {
[16:22:02.413]                       if (!is.null(pattern)) {
[16:22:02.413]                         computeRestarts <- base::computeRestarts
[16:22:02.413]                         grepl <- base::grepl
[16:22:02.413]                         restarts <- computeRestarts(cond)
[16:22:02.413]                         for (restart in restarts) {
[16:22:02.413]                           name <- restart$name
[16:22:02.413]                           if (is.null(name)) 
[16:22:02.413]                             next
[16:22:02.413]                           if (!grepl(pattern, name)) 
[16:22:02.413]                             next
[16:22:02.413]                           invokeRestart(restart)
[16:22:02.413]                           muffled <- TRUE
[16:22:02.413]                           break
[16:22:02.413]                         }
[16:22:02.413]                       }
[16:22:02.413]                     }
[16:22:02.413]                     invisible(muffled)
[16:22:02.413]                   }
[16:22:02.413]                   muffleCondition(cond)
[16:22:02.413]                 })
[16:22:02.413]             }))
[16:22:02.413]             future::FutureResult(value = ...future.value$value, 
[16:22:02.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.413]                   ...future.rng), globalenv = if (FALSE) 
[16:22:02.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:02.413]                     ...future.globalenv.names))
[16:22:02.413]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:02.413]         }, condition = base::local({
[16:22:02.413]             c <- base::c
[16:22:02.413]             inherits <- base::inherits
[16:22:02.413]             invokeRestart <- base::invokeRestart
[16:22:02.413]             length <- base::length
[16:22:02.413]             list <- base::list
[16:22:02.413]             seq.int <- base::seq.int
[16:22:02.413]             signalCondition <- base::signalCondition
[16:22:02.413]             sys.calls <- base::sys.calls
[16:22:02.413]             `[[` <- base::`[[`
[16:22:02.413]             `+` <- base::`+`
[16:22:02.413]             `<<-` <- base::`<<-`
[16:22:02.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:02.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:02.413]                   3L)]
[16:22:02.413]             }
[16:22:02.413]             function(cond) {
[16:22:02.413]                 is_error <- inherits(cond, "error")
[16:22:02.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:02.413]                   NULL)
[16:22:02.413]                 if (is_error) {
[16:22:02.413]                   sessionInformation <- function() {
[16:22:02.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:02.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:02.413]                       search = base::search(), system = base::Sys.info())
[16:22:02.413]                   }
[16:22:02.413]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:02.413]                     cond$call), session = sessionInformation(), 
[16:22:02.413]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:02.413]                   signalCondition(cond)
[16:22:02.413]                 }
[16:22:02.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:02.413]                 "immediateCondition"))) {
[16:22:02.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:02.413]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:02.413]                   if (TRUE && !signal) {
[16:22:02.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.413]                     {
[16:22:02.413]                       inherits <- base::inherits
[16:22:02.413]                       invokeRestart <- base::invokeRestart
[16:22:02.413]                       is.null <- base::is.null
[16:22:02.413]                       muffled <- FALSE
[16:22:02.413]                       if (inherits(cond, "message")) {
[16:22:02.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.413]                         if (muffled) 
[16:22:02.413]                           invokeRestart("muffleMessage")
[16:22:02.413]                       }
[16:22:02.413]                       else if (inherits(cond, "warning")) {
[16:22:02.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.413]                         if (muffled) 
[16:22:02.413]                           invokeRestart("muffleWarning")
[16:22:02.413]                       }
[16:22:02.413]                       else if (inherits(cond, "condition")) {
[16:22:02.413]                         if (!is.null(pattern)) {
[16:22:02.413]                           computeRestarts <- base::computeRestarts
[16:22:02.413]                           grepl <- base::grepl
[16:22:02.413]                           restarts <- computeRestarts(cond)
[16:22:02.413]                           for (restart in restarts) {
[16:22:02.413]                             name <- restart$name
[16:22:02.413]                             if (is.null(name)) 
[16:22:02.413]                               next
[16:22:02.413]                             if (!grepl(pattern, name)) 
[16:22:02.413]                               next
[16:22:02.413]                             invokeRestart(restart)
[16:22:02.413]                             muffled <- TRUE
[16:22:02.413]                             break
[16:22:02.413]                           }
[16:22:02.413]                         }
[16:22:02.413]                       }
[16:22:02.413]                       invisible(muffled)
[16:22:02.413]                     }
[16:22:02.413]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.413]                   }
[16:22:02.413]                 }
[16:22:02.413]                 else {
[16:22:02.413]                   if (TRUE) {
[16:22:02.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.413]                     {
[16:22:02.413]                       inherits <- base::inherits
[16:22:02.413]                       invokeRestart <- base::invokeRestart
[16:22:02.413]                       is.null <- base::is.null
[16:22:02.413]                       muffled <- FALSE
[16:22:02.413]                       if (inherits(cond, "message")) {
[16:22:02.413]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.413]                         if (muffled) 
[16:22:02.413]                           invokeRestart("muffleMessage")
[16:22:02.413]                       }
[16:22:02.413]                       else if (inherits(cond, "warning")) {
[16:22:02.413]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.413]                         if (muffled) 
[16:22:02.413]                           invokeRestart("muffleWarning")
[16:22:02.413]                       }
[16:22:02.413]                       else if (inherits(cond, "condition")) {
[16:22:02.413]                         if (!is.null(pattern)) {
[16:22:02.413]                           computeRestarts <- base::computeRestarts
[16:22:02.413]                           grepl <- base::grepl
[16:22:02.413]                           restarts <- computeRestarts(cond)
[16:22:02.413]                           for (restart in restarts) {
[16:22:02.413]                             name <- restart$name
[16:22:02.413]                             if (is.null(name)) 
[16:22:02.413]                               next
[16:22:02.413]                             if (!grepl(pattern, name)) 
[16:22:02.413]                               next
[16:22:02.413]                             invokeRestart(restart)
[16:22:02.413]                             muffled <- TRUE
[16:22:02.413]                             break
[16:22:02.413]                           }
[16:22:02.413]                         }
[16:22:02.413]                       }
[16:22:02.413]                       invisible(muffled)
[16:22:02.413]                     }
[16:22:02.413]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.413]                   }
[16:22:02.413]                 }
[16:22:02.413]             }
[16:22:02.413]         }))
[16:22:02.413]     }, error = function(ex) {
[16:22:02.413]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:02.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.413]                 ...future.rng), started = ...future.startTime, 
[16:22:02.413]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:02.413]             version = "1.8"), class = "FutureResult")
[16:22:02.413]     }, finally = {
[16:22:02.413]         if (!identical(...future.workdir, getwd())) 
[16:22:02.413]             setwd(...future.workdir)
[16:22:02.413]         {
[16:22:02.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:02.413]                 ...future.oldOptions$nwarnings <- NULL
[16:22:02.413]             }
[16:22:02.413]             base::options(...future.oldOptions)
[16:22:02.413]             if (.Platform$OS.type == "windows") {
[16:22:02.413]                 old_names <- names(...future.oldEnvVars)
[16:22:02.413]                 envs <- base::Sys.getenv()
[16:22:02.413]                 names <- names(envs)
[16:22:02.413]                 common <- intersect(names, old_names)
[16:22:02.413]                 added <- setdiff(names, old_names)
[16:22:02.413]                 removed <- setdiff(old_names, names)
[16:22:02.413]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:02.413]                   envs[common]]
[16:22:02.413]                 NAMES <- toupper(changed)
[16:22:02.413]                 args <- list()
[16:22:02.413]                 for (kk in seq_along(NAMES)) {
[16:22:02.413]                   name <- changed[[kk]]
[16:22:02.413]                   NAME <- NAMES[[kk]]
[16:22:02.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.413]                     next
[16:22:02.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.413]                 }
[16:22:02.413]                 NAMES <- toupper(added)
[16:22:02.413]                 for (kk in seq_along(NAMES)) {
[16:22:02.413]                   name <- added[[kk]]
[16:22:02.413]                   NAME <- NAMES[[kk]]
[16:22:02.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.413]                     next
[16:22:02.413]                   args[[name]] <- ""
[16:22:02.413]                 }
[16:22:02.413]                 NAMES <- toupper(removed)
[16:22:02.413]                 for (kk in seq_along(NAMES)) {
[16:22:02.413]                   name <- removed[[kk]]
[16:22:02.413]                   NAME <- NAMES[[kk]]
[16:22:02.413]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.413]                     next
[16:22:02.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.413]                 }
[16:22:02.413]                 if (length(args) > 0) 
[16:22:02.413]                   base::do.call(base::Sys.setenv, args = args)
[16:22:02.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:02.413]             }
[16:22:02.413]             else {
[16:22:02.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:02.413]             }
[16:22:02.413]             {
[16:22:02.413]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:02.413]                   0L) {
[16:22:02.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:02.413]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:02.413]                   base::options(opts)
[16:22:02.413]                 }
[16:22:02.413]                 {
[16:22:02.413]                   {
[16:22:02.413]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:02.413]                     NULL
[16:22:02.413]                   }
[16:22:02.413]                   options(future.plan = NULL)
[16:22:02.413]                   if (is.na(NA_character_)) 
[16:22:02.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:02.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:02.413]                     .init = FALSE)
[16:22:02.413]                 }
[16:22:02.413]             }
[16:22:02.413]         }
[16:22:02.413]     })
[16:22:02.413]     if (TRUE) {
[16:22:02.413]         base::sink(type = "output", split = FALSE)
[16:22:02.413]         if (TRUE) {
[16:22:02.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:02.413]         }
[16:22:02.413]         else {
[16:22:02.413]             ...future.result["stdout"] <- base::list(NULL)
[16:22:02.413]         }
[16:22:02.413]         base::close(...future.stdout)
[16:22:02.413]         ...future.stdout <- NULL
[16:22:02.413]     }
[16:22:02.413]     ...future.result$conditions <- ...future.conditions
[16:22:02.413]     ...future.result$finished <- base::Sys.time()
[16:22:02.413]     ...future.result
[16:22:02.413] }
[16:22:02.416] MultisessionFuture started
[16:22:02.416] - Launch lazy future ... done
[16:22:02.416] run() for ‘MultisessionFuture’ ... done
[16:22:02.918] receiveMessageFromWorker() for ClusterFuture ...
[16:22:02.918] - Validating connection of MultisessionFuture
[16:22:02.919] - received message: FutureResult
[16:22:02.919] - Received FutureResult
[16:22:02.919] - Erased future from FutureRegistry
[16:22:02.919] result() for ClusterFuture ...
[16:22:02.919] - result already collected: FutureResult
[16:22:02.919] result() for ClusterFuture ... done
[16:22:02.919] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:02.919] resolve() on list ...
[16:22:02.919]  recursive: 98
[16:22:02.920]  length: 2
[16:22:02.920]  elements: ‘a’, ‘b’
[16:22:02.920]  length: 1 (resolved future 1)
[16:22:02.920]  length: 0 (resolved future 2)
[16:22:02.920] resolve() on list ... DONE
[16:22:02.920] A MultisessionFuture was resolved (and resolved itself)
[16:22:02.920] getGlobalsAndPackages() ...
[16:22:02.920] Searching for globals...
[16:22:02.922] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:02.922] Searching for globals ... DONE
[16:22:02.922] Resolving globals: FALSE
[16:22:02.922] 
[16:22:02.922] 
[16:22:02.922] getGlobalsAndPackages() ... DONE
[16:22:02.923] run() for ‘Future’ ...
[16:22:02.923] - state: ‘created’
[16:22:02.923] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:02.937] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:02.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:02.937]   - Field: ‘node’
[16:22:02.937]   - Field: ‘label’
[16:22:02.937]   - Field: ‘local’
[16:22:02.937]   - Field: ‘owner’
[16:22:02.937]   - Field: ‘envir’
[16:22:02.938]   - Field: ‘workers’
[16:22:02.938]   - Field: ‘packages’
[16:22:02.938]   - Field: ‘gc’
[16:22:02.938]   - Field: ‘conditions’
[16:22:02.938]   - Field: ‘persistent’
[16:22:02.938]   - Field: ‘expr’
[16:22:02.938]   - Field: ‘uuid’
[16:22:02.938]   - Field: ‘seed’
[16:22:02.938]   - Field: ‘version’
[16:22:02.938]   - Field: ‘result’
[16:22:02.938]   - Field: ‘asynchronous’
[16:22:02.939]   - Field: ‘calls’
[16:22:02.939]   - Field: ‘globals’
[16:22:02.939]   - Field: ‘stdout’
[16:22:02.939]   - Field: ‘earlySignal’
[16:22:02.939]   - Field: ‘lazy’
[16:22:02.939]   - Field: ‘state’
[16:22:02.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:02.939] - Launch lazy future ...
[16:22:02.939] Packages needed by the future expression (n = 0): <none>
[16:22:02.940] Packages needed by future strategies (n = 0): <none>
[16:22:02.940] {
[16:22:02.940]     {
[16:22:02.940]         {
[16:22:02.940]             ...future.startTime <- base::Sys.time()
[16:22:02.940]             {
[16:22:02.940]                 {
[16:22:02.940]                   {
[16:22:02.940]                     {
[16:22:02.940]                       base::local({
[16:22:02.940]                         has_future <- base::requireNamespace("future", 
[16:22:02.940]                           quietly = TRUE)
[16:22:02.940]                         if (has_future) {
[16:22:02.940]                           ns <- base::getNamespace("future")
[16:22:02.940]                           version <- ns[[".package"]][["version"]]
[16:22:02.940]                           if (is.null(version)) 
[16:22:02.940]                             version <- utils::packageVersion("future")
[16:22:02.940]                         }
[16:22:02.940]                         else {
[16:22:02.940]                           version <- NULL
[16:22:02.940]                         }
[16:22:02.940]                         if (!has_future || version < "1.8.0") {
[16:22:02.940]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:02.940]                             "", base::R.version$version.string), 
[16:22:02.940]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:02.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:02.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:02.940]                               "release", "version")], collapse = " "), 
[16:22:02.940]                             hostname = base::Sys.info()[["nodename"]])
[16:22:02.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:02.940]                             info)
[16:22:02.940]                           info <- base::paste(info, collapse = "; ")
[16:22:02.940]                           if (!has_future) {
[16:22:02.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:02.940]                               info)
[16:22:02.940]                           }
[16:22:02.940]                           else {
[16:22:02.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:02.940]                               info, version)
[16:22:02.940]                           }
[16:22:02.940]                           base::stop(msg)
[16:22:02.940]                         }
[16:22:02.940]                       })
[16:22:02.940]                     }
[16:22:02.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:02.940]                     base::options(mc.cores = 1L)
[16:22:02.940]                   }
[16:22:02.940]                   ...future.strategy.old <- future::plan("list")
[16:22:02.940]                   options(future.plan = NULL)
[16:22:02.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:02.940]                 }
[16:22:02.940]                 ...future.workdir <- getwd()
[16:22:02.940]             }
[16:22:02.940]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:02.940]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:02.940]         }
[16:22:02.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:02.940]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:02.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:02.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:02.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:02.940]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:02.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:02.940]             base::names(...future.oldOptions))
[16:22:02.940]     }
[16:22:02.940]     if (FALSE) {
[16:22:02.940]     }
[16:22:02.940]     else {
[16:22:02.940]         if (TRUE) {
[16:22:02.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:02.940]                 open = "w")
[16:22:02.940]         }
[16:22:02.940]         else {
[16:22:02.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:02.940]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:02.940]         }
[16:22:02.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:02.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:02.940]             base::sink(type = "output", split = FALSE)
[16:22:02.940]             base::close(...future.stdout)
[16:22:02.940]         }, add = TRUE)
[16:22:02.940]     }
[16:22:02.940]     ...future.frame <- base::sys.nframe()
[16:22:02.940]     ...future.conditions <- base::list()
[16:22:02.940]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:02.940]     if (FALSE) {
[16:22:02.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:02.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:02.940]     }
[16:22:02.940]     ...future.result <- base::tryCatch({
[16:22:02.940]         base::withCallingHandlers({
[16:22:02.940]             ...future.value <- base::withVisible(base::local({
[16:22:02.940]                 ...future.makeSendCondition <- base::local({
[16:22:02.940]                   sendCondition <- NULL
[16:22:02.940]                   function(frame = 1L) {
[16:22:02.940]                     if (is.function(sendCondition)) 
[16:22:02.940]                       return(sendCondition)
[16:22:02.940]                     ns <- getNamespace("parallel")
[16:22:02.940]                     if (exists("sendData", mode = "function", 
[16:22:02.940]                       envir = ns)) {
[16:22:02.940]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:02.940]                         envir = ns)
[16:22:02.940]                       envir <- sys.frame(frame)
[16:22:02.940]                       master <- NULL
[16:22:02.940]                       while (!identical(envir, .GlobalEnv) && 
[16:22:02.940]                         !identical(envir, emptyenv())) {
[16:22:02.940]                         if (exists("master", mode = "list", envir = envir, 
[16:22:02.940]                           inherits = FALSE)) {
[16:22:02.940]                           master <- get("master", mode = "list", 
[16:22:02.940]                             envir = envir, inherits = FALSE)
[16:22:02.940]                           if (inherits(master, c("SOCKnode", 
[16:22:02.940]                             "SOCK0node"))) {
[16:22:02.940]                             sendCondition <<- function(cond) {
[16:22:02.940]                               data <- list(type = "VALUE", value = cond, 
[16:22:02.940]                                 success = TRUE)
[16:22:02.940]                               parallel_sendData(master, data)
[16:22:02.940]                             }
[16:22:02.940]                             return(sendCondition)
[16:22:02.940]                           }
[16:22:02.940]                         }
[16:22:02.940]                         frame <- frame + 1L
[16:22:02.940]                         envir <- sys.frame(frame)
[16:22:02.940]                       }
[16:22:02.940]                     }
[16:22:02.940]                     sendCondition <<- function(cond) NULL
[16:22:02.940]                   }
[16:22:02.940]                 })
[16:22:02.940]                 withCallingHandlers({
[16:22:02.940]                   {
[16:22:02.940]                     Sys.sleep(0.5)
[16:22:02.940]                     list(a = 1, b = 42L)
[16:22:02.940]                   }
[16:22:02.940]                 }, immediateCondition = function(cond) {
[16:22:02.940]                   sendCondition <- ...future.makeSendCondition()
[16:22:02.940]                   sendCondition(cond)
[16:22:02.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.940]                   {
[16:22:02.940]                     inherits <- base::inherits
[16:22:02.940]                     invokeRestart <- base::invokeRestart
[16:22:02.940]                     is.null <- base::is.null
[16:22:02.940]                     muffled <- FALSE
[16:22:02.940]                     if (inherits(cond, "message")) {
[16:22:02.940]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:02.940]                       if (muffled) 
[16:22:02.940]                         invokeRestart("muffleMessage")
[16:22:02.940]                     }
[16:22:02.940]                     else if (inherits(cond, "warning")) {
[16:22:02.940]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:02.940]                       if (muffled) 
[16:22:02.940]                         invokeRestart("muffleWarning")
[16:22:02.940]                     }
[16:22:02.940]                     else if (inherits(cond, "condition")) {
[16:22:02.940]                       if (!is.null(pattern)) {
[16:22:02.940]                         computeRestarts <- base::computeRestarts
[16:22:02.940]                         grepl <- base::grepl
[16:22:02.940]                         restarts <- computeRestarts(cond)
[16:22:02.940]                         for (restart in restarts) {
[16:22:02.940]                           name <- restart$name
[16:22:02.940]                           if (is.null(name)) 
[16:22:02.940]                             next
[16:22:02.940]                           if (!grepl(pattern, name)) 
[16:22:02.940]                             next
[16:22:02.940]                           invokeRestart(restart)
[16:22:02.940]                           muffled <- TRUE
[16:22:02.940]                           break
[16:22:02.940]                         }
[16:22:02.940]                       }
[16:22:02.940]                     }
[16:22:02.940]                     invisible(muffled)
[16:22:02.940]                   }
[16:22:02.940]                   muffleCondition(cond)
[16:22:02.940]                 })
[16:22:02.940]             }))
[16:22:02.940]             future::FutureResult(value = ...future.value$value, 
[16:22:02.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.940]                   ...future.rng), globalenv = if (FALSE) 
[16:22:02.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:02.940]                     ...future.globalenv.names))
[16:22:02.940]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:02.940]         }, condition = base::local({
[16:22:02.940]             c <- base::c
[16:22:02.940]             inherits <- base::inherits
[16:22:02.940]             invokeRestart <- base::invokeRestart
[16:22:02.940]             length <- base::length
[16:22:02.940]             list <- base::list
[16:22:02.940]             seq.int <- base::seq.int
[16:22:02.940]             signalCondition <- base::signalCondition
[16:22:02.940]             sys.calls <- base::sys.calls
[16:22:02.940]             `[[` <- base::`[[`
[16:22:02.940]             `+` <- base::`+`
[16:22:02.940]             `<<-` <- base::`<<-`
[16:22:02.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:02.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:02.940]                   3L)]
[16:22:02.940]             }
[16:22:02.940]             function(cond) {
[16:22:02.940]                 is_error <- inherits(cond, "error")
[16:22:02.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:02.940]                   NULL)
[16:22:02.940]                 if (is_error) {
[16:22:02.940]                   sessionInformation <- function() {
[16:22:02.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:02.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:02.940]                       search = base::search(), system = base::Sys.info())
[16:22:02.940]                   }
[16:22:02.940]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:02.940]                     cond$call), session = sessionInformation(), 
[16:22:02.940]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:02.940]                   signalCondition(cond)
[16:22:02.940]                 }
[16:22:02.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:02.940]                 "immediateCondition"))) {
[16:22:02.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:02.940]                   ...future.conditions[[length(...future.conditions) + 
[16:22:02.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:02.940]                   if (TRUE && !signal) {
[16:22:02.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.940]                     {
[16:22:02.940]                       inherits <- base::inherits
[16:22:02.940]                       invokeRestart <- base::invokeRestart
[16:22:02.940]                       is.null <- base::is.null
[16:22:02.940]                       muffled <- FALSE
[16:22:02.940]                       if (inherits(cond, "message")) {
[16:22:02.940]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.940]                         if (muffled) 
[16:22:02.940]                           invokeRestart("muffleMessage")
[16:22:02.940]                       }
[16:22:02.940]                       else if (inherits(cond, "warning")) {
[16:22:02.940]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.940]                         if (muffled) 
[16:22:02.940]                           invokeRestart("muffleWarning")
[16:22:02.940]                       }
[16:22:02.940]                       else if (inherits(cond, "condition")) {
[16:22:02.940]                         if (!is.null(pattern)) {
[16:22:02.940]                           computeRestarts <- base::computeRestarts
[16:22:02.940]                           grepl <- base::grepl
[16:22:02.940]                           restarts <- computeRestarts(cond)
[16:22:02.940]                           for (restart in restarts) {
[16:22:02.940]                             name <- restart$name
[16:22:02.940]                             if (is.null(name)) 
[16:22:02.940]                               next
[16:22:02.940]                             if (!grepl(pattern, name)) 
[16:22:02.940]                               next
[16:22:02.940]                             invokeRestart(restart)
[16:22:02.940]                             muffled <- TRUE
[16:22:02.940]                             break
[16:22:02.940]                           }
[16:22:02.940]                         }
[16:22:02.940]                       }
[16:22:02.940]                       invisible(muffled)
[16:22:02.940]                     }
[16:22:02.940]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.940]                   }
[16:22:02.940]                 }
[16:22:02.940]                 else {
[16:22:02.940]                   if (TRUE) {
[16:22:02.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:02.940]                     {
[16:22:02.940]                       inherits <- base::inherits
[16:22:02.940]                       invokeRestart <- base::invokeRestart
[16:22:02.940]                       is.null <- base::is.null
[16:22:02.940]                       muffled <- FALSE
[16:22:02.940]                       if (inherits(cond, "message")) {
[16:22:02.940]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:02.940]                         if (muffled) 
[16:22:02.940]                           invokeRestart("muffleMessage")
[16:22:02.940]                       }
[16:22:02.940]                       else if (inherits(cond, "warning")) {
[16:22:02.940]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:02.940]                         if (muffled) 
[16:22:02.940]                           invokeRestart("muffleWarning")
[16:22:02.940]                       }
[16:22:02.940]                       else if (inherits(cond, "condition")) {
[16:22:02.940]                         if (!is.null(pattern)) {
[16:22:02.940]                           computeRestarts <- base::computeRestarts
[16:22:02.940]                           grepl <- base::grepl
[16:22:02.940]                           restarts <- computeRestarts(cond)
[16:22:02.940]                           for (restart in restarts) {
[16:22:02.940]                             name <- restart$name
[16:22:02.940]                             if (is.null(name)) 
[16:22:02.940]                               next
[16:22:02.940]                             if (!grepl(pattern, name)) 
[16:22:02.940]                               next
[16:22:02.940]                             invokeRestart(restart)
[16:22:02.940]                             muffled <- TRUE
[16:22:02.940]                             break
[16:22:02.940]                           }
[16:22:02.940]                         }
[16:22:02.940]                       }
[16:22:02.940]                       invisible(muffled)
[16:22:02.940]                     }
[16:22:02.940]                     muffleCondition(cond, pattern = "^muffle")
[16:22:02.940]                   }
[16:22:02.940]                 }
[16:22:02.940]             }
[16:22:02.940]         }))
[16:22:02.940]     }, error = function(ex) {
[16:22:02.940]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:02.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:02.940]                 ...future.rng), started = ...future.startTime, 
[16:22:02.940]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:02.940]             version = "1.8"), class = "FutureResult")
[16:22:02.940]     }, finally = {
[16:22:02.940]         if (!identical(...future.workdir, getwd())) 
[16:22:02.940]             setwd(...future.workdir)
[16:22:02.940]         {
[16:22:02.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:02.940]                 ...future.oldOptions$nwarnings <- NULL
[16:22:02.940]             }
[16:22:02.940]             base::options(...future.oldOptions)
[16:22:02.940]             if (.Platform$OS.type == "windows") {
[16:22:02.940]                 old_names <- names(...future.oldEnvVars)
[16:22:02.940]                 envs <- base::Sys.getenv()
[16:22:02.940]                 names <- names(envs)
[16:22:02.940]                 common <- intersect(names, old_names)
[16:22:02.940]                 added <- setdiff(names, old_names)
[16:22:02.940]                 removed <- setdiff(old_names, names)
[16:22:02.940]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:02.940]                   envs[common]]
[16:22:02.940]                 NAMES <- toupper(changed)
[16:22:02.940]                 args <- list()
[16:22:02.940]                 for (kk in seq_along(NAMES)) {
[16:22:02.940]                   name <- changed[[kk]]
[16:22:02.940]                   NAME <- NAMES[[kk]]
[16:22:02.940]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.940]                     next
[16:22:02.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.940]                 }
[16:22:02.940]                 NAMES <- toupper(added)
[16:22:02.940]                 for (kk in seq_along(NAMES)) {
[16:22:02.940]                   name <- added[[kk]]
[16:22:02.940]                   NAME <- NAMES[[kk]]
[16:22:02.940]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.940]                     next
[16:22:02.940]                   args[[name]] <- ""
[16:22:02.940]                 }
[16:22:02.940]                 NAMES <- toupper(removed)
[16:22:02.940]                 for (kk in seq_along(NAMES)) {
[16:22:02.940]                   name <- removed[[kk]]
[16:22:02.940]                   NAME <- NAMES[[kk]]
[16:22:02.940]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:02.940]                     next
[16:22:02.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:02.940]                 }
[16:22:02.940]                 if (length(args) > 0) 
[16:22:02.940]                   base::do.call(base::Sys.setenv, args = args)
[16:22:02.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:02.940]             }
[16:22:02.940]             else {
[16:22:02.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:02.940]             }
[16:22:02.940]             {
[16:22:02.940]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:02.940]                   0L) {
[16:22:02.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:02.940]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:02.940]                   base::options(opts)
[16:22:02.940]                 }
[16:22:02.940]                 {
[16:22:02.940]                   {
[16:22:02.940]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:02.940]                     NULL
[16:22:02.940]                   }
[16:22:02.940]                   options(future.plan = NULL)
[16:22:02.940]                   if (is.na(NA_character_)) 
[16:22:02.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:02.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:02.940]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:02.940]                     .init = FALSE)
[16:22:02.940]                 }
[16:22:02.940]             }
[16:22:02.940]         }
[16:22:02.940]     })
[16:22:02.940]     if (TRUE) {
[16:22:02.940]         base::sink(type = "output", split = FALSE)
[16:22:02.940]         if (TRUE) {
[16:22:02.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:02.940]         }
[16:22:02.940]         else {
[16:22:02.940]             ...future.result["stdout"] <- base::list(NULL)
[16:22:02.940]         }
[16:22:02.940]         base::close(...future.stdout)
[16:22:02.940]         ...future.stdout <- NULL
[16:22:02.940]     }
[16:22:02.940]     ...future.result$conditions <- ...future.conditions
[16:22:02.940]     ...future.result$finished <- base::Sys.time()
[16:22:02.940]     ...future.result
[16:22:02.940] }
[16:22:02.943] MultisessionFuture started
[16:22:02.943] - Launch lazy future ... done
[16:22:02.943] run() for ‘MultisessionFuture’ ... done
[16:22:03.446] receiveMessageFromWorker() for ClusterFuture ...
[16:22:03.446] - Validating connection of MultisessionFuture
[16:22:03.446] - received message: FutureResult
[16:22:03.446] - Received FutureResult
[16:22:03.447] - Erased future from FutureRegistry
[16:22:03.447] result() for ClusterFuture ...
[16:22:03.447] - result already collected: FutureResult
[16:22:03.447] result() for ClusterFuture ... done
[16:22:03.447] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:03.447] resolve() on list ...
[16:22:03.447]  recursive: 98
[16:22:03.447]  length: 2
[16:22:03.447]  elements: ‘a’, ‘b’
[16:22:03.447]  length: 1 (resolved future 1)
[16:22:03.448]  length: 0 (resolved future 2)
[16:22:03.448] resolve() on list ... DONE
[16:22:03.448] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:22:03.448] getGlobalsAndPackages() ...
[16:22:03.448] Searching for globals...
[16:22:03.449] - globals found: [2] ‘list’, ‘stop’
[16:22:03.449] Searching for globals ... DONE
[16:22:03.449] Resolving globals: FALSE
[16:22:03.449] 
[16:22:03.449] 
[16:22:03.449] getGlobalsAndPackages() ... DONE
[16:22:03.450] run() for ‘Future’ ...
[16:22:03.450] - state: ‘created’
[16:22:03.455] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:03.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:03.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:03.476]   - Field: ‘node’
[16:22:03.476]   - Field: ‘label’
[16:22:03.476]   - Field: ‘local’
[16:22:03.476]   - Field: ‘owner’
[16:22:03.476]   - Field: ‘envir’
[16:22:03.477]   - Field: ‘workers’
[16:22:03.477]   - Field: ‘packages’
[16:22:03.477]   - Field: ‘gc’
[16:22:03.477]   - Field: ‘conditions’
[16:22:03.477]   - Field: ‘persistent’
[16:22:03.477]   - Field: ‘expr’
[16:22:03.478]   - Field: ‘uuid’
[16:22:03.478]   - Field: ‘seed’
[16:22:03.478]   - Field: ‘version’
[16:22:03.478]   - Field: ‘result’
[16:22:03.478]   - Field: ‘asynchronous’
[16:22:03.479]   - Field: ‘calls’
[16:22:03.479]   - Field: ‘globals’
[16:22:03.479]   - Field: ‘stdout’
[16:22:03.479]   - Field: ‘earlySignal’
[16:22:03.479]   - Field: ‘lazy’
[16:22:03.479]   - Field: ‘state’
[16:22:03.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:03.480] - Launch lazy future ...
[16:22:03.480] Packages needed by the future expression (n = 0): <none>
[16:22:03.480] Packages needed by future strategies (n = 0): <none>
[16:22:03.481] {
[16:22:03.481]     {
[16:22:03.481]         {
[16:22:03.481]             ...future.startTime <- base::Sys.time()
[16:22:03.481]             {
[16:22:03.481]                 {
[16:22:03.481]                   {
[16:22:03.481]                     {
[16:22:03.481]                       base::local({
[16:22:03.481]                         has_future <- base::requireNamespace("future", 
[16:22:03.481]                           quietly = TRUE)
[16:22:03.481]                         if (has_future) {
[16:22:03.481]                           ns <- base::getNamespace("future")
[16:22:03.481]                           version <- ns[[".package"]][["version"]]
[16:22:03.481]                           if (is.null(version)) 
[16:22:03.481]                             version <- utils::packageVersion("future")
[16:22:03.481]                         }
[16:22:03.481]                         else {
[16:22:03.481]                           version <- NULL
[16:22:03.481]                         }
[16:22:03.481]                         if (!has_future || version < "1.8.0") {
[16:22:03.481]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:03.481]                             "", base::R.version$version.string), 
[16:22:03.481]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:03.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:03.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:03.481]                               "release", "version")], collapse = " "), 
[16:22:03.481]                             hostname = base::Sys.info()[["nodename"]])
[16:22:03.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:03.481]                             info)
[16:22:03.481]                           info <- base::paste(info, collapse = "; ")
[16:22:03.481]                           if (!has_future) {
[16:22:03.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:03.481]                               info)
[16:22:03.481]                           }
[16:22:03.481]                           else {
[16:22:03.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:03.481]                               info, version)
[16:22:03.481]                           }
[16:22:03.481]                           base::stop(msg)
[16:22:03.481]                         }
[16:22:03.481]                       })
[16:22:03.481]                     }
[16:22:03.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:03.481]                     base::options(mc.cores = 1L)
[16:22:03.481]                   }
[16:22:03.481]                   ...future.strategy.old <- future::plan("list")
[16:22:03.481]                   options(future.plan = NULL)
[16:22:03.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:03.481]                 }
[16:22:03.481]                 ...future.workdir <- getwd()
[16:22:03.481]             }
[16:22:03.481]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:03.481]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:03.481]         }
[16:22:03.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:03.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:03.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:03.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:03.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:03.481]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:03.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:03.481]             base::names(...future.oldOptions))
[16:22:03.481]     }
[16:22:03.481]     if (FALSE) {
[16:22:03.481]     }
[16:22:03.481]     else {
[16:22:03.481]         if (TRUE) {
[16:22:03.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:03.481]                 open = "w")
[16:22:03.481]         }
[16:22:03.481]         else {
[16:22:03.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:03.481]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:03.481]         }
[16:22:03.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:03.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:03.481]             base::sink(type = "output", split = FALSE)
[16:22:03.481]             base::close(...future.stdout)
[16:22:03.481]         }, add = TRUE)
[16:22:03.481]     }
[16:22:03.481]     ...future.frame <- base::sys.nframe()
[16:22:03.481]     ...future.conditions <- base::list()
[16:22:03.481]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:03.481]     if (FALSE) {
[16:22:03.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:03.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:03.481]     }
[16:22:03.481]     ...future.result <- base::tryCatch({
[16:22:03.481]         base::withCallingHandlers({
[16:22:03.481]             ...future.value <- base::withVisible(base::local({
[16:22:03.481]                 ...future.makeSendCondition <- base::local({
[16:22:03.481]                   sendCondition <- NULL
[16:22:03.481]                   function(frame = 1L) {
[16:22:03.481]                     if (is.function(sendCondition)) 
[16:22:03.481]                       return(sendCondition)
[16:22:03.481]                     ns <- getNamespace("parallel")
[16:22:03.481]                     if (exists("sendData", mode = "function", 
[16:22:03.481]                       envir = ns)) {
[16:22:03.481]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:03.481]                         envir = ns)
[16:22:03.481]                       envir <- sys.frame(frame)
[16:22:03.481]                       master <- NULL
[16:22:03.481]                       while (!identical(envir, .GlobalEnv) && 
[16:22:03.481]                         !identical(envir, emptyenv())) {
[16:22:03.481]                         if (exists("master", mode = "list", envir = envir, 
[16:22:03.481]                           inherits = FALSE)) {
[16:22:03.481]                           master <- get("master", mode = "list", 
[16:22:03.481]                             envir = envir, inherits = FALSE)
[16:22:03.481]                           if (inherits(master, c("SOCKnode", 
[16:22:03.481]                             "SOCK0node"))) {
[16:22:03.481]                             sendCondition <<- function(cond) {
[16:22:03.481]                               data <- list(type = "VALUE", value = cond, 
[16:22:03.481]                                 success = TRUE)
[16:22:03.481]                               parallel_sendData(master, data)
[16:22:03.481]                             }
[16:22:03.481]                             return(sendCondition)
[16:22:03.481]                           }
[16:22:03.481]                         }
[16:22:03.481]                         frame <- frame + 1L
[16:22:03.481]                         envir <- sys.frame(frame)
[16:22:03.481]                       }
[16:22:03.481]                     }
[16:22:03.481]                     sendCondition <<- function(cond) NULL
[16:22:03.481]                   }
[16:22:03.481]                 })
[16:22:03.481]                 withCallingHandlers({
[16:22:03.481]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:03.481]                 }, immediateCondition = function(cond) {
[16:22:03.481]                   sendCondition <- ...future.makeSendCondition()
[16:22:03.481]                   sendCondition(cond)
[16:22:03.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.481]                   {
[16:22:03.481]                     inherits <- base::inherits
[16:22:03.481]                     invokeRestart <- base::invokeRestart
[16:22:03.481]                     is.null <- base::is.null
[16:22:03.481]                     muffled <- FALSE
[16:22:03.481]                     if (inherits(cond, "message")) {
[16:22:03.481]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:03.481]                       if (muffled) 
[16:22:03.481]                         invokeRestart("muffleMessage")
[16:22:03.481]                     }
[16:22:03.481]                     else if (inherits(cond, "warning")) {
[16:22:03.481]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:03.481]                       if (muffled) 
[16:22:03.481]                         invokeRestart("muffleWarning")
[16:22:03.481]                     }
[16:22:03.481]                     else if (inherits(cond, "condition")) {
[16:22:03.481]                       if (!is.null(pattern)) {
[16:22:03.481]                         computeRestarts <- base::computeRestarts
[16:22:03.481]                         grepl <- base::grepl
[16:22:03.481]                         restarts <- computeRestarts(cond)
[16:22:03.481]                         for (restart in restarts) {
[16:22:03.481]                           name <- restart$name
[16:22:03.481]                           if (is.null(name)) 
[16:22:03.481]                             next
[16:22:03.481]                           if (!grepl(pattern, name)) 
[16:22:03.481]                             next
[16:22:03.481]                           invokeRestart(restart)
[16:22:03.481]                           muffled <- TRUE
[16:22:03.481]                           break
[16:22:03.481]                         }
[16:22:03.481]                       }
[16:22:03.481]                     }
[16:22:03.481]                     invisible(muffled)
[16:22:03.481]                   }
[16:22:03.481]                   muffleCondition(cond)
[16:22:03.481]                 })
[16:22:03.481]             }))
[16:22:03.481]             future::FutureResult(value = ...future.value$value, 
[16:22:03.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.481]                   ...future.rng), globalenv = if (FALSE) 
[16:22:03.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:03.481]                     ...future.globalenv.names))
[16:22:03.481]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:03.481]         }, condition = base::local({
[16:22:03.481]             c <- base::c
[16:22:03.481]             inherits <- base::inherits
[16:22:03.481]             invokeRestart <- base::invokeRestart
[16:22:03.481]             length <- base::length
[16:22:03.481]             list <- base::list
[16:22:03.481]             seq.int <- base::seq.int
[16:22:03.481]             signalCondition <- base::signalCondition
[16:22:03.481]             sys.calls <- base::sys.calls
[16:22:03.481]             `[[` <- base::`[[`
[16:22:03.481]             `+` <- base::`+`
[16:22:03.481]             `<<-` <- base::`<<-`
[16:22:03.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:03.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:03.481]                   3L)]
[16:22:03.481]             }
[16:22:03.481]             function(cond) {
[16:22:03.481]                 is_error <- inherits(cond, "error")
[16:22:03.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:03.481]                   NULL)
[16:22:03.481]                 if (is_error) {
[16:22:03.481]                   sessionInformation <- function() {
[16:22:03.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:03.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:03.481]                       search = base::search(), system = base::Sys.info())
[16:22:03.481]                   }
[16:22:03.481]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:03.481]                     cond$call), session = sessionInformation(), 
[16:22:03.481]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:03.481]                   signalCondition(cond)
[16:22:03.481]                 }
[16:22:03.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:03.481]                 "immediateCondition"))) {
[16:22:03.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:03.481]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:03.481]                   if (TRUE && !signal) {
[16:22:03.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.481]                     {
[16:22:03.481]                       inherits <- base::inherits
[16:22:03.481]                       invokeRestart <- base::invokeRestart
[16:22:03.481]                       is.null <- base::is.null
[16:22:03.481]                       muffled <- FALSE
[16:22:03.481]                       if (inherits(cond, "message")) {
[16:22:03.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.481]                         if (muffled) 
[16:22:03.481]                           invokeRestart("muffleMessage")
[16:22:03.481]                       }
[16:22:03.481]                       else if (inherits(cond, "warning")) {
[16:22:03.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.481]                         if (muffled) 
[16:22:03.481]                           invokeRestart("muffleWarning")
[16:22:03.481]                       }
[16:22:03.481]                       else if (inherits(cond, "condition")) {
[16:22:03.481]                         if (!is.null(pattern)) {
[16:22:03.481]                           computeRestarts <- base::computeRestarts
[16:22:03.481]                           grepl <- base::grepl
[16:22:03.481]                           restarts <- computeRestarts(cond)
[16:22:03.481]                           for (restart in restarts) {
[16:22:03.481]                             name <- restart$name
[16:22:03.481]                             if (is.null(name)) 
[16:22:03.481]                               next
[16:22:03.481]                             if (!grepl(pattern, name)) 
[16:22:03.481]                               next
[16:22:03.481]                             invokeRestart(restart)
[16:22:03.481]                             muffled <- TRUE
[16:22:03.481]                             break
[16:22:03.481]                           }
[16:22:03.481]                         }
[16:22:03.481]                       }
[16:22:03.481]                       invisible(muffled)
[16:22:03.481]                     }
[16:22:03.481]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.481]                   }
[16:22:03.481]                 }
[16:22:03.481]                 else {
[16:22:03.481]                   if (TRUE) {
[16:22:03.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.481]                     {
[16:22:03.481]                       inherits <- base::inherits
[16:22:03.481]                       invokeRestart <- base::invokeRestart
[16:22:03.481]                       is.null <- base::is.null
[16:22:03.481]                       muffled <- FALSE
[16:22:03.481]                       if (inherits(cond, "message")) {
[16:22:03.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.481]                         if (muffled) 
[16:22:03.481]                           invokeRestart("muffleMessage")
[16:22:03.481]                       }
[16:22:03.481]                       else if (inherits(cond, "warning")) {
[16:22:03.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.481]                         if (muffled) 
[16:22:03.481]                           invokeRestart("muffleWarning")
[16:22:03.481]                       }
[16:22:03.481]                       else if (inherits(cond, "condition")) {
[16:22:03.481]                         if (!is.null(pattern)) {
[16:22:03.481]                           computeRestarts <- base::computeRestarts
[16:22:03.481]                           grepl <- base::grepl
[16:22:03.481]                           restarts <- computeRestarts(cond)
[16:22:03.481]                           for (restart in restarts) {
[16:22:03.481]                             name <- restart$name
[16:22:03.481]                             if (is.null(name)) 
[16:22:03.481]                               next
[16:22:03.481]                             if (!grepl(pattern, name)) 
[16:22:03.481]                               next
[16:22:03.481]                             invokeRestart(restart)
[16:22:03.481]                             muffled <- TRUE
[16:22:03.481]                             break
[16:22:03.481]                           }
[16:22:03.481]                         }
[16:22:03.481]                       }
[16:22:03.481]                       invisible(muffled)
[16:22:03.481]                     }
[16:22:03.481]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.481]                   }
[16:22:03.481]                 }
[16:22:03.481]             }
[16:22:03.481]         }))
[16:22:03.481]     }, error = function(ex) {
[16:22:03.481]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:03.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.481]                 ...future.rng), started = ...future.startTime, 
[16:22:03.481]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:03.481]             version = "1.8"), class = "FutureResult")
[16:22:03.481]     }, finally = {
[16:22:03.481]         if (!identical(...future.workdir, getwd())) 
[16:22:03.481]             setwd(...future.workdir)
[16:22:03.481]         {
[16:22:03.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:03.481]                 ...future.oldOptions$nwarnings <- NULL
[16:22:03.481]             }
[16:22:03.481]             base::options(...future.oldOptions)
[16:22:03.481]             if (.Platform$OS.type == "windows") {
[16:22:03.481]                 old_names <- names(...future.oldEnvVars)
[16:22:03.481]                 envs <- base::Sys.getenv()
[16:22:03.481]                 names <- names(envs)
[16:22:03.481]                 common <- intersect(names, old_names)
[16:22:03.481]                 added <- setdiff(names, old_names)
[16:22:03.481]                 removed <- setdiff(old_names, names)
[16:22:03.481]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:03.481]                   envs[common]]
[16:22:03.481]                 NAMES <- toupper(changed)
[16:22:03.481]                 args <- list()
[16:22:03.481]                 for (kk in seq_along(NAMES)) {
[16:22:03.481]                   name <- changed[[kk]]
[16:22:03.481]                   NAME <- NAMES[[kk]]
[16:22:03.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.481]                     next
[16:22:03.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.481]                 }
[16:22:03.481]                 NAMES <- toupper(added)
[16:22:03.481]                 for (kk in seq_along(NAMES)) {
[16:22:03.481]                   name <- added[[kk]]
[16:22:03.481]                   NAME <- NAMES[[kk]]
[16:22:03.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.481]                     next
[16:22:03.481]                   args[[name]] <- ""
[16:22:03.481]                 }
[16:22:03.481]                 NAMES <- toupper(removed)
[16:22:03.481]                 for (kk in seq_along(NAMES)) {
[16:22:03.481]                   name <- removed[[kk]]
[16:22:03.481]                   NAME <- NAMES[[kk]]
[16:22:03.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.481]                     next
[16:22:03.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.481]                 }
[16:22:03.481]                 if (length(args) > 0) 
[16:22:03.481]                   base::do.call(base::Sys.setenv, args = args)
[16:22:03.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:03.481]             }
[16:22:03.481]             else {
[16:22:03.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:03.481]             }
[16:22:03.481]             {
[16:22:03.481]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:03.481]                   0L) {
[16:22:03.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:03.481]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:03.481]                   base::options(opts)
[16:22:03.481]                 }
[16:22:03.481]                 {
[16:22:03.481]                   {
[16:22:03.481]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:03.481]                     NULL
[16:22:03.481]                   }
[16:22:03.481]                   options(future.plan = NULL)
[16:22:03.481]                   if (is.na(NA_character_)) 
[16:22:03.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:03.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:03.481]                     .init = FALSE)
[16:22:03.481]                 }
[16:22:03.481]             }
[16:22:03.481]         }
[16:22:03.481]     })
[16:22:03.481]     if (TRUE) {
[16:22:03.481]         base::sink(type = "output", split = FALSE)
[16:22:03.481]         if (TRUE) {
[16:22:03.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:03.481]         }
[16:22:03.481]         else {
[16:22:03.481]             ...future.result["stdout"] <- base::list(NULL)
[16:22:03.481]         }
[16:22:03.481]         base::close(...future.stdout)
[16:22:03.481]         ...future.stdout <- NULL
[16:22:03.481]     }
[16:22:03.481]     ...future.result$conditions <- ...future.conditions
[16:22:03.481]     ...future.result$finished <- base::Sys.time()
[16:22:03.481]     ...future.result
[16:22:03.481] }
[16:22:03.486] MultisessionFuture started
[16:22:03.486] - Launch lazy future ... done
[16:22:03.486] run() for ‘MultisessionFuture’ ... done
[16:22:03.488] receiveMessageFromWorker() for ClusterFuture ...
[16:22:03.488] - Validating connection of MultisessionFuture
[16:22:03.489] - received message: FutureResult
[16:22:03.489] - Received FutureResult
[16:22:03.489] - Erased future from FutureRegistry
[16:22:03.489] result() for ClusterFuture ...
[16:22:03.490] - result already collected: FutureResult
[16:22:03.490] result() for ClusterFuture ... done
[16:22:03.490] signalConditions() ...
[16:22:03.490]  - include = ‘immediateCondition’
[16:22:03.490]  - exclude = 
[16:22:03.490]  - resignal = FALSE
[16:22:03.490]  - Number of conditions: 1
[16:22:03.491] signalConditions() ... done
[16:22:03.491] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:03.491] A MultisessionFuture was resolved
[16:22:03.491] getGlobalsAndPackages() ...
[16:22:03.491] Searching for globals...
[16:22:03.492] - globals found: [2] ‘list’, ‘stop’
[16:22:03.493] Searching for globals ... DONE
[16:22:03.493] Resolving globals: FALSE
[16:22:03.493] 
[16:22:03.494] 
[16:22:03.494] getGlobalsAndPackages() ... DONE
[16:22:03.494] run() for ‘Future’ ...
[16:22:03.494] - state: ‘created’
[16:22:03.494] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:03.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:03.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:03.512]   - Field: ‘node’
[16:22:03.512]   - Field: ‘label’
[16:22:03.512]   - Field: ‘local’
[16:22:03.512]   - Field: ‘owner’
[16:22:03.512]   - Field: ‘envir’
[16:22:03.513]   - Field: ‘workers’
[16:22:03.513]   - Field: ‘packages’
[16:22:03.513]   - Field: ‘gc’
[16:22:03.513]   - Field: ‘conditions’
[16:22:03.513]   - Field: ‘persistent’
[16:22:03.513]   - Field: ‘expr’
[16:22:03.514]   - Field: ‘uuid’
[16:22:03.514]   - Field: ‘seed’
[16:22:03.514]   - Field: ‘version’
[16:22:03.514]   - Field: ‘result’
[16:22:03.514]   - Field: ‘asynchronous’
[16:22:03.514]   - Field: ‘calls’
[16:22:03.515]   - Field: ‘globals’
[16:22:03.515]   - Field: ‘stdout’
[16:22:03.515]   - Field: ‘earlySignal’
[16:22:03.515]   - Field: ‘lazy’
[16:22:03.515]   - Field: ‘state’
[16:22:03.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:03.516] - Launch lazy future ...
[16:22:03.516] Packages needed by the future expression (n = 0): <none>
[16:22:03.516] Packages needed by future strategies (n = 0): <none>
[16:22:03.517] {
[16:22:03.517]     {
[16:22:03.517]         {
[16:22:03.517]             ...future.startTime <- base::Sys.time()
[16:22:03.517]             {
[16:22:03.517]                 {
[16:22:03.517]                   {
[16:22:03.517]                     {
[16:22:03.517]                       base::local({
[16:22:03.517]                         has_future <- base::requireNamespace("future", 
[16:22:03.517]                           quietly = TRUE)
[16:22:03.517]                         if (has_future) {
[16:22:03.517]                           ns <- base::getNamespace("future")
[16:22:03.517]                           version <- ns[[".package"]][["version"]]
[16:22:03.517]                           if (is.null(version)) 
[16:22:03.517]                             version <- utils::packageVersion("future")
[16:22:03.517]                         }
[16:22:03.517]                         else {
[16:22:03.517]                           version <- NULL
[16:22:03.517]                         }
[16:22:03.517]                         if (!has_future || version < "1.8.0") {
[16:22:03.517]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:03.517]                             "", base::R.version$version.string), 
[16:22:03.517]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:03.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:03.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:03.517]                               "release", "version")], collapse = " "), 
[16:22:03.517]                             hostname = base::Sys.info()[["nodename"]])
[16:22:03.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:03.517]                             info)
[16:22:03.517]                           info <- base::paste(info, collapse = "; ")
[16:22:03.517]                           if (!has_future) {
[16:22:03.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:03.517]                               info)
[16:22:03.517]                           }
[16:22:03.517]                           else {
[16:22:03.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:03.517]                               info, version)
[16:22:03.517]                           }
[16:22:03.517]                           base::stop(msg)
[16:22:03.517]                         }
[16:22:03.517]                       })
[16:22:03.517]                     }
[16:22:03.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:03.517]                     base::options(mc.cores = 1L)
[16:22:03.517]                   }
[16:22:03.517]                   ...future.strategy.old <- future::plan("list")
[16:22:03.517]                   options(future.plan = NULL)
[16:22:03.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:03.517]                 }
[16:22:03.517]                 ...future.workdir <- getwd()
[16:22:03.517]             }
[16:22:03.517]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:03.517]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:03.517]         }
[16:22:03.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:03.517]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:03.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:03.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:03.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:03.517]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:03.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:03.517]             base::names(...future.oldOptions))
[16:22:03.517]     }
[16:22:03.517]     if (FALSE) {
[16:22:03.517]     }
[16:22:03.517]     else {
[16:22:03.517]         if (TRUE) {
[16:22:03.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:03.517]                 open = "w")
[16:22:03.517]         }
[16:22:03.517]         else {
[16:22:03.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:03.517]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:03.517]         }
[16:22:03.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:03.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:03.517]             base::sink(type = "output", split = FALSE)
[16:22:03.517]             base::close(...future.stdout)
[16:22:03.517]         }, add = TRUE)
[16:22:03.517]     }
[16:22:03.517]     ...future.frame <- base::sys.nframe()
[16:22:03.517]     ...future.conditions <- base::list()
[16:22:03.517]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:03.517]     if (FALSE) {
[16:22:03.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:03.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:03.517]     }
[16:22:03.517]     ...future.result <- base::tryCatch({
[16:22:03.517]         base::withCallingHandlers({
[16:22:03.517]             ...future.value <- base::withVisible(base::local({
[16:22:03.517]                 ...future.makeSendCondition <- base::local({
[16:22:03.517]                   sendCondition <- NULL
[16:22:03.517]                   function(frame = 1L) {
[16:22:03.517]                     if (is.function(sendCondition)) 
[16:22:03.517]                       return(sendCondition)
[16:22:03.517]                     ns <- getNamespace("parallel")
[16:22:03.517]                     if (exists("sendData", mode = "function", 
[16:22:03.517]                       envir = ns)) {
[16:22:03.517]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:03.517]                         envir = ns)
[16:22:03.517]                       envir <- sys.frame(frame)
[16:22:03.517]                       master <- NULL
[16:22:03.517]                       while (!identical(envir, .GlobalEnv) && 
[16:22:03.517]                         !identical(envir, emptyenv())) {
[16:22:03.517]                         if (exists("master", mode = "list", envir = envir, 
[16:22:03.517]                           inherits = FALSE)) {
[16:22:03.517]                           master <- get("master", mode = "list", 
[16:22:03.517]                             envir = envir, inherits = FALSE)
[16:22:03.517]                           if (inherits(master, c("SOCKnode", 
[16:22:03.517]                             "SOCK0node"))) {
[16:22:03.517]                             sendCondition <<- function(cond) {
[16:22:03.517]                               data <- list(type = "VALUE", value = cond, 
[16:22:03.517]                                 success = TRUE)
[16:22:03.517]                               parallel_sendData(master, data)
[16:22:03.517]                             }
[16:22:03.517]                             return(sendCondition)
[16:22:03.517]                           }
[16:22:03.517]                         }
[16:22:03.517]                         frame <- frame + 1L
[16:22:03.517]                         envir <- sys.frame(frame)
[16:22:03.517]                       }
[16:22:03.517]                     }
[16:22:03.517]                     sendCondition <<- function(cond) NULL
[16:22:03.517]                   }
[16:22:03.517]                 })
[16:22:03.517]                 withCallingHandlers({
[16:22:03.517]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:03.517]                 }, immediateCondition = function(cond) {
[16:22:03.517]                   sendCondition <- ...future.makeSendCondition()
[16:22:03.517]                   sendCondition(cond)
[16:22:03.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.517]                   {
[16:22:03.517]                     inherits <- base::inherits
[16:22:03.517]                     invokeRestart <- base::invokeRestart
[16:22:03.517]                     is.null <- base::is.null
[16:22:03.517]                     muffled <- FALSE
[16:22:03.517]                     if (inherits(cond, "message")) {
[16:22:03.517]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:03.517]                       if (muffled) 
[16:22:03.517]                         invokeRestart("muffleMessage")
[16:22:03.517]                     }
[16:22:03.517]                     else if (inherits(cond, "warning")) {
[16:22:03.517]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:03.517]                       if (muffled) 
[16:22:03.517]                         invokeRestart("muffleWarning")
[16:22:03.517]                     }
[16:22:03.517]                     else if (inherits(cond, "condition")) {
[16:22:03.517]                       if (!is.null(pattern)) {
[16:22:03.517]                         computeRestarts <- base::computeRestarts
[16:22:03.517]                         grepl <- base::grepl
[16:22:03.517]                         restarts <- computeRestarts(cond)
[16:22:03.517]                         for (restart in restarts) {
[16:22:03.517]                           name <- restart$name
[16:22:03.517]                           if (is.null(name)) 
[16:22:03.517]                             next
[16:22:03.517]                           if (!grepl(pattern, name)) 
[16:22:03.517]                             next
[16:22:03.517]                           invokeRestart(restart)
[16:22:03.517]                           muffled <- TRUE
[16:22:03.517]                           break
[16:22:03.517]                         }
[16:22:03.517]                       }
[16:22:03.517]                     }
[16:22:03.517]                     invisible(muffled)
[16:22:03.517]                   }
[16:22:03.517]                   muffleCondition(cond)
[16:22:03.517]                 })
[16:22:03.517]             }))
[16:22:03.517]             future::FutureResult(value = ...future.value$value, 
[16:22:03.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.517]                   ...future.rng), globalenv = if (FALSE) 
[16:22:03.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:03.517]                     ...future.globalenv.names))
[16:22:03.517]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:03.517]         }, condition = base::local({
[16:22:03.517]             c <- base::c
[16:22:03.517]             inherits <- base::inherits
[16:22:03.517]             invokeRestart <- base::invokeRestart
[16:22:03.517]             length <- base::length
[16:22:03.517]             list <- base::list
[16:22:03.517]             seq.int <- base::seq.int
[16:22:03.517]             signalCondition <- base::signalCondition
[16:22:03.517]             sys.calls <- base::sys.calls
[16:22:03.517]             `[[` <- base::`[[`
[16:22:03.517]             `+` <- base::`+`
[16:22:03.517]             `<<-` <- base::`<<-`
[16:22:03.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:03.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:03.517]                   3L)]
[16:22:03.517]             }
[16:22:03.517]             function(cond) {
[16:22:03.517]                 is_error <- inherits(cond, "error")
[16:22:03.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:03.517]                   NULL)
[16:22:03.517]                 if (is_error) {
[16:22:03.517]                   sessionInformation <- function() {
[16:22:03.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:03.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:03.517]                       search = base::search(), system = base::Sys.info())
[16:22:03.517]                   }
[16:22:03.517]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:03.517]                     cond$call), session = sessionInformation(), 
[16:22:03.517]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:03.517]                   signalCondition(cond)
[16:22:03.517]                 }
[16:22:03.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:03.517]                 "immediateCondition"))) {
[16:22:03.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:03.517]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:03.517]                   if (TRUE && !signal) {
[16:22:03.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.517]                     {
[16:22:03.517]                       inherits <- base::inherits
[16:22:03.517]                       invokeRestart <- base::invokeRestart
[16:22:03.517]                       is.null <- base::is.null
[16:22:03.517]                       muffled <- FALSE
[16:22:03.517]                       if (inherits(cond, "message")) {
[16:22:03.517]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.517]                         if (muffled) 
[16:22:03.517]                           invokeRestart("muffleMessage")
[16:22:03.517]                       }
[16:22:03.517]                       else if (inherits(cond, "warning")) {
[16:22:03.517]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.517]                         if (muffled) 
[16:22:03.517]                           invokeRestart("muffleWarning")
[16:22:03.517]                       }
[16:22:03.517]                       else if (inherits(cond, "condition")) {
[16:22:03.517]                         if (!is.null(pattern)) {
[16:22:03.517]                           computeRestarts <- base::computeRestarts
[16:22:03.517]                           grepl <- base::grepl
[16:22:03.517]                           restarts <- computeRestarts(cond)
[16:22:03.517]                           for (restart in restarts) {
[16:22:03.517]                             name <- restart$name
[16:22:03.517]                             if (is.null(name)) 
[16:22:03.517]                               next
[16:22:03.517]                             if (!grepl(pattern, name)) 
[16:22:03.517]                               next
[16:22:03.517]                             invokeRestart(restart)
[16:22:03.517]                             muffled <- TRUE
[16:22:03.517]                             break
[16:22:03.517]                           }
[16:22:03.517]                         }
[16:22:03.517]                       }
[16:22:03.517]                       invisible(muffled)
[16:22:03.517]                     }
[16:22:03.517]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.517]                   }
[16:22:03.517]                 }
[16:22:03.517]                 else {
[16:22:03.517]                   if (TRUE) {
[16:22:03.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.517]                     {
[16:22:03.517]                       inherits <- base::inherits
[16:22:03.517]                       invokeRestart <- base::invokeRestart
[16:22:03.517]                       is.null <- base::is.null
[16:22:03.517]                       muffled <- FALSE
[16:22:03.517]                       if (inherits(cond, "message")) {
[16:22:03.517]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.517]                         if (muffled) 
[16:22:03.517]                           invokeRestart("muffleMessage")
[16:22:03.517]                       }
[16:22:03.517]                       else if (inherits(cond, "warning")) {
[16:22:03.517]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.517]                         if (muffled) 
[16:22:03.517]                           invokeRestart("muffleWarning")
[16:22:03.517]                       }
[16:22:03.517]                       else if (inherits(cond, "condition")) {
[16:22:03.517]                         if (!is.null(pattern)) {
[16:22:03.517]                           computeRestarts <- base::computeRestarts
[16:22:03.517]                           grepl <- base::grepl
[16:22:03.517]                           restarts <- computeRestarts(cond)
[16:22:03.517]                           for (restart in restarts) {
[16:22:03.517]                             name <- restart$name
[16:22:03.517]                             if (is.null(name)) 
[16:22:03.517]                               next
[16:22:03.517]                             if (!grepl(pattern, name)) 
[16:22:03.517]                               next
[16:22:03.517]                             invokeRestart(restart)
[16:22:03.517]                             muffled <- TRUE
[16:22:03.517]                             break
[16:22:03.517]                           }
[16:22:03.517]                         }
[16:22:03.517]                       }
[16:22:03.517]                       invisible(muffled)
[16:22:03.517]                     }
[16:22:03.517]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.517]                   }
[16:22:03.517]                 }
[16:22:03.517]             }
[16:22:03.517]         }))
[16:22:03.517]     }, error = function(ex) {
[16:22:03.517]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:03.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.517]                 ...future.rng), started = ...future.startTime, 
[16:22:03.517]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:03.517]             version = "1.8"), class = "FutureResult")
[16:22:03.517]     }, finally = {
[16:22:03.517]         if (!identical(...future.workdir, getwd())) 
[16:22:03.517]             setwd(...future.workdir)
[16:22:03.517]         {
[16:22:03.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:03.517]                 ...future.oldOptions$nwarnings <- NULL
[16:22:03.517]             }
[16:22:03.517]             base::options(...future.oldOptions)
[16:22:03.517]             if (.Platform$OS.type == "windows") {
[16:22:03.517]                 old_names <- names(...future.oldEnvVars)
[16:22:03.517]                 envs <- base::Sys.getenv()
[16:22:03.517]                 names <- names(envs)
[16:22:03.517]                 common <- intersect(names, old_names)
[16:22:03.517]                 added <- setdiff(names, old_names)
[16:22:03.517]                 removed <- setdiff(old_names, names)
[16:22:03.517]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:03.517]                   envs[common]]
[16:22:03.517]                 NAMES <- toupper(changed)
[16:22:03.517]                 args <- list()
[16:22:03.517]                 for (kk in seq_along(NAMES)) {
[16:22:03.517]                   name <- changed[[kk]]
[16:22:03.517]                   NAME <- NAMES[[kk]]
[16:22:03.517]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.517]                     next
[16:22:03.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.517]                 }
[16:22:03.517]                 NAMES <- toupper(added)
[16:22:03.517]                 for (kk in seq_along(NAMES)) {
[16:22:03.517]                   name <- added[[kk]]
[16:22:03.517]                   NAME <- NAMES[[kk]]
[16:22:03.517]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.517]                     next
[16:22:03.517]                   args[[name]] <- ""
[16:22:03.517]                 }
[16:22:03.517]                 NAMES <- toupper(removed)
[16:22:03.517]                 for (kk in seq_along(NAMES)) {
[16:22:03.517]                   name <- removed[[kk]]
[16:22:03.517]                   NAME <- NAMES[[kk]]
[16:22:03.517]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.517]                     next
[16:22:03.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.517]                 }
[16:22:03.517]                 if (length(args) > 0) 
[16:22:03.517]                   base::do.call(base::Sys.setenv, args = args)
[16:22:03.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:03.517]             }
[16:22:03.517]             else {
[16:22:03.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:03.517]             }
[16:22:03.517]             {
[16:22:03.517]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:03.517]                   0L) {
[16:22:03.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:03.517]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:03.517]                   base::options(opts)
[16:22:03.517]                 }
[16:22:03.517]                 {
[16:22:03.517]                   {
[16:22:03.517]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:03.517]                     NULL
[16:22:03.517]                   }
[16:22:03.517]                   options(future.plan = NULL)
[16:22:03.517]                   if (is.na(NA_character_)) 
[16:22:03.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:03.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:03.517]                     .init = FALSE)
[16:22:03.517]                 }
[16:22:03.517]             }
[16:22:03.517]         }
[16:22:03.517]     })
[16:22:03.517]     if (TRUE) {
[16:22:03.517]         base::sink(type = "output", split = FALSE)
[16:22:03.517]         if (TRUE) {
[16:22:03.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:03.517]         }
[16:22:03.517]         else {
[16:22:03.517]             ...future.result["stdout"] <- base::list(NULL)
[16:22:03.517]         }
[16:22:03.517]         base::close(...future.stdout)
[16:22:03.517]         ...future.stdout <- NULL
[16:22:03.517]     }
[16:22:03.517]     ...future.result$conditions <- ...future.conditions
[16:22:03.517]     ...future.result$finished <- base::Sys.time()
[16:22:03.517]     ...future.result
[16:22:03.517] }
[16:22:03.522] MultisessionFuture started
[16:22:03.522] - Launch lazy future ... done
[16:22:03.522] run() for ‘MultisessionFuture’ ... done
[16:22:03.524] receiveMessageFromWorker() for ClusterFuture ...
[16:22:03.524] - Validating connection of MultisessionFuture
[16:22:03.525] - received message: FutureResult
[16:22:03.525] - Received FutureResult
[16:22:03.525] - Erased future from FutureRegistry
[16:22:03.525] result() for ClusterFuture ...
[16:22:03.526] - result already collected: FutureResult
[16:22:03.526] result() for ClusterFuture ... done
[16:22:03.526] signalConditions() ...
[16:22:03.526]  - include = ‘immediateCondition’
[16:22:03.526]  - exclude = 
[16:22:03.526]  - resignal = FALSE
[16:22:03.527]  - Number of conditions: 1
[16:22:03.527] signalConditions() ... done
[16:22:03.527] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:03.527] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[16:22:03.527] getGlobalsAndPackages() ...
[16:22:03.528] Searching for globals...
[16:22:03.530] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:03.530] Searching for globals ... DONE
[16:22:03.530] Resolving globals: FALSE
[16:22:03.531] 
[16:22:03.531] 
[16:22:03.531] getGlobalsAndPackages() ... DONE
[16:22:03.531] run() for ‘Future’ ...
[16:22:03.532] - state: ‘created’
[16:22:03.532] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:03.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:03.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:03.551]   - Field: ‘node’
[16:22:03.551]   - Field: ‘label’
[16:22:03.551]   - Field: ‘local’
[16:22:03.552]   - Field: ‘owner’
[16:22:03.552]   - Field: ‘envir’
[16:22:03.552]   - Field: ‘workers’
[16:22:03.552]   - Field: ‘packages’
[16:22:03.552]   - Field: ‘gc’
[16:22:03.553]   - Field: ‘conditions’
[16:22:03.553]   - Field: ‘persistent’
[16:22:03.553]   - Field: ‘expr’
[16:22:03.553]   - Field: ‘uuid’
[16:22:03.553]   - Field: ‘seed’
[16:22:03.553]   - Field: ‘version’
[16:22:03.554]   - Field: ‘result’
[16:22:03.554]   - Field: ‘asynchronous’
[16:22:03.554]   - Field: ‘calls’
[16:22:03.554]   - Field: ‘globals’
[16:22:03.554]   - Field: ‘stdout’
[16:22:03.555]   - Field: ‘earlySignal’
[16:22:03.555]   - Field: ‘lazy’
[16:22:03.555]   - Field: ‘state’
[16:22:03.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:03.555] - Launch lazy future ...
[16:22:03.556] Packages needed by the future expression (n = 0): <none>
[16:22:03.556] Packages needed by future strategies (n = 0): <none>
[16:22:03.557] {
[16:22:03.557]     {
[16:22:03.557]         {
[16:22:03.557]             ...future.startTime <- base::Sys.time()
[16:22:03.557]             {
[16:22:03.557]                 {
[16:22:03.557]                   {
[16:22:03.557]                     {
[16:22:03.557]                       base::local({
[16:22:03.557]                         has_future <- base::requireNamespace("future", 
[16:22:03.557]                           quietly = TRUE)
[16:22:03.557]                         if (has_future) {
[16:22:03.557]                           ns <- base::getNamespace("future")
[16:22:03.557]                           version <- ns[[".package"]][["version"]]
[16:22:03.557]                           if (is.null(version)) 
[16:22:03.557]                             version <- utils::packageVersion("future")
[16:22:03.557]                         }
[16:22:03.557]                         else {
[16:22:03.557]                           version <- NULL
[16:22:03.557]                         }
[16:22:03.557]                         if (!has_future || version < "1.8.0") {
[16:22:03.557]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:03.557]                             "", base::R.version$version.string), 
[16:22:03.557]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:03.557]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:03.557]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:03.557]                               "release", "version")], collapse = " "), 
[16:22:03.557]                             hostname = base::Sys.info()[["nodename"]])
[16:22:03.557]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:03.557]                             info)
[16:22:03.557]                           info <- base::paste(info, collapse = "; ")
[16:22:03.557]                           if (!has_future) {
[16:22:03.557]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:03.557]                               info)
[16:22:03.557]                           }
[16:22:03.557]                           else {
[16:22:03.557]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:03.557]                               info, version)
[16:22:03.557]                           }
[16:22:03.557]                           base::stop(msg)
[16:22:03.557]                         }
[16:22:03.557]                       })
[16:22:03.557]                     }
[16:22:03.557]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:03.557]                     base::options(mc.cores = 1L)
[16:22:03.557]                   }
[16:22:03.557]                   ...future.strategy.old <- future::plan("list")
[16:22:03.557]                   options(future.plan = NULL)
[16:22:03.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:03.557]                 }
[16:22:03.557]                 ...future.workdir <- getwd()
[16:22:03.557]             }
[16:22:03.557]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:03.557]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:03.557]         }
[16:22:03.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:03.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:03.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:03.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:03.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:03.557]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:03.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:03.557]             base::names(...future.oldOptions))
[16:22:03.557]     }
[16:22:03.557]     if (FALSE) {
[16:22:03.557]     }
[16:22:03.557]     else {
[16:22:03.557]         if (TRUE) {
[16:22:03.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:03.557]                 open = "w")
[16:22:03.557]         }
[16:22:03.557]         else {
[16:22:03.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:03.557]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:03.557]         }
[16:22:03.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:03.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:03.557]             base::sink(type = "output", split = FALSE)
[16:22:03.557]             base::close(...future.stdout)
[16:22:03.557]         }, add = TRUE)
[16:22:03.557]     }
[16:22:03.557]     ...future.frame <- base::sys.nframe()
[16:22:03.557]     ...future.conditions <- base::list()
[16:22:03.557]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:03.557]     if (FALSE) {
[16:22:03.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:03.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:03.557]     }
[16:22:03.557]     ...future.result <- base::tryCatch({
[16:22:03.557]         base::withCallingHandlers({
[16:22:03.557]             ...future.value <- base::withVisible(base::local({
[16:22:03.557]                 ...future.makeSendCondition <- base::local({
[16:22:03.557]                   sendCondition <- NULL
[16:22:03.557]                   function(frame = 1L) {
[16:22:03.557]                     if (is.function(sendCondition)) 
[16:22:03.557]                       return(sendCondition)
[16:22:03.557]                     ns <- getNamespace("parallel")
[16:22:03.557]                     if (exists("sendData", mode = "function", 
[16:22:03.557]                       envir = ns)) {
[16:22:03.557]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:03.557]                         envir = ns)
[16:22:03.557]                       envir <- sys.frame(frame)
[16:22:03.557]                       master <- NULL
[16:22:03.557]                       while (!identical(envir, .GlobalEnv) && 
[16:22:03.557]                         !identical(envir, emptyenv())) {
[16:22:03.557]                         if (exists("master", mode = "list", envir = envir, 
[16:22:03.557]                           inherits = FALSE)) {
[16:22:03.557]                           master <- get("master", mode = "list", 
[16:22:03.557]                             envir = envir, inherits = FALSE)
[16:22:03.557]                           if (inherits(master, c("SOCKnode", 
[16:22:03.557]                             "SOCK0node"))) {
[16:22:03.557]                             sendCondition <<- function(cond) {
[16:22:03.557]                               data <- list(type = "VALUE", value = cond, 
[16:22:03.557]                                 success = TRUE)
[16:22:03.557]                               parallel_sendData(master, data)
[16:22:03.557]                             }
[16:22:03.557]                             return(sendCondition)
[16:22:03.557]                           }
[16:22:03.557]                         }
[16:22:03.557]                         frame <- frame + 1L
[16:22:03.557]                         envir <- sys.frame(frame)
[16:22:03.557]                       }
[16:22:03.557]                     }
[16:22:03.557]                     sendCondition <<- function(cond) NULL
[16:22:03.557]                   }
[16:22:03.557]                 })
[16:22:03.557]                 withCallingHandlers({
[16:22:03.557]                   {
[16:22:03.557]                     Sys.sleep(0.5)
[16:22:03.557]                     list(a = 1, b = 42L)
[16:22:03.557]                   }
[16:22:03.557]                 }, immediateCondition = function(cond) {
[16:22:03.557]                   sendCondition <- ...future.makeSendCondition()
[16:22:03.557]                   sendCondition(cond)
[16:22:03.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.557]                   {
[16:22:03.557]                     inherits <- base::inherits
[16:22:03.557]                     invokeRestart <- base::invokeRestart
[16:22:03.557]                     is.null <- base::is.null
[16:22:03.557]                     muffled <- FALSE
[16:22:03.557]                     if (inherits(cond, "message")) {
[16:22:03.557]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:03.557]                       if (muffled) 
[16:22:03.557]                         invokeRestart("muffleMessage")
[16:22:03.557]                     }
[16:22:03.557]                     else if (inherits(cond, "warning")) {
[16:22:03.557]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:03.557]                       if (muffled) 
[16:22:03.557]                         invokeRestart("muffleWarning")
[16:22:03.557]                     }
[16:22:03.557]                     else if (inherits(cond, "condition")) {
[16:22:03.557]                       if (!is.null(pattern)) {
[16:22:03.557]                         computeRestarts <- base::computeRestarts
[16:22:03.557]                         grepl <- base::grepl
[16:22:03.557]                         restarts <- computeRestarts(cond)
[16:22:03.557]                         for (restart in restarts) {
[16:22:03.557]                           name <- restart$name
[16:22:03.557]                           if (is.null(name)) 
[16:22:03.557]                             next
[16:22:03.557]                           if (!grepl(pattern, name)) 
[16:22:03.557]                             next
[16:22:03.557]                           invokeRestart(restart)
[16:22:03.557]                           muffled <- TRUE
[16:22:03.557]                           break
[16:22:03.557]                         }
[16:22:03.557]                       }
[16:22:03.557]                     }
[16:22:03.557]                     invisible(muffled)
[16:22:03.557]                   }
[16:22:03.557]                   muffleCondition(cond)
[16:22:03.557]                 })
[16:22:03.557]             }))
[16:22:03.557]             future::FutureResult(value = ...future.value$value, 
[16:22:03.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.557]                   ...future.rng), globalenv = if (FALSE) 
[16:22:03.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:03.557]                     ...future.globalenv.names))
[16:22:03.557]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:03.557]         }, condition = base::local({
[16:22:03.557]             c <- base::c
[16:22:03.557]             inherits <- base::inherits
[16:22:03.557]             invokeRestart <- base::invokeRestart
[16:22:03.557]             length <- base::length
[16:22:03.557]             list <- base::list
[16:22:03.557]             seq.int <- base::seq.int
[16:22:03.557]             signalCondition <- base::signalCondition
[16:22:03.557]             sys.calls <- base::sys.calls
[16:22:03.557]             `[[` <- base::`[[`
[16:22:03.557]             `+` <- base::`+`
[16:22:03.557]             `<<-` <- base::`<<-`
[16:22:03.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:03.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:03.557]                   3L)]
[16:22:03.557]             }
[16:22:03.557]             function(cond) {
[16:22:03.557]                 is_error <- inherits(cond, "error")
[16:22:03.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:03.557]                   NULL)
[16:22:03.557]                 if (is_error) {
[16:22:03.557]                   sessionInformation <- function() {
[16:22:03.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:03.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:03.557]                       search = base::search(), system = base::Sys.info())
[16:22:03.557]                   }
[16:22:03.557]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:03.557]                     cond$call), session = sessionInformation(), 
[16:22:03.557]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:03.557]                   signalCondition(cond)
[16:22:03.557]                 }
[16:22:03.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:03.557]                 "immediateCondition"))) {
[16:22:03.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:03.557]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:03.557]                   if (TRUE && !signal) {
[16:22:03.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.557]                     {
[16:22:03.557]                       inherits <- base::inherits
[16:22:03.557]                       invokeRestart <- base::invokeRestart
[16:22:03.557]                       is.null <- base::is.null
[16:22:03.557]                       muffled <- FALSE
[16:22:03.557]                       if (inherits(cond, "message")) {
[16:22:03.557]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.557]                         if (muffled) 
[16:22:03.557]                           invokeRestart("muffleMessage")
[16:22:03.557]                       }
[16:22:03.557]                       else if (inherits(cond, "warning")) {
[16:22:03.557]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.557]                         if (muffled) 
[16:22:03.557]                           invokeRestart("muffleWarning")
[16:22:03.557]                       }
[16:22:03.557]                       else if (inherits(cond, "condition")) {
[16:22:03.557]                         if (!is.null(pattern)) {
[16:22:03.557]                           computeRestarts <- base::computeRestarts
[16:22:03.557]                           grepl <- base::grepl
[16:22:03.557]                           restarts <- computeRestarts(cond)
[16:22:03.557]                           for (restart in restarts) {
[16:22:03.557]                             name <- restart$name
[16:22:03.557]                             if (is.null(name)) 
[16:22:03.557]                               next
[16:22:03.557]                             if (!grepl(pattern, name)) 
[16:22:03.557]                               next
[16:22:03.557]                             invokeRestart(restart)
[16:22:03.557]                             muffled <- TRUE
[16:22:03.557]                             break
[16:22:03.557]                           }
[16:22:03.557]                         }
[16:22:03.557]                       }
[16:22:03.557]                       invisible(muffled)
[16:22:03.557]                     }
[16:22:03.557]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.557]                   }
[16:22:03.557]                 }
[16:22:03.557]                 else {
[16:22:03.557]                   if (TRUE) {
[16:22:03.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.557]                     {
[16:22:03.557]                       inherits <- base::inherits
[16:22:03.557]                       invokeRestart <- base::invokeRestart
[16:22:03.557]                       is.null <- base::is.null
[16:22:03.557]                       muffled <- FALSE
[16:22:03.557]                       if (inherits(cond, "message")) {
[16:22:03.557]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.557]                         if (muffled) 
[16:22:03.557]                           invokeRestart("muffleMessage")
[16:22:03.557]                       }
[16:22:03.557]                       else if (inherits(cond, "warning")) {
[16:22:03.557]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.557]                         if (muffled) 
[16:22:03.557]                           invokeRestart("muffleWarning")
[16:22:03.557]                       }
[16:22:03.557]                       else if (inherits(cond, "condition")) {
[16:22:03.557]                         if (!is.null(pattern)) {
[16:22:03.557]                           computeRestarts <- base::computeRestarts
[16:22:03.557]                           grepl <- base::grepl
[16:22:03.557]                           restarts <- computeRestarts(cond)
[16:22:03.557]                           for (restart in restarts) {
[16:22:03.557]                             name <- restart$name
[16:22:03.557]                             if (is.null(name)) 
[16:22:03.557]                               next
[16:22:03.557]                             if (!grepl(pattern, name)) 
[16:22:03.557]                               next
[16:22:03.557]                             invokeRestart(restart)
[16:22:03.557]                             muffled <- TRUE
[16:22:03.557]                             break
[16:22:03.557]                           }
[16:22:03.557]                         }
[16:22:03.557]                       }
[16:22:03.557]                       invisible(muffled)
[16:22:03.557]                     }
[16:22:03.557]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.557]                   }
[16:22:03.557]                 }
[16:22:03.557]             }
[16:22:03.557]         }))
[16:22:03.557]     }, error = function(ex) {
[16:22:03.557]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:03.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.557]                 ...future.rng), started = ...future.startTime, 
[16:22:03.557]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:03.557]             version = "1.8"), class = "FutureResult")
[16:22:03.557]     }, finally = {
[16:22:03.557]         if (!identical(...future.workdir, getwd())) 
[16:22:03.557]             setwd(...future.workdir)
[16:22:03.557]         {
[16:22:03.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:03.557]                 ...future.oldOptions$nwarnings <- NULL
[16:22:03.557]             }
[16:22:03.557]             base::options(...future.oldOptions)
[16:22:03.557]             if (.Platform$OS.type == "windows") {
[16:22:03.557]                 old_names <- names(...future.oldEnvVars)
[16:22:03.557]                 envs <- base::Sys.getenv()
[16:22:03.557]                 names <- names(envs)
[16:22:03.557]                 common <- intersect(names, old_names)
[16:22:03.557]                 added <- setdiff(names, old_names)
[16:22:03.557]                 removed <- setdiff(old_names, names)
[16:22:03.557]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:03.557]                   envs[common]]
[16:22:03.557]                 NAMES <- toupper(changed)
[16:22:03.557]                 args <- list()
[16:22:03.557]                 for (kk in seq_along(NAMES)) {
[16:22:03.557]                   name <- changed[[kk]]
[16:22:03.557]                   NAME <- NAMES[[kk]]
[16:22:03.557]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.557]                     next
[16:22:03.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.557]                 }
[16:22:03.557]                 NAMES <- toupper(added)
[16:22:03.557]                 for (kk in seq_along(NAMES)) {
[16:22:03.557]                   name <- added[[kk]]
[16:22:03.557]                   NAME <- NAMES[[kk]]
[16:22:03.557]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.557]                     next
[16:22:03.557]                   args[[name]] <- ""
[16:22:03.557]                 }
[16:22:03.557]                 NAMES <- toupper(removed)
[16:22:03.557]                 for (kk in seq_along(NAMES)) {
[16:22:03.557]                   name <- removed[[kk]]
[16:22:03.557]                   NAME <- NAMES[[kk]]
[16:22:03.557]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.557]                     next
[16:22:03.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.557]                 }
[16:22:03.557]                 if (length(args) > 0) 
[16:22:03.557]                   base::do.call(base::Sys.setenv, args = args)
[16:22:03.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:03.557]             }
[16:22:03.557]             else {
[16:22:03.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:03.557]             }
[16:22:03.557]             {
[16:22:03.557]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:03.557]                   0L) {
[16:22:03.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:03.557]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:03.557]                   base::options(opts)
[16:22:03.557]                 }
[16:22:03.557]                 {
[16:22:03.557]                   {
[16:22:03.557]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:03.557]                     NULL
[16:22:03.557]                   }
[16:22:03.557]                   options(future.plan = NULL)
[16:22:03.557]                   if (is.na(NA_character_)) 
[16:22:03.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:03.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:03.557]                     .init = FALSE)
[16:22:03.557]                 }
[16:22:03.557]             }
[16:22:03.557]         }
[16:22:03.557]     })
[16:22:03.557]     if (TRUE) {
[16:22:03.557]         base::sink(type = "output", split = FALSE)
[16:22:03.557]         if (TRUE) {
[16:22:03.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:03.557]         }
[16:22:03.557]         else {
[16:22:03.557]             ...future.result["stdout"] <- base::list(NULL)
[16:22:03.557]         }
[16:22:03.557]         base::close(...future.stdout)
[16:22:03.557]         ...future.stdout <- NULL
[16:22:03.557]     }
[16:22:03.557]     ...future.result$conditions <- ...future.conditions
[16:22:03.557]     ...future.result$finished <- base::Sys.time()
[16:22:03.557]     ...future.result
[16:22:03.557] }
[16:22:03.561] MultisessionFuture started
[16:22:03.562] - Launch lazy future ... done
[16:22:03.562] run() for ‘MultisessionFuture’ ... done
[16:22:03.562] getGlobalsAndPackages() ...
[16:22:03.562] Searching for globals...
[16:22:03.564] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:03.564] Searching for globals ... DONE
[16:22:03.565] Resolving globals: FALSE
[16:22:03.565] 
[16:22:03.565] 
[16:22:03.565] getGlobalsAndPackages() ... DONE
- w/ exception ...
[16:22:03.566] getGlobalsAndPackages() ...
[16:22:03.566] Searching for globals...
[16:22:03.567] - globals found: [2] ‘list’, ‘stop’
[16:22:03.567] Searching for globals ... DONE
[16:22:03.568] Resolving globals: FALSE
[16:22:03.568] 
[16:22:03.568] 
[16:22:03.568] getGlobalsAndPackages() ... DONE
[16:22:03.569] run() for ‘Future’ ...
[16:22:03.569] - state: ‘created’
[16:22:03.569] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:03.584] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:03.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:03.584]   - Field: ‘node’
[16:22:03.584]   - Field: ‘label’
[16:22:03.584]   - Field: ‘local’
[16:22:03.584]   - Field: ‘owner’
[16:22:03.584]   - Field: ‘envir’
[16:22:03.584]   - Field: ‘workers’
[16:22:03.584]   - Field: ‘packages’
[16:22:03.585]   - Field: ‘gc’
[16:22:03.585]   - Field: ‘conditions’
[16:22:03.585]   - Field: ‘persistent’
[16:22:03.585]   - Field: ‘expr’
[16:22:03.585]   - Field: ‘uuid’
[16:22:03.585]   - Field: ‘seed’
[16:22:03.585]   - Field: ‘version’
[16:22:03.585]   - Field: ‘result’
[16:22:03.585]   - Field: ‘asynchronous’
[16:22:03.585]   - Field: ‘calls’
[16:22:03.585]   - Field: ‘globals’
[16:22:03.586]   - Field: ‘stdout’
[16:22:03.586]   - Field: ‘earlySignal’
[16:22:03.586]   - Field: ‘lazy’
[16:22:03.586]   - Field: ‘state’
[16:22:03.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:03.586] - Launch lazy future ...
[16:22:03.586] Packages needed by the future expression (n = 0): <none>
[16:22:03.586] Packages needed by future strategies (n = 0): <none>
[16:22:03.587] {
[16:22:03.587]     {
[16:22:03.587]         {
[16:22:03.587]             ...future.startTime <- base::Sys.time()
[16:22:03.587]             {
[16:22:03.587]                 {
[16:22:03.587]                   {
[16:22:03.587]                     {
[16:22:03.587]                       base::local({
[16:22:03.587]                         has_future <- base::requireNamespace("future", 
[16:22:03.587]                           quietly = TRUE)
[16:22:03.587]                         if (has_future) {
[16:22:03.587]                           ns <- base::getNamespace("future")
[16:22:03.587]                           version <- ns[[".package"]][["version"]]
[16:22:03.587]                           if (is.null(version)) 
[16:22:03.587]                             version <- utils::packageVersion("future")
[16:22:03.587]                         }
[16:22:03.587]                         else {
[16:22:03.587]                           version <- NULL
[16:22:03.587]                         }
[16:22:03.587]                         if (!has_future || version < "1.8.0") {
[16:22:03.587]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:03.587]                             "", base::R.version$version.string), 
[16:22:03.587]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:03.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:03.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:03.587]                               "release", "version")], collapse = " "), 
[16:22:03.587]                             hostname = base::Sys.info()[["nodename"]])
[16:22:03.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:03.587]                             info)
[16:22:03.587]                           info <- base::paste(info, collapse = "; ")
[16:22:03.587]                           if (!has_future) {
[16:22:03.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:03.587]                               info)
[16:22:03.587]                           }
[16:22:03.587]                           else {
[16:22:03.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:03.587]                               info, version)
[16:22:03.587]                           }
[16:22:03.587]                           base::stop(msg)
[16:22:03.587]                         }
[16:22:03.587]                       })
[16:22:03.587]                     }
[16:22:03.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:03.587]                     base::options(mc.cores = 1L)
[16:22:03.587]                   }
[16:22:03.587]                   ...future.strategy.old <- future::plan("list")
[16:22:03.587]                   options(future.plan = NULL)
[16:22:03.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:03.587]                 }
[16:22:03.587]                 ...future.workdir <- getwd()
[16:22:03.587]             }
[16:22:03.587]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:03.587]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:03.587]         }
[16:22:03.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:03.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:03.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:03.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:03.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:03.587]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:03.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:03.587]             base::names(...future.oldOptions))
[16:22:03.587]     }
[16:22:03.587]     if (FALSE) {
[16:22:03.587]     }
[16:22:03.587]     else {
[16:22:03.587]         if (TRUE) {
[16:22:03.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:03.587]                 open = "w")
[16:22:03.587]         }
[16:22:03.587]         else {
[16:22:03.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:03.587]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:03.587]         }
[16:22:03.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:03.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:03.587]             base::sink(type = "output", split = FALSE)
[16:22:03.587]             base::close(...future.stdout)
[16:22:03.587]         }, add = TRUE)
[16:22:03.587]     }
[16:22:03.587]     ...future.frame <- base::sys.nframe()
[16:22:03.587]     ...future.conditions <- base::list()
[16:22:03.587]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:03.587]     if (FALSE) {
[16:22:03.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:03.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:03.587]     }
[16:22:03.587]     ...future.result <- base::tryCatch({
[16:22:03.587]         base::withCallingHandlers({
[16:22:03.587]             ...future.value <- base::withVisible(base::local({
[16:22:03.587]                 ...future.makeSendCondition <- base::local({
[16:22:03.587]                   sendCondition <- NULL
[16:22:03.587]                   function(frame = 1L) {
[16:22:03.587]                     if (is.function(sendCondition)) 
[16:22:03.587]                       return(sendCondition)
[16:22:03.587]                     ns <- getNamespace("parallel")
[16:22:03.587]                     if (exists("sendData", mode = "function", 
[16:22:03.587]                       envir = ns)) {
[16:22:03.587]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:03.587]                         envir = ns)
[16:22:03.587]                       envir <- sys.frame(frame)
[16:22:03.587]                       master <- NULL
[16:22:03.587]                       while (!identical(envir, .GlobalEnv) && 
[16:22:03.587]                         !identical(envir, emptyenv())) {
[16:22:03.587]                         if (exists("master", mode = "list", envir = envir, 
[16:22:03.587]                           inherits = FALSE)) {
[16:22:03.587]                           master <- get("master", mode = "list", 
[16:22:03.587]                             envir = envir, inherits = FALSE)
[16:22:03.587]                           if (inherits(master, c("SOCKnode", 
[16:22:03.587]                             "SOCK0node"))) {
[16:22:03.587]                             sendCondition <<- function(cond) {
[16:22:03.587]                               data <- list(type = "VALUE", value = cond, 
[16:22:03.587]                                 success = TRUE)
[16:22:03.587]                               parallel_sendData(master, data)
[16:22:03.587]                             }
[16:22:03.587]                             return(sendCondition)
[16:22:03.587]                           }
[16:22:03.587]                         }
[16:22:03.587]                         frame <- frame + 1L
[16:22:03.587]                         envir <- sys.frame(frame)
[16:22:03.587]                       }
[16:22:03.587]                     }
[16:22:03.587]                     sendCondition <<- function(cond) NULL
[16:22:03.587]                   }
[16:22:03.587]                 })
[16:22:03.587]                 withCallingHandlers({
[16:22:03.587]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:03.587]                 }, immediateCondition = function(cond) {
[16:22:03.587]                   sendCondition <- ...future.makeSendCondition()
[16:22:03.587]                   sendCondition(cond)
[16:22:03.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.587]                   {
[16:22:03.587]                     inherits <- base::inherits
[16:22:03.587]                     invokeRestart <- base::invokeRestart
[16:22:03.587]                     is.null <- base::is.null
[16:22:03.587]                     muffled <- FALSE
[16:22:03.587]                     if (inherits(cond, "message")) {
[16:22:03.587]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:03.587]                       if (muffled) 
[16:22:03.587]                         invokeRestart("muffleMessage")
[16:22:03.587]                     }
[16:22:03.587]                     else if (inherits(cond, "warning")) {
[16:22:03.587]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:03.587]                       if (muffled) 
[16:22:03.587]                         invokeRestart("muffleWarning")
[16:22:03.587]                     }
[16:22:03.587]                     else if (inherits(cond, "condition")) {
[16:22:03.587]                       if (!is.null(pattern)) {
[16:22:03.587]                         computeRestarts <- base::computeRestarts
[16:22:03.587]                         grepl <- base::grepl
[16:22:03.587]                         restarts <- computeRestarts(cond)
[16:22:03.587]                         for (restart in restarts) {
[16:22:03.587]                           name <- restart$name
[16:22:03.587]                           if (is.null(name)) 
[16:22:03.587]                             next
[16:22:03.587]                           if (!grepl(pattern, name)) 
[16:22:03.587]                             next
[16:22:03.587]                           invokeRestart(restart)
[16:22:03.587]                           muffled <- TRUE
[16:22:03.587]                           break
[16:22:03.587]                         }
[16:22:03.587]                       }
[16:22:03.587]                     }
[16:22:03.587]                     invisible(muffled)
[16:22:03.587]                   }
[16:22:03.587]                   muffleCondition(cond)
[16:22:03.587]                 })
[16:22:03.587]             }))
[16:22:03.587]             future::FutureResult(value = ...future.value$value, 
[16:22:03.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.587]                   ...future.rng), globalenv = if (FALSE) 
[16:22:03.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:03.587]                     ...future.globalenv.names))
[16:22:03.587]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:03.587]         }, condition = base::local({
[16:22:03.587]             c <- base::c
[16:22:03.587]             inherits <- base::inherits
[16:22:03.587]             invokeRestart <- base::invokeRestart
[16:22:03.587]             length <- base::length
[16:22:03.587]             list <- base::list
[16:22:03.587]             seq.int <- base::seq.int
[16:22:03.587]             signalCondition <- base::signalCondition
[16:22:03.587]             sys.calls <- base::sys.calls
[16:22:03.587]             `[[` <- base::`[[`
[16:22:03.587]             `+` <- base::`+`
[16:22:03.587]             `<<-` <- base::`<<-`
[16:22:03.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:03.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:03.587]                   3L)]
[16:22:03.587]             }
[16:22:03.587]             function(cond) {
[16:22:03.587]                 is_error <- inherits(cond, "error")
[16:22:03.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:03.587]                   NULL)
[16:22:03.587]                 if (is_error) {
[16:22:03.587]                   sessionInformation <- function() {
[16:22:03.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:03.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:03.587]                       search = base::search(), system = base::Sys.info())
[16:22:03.587]                   }
[16:22:03.587]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:03.587]                     cond$call), session = sessionInformation(), 
[16:22:03.587]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:03.587]                   signalCondition(cond)
[16:22:03.587]                 }
[16:22:03.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:03.587]                 "immediateCondition"))) {
[16:22:03.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:03.587]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:03.587]                   if (TRUE && !signal) {
[16:22:03.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.587]                     {
[16:22:03.587]                       inherits <- base::inherits
[16:22:03.587]                       invokeRestart <- base::invokeRestart
[16:22:03.587]                       is.null <- base::is.null
[16:22:03.587]                       muffled <- FALSE
[16:22:03.587]                       if (inherits(cond, "message")) {
[16:22:03.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.587]                         if (muffled) 
[16:22:03.587]                           invokeRestart("muffleMessage")
[16:22:03.587]                       }
[16:22:03.587]                       else if (inherits(cond, "warning")) {
[16:22:03.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.587]                         if (muffled) 
[16:22:03.587]                           invokeRestart("muffleWarning")
[16:22:03.587]                       }
[16:22:03.587]                       else if (inherits(cond, "condition")) {
[16:22:03.587]                         if (!is.null(pattern)) {
[16:22:03.587]                           computeRestarts <- base::computeRestarts
[16:22:03.587]                           grepl <- base::grepl
[16:22:03.587]                           restarts <- computeRestarts(cond)
[16:22:03.587]                           for (restart in restarts) {
[16:22:03.587]                             name <- restart$name
[16:22:03.587]                             if (is.null(name)) 
[16:22:03.587]                               next
[16:22:03.587]                             if (!grepl(pattern, name)) 
[16:22:03.587]                               next
[16:22:03.587]                             invokeRestart(restart)
[16:22:03.587]                             muffled <- TRUE
[16:22:03.587]                             break
[16:22:03.587]                           }
[16:22:03.587]                         }
[16:22:03.587]                       }
[16:22:03.587]                       invisible(muffled)
[16:22:03.587]                     }
[16:22:03.587]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.587]                   }
[16:22:03.587]                 }
[16:22:03.587]                 else {
[16:22:03.587]                   if (TRUE) {
[16:22:03.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.587]                     {
[16:22:03.587]                       inherits <- base::inherits
[16:22:03.587]                       invokeRestart <- base::invokeRestart
[16:22:03.587]                       is.null <- base::is.null
[16:22:03.587]                       muffled <- FALSE
[16:22:03.587]                       if (inherits(cond, "message")) {
[16:22:03.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.587]                         if (muffled) 
[16:22:03.587]                           invokeRestart("muffleMessage")
[16:22:03.587]                       }
[16:22:03.587]                       else if (inherits(cond, "warning")) {
[16:22:03.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.587]                         if (muffled) 
[16:22:03.587]                           invokeRestart("muffleWarning")
[16:22:03.587]                       }
[16:22:03.587]                       else if (inherits(cond, "condition")) {
[16:22:03.587]                         if (!is.null(pattern)) {
[16:22:03.587]                           computeRestarts <- base::computeRestarts
[16:22:03.587]                           grepl <- base::grepl
[16:22:03.587]                           restarts <- computeRestarts(cond)
[16:22:03.587]                           for (restart in restarts) {
[16:22:03.587]                             name <- restart$name
[16:22:03.587]                             if (is.null(name)) 
[16:22:03.587]                               next
[16:22:03.587]                             if (!grepl(pattern, name)) 
[16:22:03.587]                               next
[16:22:03.587]                             invokeRestart(restart)
[16:22:03.587]                             muffled <- TRUE
[16:22:03.587]                             break
[16:22:03.587]                           }
[16:22:03.587]                         }
[16:22:03.587]                       }
[16:22:03.587]                       invisible(muffled)
[16:22:03.587]                     }
[16:22:03.587]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.587]                   }
[16:22:03.587]                 }
[16:22:03.587]             }
[16:22:03.587]         }))
[16:22:03.587]     }, error = function(ex) {
[16:22:03.587]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:03.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.587]                 ...future.rng), started = ...future.startTime, 
[16:22:03.587]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:03.587]             version = "1.8"), class = "FutureResult")
[16:22:03.587]     }, finally = {
[16:22:03.587]         if (!identical(...future.workdir, getwd())) 
[16:22:03.587]             setwd(...future.workdir)
[16:22:03.587]         {
[16:22:03.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:03.587]                 ...future.oldOptions$nwarnings <- NULL
[16:22:03.587]             }
[16:22:03.587]             base::options(...future.oldOptions)
[16:22:03.587]             if (.Platform$OS.type == "windows") {
[16:22:03.587]                 old_names <- names(...future.oldEnvVars)
[16:22:03.587]                 envs <- base::Sys.getenv()
[16:22:03.587]                 names <- names(envs)
[16:22:03.587]                 common <- intersect(names, old_names)
[16:22:03.587]                 added <- setdiff(names, old_names)
[16:22:03.587]                 removed <- setdiff(old_names, names)
[16:22:03.587]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:03.587]                   envs[common]]
[16:22:03.587]                 NAMES <- toupper(changed)
[16:22:03.587]                 args <- list()
[16:22:03.587]                 for (kk in seq_along(NAMES)) {
[16:22:03.587]                   name <- changed[[kk]]
[16:22:03.587]                   NAME <- NAMES[[kk]]
[16:22:03.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.587]                     next
[16:22:03.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.587]                 }
[16:22:03.587]                 NAMES <- toupper(added)
[16:22:03.587]                 for (kk in seq_along(NAMES)) {
[16:22:03.587]                   name <- added[[kk]]
[16:22:03.587]                   NAME <- NAMES[[kk]]
[16:22:03.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.587]                     next
[16:22:03.587]                   args[[name]] <- ""
[16:22:03.587]                 }
[16:22:03.587]                 NAMES <- toupper(removed)
[16:22:03.587]                 for (kk in seq_along(NAMES)) {
[16:22:03.587]                   name <- removed[[kk]]
[16:22:03.587]                   NAME <- NAMES[[kk]]
[16:22:03.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.587]                     next
[16:22:03.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.587]                 }
[16:22:03.587]                 if (length(args) > 0) 
[16:22:03.587]                   base::do.call(base::Sys.setenv, args = args)
[16:22:03.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:03.587]             }
[16:22:03.587]             else {
[16:22:03.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:03.587]             }
[16:22:03.587]             {
[16:22:03.587]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:03.587]                   0L) {
[16:22:03.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:03.587]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:03.587]                   base::options(opts)
[16:22:03.587]                 }
[16:22:03.587]                 {
[16:22:03.587]                   {
[16:22:03.587]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:03.587]                     NULL
[16:22:03.587]                   }
[16:22:03.587]                   options(future.plan = NULL)
[16:22:03.587]                   if (is.na(NA_character_)) 
[16:22:03.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:03.587]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:03.587]                     .init = FALSE)
[16:22:03.587]                 }
[16:22:03.587]             }
[16:22:03.587]         }
[16:22:03.587]     })
[16:22:03.587]     if (TRUE) {
[16:22:03.587]         base::sink(type = "output", split = FALSE)
[16:22:03.587]         if (TRUE) {
[16:22:03.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:03.587]         }
[16:22:03.587]         else {
[16:22:03.587]             ...future.result["stdout"] <- base::list(NULL)
[16:22:03.587]         }
[16:22:03.587]         base::close(...future.stdout)
[16:22:03.587]         ...future.stdout <- NULL
[16:22:03.587]     }
[16:22:03.587]     ...future.result$conditions <- ...future.conditions
[16:22:03.587]     ...future.result$finished <- base::Sys.time()
[16:22:03.587]     ...future.result
[16:22:03.587] }
[16:22:03.589] Poll #1 (0): usedNodes() = 2, workers = 2
[16:22:03.599] receiveMessageFromWorker() for ClusterFuture ...
[16:22:03.600] - Validating connection of MultisessionFuture
[16:22:03.600] - received message: FutureResult
[16:22:03.600] - Received FutureResult
[16:22:03.600] - Erased future from FutureRegistry
[16:22:03.600] result() for ClusterFuture ...
[16:22:03.600] - result already collected: FutureResult
[16:22:03.600] result() for ClusterFuture ... done
[16:22:03.601] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:03.601] result() for ClusterFuture ...
[16:22:03.601] - result already collected: FutureResult
[16:22:03.601] result() for ClusterFuture ... done
[16:22:03.601] result() for ClusterFuture ...
[16:22:03.601] - result already collected: FutureResult
[16:22:03.601] result() for ClusterFuture ... done
[16:22:03.602] MultisessionFuture started
[16:22:03.602] - Launch lazy future ... done
[16:22:03.602] run() for ‘MultisessionFuture’ ... done
[16:22:03.602] getGlobalsAndPackages() ...
[16:22:03.602] Searching for globals...
[16:22:03.603] - globals found: [2] ‘list’, ‘stop’
[16:22:03.603] Searching for globals ... DONE
[16:22:03.603] Resolving globals: FALSE
[16:22:03.604] 
[16:22:03.604] 
[16:22:03.604] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[16:22:03.604] getGlobalsAndPackages() ...
[16:22:03.604] Searching for globals...
[16:22:03.605] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:03.605] Searching for globals ... DONE
[16:22:03.605] Resolving globals: FALSE
[16:22:03.606] 
[16:22:03.606] 
[16:22:03.606] getGlobalsAndPackages() ... DONE
[16:22:03.606] run() for ‘Future’ ...
[16:22:03.606] - state: ‘created’
[16:22:03.606] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:03.620] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:03.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:03.620]   - Field: ‘node’
[16:22:03.620]   - Field: ‘label’
[16:22:03.620]   - Field: ‘local’
[16:22:03.621]   - Field: ‘owner’
[16:22:03.621]   - Field: ‘envir’
[16:22:03.621]   - Field: ‘workers’
[16:22:03.621]   - Field: ‘packages’
[16:22:03.621]   - Field: ‘gc’
[16:22:03.621]   - Field: ‘conditions’
[16:22:03.621]   - Field: ‘persistent’
[16:22:03.621]   - Field: ‘expr’
[16:22:03.621]   - Field: ‘uuid’
[16:22:03.621]   - Field: ‘seed’
[16:22:03.621]   - Field: ‘version’
[16:22:03.622]   - Field: ‘result’
[16:22:03.622]   - Field: ‘asynchronous’
[16:22:03.622]   - Field: ‘calls’
[16:22:03.622]   - Field: ‘globals’
[16:22:03.622]   - Field: ‘stdout’
[16:22:03.622]   - Field: ‘earlySignal’
[16:22:03.622]   - Field: ‘lazy’
[16:22:03.622]   - Field: ‘state’
[16:22:03.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:03.622] - Launch lazy future ...
[16:22:03.623] Packages needed by the future expression (n = 0): <none>
[16:22:03.623] Packages needed by future strategies (n = 0): <none>
[16:22:03.623] {
[16:22:03.623]     {
[16:22:03.623]         {
[16:22:03.623]             ...future.startTime <- base::Sys.time()
[16:22:03.623]             {
[16:22:03.623]                 {
[16:22:03.623]                   {
[16:22:03.623]                     {
[16:22:03.623]                       base::local({
[16:22:03.623]                         has_future <- base::requireNamespace("future", 
[16:22:03.623]                           quietly = TRUE)
[16:22:03.623]                         if (has_future) {
[16:22:03.623]                           ns <- base::getNamespace("future")
[16:22:03.623]                           version <- ns[[".package"]][["version"]]
[16:22:03.623]                           if (is.null(version)) 
[16:22:03.623]                             version <- utils::packageVersion("future")
[16:22:03.623]                         }
[16:22:03.623]                         else {
[16:22:03.623]                           version <- NULL
[16:22:03.623]                         }
[16:22:03.623]                         if (!has_future || version < "1.8.0") {
[16:22:03.623]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:03.623]                             "", base::R.version$version.string), 
[16:22:03.623]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:03.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:03.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:03.623]                               "release", "version")], collapse = " "), 
[16:22:03.623]                             hostname = base::Sys.info()[["nodename"]])
[16:22:03.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:03.623]                             info)
[16:22:03.623]                           info <- base::paste(info, collapse = "; ")
[16:22:03.623]                           if (!has_future) {
[16:22:03.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:03.623]                               info)
[16:22:03.623]                           }
[16:22:03.623]                           else {
[16:22:03.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:03.623]                               info, version)
[16:22:03.623]                           }
[16:22:03.623]                           base::stop(msg)
[16:22:03.623]                         }
[16:22:03.623]                       })
[16:22:03.623]                     }
[16:22:03.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:03.623]                     base::options(mc.cores = 1L)
[16:22:03.623]                   }
[16:22:03.623]                   ...future.strategy.old <- future::plan("list")
[16:22:03.623]                   options(future.plan = NULL)
[16:22:03.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:03.623]                 }
[16:22:03.623]                 ...future.workdir <- getwd()
[16:22:03.623]             }
[16:22:03.623]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:03.623]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:03.623]         }
[16:22:03.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:03.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:03.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:03.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:03.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:03.623]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:03.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:03.623]             base::names(...future.oldOptions))
[16:22:03.623]     }
[16:22:03.623]     if (FALSE) {
[16:22:03.623]     }
[16:22:03.623]     else {
[16:22:03.623]         if (TRUE) {
[16:22:03.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:03.623]                 open = "w")
[16:22:03.623]         }
[16:22:03.623]         else {
[16:22:03.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:03.623]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:03.623]         }
[16:22:03.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:03.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:03.623]             base::sink(type = "output", split = FALSE)
[16:22:03.623]             base::close(...future.stdout)
[16:22:03.623]         }, add = TRUE)
[16:22:03.623]     }
[16:22:03.623]     ...future.frame <- base::sys.nframe()
[16:22:03.623]     ...future.conditions <- base::list()
[16:22:03.623]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:03.623]     if (FALSE) {
[16:22:03.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:03.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:03.623]     }
[16:22:03.623]     ...future.result <- base::tryCatch({
[16:22:03.623]         base::withCallingHandlers({
[16:22:03.623]             ...future.value <- base::withVisible(base::local({
[16:22:03.623]                 ...future.makeSendCondition <- base::local({
[16:22:03.623]                   sendCondition <- NULL
[16:22:03.623]                   function(frame = 1L) {
[16:22:03.623]                     if (is.function(sendCondition)) 
[16:22:03.623]                       return(sendCondition)
[16:22:03.623]                     ns <- getNamespace("parallel")
[16:22:03.623]                     if (exists("sendData", mode = "function", 
[16:22:03.623]                       envir = ns)) {
[16:22:03.623]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:03.623]                         envir = ns)
[16:22:03.623]                       envir <- sys.frame(frame)
[16:22:03.623]                       master <- NULL
[16:22:03.623]                       while (!identical(envir, .GlobalEnv) && 
[16:22:03.623]                         !identical(envir, emptyenv())) {
[16:22:03.623]                         if (exists("master", mode = "list", envir = envir, 
[16:22:03.623]                           inherits = FALSE)) {
[16:22:03.623]                           master <- get("master", mode = "list", 
[16:22:03.623]                             envir = envir, inherits = FALSE)
[16:22:03.623]                           if (inherits(master, c("SOCKnode", 
[16:22:03.623]                             "SOCK0node"))) {
[16:22:03.623]                             sendCondition <<- function(cond) {
[16:22:03.623]                               data <- list(type = "VALUE", value = cond, 
[16:22:03.623]                                 success = TRUE)
[16:22:03.623]                               parallel_sendData(master, data)
[16:22:03.623]                             }
[16:22:03.623]                             return(sendCondition)
[16:22:03.623]                           }
[16:22:03.623]                         }
[16:22:03.623]                         frame <- frame + 1L
[16:22:03.623]                         envir <- sys.frame(frame)
[16:22:03.623]                       }
[16:22:03.623]                     }
[16:22:03.623]                     sendCondition <<- function(cond) NULL
[16:22:03.623]                   }
[16:22:03.623]                 })
[16:22:03.623]                 withCallingHandlers({
[16:22:03.623]                   {
[16:22:03.623]                     Sys.sleep(0.5)
[16:22:03.623]                     list(a = 1, b = 42L)
[16:22:03.623]                   }
[16:22:03.623]                 }, immediateCondition = function(cond) {
[16:22:03.623]                   sendCondition <- ...future.makeSendCondition()
[16:22:03.623]                   sendCondition(cond)
[16:22:03.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.623]                   {
[16:22:03.623]                     inherits <- base::inherits
[16:22:03.623]                     invokeRestart <- base::invokeRestart
[16:22:03.623]                     is.null <- base::is.null
[16:22:03.623]                     muffled <- FALSE
[16:22:03.623]                     if (inherits(cond, "message")) {
[16:22:03.623]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:03.623]                       if (muffled) 
[16:22:03.623]                         invokeRestart("muffleMessage")
[16:22:03.623]                     }
[16:22:03.623]                     else if (inherits(cond, "warning")) {
[16:22:03.623]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:03.623]                       if (muffled) 
[16:22:03.623]                         invokeRestart("muffleWarning")
[16:22:03.623]                     }
[16:22:03.623]                     else if (inherits(cond, "condition")) {
[16:22:03.623]                       if (!is.null(pattern)) {
[16:22:03.623]                         computeRestarts <- base::computeRestarts
[16:22:03.623]                         grepl <- base::grepl
[16:22:03.623]                         restarts <- computeRestarts(cond)
[16:22:03.623]                         for (restart in restarts) {
[16:22:03.623]                           name <- restart$name
[16:22:03.623]                           if (is.null(name)) 
[16:22:03.623]                             next
[16:22:03.623]                           if (!grepl(pattern, name)) 
[16:22:03.623]                             next
[16:22:03.623]                           invokeRestart(restart)
[16:22:03.623]                           muffled <- TRUE
[16:22:03.623]                           break
[16:22:03.623]                         }
[16:22:03.623]                       }
[16:22:03.623]                     }
[16:22:03.623]                     invisible(muffled)
[16:22:03.623]                   }
[16:22:03.623]                   muffleCondition(cond)
[16:22:03.623]                 })
[16:22:03.623]             }))
[16:22:03.623]             future::FutureResult(value = ...future.value$value, 
[16:22:03.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.623]                   ...future.rng), globalenv = if (FALSE) 
[16:22:03.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:03.623]                     ...future.globalenv.names))
[16:22:03.623]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:03.623]         }, condition = base::local({
[16:22:03.623]             c <- base::c
[16:22:03.623]             inherits <- base::inherits
[16:22:03.623]             invokeRestart <- base::invokeRestart
[16:22:03.623]             length <- base::length
[16:22:03.623]             list <- base::list
[16:22:03.623]             seq.int <- base::seq.int
[16:22:03.623]             signalCondition <- base::signalCondition
[16:22:03.623]             sys.calls <- base::sys.calls
[16:22:03.623]             `[[` <- base::`[[`
[16:22:03.623]             `+` <- base::`+`
[16:22:03.623]             `<<-` <- base::`<<-`
[16:22:03.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:03.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:03.623]                   3L)]
[16:22:03.623]             }
[16:22:03.623]             function(cond) {
[16:22:03.623]                 is_error <- inherits(cond, "error")
[16:22:03.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:03.623]                   NULL)
[16:22:03.623]                 if (is_error) {
[16:22:03.623]                   sessionInformation <- function() {
[16:22:03.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:03.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:03.623]                       search = base::search(), system = base::Sys.info())
[16:22:03.623]                   }
[16:22:03.623]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:03.623]                     cond$call), session = sessionInformation(), 
[16:22:03.623]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:03.623]                   signalCondition(cond)
[16:22:03.623]                 }
[16:22:03.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:03.623]                 "immediateCondition"))) {
[16:22:03.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:03.623]                   ...future.conditions[[length(...future.conditions) + 
[16:22:03.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:03.623]                   if (TRUE && !signal) {
[16:22:03.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.623]                     {
[16:22:03.623]                       inherits <- base::inherits
[16:22:03.623]                       invokeRestart <- base::invokeRestart
[16:22:03.623]                       is.null <- base::is.null
[16:22:03.623]                       muffled <- FALSE
[16:22:03.623]                       if (inherits(cond, "message")) {
[16:22:03.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.623]                         if (muffled) 
[16:22:03.623]                           invokeRestart("muffleMessage")
[16:22:03.623]                       }
[16:22:03.623]                       else if (inherits(cond, "warning")) {
[16:22:03.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.623]                         if (muffled) 
[16:22:03.623]                           invokeRestart("muffleWarning")
[16:22:03.623]                       }
[16:22:03.623]                       else if (inherits(cond, "condition")) {
[16:22:03.623]                         if (!is.null(pattern)) {
[16:22:03.623]                           computeRestarts <- base::computeRestarts
[16:22:03.623]                           grepl <- base::grepl
[16:22:03.623]                           restarts <- computeRestarts(cond)
[16:22:03.623]                           for (restart in restarts) {
[16:22:03.623]                             name <- restart$name
[16:22:03.623]                             if (is.null(name)) 
[16:22:03.623]                               next
[16:22:03.623]                             if (!grepl(pattern, name)) 
[16:22:03.623]                               next
[16:22:03.623]                             invokeRestart(restart)
[16:22:03.623]                             muffled <- TRUE
[16:22:03.623]                             break
[16:22:03.623]                           }
[16:22:03.623]                         }
[16:22:03.623]                       }
[16:22:03.623]                       invisible(muffled)
[16:22:03.623]                     }
[16:22:03.623]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.623]                   }
[16:22:03.623]                 }
[16:22:03.623]                 else {
[16:22:03.623]                   if (TRUE) {
[16:22:03.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:03.623]                     {
[16:22:03.623]                       inherits <- base::inherits
[16:22:03.623]                       invokeRestart <- base::invokeRestart
[16:22:03.623]                       is.null <- base::is.null
[16:22:03.623]                       muffled <- FALSE
[16:22:03.623]                       if (inherits(cond, "message")) {
[16:22:03.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:03.623]                         if (muffled) 
[16:22:03.623]                           invokeRestart("muffleMessage")
[16:22:03.623]                       }
[16:22:03.623]                       else if (inherits(cond, "warning")) {
[16:22:03.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:03.623]                         if (muffled) 
[16:22:03.623]                           invokeRestart("muffleWarning")
[16:22:03.623]                       }
[16:22:03.623]                       else if (inherits(cond, "condition")) {
[16:22:03.623]                         if (!is.null(pattern)) {
[16:22:03.623]                           computeRestarts <- base::computeRestarts
[16:22:03.623]                           grepl <- base::grepl
[16:22:03.623]                           restarts <- computeRestarts(cond)
[16:22:03.623]                           for (restart in restarts) {
[16:22:03.623]                             name <- restart$name
[16:22:03.623]                             if (is.null(name)) 
[16:22:03.623]                               next
[16:22:03.623]                             if (!grepl(pattern, name)) 
[16:22:03.623]                               next
[16:22:03.623]                             invokeRestart(restart)
[16:22:03.623]                             muffled <- TRUE
[16:22:03.623]                             break
[16:22:03.623]                           }
[16:22:03.623]                         }
[16:22:03.623]                       }
[16:22:03.623]                       invisible(muffled)
[16:22:03.623]                     }
[16:22:03.623]                     muffleCondition(cond, pattern = "^muffle")
[16:22:03.623]                   }
[16:22:03.623]                 }
[16:22:03.623]             }
[16:22:03.623]         }))
[16:22:03.623]     }, error = function(ex) {
[16:22:03.623]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:03.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:03.623]                 ...future.rng), started = ...future.startTime, 
[16:22:03.623]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:03.623]             version = "1.8"), class = "FutureResult")
[16:22:03.623]     }, finally = {
[16:22:03.623]         if (!identical(...future.workdir, getwd())) 
[16:22:03.623]             setwd(...future.workdir)
[16:22:03.623]         {
[16:22:03.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:03.623]                 ...future.oldOptions$nwarnings <- NULL
[16:22:03.623]             }
[16:22:03.623]             base::options(...future.oldOptions)
[16:22:03.623]             if (.Platform$OS.type == "windows") {
[16:22:03.623]                 old_names <- names(...future.oldEnvVars)
[16:22:03.623]                 envs <- base::Sys.getenv()
[16:22:03.623]                 names <- names(envs)
[16:22:03.623]                 common <- intersect(names, old_names)
[16:22:03.623]                 added <- setdiff(names, old_names)
[16:22:03.623]                 removed <- setdiff(old_names, names)
[16:22:03.623]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:03.623]                   envs[common]]
[16:22:03.623]                 NAMES <- toupper(changed)
[16:22:03.623]                 args <- list()
[16:22:03.623]                 for (kk in seq_along(NAMES)) {
[16:22:03.623]                   name <- changed[[kk]]
[16:22:03.623]                   NAME <- NAMES[[kk]]
[16:22:03.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.623]                     next
[16:22:03.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.623]                 }
[16:22:03.623]                 NAMES <- toupper(added)
[16:22:03.623]                 for (kk in seq_along(NAMES)) {
[16:22:03.623]                   name <- added[[kk]]
[16:22:03.623]                   NAME <- NAMES[[kk]]
[16:22:03.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.623]                     next
[16:22:03.623]                   args[[name]] <- ""
[16:22:03.623]                 }
[16:22:03.623]                 NAMES <- toupper(removed)
[16:22:03.623]                 for (kk in seq_along(NAMES)) {
[16:22:03.623]                   name <- removed[[kk]]
[16:22:03.623]                   NAME <- NAMES[[kk]]
[16:22:03.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:03.623]                     next
[16:22:03.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:03.623]                 }
[16:22:03.623]                 if (length(args) > 0) 
[16:22:03.623]                   base::do.call(base::Sys.setenv, args = args)
[16:22:03.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:03.623]             }
[16:22:03.623]             else {
[16:22:03.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:03.623]             }
[16:22:03.623]             {
[16:22:03.623]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:03.623]                   0L) {
[16:22:03.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:03.623]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:03.623]                   base::options(opts)
[16:22:03.623]                 }
[16:22:03.623]                 {
[16:22:03.623]                   {
[16:22:03.623]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:03.623]                     NULL
[16:22:03.623]                   }
[16:22:03.623]                   options(future.plan = NULL)
[16:22:03.623]                   if (is.na(NA_character_)) 
[16:22:03.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:03.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:03.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:03.623]                     .init = FALSE)
[16:22:03.623]                 }
[16:22:03.623]             }
[16:22:03.623]         }
[16:22:03.623]     })
[16:22:03.623]     if (TRUE) {
[16:22:03.623]         base::sink(type = "output", split = FALSE)
[16:22:03.623]         if (TRUE) {
[16:22:03.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:03.623]         }
[16:22:03.623]         else {
[16:22:03.623]             ...future.result["stdout"] <- base::list(NULL)
[16:22:03.623]         }
[16:22:03.623]         base::close(...future.stdout)
[16:22:03.623]         ...future.stdout <- NULL
[16:22:03.623]     }
[16:22:03.623]     ...future.result$conditions <- ...future.conditions
[16:22:03.623]     ...future.result$finished <- base::Sys.time()
[16:22:03.623]     ...future.result
[16:22:03.623] }
[16:22:03.625] Poll #1 (0): usedNodes() = 2, workers = 2
[16:22:03.646] receiveMessageFromWorker() for ClusterFuture ...
[16:22:03.646] - Validating connection of MultisessionFuture
[16:22:03.647] - received message: FutureResult
[16:22:03.647] - Received FutureResult
[16:22:03.647] - Erased future from FutureRegistry
[16:22:03.647] result() for ClusterFuture ...
[16:22:03.647] - result already collected: FutureResult
[16:22:03.648] result() for ClusterFuture ... done
[16:22:03.648] signalConditions() ...
[16:22:03.648]  - include = ‘immediateCondition’
[16:22:03.648]  - exclude = 
[16:22:03.648]  - resignal = FALSE
[16:22:03.648]  - Number of conditions: 1
[16:22:03.648] signalConditions() ... done
[16:22:03.648] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:03.648] result() for ClusterFuture ...
[16:22:03.648] - result already collected: FutureResult
[16:22:03.648] result() for ClusterFuture ... done
[16:22:03.649] result() for ClusterFuture ...
[16:22:03.649] - result already collected: FutureResult
[16:22:03.649] result() for ClusterFuture ... done
[16:22:03.649] signalConditions() ...
[16:22:03.649]  - include = ‘immediateCondition’
[16:22:03.649]  - exclude = 
[16:22:03.649]  - resignal = FALSE
[16:22:03.649]  - Number of conditions: 1
[16:22:03.649] signalConditions() ... done
[16:22:03.650] MultisessionFuture started
[16:22:03.650] - Launch lazy future ... done
[16:22:03.651] run() for ‘MultisessionFuture’ ... done
[16:22:04.153] receiveMessageFromWorker() for ClusterFuture ...
[16:22:04.153] - Validating connection of MultisessionFuture
[16:22:04.154] - received message: FutureResult
[16:22:04.154] - Received FutureResult
[16:22:04.154] - Erased future from FutureRegistry
[16:22:04.154] result() for ClusterFuture ...
[16:22:04.154] - result already collected: FutureResult
[16:22:04.154] result() for ClusterFuture ... done
[16:22:04.154] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:04.154] A MultisessionFuture was resolved
[16:22:04.154] getGlobalsAndPackages() ...
[16:22:04.154] Searching for globals...
[16:22:04.156] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:04.156] Searching for globals ... DONE
[16:22:04.156] Resolving globals: FALSE
[16:22:04.156] 
[16:22:04.156] 
[16:22:04.156] getGlobalsAndPackages() ... DONE
[16:22:04.157] run() for ‘Future’ ...
[16:22:04.157] - state: ‘created’
[16:22:04.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:04.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:04.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:04.174]   - Field: ‘node’
[16:22:04.174]   - Field: ‘label’
[16:22:04.174]   - Field: ‘local’
[16:22:04.174]   - Field: ‘owner’
[16:22:04.174]   - Field: ‘envir’
[16:22:04.175]   - Field: ‘workers’
[16:22:04.175]   - Field: ‘packages’
[16:22:04.175]   - Field: ‘gc’
[16:22:04.175]   - Field: ‘conditions’
[16:22:04.175]   - Field: ‘persistent’
[16:22:04.175]   - Field: ‘expr’
[16:22:04.175]   - Field: ‘uuid’
[16:22:04.175]   - Field: ‘seed’
[16:22:04.175]   - Field: ‘version’
[16:22:04.175]   - Field: ‘result’
[16:22:04.176]   - Field: ‘asynchronous’
[16:22:04.176]   - Field: ‘calls’
[16:22:04.176]   - Field: ‘globals’
[16:22:04.176]   - Field: ‘stdout’
[16:22:04.176]   - Field: ‘earlySignal’
[16:22:04.176]   - Field: ‘lazy’
[16:22:04.176]   - Field: ‘state’
[16:22:04.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:04.176] - Launch lazy future ...
[16:22:04.177] Packages needed by the future expression (n = 0): <none>
[16:22:04.177] Packages needed by future strategies (n = 0): <none>
[16:22:04.177] {
[16:22:04.177]     {
[16:22:04.177]         {
[16:22:04.177]             ...future.startTime <- base::Sys.time()
[16:22:04.177]             {
[16:22:04.177]                 {
[16:22:04.177]                   {
[16:22:04.177]                     {
[16:22:04.177]                       base::local({
[16:22:04.177]                         has_future <- base::requireNamespace("future", 
[16:22:04.177]                           quietly = TRUE)
[16:22:04.177]                         if (has_future) {
[16:22:04.177]                           ns <- base::getNamespace("future")
[16:22:04.177]                           version <- ns[[".package"]][["version"]]
[16:22:04.177]                           if (is.null(version)) 
[16:22:04.177]                             version <- utils::packageVersion("future")
[16:22:04.177]                         }
[16:22:04.177]                         else {
[16:22:04.177]                           version <- NULL
[16:22:04.177]                         }
[16:22:04.177]                         if (!has_future || version < "1.8.0") {
[16:22:04.177]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:04.177]                             "", base::R.version$version.string), 
[16:22:04.177]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:04.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:04.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:04.177]                               "release", "version")], collapse = " "), 
[16:22:04.177]                             hostname = base::Sys.info()[["nodename"]])
[16:22:04.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:04.177]                             info)
[16:22:04.177]                           info <- base::paste(info, collapse = "; ")
[16:22:04.177]                           if (!has_future) {
[16:22:04.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:04.177]                               info)
[16:22:04.177]                           }
[16:22:04.177]                           else {
[16:22:04.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:04.177]                               info, version)
[16:22:04.177]                           }
[16:22:04.177]                           base::stop(msg)
[16:22:04.177]                         }
[16:22:04.177]                       })
[16:22:04.177]                     }
[16:22:04.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:04.177]                     base::options(mc.cores = 1L)
[16:22:04.177]                   }
[16:22:04.177]                   ...future.strategy.old <- future::plan("list")
[16:22:04.177]                   options(future.plan = NULL)
[16:22:04.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:04.177]                 }
[16:22:04.177]                 ...future.workdir <- getwd()
[16:22:04.177]             }
[16:22:04.177]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:04.177]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:04.177]         }
[16:22:04.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:04.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:04.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:04.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:04.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:04.177]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:04.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:04.177]             base::names(...future.oldOptions))
[16:22:04.177]     }
[16:22:04.177]     if (FALSE) {
[16:22:04.177]     }
[16:22:04.177]     else {
[16:22:04.177]         if (TRUE) {
[16:22:04.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:04.177]                 open = "w")
[16:22:04.177]         }
[16:22:04.177]         else {
[16:22:04.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:04.177]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:04.177]         }
[16:22:04.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:04.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:04.177]             base::sink(type = "output", split = FALSE)
[16:22:04.177]             base::close(...future.stdout)
[16:22:04.177]         }, add = TRUE)
[16:22:04.177]     }
[16:22:04.177]     ...future.frame <- base::sys.nframe()
[16:22:04.177]     ...future.conditions <- base::list()
[16:22:04.177]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:04.177]     if (FALSE) {
[16:22:04.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:04.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:04.177]     }
[16:22:04.177]     ...future.result <- base::tryCatch({
[16:22:04.177]         base::withCallingHandlers({
[16:22:04.177]             ...future.value <- base::withVisible(base::local({
[16:22:04.177]                 ...future.makeSendCondition <- base::local({
[16:22:04.177]                   sendCondition <- NULL
[16:22:04.177]                   function(frame = 1L) {
[16:22:04.177]                     if (is.function(sendCondition)) 
[16:22:04.177]                       return(sendCondition)
[16:22:04.177]                     ns <- getNamespace("parallel")
[16:22:04.177]                     if (exists("sendData", mode = "function", 
[16:22:04.177]                       envir = ns)) {
[16:22:04.177]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:04.177]                         envir = ns)
[16:22:04.177]                       envir <- sys.frame(frame)
[16:22:04.177]                       master <- NULL
[16:22:04.177]                       while (!identical(envir, .GlobalEnv) && 
[16:22:04.177]                         !identical(envir, emptyenv())) {
[16:22:04.177]                         if (exists("master", mode = "list", envir = envir, 
[16:22:04.177]                           inherits = FALSE)) {
[16:22:04.177]                           master <- get("master", mode = "list", 
[16:22:04.177]                             envir = envir, inherits = FALSE)
[16:22:04.177]                           if (inherits(master, c("SOCKnode", 
[16:22:04.177]                             "SOCK0node"))) {
[16:22:04.177]                             sendCondition <<- function(cond) {
[16:22:04.177]                               data <- list(type = "VALUE", value = cond, 
[16:22:04.177]                                 success = TRUE)
[16:22:04.177]                               parallel_sendData(master, data)
[16:22:04.177]                             }
[16:22:04.177]                             return(sendCondition)
[16:22:04.177]                           }
[16:22:04.177]                         }
[16:22:04.177]                         frame <- frame + 1L
[16:22:04.177]                         envir <- sys.frame(frame)
[16:22:04.177]                       }
[16:22:04.177]                     }
[16:22:04.177]                     sendCondition <<- function(cond) NULL
[16:22:04.177]                   }
[16:22:04.177]                 })
[16:22:04.177]                 withCallingHandlers({
[16:22:04.177]                   {
[16:22:04.177]                     Sys.sleep(0.5)
[16:22:04.177]                     list(a = 1, b = 42L)
[16:22:04.177]                   }
[16:22:04.177]                 }, immediateCondition = function(cond) {
[16:22:04.177]                   sendCondition <- ...future.makeSendCondition()
[16:22:04.177]                   sendCondition(cond)
[16:22:04.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.177]                   {
[16:22:04.177]                     inherits <- base::inherits
[16:22:04.177]                     invokeRestart <- base::invokeRestart
[16:22:04.177]                     is.null <- base::is.null
[16:22:04.177]                     muffled <- FALSE
[16:22:04.177]                     if (inherits(cond, "message")) {
[16:22:04.177]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:04.177]                       if (muffled) 
[16:22:04.177]                         invokeRestart("muffleMessage")
[16:22:04.177]                     }
[16:22:04.177]                     else if (inherits(cond, "warning")) {
[16:22:04.177]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:04.177]                       if (muffled) 
[16:22:04.177]                         invokeRestart("muffleWarning")
[16:22:04.177]                     }
[16:22:04.177]                     else if (inherits(cond, "condition")) {
[16:22:04.177]                       if (!is.null(pattern)) {
[16:22:04.177]                         computeRestarts <- base::computeRestarts
[16:22:04.177]                         grepl <- base::grepl
[16:22:04.177]                         restarts <- computeRestarts(cond)
[16:22:04.177]                         for (restart in restarts) {
[16:22:04.177]                           name <- restart$name
[16:22:04.177]                           if (is.null(name)) 
[16:22:04.177]                             next
[16:22:04.177]                           if (!grepl(pattern, name)) 
[16:22:04.177]                             next
[16:22:04.177]                           invokeRestart(restart)
[16:22:04.177]                           muffled <- TRUE
[16:22:04.177]                           break
[16:22:04.177]                         }
[16:22:04.177]                       }
[16:22:04.177]                     }
[16:22:04.177]                     invisible(muffled)
[16:22:04.177]                   }
[16:22:04.177]                   muffleCondition(cond)
[16:22:04.177]                 })
[16:22:04.177]             }))
[16:22:04.177]             future::FutureResult(value = ...future.value$value, 
[16:22:04.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.177]                   ...future.rng), globalenv = if (FALSE) 
[16:22:04.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:04.177]                     ...future.globalenv.names))
[16:22:04.177]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:04.177]         }, condition = base::local({
[16:22:04.177]             c <- base::c
[16:22:04.177]             inherits <- base::inherits
[16:22:04.177]             invokeRestart <- base::invokeRestart
[16:22:04.177]             length <- base::length
[16:22:04.177]             list <- base::list
[16:22:04.177]             seq.int <- base::seq.int
[16:22:04.177]             signalCondition <- base::signalCondition
[16:22:04.177]             sys.calls <- base::sys.calls
[16:22:04.177]             `[[` <- base::`[[`
[16:22:04.177]             `+` <- base::`+`
[16:22:04.177]             `<<-` <- base::`<<-`
[16:22:04.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:04.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:04.177]                   3L)]
[16:22:04.177]             }
[16:22:04.177]             function(cond) {
[16:22:04.177]                 is_error <- inherits(cond, "error")
[16:22:04.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:04.177]                   NULL)
[16:22:04.177]                 if (is_error) {
[16:22:04.177]                   sessionInformation <- function() {
[16:22:04.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:04.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:04.177]                       search = base::search(), system = base::Sys.info())
[16:22:04.177]                   }
[16:22:04.177]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:04.177]                     cond$call), session = sessionInformation(), 
[16:22:04.177]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:04.177]                   signalCondition(cond)
[16:22:04.177]                 }
[16:22:04.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:04.177]                 "immediateCondition"))) {
[16:22:04.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:04.177]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:04.177]                   if (TRUE && !signal) {
[16:22:04.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.177]                     {
[16:22:04.177]                       inherits <- base::inherits
[16:22:04.177]                       invokeRestart <- base::invokeRestart
[16:22:04.177]                       is.null <- base::is.null
[16:22:04.177]                       muffled <- FALSE
[16:22:04.177]                       if (inherits(cond, "message")) {
[16:22:04.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.177]                         if (muffled) 
[16:22:04.177]                           invokeRestart("muffleMessage")
[16:22:04.177]                       }
[16:22:04.177]                       else if (inherits(cond, "warning")) {
[16:22:04.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.177]                         if (muffled) 
[16:22:04.177]                           invokeRestart("muffleWarning")
[16:22:04.177]                       }
[16:22:04.177]                       else if (inherits(cond, "condition")) {
[16:22:04.177]                         if (!is.null(pattern)) {
[16:22:04.177]                           computeRestarts <- base::computeRestarts
[16:22:04.177]                           grepl <- base::grepl
[16:22:04.177]                           restarts <- computeRestarts(cond)
[16:22:04.177]                           for (restart in restarts) {
[16:22:04.177]                             name <- restart$name
[16:22:04.177]                             if (is.null(name)) 
[16:22:04.177]                               next
[16:22:04.177]                             if (!grepl(pattern, name)) 
[16:22:04.177]                               next
[16:22:04.177]                             invokeRestart(restart)
[16:22:04.177]                             muffled <- TRUE
[16:22:04.177]                             break
[16:22:04.177]                           }
[16:22:04.177]                         }
[16:22:04.177]                       }
[16:22:04.177]                       invisible(muffled)
[16:22:04.177]                     }
[16:22:04.177]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.177]                   }
[16:22:04.177]                 }
[16:22:04.177]                 else {
[16:22:04.177]                   if (TRUE) {
[16:22:04.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.177]                     {
[16:22:04.177]                       inherits <- base::inherits
[16:22:04.177]                       invokeRestart <- base::invokeRestart
[16:22:04.177]                       is.null <- base::is.null
[16:22:04.177]                       muffled <- FALSE
[16:22:04.177]                       if (inherits(cond, "message")) {
[16:22:04.177]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.177]                         if (muffled) 
[16:22:04.177]                           invokeRestart("muffleMessage")
[16:22:04.177]                       }
[16:22:04.177]                       else if (inherits(cond, "warning")) {
[16:22:04.177]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.177]                         if (muffled) 
[16:22:04.177]                           invokeRestart("muffleWarning")
[16:22:04.177]                       }
[16:22:04.177]                       else if (inherits(cond, "condition")) {
[16:22:04.177]                         if (!is.null(pattern)) {
[16:22:04.177]                           computeRestarts <- base::computeRestarts
[16:22:04.177]                           grepl <- base::grepl
[16:22:04.177]                           restarts <- computeRestarts(cond)
[16:22:04.177]                           for (restart in restarts) {
[16:22:04.177]                             name <- restart$name
[16:22:04.177]                             if (is.null(name)) 
[16:22:04.177]                               next
[16:22:04.177]                             if (!grepl(pattern, name)) 
[16:22:04.177]                               next
[16:22:04.177]                             invokeRestart(restart)
[16:22:04.177]                             muffled <- TRUE
[16:22:04.177]                             break
[16:22:04.177]                           }
[16:22:04.177]                         }
[16:22:04.177]                       }
[16:22:04.177]                       invisible(muffled)
[16:22:04.177]                     }
[16:22:04.177]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.177]                   }
[16:22:04.177]                 }
[16:22:04.177]             }
[16:22:04.177]         }))
[16:22:04.177]     }, error = function(ex) {
[16:22:04.177]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:04.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.177]                 ...future.rng), started = ...future.startTime, 
[16:22:04.177]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:04.177]             version = "1.8"), class = "FutureResult")
[16:22:04.177]     }, finally = {
[16:22:04.177]         if (!identical(...future.workdir, getwd())) 
[16:22:04.177]             setwd(...future.workdir)
[16:22:04.177]         {
[16:22:04.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:04.177]                 ...future.oldOptions$nwarnings <- NULL
[16:22:04.177]             }
[16:22:04.177]             base::options(...future.oldOptions)
[16:22:04.177]             if (.Platform$OS.type == "windows") {
[16:22:04.177]                 old_names <- names(...future.oldEnvVars)
[16:22:04.177]                 envs <- base::Sys.getenv()
[16:22:04.177]                 names <- names(envs)
[16:22:04.177]                 common <- intersect(names, old_names)
[16:22:04.177]                 added <- setdiff(names, old_names)
[16:22:04.177]                 removed <- setdiff(old_names, names)
[16:22:04.177]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:04.177]                   envs[common]]
[16:22:04.177]                 NAMES <- toupper(changed)
[16:22:04.177]                 args <- list()
[16:22:04.177]                 for (kk in seq_along(NAMES)) {
[16:22:04.177]                   name <- changed[[kk]]
[16:22:04.177]                   NAME <- NAMES[[kk]]
[16:22:04.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.177]                     next
[16:22:04.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.177]                 }
[16:22:04.177]                 NAMES <- toupper(added)
[16:22:04.177]                 for (kk in seq_along(NAMES)) {
[16:22:04.177]                   name <- added[[kk]]
[16:22:04.177]                   NAME <- NAMES[[kk]]
[16:22:04.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.177]                     next
[16:22:04.177]                   args[[name]] <- ""
[16:22:04.177]                 }
[16:22:04.177]                 NAMES <- toupper(removed)
[16:22:04.177]                 for (kk in seq_along(NAMES)) {
[16:22:04.177]                   name <- removed[[kk]]
[16:22:04.177]                   NAME <- NAMES[[kk]]
[16:22:04.177]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.177]                     next
[16:22:04.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.177]                 }
[16:22:04.177]                 if (length(args) > 0) 
[16:22:04.177]                   base::do.call(base::Sys.setenv, args = args)
[16:22:04.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:04.177]             }
[16:22:04.177]             else {
[16:22:04.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:04.177]             }
[16:22:04.177]             {
[16:22:04.177]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:04.177]                   0L) {
[16:22:04.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:04.177]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:04.177]                   base::options(opts)
[16:22:04.177]                 }
[16:22:04.177]                 {
[16:22:04.177]                   {
[16:22:04.177]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:04.177]                     NULL
[16:22:04.177]                   }
[16:22:04.177]                   options(future.plan = NULL)
[16:22:04.177]                   if (is.na(NA_character_)) 
[16:22:04.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:04.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:04.177]                     .init = FALSE)
[16:22:04.177]                 }
[16:22:04.177]             }
[16:22:04.177]         }
[16:22:04.177]     })
[16:22:04.177]     if (TRUE) {
[16:22:04.177]         base::sink(type = "output", split = FALSE)
[16:22:04.177]         if (TRUE) {
[16:22:04.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:04.177]         }
[16:22:04.177]         else {
[16:22:04.177]             ...future.result["stdout"] <- base::list(NULL)
[16:22:04.177]         }
[16:22:04.177]         base::close(...future.stdout)
[16:22:04.177]         ...future.stdout <- NULL
[16:22:04.177]     }
[16:22:04.177]     ...future.result$conditions <- ...future.conditions
[16:22:04.177]     ...future.result$finished <- base::Sys.time()
[16:22:04.177]     ...future.result
[16:22:04.177] }
[16:22:04.180] MultisessionFuture started
[16:22:04.180] - Launch lazy future ... done
[16:22:04.180] run() for ‘MultisessionFuture’ ... done
[16:22:04.683] receiveMessageFromWorker() for ClusterFuture ...
[16:22:04.683] - Validating connection of MultisessionFuture
[16:22:04.683] - received message: FutureResult
[16:22:04.683] - Received FutureResult
[16:22:04.684] - Erased future from FutureRegistry
[16:22:04.684] result() for ClusterFuture ...
[16:22:04.684] - result already collected: FutureResult
[16:22:04.684] result() for ClusterFuture ... done
[16:22:04.684] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:04.684] A MultisessionFuture was resolved
- w/ exception ...
[16:22:04.684] getGlobalsAndPackages() ...
[16:22:04.684] Searching for globals...
[16:22:04.685] - globals found: [2] ‘list’, ‘stop’
[16:22:04.685] Searching for globals ... DONE
[16:22:04.685] Resolving globals: FALSE
[16:22:04.686] 
[16:22:04.686] 
[16:22:04.686] getGlobalsAndPackages() ... DONE
[16:22:04.686] run() for ‘Future’ ...
[16:22:04.686] - state: ‘created’
[16:22:04.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:04.701] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:04.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:04.701]   - Field: ‘node’
[16:22:04.701]   - Field: ‘label’
[16:22:04.701]   - Field: ‘local’
[16:22:04.701]   - Field: ‘owner’
[16:22:04.701]   - Field: ‘envir’
[16:22:04.702]   - Field: ‘workers’
[16:22:04.702]   - Field: ‘packages’
[16:22:04.702]   - Field: ‘gc’
[16:22:04.702]   - Field: ‘conditions’
[16:22:04.702]   - Field: ‘persistent’
[16:22:04.702]   - Field: ‘expr’
[16:22:04.702]   - Field: ‘uuid’
[16:22:04.702]   - Field: ‘seed’
[16:22:04.702]   - Field: ‘version’
[16:22:04.702]   - Field: ‘result’
[16:22:04.702]   - Field: ‘asynchronous’
[16:22:04.703]   - Field: ‘calls’
[16:22:04.703]   - Field: ‘globals’
[16:22:04.703]   - Field: ‘stdout’
[16:22:04.703]   - Field: ‘earlySignal’
[16:22:04.703]   - Field: ‘lazy’
[16:22:04.703]   - Field: ‘state’
[16:22:04.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:04.703] - Launch lazy future ...
[16:22:04.703] Packages needed by the future expression (n = 0): <none>
[16:22:04.704] Packages needed by future strategies (n = 0): <none>
[16:22:04.704] {
[16:22:04.704]     {
[16:22:04.704]         {
[16:22:04.704]             ...future.startTime <- base::Sys.time()
[16:22:04.704]             {
[16:22:04.704]                 {
[16:22:04.704]                   {
[16:22:04.704]                     {
[16:22:04.704]                       base::local({
[16:22:04.704]                         has_future <- base::requireNamespace("future", 
[16:22:04.704]                           quietly = TRUE)
[16:22:04.704]                         if (has_future) {
[16:22:04.704]                           ns <- base::getNamespace("future")
[16:22:04.704]                           version <- ns[[".package"]][["version"]]
[16:22:04.704]                           if (is.null(version)) 
[16:22:04.704]                             version <- utils::packageVersion("future")
[16:22:04.704]                         }
[16:22:04.704]                         else {
[16:22:04.704]                           version <- NULL
[16:22:04.704]                         }
[16:22:04.704]                         if (!has_future || version < "1.8.0") {
[16:22:04.704]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:04.704]                             "", base::R.version$version.string), 
[16:22:04.704]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:04.704]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:04.704]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:04.704]                               "release", "version")], collapse = " "), 
[16:22:04.704]                             hostname = base::Sys.info()[["nodename"]])
[16:22:04.704]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:04.704]                             info)
[16:22:04.704]                           info <- base::paste(info, collapse = "; ")
[16:22:04.704]                           if (!has_future) {
[16:22:04.704]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:04.704]                               info)
[16:22:04.704]                           }
[16:22:04.704]                           else {
[16:22:04.704]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:04.704]                               info, version)
[16:22:04.704]                           }
[16:22:04.704]                           base::stop(msg)
[16:22:04.704]                         }
[16:22:04.704]                       })
[16:22:04.704]                     }
[16:22:04.704]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:04.704]                     base::options(mc.cores = 1L)
[16:22:04.704]                   }
[16:22:04.704]                   ...future.strategy.old <- future::plan("list")
[16:22:04.704]                   options(future.plan = NULL)
[16:22:04.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:04.704]                 }
[16:22:04.704]                 ...future.workdir <- getwd()
[16:22:04.704]             }
[16:22:04.704]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:04.704]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:04.704]         }
[16:22:04.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:04.704]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:04.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:04.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:04.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:04.704]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:04.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:04.704]             base::names(...future.oldOptions))
[16:22:04.704]     }
[16:22:04.704]     if (FALSE) {
[16:22:04.704]     }
[16:22:04.704]     else {
[16:22:04.704]         if (TRUE) {
[16:22:04.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:04.704]                 open = "w")
[16:22:04.704]         }
[16:22:04.704]         else {
[16:22:04.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:04.704]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:04.704]         }
[16:22:04.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:04.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:04.704]             base::sink(type = "output", split = FALSE)
[16:22:04.704]             base::close(...future.stdout)
[16:22:04.704]         }, add = TRUE)
[16:22:04.704]     }
[16:22:04.704]     ...future.frame <- base::sys.nframe()
[16:22:04.704]     ...future.conditions <- base::list()
[16:22:04.704]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:04.704]     if (FALSE) {
[16:22:04.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:04.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:04.704]     }
[16:22:04.704]     ...future.result <- base::tryCatch({
[16:22:04.704]         base::withCallingHandlers({
[16:22:04.704]             ...future.value <- base::withVisible(base::local({
[16:22:04.704]                 ...future.makeSendCondition <- base::local({
[16:22:04.704]                   sendCondition <- NULL
[16:22:04.704]                   function(frame = 1L) {
[16:22:04.704]                     if (is.function(sendCondition)) 
[16:22:04.704]                       return(sendCondition)
[16:22:04.704]                     ns <- getNamespace("parallel")
[16:22:04.704]                     if (exists("sendData", mode = "function", 
[16:22:04.704]                       envir = ns)) {
[16:22:04.704]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:04.704]                         envir = ns)
[16:22:04.704]                       envir <- sys.frame(frame)
[16:22:04.704]                       master <- NULL
[16:22:04.704]                       while (!identical(envir, .GlobalEnv) && 
[16:22:04.704]                         !identical(envir, emptyenv())) {
[16:22:04.704]                         if (exists("master", mode = "list", envir = envir, 
[16:22:04.704]                           inherits = FALSE)) {
[16:22:04.704]                           master <- get("master", mode = "list", 
[16:22:04.704]                             envir = envir, inherits = FALSE)
[16:22:04.704]                           if (inherits(master, c("SOCKnode", 
[16:22:04.704]                             "SOCK0node"))) {
[16:22:04.704]                             sendCondition <<- function(cond) {
[16:22:04.704]                               data <- list(type = "VALUE", value = cond, 
[16:22:04.704]                                 success = TRUE)
[16:22:04.704]                               parallel_sendData(master, data)
[16:22:04.704]                             }
[16:22:04.704]                             return(sendCondition)
[16:22:04.704]                           }
[16:22:04.704]                         }
[16:22:04.704]                         frame <- frame + 1L
[16:22:04.704]                         envir <- sys.frame(frame)
[16:22:04.704]                       }
[16:22:04.704]                     }
[16:22:04.704]                     sendCondition <<- function(cond) NULL
[16:22:04.704]                   }
[16:22:04.704]                 })
[16:22:04.704]                 withCallingHandlers({
[16:22:04.704]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:04.704]                 }, immediateCondition = function(cond) {
[16:22:04.704]                   sendCondition <- ...future.makeSendCondition()
[16:22:04.704]                   sendCondition(cond)
[16:22:04.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.704]                   {
[16:22:04.704]                     inherits <- base::inherits
[16:22:04.704]                     invokeRestart <- base::invokeRestart
[16:22:04.704]                     is.null <- base::is.null
[16:22:04.704]                     muffled <- FALSE
[16:22:04.704]                     if (inherits(cond, "message")) {
[16:22:04.704]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:04.704]                       if (muffled) 
[16:22:04.704]                         invokeRestart("muffleMessage")
[16:22:04.704]                     }
[16:22:04.704]                     else if (inherits(cond, "warning")) {
[16:22:04.704]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:04.704]                       if (muffled) 
[16:22:04.704]                         invokeRestart("muffleWarning")
[16:22:04.704]                     }
[16:22:04.704]                     else if (inherits(cond, "condition")) {
[16:22:04.704]                       if (!is.null(pattern)) {
[16:22:04.704]                         computeRestarts <- base::computeRestarts
[16:22:04.704]                         grepl <- base::grepl
[16:22:04.704]                         restarts <- computeRestarts(cond)
[16:22:04.704]                         for (restart in restarts) {
[16:22:04.704]                           name <- restart$name
[16:22:04.704]                           if (is.null(name)) 
[16:22:04.704]                             next
[16:22:04.704]                           if (!grepl(pattern, name)) 
[16:22:04.704]                             next
[16:22:04.704]                           invokeRestart(restart)
[16:22:04.704]                           muffled <- TRUE
[16:22:04.704]                           break
[16:22:04.704]                         }
[16:22:04.704]                       }
[16:22:04.704]                     }
[16:22:04.704]                     invisible(muffled)
[16:22:04.704]                   }
[16:22:04.704]                   muffleCondition(cond)
[16:22:04.704]                 })
[16:22:04.704]             }))
[16:22:04.704]             future::FutureResult(value = ...future.value$value, 
[16:22:04.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.704]                   ...future.rng), globalenv = if (FALSE) 
[16:22:04.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:04.704]                     ...future.globalenv.names))
[16:22:04.704]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:04.704]         }, condition = base::local({
[16:22:04.704]             c <- base::c
[16:22:04.704]             inherits <- base::inherits
[16:22:04.704]             invokeRestart <- base::invokeRestart
[16:22:04.704]             length <- base::length
[16:22:04.704]             list <- base::list
[16:22:04.704]             seq.int <- base::seq.int
[16:22:04.704]             signalCondition <- base::signalCondition
[16:22:04.704]             sys.calls <- base::sys.calls
[16:22:04.704]             `[[` <- base::`[[`
[16:22:04.704]             `+` <- base::`+`
[16:22:04.704]             `<<-` <- base::`<<-`
[16:22:04.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:04.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:04.704]                   3L)]
[16:22:04.704]             }
[16:22:04.704]             function(cond) {
[16:22:04.704]                 is_error <- inherits(cond, "error")
[16:22:04.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:04.704]                   NULL)
[16:22:04.704]                 if (is_error) {
[16:22:04.704]                   sessionInformation <- function() {
[16:22:04.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:04.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:04.704]                       search = base::search(), system = base::Sys.info())
[16:22:04.704]                   }
[16:22:04.704]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:04.704]                     cond$call), session = sessionInformation(), 
[16:22:04.704]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:04.704]                   signalCondition(cond)
[16:22:04.704]                 }
[16:22:04.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:04.704]                 "immediateCondition"))) {
[16:22:04.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:04.704]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:04.704]                   if (TRUE && !signal) {
[16:22:04.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.704]                     {
[16:22:04.704]                       inherits <- base::inherits
[16:22:04.704]                       invokeRestart <- base::invokeRestart
[16:22:04.704]                       is.null <- base::is.null
[16:22:04.704]                       muffled <- FALSE
[16:22:04.704]                       if (inherits(cond, "message")) {
[16:22:04.704]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.704]                         if (muffled) 
[16:22:04.704]                           invokeRestart("muffleMessage")
[16:22:04.704]                       }
[16:22:04.704]                       else if (inherits(cond, "warning")) {
[16:22:04.704]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.704]                         if (muffled) 
[16:22:04.704]                           invokeRestart("muffleWarning")
[16:22:04.704]                       }
[16:22:04.704]                       else if (inherits(cond, "condition")) {
[16:22:04.704]                         if (!is.null(pattern)) {
[16:22:04.704]                           computeRestarts <- base::computeRestarts
[16:22:04.704]                           grepl <- base::grepl
[16:22:04.704]                           restarts <- computeRestarts(cond)
[16:22:04.704]                           for (restart in restarts) {
[16:22:04.704]                             name <- restart$name
[16:22:04.704]                             if (is.null(name)) 
[16:22:04.704]                               next
[16:22:04.704]                             if (!grepl(pattern, name)) 
[16:22:04.704]                               next
[16:22:04.704]                             invokeRestart(restart)
[16:22:04.704]                             muffled <- TRUE
[16:22:04.704]                             break
[16:22:04.704]                           }
[16:22:04.704]                         }
[16:22:04.704]                       }
[16:22:04.704]                       invisible(muffled)
[16:22:04.704]                     }
[16:22:04.704]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.704]                   }
[16:22:04.704]                 }
[16:22:04.704]                 else {
[16:22:04.704]                   if (TRUE) {
[16:22:04.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.704]                     {
[16:22:04.704]                       inherits <- base::inherits
[16:22:04.704]                       invokeRestart <- base::invokeRestart
[16:22:04.704]                       is.null <- base::is.null
[16:22:04.704]                       muffled <- FALSE
[16:22:04.704]                       if (inherits(cond, "message")) {
[16:22:04.704]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.704]                         if (muffled) 
[16:22:04.704]                           invokeRestart("muffleMessage")
[16:22:04.704]                       }
[16:22:04.704]                       else if (inherits(cond, "warning")) {
[16:22:04.704]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.704]                         if (muffled) 
[16:22:04.704]                           invokeRestart("muffleWarning")
[16:22:04.704]                       }
[16:22:04.704]                       else if (inherits(cond, "condition")) {
[16:22:04.704]                         if (!is.null(pattern)) {
[16:22:04.704]                           computeRestarts <- base::computeRestarts
[16:22:04.704]                           grepl <- base::grepl
[16:22:04.704]                           restarts <- computeRestarts(cond)
[16:22:04.704]                           for (restart in restarts) {
[16:22:04.704]                             name <- restart$name
[16:22:04.704]                             if (is.null(name)) 
[16:22:04.704]                               next
[16:22:04.704]                             if (!grepl(pattern, name)) 
[16:22:04.704]                               next
[16:22:04.704]                             invokeRestart(restart)
[16:22:04.704]                             muffled <- TRUE
[16:22:04.704]                             break
[16:22:04.704]                           }
[16:22:04.704]                         }
[16:22:04.704]                       }
[16:22:04.704]                       invisible(muffled)
[16:22:04.704]                     }
[16:22:04.704]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.704]                   }
[16:22:04.704]                 }
[16:22:04.704]             }
[16:22:04.704]         }))
[16:22:04.704]     }, error = function(ex) {
[16:22:04.704]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:04.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.704]                 ...future.rng), started = ...future.startTime, 
[16:22:04.704]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:04.704]             version = "1.8"), class = "FutureResult")
[16:22:04.704]     }, finally = {
[16:22:04.704]         if (!identical(...future.workdir, getwd())) 
[16:22:04.704]             setwd(...future.workdir)
[16:22:04.704]         {
[16:22:04.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:04.704]                 ...future.oldOptions$nwarnings <- NULL
[16:22:04.704]             }
[16:22:04.704]             base::options(...future.oldOptions)
[16:22:04.704]             if (.Platform$OS.type == "windows") {
[16:22:04.704]                 old_names <- names(...future.oldEnvVars)
[16:22:04.704]                 envs <- base::Sys.getenv()
[16:22:04.704]                 names <- names(envs)
[16:22:04.704]                 common <- intersect(names, old_names)
[16:22:04.704]                 added <- setdiff(names, old_names)
[16:22:04.704]                 removed <- setdiff(old_names, names)
[16:22:04.704]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:04.704]                   envs[common]]
[16:22:04.704]                 NAMES <- toupper(changed)
[16:22:04.704]                 args <- list()
[16:22:04.704]                 for (kk in seq_along(NAMES)) {
[16:22:04.704]                   name <- changed[[kk]]
[16:22:04.704]                   NAME <- NAMES[[kk]]
[16:22:04.704]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.704]                     next
[16:22:04.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.704]                 }
[16:22:04.704]                 NAMES <- toupper(added)
[16:22:04.704]                 for (kk in seq_along(NAMES)) {
[16:22:04.704]                   name <- added[[kk]]
[16:22:04.704]                   NAME <- NAMES[[kk]]
[16:22:04.704]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.704]                     next
[16:22:04.704]                   args[[name]] <- ""
[16:22:04.704]                 }
[16:22:04.704]                 NAMES <- toupper(removed)
[16:22:04.704]                 for (kk in seq_along(NAMES)) {
[16:22:04.704]                   name <- removed[[kk]]
[16:22:04.704]                   NAME <- NAMES[[kk]]
[16:22:04.704]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.704]                     next
[16:22:04.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.704]                 }
[16:22:04.704]                 if (length(args) > 0) 
[16:22:04.704]                   base::do.call(base::Sys.setenv, args = args)
[16:22:04.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:04.704]             }
[16:22:04.704]             else {
[16:22:04.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:04.704]             }
[16:22:04.704]             {
[16:22:04.704]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:04.704]                   0L) {
[16:22:04.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:04.704]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:04.704]                   base::options(opts)
[16:22:04.704]                 }
[16:22:04.704]                 {
[16:22:04.704]                   {
[16:22:04.704]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:04.704]                     NULL
[16:22:04.704]                   }
[16:22:04.704]                   options(future.plan = NULL)
[16:22:04.704]                   if (is.na(NA_character_)) 
[16:22:04.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:04.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:04.704]                     .init = FALSE)
[16:22:04.704]                 }
[16:22:04.704]             }
[16:22:04.704]         }
[16:22:04.704]     })
[16:22:04.704]     if (TRUE) {
[16:22:04.704]         base::sink(type = "output", split = FALSE)
[16:22:04.704]         if (TRUE) {
[16:22:04.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:04.704]         }
[16:22:04.704]         else {
[16:22:04.704]             ...future.result["stdout"] <- base::list(NULL)
[16:22:04.704]         }
[16:22:04.704]         base::close(...future.stdout)
[16:22:04.704]         ...future.stdout <- NULL
[16:22:04.704]     }
[16:22:04.704]     ...future.result$conditions <- ...future.conditions
[16:22:04.704]     ...future.result$finished <- base::Sys.time()
[16:22:04.704]     ...future.result
[16:22:04.704] }
[16:22:04.707] MultisessionFuture started
[16:22:04.707] - Launch lazy future ... done
[16:22:04.707] run() for ‘MultisessionFuture’ ... done
[16:22:04.709] receiveMessageFromWorker() for ClusterFuture ...
[16:22:04.709] - Validating connection of MultisessionFuture
[16:22:04.709] - received message: FutureResult
[16:22:04.709] - Received FutureResult
[16:22:04.710] - Erased future from FutureRegistry
[16:22:04.710] result() for ClusterFuture ...
[16:22:04.710] - result already collected: FutureResult
[16:22:04.710] result() for ClusterFuture ... done
[16:22:04.710] signalConditions() ...
[16:22:04.710]  - include = ‘immediateCondition’
[16:22:04.710]  - exclude = 
[16:22:04.710]  - resignal = FALSE
[16:22:04.710]  - Number of conditions: 1
[16:22:04.710] signalConditions() ... done
[16:22:04.710] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:04.711] A MultisessionFuture was resolved
[16:22:04.711] getGlobalsAndPackages() ...
[16:22:04.711] Searching for globals...
[16:22:04.711] - globals found: [2] ‘list’, ‘stop’
[16:22:04.712] Searching for globals ... DONE
[16:22:04.712] Resolving globals: FALSE
[16:22:04.712] 
[16:22:04.712] 
[16:22:04.712] getGlobalsAndPackages() ... DONE
[16:22:04.712] run() for ‘Future’ ...
[16:22:04.713] - state: ‘created’
[16:22:04.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:04.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:04.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:04.727]   - Field: ‘node’
[16:22:04.727]   - Field: ‘label’
[16:22:04.727]   - Field: ‘local’
[16:22:04.727]   - Field: ‘owner’
[16:22:04.727]   - Field: ‘envir’
[16:22:04.727]   - Field: ‘workers’
[16:22:04.728]   - Field: ‘packages’
[16:22:04.728]   - Field: ‘gc’
[16:22:04.728]   - Field: ‘conditions’
[16:22:04.728]   - Field: ‘persistent’
[16:22:04.728]   - Field: ‘expr’
[16:22:04.728]   - Field: ‘uuid’
[16:22:04.728]   - Field: ‘seed’
[16:22:04.728]   - Field: ‘version’
[16:22:04.728]   - Field: ‘result’
[16:22:04.728]   - Field: ‘asynchronous’
[16:22:04.728]   - Field: ‘calls’
[16:22:04.729]   - Field: ‘globals’
[16:22:04.729]   - Field: ‘stdout’
[16:22:04.729]   - Field: ‘earlySignal’
[16:22:04.729]   - Field: ‘lazy’
[16:22:04.729]   - Field: ‘state’
[16:22:04.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:04.729] - Launch lazy future ...
[16:22:04.729] Packages needed by the future expression (n = 0): <none>
[16:22:04.729] Packages needed by future strategies (n = 0): <none>
[16:22:04.730] {
[16:22:04.730]     {
[16:22:04.730]         {
[16:22:04.730]             ...future.startTime <- base::Sys.time()
[16:22:04.730]             {
[16:22:04.730]                 {
[16:22:04.730]                   {
[16:22:04.730]                     {
[16:22:04.730]                       base::local({
[16:22:04.730]                         has_future <- base::requireNamespace("future", 
[16:22:04.730]                           quietly = TRUE)
[16:22:04.730]                         if (has_future) {
[16:22:04.730]                           ns <- base::getNamespace("future")
[16:22:04.730]                           version <- ns[[".package"]][["version"]]
[16:22:04.730]                           if (is.null(version)) 
[16:22:04.730]                             version <- utils::packageVersion("future")
[16:22:04.730]                         }
[16:22:04.730]                         else {
[16:22:04.730]                           version <- NULL
[16:22:04.730]                         }
[16:22:04.730]                         if (!has_future || version < "1.8.0") {
[16:22:04.730]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:04.730]                             "", base::R.version$version.string), 
[16:22:04.730]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:04.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:04.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:04.730]                               "release", "version")], collapse = " "), 
[16:22:04.730]                             hostname = base::Sys.info()[["nodename"]])
[16:22:04.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:04.730]                             info)
[16:22:04.730]                           info <- base::paste(info, collapse = "; ")
[16:22:04.730]                           if (!has_future) {
[16:22:04.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:04.730]                               info)
[16:22:04.730]                           }
[16:22:04.730]                           else {
[16:22:04.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:04.730]                               info, version)
[16:22:04.730]                           }
[16:22:04.730]                           base::stop(msg)
[16:22:04.730]                         }
[16:22:04.730]                       })
[16:22:04.730]                     }
[16:22:04.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:04.730]                     base::options(mc.cores = 1L)
[16:22:04.730]                   }
[16:22:04.730]                   ...future.strategy.old <- future::plan("list")
[16:22:04.730]                   options(future.plan = NULL)
[16:22:04.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:04.730]                 }
[16:22:04.730]                 ...future.workdir <- getwd()
[16:22:04.730]             }
[16:22:04.730]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:04.730]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:04.730]         }
[16:22:04.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:04.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:04.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:04.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:04.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:04.730]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:04.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:04.730]             base::names(...future.oldOptions))
[16:22:04.730]     }
[16:22:04.730]     if (FALSE) {
[16:22:04.730]     }
[16:22:04.730]     else {
[16:22:04.730]         if (TRUE) {
[16:22:04.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:04.730]                 open = "w")
[16:22:04.730]         }
[16:22:04.730]         else {
[16:22:04.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:04.730]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:04.730]         }
[16:22:04.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:04.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:04.730]             base::sink(type = "output", split = FALSE)
[16:22:04.730]             base::close(...future.stdout)
[16:22:04.730]         }, add = TRUE)
[16:22:04.730]     }
[16:22:04.730]     ...future.frame <- base::sys.nframe()
[16:22:04.730]     ...future.conditions <- base::list()
[16:22:04.730]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:04.730]     if (FALSE) {
[16:22:04.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:04.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:04.730]     }
[16:22:04.730]     ...future.result <- base::tryCatch({
[16:22:04.730]         base::withCallingHandlers({
[16:22:04.730]             ...future.value <- base::withVisible(base::local({
[16:22:04.730]                 ...future.makeSendCondition <- base::local({
[16:22:04.730]                   sendCondition <- NULL
[16:22:04.730]                   function(frame = 1L) {
[16:22:04.730]                     if (is.function(sendCondition)) 
[16:22:04.730]                       return(sendCondition)
[16:22:04.730]                     ns <- getNamespace("parallel")
[16:22:04.730]                     if (exists("sendData", mode = "function", 
[16:22:04.730]                       envir = ns)) {
[16:22:04.730]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:04.730]                         envir = ns)
[16:22:04.730]                       envir <- sys.frame(frame)
[16:22:04.730]                       master <- NULL
[16:22:04.730]                       while (!identical(envir, .GlobalEnv) && 
[16:22:04.730]                         !identical(envir, emptyenv())) {
[16:22:04.730]                         if (exists("master", mode = "list", envir = envir, 
[16:22:04.730]                           inherits = FALSE)) {
[16:22:04.730]                           master <- get("master", mode = "list", 
[16:22:04.730]                             envir = envir, inherits = FALSE)
[16:22:04.730]                           if (inherits(master, c("SOCKnode", 
[16:22:04.730]                             "SOCK0node"))) {
[16:22:04.730]                             sendCondition <<- function(cond) {
[16:22:04.730]                               data <- list(type = "VALUE", value = cond, 
[16:22:04.730]                                 success = TRUE)
[16:22:04.730]                               parallel_sendData(master, data)
[16:22:04.730]                             }
[16:22:04.730]                             return(sendCondition)
[16:22:04.730]                           }
[16:22:04.730]                         }
[16:22:04.730]                         frame <- frame + 1L
[16:22:04.730]                         envir <- sys.frame(frame)
[16:22:04.730]                       }
[16:22:04.730]                     }
[16:22:04.730]                     sendCondition <<- function(cond) NULL
[16:22:04.730]                   }
[16:22:04.730]                 })
[16:22:04.730]                 withCallingHandlers({
[16:22:04.730]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:04.730]                 }, immediateCondition = function(cond) {
[16:22:04.730]                   sendCondition <- ...future.makeSendCondition()
[16:22:04.730]                   sendCondition(cond)
[16:22:04.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.730]                   {
[16:22:04.730]                     inherits <- base::inherits
[16:22:04.730]                     invokeRestart <- base::invokeRestart
[16:22:04.730]                     is.null <- base::is.null
[16:22:04.730]                     muffled <- FALSE
[16:22:04.730]                     if (inherits(cond, "message")) {
[16:22:04.730]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:04.730]                       if (muffled) 
[16:22:04.730]                         invokeRestart("muffleMessage")
[16:22:04.730]                     }
[16:22:04.730]                     else if (inherits(cond, "warning")) {
[16:22:04.730]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:04.730]                       if (muffled) 
[16:22:04.730]                         invokeRestart("muffleWarning")
[16:22:04.730]                     }
[16:22:04.730]                     else if (inherits(cond, "condition")) {
[16:22:04.730]                       if (!is.null(pattern)) {
[16:22:04.730]                         computeRestarts <- base::computeRestarts
[16:22:04.730]                         grepl <- base::grepl
[16:22:04.730]                         restarts <- computeRestarts(cond)
[16:22:04.730]                         for (restart in restarts) {
[16:22:04.730]                           name <- restart$name
[16:22:04.730]                           if (is.null(name)) 
[16:22:04.730]                             next
[16:22:04.730]                           if (!grepl(pattern, name)) 
[16:22:04.730]                             next
[16:22:04.730]                           invokeRestart(restart)
[16:22:04.730]                           muffled <- TRUE
[16:22:04.730]                           break
[16:22:04.730]                         }
[16:22:04.730]                       }
[16:22:04.730]                     }
[16:22:04.730]                     invisible(muffled)
[16:22:04.730]                   }
[16:22:04.730]                   muffleCondition(cond)
[16:22:04.730]                 })
[16:22:04.730]             }))
[16:22:04.730]             future::FutureResult(value = ...future.value$value, 
[16:22:04.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.730]                   ...future.rng), globalenv = if (FALSE) 
[16:22:04.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:04.730]                     ...future.globalenv.names))
[16:22:04.730]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:04.730]         }, condition = base::local({
[16:22:04.730]             c <- base::c
[16:22:04.730]             inherits <- base::inherits
[16:22:04.730]             invokeRestart <- base::invokeRestart
[16:22:04.730]             length <- base::length
[16:22:04.730]             list <- base::list
[16:22:04.730]             seq.int <- base::seq.int
[16:22:04.730]             signalCondition <- base::signalCondition
[16:22:04.730]             sys.calls <- base::sys.calls
[16:22:04.730]             `[[` <- base::`[[`
[16:22:04.730]             `+` <- base::`+`
[16:22:04.730]             `<<-` <- base::`<<-`
[16:22:04.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:04.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:04.730]                   3L)]
[16:22:04.730]             }
[16:22:04.730]             function(cond) {
[16:22:04.730]                 is_error <- inherits(cond, "error")
[16:22:04.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:04.730]                   NULL)
[16:22:04.730]                 if (is_error) {
[16:22:04.730]                   sessionInformation <- function() {
[16:22:04.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:04.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:04.730]                       search = base::search(), system = base::Sys.info())
[16:22:04.730]                   }
[16:22:04.730]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:04.730]                     cond$call), session = sessionInformation(), 
[16:22:04.730]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:04.730]                   signalCondition(cond)
[16:22:04.730]                 }
[16:22:04.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:04.730]                 "immediateCondition"))) {
[16:22:04.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:04.730]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:04.730]                   if (TRUE && !signal) {
[16:22:04.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.730]                     {
[16:22:04.730]                       inherits <- base::inherits
[16:22:04.730]                       invokeRestart <- base::invokeRestart
[16:22:04.730]                       is.null <- base::is.null
[16:22:04.730]                       muffled <- FALSE
[16:22:04.730]                       if (inherits(cond, "message")) {
[16:22:04.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.730]                         if (muffled) 
[16:22:04.730]                           invokeRestart("muffleMessage")
[16:22:04.730]                       }
[16:22:04.730]                       else if (inherits(cond, "warning")) {
[16:22:04.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.730]                         if (muffled) 
[16:22:04.730]                           invokeRestart("muffleWarning")
[16:22:04.730]                       }
[16:22:04.730]                       else if (inherits(cond, "condition")) {
[16:22:04.730]                         if (!is.null(pattern)) {
[16:22:04.730]                           computeRestarts <- base::computeRestarts
[16:22:04.730]                           grepl <- base::grepl
[16:22:04.730]                           restarts <- computeRestarts(cond)
[16:22:04.730]                           for (restart in restarts) {
[16:22:04.730]                             name <- restart$name
[16:22:04.730]                             if (is.null(name)) 
[16:22:04.730]                               next
[16:22:04.730]                             if (!grepl(pattern, name)) 
[16:22:04.730]                               next
[16:22:04.730]                             invokeRestart(restart)
[16:22:04.730]                             muffled <- TRUE
[16:22:04.730]                             break
[16:22:04.730]                           }
[16:22:04.730]                         }
[16:22:04.730]                       }
[16:22:04.730]                       invisible(muffled)
[16:22:04.730]                     }
[16:22:04.730]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.730]                   }
[16:22:04.730]                 }
[16:22:04.730]                 else {
[16:22:04.730]                   if (TRUE) {
[16:22:04.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.730]                     {
[16:22:04.730]                       inherits <- base::inherits
[16:22:04.730]                       invokeRestart <- base::invokeRestart
[16:22:04.730]                       is.null <- base::is.null
[16:22:04.730]                       muffled <- FALSE
[16:22:04.730]                       if (inherits(cond, "message")) {
[16:22:04.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.730]                         if (muffled) 
[16:22:04.730]                           invokeRestart("muffleMessage")
[16:22:04.730]                       }
[16:22:04.730]                       else if (inherits(cond, "warning")) {
[16:22:04.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.730]                         if (muffled) 
[16:22:04.730]                           invokeRestart("muffleWarning")
[16:22:04.730]                       }
[16:22:04.730]                       else if (inherits(cond, "condition")) {
[16:22:04.730]                         if (!is.null(pattern)) {
[16:22:04.730]                           computeRestarts <- base::computeRestarts
[16:22:04.730]                           grepl <- base::grepl
[16:22:04.730]                           restarts <- computeRestarts(cond)
[16:22:04.730]                           for (restart in restarts) {
[16:22:04.730]                             name <- restart$name
[16:22:04.730]                             if (is.null(name)) 
[16:22:04.730]                               next
[16:22:04.730]                             if (!grepl(pattern, name)) 
[16:22:04.730]                               next
[16:22:04.730]                             invokeRestart(restart)
[16:22:04.730]                             muffled <- TRUE
[16:22:04.730]                             break
[16:22:04.730]                           }
[16:22:04.730]                         }
[16:22:04.730]                       }
[16:22:04.730]                       invisible(muffled)
[16:22:04.730]                     }
[16:22:04.730]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.730]                   }
[16:22:04.730]                 }
[16:22:04.730]             }
[16:22:04.730]         }))
[16:22:04.730]     }, error = function(ex) {
[16:22:04.730]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:04.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.730]                 ...future.rng), started = ...future.startTime, 
[16:22:04.730]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:04.730]             version = "1.8"), class = "FutureResult")
[16:22:04.730]     }, finally = {
[16:22:04.730]         if (!identical(...future.workdir, getwd())) 
[16:22:04.730]             setwd(...future.workdir)
[16:22:04.730]         {
[16:22:04.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:04.730]                 ...future.oldOptions$nwarnings <- NULL
[16:22:04.730]             }
[16:22:04.730]             base::options(...future.oldOptions)
[16:22:04.730]             if (.Platform$OS.type == "windows") {
[16:22:04.730]                 old_names <- names(...future.oldEnvVars)
[16:22:04.730]                 envs <- base::Sys.getenv()
[16:22:04.730]                 names <- names(envs)
[16:22:04.730]                 common <- intersect(names, old_names)
[16:22:04.730]                 added <- setdiff(names, old_names)
[16:22:04.730]                 removed <- setdiff(old_names, names)
[16:22:04.730]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:04.730]                   envs[common]]
[16:22:04.730]                 NAMES <- toupper(changed)
[16:22:04.730]                 args <- list()
[16:22:04.730]                 for (kk in seq_along(NAMES)) {
[16:22:04.730]                   name <- changed[[kk]]
[16:22:04.730]                   NAME <- NAMES[[kk]]
[16:22:04.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.730]                     next
[16:22:04.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.730]                 }
[16:22:04.730]                 NAMES <- toupper(added)
[16:22:04.730]                 for (kk in seq_along(NAMES)) {
[16:22:04.730]                   name <- added[[kk]]
[16:22:04.730]                   NAME <- NAMES[[kk]]
[16:22:04.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.730]                     next
[16:22:04.730]                   args[[name]] <- ""
[16:22:04.730]                 }
[16:22:04.730]                 NAMES <- toupper(removed)
[16:22:04.730]                 for (kk in seq_along(NAMES)) {
[16:22:04.730]                   name <- removed[[kk]]
[16:22:04.730]                   NAME <- NAMES[[kk]]
[16:22:04.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.730]                     next
[16:22:04.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.730]                 }
[16:22:04.730]                 if (length(args) > 0) 
[16:22:04.730]                   base::do.call(base::Sys.setenv, args = args)
[16:22:04.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:04.730]             }
[16:22:04.730]             else {
[16:22:04.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:04.730]             }
[16:22:04.730]             {
[16:22:04.730]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:04.730]                   0L) {
[16:22:04.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:04.730]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:04.730]                   base::options(opts)
[16:22:04.730]                 }
[16:22:04.730]                 {
[16:22:04.730]                   {
[16:22:04.730]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:04.730]                     NULL
[16:22:04.730]                   }
[16:22:04.730]                   options(future.plan = NULL)
[16:22:04.730]                   if (is.na(NA_character_)) 
[16:22:04.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:04.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:04.730]                     .init = FALSE)
[16:22:04.730]                 }
[16:22:04.730]             }
[16:22:04.730]         }
[16:22:04.730]     })
[16:22:04.730]     if (TRUE) {
[16:22:04.730]         base::sink(type = "output", split = FALSE)
[16:22:04.730]         if (TRUE) {
[16:22:04.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:04.730]         }
[16:22:04.730]         else {
[16:22:04.730]             ...future.result["stdout"] <- base::list(NULL)
[16:22:04.730]         }
[16:22:04.730]         base::close(...future.stdout)
[16:22:04.730]         ...future.stdout <- NULL
[16:22:04.730]     }
[16:22:04.730]     ...future.result$conditions <- ...future.conditions
[16:22:04.730]     ...future.result$finished <- base::Sys.time()
[16:22:04.730]     ...future.result
[16:22:04.730] }
[16:22:04.733] MultisessionFuture started
[16:22:04.733] - Launch lazy future ... done
[16:22:04.733] run() for ‘MultisessionFuture’ ... done
[16:22:04.735] receiveMessageFromWorker() for ClusterFuture ...
[16:22:04.735] - Validating connection of MultisessionFuture
[16:22:04.735] - received message: FutureResult
[16:22:04.735] - Received FutureResult
[16:22:04.736] - Erased future from FutureRegistry
[16:22:04.736] result() for ClusterFuture ...
[16:22:04.736] - result already collected: FutureResult
[16:22:04.736] result() for ClusterFuture ... done
[16:22:04.736] signalConditions() ...
[16:22:04.736]  - include = ‘immediateCondition’
[16:22:04.736]  - exclude = 
[16:22:04.736]  - resignal = FALSE
[16:22:04.736]  - Number of conditions: 1
[16:22:04.736] signalConditions() ... done
[16:22:04.737] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:04.737] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[16:22:04.737] getGlobalsAndPackages() ...
[16:22:04.737] Searching for globals...
[16:22:04.738] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:04.738] Searching for globals ... DONE
[16:22:04.738] Resolving globals: FALSE
[16:22:04.739] 
[16:22:04.739] 
[16:22:04.739] getGlobalsAndPackages() ... DONE
[16:22:04.739] run() for ‘Future’ ...
[16:22:04.739] - state: ‘created’
[16:22:04.739] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:04.753] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:04.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:04.753]   - Field: ‘node’
[16:22:04.753]   - Field: ‘label’
[16:22:04.753]   - Field: ‘local’
[16:22:04.753]   - Field: ‘owner’
[16:22:04.753]   - Field: ‘envir’
[16:22:04.753]   - Field: ‘workers’
[16:22:04.753]   - Field: ‘packages’
[16:22:04.754]   - Field: ‘gc’
[16:22:04.754]   - Field: ‘conditions’
[16:22:04.754]   - Field: ‘persistent’
[16:22:04.754]   - Field: ‘expr’
[16:22:04.754]   - Field: ‘uuid’
[16:22:04.754]   - Field: ‘seed’
[16:22:04.754]   - Field: ‘version’
[16:22:04.754]   - Field: ‘result’
[16:22:04.754]   - Field: ‘asynchronous’
[16:22:04.754]   - Field: ‘calls’
[16:22:04.754]   - Field: ‘globals’
[16:22:04.755]   - Field: ‘stdout’
[16:22:04.755]   - Field: ‘earlySignal’
[16:22:04.755]   - Field: ‘lazy’
[16:22:04.755]   - Field: ‘state’
[16:22:04.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:04.755] - Launch lazy future ...
[16:22:04.755] Packages needed by the future expression (n = 0): <none>
[16:22:04.755] Packages needed by future strategies (n = 0): <none>
[16:22:04.756] {
[16:22:04.756]     {
[16:22:04.756]         {
[16:22:04.756]             ...future.startTime <- base::Sys.time()
[16:22:04.756]             {
[16:22:04.756]                 {
[16:22:04.756]                   {
[16:22:04.756]                     {
[16:22:04.756]                       base::local({
[16:22:04.756]                         has_future <- base::requireNamespace("future", 
[16:22:04.756]                           quietly = TRUE)
[16:22:04.756]                         if (has_future) {
[16:22:04.756]                           ns <- base::getNamespace("future")
[16:22:04.756]                           version <- ns[[".package"]][["version"]]
[16:22:04.756]                           if (is.null(version)) 
[16:22:04.756]                             version <- utils::packageVersion("future")
[16:22:04.756]                         }
[16:22:04.756]                         else {
[16:22:04.756]                           version <- NULL
[16:22:04.756]                         }
[16:22:04.756]                         if (!has_future || version < "1.8.0") {
[16:22:04.756]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:04.756]                             "", base::R.version$version.string), 
[16:22:04.756]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:04.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:04.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:04.756]                               "release", "version")], collapse = " "), 
[16:22:04.756]                             hostname = base::Sys.info()[["nodename"]])
[16:22:04.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:04.756]                             info)
[16:22:04.756]                           info <- base::paste(info, collapse = "; ")
[16:22:04.756]                           if (!has_future) {
[16:22:04.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:04.756]                               info)
[16:22:04.756]                           }
[16:22:04.756]                           else {
[16:22:04.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:04.756]                               info, version)
[16:22:04.756]                           }
[16:22:04.756]                           base::stop(msg)
[16:22:04.756]                         }
[16:22:04.756]                       })
[16:22:04.756]                     }
[16:22:04.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:04.756]                     base::options(mc.cores = 1L)
[16:22:04.756]                   }
[16:22:04.756]                   ...future.strategy.old <- future::plan("list")
[16:22:04.756]                   options(future.plan = NULL)
[16:22:04.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:04.756]                 }
[16:22:04.756]                 ...future.workdir <- getwd()
[16:22:04.756]             }
[16:22:04.756]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:04.756]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:04.756]         }
[16:22:04.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:04.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:04.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:04.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:04.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:04.756]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:04.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:04.756]             base::names(...future.oldOptions))
[16:22:04.756]     }
[16:22:04.756]     if (FALSE) {
[16:22:04.756]     }
[16:22:04.756]     else {
[16:22:04.756]         if (TRUE) {
[16:22:04.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:04.756]                 open = "w")
[16:22:04.756]         }
[16:22:04.756]         else {
[16:22:04.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:04.756]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:04.756]         }
[16:22:04.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:04.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:04.756]             base::sink(type = "output", split = FALSE)
[16:22:04.756]             base::close(...future.stdout)
[16:22:04.756]         }, add = TRUE)
[16:22:04.756]     }
[16:22:04.756]     ...future.frame <- base::sys.nframe()
[16:22:04.756]     ...future.conditions <- base::list()
[16:22:04.756]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:04.756]     if (FALSE) {
[16:22:04.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:04.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:04.756]     }
[16:22:04.756]     ...future.result <- base::tryCatch({
[16:22:04.756]         base::withCallingHandlers({
[16:22:04.756]             ...future.value <- base::withVisible(base::local({
[16:22:04.756]                 ...future.makeSendCondition <- base::local({
[16:22:04.756]                   sendCondition <- NULL
[16:22:04.756]                   function(frame = 1L) {
[16:22:04.756]                     if (is.function(sendCondition)) 
[16:22:04.756]                       return(sendCondition)
[16:22:04.756]                     ns <- getNamespace("parallel")
[16:22:04.756]                     if (exists("sendData", mode = "function", 
[16:22:04.756]                       envir = ns)) {
[16:22:04.756]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:04.756]                         envir = ns)
[16:22:04.756]                       envir <- sys.frame(frame)
[16:22:04.756]                       master <- NULL
[16:22:04.756]                       while (!identical(envir, .GlobalEnv) && 
[16:22:04.756]                         !identical(envir, emptyenv())) {
[16:22:04.756]                         if (exists("master", mode = "list", envir = envir, 
[16:22:04.756]                           inherits = FALSE)) {
[16:22:04.756]                           master <- get("master", mode = "list", 
[16:22:04.756]                             envir = envir, inherits = FALSE)
[16:22:04.756]                           if (inherits(master, c("SOCKnode", 
[16:22:04.756]                             "SOCK0node"))) {
[16:22:04.756]                             sendCondition <<- function(cond) {
[16:22:04.756]                               data <- list(type = "VALUE", value = cond, 
[16:22:04.756]                                 success = TRUE)
[16:22:04.756]                               parallel_sendData(master, data)
[16:22:04.756]                             }
[16:22:04.756]                             return(sendCondition)
[16:22:04.756]                           }
[16:22:04.756]                         }
[16:22:04.756]                         frame <- frame + 1L
[16:22:04.756]                         envir <- sys.frame(frame)
[16:22:04.756]                       }
[16:22:04.756]                     }
[16:22:04.756]                     sendCondition <<- function(cond) NULL
[16:22:04.756]                   }
[16:22:04.756]                 })
[16:22:04.756]                 withCallingHandlers({
[16:22:04.756]                   {
[16:22:04.756]                     Sys.sleep(0.5)
[16:22:04.756]                     list(a = 1, b = 42L)
[16:22:04.756]                   }
[16:22:04.756]                 }, immediateCondition = function(cond) {
[16:22:04.756]                   sendCondition <- ...future.makeSendCondition()
[16:22:04.756]                   sendCondition(cond)
[16:22:04.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.756]                   {
[16:22:04.756]                     inherits <- base::inherits
[16:22:04.756]                     invokeRestart <- base::invokeRestart
[16:22:04.756]                     is.null <- base::is.null
[16:22:04.756]                     muffled <- FALSE
[16:22:04.756]                     if (inherits(cond, "message")) {
[16:22:04.756]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:04.756]                       if (muffled) 
[16:22:04.756]                         invokeRestart("muffleMessage")
[16:22:04.756]                     }
[16:22:04.756]                     else if (inherits(cond, "warning")) {
[16:22:04.756]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:04.756]                       if (muffled) 
[16:22:04.756]                         invokeRestart("muffleWarning")
[16:22:04.756]                     }
[16:22:04.756]                     else if (inherits(cond, "condition")) {
[16:22:04.756]                       if (!is.null(pattern)) {
[16:22:04.756]                         computeRestarts <- base::computeRestarts
[16:22:04.756]                         grepl <- base::grepl
[16:22:04.756]                         restarts <- computeRestarts(cond)
[16:22:04.756]                         for (restart in restarts) {
[16:22:04.756]                           name <- restart$name
[16:22:04.756]                           if (is.null(name)) 
[16:22:04.756]                             next
[16:22:04.756]                           if (!grepl(pattern, name)) 
[16:22:04.756]                             next
[16:22:04.756]                           invokeRestart(restart)
[16:22:04.756]                           muffled <- TRUE
[16:22:04.756]                           break
[16:22:04.756]                         }
[16:22:04.756]                       }
[16:22:04.756]                     }
[16:22:04.756]                     invisible(muffled)
[16:22:04.756]                   }
[16:22:04.756]                   muffleCondition(cond)
[16:22:04.756]                 })
[16:22:04.756]             }))
[16:22:04.756]             future::FutureResult(value = ...future.value$value, 
[16:22:04.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.756]                   ...future.rng), globalenv = if (FALSE) 
[16:22:04.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:04.756]                     ...future.globalenv.names))
[16:22:04.756]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:04.756]         }, condition = base::local({
[16:22:04.756]             c <- base::c
[16:22:04.756]             inherits <- base::inherits
[16:22:04.756]             invokeRestart <- base::invokeRestart
[16:22:04.756]             length <- base::length
[16:22:04.756]             list <- base::list
[16:22:04.756]             seq.int <- base::seq.int
[16:22:04.756]             signalCondition <- base::signalCondition
[16:22:04.756]             sys.calls <- base::sys.calls
[16:22:04.756]             `[[` <- base::`[[`
[16:22:04.756]             `+` <- base::`+`
[16:22:04.756]             `<<-` <- base::`<<-`
[16:22:04.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:04.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:04.756]                   3L)]
[16:22:04.756]             }
[16:22:04.756]             function(cond) {
[16:22:04.756]                 is_error <- inherits(cond, "error")
[16:22:04.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:04.756]                   NULL)
[16:22:04.756]                 if (is_error) {
[16:22:04.756]                   sessionInformation <- function() {
[16:22:04.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:04.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:04.756]                       search = base::search(), system = base::Sys.info())
[16:22:04.756]                   }
[16:22:04.756]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:04.756]                     cond$call), session = sessionInformation(), 
[16:22:04.756]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:04.756]                   signalCondition(cond)
[16:22:04.756]                 }
[16:22:04.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:04.756]                 "immediateCondition"))) {
[16:22:04.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:04.756]                   ...future.conditions[[length(...future.conditions) + 
[16:22:04.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:04.756]                   if (TRUE && !signal) {
[16:22:04.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.756]                     {
[16:22:04.756]                       inherits <- base::inherits
[16:22:04.756]                       invokeRestart <- base::invokeRestart
[16:22:04.756]                       is.null <- base::is.null
[16:22:04.756]                       muffled <- FALSE
[16:22:04.756]                       if (inherits(cond, "message")) {
[16:22:04.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.756]                         if (muffled) 
[16:22:04.756]                           invokeRestart("muffleMessage")
[16:22:04.756]                       }
[16:22:04.756]                       else if (inherits(cond, "warning")) {
[16:22:04.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.756]                         if (muffled) 
[16:22:04.756]                           invokeRestart("muffleWarning")
[16:22:04.756]                       }
[16:22:04.756]                       else if (inherits(cond, "condition")) {
[16:22:04.756]                         if (!is.null(pattern)) {
[16:22:04.756]                           computeRestarts <- base::computeRestarts
[16:22:04.756]                           grepl <- base::grepl
[16:22:04.756]                           restarts <- computeRestarts(cond)
[16:22:04.756]                           for (restart in restarts) {
[16:22:04.756]                             name <- restart$name
[16:22:04.756]                             if (is.null(name)) 
[16:22:04.756]                               next
[16:22:04.756]                             if (!grepl(pattern, name)) 
[16:22:04.756]                               next
[16:22:04.756]                             invokeRestart(restart)
[16:22:04.756]                             muffled <- TRUE
[16:22:04.756]                             break
[16:22:04.756]                           }
[16:22:04.756]                         }
[16:22:04.756]                       }
[16:22:04.756]                       invisible(muffled)
[16:22:04.756]                     }
[16:22:04.756]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.756]                   }
[16:22:04.756]                 }
[16:22:04.756]                 else {
[16:22:04.756]                   if (TRUE) {
[16:22:04.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:04.756]                     {
[16:22:04.756]                       inherits <- base::inherits
[16:22:04.756]                       invokeRestart <- base::invokeRestart
[16:22:04.756]                       is.null <- base::is.null
[16:22:04.756]                       muffled <- FALSE
[16:22:04.756]                       if (inherits(cond, "message")) {
[16:22:04.756]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:04.756]                         if (muffled) 
[16:22:04.756]                           invokeRestart("muffleMessage")
[16:22:04.756]                       }
[16:22:04.756]                       else if (inherits(cond, "warning")) {
[16:22:04.756]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:04.756]                         if (muffled) 
[16:22:04.756]                           invokeRestart("muffleWarning")
[16:22:04.756]                       }
[16:22:04.756]                       else if (inherits(cond, "condition")) {
[16:22:04.756]                         if (!is.null(pattern)) {
[16:22:04.756]                           computeRestarts <- base::computeRestarts
[16:22:04.756]                           grepl <- base::grepl
[16:22:04.756]                           restarts <- computeRestarts(cond)
[16:22:04.756]                           for (restart in restarts) {
[16:22:04.756]                             name <- restart$name
[16:22:04.756]                             if (is.null(name)) 
[16:22:04.756]                               next
[16:22:04.756]                             if (!grepl(pattern, name)) 
[16:22:04.756]                               next
[16:22:04.756]                             invokeRestart(restart)
[16:22:04.756]                             muffled <- TRUE
[16:22:04.756]                             break
[16:22:04.756]                           }
[16:22:04.756]                         }
[16:22:04.756]                       }
[16:22:04.756]                       invisible(muffled)
[16:22:04.756]                     }
[16:22:04.756]                     muffleCondition(cond, pattern = "^muffle")
[16:22:04.756]                   }
[16:22:04.756]                 }
[16:22:04.756]             }
[16:22:04.756]         }))
[16:22:04.756]     }, error = function(ex) {
[16:22:04.756]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:04.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:04.756]                 ...future.rng), started = ...future.startTime, 
[16:22:04.756]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:04.756]             version = "1.8"), class = "FutureResult")
[16:22:04.756]     }, finally = {
[16:22:04.756]         if (!identical(...future.workdir, getwd())) 
[16:22:04.756]             setwd(...future.workdir)
[16:22:04.756]         {
[16:22:04.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:04.756]                 ...future.oldOptions$nwarnings <- NULL
[16:22:04.756]             }
[16:22:04.756]             base::options(...future.oldOptions)
[16:22:04.756]             if (.Platform$OS.type == "windows") {
[16:22:04.756]                 old_names <- names(...future.oldEnvVars)
[16:22:04.756]                 envs <- base::Sys.getenv()
[16:22:04.756]                 names <- names(envs)
[16:22:04.756]                 common <- intersect(names, old_names)
[16:22:04.756]                 added <- setdiff(names, old_names)
[16:22:04.756]                 removed <- setdiff(old_names, names)
[16:22:04.756]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:04.756]                   envs[common]]
[16:22:04.756]                 NAMES <- toupper(changed)
[16:22:04.756]                 args <- list()
[16:22:04.756]                 for (kk in seq_along(NAMES)) {
[16:22:04.756]                   name <- changed[[kk]]
[16:22:04.756]                   NAME <- NAMES[[kk]]
[16:22:04.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.756]                     next
[16:22:04.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.756]                 }
[16:22:04.756]                 NAMES <- toupper(added)
[16:22:04.756]                 for (kk in seq_along(NAMES)) {
[16:22:04.756]                   name <- added[[kk]]
[16:22:04.756]                   NAME <- NAMES[[kk]]
[16:22:04.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.756]                     next
[16:22:04.756]                   args[[name]] <- ""
[16:22:04.756]                 }
[16:22:04.756]                 NAMES <- toupper(removed)
[16:22:04.756]                 for (kk in seq_along(NAMES)) {
[16:22:04.756]                   name <- removed[[kk]]
[16:22:04.756]                   NAME <- NAMES[[kk]]
[16:22:04.756]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:04.756]                     next
[16:22:04.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:04.756]                 }
[16:22:04.756]                 if (length(args) > 0) 
[16:22:04.756]                   base::do.call(base::Sys.setenv, args = args)
[16:22:04.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:04.756]             }
[16:22:04.756]             else {
[16:22:04.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:04.756]             }
[16:22:04.756]             {
[16:22:04.756]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:04.756]                   0L) {
[16:22:04.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:04.756]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:04.756]                   base::options(opts)
[16:22:04.756]                 }
[16:22:04.756]                 {
[16:22:04.756]                   {
[16:22:04.756]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:04.756]                     NULL
[16:22:04.756]                   }
[16:22:04.756]                   options(future.plan = NULL)
[16:22:04.756]                   if (is.na(NA_character_)) 
[16:22:04.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:04.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:04.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:04.756]                     .init = FALSE)
[16:22:04.756]                 }
[16:22:04.756]             }
[16:22:04.756]         }
[16:22:04.756]     })
[16:22:04.756]     if (TRUE) {
[16:22:04.756]         base::sink(type = "output", split = FALSE)
[16:22:04.756]         if (TRUE) {
[16:22:04.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:04.756]         }
[16:22:04.756]         else {
[16:22:04.756]             ...future.result["stdout"] <- base::list(NULL)
[16:22:04.756]         }
[16:22:04.756]         base::close(...future.stdout)
[16:22:04.756]         ...future.stdout <- NULL
[16:22:04.756]     }
[16:22:04.756]     ...future.result$conditions <- ...future.conditions
[16:22:04.756]     ...future.result$finished <- base::Sys.time()
[16:22:04.756]     ...future.result
[16:22:04.756] }
[16:22:04.759] MultisessionFuture started
[16:22:04.759] - Launch lazy future ... done
[16:22:04.759] run() for ‘MultisessionFuture’ ... done
[16:22:05.261] receiveMessageFromWorker() for ClusterFuture ...
[16:22:05.262] - Validating connection of MultisessionFuture
[16:22:05.262] - received message: FutureResult
[16:22:05.262] - Received FutureResult
[16:22:05.262] - Erased future from FutureRegistry
[16:22:05.262] result() for ClusterFuture ...
[16:22:05.262] - result already collected: FutureResult
[16:22:05.262] result() for ClusterFuture ... done
[16:22:05.262] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:05.263] resolve() on list ...
[16:22:05.263]  recursive: 0
[16:22:05.263]  length: 2
[16:22:05.263]  elements: ‘a’, ‘b’
[16:22:05.263]  length: 1 (resolved future 1)
[16:22:05.263]  length: 0 (resolved future 2)
[16:22:05.263] resolve() on list ... DONE
[16:22:05.263] A MultisessionFuture was resolved (and resolved itself)
[16:22:05.263] getGlobalsAndPackages() ...
[16:22:05.263] Searching for globals...
[16:22:05.265] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:05.265] Searching for globals ... DONE
[16:22:05.265] Resolving globals: FALSE
[16:22:05.265] 
[16:22:05.265] 
[16:22:05.265] getGlobalsAndPackages() ... DONE
[16:22:05.266] run() for ‘Future’ ...
[16:22:05.266] - state: ‘created’
[16:22:05.266] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:05.280] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:05.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:05.280]   - Field: ‘node’
[16:22:05.280]   - Field: ‘label’
[16:22:05.281]   - Field: ‘local’
[16:22:05.281]   - Field: ‘owner’
[16:22:05.281]   - Field: ‘envir’
[16:22:05.281]   - Field: ‘workers’
[16:22:05.281]   - Field: ‘packages’
[16:22:05.281]   - Field: ‘gc’
[16:22:05.281]   - Field: ‘conditions’
[16:22:05.281]   - Field: ‘persistent’
[16:22:05.281]   - Field: ‘expr’
[16:22:05.281]   - Field: ‘uuid’
[16:22:05.281]   - Field: ‘seed’
[16:22:05.282]   - Field: ‘version’
[16:22:05.282]   - Field: ‘result’
[16:22:05.282]   - Field: ‘asynchronous’
[16:22:05.282]   - Field: ‘calls’
[16:22:05.282]   - Field: ‘globals’
[16:22:05.282]   - Field: ‘stdout’
[16:22:05.282]   - Field: ‘earlySignal’
[16:22:05.282]   - Field: ‘lazy’
[16:22:05.282]   - Field: ‘state’
[16:22:05.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:05.283] - Launch lazy future ...
[16:22:05.283] Packages needed by the future expression (n = 0): <none>
[16:22:05.283] Packages needed by future strategies (n = 0): <none>
[16:22:05.283] {
[16:22:05.283]     {
[16:22:05.283]         {
[16:22:05.283]             ...future.startTime <- base::Sys.time()
[16:22:05.283]             {
[16:22:05.283]                 {
[16:22:05.283]                   {
[16:22:05.283]                     {
[16:22:05.283]                       base::local({
[16:22:05.283]                         has_future <- base::requireNamespace("future", 
[16:22:05.283]                           quietly = TRUE)
[16:22:05.283]                         if (has_future) {
[16:22:05.283]                           ns <- base::getNamespace("future")
[16:22:05.283]                           version <- ns[[".package"]][["version"]]
[16:22:05.283]                           if (is.null(version)) 
[16:22:05.283]                             version <- utils::packageVersion("future")
[16:22:05.283]                         }
[16:22:05.283]                         else {
[16:22:05.283]                           version <- NULL
[16:22:05.283]                         }
[16:22:05.283]                         if (!has_future || version < "1.8.0") {
[16:22:05.283]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:05.283]                             "", base::R.version$version.string), 
[16:22:05.283]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:05.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:05.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:05.283]                               "release", "version")], collapse = " "), 
[16:22:05.283]                             hostname = base::Sys.info()[["nodename"]])
[16:22:05.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:05.283]                             info)
[16:22:05.283]                           info <- base::paste(info, collapse = "; ")
[16:22:05.283]                           if (!has_future) {
[16:22:05.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:05.283]                               info)
[16:22:05.283]                           }
[16:22:05.283]                           else {
[16:22:05.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:05.283]                               info, version)
[16:22:05.283]                           }
[16:22:05.283]                           base::stop(msg)
[16:22:05.283]                         }
[16:22:05.283]                       })
[16:22:05.283]                     }
[16:22:05.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:05.283]                     base::options(mc.cores = 1L)
[16:22:05.283]                   }
[16:22:05.283]                   ...future.strategy.old <- future::plan("list")
[16:22:05.283]                   options(future.plan = NULL)
[16:22:05.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:05.283]                 }
[16:22:05.283]                 ...future.workdir <- getwd()
[16:22:05.283]             }
[16:22:05.283]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:05.283]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:05.283]         }
[16:22:05.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:05.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:05.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:05.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:05.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:05.283]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:05.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:05.283]             base::names(...future.oldOptions))
[16:22:05.283]     }
[16:22:05.283]     if (FALSE) {
[16:22:05.283]     }
[16:22:05.283]     else {
[16:22:05.283]         if (TRUE) {
[16:22:05.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:05.283]                 open = "w")
[16:22:05.283]         }
[16:22:05.283]         else {
[16:22:05.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:05.283]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:05.283]         }
[16:22:05.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:05.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:05.283]             base::sink(type = "output", split = FALSE)
[16:22:05.283]             base::close(...future.stdout)
[16:22:05.283]         }, add = TRUE)
[16:22:05.283]     }
[16:22:05.283]     ...future.frame <- base::sys.nframe()
[16:22:05.283]     ...future.conditions <- base::list()
[16:22:05.283]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:05.283]     if (FALSE) {
[16:22:05.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:05.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:05.283]     }
[16:22:05.283]     ...future.result <- base::tryCatch({
[16:22:05.283]         base::withCallingHandlers({
[16:22:05.283]             ...future.value <- base::withVisible(base::local({
[16:22:05.283]                 ...future.makeSendCondition <- base::local({
[16:22:05.283]                   sendCondition <- NULL
[16:22:05.283]                   function(frame = 1L) {
[16:22:05.283]                     if (is.function(sendCondition)) 
[16:22:05.283]                       return(sendCondition)
[16:22:05.283]                     ns <- getNamespace("parallel")
[16:22:05.283]                     if (exists("sendData", mode = "function", 
[16:22:05.283]                       envir = ns)) {
[16:22:05.283]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:05.283]                         envir = ns)
[16:22:05.283]                       envir <- sys.frame(frame)
[16:22:05.283]                       master <- NULL
[16:22:05.283]                       while (!identical(envir, .GlobalEnv) && 
[16:22:05.283]                         !identical(envir, emptyenv())) {
[16:22:05.283]                         if (exists("master", mode = "list", envir = envir, 
[16:22:05.283]                           inherits = FALSE)) {
[16:22:05.283]                           master <- get("master", mode = "list", 
[16:22:05.283]                             envir = envir, inherits = FALSE)
[16:22:05.283]                           if (inherits(master, c("SOCKnode", 
[16:22:05.283]                             "SOCK0node"))) {
[16:22:05.283]                             sendCondition <<- function(cond) {
[16:22:05.283]                               data <- list(type = "VALUE", value = cond, 
[16:22:05.283]                                 success = TRUE)
[16:22:05.283]                               parallel_sendData(master, data)
[16:22:05.283]                             }
[16:22:05.283]                             return(sendCondition)
[16:22:05.283]                           }
[16:22:05.283]                         }
[16:22:05.283]                         frame <- frame + 1L
[16:22:05.283]                         envir <- sys.frame(frame)
[16:22:05.283]                       }
[16:22:05.283]                     }
[16:22:05.283]                     sendCondition <<- function(cond) NULL
[16:22:05.283]                   }
[16:22:05.283]                 })
[16:22:05.283]                 withCallingHandlers({
[16:22:05.283]                   {
[16:22:05.283]                     Sys.sleep(0.5)
[16:22:05.283]                     list(a = 1, b = 42L)
[16:22:05.283]                   }
[16:22:05.283]                 }, immediateCondition = function(cond) {
[16:22:05.283]                   sendCondition <- ...future.makeSendCondition()
[16:22:05.283]                   sendCondition(cond)
[16:22:05.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.283]                   {
[16:22:05.283]                     inherits <- base::inherits
[16:22:05.283]                     invokeRestart <- base::invokeRestart
[16:22:05.283]                     is.null <- base::is.null
[16:22:05.283]                     muffled <- FALSE
[16:22:05.283]                     if (inherits(cond, "message")) {
[16:22:05.283]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:05.283]                       if (muffled) 
[16:22:05.283]                         invokeRestart("muffleMessage")
[16:22:05.283]                     }
[16:22:05.283]                     else if (inherits(cond, "warning")) {
[16:22:05.283]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:05.283]                       if (muffled) 
[16:22:05.283]                         invokeRestart("muffleWarning")
[16:22:05.283]                     }
[16:22:05.283]                     else if (inherits(cond, "condition")) {
[16:22:05.283]                       if (!is.null(pattern)) {
[16:22:05.283]                         computeRestarts <- base::computeRestarts
[16:22:05.283]                         grepl <- base::grepl
[16:22:05.283]                         restarts <- computeRestarts(cond)
[16:22:05.283]                         for (restart in restarts) {
[16:22:05.283]                           name <- restart$name
[16:22:05.283]                           if (is.null(name)) 
[16:22:05.283]                             next
[16:22:05.283]                           if (!grepl(pattern, name)) 
[16:22:05.283]                             next
[16:22:05.283]                           invokeRestart(restart)
[16:22:05.283]                           muffled <- TRUE
[16:22:05.283]                           break
[16:22:05.283]                         }
[16:22:05.283]                       }
[16:22:05.283]                     }
[16:22:05.283]                     invisible(muffled)
[16:22:05.283]                   }
[16:22:05.283]                   muffleCondition(cond)
[16:22:05.283]                 })
[16:22:05.283]             }))
[16:22:05.283]             future::FutureResult(value = ...future.value$value, 
[16:22:05.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.283]                   ...future.rng), globalenv = if (FALSE) 
[16:22:05.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:05.283]                     ...future.globalenv.names))
[16:22:05.283]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:05.283]         }, condition = base::local({
[16:22:05.283]             c <- base::c
[16:22:05.283]             inherits <- base::inherits
[16:22:05.283]             invokeRestart <- base::invokeRestart
[16:22:05.283]             length <- base::length
[16:22:05.283]             list <- base::list
[16:22:05.283]             seq.int <- base::seq.int
[16:22:05.283]             signalCondition <- base::signalCondition
[16:22:05.283]             sys.calls <- base::sys.calls
[16:22:05.283]             `[[` <- base::`[[`
[16:22:05.283]             `+` <- base::`+`
[16:22:05.283]             `<<-` <- base::`<<-`
[16:22:05.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:05.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:05.283]                   3L)]
[16:22:05.283]             }
[16:22:05.283]             function(cond) {
[16:22:05.283]                 is_error <- inherits(cond, "error")
[16:22:05.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:05.283]                   NULL)
[16:22:05.283]                 if (is_error) {
[16:22:05.283]                   sessionInformation <- function() {
[16:22:05.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:05.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:05.283]                       search = base::search(), system = base::Sys.info())
[16:22:05.283]                   }
[16:22:05.283]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:05.283]                     cond$call), session = sessionInformation(), 
[16:22:05.283]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:05.283]                   signalCondition(cond)
[16:22:05.283]                 }
[16:22:05.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:05.283]                 "immediateCondition"))) {
[16:22:05.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:05.283]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:05.283]                   if (TRUE && !signal) {
[16:22:05.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.283]                     {
[16:22:05.283]                       inherits <- base::inherits
[16:22:05.283]                       invokeRestart <- base::invokeRestart
[16:22:05.283]                       is.null <- base::is.null
[16:22:05.283]                       muffled <- FALSE
[16:22:05.283]                       if (inherits(cond, "message")) {
[16:22:05.283]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.283]                         if (muffled) 
[16:22:05.283]                           invokeRestart("muffleMessage")
[16:22:05.283]                       }
[16:22:05.283]                       else if (inherits(cond, "warning")) {
[16:22:05.283]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.283]                         if (muffled) 
[16:22:05.283]                           invokeRestart("muffleWarning")
[16:22:05.283]                       }
[16:22:05.283]                       else if (inherits(cond, "condition")) {
[16:22:05.283]                         if (!is.null(pattern)) {
[16:22:05.283]                           computeRestarts <- base::computeRestarts
[16:22:05.283]                           grepl <- base::grepl
[16:22:05.283]                           restarts <- computeRestarts(cond)
[16:22:05.283]                           for (restart in restarts) {
[16:22:05.283]                             name <- restart$name
[16:22:05.283]                             if (is.null(name)) 
[16:22:05.283]                               next
[16:22:05.283]                             if (!grepl(pattern, name)) 
[16:22:05.283]                               next
[16:22:05.283]                             invokeRestart(restart)
[16:22:05.283]                             muffled <- TRUE
[16:22:05.283]                             break
[16:22:05.283]                           }
[16:22:05.283]                         }
[16:22:05.283]                       }
[16:22:05.283]                       invisible(muffled)
[16:22:05.283]                     }
[16:22:05.283]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.283]                   }
[16:22:05.283]                 }
[16:22:05.283]                 else {
[16:22:05.283]                   if (TRUE) {
[16:22:05.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.283]                     {
[16:22:05.283]                       inherits <- base::inherits
[16:22:05.283]                       invokeRestart <- base::invokeRestart
[16:22:05.283]                       is.null <- base::is.null
[16:22:05.283]                       muffled <- FALSE
[16:22:05.283]                       if (inherits(cond, "message")) {
[16:22:05.283]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.283]                         if (muffled) 
[16:22:05.283]                           invokeRestart("muffleMessage")
[16:22:05.283]                       }
[16:22:05.283]                       else if (inherits(cond, "warning")) {
[16:22:05.283]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.283]                         if (muffled) 
[16:22:05.283]                           invokeRestart("muffleWarning")
[16:22:05.283]                       }
[16:22:05.283]                       else if (inherits(cond, "condition")) {
[16:22:05.283]                         if (!is.null(pattern)) {
[16:22:05.283]                           computeRestarts <- base::computeRestarts
[16:22:05.283]                           grepl <- base::grepl
[16:22:05.283]                           restarts <- computeRestarts(cond)
[16:22:05.283]                           for (restart in restarts) {
[16:22:05.283]                             name <- restart$name
[16:22:05.283]                             if (is.null(name)) 
[16:22:05.283]                               next
[16:22:05.283]                             if (!grepl(pattern, name)) 
[16:22:05.283]                               next
[16:22:05.283]                             invokeRestart(restart)
[16:22:05.283]                             muffled <- TRUE
[16:22:05.283]                             break
[16:22:05.283]                           }
[16:22:05.283]                         }
[16:22:05.283]                       }
[16:22:05.283]                       invisible(muffled)
[16:22:05.283]                     }
[16:22:05.283]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.283]                   }
[16:22:05.283]                 }
[16:22:05.283]             }
[16:22:05.283]         }))
[16:22:05.283]     }, error = function(ex) {
[16:22:05.283]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:05.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.283]                 ...future.rng), started = ...future.startTime, 
[16:22:05.283]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:05.283]             version = "1.8"), class = "FutureResult")
[16:22:05.283]     }, finally = {
[16:22:05.283]         if (!identical(...future.workdir, getwd())) 
[16:22:05.283]             setwd(...future.workdir)
[16:22:05.283]         {
[16:22:05.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:05.283]                 ...future.oldOptions$nwarnings <- NULL
[16:22:05.283]             }
[16:22:05.283]             base::options(...future.oldOptions)
[16:22:05.283]             if (.Platform$OS.type == "windows") {
[16:22:05.283]                 old_names <- names(...future.oldEnvVars)
[16:22:05.283]                 envs <- base::Sys.getenv()
[16:22:05.283]                 names <- names(envs)
[16:22:05.283]                 common <- intersect(names, old_names)
[16:22:05.283]                 added <- setdiff(names, old_names)
[16:22:05.283]                 removed <- setdiff(old_names, names)
[16:22:05.283]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:05.283]                   envs[common]]
[16:22:05.283]                 NAMES <- toupper(changed)
[16:22:05.283]                 args <- list()
[16:22:05.283]                 for (kk in seq_along(NAMES)) {
[16:22:05.283]                   name <- changed[[kk]]
[16:22:05.283]                   NAME <- NAMES[[kk]]
[16:22:05.283]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.283]                     next
[16:22:05.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.283]                 }
[16:22:05.283]                 NAMES <- toupper(added)
[16:22:05.283]                 for (kk in seq_along(NAMES)) {
[16:22:05.283]                   name <- added[[kk]]
[16:22:05.283]                   NAME <- NAMES[[kk]]
[16:22:05.283]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.283]                     next
[16:22:05.283]                   args[[name]] <- ""
[16:22:05.283]                 }
[16:22:05.283]                 NAMES <- toupper(removed)
[16:22:05.283]                 for (kk in seq_along(NAMES)) {
[16:22:05.283]                   name <- removed[[kk]]
[16:22:05.283]                   NAME <- NAMES[[kk]]
[16:22:05.283]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.283]                     next
[16:22:05.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.283]                 }
[16:22:05.283]                 if (length(args) > 0) 
[16:22:05.283]                   base::do.call(base::Sys.setenv, args = args)
[16:22:05.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:05.283]             }
[16:22:05.283]             else {
[16:22:05.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:05.283]             }
[16:22:05.283]             {
[16:22:05.283]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:05.283]                   0L) {
[16:22:05.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:05.283]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:05.283]                   base::options(opts)
[16:22:05.283]                 }
[16:22:05.283]                 {
[16:22:05.283]                   {
[16:22:05.283]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:05.283]                     NULL
[16:22:05.283]                   }
[16:22:05.283]                   options(future.plan = NULL)
[16:22:05.283]                   if (is.na(NA_character_)) 
[16:22:05.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:05.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:05.283]                     .init = FALSE)
[16:22:05.283]                 }
[16:22:05.283]             }
[16:22:05.283]         }
[16:22:05.283]     })
[16:22:05.283]     if (TRUE) {
[16:22:05.283]         base::sink(type = "output", split = FALSE)
[16:22:05.283]         if (TRUE) {
[16:22:05.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:05.283]         }
[16:22:05.283]         else {
[16:22:05.283]             ...future.result["stdout"] <- base::list(NULL)
[16:22:05.283]         }
[16:22:05.283]         base::close(...future.stdout)
[16:22:05.283]         ...future.stdout <- NULL
[16:22:05.283]     }
[16:22:05.283]     ...future.result$conditions <- ...future.conditions
[16:22:05.283]     ...future.result$finished <- base::Sys.time()
[16:22:05.283]     ...future.result
[16:22:05.283] }
[16:22:05.286] MultisessionFuture started
[16:22:05.286] - Launch lazy future ... done
[16:22:05.287] run() for ‘MultisessionFuture’ ... done
[16:22:05.789] receiveMessageFromWorker() for ClusterFuture ...
[16:22:05.789] - Validating connection of MultisessionFuture
[16:22:05.789] - received message: FutureResult
[16:22:05.789] - Received FutureResult
[16:22:05.790] - Erased future from FutureRegistry
[16:22:05.790] result() for ClusterFuture ...
[16:22:05.790] - result already collected: FutureResult
[16:22:05.790] result() for ClusterFuture ... done
[16:22:05.790] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:05.790] resolve() on list ...
[16:22:05.790]  recursive: 0
[16:22:05.791]  length: 2
[16:22:05.791]  elements: ‘a’, ‘b’
[16:22:05.791]  length: 1 (resolved future 1)
[16:22:05.791]  length: 0 (resolved future 2)
[16:22:05.791] resolve() on list ... DONE
[16:22:05.791] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:22:05.791] getGlobalsAndPackages() ...
[16:22:05.792] Searching for globals...
[16:22:05.795] - globals found: [2] ‘list’, ‘stop’
[16:22:05.795] Searching for globals ... DONE
[16:22:05.795] Resolving globals: FALSE
[16:22:05.795] 
[16:22:05.795] 
[16:22:05.796] getGlobalsAndPackages() ... DONE
[16:22:05.796] run() for ‘Future’ ...
[16:22:05.796] - state: ‘created’
[16:22:05.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:05.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:05.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:05.811]   - Field: ‘node’
[16:22:05.811]   - Field: ‘label’
[16:22:05.811]   - Field: ‘local’
[16:22:05.811]   - Field: ‘owner’
[16:22:05.811]   - Field: ‘envir’
[16:22:05.811]   - Field: ‘workers’
[16:22:05.811]   - Field: ‘packages’
[16:22:05.811]   - Field: ‘gc’
[16:22:05.811]   - Field: ‘conditions’
[16:22:05.812]   - Field: ‘persistent’
[16:22:05.812]   - Field: ‘expr’
[16:22:05.812]   - Field: ‘uuid’
[16:22:05.812]   - Field: ‘seed’
[16:22:05.812]   - Field: ‘version’
[16:22:05.812]   - Field: ‘result’
[16:22:05.812]   - Field: ‘asynchronous’
[16:22:05.812]   - Field: ‘calls’
[16:22:05.812]   - Field: ‘globals’
[16:22:05.812]   - Field: ‘stdout’
[16:22:05.812]   - Field: ‘earlySignal’
[16:22:05.813]   - Field: ‘lazy’
[16:22:05.813]   - Field: ‘state’
[16:22:05.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:05.813] - Launch lazy future ...
[16:22:05.813] Packages needed by the future expression (n = 0): <none>
[16:22:05.813] Packages needed by future strategies (n = 0): <none>
[16:22:05.814] {
[16:22:05.814]     {
[16:22:05.814]         {
[16:22:05.814]             ...future.startTime <- base::Sys.time()
[16:22:05.814]             {
[16:22:05.814]                 {
[16:22:05.814]                   {
[16:22:05.814]                     {
[16:22:05.814]                       base::local({
[16:22:05.814]                         has_future <- base::requireNamespace("future", 
[16:22:05.814]                           quietly = TRUE)
[16:22:05.814]                         if (has_future) {
[16:22:05.814]                           ns <- base::getNamespace("future")
[16:22:05.814]                           version <- ns[[".package"]][["version"]]
[16:22:05.814]                           if (is.null(version)) 
[16:22:05.814]                             version <- utils::packageVersion("future")
[16:22:05.814]                         }
[16:22:05.814]                         else {
[16:22:05.814]                           version <- NULL
[16:22:05.814]                         }
[16:22:05.814]                         if (!has_future || version < "1.8.0") {
[16:22:05.814]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:05.814]                             "", base::R.version$version.string), 
[16:22:05.814]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:05.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:05.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:05.814]                               "release", "version")], collapse = " "), 
[16:22:05.814]                             hostname = base::Sys.info()[["nodename"]])
[16:22:05.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:05.814]                             info)
[16:22:05.814]                           info <- base::paste(info, collapse = "; ")
[16:22:05.814]                           if (!has_future) {
[16:22:05.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:05.814]                               info)
[16:22:05.814]                           }
[16:22:05.814]                           else {
[16:22:05.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:05.814]                               info, version)
[16:22:05.814]                           }
[16:22:05.814]                           base::stop(msg)
[16:22:05.814]                         }
[16:22:05.814]                       })
[16:22:05.814]                     }
[16:22:05.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:05.814]                     base::options(mc.cores = 1L)
[16:22:05.814]                   }
[16:22:05.814]                   ...future.strategy.old <- future::plan("list")
[16:22:05.814]                   options(future.plan = NULL)
[16:22:05.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:05.814]                 }
[16:22:05.814]                 ...future.workdir <- getwd()
[16:22:05.814]             }
[16:22:05.814]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:05.814]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:05.814]         }
[16:22:05.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:05.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:05.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:05.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:05.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:05.814]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:05.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:05.814]             base::names(...future.oldOptions))
[16:22:05.814]     }
[16:22:05.814]     if (FALSE) {
[16:22:05.814]     }
[16:22:05.814]     else {
[16:22:05.814]         if (TRUE) {
[16:22:05.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:05.814]                 open = "w")
[16:22:05.814]         }
[16:22:05.814]         else {
[16:22:05.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:05.814]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:05.814]         }
[16:22:05.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:05.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:05.814]             base::sink(type = "output", split = FALSE)
[16:22:05.814]             base::close(...future.stdout)
[16:22:05.814]         }, add = TRUE)
[16:22:05.814]     }
[16:22:05.814]     ...future.frame <- base::sys.nframe()
[16:22:05.814]     ...future.conditions <- base::list()
[16:22:05.814]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:05.814]     if (FALSE) {
[16:22:05.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:05.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:05.814]     }
[16:22:05.814]     ...future.result <- base::tryCatch({
[16:22:05.814]         base::withCallingHandlers({
[16:22:05.814]             ...future.value <- base::withVisible(base::local({
[16:22:05.814]                 ...future.makeSendCondition <- base::local({
[16:22:05.814]                   sendCondition <- NULL
[16:22:05.814]                   function(frame = 1L) {
[16:22:05.814]                     if (is.function(sendCondition)) 
[16:22:05.814]                       return(sendCondition)
[16:22:05.814]                     ns <- getNamespace("parallel")
[16:22:05.814]                     if (exists("sendData", mode = "function", 
[16:22:05.814]                       envir = ns)) {
[16:22:05.814]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:05.814]                         envir = ns)
[16:22:05.814]                       envir <- sys.frame(frame)
[16:22:05.814]                       master <- NULL
[16:22:05.814]                       while (!identical(envir, .GlobalEnv) && 
[16:22:05.814]                         !identical(envir, emptyenv())) {
[16:22:05.814]                         if (exists("master", mode = "list", envir = envir, 
[16:22:05.814]                           inherits = FALSE)) {
[16:22:05.814]                           master <- get("master", mode = "list", 
[16:22:05.814]                             envir = envir, inherits = FALSE)
[16:22:05.814]                           if (inherits(master, c("SOCKnode", 
[16:22:05.814]                             "SOCK0node"))) {
[16:22:05.814]                             sendCondition <<- function(cond) {
[16:22:05.814]                               data <- list(type = "VALUE", value = cond, 
[16:22:05.814]                                 success = TRUE)
[16:22:05.814]                               parallel_sendData(master, data)
[16:22:05.814]                             }
[16:22:05.814]                             return(sendCondition)
[16:22:05.814]                           }
[16:22:05.814]                         }
[16:22:05.814]                         frame <- frame + 1L
[16:22:05.814]                         envir <- sys.frame(frame)
[16:22:05.814]                       }
[16:22:05.814]                     }
[16:22:05.814]                     sendCondition <<- function(cond) NULL
[16:22:05.814]                   }
[16:22:05.814]                 })
[16:22:05.814]                 withCallingHandlers({
[16:22:05.814]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:05.814]                 }, immediateCondition = function(cond) {
[16:22:05.814]                   sendCondition <- ...future.makeSendCondition()
[16:22:05.814]                   sendCondition(cond)
[16:22:05.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.814]                   {
[16:22:05.814]                     inherits <- base::inherits
[16:22:05.814]                     invokeRestart <- base::invokeRestart
[16:22:05.814]                     is.null <- base::is.null
[16:22:05.814]                     muffled <- FALSE
[16:22:05.814]                     if (inherits(cond, "message")) {
[16:22:05.814]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:05.814]                       if (muffled) 
[16:22:05.814]                         invokeRestart("muffleMessage")
[16:22:05.814]                     }
[16:22:05.814]                     else if (inherits(cond, "warning")) {
[16:22:05.814]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:05.814]                       if (muffled) 
[16:22:05.814]                         invokeRestart("muffleWarning")
[16:22:05.814]                     }
[16:22:05.814]                     else if (inherits(cond, "condition")) {
[16:22:05.814]                       if (!is.null(pattern)) {
[16:22:05.814]                         computeRestarts <- base::computeRestarts
[16:22:05.814]                         grepl <- base::grepl
[16:22:05.814]                         restarts <- computeRestarts(cond)
[16:22:05.814]                         for (restart in restarts) {
[16:22:05.814]                           name <- restart$name
[16:22:05.814]                           if (is.null(name)) 
[16:22:05.814]                             next
[16:22:05.814]                           if (!grepl(pattern, name)) 
[16:22:05.814]                             next
[16:22:05.814]                           invokeRestart(restart)
[16:22:05.814]                           muffled <- TRUE
[16:22:05.814]                           break
[16:22:05.814]                         }
[16:22:05.814]                       }
[16:22:05.814]                     }
[16:22:05.814]                     invisible(muffled)
[16:22:05.814]                   }
[16:22:05.814]                   muffleCondition(cond)
[16:22:05.814]                 })
[16:22:05.814]             }))
[16:22:05.814]             future::FutureResult(value = ...future.value$value, 
[16:22:05.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.814]                   ...future.rng), globalenv = if (FALSE) 
[16:22:05.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:05.814]                     ...future.globalenv.names))
[16:22:05.814]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:05.814]         }, condition = base::local({
[16:22:05.814]             c <- base::c
[16:22:05.814]             inherits <- base::inherits
[16:22:05.814]             invokeRestart <- base::invokeRestart
[16:22:05.814]             length <- base::length
[16:22:05.814]             list <- base::list
[16:22:05.814]             seq.int <- base::seq.int
[16:22:05.814]             signalCondition <- base::signalCondition
[16:22:05.814]             sys.calls <- base::sys.calls
[16:22:05.814]             `[[` <- base::`[[`
[16:22:05.814]             `+` <- base::`+`
[16:22:05.814]             `<<-` <- base::`<<-`
[16:22:05.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:05.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:05.814]                   3L)]
[16:22:05.814]             }
[16:22:05.814]             function(cond) {
[16:22:05.814]                 is_error <- inherits(cond, "error")
[16:22:05.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:05.814]                   NULL)
[16:22:05.814]                 if (is_error) {
[16:22:05.814]                   sessionInformation <- function() {
[16:22:05.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:05.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:05.814]                       search = base::search(), system = base::Sys.info())
[16:22:05.814]                   }
[16:22:05.814]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:05.814]                     cond$call), session = sessionInformation(), 
[16:22:05.814]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:05.814]                   signalCondition(cond)
[16:22:05.814]                 }
[16:22:05.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:05.814]                 "immediateCondition"))) {
[16:22:05.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:05.814]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:05.814]                   if (TRUE && !signal) {
[16:22:05.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.814]                     {
[16:22:05.814]                       inherits <- base::inherits
[16:22:05.814]                       invokeRestart <- base::invokeRestart
[16:22:05.814]                       is.null <- base::is.null
[16:22:05.814]                       muffled <- FALSE
[16:22:05.814]                       if (inherits(cond, "message")) {
[16:22:05.814]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.814]                         if (muffled) 
[16:22:05.814]                           invokeRestart("muffleMessage")
[16:22:05.814]                       }
[16:22:05.814]                       else if (inherits(cond, "warning")) {
[16:22:05.814]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.814]                         if (muffled) 
[16:22:05.814]                           invokeRestart("muffleWarning")
[16:22:05.814]                       }
[16:22:05.814]                       else if (inherits(cond, "condition")) {
[16:22:05.814]                         if (!is.null(pattern)) {
[16:22:05.814]                           computeRestarts <- base::computeRestarts
[16:22:05.814]                           grepl <- base::grepl
[16:22:05.814]                           restarts <- computeRestarts(cond)
[16:22:05.814]                           for (restart in restarts) {
[16:22:05.814]                             name <- restart$name
[16:22:05.814]                             if (is.null(name)) 
[16:22:05.814]                               next
[16:22:05.814]                             if (!grepl(pattern, name)) 
[16:22:05.814]                               next
[16:22:05.814]                             invokeRestart(restart)
[16:22:05.814]                             muffled <- TRUE
[16:22:05.814]                             break
[16:22:05.814]                           }
[16:22:05.814]                         }
[16:22:05.814]                       }
[16:22:05.814]                       invisible(muffled)
[16:22:05.814]                     }
[16:22:05.814]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.814]                   }
[16:22:05.814]                 }
[16:22:05.814]                 else {
[16:22:05.814]                   if (TRUE) {
[16:22:05.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.814]                     {
[16:22:05.814]                       inherits <- base::inherits
[16:22:05.814]                       invokeRestart <- base::invokeRestart
[16:22:05.814]                       is.null <- base::is.null
[16:22:05.814]                       muffled <- FALSE
[16:22:05.814]                       if (inherits(cond, "message")) {
[16:22:05.814]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.814]                         if (muffled) 
[16:22:05.814]                           invokeRestart("muffleMessage")
[16:22:05.814]                       }
[16:22:05.814]                       else if (inherits(cond, "warning")) {
[16:22:05.814]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.814]                         if (muffled) 
[16:22:05.814]                           invokeRestart("muffleWarning")
[16:22:05.814]                       }
[16:22:05.814]                       else if (inherits(cond, "condition")) {
[16:22:05.814]                         if (!is.null(pattern)) {
[16:22:05.814]                           computeRestarts <- base::computeRestarts
[16:22:05.814]                           grepl <- base::grepl
[16:22:05.814]                           restarts <- computeRestarts(cond)
[16:22:05.814]                           for (restart in restarts) {
[16:22:05.814]                             name <- restart$name
[16:22:05.814]                             if (is.null(name)) 
[16:22:05.814]                               next
[16:22:05.814]                             if (!grepl(pattern, name)) 
[16:22:05.814]                               next
[16:22:05.814]                             invokeRestart(restart)
[16:22:05.814]                             muffled <- TRUE
[16:22:05.814]                             break
[16:22:05.814]                           }
[16:22:05.814]                         }
[16:22:05.814]                       }
[16:22:05.814]                       invisible(muffled)
[16:22:05.814]                     }
[16:22:05.814]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.814]                   }
[16:22:05.814]                 }
[16:22:05.814]             }
[16:22:05.814]         }))
[16:22:05.814]     }, error = function(ex) {
[16:22:05.814]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:05.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.814]                 ...future.rng), started = ...future.startTime, 
[16:22:05.814]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:05.814]             version = "1.8"), class = "FutureResult")
[16:22:05.814]     }, finally = {
[16:22:05.814]         if (!identical(...future.workdir, getwd())) 
[16:22:05.814]             setwd(...future.workdir)
[16:22:05.814]         {
[16:22:05.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:05.814]                 ...future.oldOptions$nwarnings <- NULL
[16:22:05.814]             }
[16:22:05.814]             base::options(...future.oldOptions)
[16:22:05.814]             if (.Platform$OS.type == "windows") {
[16:22:05.814]                 old_names <- names(...future.oldEnvVars)
[16:22:05.814]                 envs <- base::Sys.getenv()
[16:22:05.814]                 names <- names(envs)
[16:22:05.814]                 common <- intersect(names, old_names)
[16:22:05.814]                 added <- setdiff(names, old_names)
[16:22:05.814]                 removed <- setdiff(old_names, names)
[16:22:05.814]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:05.814]                   envs[common]]
[16:22:05.814]                 NAMES <- toupper(changed)
[16:22:05.814]                 args <- list()
[16:22:05.814]                 for (kk in seq_along(NAMES)) {
[16:22:05.814]                   name <- changed[[kk]]
[16:22:05.814]                   NAME <- NAMES[[kk]]
[16:22:05.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.814]                     next
[16:22:05.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.814]                 }
[16:22:05.814]                 NAMES <- toupper(added)
[16:22:05.814]                 for (kk in seq_along(NAMES)) {
[16:22:05.814]                   name <- added[[kk]]
[16:22:05.814]                   NAME <- NAMES[[kk]]
[16:22:05.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.814]                     next
[16:22:05.814]                   args[[name]] <- ""
[16:22:05.814]                 }
[16:22:05.814]                 NAMES <- toupper(removed)
[16:22:05.814]                 for (kk in seq_along(NAMES)) {
[16:22:05.814]                   name <- removed[[kk]]
[16:22:05.814]                   NAME <- NAMES[[kk]]
[16:22:05.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.814]                     next
[16:22:05.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.814]                 }
[16:22:05.814]                 if (length(args) > 0) 
[16:22:05.814]                   base::do.call(base::Sys.setenv, args = args)
[16:22:05.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:05.814]             }
[16:22:05.814]             else {
[16:22:05.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:05.814]             }
[16:22:05.814]             {
[16:22:05.814]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:05.814]                   0L) {
[16:22:05.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:05.814]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:05.814]                   base::options(opts)
[16:22:05.814]                 }
[16:22:05.814]                 {
[16:22:05.814]                   {
[16:22:05.814]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:05.814]                     NULL
[16:22:05.814]                   }
[16:22:05.814]                   options(future.plan = NULL)
[16:22:05.814]                   if (is.na(NA_character_)) 
[16:22:05.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:05.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:05.814]                     .init = FALSE)
[16:22:05.814]                 }
[16:22:05.814]             }
[16:22:05.814]         }
[16:22:05.814]     })
[16:22:05.814]     if (TRUE) {
[16:22:05.814]         base::sink(type = "output", split = FALSE)
[16:22:05.814]         if (TRUE) {
[16:22:05.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:05.814]         }
[16:22:05.814]         else {
[16:22:05.814]             ...future.result["stdout"] <- base::list(NULL)
[16:22:05.814]         }
[16:22:05.814]         base::close(...future.stdout)
[16:22:05.814]         ...future.stdout <- NULL
[16:22:05.814]     }
[16:22:05.814]     ...future.result$conditions <- ...future.conditions
[16:22:05.814]     ...future.result$finished <- base::Sys.time()
[16:22:05.814]     ...future.result
[16:22:05.814] }
[16:22:05.816] MultisessionFuture started
[16:22:05.817] - Launch lazy future ... done
[16:22:05.817] run() for ‘MultisessionFuture’ ... done
[16:22:05.819] receiveMessageFromWorker() for ClusterFuture ...
[16:22:05.819] - Validating connection of MultisessionFuture
[16:22:05.819] - received message: FutureResult
[16:22:05.819] - Received FutureResult
[16:22:05.819] - Erased future from FutureRegistry
[16:22:05.820] result() for ClusterFuture ...
[16:22:05.820] - result already collected: FutureResult
[16:22:05.820] result() for ClusterFuture ... done
[16:22:05.820] signalConditions() ...
[16:22:05.820]  - include = ‘immediateCondition’
[16:22:05.820]  - exclude = 
[16:22:05.820]  - resignal = FALSE
[16:22:05.820]  - Number of conditions: 1
[16:22:05.820] signalConditions() ... done
[16:22:05.820] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:05.820] A MultisessionFuture was resolved
[16:22:05.821] getGlobalsAndPackages() ...
[16:22:05.821] Searching for globals...
[16:22:05.821] - globals found: [2] ‘list’, ‘stop’
[16:22:05.821] Searching for globals ... DONE
[16:22:05.821] Resolving globals: FALSE
[16:22:05.822] 
[16:22:05.822] 
[16:22:05.822] getGlobalsAndPackages() ... DONE
[16:22:05.822] run() for ‘Future’ ...
[16:22:05.822] - state: ‘created’
[16:22:05.822] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:05.836] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:05.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:05.836]   - Field: ‘node’
[16:22:05.837]   - Field: ‘label’
[16:22:05.837]   - Field: ‘local’
[16:22:05.837]   - Field: ‘owner’
[16:22:05.837]   - Field: ‘envir’
[16:22:05.837]   - Field: ‘workers’
[16:22:05.837]   - Field: ‘packages’
[16:22:05.837]   - Field: ‘gc’
[16:22:05.837]   - Field: ‘conditions’
[16:22:05.837]   - Field: ‘persistent’
[16:22:05.837]   - Field: ‘expr’
[16:22:05.837]   - Field: ‘uuid’
[16:22:05.837]   - Field: ‘seed’
[16:22:05.838]   - Field: ‘version’
[16:22:05.838]   - Field: ‘result’
[16:22:05.838]   - Field: ‘asynchronous’
[16:22:05.838]   - Field: ‘calls’
[16:22:05.838]   - Field: ‘globals’
[16:22:05.838]   - Field: ‘stdout’
[16:22:05.838]   - Field: ‘earlySignal’
[16:22:05.838]   - Field: ‘lazy’
[16:22:05.838]   - Field: ‘state’
[16:22:05.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:05.838] - Launch lazy future ...
[16:22:05.839] Packages needed by the future expression (n = 0): <none>
[16:22:05.839] Packages needed by future strategies (n = 0): <none>
[16:22:05.839] {
[16:22:05.839]     {
[16:22:05.839]         {
[16:22:05.839]             ...future.startTime <- base::Sys.time()
[16:22:05.839]             {
[16:22:05.839]                 {
[16:22:05.839]                   {
[16:22:05.839]                     {
[16:22:05.839]                       base::local({
[16:22:05.839]                         has_future <- base::requireNamespace("future", 
[16:22:05.839]                           quietly = TRUE)
[16:22:05.839]                         if (has_future) {
[16:22:05.839]                           ns <- base::getNamespace("future")
[16:22:05.839]                           version <- ns[[".package"]][["version"]]
[16:22:05.839]                           if (is.null(version)) 
[16:22:05.839]                             version <- utils::packageVersion("future")
[16:22:05.839]                         }
[16:22:05.839]                         else {
[16:22:05.839]                           version <- NULL
[16:22:05.839]                         }
[16:22:05.839]                         if (!has_future || version < "1.8.0") {
[16:22:05.839]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:05.839]                             "", base::R.version$version.string), 
[16:22:05.839]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:05.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:05.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:05.839]                               "release", "version")], collapse = " "), 
[16:22:05.839]                             hostname = base::Sys.info()[["nodename"]])
[16:22:05.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:05.839]                             info)
[16:22:05.839]                           info <- base::paste(info, collapse = "; ")
[16:22:05.839]                           if (!has_future) {
[16:22:05.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:05.839]                               info)
[16:22:05.839]                           }
[16:22:05.839]                           else {
[16:22:05.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:05.839]                               info, version)
[16:22:05.839]                           }
[16:22:05.839]                           base::stop(msg)
[16:22:05.839]                         }
[16:22:05.839]                       })
[16:22:05.839]                     }
[16:22:05.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:05.839]                     base::options(mc.cores = 1L)
[16:22:05.839]                   }
[16:22:05.839]                   ...future.strategy.old <- future::plan("list")
[16:22:05.839]                   options(future.plan = NULL)
[16:22:05.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:05.839]                 }
[16:22:05.839]                 ...future.workdir <- getwd()
[16:22:05.839]             }
[16:22:05.839]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:05.839]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:05.839]         }
[16:22:05.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:05.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:05.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:05.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:05.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:05.839]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:05.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:05.839]             base::names(...future.oldOptions))
[16:22:05.839]     }
[16:22:05.839]     if (FALSE) {
[16:22:05.839]     }
[16:22:05.839]     else {
[16:22:05.839]         if (TRUE) {
[16:22:05.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:05.839]                 open = "w")
[16:22:05.839]         }
[16:22:05.839]         else {
[16:22:05.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:05.839]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:05.839]         }
[16:22:05.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:05.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:05.839]             base::sink(type = "output", split = FALSE)
[16:22:05.839]             base::close(...future.stdout)
[16:22:05.839]         }, add = TRUE)
[16:22:05.839]     }
[16:22:05.839]     ...future.frame <- base::sys.nframe()
[16:22:05.839]     ...future.conditions <- base::list()
[16:22:05.839]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:05.839]     if (FALSE) {
[16:22:05.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:05.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:05.839]     }
[16:22:05.839]     ...future.result <- base::tryCatch({
[16:22:05.839]         base::withCallingHandlers({
[16:22:05.839]             ...future.value <- base::withVisible(base::local({
[16:22:05.839]                 ...future.makeSendCondition <- base::local({
[16:22:05.839]                   sendCondition <- NULL
[16:22:05.839]                   function(frame = 1L) {
[16:22:05.839]                     if (is.function(sendCondition)) 
[16:22:05.839]                       return(sendCondition)
[16:22:05.839]                     ns <- getNamespace("parallel")
[16:22:05.839]                     if (exists("sendData", mode = "function", 
[16:22:05.839]                       envir = ns)) {
[16:22:05.839]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:05.839]                         envir = ns)
[16:22:05.839]                       envir <- sys.frame(frame)
[16:22:05.839]                       master <- NULL
[16:22:05.839]                       while (!identical(envir, .GlobalEnv) && 
[16:22:05.839]                         !identical(envir, emptyenv())) {
[16:22:05.839]                         if (exists("master", mode = "list", envir = envir, 
[16:22:05.839]                           inherits = FALSE)) {
[16:22:05.839]                           master <- get("master", mode = "list", 
[16:22:05.839]                             envir = envir, inherits = FALSE)
[16:22:05.839]                           if (inherits(master, c("SOCKnode", 
[16:22:05.839]                             "SOCK0node"))) {
[16:22:05.839]                             sendCondition <<- function(cond) {
[16:22:05.839]                               data <- list(type = "VALUE", value = cond, 
[16:22:05.839]                                 success = TRUE)
[16:22:05.839]                               parallel_sendData(master, data)
[16:22:05.839]                             }
[16:22:05.839]                             return(sendCondition)
[16:22:05.839]                           }
[16:22:05.839]                         }
[16:22:05.839]                         frame <- frame + 1L
[16:22:05.839]                         envir <- sys.frame(frame)
[16:22:05.839]                       }
[16:22:05.839]                     }
[16:22:05.839]                     sendCondition <<- function(cond) NULL
[16:22:05.839]                   }
[16:22:05.839]                 })
[16:22:05.839]                 withCallingHandlers({
[16:22:05.839]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:05.839]                 }, immediateCondition = function(cond) {
[16:22:05.839]                   sendCondition <- ...future.makeSendCondition()
[16:22:05.839]                   sendCondition(cond)
[16:22:05.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.839]                   {
[16:22:05.839]                     inherits <- base::inherits
[16:22:05.839]                     invokeRestart <- base::invokeRestart
[16:22:05.839]                     is.null <- base::is.null
[16:22:05.839]                     muffled <- FALSE
[16:22:05.839]                     if (inherits(cond, "message")) {
[16:22:05.839]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:05.839]                       if (muffled) 
[16:22:05.839]                         invokeRestart("muffleMessage")
[16:22:05.839]                     }
[16:22:05.839]                     else if (inherits(cond, "warning")) {
[16:22:05.839]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:05.839]                       if (muffled) 
[16:22:05.839]                         invokeRestart("muffleWarning")
[16:22:05.839]                     }
[16:22:05.839]                     else if (inherits(cond, "condition")) {
[16:22:05.839]                       if (!is.null(pattern)) {
[16:22:05.839]                         computeRestarts <- base::computeRestarts
[16:22:05.839]                         grepl <- base::grepl
[16:22:05.839]                         restarts <- computeRestarts(cond)
[16:22:05.839]                         for (restart in restarts) {
[16:22:05.839]                           name <- restart$name
[16:22:05.839]                           if (is.null(name)) 
[16:22:05.839]                             next
[16:22:05.839]                           if (!grepl(pattern, name)) 
[16:22:05.839]                             next
[16:22:05.839]                           invokeRestart(restart)
[16:22:05.839]                           muffled <- TRUE
[16:22:05.839]                           break
[16:22:05.839]                         }
[16:22:05.839]                       }
[16:22:05.839]                     }
[16:22:05.839]                     invisible(muffled)
[16:22:05.839]                   }
[16:22:05.839]                   muffleCondition(cond)
[16:22:05.839]                 })
[16:22:05.839]             }))
[16:22:05.839]             future::FutureResult(value = ...future.value$value, 
[16:22:05.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.839]                   ...future.rng), globalenv = if (FALSE) 
[16:22:05.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:05.839]                     ...future.globalenv.names))
[16:22:05.839]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:05.839]         }, condition = base::local({
[16:22:05.839]             c <- base::c
[16:22:05.839]             inherits <- base::inherits
[16:22:05.839]             invokeRestart <- base::invokeRestart
[16:22:05.839]             length <- base::length
[16:22:05.839]             list <- base::list
[16:22:05.839]             seq.int <- base::seq.int
[16:22:05.839]             signalCondition <- base::signalCondition
[16:22:05.839]             sys.calls <- base::sys.calls
[16:22:05.839]             `[[` <- base::`[[`
[16:22:05.839]             `+` <- base::`+`
[16:22:05.839]             `<<-` <- base::`<<-`
[16:22:05.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:05.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:05.839]                   3L)]
[16:22:05.839]             }
[16:22:05.839]             function(cond) {
[16:22:05.839]                 is_error <- inherits(cond, "error")
[16:22:05.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:05.839]                   NULL)
[16:22:05.839]                 if (is_error) {
[16:22:05.839]                   sessionInformation <- function() {
[16:22:05.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:05.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:05.839]                       search = base::search(), system = base::Sys.info())
[16:22:05.839]                   }
[16:22:05.839]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:05.839]                     cond$call), session = sessionInformation(), 
[16:22:05.839]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:05.839]                   signalCondition(cond)
[16:22:05.839]                 }
[16:22:05.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:05.839]                 "immediateCondition"))) {
[16:22:05.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:05.839]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:05.839]                   if (TRUE && !signal) {
[16:22:05.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.839]                     {
[16:22:05.839]                       inherits <- base::inherits
[16:22:05.839]                       invokeRestart <- base::invokeRestart
[16:22:05.839]                       is.null <- base::is.null
[16:22:05.839]                       muffled <- FALSE
[16:22:05.839]                       if (inherits(cond, "message")) {
[16:22:05.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.839]                         if (muffled) 
[16:22:05.839]                           invokeRestart("muffleMessage")
[16:22:05.839]                       }
[16:22:05.839]                       else if (inherits(cond, "warning")) {
[16:22:05.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.839]                         if (muffled) 
[16:22:05.839]                           invokeRestart("muffleWarning")
[16:22:05.839]                       }
[16:22:05.839]                       else if (inherits(cond, "condition")) {
[16:22:05.839]                         if (!is.null(pattern)) {
[16:22:05.839]                           computeRestarts <- base::computeRestarts
[16:22:05.839]                           grepl <- base::grepl
[16:22:05.839]                           restarts <- computeRestarts(cond)
[16:22:05.839]                           for (restart in restarts) {
[16:22:05.839]                             name <- restart$name
[16:22:05.839]                             if (is.null(name)) 
[16:22:05.839]                               next
[16:22:05.839]                             if (!grepl(pattern, name)) 
[16:22:05.839]                               next
[16:22:05.839]                             invokeRestart(restart)
[16:22:05.839]                             muffled <- TRUE
[16:22:05.839]                             break
[16:22:05.839]                           }
[16:22:05.839]                         }
[16:22:05.839]                       }
[16:22:05.839]                       invisible(muffled)
[16:22:05.839]                     }
[16:22:05.839]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.839]                   }
[16:22:05.839]                 }
[16:22:05.839]                 else {
[16:22:05.839]                   if (TRUE) {
[16:22:05.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.839]                     {
[16:22:05.839]                       inherits <- base::inherits
[16:22:05.839]                       invokeRestart <- base::invokeRestart
[16:22:05.839]                       is.null <- base::is.null
[16:22:05.839]                       muffled <- FALSE
[16:22:05.839]                       if (inherits(cond, "message")) {
[16:22:05.839]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.839]                         if (muffled) 
[16:22:05.839]                           invokeRestart("muffleMessage")
[16:22:05.839]                       }
[16:22:05.839]                       else if (inherits(cond, "warning")) {
[16:22:05.839]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.839]                         if (muffled) 
[16:22:05.839]                           invokeRestart("muffleWarning")
[16:22:05.839]                       }
[16:22:05.839]                       else if (inherits(cond, "condition")) {
[16:22:05.839]                         if (!is.null(pattern)) {
[16:22:05.839]                           computeRestarts <- base::computeRestarts
[16:22:05.839]                           grepl <- base::grepl
[16:22:05.839]                           restarts <- computeRestarts(cond)
[16:22:05.839]                           for (restart in restarts) {
[16:22:05.839]                             name <- restart$name
[16:22:05.839]                             if (is.null(name)) 
[16:22:05.839]                               next
[16:22:05.839]                             if (!grepl(pattern, name)) 
[16:22:05.839]                               next
[16:22:05.839]                             invokeRestart(restart)
[16:22:05.839]                             muffled <- TRUE
[16:22:05.839]                             break
[16:22:05.839]                           }
[16:22:05.839]                         }
[16:22:05.839]                       }
[16:22:05.839]                       invisible(muffled)
[16:22:05.839]                     }
[16:22:05.839]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.839]                   }
[16:22:05.839]                 }
[16:22:05.839]             }
[16:22:05.839]         }))
[16:22:05.839]     }, error = function(ex) {
[16:22:05.839]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:05.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.839]                 ...future.rng), started = ...future.startTime, 
[16:22:05.839]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:05.839]             version = "1.8"), class = "FutureResult")
[16:22:05.839]     }, finally = {
[16:22:05.839]         if (!identical(...future.workdir, getwd())) 
[16:22:05.839]             setwd(...future.workdir)
[16:22:05.839]         {
[16:22:05.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:05.839]                 ...future.oldOptions$nwarnings <- NULL
[16:22:05.839]             }
[16:22:05.839]             base::options(...future.oldOptions)
[16:22:05.839]             if (.Platform$OS.type == "windows") {
[16:22:05.839]                 old_names <- names(...future.oldEnvVars)
[16:22:05.839]                 envs <- base::Sys.getenv()
[16:22:05.839]                 names <- names(envs)
[16:22:05.839]                 common <- intersect(names, old_names)
[16:22:05.839]                 added <- setdiff(names, old_names)
[16:22:05.839]                 removed <- setdiff(old_names, names)
[16:22:05.839]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:05.839]                   envs[common]]
[16:22:05.839]                 NAMES <- toupper(changed)
[16:22:05.839]                 args <- list()
[16:22:05.839]                 for (kk in seq_along(NAMES)) {
[16:22:05.839]                   name <- changed[[kk]]
[16:22:05.839]                   NAME <- NAMES[[kk]]
[16:22:05.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.839]                     next
[16:22:05.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.839]                 }
[16:22:05.839]                 NAMES <- toupper(added)
[16:22:05.839]                 for (kk in seq_along(NAMES)) {
[16:22:05.839]                   name <- added[[kk]]
[16:22:05.839]                   NAME <- NAMES[[kk]]
[16:22:05.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.839]                     next
[16:22:05.839]                   args[[name]] <- ""
[16:22:05.839]                 }
[16:22:05.839]                 NAMES <- toupper(removed)
[16:22:05.839]                 for (kk in seq_along(NAMES)) {
[16:22:05.839]                   name <- removed[[kk]]
[16:22:05.839]                   NAME <- NAMES[[kk]]
[16:22:05.839]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.839]                     next
[16:22:05.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.839]                 }
[16:22:05.839]                 if (length(args) > 0) 
[16:22:05.839]                   base::do.call(base::Sys.setenv, args = args)
[16:22:05.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:05.839]             }
[16:22:05.839]             else {
[16:22:05.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:05.839]             }
[16:22:05.839]             {
[16:22:05.839]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:05.839]                   0L) {
[16:22:05.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:05.839]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:05.839]                   base::options(opts)
[16:22:05.839]                 }
[16:22:05.839]                 {
[16:22:05.839]                   {
[16:22:05.839]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:05.839]                     NULL
[16:22:05.839]                   }
[16:22:05.839]                   options(future.plan = NULL)
[16:22:05.839]                   if (is.na(NA_character_)) 
[16:22:05.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:05.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:05.839]                     .init = FALSE)
[16:22:05.839]                 }
[16:22:05.839]             }
[16:22:05.839]         }
[16:22:05.839]     })
[16:22:05.839]     if (TRUE) {
[16:22:05.839]         base::sink(type = "output", split = FALSE)
[16:22:05.839]         if (TRUE) {
[16:22:05.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:05.839]         }
[16:22:05.839]         else {
[16:22:05.839]             ...future.result["stdout"] <- base::list(NULL)
[16:22:05.839]         }
[16:22:05.839]         base::close(...future.stdout)
[16:22:05.839]         ...future.stdout <- NULL
[16:22:05.839]     }
[16:22:05.839]     ...future.result$conditions <- ...future.conditions
[16:22:05.839]     ...future.result$finished <- base::Sys.time()
[16:22:05.839]     ...future.result
[16:22:05.839] }
[16:22:05.842] MultisessionFuture started
[16:22:05.842] - Launch lazy future ... done
[16:22:05.842] run() for ‘MultisessionFuture’ ... done
[16:22:05.843] receiveMessageFromWorker() for ClusterFuture ...
[16:22:05.843] - Validating connection of MultisessionFuture
[16:22:05.844] - received message: FutureResult
[16:22:05.844] - Received FutureResult
[16:22:05.844] - Erased future from FutureRegistry
[16:22:05.844] result() for ClusterFuture ...
[16:22:05.844] - result already collected: FutureResult
[16:22:05.844] result() for ClusterFuture ... done
[16:22:05.844] signalConditions() ...
[16:22:05.845]  - include = ‘immediateCondition’
[16:22:05.845]  - exclude = 
[16:22:05.845]  - resignal = FALSE
[16:22:05.845]  - Number of conditions: 1
[16:22:05.845] signalConditions() ... done
[16:22:05.845] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:05.845] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[16:22:05.845] getGlobalsAndPackages() ...
[16:22:05.845] Searching for globals...
[16:22:05.846] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:05.846] Searching for globals ... DONE
[16:22:05.847] Resolving globals: FALSE
[16:22:05.847] 
[16:22:05.847] 
[16:22:05.847] getGlobalsAndPackages() ... DONE
[16:22:05.847] run() for ‘Future’ ...
[16:22:05.847] - state: ‘created’
[16:22:05.848] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:05.864] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:05.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:05.864]   - Field: ‘node’
[16:22:05.864]   - Field: ‘label’
[16:22:05.864]   - Field: ‘local’
[16:22:05.864]   - Field: ‘owner’
[16:22:05.865]   - Field: ‘envir’
[16:22:05.865]   - Field: ‘workers’
[16:22:05.865]   - Field: ‘packages’
[16:22:05.865]   - Field: ‘gc’
[16:22:05.865]   - Field: ‘conditions’
[16:22:05.865]   - Field: ‘persistent’
[16:22:05.865]   - Field: ‘expr’
[16:22:05.865]   - Field: ‘uuid’
[16:22:05.865]   - Field: ‘seed’
[16:22:05.865]   - Field: ‘version’
[16:22:05.865]   - Field: ‘result’
[16:22:05.866]   - Field: ‘asynchronous’
[16:22:05.866]   - Field: ‘calls’
[16:22:05.866]   - Field: ‘globals’
[16:22:05.866]   - Field: ‘stdout’
[16:22:05.866]   - Field: ‘earlySignal’
[16:22:05.866]   - Field: ‘lazy’
[16:22:05.866]   - Field: ‘state’
[16:22:05.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:05.866] - Launch lazy future ...
[16:22:05.867] Packages needed by the future expression (n = 0): <none>
[16:22:05.867] Packages needed by future strategies (n = 0): <none>
[16:22:05.867] {
[16:22:05.867]     {
[16:22:05.867]         {
[16:22:05.867]             ...future.startTime <- base::Sys.time()
[16:22:05.867]             {
[16:22:05.867]                 {
[16:22:05.867]                   {
[16:22:05.867]                     {
[16:22:05.867]                       base::local({
[16:22:05.867]                         has_future <- base::requireNamespace("future", 
[16:22:05.867]                           quietly = TRUE)
[16:22:05.867]                         if (has_future) {
[16:22:05.867]                           ns <- base::getNamespace("future")
[16:22:05.867]                           version <- ns[[".package"]][["version"]]
[16:22:05.867]                           if (is.null(version)) 
[16:22:05.867]                             version <- utils::packageVersion("future")
[16:22:05.867]                         }
[16:22:05.867]                         else {
[16:22:05.867]                           version <- NULL
[16:22:05.867]                         }
[16:22:05.867]                         if (!has_future || version < "1.8.0") {
[16:22:05.867]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:05.867]                             "", base::R.version$version.string), 
[16:22:05.867]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:05.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:05.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:05.867]                               "release", "version")], collapse = " "), 
[16:22:05.867]                             hostname = base::Sys.info()[["nodename"]])
[16:22:05.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:05.867]                             info)
[16:22:05.867]                           info <- base::paste(info, collapse = "; ")
[16:22:05.867]                           if (!has_future) {
[16:22:05.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:05.867]                               info)
[16:22:05.867]                           }
[16:22:05.867]                           else {
[16:22:05.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:05.867]                               info, version)
[16:22:05.867]                           }
[16:22:05.867]                           base::stop(msg)
[16:22:05.867]                         }
[16:22:05.867]                       })
[16:22:05.867]                     }
[16:22:05.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:05.867]                     base::options(mc.cores = 1L)
[16:22:05.867]                   }
[16:22:05.867]                   ...future.strategy.old <- future::plan("list")
[16:22:05.867]                   options(future.plan = NULL)
[16:22:05.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:05.867]                 }
[16:22:05.867]                 ...future.workdir <- getwd()
[16:22:05.867]             }
[16:22:05.867]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:05.867]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:05.867]         }
[16:22:05.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:05.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:05.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:05.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:05.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:05.867]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:05.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:05.867]             base::names(...future.oldOptions))
[16:22:05.867]     }
[16:22:05.867]     if (FALSE) {
[16:22:05.867]     }
[16:22:05.867]     else {
[16:22:05.867]         if (TRUE) {
[16:22:05.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:05.867]                 open = "w")
[16:22:05.867]         }
[16:22:05.867]         else {
[16:22:05.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:05.867]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:05.867]         }
[16:22:05.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:05.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:05.867]             base::sink(type = "output", split = FALSE)
[16:22:05.867]             base::close(...future.stdout)
[16:22:05.867]         }, add = TRUE)
[16:22:05.867]     }
[16:22:05.867]     ...future.frame <- base::sys.nframe()
[16:22:05.867]     ...future.conditions <- base::list()
[16:22:05.867]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:05.867]     if (FALSE) {
[16:22:05.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:05.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:05.867]     }
[16:22:05.867]     ...future.result <- base::tryCatch({
[16:22:05.867]         base::withCallingHandlers({
[16:22:05.867]             ...future.value <- base::withVisible(base::local({
[16:22:05.867]                 ...future.makeSendCondition <- base::local({
[16:22:05.867]                   sendCondition <- NULL
[16:22:05.867]                   function(frame = 1L) {
[16:22:05.867]                     if (is.function(sendCondition)) 
[16:22:05.867]                       return(sendCondition)
[16:22:05.867]                     ns <- getNamespace("parallel")
[16:22:05.867]                     if (exists("sendData", mode = "function", 
[16:22:05.867]                       envir = ns)) {
[16:22:05.867]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:05.867]                         envir = ns)
[16:22:05.867]                       envir <- sys.frame(frame)
[16:22:05.867]                       master <- NULL
[16:22:05.867]                       while (!identical(envir, .GlobalEnv) && 
[16:22:05.867]                         !identical(envir, emptyenv())) {
[16:22:05.867]                         if (exists("master", mode = "list", envir = envir, 
[16:22:05.867]                           inherits = FALSE)) {
[16:22:05.867]                           master <- get("master", mode = "list", 
[16:22:05.867]                             envir = envir, inherits = FALSE)
[16:22:05.867]                           if (inherits(master, c("SOCKnode", 
[16:22:05.867]                             "SOCK0node"))) {
[16:22:05.867]                             sendCondition <<- function(cond) {
[16:22:05.867]                               data <- list(type = "VALUE", value = cond, 
[16:22:05.867]                                 success = TRUE)
[16:22:05.867]                               parallel_sendData(master, data)
[16:22:05.867]                             }
[16:22:05.867]                             return(sendCondition)
[16:22:05.867]                           }
[16:22:05.867]                         }
[16:22:05.867]                         frame <- frame + 1L
[16:22:05.867]                         envir <- sys.frame(frame)
[16:22:05.867]                       }
[16:22:05.867]                     }
[16:22:05.867]                     sendCondition <<- function(cond) NULL
[16:22:05.867]                   }
[16:22:05.867]                 })
[16:22:05.867]                 withCallingHandlers({
[16:22:05.867]                   {
[16:22:05.867]                     Sys.sleep(0.5)
[16:22:05.867]                     list(a = 1, b = 42L)
[16:22:05.867]                   }
[16:22:05.867]                 }, immediateCondition = function(cond) {
[16:22:05.867]                   sendCondition <- ...future.makeSendCondition()
[16:22:05.867]                   sendCondition(cond)
[16:22:05.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.867]                   {
[16:22:05.867]                     inherits <- base::inherits
[16:22:05.867]                     invokeRestart <- base::invokeRestart
[16:22:05.867]                     is.null <- base::is.null
[16:22:05.867]                     muffled <- FALSE
[16:22:05.867]                     if (inherits(cond, "message")) {
[16:22:05.867]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:05.867]                       if (muffled) 
[16:22:05.867]                         invokeRestart("muffleMessage")
[16:22:05.867]                     }
[16:22:05.867]                     else if (inherits(cond, "warning")) {
[16:22:05.867]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:05.867]                       if (muffled) 
[16:22:05.867]                         invokeRestart("muffleWarning")
[16:22:05.867]                     }
[16:22:05.867]                     else if (inherits(cond, "condition")) {
[16:22:05.867]                       if (!is.null(pattern)) {
[16:22:05.867]                         computeRestarts <- base::computeRestarts
[16:22:05.867]                         grepl <- base::grepl
[16:22:05.867]                         restarts <- computeRestarts(cond)
[16:22:05.867]                         for (restart in restarts) {
[16:22:05.867]                           name <- restart$name
[16:22:05.867]                           if (is.null(name)) 
[16:22:05.867]                             next
[16:22:05.867]                           if (!grepl(pattern, name)) 
[16:22:05.867]                             next
[16:22:05.867]                           invokeRestart(restart)
[16:22:05.867]                           muffled <- TRUE
[16:22:05.867]                           break
[16:22:05.867]                         }
[16:22:05.867]                       }
[16:22:05.867]                     }
[16:22:05.867]                     invisible(muffled)
[16:22:05.867]                   }
[16:22:05.867]                   muffleCondition(cond)
[16:22:05.867]                 })
[16:22:05.867]             }))
[16:22:05.867]             future::FutureResult(value = ...future.value$value, 
[16:22:05.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.867]                   ...future.rng), globalenv = if (FALSE) 
[16:22:05.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:05.867]                     ...future.globalenv.names))
[16:22:05.867]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:05.867]         }, condition = base::local({
[16:22:05.867]             c <- base::c
[16:22:05.867]             inherits <- base::inherits
[16:22:05.867]             invokeRestart <- base::invokeRestart
[16:22:05.867]             length <- base::length
[16:22:05.867]             list <- base::list
[16:22:05.867]             seq.int <- base::seq.int
[16:22:05.867]             signalCondition <- base::signalCondition
[16:22:05.867]             sys.calls <- base::sys.calls
[16:22:05.867]             `[[` <- base::`[[`
[16:22:05.867]             `+` <- base::`+`
[16:22:05.867]             `<<-` <- base::`<<-`
[16:22:05.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:05.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:05.867]                   3L)]
[16:22:05.867]             }
[16:22:05.867]             function(cond) {
[16:22:05.867]                 is_error <- inherits(cond, "error")
[16:22:05.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:05.867]                   NULL)
[16:22:05.867]                 if (is_error) {
[16:22:05.867]                   sessionInformation <- function() {
[16:22:05.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:05.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:05.867]                       search = base::search(), system = base::Sys.info())
[16:22:05.867]                   }
[16:22:05.867]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:05.867]                     cond$call), session = sessionInformation(), 
[16:22:05.867]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:05.867]                   signalCondition(cond)
[16:22:05.867]                 }
[16:22:05.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:05.867]                 "immediateCondition"))) {
[16:22:05.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:05.867]                   ...future.conditions[[length(...future.conditions) + 
[16:22:05.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:05.867]                   if (TRUE && !signal) {
[16:22:05.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.867]                     {
[16:22:05.867]                       inherits <- base::inherits
[16:22:05.867]                       invokeRestart <- base::invokeRestart
[16:22:05.867]                       is.null <- base::is.null
[16:22:05.867]                       muffled <- FALSE
[16:22:05.867]                       if (inherits(cond, "message")) {
[16:22:05.867]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.867]                         if (muffled) 
[16:22:05.867]                           invokeRestart("muffleMessage")
[16:22:05.867]                       }
[16:22:05.867]                       else if (inherits(cond, "warning")) {
[16:22:05.867]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.867]                         if (muffled) 
[16:22:05.867]                           invokeRestart("muffleWarning")
[16:22:05.867]                       }
[16:22:05.867]                       else if (inherits(cond, "condition")) {
[16:22:05.867]                         if (!is.null(pattern)) {
[16:22:05.867]                           computeRestarts <- base::computeRestarts
[16:22:05.867]                           grepl <- base::grepl
[16:22:05.867]                           restarts <- computeRestarts(cond)
[16:22:05.867]                           for (restart in restarts) {
[16:22:05.867]                             name <- restart$name
[16:22:05.867]                             if (is.null(name)) 
[16:22:05.867]                               next
[16:22:05.867]                             if (!grepl(pattern, name)) 
[16:22:05.867]                               next
[16:22:05.867]                             invokeRestart(restart)
[16:22:05.867]                             muffled <- TRUE
[16:22:05.867]                             break
[16:22:05.867]                           }
[16:22:05.867]                         }
[16:22:05.867]                       }
[16:22:05.867]                       invisible(muffled)
[16:22:05.867]                     }
[16:22:05.867]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.867]                   }
[16:22:05.867]                 }
[16:22:05.867]                 else {
[16:22:05.867]                   if (TRUE) {
[16:22:05.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:05.867]                     {
[16:22:05.867]                       inherits <- base::inherits
[16:22:05.867]                       invokeRestart <- base::invokeRestart
[16:22:05.867]                       is.null <- base::is.null
[16:22:05.867]                       muffled <- FALSE
[16:22:05.867]                       if (inherits(cond, "message")) {
[16:22:05.867]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:05.867]                         if (muffled) 
[16:22:05.867]                           invokeRestart("muffleMessage")
[16:22:05.867]                       }
[16:22:05.867]                       else if (inherits(cond, "warning")) {
[16:22:05.867]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:05.867]                         if (muffled) 
[16:22:05.867]                           invokeRestart("muffleWarning")
[16:22:05.867]                       }
[16:22:05.867]                       else if (inherits(cond, "condition")) {
[16:22:05.867]                         if (!is.null(pattern)) {
[16:22:05.867]                           computeRestarts <- base::computeRestarts
[16:22:05.867]                           grepl <- base::grepl
[16:22:05.867]                           restarts <- computeRestarts(cond)
[16:22:05.867]                           for (restart in restarts) {
[16:22:05.867]                             name <- restart$name
[16:22:05.867]                             if (is.null(name)) 
[16:22:05.867]                               next
[16:22:05.867]                             if (!grepl(pattern, name)) 
[16:22:05.867]                               next
[16:22:05.867]                             invokeRestart(restart)
[16:22:05.867]                             muffled <- TRUE
[16:22:05.867]                             break
[16:22:05.867]                           }
[16:22:05.867]                         }
[16:22:05.867]                       }
[16:22:05.867]                       invisible(muffled)
[16:22:05.867]                     }
[16:22:05.867]                     muffleCondition(cond, pattern = "^muffle")
[16:22:05.867]                   }
[16:22:05.867]                 }
[16:22:05.867]             }
[16:22:05.867]         }))
[16:22:05.867]     }, error = function(ex) {
[16:22:05.867]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:05.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:05.867]                 ...future.rng), started = ...future.startTime, 
[16:22:05.867]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:05.867]             version = "1.8"), class = "FutureResult")
[16:22:05.867]     }, finally = {
[16:22:05.867]         if (!identical(...future.workdir, getwd())) 
[16:22:05.867]             setwd(...future.workdir)
[16:22:05.867]         {
[16:22:05.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:05.867]                 ...future.oldOptions$nwarnings <- NULL
[16:22:05.867]             }
[16:22:05.867]             base::options(...future.oldOptions)
[16:22:05.867]             if (.Platform$OS.type == "windows") {
[16:22:05.867]                 old_names <- names(...future.oldEnvVars)
[16:22:05.867]                 envs <- base::Sys.getenv()
[16:22:05.867]                 names <- names(envs)
[16:22:05.867]                 common <- intersect(names, old_names)
[16:22:05.867]                 added <- setdiff(names, old_names)
[16:22:05.867]                 removed <- setdiff(old_names, names)
[16:22:05.867]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:05.867]                   envs[common]]
[16:22:05.867]                 NAMES <- toupper(changed)
[16:22:05.867]                 args <- list()
[16:22:05.867]                 for (kk in seq_along(NAMES)) {
[16:22:05.867]                   name <- changed[[kk]]
[16:22:05.867]                   NAME <- NAMES[[kk]]
[16:22:05.867]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.867]                     next
[16:22:05.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.867]                 }
[16:22:05.867]                 NAMES <- toupper(added)
[16:22:05.867]                 for (kk in seq_along(NAMES)) {
[16:22:05.867]                   name <- added[[kk]]
[16:22:05.867]                   NAME <- NAMES[[kk]]
[16:22:05.867]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.867]                     next
[16:22:05.867]                   args[[name]] <- ""
[16:22:05.867]                 }
[16:22:05.867]                 NAMES <- toupper(removed)
[16:22:05.867]                 for (kk in seq_along(NAMES)) {
[16:22:05.867]                   name <- removed[[kk]]
[16:22:05.867]                   NAME <- NAMES[[kk]]
[16:22:05.867]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:05.867]                     next
[16:22:05.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:05.867]                 }
[16:22:05.867]                 if (length(args) > 0) 
[16:22:05.867]                   base::do.call(base::Sys.setenv, args = args)
[16:22:05.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:05.867]             }
[16:22:05.867]             else {
[16:22:05.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:05.867]             }
[16:22:05.867]             {
[16:22:05.867]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:05.867]                   0L) {
[16:22:05.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:05.867]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:05.867]                   base::options(opts)
[16:22:05.867]                 }
[16:22:05.867]                 {
[16:22:05.867]                   {
[16:22:05.867]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:05.867]                     NULL
[16:22:05.867]                   }
[16:22:05.867]                   options(future.plan = NULL)
[16:22:05.867]                   if (is.na(NA_character_)) 
[16:22:05.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:05.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:05.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:05.867]                     .init = FALSE)
[16:22:05.867]                 }
[16:22:05.867]             }
[16:22:05.867]         }
[16:22:05.867]     })
[16:22:05.867]     if (TRUE) {
[16:22:05.867]         base::sink(type = "output", split = FALSE)
[16:22:05.867]         if (TRUE) {
[16:22:05.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:05.867]         }
[16:22:05.867]         else {
[16:22:05.867]             ...future.result["stdout"] <- base::list(NULL)
[16:22:05.867]         }
[16:22:05.867]         base::close(...future.stdout)
[16:22:05.867]         ...future.stdout <- NULL
[16:22:05.867]     }
[16:22:05.867]     ...future.result$conditions <- ...future.conditions
[16:22:05.867]     ...future.result$finished <- base::Sys.time()
[16:22:05.867]     ...future.result
[16:22:05.867] }
[16:22:05.870] MultisessionFuture started
[16:22:05.870] - Launch lazy future ... done
[16:22:05.870] run() for ‘MultisessionFuture’ ... done
[16:22:06.372] receiveMessageFromWorker() for ClusterFuture ...
[16:22:06.372] - Validating connection of MultisessionFuture
[16:22:06.373] - received message: FutureResult
[16:22:06.373] - Received FutureResult
[16:22:06.373] - Erased future from FutureRegistry
[16:22:06.373] result() for ClusterFuture ...
[16:22:06.373] - result already collected: FutureResult
[16:22:06.373] result() for ClusterFuture ... done
[16:22:06.373] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:06.374] resolve() on list ...
[16:22:06.374]  recursive: 1
[16:22:06.374]  length: 2
[16:22:06.374]  elements: ‘a’, ‘b’
[16:22:06.374]  length: 1 (resolved future 1)
[16:22:06.374]  length: 0 (resolved future 2)
[16:22:06.374] resolve() on list ... DONE
[16:22:06.374] A MultisessionFuture was resolved (and resolved itself)
[16:22:06.374] getGlobalsAndPackages() ...
[16:22:06.374] Searching for globals...
[16:22:06.376] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:06.376] Searching for globals ... DONE
[16:22:06.376] Resolving globals: FALSE
[16:22:06.376] 
[16:22:06.376] 
[16:22:06.376] getGlobalsAndPackages() ... DONE
[16:22:06.377] run() for ‘Future’ ...
[16:22:06.377] - state: ‘created’
[16:22:06.377] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:06.391] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:06.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:06.391]   - Field: ‘node’
[16:22:06.391]   - Field: ‘label’
[16:22:06.391]   - Field: ‘local’
[16:22:06.391]   - Field: ‘owner’
[16:22:06.391]   - Field: ‘envir’
[16:22:06.392]   - Field: ‘workers’
[16:22:06.392]   - Field: ‘packages’
[16:22:06.392]   - Field: ‘gc’
[16:22:06.392]   - Field: ‘conditions’
[16:22:06.392]   - Field: ‘persistent’
[16:22:06.392]   - Field: ‘expr’
[16:22:06.392]   - Field: ‘uuid’
[16:22:06.392]   - Field: ‘seed’
[16:22:06.392]   - Field: ‘version’
[16:22:06.392]   - Field: ‘result’
[16:22:06.393]   - Field: ‘asynchronous’
[16:22:06.393]   - Field: ‘calls’
[16:22:06.393]   - Field: ‘globals’
[16:22:06.393]   - Field: ‘stdout’
[16:22:06.393]   - Field: ‘earlySignal’
[16:22:06.393]   - Field: ‘lazy’
[16:22:06.393]   - Field: ‘state’
[16:22:06.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:06.393] - Launch lazy future ...
[16:22:06.394] Packages needed by the future expression (n = 0): <none>
[16:22:06.394] Packages needed by future strategies (n = 0): <none>
[16:22:06.394] {
[16:22:06.394]     {
[16:22:06.394]         {
[16:22:06.394]             ...future.startTime <- base::Sys.time()
[16:22:06.394]             {
[16:22:06.394]                 {
[16:22:06.394]                   {
[16:22:06.394]                     {
[16:22:06.394]                       base::local({
[16:22:06.394]                         has_future <- base::requireNamespace("future", 
[16:22:06.394]                           quietly = TRUE)
[16:22:06.394]                         if (has_future) {
[16:22:06.394]                           ns <- base::getNamespace("future")
[16:22:06.394]                           version <- ns[[".package"]][["version"]]
[16:22:06.394]                           if (is.null(version)) 
[16:22:06.394]                             version <- utils::packageVersion("future")
[16:22:06.394]                         }
[16:22:06.394]                         else {
[16:22:06.394]                           version <- NULL
[16:22:06.394]                         }
[16:22:06.394]                         if (!has_future || version < "1.8.0") {
[16:22:06.394]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:06.394]                             "", base::R.version$version.string), 
[16:22:06.394]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:06.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:06.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:06.394]                               "release", "version")], collapse = " "), 
[16:22:06.394]                             hostname = base::Sys.info()[["nodename"]])
[16:22:06.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:06.394]                             info)
[16:22:06.394]                           info <- base::paste(info, collapse = "; ")
[16:22:06.394]                           if (!has_future) {
[16:22:06.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:06.394]                               info)
[16:22:06.394]                           }
[16:22:06.394]                           else {
[16:22:06.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:06.394]                               info, version)
[16:22:06.394]                           }
[16:22:06.394]                           base::stop(msg)
[16:22:06.394]                         }
[16:22:06.394]                       })
[16:22:06.394]                     }
[16:22:06.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:06.394]                     base::options(mc.cores = 1L)
[16:22:06.394]                   }
[16:22:06.394]                   ...future.strategy.old <- future::plan("list")
[16:22:06.394]                   options(future.plan = NULL)
[16:22:06.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:06.394]                 }
[16:22:06.394]                 ...future.workdir <- getwd()
[16:22:06.394]             }
[16:22:06.394]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:06.394]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:06.394]         }
[16:22:06.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:06.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:06.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:06.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:06.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:06.394]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:06.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:06.394]             base::names(...future.oldOptions))
[16:22:06.394]     }
[16:22:06.394]     if (FALSE) {
[16:22:06.394]     }
[16:22:06.394]     else {
[16:22:06.394]         if (TRUE) {
[16:22:06.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:06.394]                 open = "w")
[16:22:06.394]         }
[16:22:06.394]         else {
[16:22:06.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:06.394]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:06.394]         }
[16:22:06.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:06.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:06.394]             base::sink(type = "output", split = FALSE)
[16:22:06.394]             base::close(...future.stdout)
[16:22:06.394]         }, add = TRUE)
[16:22:06.394]     }
[16:22:06.394]     ...future.frame <- base::sys.nframe()
[16:22:06.394]     ...future.conditions <- base::list()
[16:22:06.394]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:06.394]     if (FALSE) {
[16:22:06.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:06.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:06.394]     }
[16:22:06.394]     ...future.result <- base::tryCatch({
[16:22:06.394]         base::withCallingHandlers({
[16:22:06.394]             ...future.value <- base::withVisible(base::local({
[16:22:06.394]                 ...future.makeSendCondition <- base::local({
[16:22:06.394]                   sendCondition <- NULL
[16:22:06.394]                   function(frame = 1L) {
[16:22:06.394]                     if (is.function(sendCondition)) 
[16:22:06.394]                       return(sendCondition)
[16:22:06.394]                     ns <- getNamespace("parallel")
[16:22:06.394]                     if (exists("sendData", mode = "function", 
[16:22:06.394]                       envir = ns)) {
[16:22:06.394]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:06.394]                         envir = ns)
[16:22:06.394]                       envir <- sys.frame(frame)
[16:22:06.394]                       master <- NULL
[16:22:06.394]                       while (!identical(envir, .GlobalEnv) && 
[16:22:06.394]                         !identical(envir, emptyenv())) {
[16:22:06.394]                         if (exists("master", mode = "list", envir = envir, 
[16:22:06.394]                           inherits = FALSE)) {
[16:22:06.394]                           master <- get("master", mode = "list", 
[16:22:06.394]                             envir = envir, inherits = FALSE)
[16:22:06.394]                           if (inherits(master, c("SOCKnode", 
[16:22:06.394]                             "SOCK0node"))) {
[16:22:06.394]                             sendCondition <<- function(cond) {
[16:22:06.394]                               data <- list(type = "VALUE", value = cond, 
[16:22:06.394]                                 success = TRUE)
[16:22:06.394]                               parallel_sendData(master, data)
[16:22:06.394]                             }
[16:22:06.394]                             return(sendCondition)
[16:22:06.394]                           }
[16:22:06.394]                         }
[16:22:06.394]                         frame <- frame + 1L
[16:22:06.394]                         envir <- sys.frame(frame)
[16:22:06.394]                       }
[16:22:06.394]                     }
[16:22:06.394]                     sendCondition <<- function(cond) NULL
[16:22:06.394]                   }
[16:22:06.394]                 })
[16:22:06.394]                 withCallingHandlers({
[16:22:06.394]                   {
[16:22:06.394]                     Sys.sleep(0.5)
[16:22:06.394]                     list(a = 1, b = 42L)
[16:22:06.394]                   }
[16:22:06.394]                 }, immediateCondition = function(cond) {
[16:22:06.394]                   sendCondition <- ...future.makeSendCondition()
[16:22:06.394]                   sendCondition(cond)
[16:22:06.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.394]                   {
[16:22:06.394]                     inherits <- base::inherits
[16:22:06.394]                     invokeRestart <- base::invokeRestart
[16:22:06.394]                     is.null <- base::is.null
[16:22:06.394]                     muffled <- FALSE
[16:22:06.394]                     if (inherits(cond, "message")) {
[16:22:06.394]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:06.394]                       if (muffled) 
[16:22:06.394]                         invokeRestart("muffleMessage")
[16:22:06.394]                     }
[16:22:06.394]                     else if (inherits(cond, "warning")) {
[16:22:06.394]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:06.394]                       if (muffled) 
[16:22:06.394]                         invokeRestart("muffleWarning")
[16:22:06.394]                     }
[16:22:06.394]                     else if (inherits(cond, "condition")) {
[16:22:06.394]                       if (!is.null(pattern)) {
[16:22:06.394]                         computeRestarts <- base::computeRestarts
[16:22:06.394]                         grepl <- base::grepl
[16:22:06.394]                         restarts <- computeRestarts(cond)
[16:22:06.394]                         for (restart in restarts) {
[16:22:06.394]                           name <- restart$name
[16:22:06.394]                           if (is.null(name)) 
[16:22:06.394]                             next
[16:22:06.394]                           if (!grepl(pattern, name)) 
[16:22:06.394]                             next
[16:22:06.394]                           invokeRestart(restart)
[16:22:06.394]                           muffled <- TRUE
[16:22:06.394]                           break
[16:22:06.394]                         }
[16:22:06.394]                       }
[16:22:06.394]                     }
[16:22:06.394]                     invisible(muffled)
[16:22:06.394]                   }
[16:22:06.394]                   muffleCondition(cond)
[16:22:06.394]                 })
[16:22:06.394]             }))
[16:22:06.394]             future::FutureResult(value = ...future.value$value, 
[16:22:06.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.394]                   ...future.rng), globalenv = if (FALSE) 
[16:22:06.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:06.394]                     ...future.globalenv.names))
[16:22:06.394]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:06.394]         }, condition = base::local({
[16:22:06.394]             c <- base::c
[16:22:06.394]             inherits <- base::inherits
[16:22:06.394]             invokeRestart <- base::invokeRestart
[16:22:06.394]             length <- base::length
[16:22:06.394]             list <- base::list
[16:22:06.394]             seq.int <- base::seq.int
[16:22:06.394]             signalCondition <- base::signalCondition
[16:22:06.394]             sys.calls <- base::sys.calls
[16:22:06.394]             `[[` <- base::`[[`
[16:22:06.394]             `+` <- base::`+`
[16:22:06.394]             `<<-` <- base::`<<-`
[16:22:06.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:06.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:06.394]                   3L)]
[16:22:06.394]             }
[16:22:06.394]             function(cond) {
[16:22:06.394]                 is_error <- inherits(cond, "error")
[16:22:06.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:06.394]                   NULL)
[16:22:06.394]                 if (is_error) {
[16:22:06.394]                   sessionInformation <- function() {
[16:22:06.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:06.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:06.394]                       search = base::search(), system = base::Sys.info())
[16:22:06.394]                   }
[16:22:06.394]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:06.394]                     cond$call), session = sessionInformation(), 
[16:22:06.394]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:06.394]                   signalCondition(cond)
[16:22:06.394]                 }
[16:22:06.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:06.394]                 "immediateCondition"))) {
[16:22:06.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:06.394]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:06.394]                   if (TRUE && !signal) {
[16:22:06.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.394]                     {
[16:22:06.394]                       inherits <- base::inherits
[16:22:06.394]                       invokeRestart <- base::invokeRestart
[16:22:06.394]                       is.null <- base::is.null
[16:22:06.394]                       muffled <- FALSE
[16:22:06.394]                       if (inherits(cond, "message")) {
[16:22:06.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.394]                         if (muffled) 
[16:22:06.394]                           invokeRestart("muffleMessage")
[16:22:06.394]                       }
[16:22:06.394]                       else if (inherits(cond, "warning")) {
[16:22:06.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.394]                         if (muffled) 
[16:22:06.394]                           invokeRestart("muffleWarning")
[16:22:06.394]                       }
[16:22:06.394]                       else if (inherits(cond, "condition")) {
[16:22:06.394]                         if (!is.null(pattern)) {
[16:22:06.394]                           computeRestarts <- base::computeRestarts
[16:22:06.394]                           grepl <- base::grepl
[16:22:06.394]                           restarts <- computeRestarts(cond)
[16:22:06.394]                           for (restart in restarts) {
[16:22:06.394]                             name <- restart$name
[16:22:06.394]                             if (is.null(name)) 
[16:22:06.394]                               next
[16:22:06.394]                             if (!grepl(pattern, name)) 
[16:22:06.394]                               next
[16:22:06.394]                             invokeRestart(restart)
[16:22:06.394]                             muffled <- TRUE
[16:22:06.394]                             break
[16:22:06.394]                           }
[16:22:06.394]                         }
[16:22:06.394]                       }
[16:22:06.394]                       invisible(muffled)
[16:22:06.394]                     }
[16:22:06.394]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.394]                   }
[16:22:06.394]                 }
[16:22:06.394]                 else {
[16:22:06.394]                   if (TRUE) {
[16:22:06.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.394]                     {
[16:22:06.394]                       inherits <- base::inherits
[16:22:06.394]                       invokeRestart <- base::invokeRestart
[16:22:06.394]                       is.null <- base::is.null
[16:22:06.394]                       muffled <- FALSE
[16:22:06.394]                       if (inherits(cond, "message")) {
[16:22:06.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.394]                         if (muffled) 
[16:22:06.394]                           invokeRestart("muffleMessage")
[16:22:06.394]                       }
[16:22:06.394]                       else if (inherits(cond, "warning")) {
[16:22:06.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.394]                         if (muffled) 
[16:22:06.394]                           invokeRestart("muffleWarning")
[16:22:06.394]                       }
[16:22:06.394]                       else if (inherits(cond, "condition")) {
[16:22:06.394]                         if (!is.null(pattern)) {
[16:22:06.394]                           computeRestarts <- base::computeRestarts
[16:22:06.394]                           grepl <- base::grepl
[16:22:06.394]                           restarts <- computeRestarts(cond)
[16:22:06.394]                           for (restart in restarts) {
[16:22:06.394]                             name <- restart$name
[16:22:06.394]                             if (is.null(name)) 
[16:22:06.394]                               next
[16:22:06.394]                             if (!grepl(pattern, name)) 
[16:22:06.394]                               next
[16:22:06.394]                             invokeRestart(restart)
[16:22:06.394]                             muffled <- TRUE
[16:22:06.394]                             break
[16:22:06.394]                           }
[16:22:06.394]                         }
[16:22:06.394]                       }
[16:22:06.394]                       invisible(muffled)
[16:22:06.394]                     }
[16:22:06.394]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.394]                   }
[16:22:06.394]                 }
[16:22:06.394]             }
[16:22:06.394]         }))
[16:22:06.394]     }, error = function(ex) {
[16:22:06.394]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:06.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.394]                 ...future.rng), started = ...future.startTime, 
[16:22:06.394]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:06.394]             version = "1.8"), class = "FutureResult")
[16:22:06.394]     }, finally = {
[16:22:06.394]         if (!identical(...future.workdir, getwd())) 
[16:22:06.394]             setwd(...future.workdir)
[16:22:06.394]         {
[16:22:06.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:06.394]                 ...future.oldOptions$nwarnings <- NULL
[16:22:06.394]             }
[16:22:06.394]             base::options(...future.oldOptions)
[16:22:06.394]             if (.Platform$OS.type == "windows") {
[16:22:06.394]                 old_names <- names(...future.oldEnvVars)
[16:22:06.394]                 envs <- base::Sys.getenv()
[16:22:06.394]                 names <- names(envs)
[16:22:06.394]                 common <- intersect(names, old_names)
[16:22:06.394]                 added <- setdiff(names, old_names)
[16:22:06.394]                 removed <- setdiff(old_names, names)
[16:22:06.394]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:06.394]                   envs[common]]
[16:22:06.394]                 NAMES <- toupper(changed)
[16:22:06.394]                 args <- list()
[16:22:06.394]                 for (kk in seq_along(NAMES)) {
[16:22:06.394]                   name <- changed[[kk]]
[16:22:06.394]                   NAME <- NAMES[[kk]]
[16:22:06.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.394]                     next
[16:22:06.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.394]                 }
[16:22:06.394]                 NAMES <- toupper(added)
[16:22:06.394]                 for (kk in seq_along(NAMES)) {
[16:22:06.394]                   name <- added[[kk]]
[16:22:06.394]                   NAME <- NAMES[[kk]]
[16:22:06.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.394]                     next
[16:22:06.394]                   args[[name]] <- ""
[16:22:06.394]                 }
[16:22:06.394]                 NAMES <- toupper(removed)
[16:22:06.394]                 for (kk in seq_along(NAMES)) {
[16:22:06.394]                   name <- removed[[kk]]
[16:22:06.394]                   NAME <- NAMES[[kk]]
[16:22:06.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.394]                     next
[16:22:06.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.394]                 }
[16:22:06.394]                 if (length(args) > 0) 
[16:22:06.394]                   base::do.call(base::Sys.setenv, args = args)
[16:22:06.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:06.394]             }
[16:22:06.394]             else {
[16:22:06.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:06.394]             }
[16:22:06.394]             {
[16:22:06.394]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:06.394]                   0L) {
[16:22:06.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:06.394]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:06.394]                   base::options(opts)
[16:22:06.394]                 }
[16:22:06.394]                 {
[16:22:06.394]                   {
[16:22:06.394]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:06.394]                     NULL
[16:22:06.394]                   }
[16:22:06.394]                   options(future.plan = NULL)
[16:22:06.394]                   if (is.na(NA_character_)) 
[16:22:06.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:06.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:06.394]                     .init = FALSE)
[16:22:06.394]                 }
[16:22:06.394]             }
[16:22:06.394]         }
[16:22:06.394]     })
[16:22:06.394]     if (TRUE) {
[16:22:06.394]         base::sink(type = "output", split = FALSE)
[16:22:06.394]         if (TRUE) {
[16:22:06.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:06.394]         }
[16:22:06.394]         else {
[16:22:06.394]             ...future.result["stdout"] <- base::list(NULL)
[16:22:06.394]         }
[16:22:06.394]         base::close(...future.stdout)
[16:22:06.394]         ...future.stdout <- NULL
[16:22:06.394]     }
[16:22:06.394]     ...future.result$conditions <- ...future.conditions
[16:22:06.394]     ...future.result$finished <- base::Sys.time()
[16:22:06.394]     ...future.result
[16:22:06.394] }
[16:22:06.397] MultisessionFuture started
[16:22:06.397] - Launch lazy future ... done
[16:22:06.397] run() for ‘MultisessionFuture’ ... done
[16:22:06.900] receiveMessageFromWorker() for ClusterFuture ...
[16:22:06.900] - Validating connection of MultisessionFuture
[16:22:06.900] - received message: FutureResult
[16:22:06.901] - Received FutureResult
[16:22:06.901] - Erased future from FutureRegistry
[16:22:06.901] result() for ClusterFuture ...
[16:22:06.901] - result already collected: FutureResult
[16:22:06.901] result() for ClusterFuture ... done
[16:22:06.901] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:06.901] resolve() on list ...
[16:22:06.901]  recursive: 1
[16:22:06.901]  length: 2
[16:22:06.901]  elements: ‘a’, ‘b’
[16:22:06.902]  length: 1 (resolved future 1)
[16:22:06.902]  length: 0 (resolved future 2)
[16:22:06.902] resolve() on list ... DONE
[16:22:06.902] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:22:06.902] getGlobalsAndPackages() ...
[16:22:06.902] Searching for globals...
[16:22:06.903] - globals found: [2] ‘list’, ‘stop’
[16:22:06.903] Searching for globals ... DONE
[16:22:06.903] Resolving globals: FALSE
[16:22:06.903] 
[16:22:06.904] 
[16:22:06.904] getGlobalsAndPackages() ... DONE
[16:22:06.904] run() for ‘Future’ ...
[16:22:06.904] - state: ‘created’
[16:22:06.904] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:06.918] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:06.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:06.919]   - Field: ‘node’
[16:22:06.919]   - Field: ‘label’
[16:22:06.919]   - Field: ‘local’
[16:22:06.919]   - Field: ‘owner’
[16:22:06.919]   - Field: ‘envir’
[16:22:06.919]   - Field: ‘workers’
[16:22:06.919]   - Field: ‘packages’
[16:22:06.919]   - Field: ‘gc’
[16:22:06.919]   - Field: ‘conditions’
[16:22:06.919]   - Field: ‘persistent’
[16:22:06.920]   - Field: ‘expr’
[16:22:06.920]   - Field: ‘uuid’
[16:22:06.920]   - Field: ‘seed’
[16:22:06.920]   - Field: ‘version’
[16:22:06.920]   - Field: ‘result’
[16:22:06.920]   - Field: ‘asynchronous’
[16:22:06.920]   - Field: ‘calls’
[16:22:06.920]   - Field: ‘globals’
[16:22:06.920]   - Field: ‘stdout’
[16:22:06.920]   - Field: ‘earlySignal’
[16:22:06.921]   - Field: ‘lazy’
[16:22:06.921]   - Field: ‘state’
[16:22:06.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:06.921] - Launch lazy future ...
[16:22:06.921] Packages needed by the future expression (n = 0): <none>
[16:22:06.921] Packages needed by future strategies (n = 0): <none>
[16:22:06.922] {
[16:22:06.922]     {
[16:22:06.922]         {
[16:22:06.922]             ...future.startTime <- base::Sys.time()
[16:22:06.922]             {
[16:22:06.922]                 {
[16:22:06.922]                   {
[16:22:06.922]                     {
[16:22:06.922]                       base::local({
[16:22:06.922]                         has_future <- base::requireNamespace("future", 
[16:22:06.922]                           quietly = TRUE)
[16:22:06.922]                         if (has_future) {
[16:22:06.922]                           ns <- base::getNamespace("future")
[16:22:06.922]                           version <- ns[[".package"]][["version"]]
[16:22:06.922]                           if (is.null(version)) 
[16:22:06.922]                             version <- utils::packageVersion("future")
[16:22:06.922]                         }
[16:22:06.922]                         else {
[16:22:06.922]                           version <- NULL
[16:22:06.922]                         }
[16:22:06.922]                         if (!has_future || version < "1.8.0") {
[16:22:06.922]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:06.922]                             "", base::R.version$version.string), 
[16:22:06.922]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:06.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:06.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:06.922]                               "release", "version")], collapse = " "), 
[16:22:06.922]                             hostname = base::Sys.info()[["nodename"]])
[16:22:06.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:06.922]                             info)
[16:22:06.922]                           info <- base::paste(info, collapse = "; ")
[16:22:06.922]                           if (!has_future) {
[16:22:06.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:06.922]                               info)
[16:22:06.922]                           }
[16:22:06.922]                           else {
[16:22:06.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:06.922]                               info, version)
[16:22:06.922]                           }
[16:22:06.922]                           base::stop(msg)
[16:22:06.922]                         }
[16:22:06.922]                       })
[16:22:06.922]                     }
[16:22:06.922]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:06.922]                     base::options(mc.cores = 1L)
[16:22:06.922]                   }
[16:22:06.922]                   ...future.strategy.old <- future::plan("list")
[16:22:06.922]                   options(future.plan = NULL)
[16:22:06.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:06.922]                 }
[16:22:06.922]                 ...future.workdir <- getwd()
[16:22:06.922]             }
[16:22:06.922]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:06.922]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:06.922]         }
[16:22:06.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:06.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:06.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:06.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:06.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:06.922]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:06.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:06.922]             base::names(...future.oldOptions))
[16:22:06.922]     }
[16:22:06.922]     if (FALSE) {
[16:22:06.922]     }
[16:22:06.922]     else {
[16:22:06.922]         if (TRUE) {
[16:22:06.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:06.922]                 open = "w")
[16:22:06.922]         }
[16:22:06.922]         else {
[16:22:06.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:06.922]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:06.922]         }
[16:22:06.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:06.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:06.922]             base::sink(type = "output", split = FALSE)
[16:22:06.922]             base::close(...future.stdout)
[16:22:06.922]         }, add = TRUE)
[16:22:06.922]     }
[16:22:06.922]     ...future.frame <- base::sys.nframe()
[16:22:06.922]     ...future.conditions <- base::list()
[16:22:06.922]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:06.922]     if (FALSE) {
[16:22:06.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:06.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:06.922]     }
[16:22:06.922]     ...future.result <- base::tryCatch({
[16:22:06.922]         base::withCallingHandlers({
[16:22:06.922]             ...future.value <- base::withVisible(base::local({
[16:22:06.922]                 ...future.makeSendCondition <- base::local({
[16:22:06.922]                   sendCondition <- NULL
[16:22:06.922]                   function(frame = 1L) {
[16:22:06.922]                     if (is.function(sendCondition)) 
[16:22:06.922]                       return(sendCondition)
[16:22:06.922]                     ns <- getNamespace("parallel")
[16:22:06.922]                     if (exists("sendData", mode = "function", 
[16:22:06.922]                       envir = ns)) {
[16:22:06.922]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:06.922]                         envir = ns)
[16:22:06.922]                       envir <- sys.frame(frame)
[16:22:06.922]                       master <- NULL
[16:22:06.922]                       while (!identical(envir, .GlobalEnv) && 
[16:22:06.922]                         !identical(envir, emptyenv())) {
[16:22:06.922]                         if (exists("master", mode = "list", envir = envir, 
[16:22:06.922]                           inherits = FALSE)) {
[16:22:06.922]                           master <- get("master", mode = "list", 
[16:22:06.922]                             envir = envir, inherits = FALSE)
[16:22:06.922]                           if (inherits(master, c("SOCKnode", 
[16:22:06.922]                             "SOCK0node"))) {
[16:22:06.922]                             sendCondition <<- function(cond) {
[16:22:06.922]                               data <- list(type = "VALUE", value = cond, 
[16:22:06.922]                                 success = TRUE)
[16:22:06.922]                               parallel_sendData(master, data)
[16:22:06.922]                             }
[16:22:06.922]                             return(sendCondition)
[16:22:06.922]                           }
[16:22:06.922]                         }
[16:22:06.922]                         frame <- frame + 1L
[16:22:06.922]                         envir <- sys.frame(frame)
[16:22:06.922]                       }
[16:22:06.922]                     }
[16:22:06.922]                     sendCondition <<- function(cond) NULL
[16:22:06.922]                   }
[16:22:06.922]                 })
[16:22:06.922]                 withCallingHandlers({
[16:22:06.922]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:06.922]                 }, immediateCondition = function(cond) {
[16:22:06.922]                   sendCondition <- ...future.makeSendCondition()
[16:22:06.922]                   sendCondition(cond)
[16:22:06.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.922]                   {
[16:22:06.922]                     inherits <- base::inherits
[16:22:06.922]                     invokeRestart <- base::invokeRestart
[16:22:06.922]                     is.null <- base::is.null
[16:22:06.922]                     muffled <- FALSE
[16:22:06.922]                     if (inherits(cond, "message")) {
[16:22:06.922]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:06.922]                       if (muffled) 
[16:22:06.922]                         invokeRestart("muffleMessage")
[16:22:06.922]                     }
[16:22:06.922]                     else if (inherits(cond, "warning")) {
[16:22:06.922]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:06.922]                       if (muffled) 
[16:22:06.922]                         invokeRestart("muffleWarning")
[16:22:06.922]                     }
[16:22:06.922]                     else if (inherits(cond, "condition")) {
[16:22:06.922]                       if (!is.null(pattern)) {
[16:22:06.922]                         computeRestarts <- base::computeRestarts
[16:22:06.922]                         grepl <- base::grepl
[16:22:06.922]                         restarts <- computeRestarts(cond)
[16:22:06.922]                         for (restart in restarts) {
[16:22:06.922]                           name <- restart$name
[16:22:06.922]                           if (is.null(name)) 
[16:22:06.922]                             next
[16:22:06.922]                           if (!grepl(pattern, name)) 
[16:22:06.922]                             next
[16:22:06.922]                           invokeRestart(restart)
[16:22:06.922]                           muffled <- TRUE
[16:22:06.922]                           break
[16:22:06.922]                         }
[16:22:06.922]                       }
[16:22:06.922]                     }
[16:22:06.922]                     invisible(muffled)
[16:22:06.922]                   }
[16:22:06.922]                   muffleCondition(cond)
[16:22:06.922]                 })
[16:22:06.922]             }))
[16:22:06.922]             future::FutureResult(value = ...future.value$value, 
[16:22:06.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.922]                   ...future.rng), globalenv = if (FALSE) 
[16:22:06.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:06.922]                     ...future.globalenv.names))
[16:22:06.922]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:06.922]         }, condition = base::local({
[16:22:06.922]             c <- base::c
[16:22:06.922]             inherits <- base::inherits
[16:22:06.922]             invokeRestart <- base::invokeRestart
[16:22:06.922]             length <- base::length
[16:22:06.922]             list <- base::list
[16:22:06.922]             seq.int <- base::seq.int
[16:22:06.922]             signalCondition <- base::signalCondition
[16:22:06.922]             sys.calls <- base::sys.calls
[16:22:06.922]             `[[` <- base::`[[`
[16:22:06.922]             `+` <- base::`+`
[16:22:06.922]             `<<-` <- base::`<<-`
[16:22:06.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:06.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:06.922]                   3L)]
[16:22:06.922]             }
[16:22:06.922]             function(cond) {
[16:22:06.922]                 is_error <- inherits(cond, "error")
[16:22:06.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:06.922]                   NULL)
[16:22:06.922]                 if (is_error) {
[16:22:06.922]                   sessionInformation <- function() {
[16:22:06.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:06.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:06.922]                       search = base::search(), system = base::Sys.info())
[16:22:06.922]                   }
[16:22:06.922]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:06.922]                     cond$call), session = sessionInformation(), 
[16:22:06.922]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:06.922]                   signalCondition(cond)
[16:22:06.922]                 }
[16:22:06.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:06.922]                 "immediateCondition"))) {
[16:22:06.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:06.922]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:06.922]                   if (TRUE && !signal) {
[16:22:06.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.922]                     {
[16:22:06.922]                       inherits <- base::inherits
[16:22:06.922]                       invokeRestart <- base::invokeRestart
[16:22:06.922]                       is.null <- base::is.null
[16:22:06.922]                       muffled <- FALSE
[16:22:06.922]                       if (inherits(cond, "message")) {
[16:22:06.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.922]                         if (muffled) 
[16:22:06.922]                           invokeRestart("muffleMessage")
[16:22:06.922]                       }
[16:22:06.922]                       else if (inherits(cond, "warning")) {
[16:22:06.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.922]                         if (muffled) 
[16:22:06.922]                           invokeRestart("muffleWarning")
[16:22:06.922]                       }
[16:22:06.922]                       else if (inherits(cond, "condition")) {
[16:22:06.922]                         if (!is.null(pattern)) {
[16:22:06.922]                           computeRestarts <- base::computeRestarts
[16:22:06.922]                           grepl <- base::grepl
[16:22:06.922]                           restarts <- computeRestarts(cond)
[16:22:06.922]                           for (restart in restarts) {
[16:22:06.922]                             name <- restart$name
[16:22:06.922]                             if (is.null(name)) 
[16:22:06.922]                               next
[16:22:06.922]                             if (!grepl(pattern, name)) 
[16:22:06.922]                               next
[16:22:06.922]                             invokeRestart(restart)
[16:22:06.922]                             muffled <- TRUE
[16:22:06.922]                             break
[16:22:06.922]                           }
[16:22:06.922]                         }
[16:22:06.922]                       }
[16:22:06.922]                       invisible(muffled)
[16:22:06.922]                     }
[16:22:06.922]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.922]                   }
[16:22:06.922]                 }
[16:22:06.922]                 else {
[16:22:06.922]                   if (TRUE) {
[16:22:06.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.922]                     {
[16:22:06.922]                       inherits <- base::inherits
[16:22:06.922]                       invokeRestart <- base::invokeRestart
[16:22:06.922]                       is.null <- base::is.null
[16:22:06.922]                       muffled <- FALSE
[16:22:06.922]                       if (inherits(cond, "message")) {
[16:22:06.922]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.922]                         if (muffled) 
[16:22:06.922]                           invokeRestart("muffleMessage")
[16:22:06.922]                       }
[16:22:06.922]                       else if (inherits(cond, "warning")) {
[16:22:06.922]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.922]                         if (muffled) 
[16:22:06.922]                           invokeRestart("muffleWarning")
[16:22:06.922]                       }
[16:22:06.922]                       else if (inherits(cond, "condition")) {
[16:22:06.922]                         if (!is.null(pattern)) {
[16:22:06.922]                           computeRestarts <- base::computeRestarts
[16:22:06.922]                           grepl <- base::grepl
[16:22:06.922]                           restarts <- computeRestarts(cond)
[16:22:06.922]                           for (restart in restarts) {
[16:22:06.922]                             name <- restart$name
[16:22:06.922]                             if (is.null(name)) 
[16:22:06.922]                               next
[16:22:06.922]                             if (!grepl(pattern, name)) 
[16:22:06.922]                               next
[16:22:06.922]                             invokeRestart(restart)
[16:22:06.922]                             muffled <- TRUE
[16:22:06.922]                             break
[16:22:06.922]                           }
[16:22:06.922]                         }
[16:22:06.922]                       }
[16:22:06.922]                       invisible(muffled)
[16:22:06.922]                     }
[16:22:06.922]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.922]                   }
[16:22:06.922]                 }
[16:22:06.922]             }
[16:22:06.922]         }))
[16:22:06.922]     }, error = function(ex) {
[16:22:06.922]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:06.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.922]                 ...future.rng), started = ...future.startTime, 
[16:22:06.922]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:06.922]             version = "1.8"), class = "FutureResult")
[16:22:06.922]     }, finally = {
[16:22:06.922]         if (!identical(...future.workdir, getwd())) 
[16:22:06.922]             setwd(...future.workdir)
[16:22:06.922]         {
[16:22:06.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:06.922]                 ...future.oldOptions$nwarnings <- NULL
[16:22:06.922]             }
[16:22:06.922]             base::options(...future.oldOptions)
[16:22:06.922]             if (.Platform$OS.type == "windows") {
[16:22:06.922]                 old_names <- names(...future.oldEnvVars)
[16:22:06.922]                 envs <- base::Sys.getenv()
[16:22:06.922]                 names <- names(envs)
[16:22:06.922]                 common <- intersect(names, old_names)
[16:22:06.922]                 added <- setdiff(names, old_names)
[16:22:06.922]                 removed <- setdiff(old_names, names)
[16:22:06.922]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:06.922]                   envs[common]]
[16:22:06.922]                 NAMES <- toupper(changed)
[16:22:06.922]                 args <- list()
[16:22:06.922]                 for (kk in seq_along(NAMES)) {
[16:22:06.922]                   name <- changed[[kk]]
[16:22:06.922]                   NAME <- NAMES[[kk]]
[16:22:06.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.922]                     next
[16:22:06.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.922]                 }
[16:22:06.922]                 NAMES <- toupper(added)
[16:22:06.922]                 for (kk in seq_along(NAMES)) {
[16:22:06.922]                   name <- added[[kk]]
[16:22:06.922]                   NAME <- NAMES[[kk]]
[16:22:06.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.922]                     next
[16:22:06.922]                   args[[name]] <- ""
[16:22:06.922]                 }
[16:22:06.922]                 NAMES <- toupper(removed)
[16:22:06.922]                 for (kk in seq_along(NAMES)) {
[16:22:06.922]                   name <- removed[[kk]]
[16:22:06.922]                   NAME <- NAMES[[kk]]
[16:22:06.922]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.922]                     next
[16:22:06.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.922]                 }
[16:22:06.922]                 if (length(args) > 0) 
[16:22:06.922]                   base::do.call(base::Sys.setenv, args = args)
[16:22:06.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:06.922]             }
[16:22:06.922]             else {
[16:22:06.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:06.922]             }
[16:22:06.922]             {
[16:22:06.922]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:06.922]                   0L) {
[16:22:06.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:06.922]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:06.922]                   base::options(opts)
[16:22:06.922]                 }
[16:22:06.922]                 {
[16:22:06.922]                   {
[16:22:06.922]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:06.922]                     NULL
[16:22:06.922]                   }
[16:22:06.922]                   options(future.plan = NULL)
[16:22:06.922]                   if (is.na(NA_character_)) 
[16:22:06.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:06.922]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:06.922]                     .init = FALSE)
[16:22:06.922]                 }
[16:22:06.922]             }
[16:22:06.922]         }
[16:22:06.922]     })
[16:22:06.922]     if (TRUE) {
[16:22:06.922]         base::sink(type = "output", split = FALSE)
[16:22:06.922]         if (TRUE) {
[16:22:06.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:06.922]         }
[16:22:06.922]         else {
[16:22:06.922]             ...future.result["stdout"] <- base::list(NULL)
[16:22:06.922]         }
[16:22:06.922]         base::close(...future.stdout)
[16:22:06.922]         ...future.stdout <- NULL
[16:22:06.922]     }
[16:22:06.922]     ...future.result$conditions <- ...future.conditions
[16:22:06.922]     ...future.result$finished <- base::Sys.time()
[16:22:06.922]     ...future.result
[16:22:06.922] }
[16:22:06.925] MultisessionFuture started
[16:22:06.925] - Launch lazy future ... done
[16:22:06.925] run() for ‘MultisessionFuture’ ... done
[16:22:06.927] receiveMessageFromWorker() for ClusterFuture ...
[16:22:06.927] - Validating connection of MultisessionFuture
[16:22:06.927] - received message: FutureResult
[16:22:06.928] - Received FutureResult
[16:22:06.928] - Erased future from FutureRegistry
[16:22:06.928] result() for ClusterFuture ...
[16:22:06.928] - result already collected: FutureResult
[16:22:06.928] result() for ClusterFuture ... done
[16:22:06.928] signalConditions() ...
[16:22:06.928]  - include = ‘immediateCondition’
[16:22:06.928]  - exclude = 
[16:22:06.928]  - resignal = FALSE
[16:22:06.928]  - Number of conditions: 1
[16:22:06.929] signalConditions() ... done
[16:22:06.929] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:06.929] A MultisessionFuture was resolved
[16:22:06.929] getGlobalsAndPackages() ...
[16:22:06.929] Searching for globals...
[16:22:06.930] - globals found: [2] ‘list’, ‘stop’
[16:22:06.930] Searching for globals ... DONE
[16:22:06.930] Resolving globals: FALSE
[16:22:06.930] 
[16:22:06.930] 
[16:22:06.930] getGlobalsAndPackages() ... DONE
[16:22:06.933] run() for ‘Future’ ...
[16:22:06.933] - state: ‘created’
[16:22:06.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:06.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:06.952] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:06.952]   - Field: ‘node’
[16:22:06.952]   - Field: ‘label’
[16:22:06.952]   - Field: ‘local’
[16:22:06.952]   - Field: ‘owner’
[16:22:06.952]   - Field: ‘envir’
[16:22:06.952]   - Field: ‘workers’
[16:22:06.952]   - Field: ‘packages’
[16:22:06.952]   - Field: ‘gc’
[16:22:06.952]   - Field: ‘conditions’
[16:22:06.953]   - Field: ‘persistent’
[16:22:06.953]   - Field: ‘expr’
[16:22:06.953]   - Field: ‘uuid’
[16:22:06.953]   - Field: ‘seed’
[16:22:06.953]   - Field: ‘version’
[16:22:06.953]   - Field: ‘result’
[16:22:06.953]   - Field: ‘asynchronous’
[16:22:06.953]   - Field: ‘calls’
[16:22:06.953]   - Field: ‘globals’
[16:22:06.953]   - Field: ‘stdout’
[16:22:06.953]   - Field: ‘earlySignal’
[16:22:06.954]   - Field: ‘lazy’
[16:22:06.954]   - Field: ‘state’
[16:22:06.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:06.954] - Launch lazy future ...
[16:22:06.954] Packages needed by the future expression (n = 0): <none>
[16:22:06.954] Packages needed by future strategies (n = 0): <none>
[16:22:06.955] {
[16:22:06.955]     {
[16:22:06.955]         {
[16:22:06.955]             ...future.startTime <- base::Sys.time()
[16:22:06.955]             {
[16:22:06.955]                 {
[16:22:06.955]                   {
[16:22:06.955]                     {
[16:22:06.955]                       base::local({
[16:22:06.955]                         has_future <- base::requireNamespace("future", 
[16:22:06.955]                           quietly = TRUE)
[16:22:06.955]                         if (has_future) {
[16:22:06.955]                           ns <- base::getNamespace("future")
[16:22:06.955]                           version <- ns[[".package"]][["version"]]
[16:22:06.955]                           if (is.null(version)) 
[16:22:06.955]                             version <- utils::packageVersion("future")
[16:22:06.955]                         }
[16:22:06.955]                         else {
[16:22:06.955]                           version <- NULL
[16:22:06.955]                         }
[16:22:06.955]                         if (!has_future || version < "1.8.0") {
[16:22:06.955]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:06.955]                             "", base::R.version$version.string), 
[16:22:06.955]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:06.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:06.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:06.955]                               "release", "version")], collapse = " "), 
[16:22:06.955]                             hostname = base::Sys.info()[["nodename"]])
[16:22:06.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:06.955]                             info)
[16:22:06.955]                           info <- base::paste(info, collapse = "; ")
[16:22:06.955]                           if (!has_future) {
[16:22:06.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:06.955]                               info)
[16:22:06.955]                           }
[16:22:06.955]                           else {
[16:22:06.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:06.955]                               info, version)
[16:22:06.955]                           }
[16:22:06.955]                           base::stop(msg)
[16:22:06.955]                         }
[16:22:06.955]                       })
[16:22:06.955]                     }
[16:22:06.955]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:06.955]                     base::options(mc.cores = 1L)
[16:22:06.955]                   }
[16:22:06.955]                   ...future.strategy.old <- future::plan("list")
[16:22:06.955]                   options(future.plan = NULL)
[16:22:06.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:06.955]                 }
[16:22:06.955]                 ...future.workdir <- getwd()
[16:22:06.955]             }
[16:22:06.955]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:06.955]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:06.955]         }
[16:22:06.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:06.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:06.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:06.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:06.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:06.955]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:06.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:06.955]             base::names(...future.oldOptions))
[16:22:06.955]     }
[16:22:06.955]     if (FALSE) {
[16:22:06.955]     }
[16:22:06.955]     else {
[16:22:06.955]         if (TRUE) {
[16:22:06.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:06.955]                 open = "w")
[16:22:06.955]         }
[16:22:06.955]         else {
[16:22:06.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:06.955]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:06.955]         }
[16:22:06.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:06.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:06.955]             base::sink(type = "output", split = FALSE)
[16:22:06.955]             base::close(...future.stdout)
[16:22:06.955]         }, add = TRUE)
[16:22:06.955]     }
[16:22:06.955]     ...future.frame <- base::sys.nframe()
[16:22:06.955]     ...future.conditions <- base::list()
[16:22:06.955]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:06.955]     if (FALSE) {
[16:22:06.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:06.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:06.955]     }
[16:22:06.955]     ...future.result <- base::tryCatch({
[16:22:06.955]         base::withCallingHandlers({
[16:22:06.955]             ...future.value <- base::withVisible(base::local({
[16:22:06.955]                 ...future.makeSendCondition <- base::local({
[16:22:06.955]                   sendCondition <- NULL
[16:22:06.955]                   function(frame = 1L) {
[16:22:06.955]                     if (is.function(sendCondition)) 
[16:22:06.955]                       return(sendCondition)
[16:22:06.955]                     ns <- getNamespace("parallel")
[16:22:06.955]                     if (exists("sendData", mode = "function", 
[16:22:06.955]                       envir = ns)) {
[16:22:06.955]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:06.955]                         envir = ns)
[16:22:06.955]                       envir <- sys.frame(frame)
[16:22:06.955]                       master <- NULL
[16:22:06.955]                       while (!identical(envir, .GlobalEnv) && 
[16:22:06.955]                         !identical(envir, emptyenv())) {
[16:22:06.955]                         if (exists("master", mode = "list", envir = envir, 
[16:22:06.955]                           inherits = FALSE)) {
[16:22:06.955]                           master <- get("master", mode = "list", 
[16:22:06.955]                             envir = envir, inherits = FALSE)
[16:22:06.955]                           if (inherits(master, c("SOCKnode", 
[16:22:06.955]                             "SOCK0node"))) {
[16:22:06.955]                             sendCondition <<- function(cond) {
[16:22:06.955]                               data <- list(type = "VALUE", value = cond, 
[16:22:06.955]                                 success = TRUE)
[16:22:06.955]                               parallel_sendData(master, data)
[16:22:06.955]                             }
[16:22:06.955]                             return(sendCondition)
[16:22:06.955]                           }
[16:22:06.955]                         }
[16:22:06.955]                         frame <- frame + 1L
[16:22:06.955]                         envir <- sys.frame(frame)
[16:22:06.955]                       }
[16:22:06.955]                     }
[16:22:06.955]                     sendCondition <<- function(cond) NULL
[16:22:06.955]                   }
[16:22:06.955]                 })
[16:22:06.955]                 withCallingHandlers({
[16:22:06.955]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:06.955]                 }, immediateCondition = function(cond) {
[16:22:06.955]                   sendCondition <- ...future.makeSendCondition()
[16:22:06.955]                   sendCondition(cond)
[16:22:06.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.955]                   {
[16:22:06.955]                     inherits <- base::inherits
[16:22:06.955]                     invokeRestart <- base::invokeRestart
[16:22:06.955]                     is.null <- base::is.null
[16:22:06.955]                     muffled <- FALSE
[16:22:06.955]                     if (inherits(cond, "message")) {
[16:22:06.955]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:06.955]                       if (muffled) 
[16:22:06.955]                         invokeRestart("muffleMessage")
[16:22:06.955]                     }
[16:22:06.955]                     else if (inherits(cond, "warning")) {
[16:22:06.955]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:06.955]                       if (muffled) 
[16:22:06.955]                         invokeRestart("muffleWarning")
[16:22:06.955]                     }
[16:22:06.955]                     else if (inherits(cond, "condition")) {
[16:22:06.955]                       if (!is.null(pattern)) {
[16:22:06.955]                         computeRestarts <- base::computeRestarts
[16:22:06.955]                         grepl <- base::grepl
[16:22:06.955]                         restarts <- computeRestarts(cond)
[16:22:06.955]                         for (restart in restarts) {
[16:22:06.955]                           name <- restart$name
[16:22:06.955]                           if (is.null(name)) 
[16:22:06.955]                             next
[16:22:06.955]                           if (!grepl(pattern, name)) 
[16:22:06.955]                             next
[16:22:06.955]                           invokeRestart(restart)
[16:22:06.955]                           muffled <- TRUE
[16:22:06.955]                           break
[16:22:06.955]                         }
[16:22:06.955]                       }
[16:22:06.955]                     }
[16:22:06.955]                     invisible(muffled)
[16:22:06.955]                   }
[16:22:06.955]                   muffleCondition(cond)
[16:22:06.955]                 })
[16:22:06.955]             }))
[16:22:06.955]             future::FutureResult(value = ...future.value$value, 
[16:22:06.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.955]                   ...future.rng), globalenv = if (FALSE) 
[16:22:06.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:06.955]                     ...future.globalenv.names))
[16:22:06.955]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:06.955]         }, condition = base::local({
[16:22:06.955]             c <- base::c
[16:22:06.955]             inherits <- base::inherits
[16:22:06.955]             invokeRestart <- base::invokeRestart
[16:22:06.955]             length <- base::length
[16:22:06.955]             list <- base::list
[16:22:06.955]             seq.int <- base::seq.int
[16:22:06.955]             signalCondition <- base::signalCondition
[16:22:06.955]             sys.calls <- base::sys.calls
[16:22:06.955]             `[[` <- base::`[[`
[16:22:06.955]             `+` <- base::`+`
[16:22:06.955]             `<<-` <- base::`<<-`
[16:22:06.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:06.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:06.955]                   3L)]
[16:22:06.955]             }
[16:22:06.955]             function(cond) {
[16:22:06.955]                 is_error <- inherits(cond, "error")
[16:22:06.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:06.955]                   NULL)
[16:22:06.955]                 if (is_error) {
[16:22:06.955]                   sessionInformation <- function() {
[16:22:06.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:06.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:06.955]                       search = base::search(), system = base::Sys.info())
[16:22:06.955]                   }
[16:22:06.955]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:06.955]                     cond$call), session = sessionInformation(), 
[16:22:06.955]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:06.955]                   signalCondition(cond)
[16:22:06.955]                 }
[16:22:06.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:06.955]                 "immediateCondition"))) {
[16:22:06.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:06.955]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:06.955]                   if (TRUE && !signal) {
[16:22:06.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.955]                     {
[16:22:06.955]                       inherits <- base::inherits
[16:22:06.955]                       invokeRestart <- base::invokeRestart
[16:22:06.955]                       is.null <- base::is.null
[16:22:06.955]                       muffled <- FALSE
[16:22:06.955]                       if (inherits(cond, "message")) {
[16:22:06.955]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.955]                         if (muffled) 
[16:22:06.955]                           invokeRestart("muffleMessage")
[16:22:06.955]                       }
[16:22:06.955]                       else if (inherits(cond, "warning")) {
[16:22:06.955]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.955]                         if (muffled) 
[16:22:06.955]                           invokeRestart("muffleWarning")
[16:22:06.955]                       }
[16:22:06.955]                       else if (inherits(cond, "condition")) {
[16:22:06.955]                         if (!is.null(pattern)) {
[16:22:06.955]                           computeRestarts <- base::computeRestarts
[16:22:06.955]                           grepl <- base::grepl
[16:22:06.955]                           restarts <- computeRestarts(cond)
[16:22:06.955]                           for (restart in restarts) {
[16:22:06.955]                             name <- restart$name
[16:22:06.955]                             if (is.null(name)) 
[16:22:06.955]                               next
[16:22:06.955]                             if (!grepl(pattern, name)) 
[16:22:06.955]                               next
[16:22:06.955]                             invokeRestart(restart)
[16:22:06.955]                             muffled <- TRUE
[16:22:06.955]                             break
[16:22:06.955]                           }
[16:22:06.955]                         }
[16:22:06.955]                       }
[16:22:06.955]                       invisible(muffled)
[16:22:06.955]                     }
[16:22:06.955]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.955]                   }
[16:22:06.955]                 }
[16:22:06.955]                 else {
[16:22:06.955]                   if (TRUE) {
[16:22:06.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.955]                     {
[16:22:06.955]                       inherits <- base::inherits
[16:22:06.955]                       invokeRestart <- base::invokeRestart
[16:22:06.955]                       is.null <- base::is.null
[16:22:06.955]                       muffled <- FALSE
[16:22:06.955]                       if (inherits(cond, "message")) {
[16:22:06.955]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.955]                         if (muffled) 
[16:22:06.955]                           invokeRestart("muffleMessage")
[16:22:06.955]                       }
[16:22:06.955]                       else if (inherits(cond, "warning")) {
[16:22:06.955]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.955]                         if (muffled) 
[16:22:06.955]                           invokeRestart("muffleWarning")
[16:22:06.955]                       }
[16:22:06.955]                       else if (inherits(cond, "condition")) {
[16:22:06.955]                         if (!is.null(pattern)) {
[16:22:06.955]                           computeRestarts <- base::computeRestarts
[16:22:06.955]                           grepl <- base::grepl
[16:22:06.955]                           restarts <- computeRestarts(cond)
[16:22:06.955]                           for (restart in restarts) {
[16:22:06.955]                             name <- restart$name
[16:22:06.955]                             if (is.null(name)) 
[16:22:06.955]                               next
[16:22:06.955]                             if (!grepl(pattern, name)) 
[16:22:06.955]                               next
[16:22:06.955]                             invokeRestart(restart)
[16:22:06.955]                             muffled <- TRUE
[16:22:06.955]                             break
[16:22:06.955]                           }
[16:22:06.955]                         }
[16:22:06.955]                       }
[16:22:06.955]                       invisible(muffled)
[16:22:06.955]                     }
[16:22:06.955]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.955]                   }
[16:22:06.955]                 }
[16:22:06.955]             }
[16:22:06.955]         }))
[16:22:06.955]     }, error = function(ex) {
[16:22:06.955]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:06.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.955]                 ...future.rng), started = ...future.startTime, 
[16:22:06.955]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:06.955]             version = "1.8"), class = "FutureResult")
[16:22:06.955]     }, finally = {
[16:22:06.955]         if (!identical(...future.workdir, getwd())) 
[16:22:06.955]             setwd(...future.workdir)
[16:22:06.955]         {
[16:22:06.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:06.955]                 ...future.oldOptions$nwarnings <- NULL
[16:22:06.955]             }
[16:22:06.955]             base::options(...future.oldOptions)
[16:22:06.955]             if (.Platform$OS.type == "windows") {
[16:22:06.955]                 old_names <- names(...future.oldEnvVars)
[16:22:06.955]                 envs <- base::Sys.getenv()
[16:22:06.955]                 names <- names(envs)
[16:22:06.955]                 common <- intersect(names, old_names)
[16:22:06.955]                 added <- setdiff(names, old_names)
[16:22:06.955]                 removed <- setdiff(old_names, names)
[16:22:06.955]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:06.955]                   envs[common]]
[16:22:06.955]                 NAMES <- toupper(changed)
[16:22:06.955]                 args <- list()
[16:22:06.955]                 for (kk in seq_along(NAMES)) {
[16:22:06.955]                   name <- changed[[kk]]
[16:22:06.955]                   NAME <- NAMES[[kk]]
[16:22:06.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.955]                     next
[16:22:06.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.955]                 }
[16:22:06.955]                 NAMES <- toupper(added)
[16:22:06.955]                 for (kk in seq_along(NAMES)) {
[16:22:06.955]                   name <- added[[kk]]
[16:22:06.955]                   NAME <- NAMES[[kk]]
[16:22:06.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.955]                     next
[16:22:06.955]                   args[[name]] <- ""
[16:22:06.955]                 }
[16:22:06.955]                 NAMES <- toupper(removed)
[16:22:06.955]                 for (kk in seq_along(NAMES)) {
[16:22:06.955]                   name <- removed[[kk]]
[16:22:06.955]                   NAME <- NAMES[[kk]]
[16:22:06.955]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.955]                     next
[16:22:06.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.955]                 }
[16:22:06.955]                 if (length(args) > 0) 
[16:22:06.955]                   base::do.call(base::Sys.setenv, args = args)
[16:22:06.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:06.955]             }
[16:22:06.955]             else {
[16:22:06.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:06.955]             }
[16:22:06.955]             {
[16:22:06.955]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:06.955]                   0L) {
[16:22:06.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:06.955]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:06.955]                   base::options(opts)
[16:22:06.955]                 }
[16:22:06.955]                 {
[16:22:06.955]                   {
[16:22:06.955]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:06.955]                     NULL
[16:22:06.955]                   }
[16:22:06.955]                   options(future.plan = NULL)
[16:22:06.955]                   if (is.na(NA_character_)) 
[16:22:06.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:06.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:06.955]                     .init = FALSE)
[16:22:06.955]                 }
[16:22:06.955]             }
[16:22:06.955]         }
[16:22:06.955]     })
[16:22:06.955]     if (TRUE) {
[16:22:06.955]         base::sink(type = "output", split = FALSE)
[16:22:06.955]         if (TRUE) {
[16:22:06.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:06.955]         }
[16:22:06.955]         else {
[16:22:06.955]             ...future.result["stdout"] <- base::list(NULL)
[16:22:06.955]         }
[16:22:06.955]         base::close(...future.stdout)
[16:22:06.955]         ...future.stdout <- NULL
[16:22:06.955]     }
[16:22:06.955]     ...future.result$conditions <- ...future.conditions
[16:22:06.955]     ...future.result$finished <- base::Sys.time()
[16:22:06.955]     ...future.result
[16:22:06.955] }
[16:22:06.958] MultisessionFuture started
[16:22:06.958] - Launch lazy future ... done
[16:22:06.958] run() for ‘MultisessionFuture’ ... done
[16:22:06.960] receiveMessageFromWorker() for ClusterFuture ...
[16:22:06.960] - Validating connection of MultisessionFuture
[16:22:06.960] - received message: FutureResult
[16:22:06.960] - Received FutureResult
[16:22:06.961] - Erased future from FutureRegistry
[16:22:06.961] result() for ClusterFuture ...
[16:22:06.961] - result already collected: FutureResult
[16:22:06.961] result() for ClusterFuture ... done
[16:22:06.961] signalConditions() ...
[16:22:06.961]  - include = ‘immediateCondition’
[16:22:06.961]  - exclude = 
[16:22:06.961]  - resignal = FALSE
[16:22:06.961]  - Number of conditions: 1
[16:22:06.961] signalConditions() ... done
[16:22:06.961] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:06.961] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[16:22:06.962] getGlobalsAndPackages() ...
[16:22:06.962] Searching for globals...
[16:22:06.963] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:06.963] Searching for globals ... DONE
[16:22:06.963] Resolving globals: FALSE
[16:22:06.963] 
[16:22:06.964] 
[16:22:06.964] getGlobalsAndPackages() ... DONE
[16:22:06.964] run() for ‘Future’ ...
[16:22:06.964] - state: ‘created’
[16:22:06.964] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:06.978] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:06.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:06.978]   - Field: ‘node’
[16:22:06.978]   - Field: ‘label’
[16:22:06.978]   - Field: ‘local’
[16:22:06.978]   - Field: ‘owner’
[16:22:06.978]   - Field: ‘envir’
[16:22:06.978]   - Field: ‘workers’
[16:22:06.979]   - Field: ‘packages’
[16:22:06.979]   - Field: ‘gc’
[16:22:06.979]   - Field: ‘conditions’
[16:22:06.979]   - Field: ‘persistent’
[16:22:06.979]   - Field: ‘expr’
[16:22:06.979]   - Field: ‘uuid’
[16:22:06.979]   - Field: ‘seed’
[16:22:06.979]   - Field: ‘version’
[16:22:06.979]   - Field: ‘result’
[16:22:06.979]   - Field: ‘asynchronous’
[16:22:06.979]   - Field: ‘calls’
[16:22:06.980]   - Field: ‘globals’
[16:22:06.980]   - Field: ‘stdout’
[16:22:06.980]   - Field: ‘earlySignal’
[16:22:06.980]   - Field: ‘lazy’
[16:22:06.980]   - Field: ‘state’
[16:22:06.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:06.980] - Launch lazy future ...
[16:22:06.980] Packages needed by the future expression (n = 0): <none>
[16:22:06.981] Packages needed by future strategies (n = 0): <none>
[16:22:06.981] {
[16:22:06.981]     {
[16:22:06.981]         {
[16:22:06.981]             ...future.startTime <- base::Sys.time()
[16:22:06.981]             {
[16:22:06.981]                 {
[16:22:06.981]                   {
[16:22:06.981]                     {
[16:22:06.981]                       base::local({
[16:22:06.981]                         has_future <- base::requireNamespace("future", 
[16:22:06.981]                           quietly = TRUE)
[16:22:06.981]                         if (has_future) {
[16:22:06.981]                           ns <- base::getNamespace("future")
[16:22:06.981]                           version <- ns[[".package"]][["version"]]
[16:22:06.981]                           if (is.null(version)) 
[16:22:06.981]                             version <- utils::packageVersion("future")
[16:22:06.981]                         }
[16:22:06.981]                         else {
[16:22:06.981]                           version <- NULL
[16:22:06.981]                         }
[16:22:06.981]                         if (!has_future || version < "1.8.0") {
[16:22:06.981]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:06.981]                             "", base::R.version$version.string), 
[16:22:06.981]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:06.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:06.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:06.981]                               "release", "version")], collapse = " "), 
[16:22:06.981]                             hostname = base::Sys.info()[["nodename"]])
[16:22:06.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:06.981]                             info)
[16:22:06.981]                           info <- base::paste(info, collapse = "; ")
[16:22:06.981]                           if (!has_future) {
[16:22:06.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:06.981]                               info)
[16:22:06.981]                           }
[16:22:06.981]                           else {
[16:22:06.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:06.981]                               info, version)
[16:22:06.981]                           }
[16:22:06.981]                           base::stop(msg)
[16:22:06.981]                         }
[16:22:06.981]                       })
[16:22:06.981]                     }
[16:22:06.981]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:06.981]                     base::options(mc.cores = 1L)
[16:22:06.981]                   }
[16:22:06.981]                   ...future.strategy.old <- future::plan("list")
[16:22:06.981]                   options(future.plan = NULL)
[16:22:06.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:06.981]                 }
[16:22:06.981]                 ...future.workdir <- getwd()
[16:22:06.981]             }
[16:22:06.981]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:06.981]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:06.981]         }
[16:22:06.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:06.981]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:06.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:06.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:06.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:06.981]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:06.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:06.981]             base::names(...future.oldOptions))
[16:22:06.981]     }
[16:22:06.981]     if (FALSE) {
[16:22:06.981]     }
[16:22:06.981]     else {
[16:22:06.981]         if (TRUE) {
[16:22:06.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:06.981]                 open = "w")
[16:22:06.981]         }
[16:22:06.981]         else {
[16:22:06.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:06.981]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:06.981]         }
[16:22:06.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:06.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:06.981]             base::sink(type = "output", split = FALSE)
[16:22:06.981]             base::close(...future.stdout)
[16:22:06.981]         }, add = TRUE)
[16:22:06.981]     }
[16:22:06.981]     ...future.frame <- base::sys.nframe()
[16:22:06.981]     ...future.conditions <- base::list()
[16:22:06.981]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:06.981]     if (FALSE) {
[16:22:06.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:06.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:06.981]     }
[16:22:06.981]     ...future.result <- base::tryCatch({
[16:22:06.981]         base::withCallingHandlers({
[16:22:06.981]             ...future.value <- base::withVisible(base::local({
[16:22:06.981]                 ...future.makeSendCondition <- base::local({
[16:22:06.981]                   sendCondition <- NULL
[16:22:06.981]                   function(frame = 1L) {
[16:22:06.981]                     if (is.function(sendCondition)) 
[16:22:06.981]                       return(sendCondition)
[16:22:06.981]                     ns <- getNamespace("parallel")
[16:22:06.981]                     if (exists("sendData", mode = "function", 
[16:22:06.981]                       envir = ns)) {
[16:22:06.981]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:06.981]                         envir = ns)
[16:22:06.981]                       envir <- sys.frame(frame)
[16:22:06.981]                       master <- NULL
[16:22:06.981]                       while (!identical(envir, .GlobalEnv) && 
[16:22:06.981]                         !identical(envir, emptyenv())) {
[16:22:06.981]                         if (exists("master", mode = "list", envir = envir, 
[16:22:06.981]                           inherits = FALSE)) {
[16:22:06.981]                           master <- get("master", mode = "list", 
[16:22:06.981]                             envir = envir, inherits = FALSE)
[16:22:06.981]                           if (inherits(master, c("SOCKnode", 
[16:22:06.981]                             "SOCK0node"))) {
[16:22:06.981]                             sendCondition <<- function(cond) {
[16:22:06.981]                               data <- list(type = "VALUE", value = cond, 
[16:22:06.981]                                 success = TRUE)
[16:22:06.981]                               parallel_sendData(master, data)
[16:22:06.981]                             }
[16:22:06.981]                             return(sendCondition)
[16:22:06.981]                           }
[16:22:06.981]                         }
[16:22:06.981]                         frame <- frame + 1L
[16:22:06.981]                         envir <- sys.frame(frame)
[16:22:06.981]                       }
[16:22:06.981]                     }
[16:22:06.981]                     sendCondition <<- function(cond) NULL
[16:22:06.981]                   }
[16:22:06.981]                 })
[16:22:06.981]                 withCallingHandlers({
[16:22:06.981]                   {
[16:22:06.981]                     Sys.sleep(0.5)
[16:22:06.981]                     list(a = 1, b = 42L)
[16:22:06.981]                   }
[16:22:06.981]                 }, immediateCondition = function(cond) {
[16:22:06.981]                   sendCondition <- ...future.makeSendCondition()
[16:22:06.981]                   sendCondition(cond)
[16:22:06.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.981]                   {
[16:22:06.981]                     inherits <- base::inherits
[16:22:06.981]                     invokeRestart <- base::invokeRestart
[16:22:06.981]                     is.null <- base::is.null
[16:22:06.981]                     muffled <- FALSE
[16:22:06.981]                     if (inherits(cond, "message")) {
[16:22:06.981]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:06.981]                       if (muffled) 
[16:22:06.981]                         invokeRestart("muffleMessage")
[16:22:06.981]                     }
[16:22:06.981]                     else if (inherits(cond, "warning")) {
[16:22:06.981]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:06.981]                       if (muffled) 
[16:22:06.981]                         invokeRestart("muffleWarning")
[16:22:06.981]                     }
[16:22:06.981]                     else if (inherits(cond, "condition")) {
[16:22:06.981]                       if (!is.null(pattern)) {
[16:22:06.981]                         computeRestarts <- base::computeRestarts
[16:22:06.981]                         grepl <- base::grepl
[16:22:06.981]                         restarts <- computeRestarts(cond)
[16:22:06.981]                         for (restart in restarts) {
[16:22:06.981]                           name <- restart$name
[16:22:06.981]                           if (is.null(name)) 
[16:22:06.981]                             next
[16:22:06.981]                           if (!grepl(pattern, name)) 
[16:22:06.981]                             next
[16:22:06.981]                           invokeRestart(restart)
[16:22:06.981]                           muffled <- TRUE
[16:22:06.981]                           break
[16:22:06.981]                         }
[16:22:06.981]                       }
[16:22:06.981]                     }
[16:22:06.981]                     invisible(muffled)
[16:22:06.981]                   }
[16:22:06.981]                   muffleCondition(cond)
[16:22:06.981]                 })
[16:22:06.981]             }))
[16:22:06.981]             future::FutureResult(value = ...future.value$value, 
[16:22:06.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.981]                   ...future.rng), globalenv = if (FALSE) 
[16:22:06.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:06.981]                     ...future.globalenv.names))
[16:22:06.981]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:06.981]         }, condition = base::local({
[16:22:06.981]             c <- base::c
[16:22:06.981]             inherits <- base::inherits
[16:22:06.981]             invokeRestart <- base::invokeRestart
[16:22:06.981]             length <- base::length
[16:22:06.981]             list <- base::list
[16:22:06.981]             seq.int <- base::seq.int
[16:22:06.981]             signalCondition <- base::signalCondition
[16:22:06.981]             sys.calls <- base::sys.calls
[16:22:06.981]             `[[` <- base::`[[`
[16:22:06.981]             `+` <- base::`+`
[16:22:06.981]             `<<-` <- base::`<<-`
[16:22:06.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:06.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:06.981]                   3L)]
[16:22:06.981]             }
[16:22:06.981]             function(cond) {
[16:22:06.981]                 is_error <- inherits(cond, "error")
[16:22:06.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:06.981]                   NULL)
[16:22:06.981]                 if (is_error) {
[16:22:06.981]                   sessionInformation <- function() {
[16:22:06.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:06.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:06.981]                       search = base::search(), system = base::Sys.info())
[16:22:06.981]                   }
[16:22:06.981]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:06.981]                     cond$call), session = sessionInformation(), 
[16:22:06.981]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:06.981]                   signalCondition(cond)
[16:22:06.981]                 }
[16:22:06.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:06.981]                 "immediateCondition"))) {
[16:22:06.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:06.981]                   ...future.conditions[[length(...future.conditions) + 
[16:22:06.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:06.981]                   if (TRUE && !signal) {
[16:22:06.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.981]                     {
[16:22:06.981]                       inherits <- base::inherits
[16:22:06.981]                       invokeRestart <- base::invokeRestart
[16:22:06.981]                       is.null <- base::is.null
[16:22:06.981]                       muffled <- FALSE
[16:22:06.981]                       if (inherits(cond, "message")) {
[16:22:06.981]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.981]                         if (muffled) 
[16:22:06.981]                           invokeRestart("muffleMessage")
[16:22:06.981]                       }
[16:22:06.981]                       else if (inherits(cond, "warning")) {
[16:22:06.981]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.981]                         if (muffled) 
[16:22:06.981]                           invokeRestart("muffleWarning")
[16:22:06.981]                       }
[16:22:06.981]                       else if (inherits(cond, "condition")) {
[16:22:06.981]                         if (!is.null(pattern)) {
[16:22:06.981]                           computeRestarts <- base::computeRestarts
[16:22:06.981]                           grepl <- base::grepl
[16:22:06.981]                           restarts <- computeRestarts(cond)
[16:22:06.981]                           for (restart in restarts) {
[16:22:06.981]                             name <- restart$name
[16:22:06.981]                             if (is.null(name)) 
[16:22:06.981]                               next
[16:22:06.981]                             if (!grepl(pattern, name)) 
[16:22:06.981]                               next
[16:22:06.981]                             invokeRestart(restart)
[16:22:06.981]                             muffled <- TRUE
[16:22:06.981]                             break
[16:22:06.981]                           }
[16:22:06.981]                         }
[16:22:06.981]                       }
[16:22:06.981]                       invisible(muffled)
[16:22:06.981]                     }
[16:22:06.981]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.981]                   }
[16:22:06.981]                 }
[16:22:06.981]                 else {
[16:22:06.981]                   if (TRUE) {
[16:22:06.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:06.981]                     {
[16:22:06.981]                       inherits <- base::inherits
[16:22:06.981]                       invokeRestart <- base::invokeRestart
[16:22:06.981]                       is.null <- base::is.null
[16:22:06.981]                       muffled <- FALSE
[16:22:06.981]                       if (inherits(cond, "message")) {
[16:22:06.981]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:06.981]                         if (muffled) 
[16:22:06.981]                           invokeRestart("muffleMessage")
[16:22:06.981]                       }
[16:22:06.981]                       else if (inherits(cond, "warning")) {
[16:22:06.981]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:06.981]                         if (muffled) 
[16:22:06.981]                           invokeRestart("muffleWarning")
[16:22:06.981]                       }
[16:22:06.981]                       else if (inherits(cond, "condition")) {
[16:22:06.981]                         if (!is.null(pattern)) {
[16:22:06.981]                           computeRestarts <- base::computeRestarts
[16:22:06.981]                           grepl <- base::grepl
[16:22:06.981]                           restarts <- computeRestarts(cond)
[16:22:06.981]                           for (restart in restarts) {
[16:22:06.981]                             name <- restart$name
[16:22:06.981]                             if (is.null(name)) 
[16:22:06.981]                               next
[16:22:06.981]                             if (!grepl(pattern, name)) 
[16:22:06.981]                               next
[16:22:06.981]                             invokeRestart(restart)
[16:22:06.981]                             muffled <- TRUE
[16:22:06.981]                             break
[16:22:06.981]                           }
[16:22:06.981]                         }
[16:22:06.981]                       }
[16:22:06.981]                       invisible(muffled)
[16:22:06.981]                     }
[16:22:06.981]                     muffleCondition(cond, pattern = "^muffle")
[16:22:06.981]                   }
[16:22:06.981]                 }
[16:22:06.981]             }
[16:22:06.981]         }))
[16:22:06.981]     }, error = function(ex) {
[16:22:06.981]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:06.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:06.981]                 ...future.rng), started = ...future.startTime, 
[16:22:06.981]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:06.981]             version = "1.8"), class = "FutureResult")
[16:22:06.981]     }, finally = {
[16:22:06.981]         if (!identical(...future.workdir, getwd())) 
[16:22:06.981]             setwd(...future.workdir)
[16:22:06.981]         {
[16:22:06.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:06.981]                 ...future.oldOptions$nwarnings <- NULL
[16:22:06.981]             }
[16:22:06.981]             base::options(...future.oldOptions)
[16:22:06.981]             if (.Platform$OS.type == "windows") {
[16:22:06.981]                 old_names <- names(...future.oldEnvVars)
[16:22:06.981]                 envs <- base::Sys.getenv()
[16:22:06.981]                 names <- names(envs)
[16:22:06.981]                 common <- intersect(names, old_names)
[16:22:06.981]                 added <- setdiff(names, old_names)
[16:22:06.981]                 removed <- setdiff(old_names, names)
[16:22:06.981]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:06.981]                   envs[common]]
[16:22:06.981]                 NAMES <- toupper(changed)
[16:22:06.981]                 args <- list()
[16:22:06.981]                 for (kk in seq_along(NAMES)) {
[16:22:06.981]                   name <- changed[[kk]]
[16:22:06.981]                   NAME <- NAMES[[kk]]
[16:22:06.981]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.981]                     next
[16:22:06.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.981]                 }
[16:22:06.981]                 NAMES <- toupper(added)
[16:22:06.981]                 for (kk in seq_along(NAMES)) {
[16:22:06.981]                   name <- added[[kk]]
[16:22:06.981]                   NAME <- NAMES[[kk]]
[16:22:06.981]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.981]                     next
[16:22:06.981]                   args[[name]] <- ""
[16:22:06.981]                 }
[16:22:06.981]                 NAMES <- toupper(removed)
[16:22:06.981]                 for (kk in seq_along(NAMES)) {
[16:22:06.981]                   name <- removed[[kk]]
[16:22:06.981]                   NAME <- NAMES[[kk]]
[16:22:06.981]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:06.981]                     next
[16:22:06.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:06.981]                 }
[16:22:06.981]                 if (length(args) > 0) 
[16:22:06.981]                   base::do.call(base::Sys.setenv, args = args)
[16:22:06.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:06.981]             }
[16:22:06.981]             else {
[16:22:06.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:06.981]             }
[16:22:06.981]             {
[16:22:06.981]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:06.981]                   0L) {
[16:22:06.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:06.981]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:06.981]                   base::options(opts)
[16:22:06.981]                 }
[16:22:06.981]                 {
[16:22:06.981]                   {
[16:22:06.981]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:06.981]                     NULL
[16:22:06.981]                   }
[16:22:06.981]                   options(future.plan = NULL)
[16:22:06.981]                   if (is.na(NA_character_)) 
[16:22:06.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:06.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:06.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:06.981]                     .init = FALSE)
[16:22:06.981]                 }
[16:22:06.981]             }
[16:22:06.981]         }
[16:22:06.981]     })
[16:22:06.981]     if (TRUE) {
[16:22:06.981]         base::sink(type = "output", split = FALSE)
[16:22:06.981]         if (TRUE) {
[16:22:06.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:06.981]         }
[16:22:06.981]         else {
[16:22:06.981]             ...future.result["stdout"] <- base::list(NULL)
[16:22:06.981]         }
[16:22:06.981]         base::close(...future.stdout)
[16:22:06.981]         ...future.stdout <- NULL
[16:22:06.981]     }
[16:22:06.981]     ...future.result$conditions <- ...future.conditions
[16:22:06.981]     ...future.result$finished <- base::Sys.time()
[16:22:06.981]     ...future.result
[16:22:06.981] }
[16:22:06.984] MultisessionFuture started
[16:22:06.984] - Launch lazy future ... done
[16:22:06.984] run() for ‘MultisessionFuture’ ... done
[16:22:07.486] receiveMessageFromWorker() for ClusterFuture ...
[16:22:07.487] - Validating connection of MultisessionFuture
[16:22:07.487] - received message: FutureResult
[16:22:07.487] - Received FutureResult
[16:22:07.487] - Erased future from FutureRegistry
[16:22:07.487] result() for ClusterFuture ...
[16:22:07.487] - result already collected: FutureResult
[16:22:07.488] result() for ClusterFuture ... done
[16:22:07.488] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:07.488] resolve() on list ...
[16:22:07.488]  recursive: Inf
[16:22:07.488]  length: 2
[16:22:07.488]  elements: ‘a’, ‘b’
[16:22:07.488]  length: 1 (resolved future 1)
[16:22:07.488]  length: 0 (resolved future 2)
[16:22:07.488] resolve() on list ... DONE
[16:22:07.489] A MultisessionFuture was resolved (and resolved itself)
[16:22:07.489] getGlobalsAndPackages() ...
[16:22:07.489] Searching for globals...
[16:22:07.490] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:22:07.490] Searching for globals ... DONE
[16:22:07.490] Resolving globals: FALSE
[16:22:07.490] 
[16:22:07.491] 
[16:22:07.491] getGlobalsAndPackages() ... DONE
[16:22:07.491] run() for ‘Future’ ...
[16:22:07.491] - state: ‘created’
[16:22:07.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:07.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:07.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:07.505]   - Field: ‘node’
[16:22:07.505]   - Field: ‘label’
[16:22:07.506]   - Field: ‘local’
[16:22:07.506]   - Field: ‘owner’
[16:22:07.506]   - Field: ‘envir’
[16:22:07.506]   - Field: ‘workers’
[16:22:07.506]   - Field: ‘packages’
[16:22:07.506]   - Field: ‘gc’
[16:22:07.506]   - Field: ‘conditions’
[16:22:07.506]   - Field: ‘persistent’
[16:22:07.506]   - Field: ‘expr’
[16:22:07.506]   - Field: ‘uuid’
[16:22:07.507]   - Field: ‘seed’
[16:22:07.507]   - Field: ‘version’
[16:22:07.507]   - Field: ‘result’
[16:22:07.507]   - Field: ‘asynchronous’
[16:22:07.507]   - Field: ‘calls’
[16:22:07.507]   - Field: ‘globals’
[16:22:07.507]   - Field: ‘stdout’
[16:22:07.507]   - Field: ‘earlySignal’
[16:22:07.507]   - Field: ‘lazy’
[16:22:07.507]   - Field: ‘state’
[16:22:07.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:07.508] - Launch lazy future ...
[16:22:07.508] Packages needed by the future expression (n = 0): <none>
[16:22:07.508] Packages needed by future strategies (n = 0): <none>
[16:22:07.508] {
[16:22:07.508]     {
[16:22:07.508]         {
[16:22:07.508]             ...future.startTime <- base::Sys.time()
[16:22:07.508]             {
[16:22:07.508]                 {
[16:22:07.508]                   {
[16:22:07.508]                     {
[16:22:07.508]                       base::local({
[16:22:07.508]                         has_future <- base::requireNamespace("future", 
[16:22:07.508]                           quietly = TRUE)
[16:22:07.508]                         if (has_future) {
[16:22:07.508]                           ns <- base::getNamespace("future")
[16:22:07.508]                           version <- ns[[".package"]][["version"]]
[16:22:07.508]                           if (is.null(version)) 
[16:22:07.508]                             version <- utils::packageVersion("future")
[16:22:07.508]                         }
[16:22:07.508]                         else {
[16:22:07.508]                           version <- NULL
[16:22:07.508]                         }
[16:22:07.508]                         if (!has_future || version < "1.8.0") {
[16:22:07.508]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:07.508]                             "", base::R.version$version.string), 
[16:22:07.508]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:07.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:07.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:07.508]                               "release", "version")], collapse = " "), 
[16:22:07.508]                             hostname = base::Sys.info()[["nodename"]])
[16:22:07.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:07.508]                             info)
[16:22:07.508]                           info <- base::paste(info, collapse = "; ")
[16:22:07.508]                           if (!has_future) {
[16:22:07.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:07.508]                               info)
[16:22:07.508]                           }
[16:22:07.508]                           else {
[16:22:07.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:07.508]                               info, version)
[16:22:07.508]                           }
[16:22:07.508]                           base::stop(msg)
[16:22:07.508]                         }
[16:22:07.508]                       })
[16:22:07.508]                     }
[16:22:07.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:07.508]                     base::options(mc.cores = 1L)
[16:22:07.508]                   }
[16:22:07.508]                   ...future.strategy.old <- future::plan("list")
[16:22:07.508]                   options(future.plan = NULL)
[16:22:07.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:07.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:07.508]                 }
[16:22:07.508]                 ...future.workdir <- getwd()
[16:22:07.508]             }
[16:22:07.508]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:07.508]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:07.508]         }
[16:22:07.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:07.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:07.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:07.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:07.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:07.508]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:07.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:07.508]             base::names(...future.oldOptions))
[16:22:07.508]     }
[16:22:07.508]     if (FALSE) {
[16:22:07.508]     }
[16:22:07.508]     else {
[16:22:07.508]         if (TRUE) {
[16:22:07.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:07.508]                 open = "w")
[16:22:07.508]         }
[16:22:07.508]         else {
[16:22:07.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:07.508]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:07.508]         }
[16:22:07.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:07.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:07.508]             base::sink(type = "output", split = FALSE)
[16:22:07.508]             base::close(...future.stdout)
[16:22:07.508]         }, add = TRUE)
[16:22:07.508]     }
[16:22:07.508]     ...future.frame <- base::sys.nframe()
[16:22:07.508]     ...future.conditions <- base::list()
[16:22:07.508]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:07.508]     if (FALSE) {
[16:22:07.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:07.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:07.508]     }
[16:22:07.508]     ...future.result <- base::tryCatch({
[16:22:07.508]         base::withCallingHandlers({
[16:22:07.508]             ...future.value <- base::withVisible(base::local({
[16:22:07.508]                 ...future.makeSendCondition <- base::local({
[16:22:07.508]                   sendCondition <- NULL
[16:22:07.508]                   function(frame = 1L) {
[16:22:07.508]                     if (is.function(sendCondition)) 
[16:22:07.508]                       return(sendCondition)
[16:22:07.508]                     ns <- getNamespace("parallel")
[16:22:07.508]                     if (exists("sendData", mode = "function", 
[16:22:07.508]                       envir = ns)) {
[16:22:07.508]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:07.508]                         envir = ns)
[16:22:07.508]                       envir <- sys.frame(frame)
[16:22:07.508]                       master <- NULL
[16:22:07.508]                       while (!identical(envir, .GlobalEnv) && 
[16:22:07.508]                         !identical(envir, emptyenv())) {
[16:22:07.508]                         if (exists("master", mode = "list", envir = envir, 
[16:22:07.508]                           inherits = FALSE)) {
[16:22:07.508]                           master <- get("master", mode = "list", 
[16:22:07.508]                             envir = envir, inherits = FALSE)
[16:22:07.508]                           if (inherits(master, c("SOCKnode", 
[16:22:07.508]                             "SOCK0node"))) {
[16:22:07.508]                             sendCondition <<- function(cond) {
[16:22:07.508]                               data <- list(type = "VALUE", value = cond, 
[16:22:07.508]                                 success = TRUE)
[16:22:07.508]                               parallel_sendData(master, data)
[16:22:07.508]                             }
[16:22:07.508]                             return(sendCondition)
[16:22:07.508]                           }
[16:22:07.508]                         }
[16:22:07.508]                         frame <- frame + 1L
[16:22:07.508]                         envir <- sys.frame(frame)
[16:22:07.508]                       }
[16:22:07.508]                     }
[16:22:07.508]                     sendCondition <<- function(cond) NULL
[16:22:07.508]                   }
[16:22:07.508]                 })
[16:22:07.508]                 withCallingHandlers({
[16:22:07.508]                   {
[16:22:07.508]                     Sys.sleep(0.5)
[16:22:07.508]                     list(a = 1, b = 42L)
[16:22:07.508]                   }
[16:22:07.508]                 }, immediateCondition = function(cond) {
[16:22:07.508]                   sendCondition <- ...future.makeSendCondition()
[16:22:07.508]                   sendCondition(cond)
[16:22:07.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:07.508]                   {
[16:22:07.508]                     inherits <- base::inherits
[16:22:07.508]                     invokeRestart <- base::invokeRestart
[16:22:07.508]                     is.null <- base::is.null
[16:22:07.508]                     muffled <- FALSE
[16:22:07.508]                     if (inherits(cond, "message")) {
[16:22:07.508]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:07.508]                       if (muffled) 
[16:22:07.508]                         invokeRestart("muffleMessage")
[16:22:07.508]                     }
[16:22:07.508]                     else if (inherits(cond, "warning")) {
[16:22:07.508]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:07.508]                       if (muffled) 
[16:22:07.508]                         invokeRestart("muffleWarning")
[16:22:07.508]                     }
[16:22:07.508]                     else if (inherits(cond, "condition")) {
[16:22:07.508]                       if (!is.null(pattern)) {
[16:22:07.508]                         computeRestarts <- base::computeRestarts
[16:22:07.508]                         grepl <- base::grepl
[16:22:07.508]                         restarts <- computeRestarts(cond)
[16:22:07.508]                         for (restart in restarts) {
[16:22:07.508]                           name <- restart$name
[16:22:07.508]                           if (is.null(name)) 
[16:22:07.508]                             next
[16:22:07.508]                           if (!grepl(pattern, name)) 
[16:22:07.508]                             next
[16:22:07.508]                           invokeRestart(restart)
[16:22:07.508]                           muffled <- TRUE
[16:22:07.508]                           break
[16:22:07.508]                         }
[16:22:07.508]                       }
[16:22:07.508]                     }
[16:22:07.508]                     invisible(muffled)
[16:22:07.508]                   }
[16:22:07.508]                   muffleCondition(cond)
[16:22:07.508]                 })
[16:22:07.508]             }))
[16:22:07.508]             future::FutureResult(value = ...future.value$value, 
[16:22:07.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:07.508]                   ...future.rng), globalenv = if (FALSE) 
[16:22:07.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:07.508]                     ...future.globalenv.names))
[16:22:07.508]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:07.508]         }, condition = base::local({
[16:22:07.508]             c <- base::c
[16:22:07.508]             inherits <- base::inherits
[16:22:07.508]             invokeRestart <- base::invokeRestart
[16:22:07.508]             length <- base::length
[16:22:07.508]             list <- base::list
[16:22:07.508]             seq.int <- base::seq.int
[16:22:07.508]             signalCondition <- base::signalCondition
[16:22:07.508]             sys.calls <- base::sys.calls
[16:22:07.508]             `[[` <- base::`[[`
[16:22:07.508]             `+` <- base::`+`
[16:22:07.508]             `<<-` <- base::`<<-`
[16:22:07.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:07.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:07.508]                   3L)]
[16:22:07.508]             }
[16:22:07.508]             function(cond) {
[16:22:07.508]                 is_error <- inherits(cond, "error")
[16:22:07.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:07.508]                   NULL)
[16:22:07.508]                 if (is_error) {
[16:22:07.508]                   sessionInformation <- function() {
[16:22:07.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:07.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:07.508]                       search = base::search(), system = base::Sys.info())
[16:22:07.508]                   }
[16:22:07.508]                   ...future.conditions[[length(...future.conditions) + 
[16:22:07.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:07.508]                     cond$call), session = sessionInformation(), 
[16:22:07.508]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:07.508]                   signalCondition(cond)
[16:22:07.508]                 }
[16:22:07.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:07.508]                 "immediateCondition"))) {
[16:22:07.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:07.508]                   ...future.conditions[[length(...future.conditions) + 
[16:22:07.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:07.508]                   if (TRUE && !signal) {
[16:22:07.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:07.508]                     {
[16:22:07.508]                       inherits <- base::inherits
[16:22:07.508]                       invokeRestart <- base::invokeRestart
[16:22:07.508]                       is.null <- base::is.null
[16:22:07.508]                       muffled <- FALSE
[16:22:07.508]                       if (inherits(cond, "message")) {
[16:22:07.508]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:07.508]                         if (muffled) 
[16:22:07.508]                           invokeRestart("muffleMessage")
[16:22:07.508]                       }
[16:22:07.508]                       else if (inherits(cond, "warning")) {
[16:22:07.508]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:07.508]                         if (muffled) 
[16:22:07.508]                           invokeRestart("muffleWarning")
[16:22:07.508]                       }
[16:22:07.508]                       else if (inherits(cond, "condition")) {
[16:22:07.508]                         if (!is.null(pattern)) {
[16:22:07.508]                           computeRestarts <- base::computeRestarts
[16:22:07.508]                           grepl <- base::grepl
[16:22:07.508]                           restarts <- computeRestarts(cond)
[16:22:07.508]                           for (restart in restarts) {
[16:22:07.508]                             name <- restart$name
[16:22:07.508]                             if (is.null(name)) 
[16:22:07.508]                               next
[16:22:07.508]                             if (!grepl(pattern, name)) 
[16:22:07.508]                               next
[16:22:07.508]                             invokeRestart(restart)
[16:22:07.508]                             muffled <- TRUE
[16:22:07.508]                             break
[16:22:07.508]                           }
[16:22:07.508]                         }
[16:22:07.508]                       }
[16:22:07.508]                       invisible(muffled)
[16:22:07.508]                     }
[16:22:07.508]                     muffleCondition(cond, pattern = "^muffle")
[16:22:07.508]                   }
[16:22:07.508]                 }
[16:22:07.508]                 else {
[16:22:07.508]                   if (TRUE) {
[16:22:07.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:07.508]                     {
[16:22:07.508]                       inherits <- base::inherits
[16:22:07.508]                       invokeRestart <- base::invokeRestart
[16:22:07.508]                       is.null <- base::is.null
[16:22:07.508]                       muffled <- FALSE
[16:22:07.508]                       if (inherits(cond, "message")) {
[16:22:07.508]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:07.508]                         if (muffled) 
[16:22:07.508]                           invokeRestart("muffleMessage")
[16:22:07.508]                       }
[16:22:07.508]                       else if (inherits(cond, "warning")) {
[16:22:07.508]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:07.508]                         if (muffled) 
[16:22:07.508]                           invokeRestart("muffleWarning")
[16:22:07.508]                       }
[16:22:07.508]                       else if (inherits(cond, "condition")) {
[16:22:07.508]                         if (!is.null(pattern)) {
[16:22:07.508]                           computeRestarts <- base::computeRestarts
[16:22:07.508]                           grepl <- base::grepl
[16:22:07.508]                           restarts <- computeRestarts(cond)
[16:22:07.508]                           for (restart in restarts) {
[16:22:07.508]                             name <- restart$name
[16:22:07.508]                             if (is.null(name)) 
[16:22:07.508]                               next
[16:22:07.508]                             if (!grepl(pattern, name)) 
[16:22:07.508]                               next
[16:22:07.508]                             invokeRestart(restart)
[16:22:07.508]                             muffled <- TRUE
[16:22:07.508]                             break
[16:22:07.508]                           }
[16:22:07.508]                         }
[16:22:07.508]                       }
[16:22:07.508]                       invisible(muffled)
[16:22:07.508]                     }
[16:22:07.508]                     muffleCondition(cond, pattern = "^muffle")
[16:22:07.508]                   }
[16:22:07.508]                 }
[16:22:07.508]             }
[16:22:07.508]         }))
[16:22:07.508]     }, error = function(ex) {
[16:22:07.508]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:07.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:07.508]                 ...future.rng), started = ...future.startTime, 
[16:22:07.508]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:07.508]             version = "1.8"), class = "FutureResult")
[16:22:07.508]     }, finally = {
[16:22:07.508]         if (!identical(...future.workdir, getwd())) 
[16:22:07.508]             setwd(...future.workdir)
[16:22:07.508]         {
[16:22:07.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:07.508]                 ...future.oldOptions$nwarnings <- NULL
[16:22:07.508]             }
[16:22:07.508]             base::options(...future.oldOptions)
[16:22:07.508]             if (.Platform$OS.type == "windows") {
[16:22:07.508]                 old_names <- names(...future.oldEnvVars)
[16:22:07.508]                 envs <- base::Sys.getenv()
[16:22:07.508]                 names <- names(envs)
[16:22:07.508]                 common <- intersect(names, old_names)
[16:22:07.508]                 added <- setdiff(names, old_names)
[16:22:07.508]                 removed <- setdiff(old_names, names)
[16:22:07.508]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:07.508]                   envs[common]]
[16:22:07.508]                 NAMES <- toupper(changed)
[16:22:07.508]                 args <- list()
[16:22:07.508]                 for (kk in seq_along(NAMES)) {
[16:22:07.508]                   name <- changed[[kk]]
[16:22:07.508]                   NAME <- NAMES[[kk]]
[16:22:07.508]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:07.508]                     next
[16:22:07.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:07.508]                 }
[16:22:07.508]                 NAMES <- toupper(added)
[16:22:07.508]                 for (kk in seq_along(NAMES)) {
[16:22:07.508]                   name <- added[[kk]]
[16:22:07.508]                   NAME <- NAMES[[kk]]
[16:22:07.508]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:07.508]                     next
[16:22:07.508]                   args[[name]] <- ""
[16:22:07.508]                 }
[16:22:07.508]                 NAMES <- toupper(removed)
[16:22:07.508]                 for (kk in seq_along(NAMES)) {
[16:22:07.508]                   name <- removed[[kk]]
[16:22:07.508]                   NAME <- NAMES[[kk]]
[16:22:07.508]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:07.508]                     next
[16:22:07.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:07.508]                 }
[16:22:07.508]                 if (length(args) > 0) 
[16:22:07.508]                   base::do.call(base::Sys.setenv, args = args)
[16:22:07.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:07.508]             }
[16:22:07.508]             else {
[16:22:07.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:07.508]             }
[16:22:07.508]             {
[16:22:07.508]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:07.508]                   0L) {
[16:22:07.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:07.508]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:07.508]                   base::options(opts)
[16:22:07.508]                 }
[16:22:07.508]                 {
[16:22:07.508]                   {
[16:22:07.508]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:07.508]                     NULL
[16:22:07.508]                   }
[16:22:07.508]                   options(future.plan = NULL)
[16:22:07.508]                   if (is.na(NA_character_)) 
[16:22:07.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:07.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:07.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:07.508]                     .init = FALSE)
[16:22:07.508]                 }
[16:22:07.508]             }
[16:22:07.508]         }
[16:22:07.508]     })
[16:22:07.508]     if (TRUE) {
[16:22:07.508]         base::sink(type = "output", split = FALSE)
[16:22:07.508]         if (TRUE) {
[16:22:07.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:07.508]         }
[16:22:07.508]         else {
[16:22:07.508]             ...future.result["stdout"] <- base::list(NULL)
[16:22:07.508]         }
[16:22:07.508]         base::close(...future.stdout)
[16:22:07.508]         ...future.stdout <- NULL
[16:22:07.508]     }
[16:22:07.508]     ...future.result$conditions <- ...future.conditions
[16:22:07.508]     ...future.result$finished <- base::Sys.time()
[16:22:07.508]     ...future.result
[16:22:07.508] }
[16:22:07.511] MultisessionFuture started
[16:22:07.512] - Launch lazy future ... done
[16:22:07.512] run() for ‘MultisessionFuture’ ... done
[16:22:08.014] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.014] - Validating connection of MultisessionFuture
[16:22:08.015] - received message: FutureResult
[16:22:08.015] - Received FutureResult
[16:22:08.015] - Erased future from FutureRegistry
[16:22:08.015] result() for ClusterFuture ...
[16:22:08.016] - result already collected: FutureResult
[16:22:08.016] result() for ClusterFuture ... done
[16:22:08.016] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.016] resolve() on list ...
[16:22:08.016]  recursive: Inf
[16:22:08.016]  length: 2
[16:22:08.016]  elements: ‘a’, ‘b’
[16:22:08.016]  length: 1 (resolved future 1)
[16:22:08.016]  length: 0 (resolved future 2)
[16:22:08.017] resolve() on list ... DONE
[16:22:08.017] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:22:08.017] getGlobalsAndPackages() ...
[16:22:08.017] Searching for globals...
[16:22:08.018] - globals found: [2] ‘list’, ‘stop’
[16:22:08.018] Searching for globals ... DONE
[16:22:08.018] Resolving globals: FALSE
[16:22:08.018] 
[16:22:08.018] 
[16:22:08.018] getGlobalsAndPackages() ... DONE
[16:22:08.019] run() for ‘Future’ ...
[16:22:08.019] - state: ‘created’
[16:22:08.019] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.033] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.033]   - Field: ‘node’
[16:22:08.033]   - Field: ‘label’
[16:22:08.033]   - Field: ‘local’
[16:22:08.033]   - Field: ‘owner’
[16:22:08.033]   - Field: ‘envir’
[16:22:08.033]   - Field: ‘workers’
[16:22:08.033]   - Field: ‘packages’
[16:22:08.034]   - Field: ‘gc’
[16:22:08.034]   - Field: ‘conditions’
[16:22:08.034]   - Field: ‘persistent’
[16:22:08.034]   - Field: ‘expr’
[16:22:08.034]   - Field: ‘uuid’
[16:22:08.034]   - Field: ‘seed’
[16:22:08.034]   - Field: ‘version’
[16:22:08.034]   - Field: ‘result’
[16:22:08.034]   - Field: ‘asynchronous’
[16:22:08.034]   - Field: ‘calls’
[16:22:08.034]   - Field: ‘globals’
[16:22:08.035]   - Field: ‘stdout’
[16:22:08.035]   - Field: ‘earlySignal’
[16:22:08.035]   - Field: ‘lazy’
[16:22:08.035]   - Field: ‘state’
[16:22:08.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.035] - Launch lazy future ...
[16:22:08.035] Packages needed by the future expression (n = 0): <none>
[16:22:08.035] Packages needed by future strategies (n = 0): <none>
[16:22:08.036] {
[16:22:08.036]     {
[16:22:08.036]         {
[16:22:08.036]             ...future.startTime <- base::Sys.time()
[16:22:08.036]             {
[16:22:08.036]                 {
[16:22:08.036]                   {
[16:22:08.036]                     {
[16:22:08.036]                       base::local({
[16:22:08.036]                         has_future <- base::requireNamespace("future", 
[16:22:08.036]                           quietly = TRUE)
[16:22:08.036]                         if (has_future) {
[16:22:08.036]                           ns <- base::getNamespace("future")
[16:22:08.036]                           version <- ns[[".package"]][["version"]]
[16:22:08.036]                           if (is.null(version)) 
[16:22:08.036]                             version <- utils::packageVersion("future")
[16:22:08.036]                         }
[16:22:08.036]                         else {
[16:22:08.036]                           version <- NULL
[16:22:08.036]                         }
[16:22:08.036]                         if (!has_future || version < "1.8.0") {
[16:22:08.036]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.036]                             "", base::R.version$version.string), 
[16:22:08.036]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.036]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.036]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.036]                               "release", "version")], collapse = " "), 
[16:22:08.036]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.036]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.036]                             info)
[16:22:08.036]                           info <- base::paste(info, collapse = "; ")
[16:22:08.036]                           if (!has_future) {
[16:22:08.036]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.036]                               info)
[16:22:08.036]                           }
[16:22:08.036]                           else {
[16:22:08.036]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.036]                               info, version)
[16:22:08.036]                           }
[16:22:08.036]                           base::stop(msg)
[16:22:08.036]                         }
[16:22:08.036]                       })
[16:22:08.036]                     }
[16:22:08.036]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.036]                     base::options(mc.cores = 1L)
[16:22:08.036]                   }
[16:22:08.036]                   ...future.strategy.old <- future::plan("list")
[16:22:08.036]                   options(future.plan = NULL)
[16:22:08.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.036]                 }
[16:22:08.036]                 ...future.workdir <- getwd()
[16:22:08.036]             }
[16:22:08.036]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.036]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.036]         }
[16:22:08.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.036]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.036]             base::names(...future.oldOptions))
[16:22:08.036]     }
[16:22:08.036]     if (FALSE) {
[16:22:08.036]     }
[16:22:08.036]     else {
[16:22:08.036]         if (TRUE) {
[16:22:08.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.036]                 open = "w")
[16:22:08.036]         }
[16:22:08.036]         else {
[16:22:08.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.036]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.036]         }
[16:22:08.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.036]             base::sink(type = "output", split = FALSE)
[16:22:08.036]             base::close(...future.stdout)
[16:22:08.036]         }, add = TRUE)
[16:22:08.036]     }
[16:22:08.036]     ...future.frame <- base::sys.nframe()
[16:22:08.036]     ...future.conditions <- base::list()
[16:22:08.036]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.036]     if (FALSE) {
[16:22:08.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.036]     }
[16:22:08.036]     ...future.result <- base::tryCatch({
[16:22:08.036]         base::withCallingHandlers({
[16:22:08.036]             ...future.value <- base::withVisible(base::local({
[16:22:08.036]                 ...future.makeSendCondition <- base::local({
[16:22:08.036]                   sendCondition <- NULL
[16:22:08.036]                   function(frame = 1L) {
[16:22:08.036]                     if (is.function(sendCondition)) 
[16:22:08.036]                       return(sendCondition)
[16:22:08.036]                     ns <- getNamespace("parallel")
[16:22:08.036]                     if (exists("sendData", mode = "function", 
[16:22:08.036]                       envir = ns)) {
[16:22:08.036]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.036]                         envir = ns)
[16:22:08.036]                       envir <- sys.frame(frame)
[16:22:08.036]                       master <- NULL
[16:22:08.036]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.036]                         !identical(envir, emptyenv())) {
[16:22:08.036]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.036]                           inherits = FALSE)) {
[16:22:08.036]                           master <- get("master", mode = "list", 
[16:22:08.036]                             envir = envir, inherits = FALSE)
[16:22:08.036]                           if (inherits(master, c("SOCKnode", 
[16:22:08.036]                             "SOCK0node"))) {
[16:22:08.036]                             sendCondition <<- function(cond) {
[16:22:08.036]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.036]                                 success = TRUE)
[16:22:08.036]                               parallel_sendData(master, data)
[16:22:08.036]                             }
[16:22:08.036]                             return(sendCondition)
[16:22:08.036]                           }
[16:22:08.036]                         }
[16:22:08.036]                         frame <- frame + 1L
[16:22:08.036]                         envir <- sys.frame(frame)
[16:22:08.036]                       }
[16:22:08.036]                     }
[16:22:08.036]                     sendCondition <<- function(cond) NULL
[16:22:08.036]                   }
[16:22:08.036]                 })
[16:22:08.036]                 withCallingHandlers({
[16:22:08.036]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:08.036]                 }, immediateCondition = function(cond) {
[16:22:08.036]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.036]                   sendCondition(cond)
[16:22:08.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.036]                   {
[16:22:08.036]                     inherits <- base::inherits
[16:22:08.036]                     invokeRestart <- base::invokeRestart
[16:22:08.036]                     is.null <- base::is.null
[16:22:08.036]                     muffled <- FALSE
[16:22:08.036]                     if (inherits(cond, "message")) {
[16:22:08.036]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.036]                       if (muffled) 
[16:22:08.036]                         invokeRestart("muffleMessage")
[16:22:08.036]                     }
[16:22:08.036]                     else if (inherits(cond, "warning")) {
[16:22:08.036]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.036]                       if (muffled) 
[16:22:08.036]                         invokeRestart("muffleWarning")
[16:22:08.036]                     }
[16:22:08.036]                     else if (inherits(cond, "condition")) {
[16:22:08.036]                       if (!is.null(pattern)) {
[16:22:08.036]                         computeRestarts <- base::computeRestarts
[16:22:08.036]                         grepl <- base::grepl
[16:22:08.036]                         restarts <- computeRestarts(cond)
[16:22:08.036]                         for (restart in restarts) {
[16:22:08.036]                           name <- restart$name
[16:22:08.036]                           if (is.null(name)) 
[16:22:08.036]                             next
[16:22:08.036]                           if (!grepl(pattern, name)) 
[16:22:08.036]                             next
[16:22:08.036]                           invokeRestart(restart)
[16:22:08.036]                           muffled <- TRUE
[16:22:08.036]                           break
[16:22:08.036]                         }
[16:22:08.036]                       }
[16:22:08.036]                     }
[16:22:08.036]                     invisible(muffled)
[16:22:08.036]                   }
[16:22:08.036]                   muffleCondition(cond)
[16:22:08.036]                 })
[16:22:08.036]             }))
[16:22:08.036]             future::FutureResult(value = ...future.value$value, 
[16:22:08.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.036]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.036]                     ...future.globalenv.names))
[16:22:08.036]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.036]         }, condition = base::local({
[16:22:08.036]             c <- base::c
[16:22:08.036]             inherits <- base::inherits
[16:22:08.036]             invokeRestart <- base::invokeRestart
[16:22:08.036]             length <- base::length
[16:22:08.036]             list <- base::list
[16:22:08.036]             seq.int <- base::seq.int
[16:22:08.036]             signalCondition <- base::signalCondition
[16:22:08.036]             sys.calls <- base::sys.calls
[16:22:08.036]             `[[` <- base::`[[`
[16:22:08.036]             `+` <- base::`+`
[16:22:08.036]             `<<-` <- base::`<<-`
[16:22:08.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.036]                   3L)]
[16:22:08.036]             }
[16:22:08.036]             function(cond) {
[16:22:08.036]                 is_error <- inherits(cond, "error")
[16:22:08.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.036]                   NULL)
[16:22:08.036]                 if (is_error) {
[16:22:08.036]                   sessionInformation <- function() {
[16:22:08.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.036]                       search = base::search(), system = base::Sys.info())
[16:22:08.036]                   }
[16:22:08.036]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.036]                     cond$call), session = sessionInformation(), 
[16:22:08.036]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.036]                   signalCondition(cond)
[16:22:08.036]                 }
[16:22:08.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.036]                 "immediateCondition"))) {
[16:22:08.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.036]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.036]                   if (TRUE && !signal) {
[16:22:08.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.036]                     {
[16:22:08.036]                       inherits <- base::inherits
[16:22:08.036]                       invokeRestart <- base::invokeRestart
[16:22:08.036]                       is.null <- base::is.null
[16:22:08.036]                       muffled <- FALSE
[16:22:08.036]                       if (inherits(cond, "message")) {
[16:22:08.036]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.036]                         if (muffled) 
[16:22:08.036]                           invokeRestart("muffleMessage")
[16:22:08.036]                       }
[16:22:08.036]                       else if (inherits(cond, "warning")) {
[16:22:08.036]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.036]                         if (muffled) 
[16:22:08.036]                           invokeRestart("muffleWarning")
[16:22:08.036]                       }
[16:22:08.036]                       else if (inherits(cond, "condition")) {
[16:22:08.036]                         if (!is.null(pattern)) {
[16:22:08.036]                           computeRestarts <- base::computeRestarts
[16:22:08.036]                           grepl <- base::grepl
[16:22:08.036]                           restarts <- computeRestarts(cond)
[16:22:08.036]                           for (restart in restarts) {
[16:22:08.036]                             name <- restart$name
[16:22:08.036]                             if (is.null(name)) 
[16:22:08.036]                               next
[16:22:08.036]                             if (!grepl(pattern, name)) 
[16:22:08.036]                               next
[16:22:08.036]                             invokeRestart(restart)
[16:22:08.036]                             muffled <- TRUE
[16:22:08.036]                             break
[16:22:08.036]                           }
[16:22:08.036]                         }
[16:22:08.036]                       }
[16:22:08.036]                       invisible(muffled)
[16:22:08.036]                     }
[16:22:08.036]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.036]                   }
[16:22:08.036]                 }
[16:22:08.036]                 else {
[16:22:08.036]                   if (TRUE) {
[16:22:08.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.036]                     {
[16:22:08.036]                       inherits <- base::inherits
[16:22:08.036]                       invokeRestart <- base::invokeRestart
[16:22:08.036]                       is.null <- base::is.null
[16:22:08.036]                       muffled <- FALSE
[16:22:08.036]                       if (inherits(cond, "message")) {
[16:22:08.036]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.036]                         if (muffled) 
[16:22:08.036]                           invokeRestart("muffleMessage")
[16:22:08.036]                       }
[16:22:08.036]                       else if (inherits(cond, "warning")) {
[16:22:08.036]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.036]                         if (muffled) 
[16:22:08.036]                           invokeRestart("muffleWarning")
[16:22:08.036]                       }
[16:22:08.036]                       else if (inherits(cond, "condition")) {
[16:22:08.036]                         if (!is.null(pattern)) {
[16:22:08.036]                           computeRestarts <- base::computeRestarts
[16:22:08.036]                           grepl <- base::grepl
[16:22:08.036]                           restarts <- computeRestarts(cond)
[16:22:08.036]                           for (restart in restarts) {
[16:22:08.036]                             name <- restart$name
[16:22:08.036]                             if (is.null(name)) 
[16:22:08.036]                               next
[16:22:08.036]                             if (!grepl(pattern, name)) 
[16:22:08.036]                               next
[16:22:08.036]                             invokeRestart(restart)
[16:22:08.036]                             muffled <- TRUE
[16:22:08.036]                             break
[16:22:08.036]                           }
[16:22:08.036]                         }
[16:22:08.036]                       }
[16:22:08.036]                       invisible(muffled)
[16:22:08.036]                     }
[16:22:08.036]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.036]                   }
[16:22:08.036]                 }
[16:22:08.036]             }
[16:22:08.036]         }))
[16:22:08.036]     }, error = function(ex) {
[16:22:08.036]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.036]                 ...future.rng), started = ...future.startTime, 
[16:22:08.036]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.036]             version = "1.8"), class = "FutureResult")
[16:22:08.036]     }, finally = {
[16:22:08.036]         if (!identical(...future.workdir, getwd())) 
[16:22:08.036]             setwd(...future.workdir)
[16:22:08.036]         {
[16:22:08.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.036]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.036]             }
[16:22:08.036]             base::options(...future.oldOptions)
[16:22:08.036]             if (.Platform$OS.type == "windows") {
[16:22:08.036]                 old_names <- names(...future.oldEnvVars)
[16:22:08.036]                 envs <- base::Sys.getenv()
[16:22:08.036]                 names <- names(envs)
[16:22:08.036]                 common <- intersect(names, old_names)
[16:22:08.036]                 added <- setdiff(names, old_names)
[16:22:08.036]                 removed <- setdiff(old_names, names)
[16:22:08.036]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.036]                   envs[common]]
[16:22:08.036]                 NAMES <- toupper(changed)
[16:22:08.036]                 args <- list()
[16:22:08.036]                 for (kk in seq_along(NAMES)) {
[16:22:08.036]                   name <- changed[[kk]]
[16:22:08.036]                   NAME <- NAMES[[kk]]
[16:22:08.036]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.036]                     next
[16:22:08.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.036]                 }
[16:22:08.036]                 NAMES <- toupper(added)
[16:22:08.036]                 for (kk in seq_along(NAMES)) {
[16:22:08.036]                   name <- added[[kk]]
[16:22:08.036]                   NAME <- NAMES[[kk]]
[16:22:08.036]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.036]                     next
[16:22:08.036]                   args[[name]] <- ""
[16:22:08.036]                 }
[16:22:08.036]                 NAMES <- toupper(removed)
[16:22:08.036]                 for (kk in seq_along(NAMES)) {
[16:22:08.036]                   name <- removed[[kk]]
[16:22:08.036]                   NAME <- NAMES[[kk]]
[16:22:08.036]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.036]                     next
[16:22:08.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.036]                 }
[16:22:08.036]                 if (length(args) > 0) 
[16:22:08.036]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.036]             }
[16:22:08.036]             else {
[16:22:08.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.036]             }
[16:22:08.036]             {
[16:22:08.036]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.036]                   0L) {
[16:22:08.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.036]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.036]                   base::options(opts)
[16:22:08.036]                 }
[16:22:08.036]                 {
[16:22:08.036]                   {
[16:22:08.036]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.036]                     NULL
[16:22:08.036]                   }
[16:22:08.036]                   options(future.plan = NULL)
[16:22:08.036]                   if (is.na(NA_character_)) 
[16:22:08.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.036]                     .init = FALSE)
[16:22:08.036]                 }
[16:22:08.036]             }
[16:22:08.036]         }
[16:22:08.036]     })
[16:22:08.036]     if (TRUE) {
[16:22:08.036]         base::sink(type = "output", split = FALSE)
[16:22:08.036]         if (TRUE) {
[16:22:08.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.036]         }
[16:22:08.036]         else {
[16:22:08.036]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.036]         }
[16:22:08.036]         base::close(...future.stdout)
[16:22:08.036]         ...future.stdout <- NULL
[16:22:08.036]     }
[16:22:08.036]     ...future.result$conditions <- ...future.conditions
[16:22:08.036]     ...future.result$finished <- base::Sys.time()
[16:22:08.036]     ...future.result
[16:22:08.036] }
[16:22:08.039] MultisessionFuture started
[16:22:08.039] - Launch lazy future ... done
[16:22:08.039] run() for ‘MultisessionFuture’ ... done
[16:22:08.040] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.041] - Validating connection of MultisessionFuture
[16:22:08.041] - received message: FutureResult
[16:22:08.041] - Received FutureResult
[16:22:08.041] - Erased future from FutureRegistry
[16:22:08.041] result() for ClusterFuture ...
[16:22:08.041] - result already collected: FutureResult
[16:22:08.041] result() for ClusterFuture ... done
[16:22:08.042] signalConditions() ...
[16:22:08.042]  - include = ‘immediateCondition’
[16:22:08.042]  - exclude = 
[16:22:08.042]  - resignal = FALSE
[16:22:08.042]  - Number of conditions: 1
[16:22:08.042] signalConditions() ... done
[16:22:08.042] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.042] A MultisessionFuture was resolved
[16:22:08.042] getGlobalsAndPackages() ...
[16:22:08.042] Searching for globals...
[16:22:08.043] - globals found: [2] ‘list’, ‘stop’
[16:22:08.043] Searching for globals ... DONE
[16:22:08.043] Resolving globals: FALSE
[16:22:08.044] 
[16:22:08.044] 
[16:22:08.044] getGlobalsAndPackages() ... DONE
[16:22:08.044] run() for ‘Future’ ...
[16:22:08.044] - state: ‘created’
[16:22:08.044] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.058] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.058]   - Field: ‘node’
[16:22:08.058]   - Field: ‘label’
[16:22:08.058]   - Field: ‘local’
[16:22:08.058]   - Field: ‘owner’
[16:22:08.058]   - Field: ‘envir’
[16:22:08.058]   - Field: ‘workers’
[16:22:08.058]   - Field: ‘packages’
[16:22:08.058]   - Field: ‘gc’
[16:22:08.059]   - Field: ‘conditions’
[16:22:08.059]   - Field: ‘persistent’
[16:22:08.059]   - Field: ‘expr’
[16:22:08.059]   - Field: ‘uuid’
[16:22:08.059]   - Field: ‘seed’
[16:22:08.059]   - Field: ‘version’
[16:22:08.059]   - Field: ‘result’
[16:22:08.059]   - Field: ‘asynchronous’
[16:22:08.059]   - Field: ‘calls’
[16:22:08.059]   - Field: ‘globals’
[16:22:08.059]   - Field: ‘stdout’
[16:22:08.060]   - Field: ‘earlySignal’
[16:22:08.060]   - Field: ‘lazy’
[16:22:08.060]   - Field: ‘state’
[16:22:08.060] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.060] - Launch lazy future ...
[16:22:08.060] Packages needed by the future expression (n = 0): <none>
[16:22:08.060] Packages needed by future strategies (n = 0): <none>
[16:22:08.061] {
[16:22:08.061]     {
[16:22:08.061]         {
[16:22:08.061]             ...future.startTime <- base::Sys.time()
[16:22:08.061]             {
[16:22:08.061]                 {
[16:22:08.061]                   {
[16:22:08.061]                     {
[16:22:08.061]                       base::local({
[16:22:08.061]                         has_future <- base::requireNamespace("future", 
[16:22:08.061]                           quietly = TRUE)
[16:22:08.061]                         if (has_future) {
[16:22:08.061]                           ns <- base::getNamespace("future")
[16:22:08.061]                           version <- ns[[".package"]][["version"]]
[16:22:08.061]                           if (is.null(version)) 
[16:22:08.061]                             version <- utils::packageVersion("future")
[16:22:08.061]                         }
[16:22:08.061]                         else {
[16:22:08.061]                           version <- NULL
[16:22:08.061]                         }
[16:22:08.061]                         if (!has_future || version < "1.8.0") {
[16:22:08.061]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.061]                             "", base::R.version$version.string), 
[16:22:08.061]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.061]                               "release", "version")], collapse = " "), 
[16:22:08.061]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.061]                             info)
[16:22:08.061]                           info <- base::paste(info, collapse = "; ")
[16:22:08.061]                           if (!has_future) {
[16:22:08.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.061]                               info)
[16:22:08.061]                           }
[16:22:08.061]                           else {
[16:22:08.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.061]                               info, version)
[16:22:08.061]                           }
[16:22:08.061]                           base::stop(msg)
[16:22:08.061]                         }
[16:22:08.061]                       })
[16:22:08.061]                     }
[16:22:08.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.061]                     base::options(mc.cores = 1L)
[16:22:08.061]                   }
[16:22:08.061]                   ...future.strategy.old <- future::plan("list")
[16:22:08.061]                   options(future.plan = NULL)
[16:22:08.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.061]                 }
[16:22:08.061]                 ...future.workdir <- getwd()
[16:22:08.061]             }
[16:22:08.061]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.061]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.061]         }
[16:22:08.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.061]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.061]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.061]             base::names(...future.oldOptions))
[16:22:08.061]     }
[16:22:08.061]     if (FALSE) {
[16:22:08.061]     }
[16:22:08.061]     else {
[16:22:08.061]         if (TRUE) {
[16:22:08.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.061]                 open = "w")
[16:22:08.061]         }
[16:22:08.061]         else {
[16:22:08.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.061]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.061]         }
[16:22:08.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.061]             base::sink(type = "output", split = FALSE)
[16:22:08.061]             base::close(...future.stdout)
[16:22:08.061]         }, add = TRUE)
[16:22:08.061]     }
[16:22:08.061]     ...future.frame <- base::sys.nframe()
[16:22:08.061]     ...future.conditions <- base::list()
[16:22:08.061]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.061]     if (FALSE) {
[16:22:08.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.061]     }
[16:22:08.061]     ...future.result <- base::tryCatch({
[16:22:08.061]         base::withCallingHandlers({
[16:22:08.061]             ...future.value <- base::withVisible(base::local({
[16:22:08.061]                 ...future.makeSendCondition <- base::local({
[16:22:08.061]                   sendCondition <- NULL
[16:22:08.061]                   function(frame = 1L) {
[16:22:08.061]                     if (is.function(sendCondition)) 
[16:22:08.061]                       return(sendCondition)
[16:22:08.061]                     ns <- getNamespace("parallel")
[16:22:08.061]                     if (exists("sendData", mode = "function", 
[16:22:08.061]                       envir = ns)) {
[16:22:08.061]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.061]                         envir = ns)
[16:22:08.061]                       envir <- sys.frame(frame)
[16:22:08.061]                       master <- NULL
[16:22:08.061]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.061]                         !identical(envir, emptyenv())) {
[16:22:08.061]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.061]                           inherits = FALSE)) {
[16:22:08.061]                           master <- get("master", mode = "list", 
[16:22:08.061]                             envir = envir, inherits = FALSE)
[16:22:08.061]                           if (inherits(master, c("SOCKnode", 
[16:22:08.061]                             "SOCK0node"))) {
[16:22:08.061]                             sendCondition <<- function(cond) {
[16:22:08.061]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.061]                                 success = TRUE)
[16:22:08.061]                               parallel_sendData(master, data)
[16:22:08.061]                             }
[16:22:08.061]                             return(sendCondition)
[16:22:08.061]                           }
[16:22:08.061]                         }
[16:22:08.061]                         frame <- frame + 1L
[16:22:08.061]                         envir <- sys.frame(frame)
[16:22:08.061]                       }
[16:22:08.061]                     }
[16:22:08.061]                     sendCondition <<- function(cond) NULL
[16:22:08.061]                   }
[16:22:08.061]                 })
[16:22:08.061]                 withCallingHandlers({
[16:22:08.061]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:22:08.061]                 }, immediateCondition = function(cond) {
[16:22:08.061]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.061]                   sendCondition(cond)
[16:22:08.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.061]                   {
[16:22:08.061]                     inherits <- base::inherits
[16:22:08.061]                     invokeRestart <- base::invokeRestart
[16:22:08.061]                     is.null <- base::is.null
[16:22:08.061]                     muffled <- FALSE
[16:22:08.061]                     if (inherits(cond, "message")) {
[16:22:08.061]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.061]                       if (muffled) 
[16:22:08.061]                         invokeRestart("muffleMessage")
[16:22:08.061]                     }
[16:22:08.061]                     else if (inherits(cond, "warning")) {
[16:22:08.061]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.061]                       if (muffled) 
[16:22:08.061]                         invokeRestart("muffleWarning")
[16:22:08.061]                     }
[16:22:08.061]                     else if (inherits(cond, "condition")) {
[16:22:08.061]                       if (!is.null(pattern)) {
[16:22:08.061]                         computeRestarts <- base::computeRestarts
[16:22:08.061]                         grepl <- base::grepl
[16:22:08.061]                         restarts <- computeRestarts(cond)
[16:22:08.061]                         for (restart in restarts) {
[16:22:08.061]                           name <- restart$name
[16:22:08.061]                           if (is.null(name)) 
[16:22:08.061]                             next
[16:22:08.061]                           if (!grepl(pattern, name)) 
[16:22:08.061]                             next
[16:22:08.061]                           invokeRestart(restart)
[16:22:08.061]                           muffled <- TRUE
[16:22:08.061]                           break
[16:22:08.061]                         }
[16:22:08.061]                       }
[16:22:08.061]                     }
[16:22:08.061]                     invisible(muffled)
[16:22:08.061]                   }
[16:22:08.061]                   muffleCondition(cond)
[16:22:08.061]                 })
[16:22:08.061]             }))
[16:22:08.061]             future::FutureResult(value = ...future.value$value, 
[16:22:08.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.061]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.061]                     ...future.globalenv.names))
[16:22:08.061]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.061]         }, condition = base::local({
[16:22:08.061]             c <- base::c
[16:22:08.061]             inherits <- base::inherits
[16:22:08.061]             invokeRestart <- base::invokeRestart
[16:22:08.061]             length <- base::length
[16:22:08.061]             list <- base::list
[16:22:08.061]             seq.int <- base::seq.int
[16:22:08.061]             signalCondition <- base::signalCondition
[16:22:08.061]             sys.calls <- base::sys.calls
[16:22:08.061]             `[[` <- base::`[[`
[16:22:08.061]             `+` <- base::`+`
[16:22:08.061]             `<<-` <- base::`<<-`
[16:22:08.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.061]                   3L)]
[16:22:08.061]             }
[16:22:08.061]             function(cond) {
[16:22:08.061]                 is_error <- inherits(cond, "error")
[16:22:08.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.061]                   NULL)
[16:22:08.061]                 if (is_error) {
[16:22:08.061]                   sessionInformation <- function() {
[16:22:08.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.061]                       search = base::search(), system = base::Sys.info())
[16:22:08.061]                   }
[16:22:08.061]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.061]                     cond$call), session = sessionInformation(), 
[16:22:08.061]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.061]                   signalCondition(cond)
[16:22:08.061]                 }
[16:22:08.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.061]                 "immediateCondition"))) {
[16:22:08.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.061]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.061]                   if (TRUE && !signal) {
[16:22:08.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.061]                     {
[16:22:08.061]                       inherits <- base::inherits
[16:22:08.061]                       invokeRestart <- base::invokeRestart
[16:22:08.061]                       is.null <- base::is.null
[16:22:08.061]                       muffled <- FALSE
[16:22:08.061]                       if (inherits(cond, "message")) {
[16:22:08.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.061]                         if (muffled) 
[16:22:08.061]                           invokeRestart("muffleMessage")
[16:22:08.061]                       }
[16:22:08.061]                       else if (inherits(cond, "warning")) {
[16:22:08.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.061]                         if (muffled) 
[16:22:08.061]                           invokeRestart("muffleWarning")
[16:22:08.061]                       }
[16:22:08.061]                       else if (inherits(cond, "condition")) {
[16:22:08.061]                         if (!is.null(pattern)) {
[16:22:08.061]                           computeRestarts <- base::computeRestarts
[16:22:08.061]                           grepl <- base::grepl
[16:22:08.061]                           restarts <- computeRestarts(cond)
[16:22:08.061]                           for (restart in restarts) {
[16:22:08.061]                             name <- restart$name
[16:22:08.061]                             if (is.null(name)) 
[16:22:08.061]                               next
[16:22:08.061]                             if (!grepl(pattern, name)) 
[16:22:08.061]                               next
[16:22:08.061]                             invokeRestart(restart)
[16:22:08.061]                             muffled <- TRUE
[16:22:08.061]                             break
[16:22:08.061]                           }
[16:22:08.061]                         }
[16:22:08.061]                       }
[16:22:08.061]                       invisible(muffled)
[16:22:08.061]                     }
[16:22:08.061]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.061]                   }
[16:22:08.061]                 }
[16:22:08.061]                 else {
[16:22:08.061]                   if (TRUE) {
[16:22:08.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.061]                     {
[16:22:08.061]                       inherits <- base::inherits
[16:22:08.061]                       invokeRestart <- base::invokeRestart
[16:22:08.061]                       is.null <- base::is.null
[16:22:08.061]                       muffled <- FALSE
[16:22:08.061]                       if (inherits(cond, "message")) {
[16:22:08.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.061]                         if (muffled) 
[16:22:08.061]                           invokeRestart("muffleMessage")
[16:22:08.061]                       }
[16:22:08.061]                       else if (inherits(cond, "warning")) {
[16:22:08.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.061]                         if (muffled) 
[16:22:08.061]                           invokeRestart("muffleWarning")
[16:22:08.061]                       }
[16:22:08.061]                       else if (inherits(cond, "condition")) {
[16:22:08.061]                         if (!is.null(pattern)) {
[16:22:08.061]                           computeRestarts <- base::computeRestarts
[16:22:08.061]                           grepl <- base::grepl
[16:22:08.061]                           restarts <- computeRestarts(cond)
[16:22:08.061]                           for (restart in restarts) {
[16:22:08.061]                             name <- restart$name
[16:22:08.061]                             if (is.null(name)) 
[16:22:08.061]                               next
[16:22:08.061]                             if (!grepl(pattern, name)) 
[16:22:08.061]                               next
[16:22:08.061]                             invokeRestart(restart)
[16:22:08.061]                             muffled <- TRUE
[16:22:08.061]                             break
[16:22:08.061]                           }
[16:22:08.061]                         }
[16:22:08.061]                       }
[16:22:08.061]                       invisible(muffled)
[16:22:08.061]                     }
[16:22:08.061]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.061]                   }
[16:22:08.061]                 }
[16:22:08.061]             }
[16:22:08.061]         }))
[16:22:08.061]     }, error = function(ex) {
[16:22:08.061]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.061]                 ...future.rng), started = ...future.startTime, 
[16:22:08.061]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.061]             version = "1.8"), class = "FutureResult")
[16:22:08.061]     }, finally = {
[16:22:08.061]         if (!identical(...future.workdir, getwd())) 
[16:22:08.061]             setwd(...future.workdir)
[16:22:08.061]         {
[16:22:08.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.061]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.061]             }
[16:22:08.061]             base::options(...future.oldOptions)
[16:22:08.061]             if (.Platform$OS.type == "windows") {
[16:22:08.061]                 old_names <- names(...future.oldEnvVars)
[16:22:08.061]                 envs <- base::Sys.getenv()
[16:22:08.061]                 names <- names(envs)
[16:22:08.061]                 common <- intersect(names, old_names)
[16:22:08.061]                 added <- setdiff(names, old_names)
[16:22:08.061]                 removed <- setdiff(old_names, names)
[16:22:08.061]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.061]                   envs[common]]
[16:22:08.061]                 NAMES <- toupper(changed)
[16:22:08.061]                 args <- list()
[16:22:08.061]                 for (kk in seq_along(NAMES)) {
[16:22:08.061]                   name <- changed[[kk]]
[16:22:08.061]                   NAME <- NAMES[[kk]]
[16:22:08.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.061]                     next
[16:22:08.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.061]                 }
[16:22:08.061]                 NAMES <- toupper(added)
[16:22:08.061]                 for (kk in seq_along(NAMES)) {
[16:22:08.061]                   name <- added[[kk]]
[16:22:08.061]                   NAME <- NAMES[[kk]]
[16:22:08.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.061]                     next
[16:22:08.061]                   args[[name]] <- ""
[16:22:08.061]                 }
[16:22:08.061]                 NAMES <- toupper(removed)
[16:22:08.061]                 for (kk in seq_along(NAMES)) {
[16:22:08.061]                   name <- removed[[kk]]
[16:22:08.061]                   NAME <- NAMES[[kk]]
[16:22:08.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.061]                     next
[16:22:08.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.061]                 }
[16:22:08.061]                 if (length(args) > 0) 
[16:22:08.061]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.061]             }
[16:22:08.061]             else {
[16:22:08.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.061]             }
[16:22:08.061]             {
[16:22:08.061]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.061]                   0L) {
[16:22:08.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.061]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.061]                   base::options(opts)
[16:22:08.061]                 }
[16:22:08.061]                 {
[16:22:08.061]                   {
[16:22:08.061]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.061]                     NULL
[16:22:08.061]                   }
[16:22:08.061]                   options(future.plan = NULL)
[16:22:08.061]                   if (is.na(NA_character_)) 
[16:22:08.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.061]                     .init = FALSE)
[16:22:08.061]                 }
[16:22:08.061]             }
[16:22:08.061]         }
[16:22:08.061]     })
[16:22:08.061]     if (TRUE) {
[16:22:08.061]         base::sink(type = "output", split = FALSE)
[16:22:08.061]         if (TRUE) {
[16:22:08.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.061]         }
[16:22:08.061]         else {
[16:22:08.061]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.061]         }
[16:22:08.061]         base::close(...future.stdout)
[16:22:08.061]         ...future.stdout <- NULL
[16:22:08.061]     }
[16:22:08.061]     ...future.result$conditions <- ...future.conditions
[16:22:08.061]     ...future.result$finished <- base::Sys.time()
[16:22:08.061]     ...future.result
[16:22:08.061] }
[16:22:08.064] MultisessionFuture started
[16:22:08.064] - Launch lazy future ... done
[16:22:08.064] run() for ‘MultisessionFuture’ ... done
[16:22:08.066] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.066] - Validating connection of MultisessionFuture
[16:22:08.066] - received message: FutureResult
[16:22:08.066] - Received FutureResult
[16:22:08.066] - Erased future from FutureRegistry
[16:22:08.067] result() for ClusterFuture ...
[16:22:08.067] - result already collected: FutureResult
[16:22:08.067] result() for ClusterFuture ... done
[16:22:08.067] signalConditions() ...
[16:22:08.067]  - include = ‘immediateCondition’
[16:22:08.067]  - exclude = 
[16:22:08.067]  - resignal = FALSE
[16:22:08.067]  - Number of conditions: 1
[16:22:08.067] signalConditions() ... done
[16:22:08.067] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.067] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[16:22:08.068] resolve() on list ...
[16:22:08.068]  recursive: 0
[16:22:08.068]  length: 2
[16:22:08.068]  elements: ‘a’, ‘b’
[16:22:08.068]  length: 1 (resolved future 1)
[16:22:08.068]  length: 0 (resolved future 2)
[16:22:08.068] resolve() on list ... DONE
[16:22:08.069] getGlobalsAndPackages() ...
[16:22:08.069] Searching for globals...
[16:22:08.069] 
[16:22:08.069] Searching for globals ... DONE
[16:22:08.069] - globals: [0] <none>
[16:22:08.069] getGlobalsAndPackages() ... DONE
[16:22:08.070] run() for ‘Future’ ...
[16:22:08.070] - state: ‘created’
[16:22:08.073] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.089] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.089]   - Field: ‘node’
[16:22:08.090]   - Field: ‘label’
[16:22:08.090]   - Field: ‘local’
[16:22:08.090]   - Field: ‘owner’
[16:22:08.090]   - Field: ‘envir’
[16:22:08.090]   - Field: ‘workers’
[16:22:08.090]   - Field: ‘packages’
[16:22:08.090]   - Field: ‘gc’
[16:22:08.090]   - Field: ‘conditions’
[16:22:08.090]   - Field: ‘persistent’
[16:22:08.090]   - Field: ‘expr’
[16:22:08.090]   - Field: ‘uuid’
[16:22:08.091]   - Field: ‘seed’
[16:22:08.091]   - Field: ‘version’
[16:22:08.091]   - Field: ‘result’
[16:22:08.091]   - Field: ‘asynchronous’
[16:22:08.091]   - Field: ‘calls’
[16:22:08.091]   - Field: ‘globals’
[16:22:08.091]   - Field: ‘stdout’
[16:22:08.091]   - Field: ‘earlySignal’
[16:22:08.091]   - Field: ‘lazy’
[16:22:08.091]   - Field: ‘state’
[16:22:08.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.092] - Launch lazy future ...
[16:22:08.092] Packages needed by the future expression (n = 0): <none>
[16:22:08.092] Packages needed by future strategies (n = 0): <none>
[16:22:08.092] {
[16:22:08.092]     {
[16:22:08.092]         {
[16:22:08.092]             ...future.startTime <- base::Sys.time()
[16:22:08.092]             {
[16:22:08.092]                 {
[16:22:08.092]                   {
[16:22:08.092]                     {
[16:22:08.092]                       base::local({
[16:22:08.092]                         has_future <- base::requireNamespace("future", 
[16:22:08.092]                           quietly = TRUE)
[16:22:08.092]                         if (has_future) {
[16:22:08.092]                           ns <- base::getNamespace("future")
[16:22:08.092]                           version <- ns[[".package"]][["version"]]
[16:22:08.092]                           if (is.null(version)) 
[16:22:08.092]                             version <- utils::packageVersion("future")
[16:22:08.092]                         }
[16:22:08.092]                         else {
[16:22:08.092]                           version <- NULL
[16:22:08.092]                         }
[16:22:08.092]                         if (!has_future || version < "1.8.0") {
[16:22:08.092]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.092]                             "", base::R.version$version.string), 
[16:22:08.092]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.092]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.092]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.092]                               "release", "version")], collapse = " "), 
[16:22:08.092]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.092]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.092]                             info)
[16:22:08.092]                           info <- base::paste(info, collapse = "; ")
[16:22:08.092]                           if (!has_future) {
[16:22:08.092]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.092]                               info)
[16:22:08.092]                           }
[16:22:08.092]                           else {
[16:22:08.092]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.092]                               info, version)
[16:22:08.092]                           }
[16:22:08.092]                           base::stop(msg)
[16:22:08.092]                         }
[16:22:08.092]                       })
[16:22:08.092]                     }
[16:22:08.092]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.092]                     base::options(mc.cores = 1L)
[16:22:08.092]                   }
[16:22:08.092]                   ...future.strategy.old <- future::plan("list")
[16:22:08.092]                   options(future.plan = NULL)
[16:22:08.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.092]                 }
[16:22:08.092]                 ...future.workdir <- getwd()
[16:22:08.092]             }
[16:22:08.092]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.092]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.092]         }
[16:22:08.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.092]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.092]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.092]             base::names(...future.oldOptions))
[16:22:08.092]     }
[16:22:08.092]     if (FALSE) {
[16:22:08.092]     }
[16:22:08.092]     else {
[16:22:08.092]         if (TRUE) {
[16:22:08.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.092]                 open = "w")
[16:22:08.092]         }
[16:22:08.092]         else {
[16:22:08.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.092]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.092]         }
[16:22:08.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.092]             base::sink(type = "output", split = FALSE)
[16:22:08.092]             base::close(...future.stdout)
[16:22:08.092]         }, add = TRUE)
[16:22:08.092]     }
[16:22:08.092]     ...future.frame <- base::sys.nframe()
[16:22:08.092]     ...future.conditions <- base::list()
[16:22:08.092]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.092]     if (FALSE) {
[16:22:08.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.092]     }
[16:22:08.092]     ...future.result <- base::tryCatch({
[16:22:08.092]         base::withCallingHandlers({
[16:22:08.092]             ...future.value <- base::withVisible(base::local({
[16:22:08.092]                 ...future.makeSendCondition <- base::local({
[16:22:08.092]                   sendCondition <- NULL
[16:22:08.092]                   function(frame = 1L) {
[16:22:08.092]                     if (is.function(sendCondition)) 
[16:22:08.092]                       return(sendCondition)
[16:22:08.092]                     ns <- getNamespace("parallel")
[16:22:08.092]                     if (exists("sendData", mode = "function", 
[16:22:08.092]                       envir = ns)) {
[16:22:08.092]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.092]                         envir = ns)
[16:22:08.092]                       envir <- sys.frame(frame)
[16:22:08.092]                       master <- NULL
[16:22:08.092]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.092]                         !identical(envir, emptyenv())) {
[16:22:08.092]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.092]                           inherits = FALSE)) {
[16:22:08.092]                           master <- get("master", mode = "list", 
[16:22:08.092]                             envir = envir, inherits = FALSE)
[16:22:08.092]                           if (inherits(master, c("SOCKnode", 
[16:22:08.092]                             "SOCK0node"))) {
[16:22:08.092]                             sendCondition <<- function(cond) {
[16:22:08.092]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.092]                                 success = TRUE)
[16:22:08.092]                               parallel_sendData(master, data)
[16:22:08.092]                             }
[16:22:08.092]                             return(sendCondition)
[16:22:08.092]                           }
[16:22:08.092]                         }
[16:22:08.092]                         frame <- frame + 1L
[16:22:08.092]                         envir <- sys.frame(frame)
[16:22:08.092]                       }
[16:22:08.092]                     }
[16:22:08.092]                     sendCondition <<- function(cond) NULL
[16:22:08.092]                   }
[16:22:08.092]                 })
[16:22:08.092]                 withCallingHandlers({
[16:22:08.092]                   1
[16:22:08.092]                 }, immediateCondition = function(cond) {
[16:22:08.092]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.092]                   sendCondition(cond)
[16:22:08.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.092]                   {
[16:22:08.092]                     inherits <- base::inherits
[16:22:08.092]                     invokeRestart <- base::invokeRestart
[16:22:08.092]                     is.null <- base::is.null
[16:22:08.092]                     muffled <- FALSE
[16:22:08.092]                     if (inherits(cond, "message")) {
[16:22:08.092]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.092]                       if (muffled) 
[16:22:08.092]                         invokeRestart("muffleMessage")
[16:22:08.092]                     }
[16:22:08.092]                     else if (inherits(cond, "warning")) {
[16:22:08.092]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.092]                       if (muffled) 
[16:22:08.092]                         invokeRestart("muffleWarning")
[16:22:08.092]                     }
[16:22:08.092]                     else if (inherits(cond, "condition")) {
[16:22:08.092]                       if (!is.null(pattern)) {
[16:22:08.092]                         computeRestarts <- base::computeRestarts
[16:22:08.092]                         grepl <- base::grepl
[16:22:08.092]                         restarts <- computeRestarts(cond)
[16:22:08.092]                         for (restart in restarts) {
[16:22:08.092]                           name <- restart$name
[16:22:08.092]                           if (is.null(name)) 
[16:22:08.092]                             next
[16:22:08.092]                           if (!grepl(pattern, name)) 
[16:22:08.092]                             next
[16:22:08.092]                           invokeRestart(restart)
[16:22:08.092]                           muffled <- TRUE
[16:22:08.092]                           break
[16:22:08.092]                         }
[16:22:08.092]                       }
[16:22:08.092]                     }
[16:22:08.092]                     invisible(muffled)
[16:22:08.092]                   }
[16:22:08.092]                   muffleCondition(cond)
[16:22:08.092]                 })
[16:22:08.092]             }))
[16:22:08.092]             future::FutureResult(value = ...future.value$value, 
[16:22:08.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.092]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.092]                     ...future.globalenv.names))
[16:22:08.092]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.092]         }, condition = base::local({
[16:22:08.092]             c <- base::c
[16:22:08.092]             inherits <- base::inherits
[16:22:08.092]             invokeRestart <- base::invokeRestart
[16:22:08.092]             length <- base::length
[16:22:08.092]             list <- base::list
[16:22:08.092]             seq.int <- base::seq.int
[16:22:08.092]             signalCondition <- base::signalCondition
[16:22:08.092]             sys.calls <- base::sys.calls
[16:22:08.092]             `[[` <- base::`[[`
[16:22:08.092]             `+` <- base::`+`
[16:22:08.092]             `<<-` <- base::`<<-`
[16:22:08.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.092]                   3L)]
[16:22:08.092]             }
[16:22:08.092]             function(cond) {
[16:22:08.092]                 is_error <- inherits(cond, "error")
[16:22:08.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.092]                   NULL)
[16:22:08.092]                 if (is_error) {
[16:22:08.092]                   sessionInformation <- function() {
[16:22:08.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.092]                       search = base::search(), system = base::Sys.info())
[16:22:08.092]                   }
[16:22:08.092]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.092]                     cond$call), session = sessionInformation(), 
[16:22:08.092]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.092]                   signalCondition(cond)
[16:22:08.092]                 }
[16:22:08.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.092]                 "immediateCondition"))) {
[16:22:08.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.092]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.092]                   if (TRUE && !signal) {
[16:22:08.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.092]                     {
[16:22:08.092]                       inherits <- base::inherits
[16:22:08.092]                       invokeRestart <- base::invokeRestart
[16:22:08.092]                       is.null <- base::is.null
[16:22:08.092]                       muffled <- FALSE
[16:22:08.092]                       if (inherits(cond, "message")) {
[16:22:08.092]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.092]                         if (muffled) 
[16:22:08.092]                           invokeRestart("muffleMessage")
[16:22:08.092]                       }
[16:22:08.092]                       else if (inherits(cond, "warning")) {
[16:22:08.092]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.092]                         if (muffled) 
[16:22:08.092]                           invokeRestart("muffleWarning")
[16:22:08.092]                       }
[16:22:08.092]                       else if (inherits(cond, "condition")) {
[16:22:08.092]                         if (!is.null(pattern)) {
[16:22:08.092]                           computeRestarts <- base::computeRestarts
[16:22:08.092]                           grepl <- base::grepl
[16:22:08.092]                           restarts <- computeRestarts(cond)
[16:22:08.092]                           for (restart in restarts) {
[16:22:08.092]                             name <- restart$name
[16:22:08.092]                             if (is.null(name)) 
[16:22:08.092]                               next
[16:22:08.092]                             if (!grepl(pattern, name)) 
[16:22:08.092]                               next
[16:22:08.092]                             invokeRestart(restart)
[16:22:08.092]                             muffled <- TRUE
[16:22:08.092]                             break
[16:22:08.092]                           }
[16:22:08.092]                         }
[16:22:08.092]                       }
[16:22:08.092]                       invisible(muffled)
[16:22:08.092]                     }
[16:22:08.092]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.092]                   }
[16:22:08.092]                 }
[16:22:08.092]                 else {
[16:22:08.092]                   if (TRUE) {
[16:22:08.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.092]                     {
[16:22:08.092]                       inherits <- base::inherits
[16:22:08.092]                       invokeRestart <- base::invokeRestart
[16:22:08.092]                       is.null <- base::is.null
[16:22:08.092]                       muffled <- FALSE
[16:22:08.092]                       if (inherits(cond, "message")) {
[16:22:08.092]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.092]                         if (muffled) 
[16:22:08.092]                           invokeRestart("muffleMessage")
[16:22:08.092]                       }
[16:22:08.092]                       else if (inherits(cond, "warning")) {
[16:22:08.092]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.092]                         if (muffled) 
[16:22:08.092]                           invokeRestart("muffleWarning")
[16:22:08.092]                       }
[16:22:08.092]                       else if (inherits(cond, "condition")) {
[16:22:08.092]                         if (!is.null(pattern)) {
[16:22:08.092]                           computeRestarts <- base::computeRestarts
[16:22:08.092]                           grepl <- base::grepl
[16:22:08.092]                           restarts <- computeRestarts(cond)
[16:22:08.092]                           for (restart in restarts) {
[16:22:08.092]                             name <- restart$name
[16:22:08.092]                             if (is.null(name)) 
[16:22:08.092]                               next
[16:22:08.092]                             if (!grepl(pattern, name)) 
[16:22:08.092]                               next
[16:22:08.092]                             invokeRestart(restart)
[16:22:08.092]                             muffled <- TRUE
[16:22:08.092]                             break
[16:22:08.092]                           }
[16:22:08.092]                         }
[16:22:08.092]                       }
[16:22:08.092]                       invisible(muffled)
[16:22:08.092]                     }
[16:22:08.092]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.092]                   }
[16:22:08.092]                 }
[16:22:08.092]             }
[16:22:08.092]         }))
[16:22:08.092]     }, error = function(ex) {
[16:22:08.092]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.092]                 ...future.rng), started = ...future.startTime, 
[16:22:08.092]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.092]             version = "1.8"), class = "FutureResult")
[16:22:08.092]     }, finally = {
[16:22:08.092]         if (!identical(...future.workdir, getwd())) 
[16:22:08.092]             setwd(...future.workdir)
[16:22:08.092]         {
[16:22:08.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.092]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.092]             }
[16:22:08.092]             base::options(...future.oldOptions)
[16:22:08.092]             if (.Platform$OS.type == "windows") {
[16:22:08.092]                 old_names <- names(...future.oldEnvVars)
[16:22:08.092]                 envs <- base::Sys.getenv()
[16:22:08.092]                 names <- names(envs)
[16:22:08.092]                 common <- intersect(names, old_names)
[16:22:08.092]                 added <- setdiff(names, old_names)
[16:22:08.092]                 removed <- setdiff(old_names, names)
[16:22:08.092]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.092]                   envs[common]]
[16:22:08.092]                 NAMES <- toupper(changed)
[16:22:08.092]                 args <- list()
[16:22:08.092]                 for (kk in seq_along(NAMES)) {
[16:22:08.092]                   name <- changed[[kk]]
[16:22:08.092]                   NAME <- NAMES[[kk]]
[16:22:08.092]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.092]                     next
[16:22:08.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.092]                 }
[16:22:08.092]                 NAMES <- toupper(added)
[16:22:08.092]                 for (kk in seq_along(NAMES)) {
[16:22:08.092]                   name <- added[[kk]]
[16:22:08.092]                   NAME <- NAMES[[kk]]
[16:22:08.092]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.092]                     next
[16:22:08.092]                   args[[name]] <- ""
[16:22:08.092]                 }
[16:22:08.092]                 NAMES <- toupper(removed)
[16:22:08.092]                 for (kk in seq_along(NAMES)) {
[16:22:08.092]                   name <- removed[[kk]]
[16:22:08.092]                   NAME <- NAMES[[kk]]
[16:22:08.092]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.092]                     next
[16:22:08.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.092]                 }
[16:22:08.092]                 if (length(args) > 0) 
[16:22:08.092]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.092]             }
[16:22:08.092]             else {
[16:22:08.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.092]             }
[16:22:08.092]             {
[16:22:08.092]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.092]                   0L) {
[16:22:08.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.092]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.092]                   base::options(opts)
[16:22:08.092]                 }
[16:22:08.092]                 {
[16:22:08.092]                   {
[16:22:08.092]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.092]                     NULL
[16:22:08.092]                   }
[16:22:08.092]                   options(future.plan = NULL)
[16:22:08.092]                   if (is.na(NA_character_)) 
[16:22:08.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.092]                     .init = FALSE)
[16:22:08.092]                 }
[16:22:08.092]             }
[16:22:08.092]         }
[16:22:08.092]     })
[16:22:08.092]     if (TRUE) {
[16:22:08.092]         base::sink(type = "output", split = FALSE)
[16:22:08.092]         if (TRUE) {
[16:22:08.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.092]         }
[16:22:08.092]         else {
[16:22:08.092]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.092]         }
[16:22:08.092]         base::close(...future.stdout)
[16:22:08.092]         ...future.stdout <- NULL
[16:22:08.092]     }
[16:22:08.092]     ...future.result$conditions <- ...future.conditions
[16:22:08.092]     ...future.result$finished <- base::Sys.time()
[16:22:08.092]     ...future.result
[16:22:08.092] }
[16:22:08.095] MultisessionFuture started
[16:22:08.096] - Launch lazy future ... done
[16:22:08.096] run() for ‘MultisessionFuture’ ... done
[16:22:08.096] getGlobalsAndPackages() ...
[16:22:08.096] Searching for globals...
[16:22:08.097] 
[16:22:08.097] Searching for globals ... DONE
[16:22:08.097] - globals: [0] <none>
[16:22:08.097] getGlobalsAndPackages() ... DONE
[16:22:08.097] run() for ‘Future’ ...
[16:22:08.098] - state: ‘created’
[16:22:08.098] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.111] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.112]   - Field: ‘node’
[16:22:08.112]   - Field: ‘label’
[16:22:08.112]   - Field: ‘local’
[16:22:08.112]   - Field: ‘owner’
[16:22:08.112]   - Field: ‘envir’
[16:22:08.112]   - Field: ‘workers’
[16:22:08.112]   - Field: ‘packages’
[16:22:08.112]   - Field: ‘gc’
[16:22:08.113]   - Field: ‘conditions’
[16:22:08.113]   - Field: ‘persistent’
[16:22:08.113]   - Field: ‘expr’
[16:22:08.113]   - Field: ‘uuid’
[16:22:08.113]   - Field: ‘seed’
[16:22:08.113]   - Field: ‘version’
[16:22:08.113]   - Field: ‘result’
[16:22:08.113]   - Field: ‘asynchronous’
[16:22:08.113]   - Field: ‘calls’
[16:22:08.113]   - Field: ‘globals’
[16:22:08.113]   - Field: ‘stdout’
[16:22:08.113]   - Field: ‘earlySignal’
[16:22:08.114]   - Field: ‘lazy’
[16:22:08.114]   - Field: ‘state’
[16:22:08.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.114] - Launch lazy future ...
[16:22:08.114] Packages needed by the future expression (n = 0): <none>
[16:22:08.114] Packages needed by future strategies (n = 0): <none>
[16:22:08.115] {
[16:22:08.115]     {
[16:22:08.115]         {
[16:22:08.115]             ...future.startTime <- base::Sys.time()
[16:22:08.115]             {
[16:22:08.115]                 {
[16:22:08.115]                   {
[16:22:08.115]                     {
[16:22:08.115]                       base::local({
[16:22:08.115]                         has_future <- base::requireNamespace("future", 
[16:22:08.115]                           quietly = TRUE)
[16:22:08.115]                         if (has_future) {
[16:22:08.115]                           ns <- base::getNamespace("future")
[16:22:08.115]                           version <- ns[[".package"]][["version"]]
[16:22:08.115]                           if (is.null(version)) 
[16:22:08.115]                             version <- utils::packageVersion("future")
[16:22:08.115]                         }
[16:22:08.115]                         else {
[16:22:08.115]                           version <- NULL
[16:22:08.115]                         }
[16:22:08.115]                         if (!has_future || version < "1.8.0") {
[16:22:08.115]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.115]                             "", base::R.version$version.string), 
[16:22:08.115]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.115]                               "release", "version")], collapse = " "), 
[16:22:08.115]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.115]                             info)
[16:22:08.115]                           info <- base::paste(info, collapse = "; ")
[16:22:08.115]                           if (!has_future) {
[16:22:08.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.115]                               info)
[16:22:08.115]                           }
[16:22:08.115]                           else {
[16:22:08.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.115]                               info, version)
[16:22:08.115]                           }
[16:22:08.115]                           base::stop(msg)
[16:22:08.115]                         }
[16:22:08.115]                       })
[16:22:08.115]                     }
[16:22:08.115]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.115]                     base::options(mc.cores = 1L)
[16:22:08.115]                   }
[16:22:08.115]                   ...future.strategy.old <- future::plan("list")
[16:22:08.115]                   options(future.plan = NULL)
[16:22:08.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.115]                 }
[16:22:08.115]                 ...future.workdir <- getwd()
[16:22:08.115]             }
[16:22:08.115]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.115]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.115]         }
[16:22:08.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.115]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.115]             base::names(...future.oldOptions))
[16:22:08.115]     }
[16:22:08.115]     if (FALSE) {
[16:22:08.115]     }
[16:22:08.115]     else {
[16:22:08.115]         if (TRUE) {
[16:22:08.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.115]                 open = "w")
[16:22:08.115]         }
[16:22:08.115]         else {
[16:22:08.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.115]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.115]         }
[16:22:08.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.115]             base::sink(type = "output", split = FALSE)
[16:22:08.115]             base::close(...future.stdout)
[16:22:08.115]         }, add = TRUE)
[16:22:08.115]     }
[16:22:08.115]     ...future.frame <- base::sys.nframe()
[16:22:08.115]     ...future.conditions <- base::list()
[16:22:08.115]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.115]     if (FALSE) {
[16:22:08.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.115]     }
[16:22:08.115]     ...future.result <- base::tryCatch({
[16:22:08.115]         base::withCallingHandlers({
[16:22:08.115]             ...future.value <- base::withVisible(base::local({
[16:22:08.115]                 ...future.makeSendCondition <- base::local({
[16:22:08.115]                   sendCondition <- NULL
[16:22:08.115]                   function(frame = 1L) {
[16:22:08.115]                     if (is.function(sendCondition)) 
[16:22:08.115]                       return(sendCondition)
[16:22:08.115]                     ns <- getNamespace("parallel")
[16:22:08.115]                     if (exists("sendData", mode = "function", 
[16:22:08.115]                       envir = ns)) {
[16:22:08.115]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.115]                         envir = ns)
[16:22:08.115]                       envir <- sys.frame(frame)
[16:22:08.115]                       master <- NULL
[16:22:08.115]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.115]                         !identical(envir, emptyenv())) {
[16:22:08.115]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.115]                           inherits = FALSE)) {
[16:22:08.115]                           master <- get("master", mode = "list", 
[16:22:08.115]                             envir = envir, inherits = FALSE)
[16:22:08.115]                           if (inherits(master, c("SOCKnode", 
[16:22:08.115]                             "SOCK0node"))) {
[16:22:08.115]                             sendCondition <<- function(cond) {
[16:22:08.115]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.115]                                 success = TRUE)
[16:22:08.115]                               parallel_sendData(master, data)
[16:22:08.115]                             }
[16:22:08.115]                             return(sendCondition)
[16:22:08.115]                           }
[16:22:08.115]                         }
[16:22:08.115]                         frame <- frame + 1L
[16:22:08.115]                         envir <- sys.frame(frame)
[16:22:08.115]                       }
[16:22:08.115]                     }
[16:22:08.115]                     sendCondition <<- function(cond) NULL
[16:22:08.115]                   }
[16:22:08.115]                 })
[16:22:08.115]                 withCallingHandlers({
[16:22:08.115]                   2
[16:22:08.115]                 }, immediateCondition = function(cond) {
[16:22:08.115]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.115]                   sendCondition(cond)
[16:22:08.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.115]                   {
[16:22:08.115]                     inherits <- base::inherits
[16:22:08.115]                     invokeRestart <- base::invokeRestart
[16:22:08.115]                     is.null <- base::is.null
[16:22:08.115]                     muffled <- FALSE
[16:22:08.115]                     if (inherits(cond, "message")) {
[16:22:08.115]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.115]                       if (muffled) 
[16:22:08.115]                         invokeRestart("muffleMessage")
[16:22:08.115]                     }
[16:22:08.115]                     else if (inherits(cond, "warning")) {
[16:22:08.115]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.115]                       if (muffled) 
[16:22:08.115]                         invokeRestart("muffleWarning")
[16:22:08.115]                     }
[16:22:08.115]                     else if (inherits(cond, "condition")) {
[16:22:08.115]                       if (!is.null(pattern)) {
[16:22:08.115]                         computeRestarts <- base::computeRestarts
[16:22:08.115]                         grepl <- base::grepl
[16:22:08.115]                         restarts <- computeRestarts(cond)
[16:22:08.115]                         for (restart in restarts) {
[16:22:08.115]                           name <- restart$name
[16:22:08.115]                           if (is.null(name)) 
[16:22:08.115]                             next
[16:22:08.115]                           if (!grepl(pattern, name)) 
[16:22:08.115]                             next
[16:22:08.115]                           invokeRestart(restart)
[16:22:08.115]                           muffled <- TRUE
[16:22:08.115]                           break
[16:22:08.115]                         }
[16:22:08.115]                       }
[16:22:08.115]                     }
[16:22:08.115]                     invisible(muffled)
[16:22:08.115]                   }
[16:22:08.115]                   muffleCondition(cond)
[16:22:08.115]                 })
[16:22:08.115]             }))
[16:22:08.115]             future::FutureResult(value = ...future.value$value, 
[16:22:08.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.115]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.115]                     ...future.globalenv.names))
[16:22:08.115]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.115]         }, condition = base::local({
[16:22:08.115]             c <- base::c
[16:22:08.115]             inherits <- base::inherits
[16:22:08.115]             invokeRestart <- base::invokeRestart
[16:22:08.115]             length <- base::length
[16:22:08.115]             list <- base::list
[16:22:08.115]             seq.int <- base::seq.int
[16:22:08.115]             signalCondition <- base::signalCondition
[16:22:08.115]             sys.calls <- base::sys.calls
[16:22:08.115]             `[[` <- base::`[[`
[16:22:08.115]             `+` <- base::`+`
[16:22:08.115]             `<<-` <- base::`<<-`
[16:22:08.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.115]                   3L)]
[16:22:08.115]             }
[16:22:08.115]             function(cond) {
[16:22:08.115]                 is_error <- inherits(cond, "error")
[16:22:08.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.115]                   NULL)
[16:22:08.115]                 if (is_error) {
[16:22:08.115]                   sessionInformation <- function() {
[16:22:08.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.115]                       search = base::search(), system = base::Sys.info())
[16:22:08.115]                   }
[16:22:08.115]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.115]                     cond$call), session = sessionInformation(), 
[16:22:08.115]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.115]                   signalCondition(cond)
[16:22:08.115]                 }
[16:22:08.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.115]                 "immediateCondition"))) {
[16:22:08.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.115]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.115]                   if (TRUE && !signal) {
[16:22:08.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.115]                     {
[16:22:08.115]                       inherits <- base::inherits
[16:22:08.115]                       invokeRestart <- base::invokeRestart
[16:22:08.115]                       is.null <- base::is.null
[16:22:08.115]                       muffled <- FALSE
[16:22:08.115]                       if (inherits(cond, "message")) {
[16:22:08.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.115]                         if (muffled) 
[16:22:08.115]                           invokeRestart("muffleMessage")
[16:22:08.115]                       }
[16:22:08.115]                       else if (inherits(cond, "warning")) {
[16:22:08.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.115]                         if (muffled) 
[16:22:08.115]                           invokeRestart("muffleWarning")
[16:22:08.115]                       }
[16:22:08.115]                       else if (inherits(cond, "condition")) {
[16:22:08.115]                         if (!is.null(pattern)) {
[16:22:08.115]                           computeRestarts <- base::computeRestarts
[16:22:08.115]                           grepl <- base::grepl
[16:22:08.115]                           restarts <- computeRestarts(cond)
[16:22:08.115]                           for (restart in restarts) {
[16:22:08.115]                             name <- restart$name
[16:22:08.115]                             if (is.null(name)) 
[16:22:08.115]                               next
[16:22:08.115]                             if (!grepl(pattern, name)) 
[16:22:08.115]                               next
[16:22:08.115]                             invokeRestart(restart)
[16:22:08.115]                             muffled <- TRUE
[16:22:08.115]                             break
[16:22:08.115]                           }
[16:22:08.115]                         }
[16:22:08.115]                       }
[16:22:08.115]                       invisible(muffled)
[16:22:08.115]                     }
[16:22:08.115]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.115]                   }
[16:22:08.115]                 }
[16:22:08.115]                 else {
[16:22:08.115]                   if (TRUE) {
[16:22:08.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.115]                     {
[16:22:08.115]                       inherits <- base::inherits
[16:22:08.115]                       invokeRestart <- base::invokeRestart
[16:22:08.115]                       is.null <- base::is.null
[16:22:08.115]                       muffled <- FALSE
[16:22:08.115]                       if (inherits(cond, "message")) {
[16:22:08.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.115]                         if (muffled) 
[16:22:08.115]                           invokeRestart("muffleMessage")
[16:22:08.115]                       }
[16:22:08.115]                       else if (inherits(cond, "warning")) {
[16:22:08.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.115]                         if (muffled) 
[16:22:08.115]                           invokeRestart("muffleWarning")
[16:22:08.115]                       }
[16:22:08.115]                       else if (inherits(cond, "condition")) {
[16:22:08.115]                         if (!is.null(pattern)) {
[16:22:08.115]                           computeRestarts <- base::computeRestarts
[16:22:08.115]                           grepl <- base::grepl
[16:22:08.115]                           restarts <- computeRestarts(cond)
[16:22:08.115]                           for (restart in restarts) {
[16:22:08.115]                             name <- restart$name
[16:22:08.115]                             if (is.null(name)) 
[16:22:08.115]                               next
[16:22:08.115]                             if (!grepl(pattern, name)) 
[16:22:08.115]                               next
[16:22:08.115]                             invokeRestart(restart)
[16:22:08.115]                             muffled <- TRUE
[16:22:08.115]                             break
[16:22:08.115]                           }
[16:22:08.115]                         }
[16:22:08.115]                       }
[16:22:08.115]                       invisible(muffled)
[16:22:08.115]                     }
[16:22:08.115]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.115]                   }
[16:22:08.115]                 }
[16:22:08.115]             }
[16:22:08.115]         }))
[16:22:08.115]     }, error = function(ex) {
[16:22:08.115]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.115]                 ...future.rng), started = ...future.startTime, 
[16:22:08.115]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.115]             version = "1.8"), class = "FutureResult")
[16:22:08.115]     }, finally = {
[16:22:08.115]         if (!identical(...future.workdir, getwd())) 
[16:22:08.115]             setwd(...future.workdir)
[16:22:08.115]         {
[16:22:08.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.115]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.115]             }
[16:22:08.115]             base::options(...future.oldOptions)
[16:22:08.115]             if (.Platform$OS.type == "windows") {
[16:22:08.115]                 old_names <- names(...future.oldEnvVars)
[16:22:08.115]                 envs <- base::Sys.getenv()
[16:22:08.115]                 names <- names(envs)
[16:22:08.115]                 common <- intersect(names, old_names)
[16:22:08.115]                 added <- setdiff(names, old_names)
[16:22:08.115]                 removed <- setdiff(old_names, names)
[16:22:08.115]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.115]                   envs[common]]
[16:22:08.115]                 NAMES <- toupper(changed)
[16:22:08.115]                 args <- list()
[16:22:08.115]                 for (kk in seq_along(NAMES)) {
[16:22:08.115]                   name <- changed[[kk]]
[16:22:08.115]                   NAME <- NAMES[[kk]]
[16:22:08.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.115]                     next
[16:22:08.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.115]                 }
[16:22:08.115]                 NAMES <- toupper(added)
[16:22:08.115]                 for (kk in seq_along(NAMES)) {
[16:22:08.115]                   name <- added[[kk]]
[16:22:08.115]                   NAME <- NAMES[[kk]]
[16:22:08.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.115]                     next
[16:22:08.115]                   args[[name]] <- ""
[16:22:08.115]                 }
[16:22:08.115]                 NAMES <- toupper(removed)
[16:22:08.115]                 for (kk in seq_along(NAMES)) {
[16:22:08.115]                   name <- removed[[kk]]
[16:22:08.115]                   NAME <- NAMES[[kk]]
[16:22:08.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.115]                     next
[16:22:08.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.115]                 }
[16:22:08.115]                 if (length(args) > 0) 
[16:22:08.115]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.115]             }
[16:22:08.115]             else {
[16:22:08.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.115]             }
[16:22:08.115]             {
[16:22:08.115]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.115]                   0L) {
[16:22:08.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.115]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.115]                   base::options(opts)
[16:22:08.115]                 }
[16:22:08.115]                 {
[16:22:08.115]                   {
[16:22:08.115]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.115]                     NULL
[16:22:08.115]                   }
[16:22:08.115]                   options(future.plan = NULL)
[16:22:08.115]                   if (is.na(NA_character_)) 
[16:22:08.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.115]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.115]                     .init = FALSE)
[16:22:08.115]                 }
[16:22:08.115]             }
[16:22:08.115]         }
[16:22:08.115]     })
[16:22:08.115]     if (TRUE) {
[16:22:08.115]         base::sink(type = "output", split = FALSE)
[16:22:08.115]         if (TRUE) {
[16:22:08.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.115]         }
[16:22:08.115]         else {
[16:22:08.115]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.115]         }
[16:22:08.115]         base::close(...future.stdout)
[16:22:08.115]         ...future.stdout <- NULL
[16:22:08.115]     }
[16:22:08.115]     ...future.result$conditions <- ...future.conditions
[16:22:08.115]     ...future.result$finished <- base::Sys.time()
[16:22:08.115]     ...future.result
[16:22:08.115] }
[16:22:08.117] Poll #1 (0): usedNodes() = 2, workers = 2
[16:22:08.127] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.128] - Validating connection of MultisessionFuture
[16:22:08.128] - received message: FutureResult
[16:22:08.128] - Received FutureResult
[16:22:08.128] - Erased future from FutureRegistry
[16:22:08.128] result() for ClusterFuture ...
[16:22:08.128] - result already collected: FutureResult
[16:22:08.128] result() for ClusterFuture ... done
[16:22:08.128] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.129] result() for ClusterFuture ...
[16:22:08.129] - result already collected: FutureResult
[16:22:08.129] result() for ClusterFuture ... done
[16:22:08.129] result() for ClusterFuture ...
[16:22:08.129] - result already collected: FutureResult
[16:22:08.129] result() for ClusterFuture ... done
[16:22:08.130] MultisessionFuture started
[16:22:08.130] - Launch lazy future ... done
[16:22:08.130] run() for ‘MultisessionFuture’ ... done
[16:22:08.131] resolve() on list ...
[16:22:08.131]  recursive: 0
[16:22:08.131]  length: 3
[16:22:08.131]  elements: ‘a’, ‘b’, ‘’
[16:22:08.132] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.132] - Validating connection of MultisessionFuture
[16:22:08.132] - received message: FutureResult
[16:22:08.132] - Received FutureResult
[16:22:08.133] - Erased future from FutureRegistry
[16:22:08.133] result() for ClusterFuture ...
[16:22:08.133] - result already collected: FutureResult
[16:22:08.133] result() for ClusterFuture ... done
[16:22:08.133] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.133] Future #1
[16:22:08.133]  length: 2 (resolved future 1)
[16:22:08.134] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.134] - Validating connection of MultisessionFuture
[16:22:08.134] - received message: FutureResult
[16:22:08.134] - Received FutureResult
[16:22:08.134] - Erased future from FutureRegistry
[16:22:08.134] result() for ClusterFuture ...
[16:22:08.134] - result already collected: FutureResult
[16:22:08.134] result() for ClusterFuture ... done
[16:22:08.134] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.135] Future #2
[16:22:08.135]  length: 1 (resolved future 2)
[16:22:08.135]  length: 0 (resolved future 3)
[16:22:08.135] resolve() on list ... DONE
[16:22:08.135] getGlobalsAndPackages() ...
[16:22:08.135] Searching for globals...
[16:22:08.135] 
[16:22:08.135] Searching for globals ... DONE
[16:22:08.136] - globals: [0] <none>
[16:22:08.136] getGlobalsAndPackages() ... DONE
[16:22:08.136] getGlobalsAndPackages() ...
[16:22:08.136] Searching for globals...
[16:22:08.136] 
[16:22:08.136] Searching for globals ... DONE
[16:22:08.137] - globals: [0] <none>
[16:22:08.137] getGlobalsAndPackages() ... DONE
[16:22:08.137] run() for ‘Future’ ...
[16:22:08.137] - state: ‘created’
[16:22:08.137] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.151] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.152]   - Field: ‘node’
[16:22:08.152]   - Field: ‘label’
[16:22:08.152]   - Field: ‘local’
[16:22:08.152]   - Field: ‘owner’
[16:22:08.152]   - Field: ‘envir’
[16:22:08.152]   - Field: ‘workers’
[16:22:08.152]   - Field: ‘packages’
[16:22:08.153]   - Field: ‘gc’
[16:22:08.153]   - Field: ‘conditions’
[16:22:08.153]   - Field: ‘persistent’
[16:22:08.153]   - Field: ‘expr’
[16:22:08.153]   - Field: ‘uuid’
[16:22:08.153]   - Field: ‘seed’
[16:22:08.153]   - Field: ‘version’
[16:22:08.153]   - Field: ‘result’
[16:22:08.153]   - Field: ‘asynchronous’
[16:22:08.153]   - Field: ‘calls’
[16:22:08.153]   - Field: ‘globals’
[16:22:08.154]   - Field: ‘stdout’
[16:22:08.154]   - Field: ‘earlySignal’
[16:22:08.154]   - Field: ‘lazy’
[16:22:08.154]   - Field: ‘state’
[16:22:08.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.154] - Launch lazy future ...
[16:22:08.154] Packages needed by the future expression (n = 0): <none>
[16:22:08.154] Packages needed by future strategies (n = 0): <none>
[16:22:08.155] {
[16:22:08.155]     {
[16:22:08.155]         {
[16:22:08.155]             ...future.startTime <- base::Sys.time()
[16:22:08.155]             {
[16:22:08.155]                 {
[16:22:08.155]                   {
[16:22:08.155]                     {
[16:22:08.155]                       base::local({
[16:22:08.155]                         has_future <- base::requireNamespace("future", 
[16:22:08.155]                           quietly = TRUE)
[16:22:08.155]                         if (has_future) {
[16:22:08.155]                           ns <- base::getNamespace("future")
[16:22:08.155]                           version <- ns[[".package"]][["version"]]
[16:22:08.155]                           if (is.null(version)) 
[16:22:08.155]                             version <- utils::packageVersion("future")
[16:22:08.155]                         }
[16:22:08.155]                         else {
[16:22:08.155]                           version <- NULL
[16:22:08.155]                         }
[16:22:08.155]                         if (!has_future || version < "1.8.0") {
[16:22:08.155]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.155]                             "", base::R.version$version.string), 
[16:22:08.155]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.155]                               "release", "version")], collapse = " "), 
[16:22:08.155]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.155]                             info)
[16:22:08.155]                           info <- base::paste(info, collapse = "; ")
[16:22:08.155]                           if (!has_future) {
[16:22:08.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.155]                               info)
[16:22:08.155]                           }
[16:22:08.155]                           else {
[16:22:08.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.155]                               info, version)
[16:22:08.155]                           }
[16:22:08.155]                           base::stop(msg)
[16:22:08.155]                         }
[16:22:08.155]                       })
[16:22:08.155]                     }
[16:22:08.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.155]                     base::options(mc.cores = 1L)
[16:22:08.155]                   }
[16:22:08.155]                   ...future.strategy.old <- future::plan("list")
[16:22:08.155]                   options(future.plan = NULL)
[16:22:08.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.155]                 }
[16:22:08.155]                 ...future.workdir <- getwd()
[16:22:08.155]             }
[16:22:08.155]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.155]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.155]         }
[16:22:08.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.155]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.155]             base::names(...future.oldOptions))
[16:22:08.155]     }
[16:22:08.155]     if (FALSE) {
[16:22:08.155]     }
[16:22:08.155]     else {
[16:22:08.155]         if (TRUE) {
[16:22:08.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.155]                 open = "w")
[16:22:08.155]         }
[16:22:08.155]         else {
[16:22:08.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.155]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.155]         }
[16:22:08.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.155]             base::sink(type = "output", split = FALSE)
[16:22:08.155]             base::close(...future.stdout)
[16:22:08.155]         }, add = TRUE)
[16:22:08.155]     }
[16:22:08.155]     ...future.frame <- base::sys.nframe()
[16:22:08.155]     ...future.conditions <- base::list()
[16:22:08.155]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.155]     if (FALSE) {
[16:22:08.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.155]     }
[16:22:08.155]     ...future.result <- base::tryCatch({
[16:22:08.155]         base::withCallingHandlers({
[16:22:08.155]             ...future.value <- base::withVisible(base::local({
[16:22:08.155]                 ...future.makeSendCondition <- base::local({
[16:22:08.155]                   sendCondition <- NULL
[16:22:08.155]                   function(frame = 1L) {
[16:22:08.155]                     if (is.function(sendCondition)) 
[16:22:08.155]                       return(sendCondition)
[16:22:08.155]                     ns <- getNamespace("parallel")
[16:22:08.155]                     if (exists("sendData", mode = "function", 
[16:22:08.155]                       envir = ns)) {
[16:22:08.155]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.155]                         envir = ns)
[16:22:08.155]                       envir <- sys.frame(frame)
[16:22:08.155]                       master <- NULL
[16:22:08.155]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.155]                         !identical(envir, emptyenv())) {
[16:22:08.155]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.155]                           inherits = FALSE)) {
[16:22:08.155]                           master <- get("master", mode = "list", 
[16:22:08.155]                             envir = envir, inherits = FALSE)
[16:22:08.155]                           if (inherits(master, c("SOCKnode", 
[16:22:08.155]                             "SOCK0node"))) {
[16:22:08.155]                             sendCondition <<- function(cond) {
[16:22:08.155]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.155]                                 success = TRUE)
[16:22:08.155]                               parallel_sendData(master, data)
[16:22:08.155]                             }
[16:22:08.155]                             return(sendCondition)
[16:22:08.155]                           }
[16:22:08.155]                         }
[16:22:08.155]                         frame <- frame + 1L
[16:22:08.155]                         envir <- sys.frame(frame)
[16:22:08.155]                       }
[16:22:08.155]                     }
[16:22:08.155]                     sendCondition <<- function(cond) NULL
[16:22:08.155]                   }
[16:22:08.155]                 })
[16:22:08.155]                 withCallingHandlers({
[16:22:08.155]                   2
[16:22:08.155]                 }, immediateCondition = function(cond) {
[16:22:08.155]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.155]                   sendCondition(cond)
[16:22:08.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.155]                   {
[16:22:08.155]                     inherits <- base::inherits
[16:22:08.155]                     invokeRestart <- base::invokeRestart
[16:22:08.155]                     is.null <- base::is.null
[16:22:08.155]                     muffled <- FALSE
[16:22:08.155]                     if (inherits(cond, "message")) {
[16:22:08.155]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.155]                       if (muffled) 
[16:22:08.155]                         invokeRestart("muffleMessage")
[16:22:08.155]                     }
[16:22:08.155]                     else if (inherits(cond, "warning")) {
[16:22:08.155]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.155]                       if (muffled) 
[16:22:08.155]                         invokeRestart("muffleWarning")
[16:22:08.155]                     }
[16:22:08.155]                     else if (inherits(cond, "condition")) {
[16:22:08.155]                       if (!is.null(pattern)) {
[16:22:08.155]                         computeRestarts <- base::computeRestarts
[16:22:08.155]                         grepl <- base::grepl
[16:22:08.155]                         restarts <- computeRestarts(cond)
[16:22:08.155]                         for (restart in restarts) {
[16:22:08.155]                           name <- restart$name
[16:22:08.155]                           if (is.null(name)) 
[16:22:08.155]                             next
[16:22:08.155]                           if (!grepl(pattern, name)) 
[16:22:08.155]                             next
[16:22:08.155]                           invokeRestart(restart)
[16:22:08.155]                           muffled <- TRUE
[16:22:08.155]                           break
[16:22:08.155]                         }
[16:22:08.155]                       }
[16:22:08.155]                     }
[16:22:08.155]                     invisible(muffled)
[16:22:08.155]                   }
[16:22:08.155]                   muffleCondition(cond)
[16:22:08.155]                 })
[16:22:08.155]             }))
[16:22:08.155]             future::FutureResult(value = ...future.value$value, 
[16:22:08.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.155]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.155]                     ...future.globalenv.names))
[16:22:08.155]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.155]         }, condition = base::local({
[16:22:08.155]             c <- base::c
[16:22:08.155]             inherits <- base::inherits
[16:22:08.155]             invokeRestart <- base::invokeRestart
[16:22:08.155]             length <- base::length
[16:22:08.155]             list <- base::list
[16:22:08.155]             seq.int <- base::seq.int
[16:22:08.155]             signalCondition <- base::signalCondition
[16:22:08.155]             sys.calls <- base::sys.calls
[16:22:08.155]             `[[` <- base::`[[`
[16:22:08.155]             `+` <- base::`+`
[16:22:08.155]             `<<-` <- base::`<<-`
[16:22:08.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.155]                   3L)]
[16:22:08.155]             }
[16:22:08.155]             function(cond) {
[16:22:08.155]                 is_error <- inherits(cond, "error")
[16:22:08.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.155]                   NULL)
[16:22:08.155]                 if (is_error) {
[16:22:08.155]                   sessionInformation <- function() {
[16:22:08.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.155]                       search = base::search(), system = base::Sys.info())
[16:22:08.155]                   }
[16:22:08.155]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.155]                     cond$call), session = sessionInformation(), 
[16:22:08.155]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.155]                   signalCondition(cond)
[16:22:08.155]                 }
[16:22:08.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.155]                 "immediateCondition"))) {
[16:22:08.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.155]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.155]                   if (TRUE && !signal) {
[16:22:08.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.155]                     {
[16:22:08.155]                       inherits <- base::inherits
[16:22:08.155]                       invokeRestart <- base::invokeRestart
[16:22:08.155]                       is.null <- base::is.null
[16:22:08.155]                       muffled <- FALSE
[16:22:08.155]                       if (inherits(cond, "message")) {
[16:22:08.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.155]                         if (muffled) 
[16:22:08.155]                           invokeRestart("muffleMessage")
[16:22:08.155]                       }
[16:22:08.155]                       else if (inherits(cond, "warning")) {
[16:22:08.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.155]                         if (muffled) 
[16:22:08.155]                           invokeRestart("muffleWarning")
[16:22:08.155]                       }
[16:22:08.155]                       else if (inherits(cond, "condition")) {
[16:22:08.155]                         if (!is.null(pattern)) {
[16:22:08.155]                           computeRestarts <- base::computeRestarts
[16:22:08.155]                           grepl <- base::grepl
[16:22:08.155]                           restarts <- computeRestarts(cond)
[16:22:08.155]                           for (restart in restarts) {
[16:22:08.155]                             name <- restart$name
[16:22:08.155]                             if (is.null(name)) 
[16:22:08.155]                               next
[16:22:08.155]                             if (!grepl(pattern, name)) 
[16:22:08.155]                               next
[16:22:08.155]                             invokeRestart(restart)
[16:22:08.155]                             muffled <- TRUE
[16:22:08.155]                             break
[16:22:08.155]                           }
[16:22:08.155]                         }
[16:22:08.155]                       }
[16:22:08.155]                       invisible(muffled)
[16:22:08.155]                     }
[16:22:08.155]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.155]                   }
[16:22:08.155]                 }
[16:22:08.155]                 else {
[16:22:08.155]                   if (TRUE) {
[16:22:08.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.155]                     {
[16:22:08.155]                       inherits <- base::inherits
[16:22:08.155]                       invokeRestart <- base::invokeRestart
[16:22:08.155]                       is.null <- base::is.null
[16:22:08.155]                       muffled <- FALSE
[16:22:08.155]                       if (inherits(cond, "message")) {
[16:22:08.155]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.155]                         if (muffled) 
[16:22:08.155]                           invokeRestart("muffleMessage")
[16:22:08.155]                       }
[16:22:08.155]                       else if (inherits(cond, "warning")) {
[16:22:08.155]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.155]                         if (muffled) 
[16:22:08.155]                           invokeRestart("muffleWarning")
[16:22:08.155]                       }
[16:22:08.155]                       else if (inherits(cond, "condition")) {
[16:22:08.155]                         if (!is.null(pattern)) {
[16:22:08.155]                           computeRestarts <- base::computeRestarts
[16:22:08.155]                           grepl <- base::grepl
[16:22:08.155]                           restarts <- computeRestarts(cond)
[16:22:08.155]                           for (restart in restarts) {
[16:22:08.155]                             name <- restart$name
[16:22:08.155]                             if (is.null(name)) 
[16:22:08.155]                               next
[16:22:08.155]                             if (!grepl(pattern, name)) 
[16:22:08.155]                               next
[16:22:08.155]                             invokeRestart(restart)
[16:22:08.155]                             muffled <- TRUE
[16:22:08.155]                             break
[16:22:08.155]                           }
[16:22:08.155]                         }
[16:22:08.155]                       }
[16:22:08.155]                       invisible(muffled)
[16:22:08.155]                     }
[16:22:08.155]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.155]                   }
[16:22:08.155]                 }
[16:22:08.155]             }
[16:22:08.155]         }))
[16:22:08.155]     }, error = function(ex) {
[16:22:08.155]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.155]                 ...future.rng), started = ...future.startTime, 
[16:22:08.155]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.155]             version = "1.8"), class = "FutureResult")
[16:22:08.155]     }, finally = {
[16:22:08.155]         if (!identical(...future.workdir, getwd())) 
[16:22:08.155]             setwd(...future.workdir)
[16:22:08.155]         {
[16:22:08.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.155]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.155]             }
[16:22:08.155]             base::options(...future.oldOptions)
[16:22:08.155]             if (.Platform$OS.type == "windows") {
[16:22:08.155]                 old_names <- names(...future.oldEnvVars)
[16:22:08.155]                 envs <- base::Sys.getenv()
[16:22:08.155]                 names <- names(envs)
[16:22:08.155]                 common <- intersect(names, old_names)
[16:22:08.155]                 added <- setdiff(names, old_names)
[16:22:08.155]                 removed <- setdiff(old_names, names)
[16:22:08.155]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.155]                   envs[common]]
[16:22:08.155]                 NAMES <- toupper(changed)
[16:22:08.155]                 args <- list()
[16:22:08.155]                 for (kk in seq_along(NAMES)) {
[16:22:08.155]                   name <- changed[[kk]]
[16:22:08.155]                   NAME <- NAMES[[kk]]
[16:22:08.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.155]                     next
[16:22:08.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.155]                 }
[16:22:08.155]                 NAMES <- toupper(added)
[16:22:08.155]                 for (kk in seq_along(NAMES)) {
[16:22:08.155]                   name <- added[[kk]]
[16:22:08.155]                   NAME <- NAMES[[kk]]
[16:22:08.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.155]                     next
[16:22:08.155]                   args[[name]] <- ""
[16:22:08.155]                 }
[16:22:08.155]                 NAMES <- toupper(removed)
[16:22:08.155]                 for (kk in seq_along(NAMES)) {
[16:22:08.155]                   name <- removed[[kk]]
[16:22:08.155]                   NAME <- NAMES[[kk]]
[16:22:08.155]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.155]                     next
[16:22:08.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.155]                 }
[16:22:08.155]                 if (length(args) > 0) 
[16:22:08.155]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.155]             }
[16:22:08.155]             else {
[16:22:08.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.155]             }
[16:22:08.155]             {
[16:22:08.155]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.155]                   0L) {
[16:22:08.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.155]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.155]                   base::options(opts)
[16:22:08.155]                 }
[16:22:08.155]                 {
[16:22:08.155]                   {
[16:22:08.155]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.155]                     NULL
[16:22:08.155]                   }
[16:22:08.155]                   options(future.plan = NULL)
[16:22:08.155]                   if (is.na(NA_character_)) 
[16:22:08.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.155]                     .init = FALSE)
[16:22:08.155]                 }
[16:22:08.155]             }
[16:22:08.155]         }
[16:22:08.155]     })
[16:22:08.155]     if (TRUE) {
[16:22:08.155]         base::sink(type = "output", split = FALSE)
[16:22:08.155]         if (TRUE) {
[16:22:08.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.155]         }
[16:22:08.155]         else {
[16:22:08.155]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.155]         }
[16:22:08.155]         base::close(...future.stdout)
[16:22:08.155]         ...future.stdout <- NULL
[16:22:08.155]     }
[16:22:08.155]     ...future.result$conditions <- ...future.conditions
[16:22:08.155]     ...future.result$finished <- base::Sys.time()
[16:22:08.155]     ...future.result
[16:22:08.155] }
[16:22:08.158] MultisessionFuture started
[16:22:08.158] - Launch lazy future ... done
[16:22:08.158] run() for ‘MultisessionFuture’ ... done
[16:22:08.158] resolve() on list ...
[16:22:08.158]  recursive: 0
[16:22:08.158]  length: 3
[16:22:08.158]  elements: ‘a’, ‘b’, ‘’
[16:22:08.158] run() for ‘Future’ ...
[16:22:08.158] - state: ‘created’
[16:22:08.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.172] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.172]   - Field: ‘node’
[16:22:08.173]   - Field: ‘label’
[16:22:08.173]   - Field: ‘local’
[16:22:08.173]   - Field: ‘owner’
[16:22:08.173]   - Field: ‘envir’
[16:22:08.173]   - Field: ‘workers’
[16:22:08.173]   - Field: ‘packages’
[16:22:08.173]   - Field: ‘gc’
[16:22:08.173]   - Field: ‘conditions’
[16:22:08.173]   - Field: ‘persistent’
[16:22:08.173]   - Field: ‘expr’
[16:22:08.173]   - Field: ‘uuid’
[16:22:08.174]   - Field: ‘seed’
[16:22:08.174]   - Field: ‘version’
[16:22:08.174]   - Field: ‘result’
[16:22:08.174]   - Field: ‘asynchronous’
[16:22:08.174]   - Field: ‘calls’
[16:22:08.174]   - Field: ‘globals’
[16:22:08.174]   - Field: ‘stdout’
[16:22:08.174]   - Field: ‘earlySignal’
[16:22:08.174]   - Field: ‘lazy’
[16:22:08.174]   - Field: ‘state’
[16:22:08.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.175] - Launch lazy future ...
[16:22:08.175] Packages needed by the future expression (n = 0): <none>
[16:22:08.175] Packages needed by future strategies (n = 0): <none>
[16:22:08.175] {
[16:22:08.175]     {
[16:22:08.175]         {
[16:22:08.175]             ...future.startTime <- base::Sys.time()
[16:22:08.175]             {
[16:22:08.175]                 {
[16:22:08.175]                   {
[16:22:08.175]                     {
[16:22:08.175]                       base::local({
[16:22:08.175]                         has_future <- base::requireNamespace("future", 
[16:22:08.175]                           quietly = TRUE)
[16:22:08.175]                         if (has_future) {
[16:22:08.175]                           ns <- base::getNamespace("future")
[16:22:08.175]                           version <- ns[[".package"]][["version"]]
[16:22:08.175]                           if (is.null(version)) 
[16:22:08.175]                             version <- utils::packageVersion("future")
[16:22:08.175]                         }
[16:22:08.175]                         else {
[16:22:08.175]                           version <- NULL
[16:22:08.175]                         }
[16:22:08.175]                         if (!has_future || version < "1.8.0") {
[16:22:08.175]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.175]                             "", base::R.version$version.string), 
[16:22:08.175]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.175]                               "release", "version")], collapse = " "), 
[16:22:08.175]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.175]                             info)
[16:22:08.175]                           info <- base::paste(info, collapse = "; ")
[16:22:08.175]                           if (!has_future) {
[16:22:08.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.175]                               info)
[16:22:08.175]                           }
[16:22:08.175]                           else {
[16:22:08.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.175]                               info, version)
[16:22:08.175]                           }
[16:22:08.175]                           base::stop(msg)
[16:22:08.175]                         }
[16:22:08.175]                       })
[16:22:08.175]                     }
[16:22:08.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.175]                     base::options(mc.cores = 1L)
[16:22:08.175]                   }
[16:22:08.175]                   ...future.strategy.old <- future::plan("list")
[16:22:08.175]                   options(future.plan = NULL)
[16:22:08.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.175]                 }
[16:22:08.175]                 ...future.workdir <- getwd()
[16:22:08.175]             }
[16:22:08.175]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.175]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.175]         }
[16:22:08.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.175]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.175]             base::names(...future.oldOptions))
[16:22:08.175]     }
[16:22:08.175]     if (FALSE) {
[16:22:08.175]     }
[16:22:08.175]     else {
[16:22:08.175]         if (TRUE) {
[16:22:08.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.175]                 open = "w")
[16:22:08.175]         }
[16:22:08.175]         else {
[16:22:08.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.175]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.175]         }
[16:22:08.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.175]             base::sink(type = "output", split = FALSE)
[16:22:08.175]             base::close(...future.stdout)
[16:22:08.175]         }, add = TRUE)
[16:22:08.175]     }
[16:22:08.175]     ...future.frame <- base::sys.nframe()
[16:22:08.175]     ...future.conditions <- base::list()
[16:22:08.175]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.175]     if (FALSE) {
[16:22:08.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.175]     }
[16:22:08.175]     ...future.result <- base::tryCatch({
[16:22:08.175]         base::withCallingHandlers({
[16:22:08.175]             ...future.value <- base::withVisible(base::local({
[16:22:08.175]                 ...future.makeSendCondition <- base::local({
[16:22:08.175]                   sendCondition <- NULL
[16:22:08.175]                   function(frame = 1L) {
[16:22:08.175]                     if (is.function(sendCondition)) 
[16:22:08.175]                       return(sendCondition)
[16:22:08.175]                     ns <- getNamespace("parallel")
[16:22:08.175]                     if (exists("sendData", mode = "function", 
[16:22:08.175]                       envir = ns)) {
[16:22:08.175]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.175]                         envir = ns)
[16:22:08.175]                       envir <- sys.frame(frame)
[16:22:08.175]                       master <- NULL
[16:22:08.175]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.175]                         !identical(envir, emptyenv())) {
[16:22:08.175]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.175]                           inherits = FALSE)) {
[16:22:08.175]                           master <- get("master", mode = "list", 
[16:22:08.175]                             envir = envir, inherits = FALSE)
[16:22:08.175]                           if (inherits(master, c("SOCKnode", 
[16:22:08.175]                             "SOCK0node"))) {
[16:22:08.175]                             sendCondition <<- function(cond) {
[16:22:08.175]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.175]                                 success = TRUE)
[16:22:08.175]                               parallel_sendData(master, data)
[16:22:08.175]                             }
[16:22:08.175]                             return(sendCondition)
[16:22:08.175]                           }
[16:22:08.175]                         }
[16:22:08.175]                         frame <- frame + 1L
[16:22:08.175]                         envir <- sys.frame(frame)
[16:22:08.175]                       }
[16:22:08.175]                     }
[16:22:08.175]                     sendCondition <<- function(cond) NULL
[16:22:08.175]                   }
[16:22:08.175]                 })
[16:22:08.175]                 withCallingHandlers({
[16:22:08.175]                   1
[16:22:08.175]                 }, immediateCondition = function(cond) {
[16:22:08.175]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.175]                   sendCondition(cond)
[16:22:08.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.175]                   {
[16:22:08.175]                     inherits <- base::inherits
[16:22:08.175]                     invokeRestart <- base::invokeRestart
[16:22:08.175]                     is.null <- base::is.null
[16:22:08.175]                     muffled <- FALSE
[16:22:08.175]                     if (inherits(cond, "message")) {
[16:22:08.175]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.175]                       if (muffled) 
[16:22:08.175]                         invokeRestart("muffleMessage")
[16:22:08.175]                     }
[16:22:08.175]                     else if (inherits(cond, "warning")) {
[16:22:08.175]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.175]                       if (muffled) 
[16:22:08.175]                         invokeRestart("muffleWarning")
[16:22:08.175]                     }
[16:22:08.175]                     else if (inherits(cond, "condition")) {
[16:22:08.175]                       if (!is.null(pattern)) {
[16:22:08.175]                         computeRestarts <- base::computeRestarts
[16:22:08.175]                         grepl <- base::grepl
[16:22:08.175]                         restarts <- computeRestarts(cond)
[16:22:08.175]                         for (restart in restarts) {
[16:22:08.175]                           name <- restart$name
[16:22:08.175]                           if (is.null(name)) 
[16:22:08.175]                             next
[16:22:08.175]                           if (!grepl(pattern, name)) 
[16:22:08.175]                             next
[16:22:08.175]                           invokeRestart(restart)
[16:22:08.175]                           muffled <- TRUE
[16:22:08.175]                           break
[16:22:08.175]                         }
[16:22:08.175]                       }
[16:22:08.175]                     }
[16:22:08.175]                     invisible(muffled)
[16:22:08.175]                   }
[16:22:08.175]                   muffleCondition(cond)
[16:22:08.175]                 })
[16:22:08.175]             }))
[16:22:08.175]             future::FutureResult(value = ...future.value$value, 
[16:22:08.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.175]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.175]                     ...future.globalenv.names))
[16:22:08.175]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.175]         }, condition = base::local({
[16:22:08.175]             c <- base::c
[16:22:08.175]             inherits <- base::inherits
[16:22:08.175]             invokeRestart <- base::invokeRestart
[16:22:08.175]             length <- base::length
[16:22:08.175]             list <- base::list
[16:22:08.175]             seq.int <- base::seq.int
[16:22:08.175]             signalCondition <- base::signalCondition
[16:22:08.175]             sys.calls <- base::sys.calls
[16:22:08.175]             `[[` <- base::`[[`
[16:22:08.175]             `+` <- base::`+`
[16:22:08.175]             `<<-` <- base::`<<-`
[16:22:08.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.175]                   3L)]
[16:22:08.175]             }
[16:22:08.175]             function(cond) {
[16:22:08.175]                 is_error <- inherits(cond, "error")
[16:22:08.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.175]                   NULL)
[16:22:08.175]                 if (is_error) {
[16:22:08.175]                   sessionInformation <- function() {
[16:22:08.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.175]                       search = base::search(), system = base::Sys.info())
[16:22:08.175]                   }
[16:22:08.175]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.175]                     cond$call), session = sessionInformation(), 
[16:22:08.175]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.175]                   signalCondition(cond)
[16:22:08.175]                 }
[16:22:08.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.175]                 "immediateCondition"))) {
[16:22:08.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.175]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.175]                   if (TRUE && !signal) {
[16:22:08.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.175]                     {
[16:22:08.175]                       inherits <- base::inherits
[16:22:08.175]                       invokeRestart <- base::invokeRestart
[16:22:08.175]                       is.null <- base::is.null
[16:22:08.175]                       muffled <- FALSE
[16:22:08.175]                       if (inherits(cond, "message")) {
[16:22:08.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.175]                         if (muffled) 
[16:22:08.175]                           invokeRestart("muffleMessage")
[16:22:08.175]                       }
[16:22:08.175]                       else if (inherits(cond, "warning")) {
[16:22:08.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.175]                         if (muffled) 
[16:22:08.175]                           invokeRestart("muffleWarning")
[16:22:08.175]                       }
[16:22:08.175]                       else if (inherits(cond, "condition")) {
[16:22:08.175]                         if (!is.null(pattern)) {
[16:22:08.175]                           computeRestarts <- base::computeRestarts
[16:22:08.175]                           grepl <- base::grepl
[16:22:08.175]                           restarts <- computeRestarts(cond)
[16:22:08.175]                           for (restart in restarts) {
[16:22:08.175]                             name <- restart$name
[16:22:08.175]                             if (is.null(name)) 
[16:22:08.175]                               next
[16:22:08.175]                             if (!grepl(pattern, name)) 
[16:22:08.175]                               next
[16:22:08.175]                             invokeRestart(restart)
[16:22:08.175]                             muffled <- TRUE
[16:22:08.175]                             break
[16:22:08.175]                           }
[16:22:08.175]                         }
[16:22:08.175]                       }
[16:22:08.175]                       invisible(muffled)
[16:22:08.175]                     }
[16:22:08.175]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.175]                   }
[16:22:08.175]                 }
[16:22:08.175]                 else {
[16:22:08.175]                   if (TRUE) {
[16:22:08.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.175]                     {
[16:22:08.175]                       inherits <- base::inherits
[16:22:08.175]                       invokeRestart <- base::invokeRestart
[16:22:08.175]                       is.null <- base::is.null
[16:22:08.175]                       muffled <- FALSE
[16:22:08.175]                       if (inherits(cond, "message")) {
[16:22:08.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.175]                         if (muffled) 
[16:22:08.175]                           invokeRestart("muffleMessage")
[16:22:08.175]                       }
[16:22:08.175]                       else if (inherits(cond, "warning")) {
[16:22:08.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.175]                         if (muffled) 
[16:22:08.175]                           invokeRestart("muffleWarning")
[16:22:08.175]                       }
[16:22:08.175]                       else if (inherits(cond, "condition")) {
[16:22:08.175]                         if (!is.null(pattern)) {
[16:22:08.175]                           computeRestarts <- base::computeRestarts
[16:22:08.175]                           grepl <- base::grepl
[16:22:08.175]                           restarts <- computeRestarts(cond)
[16:22:08.175]                           for (restart in restarts) {
[16:22:08.175]                             name <- restart$name
[16:22:08.175]                             if (is.null(name)) 
[16:22:08.175]                               next
[16:22:08.175]                             if (!grepl(pattern, name)) 
[16:22:08.175]                               next
[16:22:08.175]                             invokeRestart(restart)
[16:22:08.175]                             muffled <- TRUE
[16:22:08.175]                             break
[16:22:08.175]                           }
[16:22:08.175]                         }
[16:22:08.175]                       }
[16:22:08.175]                       invisible(muffled)
[16:22:08.175]                     }
[16:22:08.175]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.175]                   }
[16:22:08.175]                 }
[16:22:08.175]             }
[16:22:08.175]         }))
[16:22:08.175]     }, error = function(ex) {
[16:22:08.175]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.175]                 ...future.rng), started = ...future.startTime, 
[16:22:08.175]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.175]             version = "1.8"), class = "FutureResult")
[16:22:08.175]     }, finally = {
[16:22:08.175]         if (!identical(...future.workdir, getwd())) 
[16:22:08.175]             setwd(...future.workdir)
[16:22:08.175]         {
[16:22:08.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.175]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.175]             }
[16:22:08.175]             base::options(...future.oldOptions)
[16:22:08.175]             if (.Platform$OS.type == "windows") {
[16:22:08.175]                 old_names <- names(...future.oldEnvVars)
[16:22:08.175]                 envs <- base::Sys.getenv()
[16:22:08.175]                 names <- names(envs)
[16:22:08.175]                 common <- intersect(names, old_names)
[16:22:08.175]                 added <- setdiff(names, old_names)
[16:22:08.175]                 removed <- setdiff(old_names, names)
[16:22:08.175]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.175]                   envs[common]]
[16:22:08.175]                 NAMES <- toupper(changed)
[16:22:08.175]                 args <- list()
[16:22:08.175]                 for (kk in seq_along(NAMES)) {
[16:22:08.175]                   name <- changed[[kk]]
[16:22:08.175]                   NAME <- NAMES[[kk]]
[16:22:08.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.175]                     next
[16:22:08.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.175]                 }
[16:22:08.175]                 NAMES <- toupper(added)
[16:22:08.175]                 for (kk in seq_along(NAMES)) {
[16:22:08.175]                   name <- added[[kk]]
[16:22:08.175]                   NAME <- NAMES[[kk]]
[16:22:08.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.175]                     next
[16:22:08.175]                   args[[name]] <- ""
[16:22:08.175]                 }
[16:22:08.175]                 NAMES <- toupper(removed)
[16:22:08.175]                 for (kk in seq_along(NAMES)) {
[16:22:08.175]                   name <- removed[[kk]]
[16:22:08.175]                   NAME <- NAMES[[kk]]
[16:22:08.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.175]                     next
[16:22:08.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.175]                 }
[16:22:08.175]                 if (length(args) > 0) 
[16:22:08.175]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.175]             }
[16:22:08.175]             else {
[16:22:08.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.175]             }
[16:22:08.175]             {
[16:22:08.175]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.175]                   0L) {
[16:22:08.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.175]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.175]                   base::options(opts)
[16:22:08.175]                 }
[16:22:08.175]                 {
[16:22:08.175]                   {
[16:22:08.175]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.175]                     NULL
[16:22:08.175]                   }
[16:22:08.175]                   options(future.plan = NULL)
[16:22:08.175]                   if (is.na(NA_character_)) 
[16:22:08.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.175]                     .init = FALSE)
[16:22:08.175]                 }
[16:22:08.175]             }
[16:22:08.175]         }
[16:22:08.175]     })
[16:22:08.175]     if (TRUE) {
[16:22:08.175]         base::sink(type = "output", split = FALSE)
[16:22:08.175]         if (TRUE) {
[16:22:08.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.175]         }
[16:22:08.175]         else {
[16:22:08.175]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.175]         }
[16:22:08.175]         base::close(...future.stdout)
[16:22:08.175]         ...future.stdout <- NULL
[16:22:08.175]     }
[16:22:08.175]     ...future.result$conditions <- ...future.conditions
[16:22:08.175]     ...future.result$finished <- base::Sys.time()
[16:22:08.175]     ...future.result
[16:22:08.175] }
[16:22:08.178] MultisessionFuture started
[16:22:08.179] - Launch lazy future ... done
[16:22:08.179] run() for ‘MultisessionFuture’ ... done
[16:22:08.180] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.180] - Validating connection of MultisessionFuture
[16:22:08.181] - received message: FutureResult
[16:22:08.181] - Received FutureResult
[16:22:08.181] - Erased future from FutureRegistry
[16:22:08.181] result() for ClusterFuture ...
[16:22:08.181] - result already collected: FutureResult
[16:22:08.181] result() for ClusterFuture ... done
[16:22:08.181] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.181] Future #1
[16:22:08.182]  length: 2 (resolved future 1)
[16:22:08.182] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.182] - Validating connection of MultisessionFuture
[16:22:08.182] - received message: FutureResult
[16:22:08.182] - Received FutureResult
[16:22:08.182] - Erased future from FutureRegistry
[16:22:08.183] result() for ClusterFuture ...
[16:22:08.183] - result already collected: FutureResult
[16:22:08.183] result() for ClusterFuture ... done
[16:22:08.183] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.183] Future #2
[16:22:08.183]  length: 1 (resolved future 2)
[16:22:08.183]  length: 0 (resolved future 3)
[16:22:08.183] resolve() on list ... DONE
[16:22:08.183] getGlobalsAndPackages() ...
[16:22:08.183] Searching for globals...
[16:22:08.184] 
[16:22:08.184] Searching for globals ... DONE
[16:22:08.184] - globals: [0] <none>
[16:22:08.184] getGlobalsAndPackages() ... DONE
[16:22:08.184] getGlobalsAndPackages() ...
[16:22:08.184] Searching for globals...
[16:22:08.185] 
[16:22:08.185] Searching for globals ... DONE
[16:22:08.185] - globals: [0] <none>
[16:22:08.185] getGlobalsAndPackages() ... DONE
[16:22:08.185] resolve() on list ...
[16:22:08.185]  recursive: 0
[16:22:08.185]  length: 3
[16:22:08.185]  elements: ‘a’, ‘b’, ‘’
[16:22:08.186] run() for ‘Future’ ...
[16:22:08.186] - state: ‘created’
[16:22:08.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.199] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.199] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.200]   - Field: ‘node’
[16:22:08.200]   - Field: ‘label’
[16:22:08.200]   - Field: ‘local’
[16:22:08.200]   - Field: ‘owner’
[16:22:08.200]   - Field: ‘envir’
[16:22:08.200]   - Field: ‘workers’
[16:22:08.200]   - Field: ‘packages’
[16:22:08.200]   - Field: ‘gc’
[16:22:08.200]   - Field: ‘conditions’
[16:22:08.200]   - Field: ‘persistent’
[16:22:08.201]   - Field: ‘expr’
[16:22:08.201]   - Field: ‘uuid’
[16:22:08.201]   - Field: ‘seed’
[16:22:08.201]   - Field: ‘version’
[16:22:08.201]   - Field: ‘result’
[16:22:08.201]   - Field: ‘asynchronous’
[16:22:08.201]   - Field: ‘calls’
[16:22:08.201]   - Field: ‘globals’
[16:22:08.201]   - Field: ‘stdout’
[16:22:08.201]   - Field: ‘earlySignal’
[16:22:08.201]   - Field: ‘lazy’
[16:22:08.202]   - Field: ‘state’
[16:22:08.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.202] - Launch lazy future ...
[16:22:08.202] Packages needed by the future expression (n = 0): <none>
[16:22:08.202] Packages needed by future strategies (n = 0): <none>
[16:22:08.202] {
[16:22:08.202]     {
[16:22:08.202]         {
[16:22:08.202]             ...future.startTime <- base::Sys.time()
[16:22:08.202]             {
[16:22:08.202]                 {
[16:22:08.202]                   {
[16:22:08.202]                     {
[16:22:08.202]                       base::local({
[16:22:08.202]                         has_future <- base::requireNamespace("future", 
[16:22:08.202]                           quietly = TRUE)
[16:22:08.202]                         if (has_future) {
[16:22:08.202]                           ns <- base::getNamespace("future")
[16:22:08.202]                           version <- ns[[".package"]][["version"]]
[16:22:08.202]                           if (is.null(version)) 
[16:22:08.202]                             version <- utils::packageVersion("future")
[16:22:08.202]                         }
[16:22:08.202]                         else {
[16:22:08.202]                           version <- NULL
[16:22:08.202]                         }
[16:22:08.202]                         if (!has_future || version < "1.8.0") {
[16:22:08.202]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.202]                             "", base::R.version$version.string), 
[16:22:08.202]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.202]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.202]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.202]                               "release", "version")], collapse = " "), 
[16:22:08.202]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.202]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.202]                             info)
[16:22:08.202]                           info <- base::paste(info, collapse = "; ")
[16:22:08.202]                           if (!has_future) {
[16:22:08.202]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.202]                               info)
[16:22:08.202]                           }
[16:22:08.202]                           else {
[16:22:08.202]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.202]                               info, version)
[16:22:08.202]                           }
[16:22:08.202]                           base::stop(msg)
[16:22:08.202]                         }
[16:22:08.202]                       })
[16:22:08.202]                     }
[16:22:08.202]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.202]                     base::options(mc.cores = 1L)
[16:22:08.202]                   }
[16:22:08.202]                   ...future.strategy.old <- future::plan("list")
[16:22:08.202]                   options(future.plan = NULL)
[16:22:08.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.202]                 }
[16:22:08.202]                 ...future.workdir <- getwd()
[16:22:08.202]             }
[16:22:08.202]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.202]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.202]         }
[16:22:08.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.202]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.202]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.202]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.202]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.202]             base::names(...future.oldOptions))
[16:22:08.202]     }
[16:22:08.202]     if (FALSE) {
[16:22:08.202]     }
[16:22:08.202]     else {
[16:22:08.202]         if (TRUE) {
[16:22:08.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.202]                 open = "w")
[16:22:08.202]         }
[16:22:08.202]         else {
[16:22:08.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.202]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.202]         }
[16:22:08.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.202]             base::sink(type = "output", split = FALSE)
[16:22:08.202]             base::close(...future.stdout)
[16:22:08.202]         }, add = TRUE)
[16:22:08.202]     }
[16:22:08.202]     ...future.frame <- base::sys.nframe()
[16:22:08.202]     ...future.conditions <- base::list()
[16:22:08.202]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.202]     if (FALSE) {
[16:22:08.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.202]     }
[16:22:08.202]     ...future.result <- base::tryCatch({
[16:22:08.202]         base::withCallingHandlers({
[16:22:08.202]             ...future.value <- base::withVisible(base::local({
[16:22:08.202]                 ...future.makeSendCondition <- base::local({
[16:22:08.202]                   sendCondition <- NULL
[16:22:08.202]                   function(frame = 1L) {
[16:22:08.202]                     if (is.function(sendCondition)) 
[16:22:08.202]                       return(sendCondition)
[16:22:08.202]                     ns <- getNamespace("parallel")
[16:22:08.202]                     if (exists("sendData", mode = "function", 
[16:22:08.202]                       envir = ns)) {
[16:22:08.202]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.202]                         envir = ns)
[16:22:08.202]                       envir <- sys.frame(frame)
[16:22:08.202]                       master <- NULL
[16:22:08.202]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.202]                         !identical(envir, emptyenv())) {
[16:22:08.202]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.202]                           inherits = FALSE)) {
[16:22:08.202]                           master <- get("master", mode = "list", 
[16:22:08.202]                             envir = envir, inherits = FALSE)
[16:22:08.202]                           if (inherits(master, c("SOCKnode", 
[16:22:08.202]                             "SOCK0node"))) {
[16:22:08.202]                             sendCondition <<- function(cond) {
[16:22:08.202]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.202]                                 success = TRUE)
[16:22:08.202]                               parallel_sendData(master, data)
[16:22:08.202]                             }
[16:22:08.202]                             return(sendCondition)
[16:22:08.202]                           }
[16:22:08.202]                         }
[16:22:08.202]                         frame <- frame + 1L
[16:22:08.202]                         envir <- sys.frame(frame)
[16:22:08.202]                       }
[16:22:08.202]                     }
[16:22:08.202]                     sendCondition <<- function(cond) NULL
[16:22:08.202]                   }
[16:22:08.202]                 })
[16:22:08.202]                 withCallingHandlers({
[16:22:08.202]                   1
[16:22:08.202]                 }, immediateCondition = function(cond) {
[16:22:08.202]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.202]                   sendCondition(cond)
[16:22:08.202]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.202]                   {
[16:22:08.202]                     inherits <- base::inherits
[16:22:08.202]                     invokeRestart <- base::invokeRestart
[16:22:08.202]                     is.null <- base::is.null
[16:22:08.202]                     muffled <- FALSE
[16:22:08.202]                     if (inherits(cond, "message")) {
[16:22:08.202]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.202]                       if (muffled) 
[16:22:08.202]                         invokeRestart("muffleMessage")
[16:22:08.202]                     }
[16:22:08.202]                     else if (inherits(cond, "warning")) {
[16:22:08.202]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.202]                       if (muffled) 
[16:22:08.202]                         invokeRestart("muffleWarning")
[16:22:08.202]                     }
[16:22:08.202]                     else if (inherits(cond, "condition")) {
[16:22:08.202]                       if (!is.null(pattern)) {
[16:22:08.202]                         computeRestarts <- base::computeRestarts
[16:22:08.202]                         grepl <- base::grepl
[16:22:08.202]                         restarts <- computeRestarts(cond)
[16:22:08.202]                         for (restart in restarts) {
[16:22:08.202]                           name <- restart$name
[16:22:08.202]                           if (is.null(name)) 
[16:22:08.202]                             next
[16:22:08.202]                           if (!grepl(pattern, name)) 
[16:22:08.202]                             next
[16:22:08.202]                           invokeRestart(restart)
[16:22:08.202]                           muffled <- TRUE
[16:22:08.202]                           break
[16:22:08.202]                         }
[16:22:08.202]                       }
[16:22:08.202]                     }
[16:22:08.202]                     invisible(muffled)
[16:22:08.202]                   }
[16:22:08.202]                   muffleCondition(cond)
[16:22:08.202]                 })
[16:22:08.202]             }))
[16:22:08.202]             future::FutureResult(value = ...future.value$value, 
[16:22:08.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.202]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.202]                     ...future.globalenv.names))
[16:22:08.202]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.202]         }, condition = base::local({
[16:22:08.202]             c <- base::c
[16:22:08.202]             inherits <- base::inherits
[16:22:08.202]             invokeRestart <- base::invokeRestart
[16:22:08.202]             length <- base::length
[16:22:08.202]             list <- base::list
[16:22:08.202]             seq.int <- base::seq.int
[16:22:08.202]             signalCondition <- base::signalCondition
[16:22:08.202]             sys.calls <- base::sys.calls
[16:22:08.202]             `[[` <- base::`[[`
[16:22:08.202]             `+` <- base::`+`
[16:22:08.202]             `<<-` <- base::`<<-`
[16:22:08.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.202]                   3L)]
[16:22:08.202]             }
[16:22:08.202]             function(cond) {
[16:22:08.202]                 is_error <- inherits(cond, "error")
[16:22:08.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.202]                   NULL)
[16:22:08.202]                 if (is_error) {
[16:22:08.202]                   sessionInformation <- function() {
[16:22:08.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.202]                       search = base::search(), system = base::Sys.info())
[16:22:08.202]                   }
[16:22:08.202]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.202]                     cond$call), session = sessionInformation(), 
[16:22:08.202]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.202]                   signalCondition(cond)
[16:22:08.202]                 }
[16:22:08.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.202]                 "immediateCondition"))) {
[16:22:08.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.202]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.202]                   if (TRUE && !signal) {
[16:22:08.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.202]                     {
[16:22:08.202]                       inherits <- base::inherits
[16:22:08.202]                       invokeRestart <- base::invokeRestart
[16:22:08.202]                       is.null <- base::is.null
[16:22:08.202]                       muffled <- FALSE
[16:22:08.202]                       if (inherits(cond, "message")) {
[16:22:08.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.202]                         if (muffled) 
[16:22:08.202]                           invokeRestart("muffleMessage")
[16:22:08.202]                       }
[16:22:08.202]                       else if (inherits(cond, "warning")) {
[16:22:08.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.202]                         if (muffled) 
[16:22:08.202]                           invokeRestart("muffleWarning")
[16:22:08.202]                       }
[16:22:08.202]                       else if (inherits(cond, "condition")) {
[16:22:08.202]                         if (!is.null(pattern)) {
[16:22:08.202]                           computeRestarts <- base::computeRestarts
[16:22:08.202]                           grepl <- base::grepl
[16:22:08.202]                           restarts <- computeRestarts(cond)
[16:22:08.202]                           for (restart in restarts) {
[16:22:08.202]                             name <- restart$name
[16:22:08.202]                             if (is.null(name)) 
[16:22:08.202]                               next
[16:22:08.202]                             if (!grepl(pattern, name)) 
[16:22:08.202]                               next
[16:22:08.202]                             invokeRestart(restart)
[16:22:08.202]                             muffled <- TRUE
[16:22:08.202]                             break
[16:22:08.202]                           }
[16:22:08.202]                         }
[16:22:08.202]                       }
[16:22:08.202]                       invisible(muffled)
[16:22:08.202]                     }
[16:22:08.202]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.202]                   }
[16:22:08.202]                 }
[16:22:08.202]                 else {
[16:22:08.202]                   if (TRUE) {
[16:22:08.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.202]                     {
[16:22:08.202]                       inherits <- base::inherits
[16:22:08.202]                       invokeRestart <- base::invokeRestart
[16:22:08.202]                       is.null <- base::is.null
[16:22:08.202]                       muffled <- FALSE
[16:22:08.202]                       if (inherits(cond, "message")) {
[16:22:08.202]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.202]                         if (muffled) 
[16:22:08.202]                           invokeRestart("muffleMessage")
[16:22:08.202]                       }
[16:22:08.202]                       else if (inherits(cond, "warning")) {
[16:22:08.202]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.202]                         if (muffled) 
[16:22:08.202]                           invokeRestart("muffleWarning")
[16:22:08.202]                       }
[16:22:08.202]                       else if (inherits(cond, "condition")) {
[16:22:08.202]                         if (!is.null(pattern)) {
[16:22:08.202]                           computeRestarts <- base::computeRestarts
[16:22:08.202]                           grepl <- base::grepl
[16:22:08.202]                           restarts <- computeRestarts(cond)
[16:22:08.202]                           for (restart in restarts) {
[16:22:08.202]                             name <- restart$name
[16:22:08.202]                             if (is.null(name)) 
[16:22:08.202]                               next
[16:22:08.202]                             if (!grepl(pattern, name)) 
[16:22:08.202]                               next
[16:22:08.202]                             invokeRestart(restart)
[16:22:08.202]                             muffled <- TRUE
[16:22:08.202]                             break
[16:22:08.202]                           }
[16:22:08.202]                         }
[16:22:08.202]                       }
[16:22:08.202]                       invisible(muffled)
[16:22:08.202]                     }
[16:22:08.202]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.202]                   }
[16:22:08.202]                 }
[16:22:08.202]             }
[16:22:08.202]         }))
[16:22:08.202]     }, error = function(ex) {
[16:22:08.202]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.202]                 ...future.rng), started = ...future.startTime, 
[16:22:08.202]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.202]             version = "1.8"), class = "FutureResult")
[16:22:08.202]     }, finally = {
[16:22:08.202]         if (!identical(...future.workdir, getwd())) 
[16:22:08.202]             setwd(...future.workdir)
[16:22:08.202]         {
[16:22:08.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.202]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.202]             }
[16:22:08.202]             base::options(...future.oldOptions)
[16:22:08.202]             if (.Platform$OS.type == "windows") {
[16:22:08.202]                 old_names <- names(...future.oldEnvVars)
[16:22:08.202]                 envs <- base::Sys.getenv()
[16:22:08.202]                 names <- names(envs)
[16:22:08.202]                 common <- intersect(names, old_names)
[16:22:08.202]                 added <- setdiff(names, old_names)
[16:22:08.202]                 removed <- setdiff(old_names, names)
[16:22:08.202]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.202]                   envs[common]]
[16:22:08.202]                 NAMES <- toupper(changed)
[16:22:08.202]                 args <- list()
[16:22:08.202]                 for (kk in seq_along(NAMES)) {
[16:22:08.202]                   name <- changed[[kk]]
[16:22:08.202]                   NAME <- NAMES[[kk]]
[16:22:08.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.202]                     next
[16:22:08.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.202]                 }
[16:22:08.202]                 NAMES <- toupper(added)
[16:22:08.202]                 for (kk in seq_along(NAMES)) {
[16:22:08.202]                   name <- added[[kk]]
[16:22:08.202]                   NAME <- NAMES[[kk]]
[16:22:08.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.202]                     next
[16:22:08.202]                   args[[name]] <- ""
[16:22:08.202]                 }
[16:22:08.202]                 NAMES <- toupper(removed)
[16:22:08.202]                 for (kk in seq_along(NAMES)) {
[16:22:08.202]                   name <- removed[[kk]]
[16:22:08.202]                   NAME <- NAMES[[kk]]
[16:22:08.202]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.202]                     next
[16:22:08.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.202]                 }
[16:22:08.202]                 if (length(args) > 0) 
[16:22:08.202]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.202]             }
[16:22:08.202]             else {
[16:22:08.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.202]             }
[16:22:08.202]             {
[16:22:08.202]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.202]                   0L) {
[16:22:08.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.202]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.202]                   base::options(opts)
[16:22:08.202]                 }
[16:22:08.202]                 {
[16:22:08.202]                   {
[16:22:08.202]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.202]                     NULL
[16:22:08.202]                   }
[16:22:08.202]                   options(future.plan = NULL)
[16:22:08.202]                   if (is.na(NA_character_)) 
[16:22:08.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.202]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.202]                     .init = FALSE)
[16:22:08.202]                 }
[16:22:08.202]             }
[16:22:08.202]         }
[16:22:08.202]     })
[16:22:08.202]     if (TRUE) {
[16:22:08.202]         base::sink(type = "output", split = FALSE)
[16:22:08.202]         if (TRUE) {
[16:22:08.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.202]         }
[16:22:08.202]         else {
[16:22:08.202]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.202]         }
[16:22:08.202]         base::close(...future.stdout)
[16:22:08.202]         ...future.stdout <- NULL
[16:22:08.202]     }
[16:22:08.202]     ...future.result$conditions <- ...future.conditions
[16:22:08.202]     ...future.result$finished <- base::Sys.time()
[16:22:08.202]     ...future.result
[16:22:08.202] }
[16:22:08.205] MultisessionFuture started
[16:22:08.205] - Launch lazy future ... done
[16:22:08.206] run() for ‘MultisessionFuture’ ... done
[16:22:08.207] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.207] - Validating connection of MultisessionFuture
[16:22:08.207] - received message: FutureResult
[16:22:08.207] - Received FutureResult
[16:22:08.207] - Erased future from FutureRegistry
[16:22:08.208] result() for ClusterFuture ...
[16:22:08.208] - result already collected: FutureResult
[16:22:08.208] result() for ClusterFuture ... done
[16:22:08.208] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.208] Future #1
[16:22:08.208]  length: 2 (resolved future 1)
[16:22:08.208] run() for ‘Future’ ...
[16:22:08.208] - state: ‘created’
[16:22:08.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.222]   - Field: ‘node’
[16:22:08.222]   - Field: ‘label’
[16:22:08.223]   - Field: ‘local’
[16:22:08.223]   - Field: ‘owner’
[16:22:08.223]   - Field: ‘envir’
[16:22:08.223]   - Field: ‘workers’
[16:22:08.223]   - Field: ‘packages’
[16:22:08.223]   - Field: ‘gc’
[16:22:08.223]   - Field: ‘conditions’
[16:22:08.223]   - Field: ‘persistent’
[16:22:08.223]   - Field: ‘expr’
[16:22:08.223]   - Field: ‘uuid’
[16:22:08.223]   - Field: ‘seed’
[16:22:08.224]   - Field: ‘version’
[16:22:08.224]   - Field: ‘result’
[16:22:08.224]   - Field: ‘asynchronous’
[16:22:08.224]   - Field: ‘calls’
[16:22:08.224]   - Field: ‘globals’
[16:22:08.224]   - Field: ‘stdout’
[16:22:08.224]   - Field: ‘earlySignal’
[16:22:08.224]   - Field: ‘lazy’
[16:22:08.224]   - Field: ‘state’
[16:22:08.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.225] - Launch lazy future ...
[16:22:08.225] Packages needed by the future expression (n = 0): <none>
[16:22:08.225] Packages needed by future strategies (n = 0): <none>
[16:22:08.225] {
[16:22:08.225]     {
[16:22:08.225]         {
[16:22:08.225]             ...future.startTime <- base::Sys.time()
[16:22:08.225]             {
[16:22:08.225]                 {
[16:22:08.225]                   {
[16:22:08.225]                     {
[16:22:08.225]                       base::local({
[16:22:08.225]                         has_future <- base::requireNamespace("future", 
[16:22:08.225]                           quietly = TRUE)
[16:22:08.225]                         if (has_future) {
[16:22:08.225]                           ns <- base::getNamespace("future")
[16:22:08.225]                           version <- ns[[".package"]][["version"]]
[16:22:08.225]                           if (is.null(version)) 
[16:22:08.225]                             version <- utils::packageVersion("future")
[16:22:08.225]                         }
[16:22:08.225]                         else {
[16:22:08.225]                           version <- NULL
[16:22:08.225]                         }
[16:22:08.225]                         if (!has_future || version < "1.8.0") {
[16:22:08.225]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.225]                             "", base::R.version$version.string), 
[16:22:08.225]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.225]                               "release", "version")], collapse = " "), 
[16:22:08.225]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.225]                             info)
[16:22:08.225]                           info <- base::paste(info, collapse = "; ")
[16:22:08.225]                           if (!has_future) {
[16:22:08.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.225]                               info)
[16:22:08.225]                           }
[16:22:08.225]                           else {
[16:22:08.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.225]                               info, version)
[16:22:08.225]                           }
[16:22:08.225]                           base::stop(msg)
[16:22:08.225]                         }
[16:22:08.225]                       })
[16:22:08.225]                     }
[16:22:08.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.225]                     base::options(mc.cores = 1L)
[16:22:08.225]                   }
[16:22:08.225]                   ...future.strategy.old <- future::plan("list")
[16:22:08.225]                   options(future.plan = NULL)
[16:22:08.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.225]                 }
[16:22:08.225]                 ...future.workdir <- getwd()
[16:22:08.225]             }
[16:22:08.225]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.225]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.225]         }
[16:22:08.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.225]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.225]             base::names(...future.oldOptions))
[16:22:08.225]     }
[16:22:08.225]     if (FALSE) {
[16:22:08.225]     }
[16:22:08.225]     else {
[16:22:08.225]         if (TRUE) {
[16:22:08.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.225]                 open = "w")
[16:22:08.225]         }
[16:22:08.225]         else {
[16:22:08.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.225]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.225]         }
[16:22:08.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.225]             base::sink(type = "output", split = FALSE)
[16:22:08.225]             base::close(...future.stdout)
[16:22:08.225]         }, add = TRUE)
[16:22:08.225]     }
[16:22:08.225]     ...future.frame <- base::sys.nframe()
[16:22:08.225]     ...future.conditions <- base::list()
[16:22:08.225]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.225]     if (FALSE) {
[16:22:08.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.225]     }
[16:22:08.225]     ...future.result <- base::tryCatch({
[16:22:08.225]         base::withCallingHandlers({
[16:22:08.225]             ...future.value <- base::withVisible(base::local({
[16:22:08.225]                 ...future.makeSendCondition <- base::local({
[16:22:08.225]                   sendCondition <- NULL
[16:22:08.225]                   function(frame = 1L) {
[16:22:08.225]                     if (is.function(sendCondition)) 
[16:22:08.225]                       return(sendCondition)
[16:22:08.225]                     ns <- getNamespace("parallel")
[16:22:08.225]                     if (exists("sendData", mode = "function", 
[16:22:08.225]                       envir = ns)) {
[16:22:08.225]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.225]                         envir = ns)
[16:22:08.225]                       envir <- sys.frame(frame)
[16:22:08.225]                       master <- NULL
[16:22:08.225]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.225]                         !identical(envir, emptyenv())) {
[16:22:08.225]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.225]                           inherits = FALSE)) {
[16:22:08.225]                           master <- get("master", mode = "list", 
[16:22:08.225]                             envir = envir, inherits = FALSE)
[16:22:08.225]                           if (inherits(master, c("SOCKnode", 
[16:22:08.225]                             "SOCK0node"))) {
[16:22:08.225]                             sendCondition <<- function(cond) {
[16:22:08.225]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.225]                                 success = TRUE)
[16:22:08.225]                               parallel_sendData(master, data)
[16:22:08.225]                             }
[16:22:08.225]                             return(sendCondition)
[16:22:08.225]                           }
[16:22:08.225]                         }
[16:22:08.225]                         frame <- frame + 1L
[16:22:08.225]                         envir <- sys.frame(frame)
[16:22:08.225]                       }
[16:22:08.225]                     }
[16:22:08.225]                     sendCondition <<- function(cond) NULL
[16:22:08.225]                   }
[16:22:08.225]                 })
[16:22:08.225]                 withCallingHandlers({
[16:22:08.225]                   2
[16:22:08.225]                 }, immediateCondition = function(cond) {
[16:22:08.225]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.225]                   sendCondition(cond)
[16:22:08.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.225]                   {
[16:22:08.225]                     inherits <- base::inherits
[16:22:08.225]                     invokeRestart <- base::invokeRestart
[16:22:08.225]                     is.null <- base::is.null
[16:22:08.225]                     muffled <- FALSE
[16:22:08.225]                     if (inherits(cond, "message")) {
[16:22:08.225]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.225]                       if (muffled) 
[16:22:08.225]                         invokeRestart("muffleMessage")
[16:22:08.225]                     }
[16:22:08.225]                     else if (inherits(cond, "warning")) {
[16:22:08.225]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.225]                       if (muffled) 
[16:22:08.225]                         invokeRestart("muffleWarning")
[16:22:08.225]                     }
[16:22:08.225]                     else if (inherits(cond, "condition")) {
[16:22:08.225]                       if (!is.null(pattern)) {
[16:22:08.225]                         computeRestarts <- base::computeRestarts
[16:22:08.225]                         grepl <- base::grepl
[16:22:08.225]                         restarts <- computeRestarts(cond)
[16:22:08.225]                         for (restart in restarts) {
[16:22:08.225]                           name <- restart$name
[16:22:08.225]                           if (is.null(name)) 
[16:22:08.225]                             next
[16:22:08.225]                           if (!grepl(pattern, name)) 
[16:22:08.225]                             next
[16:22:08.225]                           invokeRestart(restart)
[16:22:08.225]                           muffled <- TRUE
[16:22:08.225]                           break
[16:22:08.225]                         }
[16:22:08.225]                       }
[16:22:08.225]                     }
[16:22:08.225]                     invisible(muffled)
[16:22:08.225]                   }
[16:22:08.225]                   muffleCondition(cond)
[16:22:08.225]                 })
[16:22:08.225]             }))
[16:22:08.225]             future::FutureResult(value = ...future.value$value, 
[16:22:08.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.225]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.225]                     ...future.globalenv.names))
[16:22:08.225]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.225]         }, condition = base::local({
[16:22:08.225]             c <- base::c
[16:22:08.225]             inherits <- base::inherits
[16:22:08.225]             invokeRestart <- base::invokeRestart
[16:22:08.225]             length <- base::length
[16:22:08.225]             list <- base::list
[16:22:08.225]             seq.int <- base::seq.int
[16:22:08.225]             signalCondition <- base::signalCondition
[16:22:08.225]             sys.calls <- base::sys.calls
[16:22:08.225]             `[[` <- base::`[[`
[16:22:08.225]             `+` <- base::`+`
[16:22:08.225]             `<<-` <- base::`<<-`
[16:22:08.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.225]                   3L)]
[16:22:08.225]             }
[16:22:08.225]             function(cond) {
[16:22:08.225]                 is_error <- inherits(cond, "error")
[16:22:08.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.225]                   NULL)
[16:22:08.225]                 if (is_error) {
[16:22:08.225]                   sessionInformation <- function() {
[16:22:08.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.225]                       search = base::search(), system = base::Sys.info())
[16:22:08.225]                   }
[16:22:08.225]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.225]                     cond$call), session = sessionInformation(), 
[16:22:08.225]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.225]                   signalCondition(cond)
[16:22:08.225]                 }
[16:22:08.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.225]                 "immediateCondition"))) {
[16:22:08.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.225]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.225]                   if (TRUE && !signal) {
[16:22:08.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.225]                     {
[16:22:08.225]                       inherits <- base::inherits
[16:22:08.225]                       invokeRestart <- base::invokeRestart
[16:22:08.225]                       is.null <- base::is.null
[16:22:08.225]                       muffled <- FALSE
[16:22:08.225]                       if (inherits(cond, "message")) {
[16:22:08.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.225]                         if (muffled) 
[16:22:08.225]                           invokeRestart("muffleMessage")
[16:22:08.225]                       }
[16:22:08.225]                       else if (inherits(cond, "warning")) {
[16:22:08.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.225]                         if (muffled) 
[16:22:08.225]                           invokeRestart("muffleWarning")
[16:22:08.225]                       }
[16:22:08.225]                       else if (inherits(cond, "condition")) {
[16:22:08.225]                         if (!is.null(pattern)) {
[16:22:08.225]                           computeRestarts <- base::computeRestarts
[16:22:08.225]                           grepl <- base::grepl
[16:22:08.225]                           restarts <- computeRestarts(cond)
[16:22:08.225]                           for (restart in restarts) {
[16:22:08.225]                             name <- restart$name
[16:22:08.225]                             if (is.null(name)) 
[16:22:08.225]                               next
[16:22:08.225]                             if (!grepl(pattern, name)) 
[16:22:08.225]                               next
[16:22:08.225]                             invokeRestart(restart)
[16:22:08.225]                             muffled <- TRUE
[16:22:08.225]                             break
[16:22:08.225]                           }
[16:22:08.225]                         }
[16:22:08.225]                       }
[16:22:08.225]                       invisible(muffled)
[16:22:08.225]                     }
[16:22:08.225]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.225]                   }
[16:22:08.225]                 }
[16:22:08.225]                 else {
[16:22:08.225]                   if (TRUE) {
[16:22:08.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.225]                     {
[16:22:08.225]                       inherits <- base::inherits
[16:22:08.225]                       invokeRestart <- base::invokeRestart
[16:22:08.225]                       is.null <- base::is.null
[16:22:08.225]                       muffled <- FALSE
[16:22:08.225]                       if (inherits(cond, "message")) {
[16:22:08.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.225]                         if (muffled) 
[16:22:08.225]                           invokeRestart("muffleMessage")
[16:22:08.225]                       }
[16:22:08.225]                       else if (inherits(cond, "warning")) {
[16:22:08.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.225]                         if (muffled) 
[16:22:08.225]                           invokeRestart("muffleWarning")
[16:22:08.225]                       }
[16:22:08.225]                       else if (inherits(cond, "condition")) {
[16:22:08.225]                         if (!is.null(pattern)) {
[16:22:08.225]                           computeRestarts <- base::computeRestarts
[16:22:08.225]                           grepl <- base::grepl
[16:22:08.225]                           restarts <- computeRestarts(cond)
[16:22:08.225]                           for (restart in restarts) {
[16:22:08.225]                             name <- restart$name
[16:22:08.225]                             if (is.null(name)) 
[16:22:08.225]                               next
[16:22:08.225]                             if (!grepl(pattern, name)) 
[16:22:08.225]                               next
[16:22:08.225]                             invokeRestart(restart)
[16:22:08.225]                             muffled <- TRUE
[16:22:08.225]                             break
[16:22:08.225]                           }
[16:22:08.225]                         }
[16:22:08.225]                       }
[16:22:08.225]                       invisible(muffled)
[16:22:08.225]                     }
[16:22:08.225]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.225]                   }
[16:22:08.225]                 }
[16:22:08.225]             }
[16:22:08.225]         }))
[16:22:08.225]     }, error = function(ex) {
[16:22:08.225]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.225]                 ...future.rng), started = ...future.startTime, 
[16:22:08.225]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.225]             version = "1.8"), class = "FutureResult")
[16:22:08.225]     }, finally = {
[16:22:08.225]         if (!identical(...future.workdir, getwd())) 
[16:22:08.225]             setwd(...future.workdir)
[16:22:08.225]         {
[16:22:08.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.225]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.225]             }
[16:22:08.225]             base::options(...future.oldOptions)
[16:22:08.225]             if (.Platform$OS.type == "windows") {
[16:22:08.225]                 old_names <- names(...future.oldEnvVars)
[16:22:08.225]                 envs <- base::Sys.getenv()
[16:22:08.225]                 names <- names(envs)
[16:22:08.225]                 common <- intersect(names, old_names)
[16:22:08.225]                 added <- setdiff(names, old_names)
[16:22:08.225]                 removed <- setdiff(old_names, names)
[16:22:08.225]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.225]                   envs[common]]
[16:22:08.225]                 NAMES <- toupper(changed)
[16:22:08.225]                 args <- list()
[16:22:08.225]                 for (kk in seq_along(NAMES)) {
[16:22:08.225]                   name <- changed[[kk]]
[16:22:08.225]                   NAME <- NAMES[[kk]]
[16:22:08.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.225]                     next
[16:22:08.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.225]                 }
[16:22:08.225]                 NAMES <- toupper(added)
[16:22:08.225]                 for (kk in seq_along(NAMES)) {
[16:22:08.225]                   name <- added[[kk]]
[16:22:08.225]                   NAME <- NAMES[[kk]]
[16:22:08.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.225]                     next
[16:22:08.225]                   args[[name]] <- ""
[16:22:08.225]                 }
[16:22:08.225]                 NAMES <- toupper(removed)
[16:22:08.225]                 for (kk in seq_along(NAMES)) {
[16:22:08.225]                   name <- removed[[kk]]
[16:22:08.225]                   NAME <- NAMES[[kk]]
[16:22:08.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.225]                     next
[16:22:08.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.225]                 }
[16:22:08.225]                 if (length(args) > 0) 
[16:22:08.225]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.225]             }
[16:22:08.225]             else {
[16:22:08.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.225]             }
[16:22:08.225]             {
[16:22:08.225]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.225]                   0L) {
[16:22:08.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.225]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.225]                   base::options(opts)
[16:22:08.225]                 }
[16:22:08.225]                 {
[16:22:08.225]                   {
[16:22:08.225]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.225]                     NULL
[16:22:08.225]                   }
[16:22:08.225]                   options(future.plan = NULL)
[16:22:08.225]                   if (is.na(NA_character_)) 
[16:22:08.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.225]                     .init = FALSE)
[16:22:08.225]                 }
[16:22:08.225]             }
[16:22:08.225]         }
[16:22:08.225]     })
[16:22:08.225]     if (TRUE) {
[16:22:08.225]         base::sink(type = "output", split = FALSE)
[16:22:08.225]         if (TRUE) {
[16:22:08.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.225]         }
[16:22:08.225]         else {
[16:22:08.225]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.225]         }
[16:22:08.225]         base::close(...future.stdout)
[16:22:08.225]         ...future.stdout <- NULL
[16:22:08.225]     }
[16:22:08.225]     ...future.result$conditions <- ...future.conditions
[16:22:08.225]     ...future.result$finished <- base::Sys.time()
[16:22:08.225]     ...future.result
[16:22:08.225] }
[16:22:08.228] MultisessionFuture started
[16:22:08.228] - Launch lazy future ... done
[16:22:08.229] run() for ‘MultisessionFuture’ ... done
[16:22:08.230] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.230] - Validating connection of MultisessionFuture
[16:22:08.230] - received message: FutureResult
[16:22:08.230] - Received FutureResult
[16:22:08.230] - Erased future from FutureRegistry
[16:22:08.230] result() for ClusterFuture ...
[16:22:08.231] - result already collected: FutureResult
[16:22:08.231] result() for ClusterFuture ... done
[16:22:08.231] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.231] Future #2
[16:22:08.231]  length: 1 (resolved future 2)
[16:22:08.231]  length: 0 (resolved future 3)
[16:22:08.231] resolve() on list ... DONE
[16:22:08.231] getGlobalsAndPackages() ...
[16:22:08.231] Searching for globals...
[16:22:08.232] 
[16:22:08.232] Searching for globals ... DONE
[16:22:08.232] - globals: [0] <none>
[16:22:08.232] getGlobalsAndPackages() ... DONE
[16:22:08.232] run() for ‘Future’ ...
[16:22:08.232] - state: ‘created’
[16:22:08.232] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.246] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.246]   - Field: ‘node’
[16:22:08.247]   - Field: ‘label’
[16:22:08.247]   - Field: ‘local’
[16:22:08.247]   - Field: ‘owner’
[16:22:08.247]   - Field: ‘envir’
[16:22:08.247]   - Field: ‘workers’
[16:22:08.247]   - Field: ‘packages’
[16:22:08.247]   - Field: ‘gc’
[16:22:08.247]   - Field: ‘conditions’
[16:22:08.247]   - Field: ‘persistent’
[16:22:08.247]   - Field: ‘expr’
[16:22:08.247]   - Field: ‘uuid’
[16:22:08.248]   - Field: ‘seed’
[16:22:08.248]   - Field: ‘version’
[16:22:08.248]   - Field: ‘result’
[16:22:08.248]   - Field: ‘asynchronous’
[16:22:08.248]   - Field: ‘calls’
[16:22:08.248]   - Field: ‘globals’
[16:22:08.248]   - Field: ‘stdout’
[16:22:08.248]   - Field: ‘earlySignal’
[16:22:08.248]   - Field: ‘lazy’
[16:22:08.248]   - Field: ‘state’
[16:22:08.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.249] - Launch lazy future ...
[16:22:08.249] Packages needed by the future expression (n = 0): <none>
[16:22:08.249] Packages needed by future strategies (n = 0): <none>
[16:22:08.249] {
[16:22:08.249]     {
[16:22:08.249]         {
[16:22:08.249]             ...future.startTime <- base::Sys.time()
[16:22:08.249]             {
[16:22:08.249]                 {
[16:22:08.249]                   {
[16:22:08.249]                     {
[16:22:08.249]                       base::local({
[16:22:08.249]                         has_future <- base::requireNamespace("future", 
[16:22:08.249]                           quietly = TRUE)
[16:22:08.249]                         if (has_future) {
[16:22:08.249]                           ns <- base::getNamespace("future")
[16:22:08.249]                           version <- ns[[".package"]][["version"]]
[16:22:08.249]                           if (is.null(version)) 
[16:22:08.249]                             version <- utils::packageVersion("future")
[16:22:08.249]                         }
[16:22:08.249]                         else {
[16:22:08.249]                           version <- NULL
[16:22:08.249]                         }
[16:22:08.249]                         if (!has_future || version < "1.8.0") {
[16:22:08.249]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.249]                             "", base::R.version$version.string), 
[16:22:08.249]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.249]                               "release", "version")], collapse = " "), 
[16:22:08.249]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.249]                             info)
[16:22:08.249]                           info <- base::paste(info, collapse = "; ")
[16:22:08.249]                           if (!has_future) {
[16:22:08.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.249]                               info)
[16:22:08.249]                           }
[16:22:08.249]                           else {
[16:22:08.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.249]                               info, version)
[16:22:08.249]                           }
[16:22:08.249]                           base::stop(msg)
[16:22:08.249]                         }
[16:22:08.249]                       })
[16:22:08.249]                     }
[16:22:08.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.249]                     base::options(mc.cores = 1L)
[16:22:08.249]                   }
[16:22:08.249]                   ...future.strategy.old <- future::plan("list")
[16:22:08.249]                   options(future.plan = NULL)
[16:22:08.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.249]                 }
[16:22:08.249]                 ...future.workdir <- getwd()
[16:22:08.249]             }
[16:22:08.249]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.249]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.249]         }
[16:22:08.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.249]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.249]             base::names(...future.oldOptions))
[16:22:08.249]     }
[16:22:08.249]     if (FALSE) {
[16:22:08.249]     }
[16:22:08.249]     else {
[16:22:08.249]         if (TRUE) {
[16:22:08.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.249]                 open = "w")
[16:22:08.249]         }
[16:22:08.249]         else {
[16:22:08.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.249]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.249]         }
[16:22:08.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.249]             base::sink(type = "output", split = FALSE)
[16:22:08.249]             base::close(...future.stdout)
[16:22:08.249]         }, add = TRUE)
[16:22:08.249]     }
[16:22:08.249]     ...future.frame <- base::sys.nframe()
[16:22:08.249]     ...future.conditions <- base::list()
[16:22:08.249]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.249]     if (FALSE) {
[16:22:08.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.249]     }
[16:22:08.249]     ...future.result <- base::tryCatch({
[16:22:08.249]         base::withCallingHandlers({
[16:22:08.249]             ...future.value <- base::withVisible(base::local({
[16:22:08.249]                 ...future.makeSendCondition <- base::local({
[16:22:08.249]                   sendCondition <- NULL
[16:22:08.249]                   function(frame = 1L) {
[16:22:08.249]                     if (is.function(sendCondition)) 
[16:22:08.249]                       return(sendCondition)
[16:22:08.249]                     ns <- getNamespace("parallel")
[16:22:08.249]                     if (exists("sendData", mode = "function", 
[16:22:08.249]                       envir = ns)) {
[16:22:08.249]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.249]                         envir = ns)
[16:22:08.249]                       envir <- sys.frame(frame)
[16:22:08.249]                       master <- NULL
[16:22:08.249]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.249]                         !identical(envir, emptyenv())) {
[16:22:08.249]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.249]                           inherits = FALSE)) {
[16:22:08.249]                           master <- get("master", mode = "list", 
[16:22:08.249]                             envir = envir, inherits = FALSE)
[16:22:08.249]                           if (inherits(master, c("SOCKnode", 
[16:22:08.249]                             "SOCK0node"))) {
[16:22:08.249]                             sendCondition <<- function(cond) {
[16:22:08.249]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.249]                                 success = TRUE)
[16:22:08.249]                               parallel_sendData(master, data)
[16:22:08.249]                             }
[16:22:08.249]                             return(sendCondition)
[16:22:08.249]                           }
[16:22:08.249]                         }
[16:22:08.249]                         frame <- frame + 1L
[16:22:08.249]                         envir <- sys.frame(frame)
[16:22:08.249]                       }
[16:22:08.249]                     }
[16:22:08.249]                     sendCondition <<- function(cond) NULL
[16:22:08.249]                   }
[16:22:08.249]                 })
[16:22:08.249]                 withCallingHandlers({
[16:22:08.249]                   1
[16:22:08.249]                 }, immediateCondition = function(cond) {
[16:22:08.249]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.249]                   sendCondition(cond)
[16:22:08.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.249]                   {
[16:22:08.249]                     inherits <- base::inherits
[16:22:08.249]                     invokeRestart <- base::invokeRestart
[16:22:08.249]                     is.null <- base::is.null
[16:22:08.249]                     muffled <- FALSE
[16:22:08.249]                     if (inherits(cond, "message")) {
[16:22:08.249]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.249]                       if (muffled) 
[16:22:08.249]                         invokeRestart("muffleMessage")
[16:22:08.249]                     }
[16:22:08.249]                     else if (inherits(cond, "warning")) {
[16:22:08.249]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.249]                       if (muffled) 
[16:22:08.249]                         invokeRestart("muffleWarning")
[16:22:08.249]                     }
[16:22:08.249]                     else if (inherits(cond, "condition")) {
[16:22:08.249]                       if (!is.null(pattern)) {
[16:22:08.249]                         computeRestarts <- base::computeRestarts
[16:22:08.249]                         grepl <- base::grepl
[16:22:08.249]                         restarts <- computeRestarts(cond)
[16:22:08.249]                         for (restart in restarts) {
[16:22:08.249]                           name <- restart$name
[16:22:08.249]                           if (is.null(name)) 
[16:22:08.249]                             next
[16:22:08.249]                           if (!grepl(pattern, name)) 
[16:22:08.249]                             next
[16:22:08.249]                           invokeRestart(restart)
[16:22:08.249]                           muffled <- TRUE
[16:22:08.249]                           break
[16:22:08.249]                         }
[16:22:08.249]                       }
[16:22:08.249]                     }
[16:22:08.249]                     invisible(muffled)
[16:22:08.249]                   }
[16:22:08.249]                   muffleCondition(cond)
[16:22:08.249]                 })
[16:22:08.249]             }))
[16:22:08.249]             future::FutureResult(value = ...future.value$value, 
[16:22:08.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.249]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.249]                     ...future.globalenv.names))
[16:22:08.249]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.249]         }, condition = base::local({
[16:22:08.249]             c <- base::c
[16:22:08.249]             inherits <- base::inherits
[16:22:08.249]             invokeRestart <- base::invokeRestart
[16:22:08.249]             length <- base::length
[16:22:08.249]             list <- base::list
[16:22:08.249]             seq.int <- base::seq.int
[16:22:08.249]             signalCondition <- base::signalCondition
[16:22:08.249]             sys.calls <- base::sys.calls
[16:22:08.249]             `[[` <- base::`[[`
[16:22:08.249]             `+` <- base::`+`
[16:22:08.249]             `<<-` <- base::`<<-`
[16:22:08.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.249]                   3L)]
[16:22:08.249]             }
[16:22:08.249]             function(cond) {
[16:22:08.249]                 is_error <- inherits(cond, "error")
[16:22:08.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.249]                   NULL)
[16:22:08.249]                 if (is_error) {
[16:22:08.249]                   sessionInformation <- function() {
[16:22:08.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.249]                       search = base::search(), system = base::Sys.info())
[16:22:08.249]                   }
[16:22:08.249]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.249]                     cond$call), session = sessionInformation(), 
[16:22:08.249]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.249]                   signalCondition(cond)
[16:22:08.249]                 }
[16:22:08.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.249]                 "immediateCondition"))) {
[16:22:08.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.249]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.249]                   if (TRUE && !signal) {
[16:22:08.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.249]                     {
[16:22:08.249]                       inherits <- base::inherits
[16:22:08.249]                       invokeRestart <- base::invokeRestart
[16:22:08.249]                       is.null <- base::is.null
[16:22:08.249]                       muffled <- FALSE
[16:22:08.249]                       if (inherits(cond, "message")) {
[16:22:08.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.249]                         if (muffled) 
[16:22:08.249]                           invokeRestart("muffleMessage")
[16:22:08.249]                       }
[16:22:08.249]                       else if (inherits(cond, "warning")) {
[16:22:08.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.249]                         if (muffled) 
[16:22:08.249]                           invokeRestart("muffleWarning")
[16:22:08.249]                       }
[16:22:08.249]                       else if (inherits(cond, "condition")) {
[16:22:08.249]                         if (!is.null(pattern)) {
[16:22:08.249]                           computeRestarts <- base::computeRestarts
[16:22:08.249]                           grepl <- base::grepl
[16:22:08.249]                           restarts <- computeRestarts(cond)
[16:22:08.249]                           for (restart in restarts) {
[16:22:08.249]                             name <- restart$name
[16:22:08.249]                             if (is.null(name)) 
[16:22:08.249]                               next
[16:22:08.249]                             if (!grepl(pattern, name)) 
[16:22:08.249]                               next
[16:22:08.249]                             invokeRestart(restart)
[16:22:08.249]                             muffled <- TRUE
[16:22:08.249]                             break
[16:22:08.249]                           }
[16:22:08.249]                         }
[16:22:08.249]                       }
[16:22:08.249]                       invisible(muffled)
[16:22:08.249]                     }
[16:22:08.249]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.249]                   }
[16:22:08.249]                 }
[16:22:08.249]                 else {
[16:22:08.249]                   if (TRUE) {
[16:22:08.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.249]                     {
[16:22:08.249]                       inherits <- base::inherits
[16:22:08.249]                       invokeRestart <- base::invokeRestart
[16:22:08.249]                       is.null <- base::is.null
[16:22:08.249]                       muffled <- FALSE
[16:22:08.249]                       if (inherits(cond, "message")) {
[16:22:08.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.249]                         if (muffled) 
[16:22:08.249]                           invokeRestart("muffleMessage")
[16:22:08.249]                       }
[16:22:08.249]                       else if (inherits(cond, "warning")) {
[16:22:08.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.249]                         if (muffled) 
[16:22:08.249]                           invokeRestart("muffleWarning")
[16:22:08.249]                       }
[16:22:08.249]                       else if (inherits(cond, "condition")) {
[16:22:08.249]                         if (!is.null(pattern)) {
[16:22:08.249]                           computeRestarts <- base::computeRestarts
[16:22:08.249]                           grepl <- base::grepl
[16:22:08.249]                           restarts <- computeRestarts(cond)
[16:22:08.249]                           for (restart in restarts) {
[16:22:08.249]                             name <- restart$name
[16:22:08.249]                             if (is.null(name)) 
[16:22:08.249]                               next
[16:22:08.249]                             if (!grepl(pattern, name)) 
[16:22:08.249]                               next
[16:22:08.249]                             invokeRestart(restart)
[16:22:08.249]                             muffled <- TRUE
[16:22:08.249]                             break
[16:22:08.249]                           }
[16:22:08.249]                         }
[16:22:08.249]                       }
[16:22:08.249]                       invisible(muffled)
[16:22:08.249]                     }
[16:22:08.249]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.249]                   }
[16:22:08.249]                 }
[16:22:08.249]             }
[16:22:08.249]         }))
[16:22:08.249]     }, error = function(ex) {
[16:22:08.249]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.249]                 ...future.rng), started = ...future.startTime, 
[16:22:08.249]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.249]             version = "1.8"), class = "FutureResult")
[16:22:08.249]     }, finally = {
[16:22:08.249]         if (!identical(...future.workdir, getwd())) 
[16:22:08.249]             setwd(...future.workdir)
[16:22:08.249]         {
[16:22:08.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.249]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.249]             }
[16:22:08.249]             base::options(...future.oldOptions)
[16:22:08.249]             if (.Platform$OS.type == "windows") {
[16:22:08.249]                 old_names <- names(...future.oldEnvVars)
[16:22:08.249]                 envs <- base::Sys.getenv()
[16:22:08.249]                 names <- names(envs)
[16:22:08.249]                 common <- intersect(names, old_names)
[16:22:08.249]                 added <- setdiff(names, old_names)
[16:22:08.249]                 removed <- setdiff(old_names, names)
[16:22:08.249]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.249]                   envs[common]]
[16:22:08.249]                 NAMES <- toupper(changed)
[16:22:08.249]                 args <- list()
[16:22:08.249]                 for (kk in seq_along(NAMES)) {
[16:22:08.249]                   name <- changed[[kk]]
[16:22:08.249]                   NAME <- NAMES[[kk]]
[16:22:08.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.249]                     next
[16:22:08.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.249]                 }
[16:22:08.249]                 NAMES <- toupper(added)
[16:22:08.249]                 for (kk in seq_along(NAMES)) {
[16:22:08.249]                   name <- added[[kk]]
[16:22:08.249]                   NAME <- NAMES[[kk]]
[16:22:08.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.249]                     next
[16:22:08.249]                   args[[name]] <- ""
[16:22:08.249]                 }
[16:22:08.249]                 NAMES <- toupper(removed)
[16:22:08.249]                 for (kk in seq_along(NAMES)) {
[16:22:08.249]                   name <- removed[[kk]]
[16:22:08.249]                   NAME <- NAMES[[kk]]
[16:22:08.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.249]                     next
[16:22:08.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.249]                 }
[16:22:08.249]                 if (length(args) > 0) 
[16:22:08.249]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.249]             }
[16:22:08.249]             else {
[16:22:08.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.249]             }
[16:22:08.249]             {
[16:22:08.249]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.249]                   0L) {
[16:22:08.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.249]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.249]                   base::options(opts)
[16:22:08.249]                 }
[16:22:08.249]                 {
[16:22:08.249]                   {
[16:22:08.249]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.249]                     NULL
[16:22:08.249]                   }
[16:22:08.249]                   options(future.plan = NULL)
[16:22:08.249]                   if (is.na(NA_character_)) 
[16:22:08.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.249]                     .init = FALSE)
[16:22:08.249]                 }
[16:22:08.249]             }
[16:22:08.249]         }
[16:22:08.249]     })
[16:22:08.249]     if (TRUE) {
[16:22:08.249]         base::sink(type = "output", split = FALSE)
[16:22:08.249]         if (TRUE) {
[16:22:08.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.249]         }
[16:22:08.249]         else {
[16:22:08.249]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.249]         }
[16:22:08.249]         base::close(...future.stdout)
[16:22:08.249]         ...future.stdout <- NULL
[16:22:08.249]     }
[16:22:08.249]     ...future.result$conditions <- ...future.conditions
[16:22:08.249]     ...future.result$finished <- base::Sys.time()
[16:22:08.249]     ...future.result
[16:22:08.249] }
[16:22:08.252] MultisessionFuture started
[16:22:08.252] - Launch lazy future ... done
[16:22:08.253] run() for ‘MultisessionFuture’ ... done
[16:22:08.253] getGlobalsAndPackages() ...
[16:22:08.253] Searching for globals...
[16:22:08.257] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:22:08.257] Searching for globals ... DONE
[16:22:08.257] Resolving globals: FALSE
[16:22:08.258] 
[16:22:08.258] 
[16:22:08.258] getGlobalsAndPackages() ... DONE
[16:22:08.258] run() for ‘Future’ ...
[16:22:08.258] - state: ‘created’
[16:22:08.258] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.272] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.272]   - Field: ‘node’
[16:22:08.272]   - Field: ‘label’
[16:22:08.272]   - Field: ‘local’
[16:22:08.273]   - Field: ‘owner’
[16:22:08.273]   - Field: ‘envir’
[16:22:08.273]   - Field: ‘workers’
[16:22:08.273]   - Field: ‘packages’
[16:22:08.273]   - Field: ‘gc’
[16:22:08.273]   - Field: ‘conditions’
[16:22:08.273]   - Field: ‘persistent’
[16:22:08.273]   - Field: ‘expr’
[16:22:08.273]   - Field: ‘uuid’
[16:22:08.273]   - Field: ‘seed’
[16:22:08.273]   - Field: ‘version’
[16:22:08.274]   - Field: ‘result’
[16:22:08.274]   - Field: ‘asynchronous’
[16:22:08.274]   - Field: ‘calls’
[16:22:08.274]   - Field: ‘globals’
[16:22:08.274]   - Field: ‘stdout’
[16:22:08.274]   - Field: ‘earlySignal’
[16:22:08.274]   - Field: ‘lazy’
[16:22:08.274]   - Field: ‘state’
[16:22:08.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.274] - Launch lazy future ...
[16:22:08.275] Packages needed by the future expression (n = 0): <none>
[16:22:08.275] Packages needed by future strategies (n = 0): <none>
[16:22:08.275] {
[16:22:08.275]     {
[16:22:08.275]         {
[16:22:08.275]             ...future.startTime <- base::Sys.time()
[16:22:08.275]             {
[16:22:08.275]                 {
[16:22:08.275]                   {
[16:22:08.275]                     {
[16:22:08.275]                       base::local({
[16:22:08.275]                         has_future <- base::requireNamespace("future", 
[16:22:08.275]                           quietly = TRUE)
[16:22:08.275]                         if (has_future) {
[16:22:08.275]                           ns <- base::getNamespace("future")
[16:22:08.275]                           version <- ns[[".package"]][["version"]]
[16:22:08.275]                           if (is.null(version)) 
[16:22:08.275]                             version <- utils::packageVersion("future")
[16:22:08.275]                         }
[16:22:08.275]                         else {
[16:22:08.275]                           version <- NULL
[16:22:08.275]                         }
[16:22:08.275]                         if (!has_future || version < "1.8.0") {
[16:22:08.275]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.275]                             "", base::R.version$version.string), 
[16:22:08.275]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.275]                               "release", "version")], collapse = " "), 
[16:22:08.275]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.275]                             info)
[16:22:08.275]                           info <- base::paste(info, collapse = "; ")
[16:22:08.275]                           if (!has_future) {
[16:22:08.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.275]                               info)
[16:22:08.275]                           }
[16:22:08.275]                           else {
[16:22:08.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.275]                               info, version)
[16:22:08.275]                           }
[16:22:08.275]                           base::stop(msg)
[16:22:08.275]                         }
[16:22:08.275]                       })
[16:22:08.275]                     }
[16:22:08.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.275]                     base::options(mc.cores = 1L)
[16:22:08.275]                   }
[16:22:08.275]                   ...future.strategy.old <- future::plan("list")
[16:22:08.275]                   options(future.plan = NULL)
[16:22:08.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.275]                 }
[16:22:08.275]                 ...future.workdir <- getwd()
[16:22:08.275]             }
[16:22:08.275]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.275]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.275]         }
[16:22:08.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.275]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.275]             base::names(...future.oldOptions))
[16:22:08.275]     }
[16:22:08.275]     if (FALSE) {
[16:22:08.275]     }
[16:22:08.275]     else {
[16:22:08.275]         if (TRUE) {
[16:22:08.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.275]                 open = "w")
[16:22:08.275]         }
[16:22:08.275]         else {
[16:22:08.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.275]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.275]         }
[16:22:08.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.275]             base::sink(type = "output", split = FALSE)
[16:22:08.275]             base::close(...future.stdout)
[16:22:08.275]         }, add = TRUE)
[16:22:08.275]     }
[16:22:08.275]     ...future.frame <- base::sys.nframe()
[16:22:08.275]     ...future.conditions <- base::list()
[16:22:08.275]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.275]     if (FALSE) {
[16:22:08.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.275]     }
[16:22:08.275]     ...future.result <- base::tryCatch({
[16:22:08.275]         base::withCallingHandlers({
[16:22:08.275]             ...future.value <- base::withVisible(base::local({
[16:22:08.275]                 ...future.makeSendCondition <- base::local({
[16:22:08.275]                   sendCondition <- NULL
[16:22:08.275]                   function(frame = 1L) {
[16:22:08.275]                     if (is.function(sendCondition)) 
[16:22:08.275]                       return(sendCondition)
[16:22:08.275]                     ns <- getNamespace("parallel")
[16:22:08.275]                     if (exists("sendData", mode = "function", 
[16:22:08.275]                       envir = ns)) {
[16:22:08.275]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.275]                         envir = ns)
[16:22:08.275]                       envir <- sys.frame(frame)
[16:22:08.275]                       master <- NULL
[16:22:08.275]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.275]                         !identical(envir, emptyenv())) {
[16:22:08.275]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.275]                           inherits = FALSE)) {
[16:22:08.275]                           master <- get("master", mode = "list", 
[16:22:08.275]                             envir = envir, inherits = FALSE)
[16:22:08.275]                           if (inherits(master, c("SOCKnode", 
[16:22:08.275]                             "SOCK0node"))) {
[16:22:08.275]                             sendCondition <<- function(cond) {
[16:22:08.275]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.275]                                 success = TRUE)
[16:22:08.275]                               parallel_sendData(master, data)
[16:22:08.275]                             }
[16:22:08.275]                             return(sendCondition)
[16:22:08.275]                           }
[16:22:08.275]                         }
[16:22:08.275]                         frame <- frame + 1L
[16:22:08.275]                         envir <- sys.frame(frame)
[16:22:08.275]                       }
[16:22:08.275]                     }
[16:22:08.275]                     sendCondition <<- function(cond) NULL
[16:22:08.275]                   }
[16:22:08.275]                 })
[16:22:08.275]                 withCallingHandlers({
[16:22:08.275]                   {
[16:22:08.275]                     Sys.sleep(0.5)
[16:22:08.275]                     2
[16:22:08.275]                   }
[16:22:08.275]                 }, immediateCondition = function(cond) {
[16:22:08.275]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.275]                   sendCondition(cond)
[16:22:08.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.275]                   {
[16:22:08.275]                     inherits <- base::inherits
[16:22:08.275]                     invokeRestart <- base::invokeRestart
[16:22:08.275]                     is.null <- base::is.null
[16:22:08.275]                     muffled <- FALSE
[16:22:08.275]                     if (inherits(cond, "message")) {
[16:22:08.275]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.275]                       if (muffled) 
[16:22:08.275]                         invokeRestart("muffleMessage")
[16:22:08.275]                     }
[16:22:08.275]                     else if (inherits(cond, "warning")) {
[16:22:08.275]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.275]                       if (muffled) 
[16:22:08.275]                         invokeRestart("muffleWarning")
[16:22:08.275]                     }
[16:22:08.275]                     else if (inherits(cond, "condition")) {
[16:22:08.275]                       if (!is.null(pattern)) {
[16:22:08.275]                         computeRestarts <- base::computeRestarts
[16:22:08.275]                         grepl <- base::grepl
[16:22:08.275]                         restarts <- computeRestarts(cond)
[16:22:08.275]                         for (restart in restarts) {
[16:22:08.275]                           name <- restart$name
[16:22:08.275]                           if (is.null(name)) 
[16:22:08.275]                             next
[16:22:08.275]                           if (!grepl(pattern, name)) 
[16:22:08.275]                             next
[16:22:08.275]                           invokeRestart(restart)
[16:22:08.275]                           muffled <- TRUE
[16:22:08.275]                           break
[16:22:08.275]                         }
[16:22:08.275]                       }
[16:22:08.275]                     }
[16:22:08.275]                     invisible(muffled)
[16:22:08.275]                   }
[16:22:08.275]                   muffleCondition(cond)
[16:22:08.275]                 })
[16:22:08.275]             }))
[16:22:08.275]             future::FutureResult(value = ...future.value$value, 
[16:22:08.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.275]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.275]                     ...future.globalenv.names))
[16:22:08.275]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.275]         }, condition = base::local({
[16:22:08.275]             c <- base::c
[16:22:08.275]             inherits <- base::inherits
[16:22:08.275]             invokeRestart <- base::invokeRestart
[16:22:08.275]             length <- base::length
[16:22:08.275]             list <- base::list
[16:22:08.275]             seq.int <- base::seq.int
[16:22:08.275]             signalCondition <- base::signalCondition
[16:22:08.275]             sys.calls <- base::sys.calls
[16:22:08.275]             `[[` <- base::`[[`
[16:22:08.275]             `+` <- base::`+`
[16:22:08.275]             `<<-` <- base::`<<-`
[16:22:08.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.275]                   3L)]
[16:22:08.275]             }
[16:22:08.275]             function(cond) {
[16:22:08.275]                 is_error <- inherits(cond, "error")
[16:22:08.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.275]                   NULL)
[16:22:08.275]                 if (is_error) {
[16:22:08.275]                   sessionInformation <- function() {
[16:22:08.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.275]                       search = base::search(), system = base::Sys.info())
[16:22:08.275]                   }
[16:22:08.275]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.275]                     cond$call), session = sessionInformation(), 
[16:22:08.275]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.275]                   signalCondition(cond)
[16:22:08.275]                 }
[16:22:08.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.275]                 "immediateCondition"))) {
[16:22:08.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.275]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.275]                   if (TRUE && !signal) {
[16:22:08.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.275]                     {
[16:22:08.275]                       inherits <- base::inherits
[16:22:08.275]                       invokeRestart <- base::invokeRestart
[16:22:08.275]                       is.null <- base::is.null
[16:22:08.275]                       muffled <- FALSE
[16:22:08.275]                       if (inherits(cond, "message")) {
[16:22:08.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.275]                         if (muffled) 
[16:22:08.275]                           invokeRestart("muffleMessage")
[16:22:08.275]                       }
[16:22:08.275]                       else if (inherits(cond, "warning")) {
[16:22:08.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.275]                         if (muffled) 
[16:22:08.275]                           invokeRestart("muffleWarning")
[16:22:08.275]                       }
[16:22:08.275]                       else if (inherits(cond, "condition")) {
[16:22:08.275]                         if (!is.null(pattern)) {
[16:22:08.275]                           computeRestarts <- base::computeRestarts
[16:22:08.275]                           grepl <- base::grepl
[16:22:08.275]                           restarts <- computeRestarts(cond)
[16:22:08.275]                           for (restart in restarts) {
[16:22:08.275]                             name <- restart$name
[16:22:08.275]                             if (is.null(name)) 
[16:22:08.275]                               next
[16:22:08.275]                             if (!grepl(pattern, name)) 
[16:22:08.275]                               next
[16:22:08.275]                             invokeRestart(restart)
[16:22:08.275]                             muffled <- TRUE
[16:22:08.275]                             break
[16:22:08.275]                           }
[16:22:08.275]                         }
[16:22:08.275]                       }
[16:22:08.275]                       invisible(muffled)
[16:22:08.275]                     }
[16:22:08.275]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.275]                   }
[16:22:08.275]                 }
[16:22:08.275]                 else {
[16:22:08.275]                   if (TRUE) {
[16:22:08.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.275]                     {
[16:22:08.275]                       inherits <- base::inherits
[16:22:08.275]                       invokeRestart <- base::invokeRestart
[16:22:08.275]                       is.null <- base::is.null
[16:22:08.275]                       muffled <- FALSE
[16:22:08.275]                       if (inherits(cond, "message")) {
[16:22:08.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.275]                         if (muffled) 
[16:22:08.275]                           invokeRestart("muffleMessage")
[16:22:08.275]                       }
[16:22:08.275]                       else if (inherits(cond, "warning")) {
[16:22:08.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.275]                         if (muffled) 
[16:22:08.275]                           invokeRestart("muffleWarning")
[16:22:08.275]                       }
[16:22:08.275]                       else if (inherits(cond, "condition")) {
[16:22:08.275]                         if (!is.null(pattern)) {
[16:22:08.275]                           computeRestarts <- base::computeRestarts
[16:22:08.275]                           grepl <- base::grepl
[16:22:08.275]                           restarts <- computeRestarts(cond)
[16:22:08.275]                           for (restart in restarts) {
[16:22:08.275]                             name <- restart$name
[16:22:08.275]                             if (is.null(name)) 
[16:22:08.275]                               next
[16:22:08.275]                             if (!grepl(pattern, name)) 
[16:22:08.275]                               next
[16:22:08.275]                             invokeRestart(restart)
[16:22:08.275]                             muffled <- TRUE
[16:22:08.275]                             break
[16:22:08.275]                           }
[16:22:08.275]                         }
[16:22:08.275]                       }
[16:22:08.275]                       invisible(muffled)
[16:22:08.275]                     }
[16:22:08.275]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.275]                   }
[16:22:08.275]                 }
[16:22:08.275]             }
[16:22:08.275]         }))
[16:22:08.275]     }, error = function(ex) {
[16:22:08.275]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.275]                 ...future.rng), started = ...future.startTime, 
[16:22:08.275]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.275]             version = "1.8"), class = "FutureResult")
[16:22:08.275]     }, finally = {
[16:22:08.275]         if (!identical(...future.workdir, getwd())) 
[16:22:08.275]             setwd(...future.workdir)
[16:22:08.275]         {
[16:22:08.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.275]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.275]             }
[16:22:08.275]             base::options(...future.oldOptions)
[16:22:08.275]             if (.Platform$OS.type == "windows") {
[16:22:08.275]                 old_names <- names(...future.oldEnvVars)
[16:22:08.275]                 envs <- base::Sys.getenv()
[16:22:08.275]                 names <- names(envs)
[16:22:08.275]                 common <- intersect(names, old_names)
[16:22:08.275]                 added <- setdiff(names, old_names)
[16:22:08.275]                 removed <- setdiff(old_names, names)
[16:22:08.275]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.275]                   envs[common]]
[16:22:08.275]                 NAMES <- toupper(changed)
[16:22:08.275]                 args <- list()
[16:22:08.275]                 for (kk in seq_along(NAMES)) {
[16:22:08.275]                   name <- changed[[kk]]
[16:22:08.275]                   NAME <- NAMES[[kk]]
[16:22:08.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.275]                     next
[16:22:08.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.275]                 }
[16:22:08.275]                 NAMES <- toupper(added)
[16:22:08.275]                 for (kk in seq_along(NAMES)) {
[16:22:08.275]                   name <- added[[kk]]
[16:22:08.275]                   NAME <- NAMES[[kk]]
[16:22:08.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.275]                     next
[16:22:08.275]                   args[[name]] <- ""
[16:22:08.275]                 }
[16:22:08.275]                 NAMES <- toupper(removed)
[16:22:08.275]                 for (kk in seq_along(NAMES)) {
[16:22:08.275]                   name <- removed[[kk]]
[16:22:08.275]                   NAME <- NAMES[[kk]]
[16:22:08.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.275]                     next
[16:22:08.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.275]                 }
[16:22:08.275]                 if (length(args) > 0) 
[16:22:08.275]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.275]             }
[16:22:08.275]             else {
[16:22:08.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.275]             }
[16:22:08.275]             {
[16:22:08.275]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.275]                   0L) {
[16:22:08.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.275]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.275]                   base::options(opts)
[16:22:08.275]                 }
[16:22:08.275]                 {
[16:22:08.275]                   {
[16:22:08.275]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.275]                     NULL
[16:22:08.275]                   }
[16:22:08.275]                   options(future.plan = NULL)
[16:22:08.275]                   if (is.na(NA_character_)) 
[16:22:08.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.275]                     .init = FALSE)
[16:22:08.275]                 }
[16:22:08.275]             }
[16:22:08.275]         }
[16:22:08.275]     })
[16:22:08.275]     if (TRUE) {
[16:22:08.275]         base::sink(type = "output", split = FALSE)
[16:22:08.275]         if (TRUE) {
[16:22:08.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.275]         }
[16:22:08.275]         else {
[16:22:08.275]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.275]         }
[16:22:08.275]         base::close(...future.stdout)
[16:22:08.275]         ...future.stdout <- NULL
[16:22:08.275]     }
[16:22:08.275]     ...future.result$conditions <- ...future.conditions
[16:22:08.275]     ...future.result$finished <- base::Sys.time()
[16:22:08.275]     ...future.result
[16:22:08.275] }
[16:22:08.278] MultisessionFuture started
[16:22:08.278] - Launch lazy future ... done
[16:22:08.278] run() for ‘MultisessionFuture’ ... done
[16:22:08.279] resolve() on list ...
[16:22:08.279]  recursive: 0
[16:22:08.279]  length: 1
[16:22:08.279] 
[16:22:08.280] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.280] - Validating connection of MultisessionFuture
[16:22:08.280] - received message: FutureResult
[16:22:08.280] - Received FutureResult
[16:22:08.280] - Erased future from FutureRegistry
[16:22:08.280] result() for ClusterFuture ...
[16:22:08.281] - result already collected: FutureResult
[16:22:08.281] result() for ClusterFuture ... done
[16:22:08.281] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.281] Future #1
[16:22:08.281]  length: 0 (resolved future 1)
[16:22:08.281] resolve() on list ... DONE
[16:22:08.281] resolve() on list ...
[16:22:08.281]  recursive: 0
[16:22:08.281]  length: 1
[16:22:08.281] 
[16:22:08.783] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.783] - Validating connection of MultisessionFuture
[16:22:08.783] - received message: FutureResult
[16:22:08.783] - Received FutureResult
[16:22:08.784] - Erased future from FutureRegistry
[16:22:08.784] result() for ClusterFuture ...
[16:22:08.784] - result already collected: FutureResult
[16:22:08.784] result() for ClusterFuture ... done
[16:22:08.784] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.784] Future #1
[16:22:08.784]  length: 0 (resolved future 1)
[16:22:08.784] resolve() on list ... DONE
[16:22:08.785] resolve() on list ...
[16:22:08.785]  recursive: 0
[16:22:08.785]  length: 1
[16:22:08.785] 
[16:22:08.785]  length: 0 (resolved future 1)
[16:22:08.785] resolve() on list ... DONE
[16:22:08.785] resolve() on list ...
[16:22:08.785]  recursive: 0
[16:22:08.785]  length: 4
[16:22:08.785] 
[16:22:08.786] Future #1
[16:22:08.786]  length: 3 (resolved future 1)
[16:22:08.786] Future #2
[16:22:08.786]  length: 2 (resolved future 2)
[16:22:08.786]  length: 1 (resolved future 3)
[16:22:08.786]  length: 0 (resolved future 4)
[16:22:08.786] resolve() on list ... DONE
[16:22:08.786] resolve() on list ...
[16:22:08.786]  recursive: 0
[16:22:08.787]  length: 4
[16:22:08.787] 
[16:22:08.787] Future #1
[16:22:08.787]  length: 3 (resolved future 1)
[16:22:08.787] Future #2
[16:22:08.787]  length: 2 (resolved future 2)
[16:22:08.787]  length: 1 (resolved future 3)
[16:22:08.787]  length: 0 (resolved future 4)
[16:22:08.787] resolve() on list ... DONE
[16:22:08.788] resolve() on list ...
[16:22:08.788]  recursive: 0
[16:22:08.788]  length: 1
[16:22:08.788] 
[16:22:08.788]  length: 0 (resolved future 1)
[16:22:08.788] resolve() on list ... DONE
[16:22:08.788] getGlobalsAndPackages() ...
[16:22:08.788] Searching for globals...
[16:22:08.789] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:22:08.789] Searching for globals ... DONE
[16:22:08.790] Resolving globals: FALSE
[16:22:08.790] The total size of the 1 globals is 56 bytes (56 bytes)
[16:22:08.790] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:22:08.790] - globals: [1] ‘kk’
[16:22:08.791] 
[16:22:08.791] getGlobalsAndPackages() ... DONE
[16:22:08.791] run() for ‘Future’ ...
[16:22:08.791] - state: ‘created’
[16:22:08.791] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.805] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.806]   - Field: ‘node’
[16:22:08.806]   - Field: ‘label’
[16:22:08.806]   - Field: ‘local’
[16:22:08.806]   - Field: ‘owner’
[16:22:08.806]   - Field: ‘envir’
[16:22:08.806]   - Field: ‘workers’
[16:22:08.806]   - Field: ‘packages’
[16:22:08.806]   - Field: ‘gc’
[16:22:08.806]   - Field: ‘conditions’
[16:22:08.806]   - Field: ‘persistent’
[16:22:08.807]   - Field: ‘expr’
[16:22:08.807]   - Field: ‘uuid’
[16:22:08.807]   - Field: ‘seed’
[16:22:08.807]   - Field: ‘version’
[16:22:08.807]   - Field: ‘result’
[16:22:08.807]   - Field: ‘asynchronous’
[16:22:08.807]   - Field: ‘calls’
[16:22:08.807]   - Field: ‘globals’
[16:22:08.807]   - Field: ‘stdout’
[16:22:08.807]   - Field: ‘earlySignal’
[16:22:08.807]   - Field: ‘lazy’
[16:22:08.808]   - Field: ‘state’
[16:22:08.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.808] - Launch lazy future ...
[16:22:08.808] Packages needed by the future expression (n = 0): <none>
[16:22:08.808] Packages needed by future strategies (n = 0): <none>
[16:22:08.809] {
[16:22:08.809]     {
[16:22:08.809]         {
[16:22:08.809]             ...future.startTime <- base::Sys.time()
[16:22:08.809]             {
[16:22:08.809]                 {
[16:22:08.809]                   {
[16:22:08.809]                     {
[16:22:08.809]                       base::local({
[16:22:08.809]                         has_future <- base::requireNamespace("future", 
[16:22:08.809]                           quietly = TRUE)
[16:22:08.809]                         if (has_future) {
[16:22:08.809]                           ns <- base::getNamespace("future")
[16:22:08.809]                           version <- ns[[".package"]][["version"]]
[16:22:08.809]                           if (is.null(version)) 
[16:22:08.809]                             version <- utils::packageVersion("future")
[16:22:08.809]                         }
[16:22:08.809]                         else {
[16:22:08.809]                           version <- NULL
[16:22:08.809]                         }
[16:22:08.809]                         if (!has_future || version < "1.8.0") {
[16:22:08.809]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.809]                             "", base::R.version$version.string), 
[16:22:08.809]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.809]                               "release", "version")], collapse = " "), 
[16:22:08.809]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.809]                             info)
[16:22:08.809]                           info <- base::paste(info, collapse = "; ")
[16:22:08.809]                           if (!has_future) {
[16:22:08.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.809]                               info)
[16:22:08.809]                           }
[16:22:08.809]                           else {
[16:22:08.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.809]                               info, version)
[16:22:08.809]                           }
[16:22:08.809]                           base::stop(msg)
[16:22:08.809]                         }
[16:22:08.809]                       })
[16:22:08.809]                     }
[16:22:08.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.809]                     base::options(mc.cores = 1L)
[16:22:08.809]                   }
[16:22:08.809]                   ...future.strategy.old <- future::plan("list")
[16:22:08.809]                   options(future.plan = NULL)
[16:22:08.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.809]                 }
[16:22:08.809]                 ...future.workdir <- getwd()
[16:22:08.809]             }
[16:22:08.809]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.809]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.809]         }
[16:22:08.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.809]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.809]             base::names(...future.oldOptions))
[16:22:08.809]     }
[16:22:08.809]     if (FALSE) {
[16:22:08.809]     }
[16:22:08.809]     else {
[16:22:08.809]         if (TRUE) {
[16:22:08.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.809]                 open = "w")
[16:22:08.809]         }
[16:22:08.809]         else {
[16:22:08.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.809]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.809]         }
[16:22:08.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.809]             base::sink(type = "output", split = FALSE)
[16:22:08.809]             base::close(...future.stdout)
[16:22:08.809]         }, add = TRUE)
[16:22:08.809]     }
[16:22:08.809]     ...future.frame <- base::sys.nframe()
[16:22:08.809]     ...future.conditions <- base::list()
[16:22:08.809]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.809]     if (FALSE) {
[16:22:08.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.809]     }
[16:22:08.809]     ...future.result <- base::tryCatch({
[16:22:08.809]         base::withCallingHandlers({
[16:22:08.809]             ...future.value <- base::withVisible(base::local({
[16:22:08.809]                 ...future.makeSendCondition <- base::local({
[16:22:08.809]                   sendCondition <- NULL
[16:22:08.809]                   function(frame = 1L) {
[16:22:08.809]                     if (is.function(sendCondition)) 
[16:22:08.809]                       return(sendCondition)
[16:22:08.809]                     ns <- getNamespace("parallel")
[16:22:08.809]                     if (exists("sendData", mode = "function", 
[16:22:08.809]                       envir = ns)) {
[16:22:08.809]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.809]                         envir = ns)
[16:22:08.809]                       envir <- sys.frame(frame)
[16:22:08.809]                       master <- NULL
[16:22:08.809]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.809]                         !identical(envir, emptyenv())) {
[16:22:08.809]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.809]                           inherits = FALSE)) {
[16:22:08.809]                           master <- get("master", mode = "list", 
[16:22:08.809]                             envir = envir, inherits = FALSE)
[16:22:08.809]                           if (inherits(master, c("SOCKnode", 
[16:22:08.809]                             "SOCK0node"))) {
[16:22:08.809]                             sendCondition <<- function(cond) {
[16:22:08.809]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.809]                                 success = TRUE)
[16:22:08.809]                               parallel_sendData(master, data)
[16:22:08.809]                             }
[16:22:08.809]                             return(sendCondition)
[16:22:08.809]                           }
[16:22:08.809]                         }
[16:22:08.809]                         frame <- frame + 1L
[16:22:08.809]                         envir <- sys.frame(frame)
[16:22:08.809]                       }
[16:22:08.809]                     }
[16:22:08.809]                     sendCondition <<- function(cond) NULL
[16:22:08.809]                   }
[16:22:08.809]                 })
[16:22:08.809]                 withCallingHandlers({
[16:22:08.809]                   {
[16:22:08.809]                     Sys.sleep(0.1)
[16:22:08.809]                     kk
[16:22:08.809]                   }
[16:22:08.809]                 }, immediateCondition = function(cond) {
[16:22:08.809]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.809]                   sendCondition(cond)
[16:22:08.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.809]                   {
[16:22:08.809]                     inherits <- base::inherits
[16:22:08.809]                     invokeRestart <- base::invokeRestart
[16:22:08.809]                     is.null <- base::is.null
[16:22:08.809]                     muffled <- FALSE
[16:22:08.809]                     if (inherits(cond, "message")) {
[16:22:08.809]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.809]                       if (muffled) 
[16:22:08.809]                         invokeRestart("muffleMessage")
[16:22:08.809]                     }
[16:22:08.809]                     else if (inherits(cond, "warning")) {
[16:22:08.809]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.809]                       if (muffled) 
[16:22:08.809]                         invokeRestart("muffleWarning")
[16:22:08.809]                     }
[16:22:08.809]                     else if (inherits(cond, "condition")) {
[16:22:08.809]                       if (!is.null(pattern)) {
[16:22:08.809]                         computeRestarts <- base::computeRestarts
[16:22:08.809]                         grepl <- base::grepl
[16:22:08.809]                         restarts <- computeRestarts(cond)
[16:22:08.809]                         for (restart in restarts) {
[16:22:08.809]                           name <- restart$name
[16:22:08.809]                           if (is.null(name)) 
[16:22:08.809]                             next
[16:22:08.809]                           if (!grepl(pattern, name)) 
[16:22:08.809]                             next
[16:22:08.809]                           invokeRestart(restart)
[16:22:08.809]                           muffled <- TRUE
[16:22:08.809]                           break
[16:22:08.809]                         }
[16:22:08.809]                       }
[16:22:08.809]                     }
[16:22:08.809]                     invisible(muffled)
[16:22:08.809]                   }
[16:22:08.809]                   muffleCondition(cond)
[16:22:08.809]                 })
[16:22:08.809]             }))
[16:22:08.809]             future::FutureResult(value = ...future.value$value, 
[16:22:08.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.809]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.809]                     ...future.globalenv.names))
[16:22:08.809]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.809]         }, condition = base::local({
[16:22:08.809]             c <- base::c
[16:22:08.809]             inherits <- base::inherits
[16:22:08.809]             invokeRestart <- base::invokeRestart
[16:22:08.809]             length <- base::length
[16:22:08.809]             list <- base::list
[16:22:08.809]             seq.int <- base::seq.int
[16:22:08.809]             signalCondition <- base::signalCondition
[16:22:08.809]             sys.calls <- base::sys.calls
[16:22:08.809]             `[[` <- base::`[[`
[16:22:08.809]             `+` <- base::`+`
[16:22:08.809]             `<<-` <- base::`<<-`
[16:22:08.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.809]                   3L)]
[16:22:08.809]             }
[16:22:08.809]             function(cond) {
[16:22:08.809]                 is_error <- inherits(cond, "error")
[16:22:08.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.809]                   NULL)
[16:22:08.809]                 if (is_error) {
[16:22:08.809]                   sessionInformation <- function() {
[16:22:08.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.809]                       search = base::search(), system = base::Sys.info())
[16:22:08.809]                   }
[16:22:08.809]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.809]                     cond$call), session = sessionInformation(), 
[16:22:08.809]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.809]                   signalCondition(cond)
[16:22:08.809]                 }
[16:22:08.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.809]                 "immediateCondition"))) {
[16:22:08.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.809]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.809]                   if (TRUE && !signal) {
[16:22:08.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.809]                     {
[16:22:08.809]                       inherits <- base::inherits
[16:22:08.809]                       invokeRestart <- base::invokeRestart
[16:22:08.809]                       is.null <- base::is.null
[16:22:08.809]                       muffled <- FALSE
[16:22:08.809]                       if (inherits(cond, "message")) {
[16:22:08.809]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.809]                         if (muffled) 
[16:22:08.809]                           invokeRestart("muffleMessage")
[16:22:08.809]                       }
[16:22:08.809]                       else if (inherits(cond, "warning")) {
[16:22:08.809]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.809]                         if (muffled) 
[16:22:08.809]                           invokeRestart("muffleWarning")
[16:22:08.809]                       }
[16:22:08.809]                       else if (inherits(cond, "condition")) {
[16:22:08.809]                         if (!is.null(pattern)) {
[16:22:08.809]                           computeRestarts <- base::computeRestarts
[16:22:08.809]                           grepl <- base::grepl
[16:22:08.809]                           restarts <- computeRestarts(cond)
[16:22:08.809]                           for (restart in restarts) {
[16:22:08.809]                             name <- restart$name
[16:22:08.809]                             if (is.null(name)) 
[16:22:08.809]                               next
[16:22:08.809]                             if (!grepl(pattern, name)) 
[16:22:08.809]                               next
[16:22:08.809]                             invokeRestart(restart)
[16:22:08.809]                             muffled <- TRUE
[16:22:08.809]                             break
[16:22:08.809]                           }
[16:22:08.809]                         }
[16:22:08.809]                       }
[16:22:08.809]                       invisible(muffled)
[16:22:08.809]                     }
[16:22:08.809]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.809]                   }
[16:22:08.809]                 }
[16:22:08.809]                 else {
[16:22:08.809]                   if (TRUE) {
[16:22:08.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.809]                     {
[16:22:08.809]                       inherits <- base::inherits
[16:22:08.809]                       invokeRestart <- base::invokeRestart
[16:22:08.809]                       is.null <- base::is.null
[16:22:08.809]                       muffled <- FALSE
[16:22:08.809]                       if (inherits(cond, "message")) {
[16:22:08.809]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.809]                         if (muffled) 
[16:22:08.809]                           invokeRestart("muffleMessage")
[16:22:08.809]                       }
[16:22:08.809]                       else if (inherits(cond, "warning")) {
[16:22:08.809]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.809]                         if (muffled) 
[16:22:08.809]                           invokeRestart("muffleWarning")
[16:22:08.809]                       }
[16:22:08.809]                       else if (inherits(cond, "condition")) {
[16:22:08.809]                         if (!is.null(pattern)) {
[16:22:08.809]                           computeRestarts <- base::computeRestarts
[16:22:08.809]                           grepl <- base::grepl
[16:22:08.809]                           restarts <- computeRestarts(cond)
[16:22:08.809]                           for (restart in restarts) {
[16:22:08.809]                             name <- restart$name
[16:22:08.809]                             if (is.null(name)) 
[16:22:08.809]                               next
[16:22:08.809]                             if (!grepl(pattern, name)) 
[16:22:08.809]                               next
[16:22:08.809]                             invokeRestart(restart)
[16:22:08.809]                             muffled <- TRUE
[16:22:08.809]                             break
[16:22:08.809]                           }
[16:22:08.809]                         }
[16:22:08.809]                       }
[16:22:08.809]                       invisible(muffled)
[16:22:08.809]                     }
[16:22:08.809]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.809]                   }
[16:22:08.809]                 }
[16:22:08.809]             }
[16:22:08.809]         }))
[16:22:08.809]     }, error = function(ex) {
[16:22:08.809]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.809]                 ...future.rng), started = ...future.startTime, 
[16:22:08.809]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.809]             version = "1.8"), class = "FutureResult")
[16:22:08.809]     }, finally = {
[16:22:08.809]         if (!identical(...future.workdir, getwd())) 
[16:22:08.809]             setwd(...future.workdir)
[16:22:08.809]         {
[16:22:08.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.809]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.809]             }
[16:22:08.809]             base::options(...future.oldOptions)
[16:22:08.809]             if (.Platform$OS.type == "windows") {
[16:22:08.809]                 old_names <- names(...future.oldEnvVars)
[16:22:08.809]                 envs <- base::Sys.getenv()
[16:22:08.809]                 names <- names(envs)
[16:22:08.809]                 common <- intersect(names, old_names)
[16:22:08.809]                 added <- setdiff(names, old_names)
[16:22:08.809]                 removed <- setdiff(old_names, names)
[16:22:08.809]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.809]                   envs[common]]
[16:22:08.809]                 NAMES <- toupper(changed)
[16:22:08.809]                 args <- list()
[16:22:08.809]                 for (kk in seq_along(NAMES)) {
[16:22:08.809]                   name <- changed[[kk]]
[16:22:08.809]                   NAME <- NAMES[[kk]]
[16:22:08.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.809]                     next
[16:22:08.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.809]                 }
[16:22:08.809]                 NAMES <- toupper(added)
[16:22:08.809]                 for (kk in seq_along(NAMES)) {
[16:22:08.809]                   name <- added[[kk]]
[16:22:08.809]                   NAME <- NAMES[[kk]]
[16:22:08.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.809]                     next
[16:22:08.809]                   args[[name]] <- ""
[16:22:08.809]                 }
[16:22:08.809]                 NAMES <- toupper(removed)
[16:22:08.809]                 for (kk in seq_along(NAMES)) {
[16:22:08.809]                   name <- removed[[kk]]
[16:22:08.809]                   NAME <- NAMES[[kk]]
[16:22:08.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.809]                     next
[16:22:08.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.809]                 }
[16:22:08.809]                 if (length(args) > 0) 
[16:22:08.809]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.809]             }
[16:22:08.809]             else {
[16:22:08.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.809]             }
[16:22:08.809]             {
[16:22:08.809]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.809]                   0L) {
[16:22:08.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.809]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.809]                   base::options(opts)
[16:22:08.809]                 }
[16:22:08.809]                 {
[16:22:08.809]                   {
[16:22:08.809]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.809]                     NULL
[16:22:08.809]                   }
[16:22:08.809]                   options(future.plan = NULL)
[16:22:08.809]                   if (is.na(NA_character_)) 
[16:22:08.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.809]                     .init = FALSE)
[16:22:08.809]                 }
[16:22:08.809]             }
[16:22:08.809]         }
[16:22:08.809]     })
[16:22:08.809]     if (TRUE) {
[16:22:08.809]         base::sink(type = "output", split = FALSE)
[16:22:08.809]         if (TRUE) {
[16:22:08.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.809]         }
[16:22:08.809]         else {
[16:22:08.809]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.809]         }
[16:22:08.809]         base::close(...future.stdout)
[16:22:08.809]         ...future.stdout <- NULL
[16:22:08.809]     }
[16:22:08.809]     ...future.result$conditions <- ...future.conditions
[16:22:08.809]     ...future.result$finished <- base::Sys.time()
[16:22:08.809]     ...future.result
[16:22:08.809] }
[16:22:08.811] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:22:08.811] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:22:08.812] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:22:08.812] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:22:08.812] MultisessionFuture started
[16:22:08.812] - Launch lazy future ... done
[16:22:08.813] run() for ‘MultisessionFuture’ ... done
[16:22:08.813] getGlobalsAndPackages() ...
[16:22:08.813] Searching for globals...
[16:22:08.814] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:22:08.814] Searching for globals ... DONE
[16:22:08.814] Resolving globals: FALSE
[16:22:08.814] The total size of the 1 globals is 56 bytes (56 bytes)
[16:22:08.815] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:22:08.815] - globals: [1] ‘kk’
[16:22:08.815] 
[16:22:08.815] getGlobalsAndPackages() ... DONE
[16:22:08.815] run() for ‘Future’ ...
[16:22:08.815] - state: ‘created’
[16:22:08.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.829]   - Field: ‘node’
[16:22:08.829]   - Field: ‘label’
[16:22:08.829]   - Field: ‘local’
[16:22:08.830]   - Field: ‘owner’
[16:22:08.830]   - Field: ‘envir’
[16:22:08.830]   - Field: ‘workers’
[16:22:08.830]   - Field: ‘packages’
[16:22:08.830]   - Field: ‘gc’
[16:22:08.830]   - Field: ‘conditions’
[16:22:08.830]   - Field: ‘persistent’
[16:22:08.830]   - Field: ‘expr’
[16:22:08.830]   - Field: ‘uuid’
[16:22:08.830]   - Field: ‘seed’
[16:22:08.830]   - Field: ‘version’
[16:22:08.831]   - Field: ‘result’
[16:22:08.831]   - Field: ‘asynchronous’
[16:22:08.831]   - Field: ‘calls’
[16:22:08.831]   - Field: ‘globals’
[16:22:08.831]   - Field: ‘stdout’
[16:22:08.831]   - Field: ‘earlySignal’
[16:22:08.831]   - Field: ‘lazy’
[16:22:08.831]   - Field: ‘state’
[16:22:08.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.831] - Launch lazy future ...
[16:22:08.832] Packages needed by the future expression (n = 0): <none>
[16:22:08.832] Packages needed by future strategies (n = 0): <none>
[16:22:08.832] {
[16:22:08.832]     {
[16:22:08.832]         {
[16:22:08.832]             ...future.startTime <- base::Sys.time()
[16:22:08.832]             {
[16:22:08.832]                 {
[16:22:08.832]                   {
[16:22:08.832]                     {
[16:22:08.832]                       base::local({
[16:22:08.832]                         has_future <- base::requireNamespace("future", 
[16:22:08.832]                           quietly = TRUE)
[16:22:08.832]                         if (has_future) {
[16:22:08.832]                           ns <- base::getNamespace("future")
[16:22:08.832]                           version <- ns[[".package"]][["version"]]
[16:22:08.832]                           if (is.null(version)) 
[16:22:08.832]                             version <- utils::packageVersion("future")
[16:22:08.832]                         }
[16:22:08.832]                         else {
[16:22:08.832]                           version <- NULL
[16:22:08.832]                         }
[16:22:08.832]                         if (!has_future || version < "1.8.0") {
[16:22:08.832]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.832]                             "", base::R.version$version.string), 
[16:22:08.832]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.832]                               "release", "version")], collapse = " "), 
[16:22:08.832]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.832]                             info)
[16:22:08.832]                           info <- base::paste(info, collapse = "; ")
[16:22:08.832]                           if (!has_future) {
[16:22:08.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.832]                               info)
[16:22:08.832]                           }
[16:22:08.832]                           else {
[16:22:08.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.832]                               info, version)
[16:22:08.832]                           }
[16:22:08.832]                           base::stop(msg)
[16:22:08.832]                         }
[16:22:08.832]                       })
[16:22:08.832]                     }
[16:22:08.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.832]                     base::options(mc.cores = 1L)
[16:22:08.832]                   }
[16:22:08.832]                   ...future.strategy.old <- future::plan("list")
[16:22:08.832]                   options(future.plan = NULL)
[16:22:08.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.832]                 }
[16:22:08.832]                 ...future.workdir <- getwd()
[16:22:08.832]             }
[16:22:08.832]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.832]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.832]         }
[16:22:08.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.832]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.832]             base::names(...future.oldOptions))
[16:22:08.832]     }
[16:22:08.832]     if (FALSE) {
[16:22:08.832]     }
[16:22:08.832]     else {
[16:22:08.832]         if (TRUE) {
[16:22:08.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.832]                 open = "w")
[16:22:08.832]         }
[16:22:08.832]         else {
[16:22:08.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.832]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.832]         }
[16:22:08.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.832]             base::sink(type = "output", split = FALSE)
[16:22:08.832]             base::close(...future.stdout)
[16:22:08.832]         }, add = TRUE)
[16:22:08.832]     }
[16:22:08.832]     ...future.frame <- base::sys.nframe()
[16:22:08.832]     ...future.conditions <- base::list()
[16:22:08.832]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.832]     if (FALSE) {
[16:22:08.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.832]     }
[16:22:08.832]     ...future.result <- base::tryCatch({
[16:22:08.832]         base::withCallingHandlers({
[16:22:08.832]             ...future.value <- base::withVisible(base::local({
[16:22:08.832]                 ...future.makeSendCondition <- base::local({
[16:22:08.832]                   sendCondition <- NULL
[16:22:08.832]                   function(frame = 1L) {
[16:22:08.832]                     if (is.function(sendCondition)) 
[16:22:08.832]                       return(sendCondition)
[16:22:08.832]                     ns <- getNamespace("parallel")
[16:22:08.832]                     if (exists("sendData", mode = "function", 
[16:22:08.832]                       envir = ns)) {
[16:22:08.832]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.832]                         envir = ns)
[16:22:08.832]                       envir <- sys.frame(frame)
[16:22:08.832]                       master <- NULL
[16:22:08.832]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.832]                         !identical(envir, emptyenv())) {
[16:22:08.832]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.832]                           inherits = FALSE)) {
[16:22:08.832]                           master <- get("master", mode = "list", 
[16:22:08.832]                             envir = envir, inherits = FALSE)
[16:22:08.832]                           if (inherits(master, c("SOCKnode", 
[16:22:08.832]                             "SOCK0node"))) {
[16:22:08.832]                             sendCondition <<- function(cond) {
[16:22:08.832]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.832]                                 success = TRUE)
[16:22:08.832]                               parallel_sendData(master, data)
[16:22:08.832]                             }
[16:22:08.832]                             return(sendCondition)
[16:22:08.832]                           }
[16:22:08.832]                         }
[16:22:08.832]                         frame <- frame + 1L
[16:22:08.832]                         envir <- sys.frame(frame)
[16:22:08.832]                       }
[16:22:08.832]                     }
[16:22:08.832]                     sendCondition <<- function(cond) NULL
[16:22:08.832]                   }
[16:22:08.832]                 })
[16:22:08.832]                 withCallingHandlers({
[16:22:08.832]                   {
[16:22:08.832]                     Sys.sleep(0.1)
[16:22:08.832]                     kk
[16:22:08.832]                   }
[16:22:08.832]                 }, immediateCondition = function(cond) {
[16:22:08.832]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.832]                   sendCondition(cond)
[16:22:08.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.832]                   {
[16:22:08.832]                     inherits <- base::inherits
[16:22:08.832]                     invokeRestart <- base::invokeRestart
[16:22:08.832]                     is.null <- base::is.null
[16:22:08.832]                     muffled <- FALSE
[16:22:08.832]                     if (inherits(cond, "message")) {
[16:22:08.832]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.832]                       if (muffled) 
[16:22:08.832]                         invokeRestart("muffleMessage")
[16:22:08.832]                     }
[16:22:08.832]                     else if (inherits(cond, "warning")) {
[16:22:08.832]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.832]                       if (muffled) 
[16:22:08.832]                         invokeRestart("muffleWarning")
[16:22:08.832]                     }
[16:22:08.832]                     else if (inherits(cond, "condition")) {
[16:22:08.832]                       if (!is.null(pattern)) {
[16:22:08.832]                         computeRestarts <- base::computeRestarts
[16:22:08.832]                         grepl <- base::grepl
[16:22:08.832]                         restarts <- computeRestarts(cond)
[16:22:08.832]                         for (restart in restarts) {
[16:22:08.832]                           name <- restart$name
[16:22:08.832]                           if (is.null(name)) 
[16:22:08.832]                             next
[16:22:08.832]                           if (!grepl(pattern, name)) 
[16:22:08.832]                             next
[16:22:08.832]                           invokeRestart(restart)
[16:22:08.832]                           muffled <- TRUE
[16:22:08.832]                           break
[16:22:08.832]                         }
[16:22:08.832]                       }
[16:22:08.832]                     }
[16:22:08.832]                     invisible(muffled)
[16:22:08.832]                   }
[16:22:08.832]                   muffleCondition(cond)
[16:22:08.832]                 })
[16:22:08.832]             }))
[16:22:08.832]             future::FutureResult(value = ...future.value$value, 
[16:22:08.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.832]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.832]                     ...future.globalenv.names))
[16:22:08.832]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.832]         }, condition = base::local({
[16:22:08.832]             c <- base::c
[16:22:08.832]             inherits <- base::inherits
[16:22:08.832]             invokeRestart <- base::invokeRestart
[16:22:08.832]             length <- base::length
[16:22:08.832]             list <- base::list
[16:22:08.832]             seq.int <- base::seq.int
[16:22:08.832]             signalCondition <- base::signalCondition
[16:22:08.832]             sys.calls <- base::sys.calls
[16:22:08.832]             `[[` <- base::`[[`
[16:22:08.832]             `+` <- base::`+`
[16:22:08.832]             `<<-` <- base::`<<-`
[16:22:08.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.832]                   3L)]
[16:22:08.832]             }
[16:22:08.832]             function(cond) {
[16:22:08.832]                 is_error <- inherits(cond, "error")
[16:22:08.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.832]                   NULL)
[16:22:08.832]                 if (is_error) {
[16:22:08.832]                   sessionInformation <- function() {
[16:22:08.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.832]                       search = base::search(), system = base::Sys.info())
[16:22:08.832]                   }
[16:22:08.832]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.832]                     cond$call), session = sessionInformation(), 
[16:22:08.832]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.832]                   signalCondition(cond)
[16:22:08.832]                 }
[16:22:08.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.832]                 "immediateCondition"))) {
[16:22:08.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.832]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.832]                   if (TRUE && !signal) {
[16:22:08.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.832]                     {
[16:22:08.832]                       inherits <- base::inherits
[16:22:08.832]                       invokeRestart <- base::invokeRestart
[16:22:08.832]                       is.null <- base::is.null
[16:22:08.832]                       muffled <- FALSE
[16:22:08.832]                       if (inherits(cond, "message")) {
[16:22:08.832]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.832]                         if (muffled) 
[16:22:08.832]                           invokeRestart("muffleMessage")
[16:22:08.832]                       }
[16:22:08.832]                       else if (inherits(cond, "warning")) {
[16:22:08.832]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.832]                         if (muffled) 
[16:22:08.832]                           invokeRestart("muffleWarning")
[16:22:08.832]                       }
[16:22:08.832]                       else if (inherits(cond, "condition")) {
[16:22:08.832]                         if (!is.null(pattern)) {
[16:22:08.832]                           computeRestarts <- base::computeRestarts
[16:22:08.832]                           grepl <- base::grepl
[16:22:08.832]                           restarts <- computeRestarts(cond)
[16:22:08.832]                           for (restart in restarts) {
[16:22:08.832]                             name <- restart$name
[16:22:08.832]                             if (is.null(name)) 
[16:22:08.832]                               next
[16:22:08.832]                             if (!grepl(pattern, name)) 
[16:22:08.832]                               next
[16:22:08.832]                             invokeRestart(restart)
[16:22:08.832]                             muffled <- TRUE
[16:22:08.832]                             break
[16:22:08.832]                           }
[16:22:08.832]                         }
[16:22:08.832]                       }
[16:22:08.832]                       invisible(muffled)
[16:22:08.832]                     }
[16:22:08.832]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.832]                   }
[16:22:08.832]                 }
[16:22:08.832]                 else {
[16:22:08.832]                   if (TRUE) {
[16:22:08.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.832]                     {
[16:22:08.832]                       inherits <- base::inherits
[16:22:08.832]                       invokeRestart <- base::invokeRestart
[16:22:08.832]                       is.null <- base::is.null
[16:22:08.832]                       muffled <- FALSE
[16:22:08.832]                       if (inherits(cond, "message")) {
[16:22:08.832]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.832]                         if (muffled) 
[16:22:08.832]                           invokeRestart("muffleMessage")
[16:22:08.832]                       }
[16:22:08.832]                       else if (inherits(cond, "warning")) {
[16:22:08.832]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.832]                         if (muffled) 
[16:22:08.832]                           invokeRestart("muffleWarning")
[16:22:08.832]                       }
[16:22:08.832]                       else if (inherits(cond, "condition")) {
[16:22:08.832]                         if (!is.null(pattern)) {
[16:22:08.832]                           computeRestarts <- base::computeRestarts
[16:22:08.832]                           grepl <- base::grepl
[16:22:08.832]                           restarts <- computeRestarts(cond)
[16:22:08.832]                           for (restart in restarts) {
[16:22:08.832]                             name <- restart$name
[16:22:08.832]                             if (is.null(name)) 
[16:22:08.832]                               next
[16:22:08.832]                             if (!grepl(pattern, name)) 
[16:22:08.832]                               next
[16:22:08.832]                             invokeRestart(restart)
[16:22:08.832]                             muffled <- TRUE
[16:22:08.832]                             break
[16:22:08.832]                           }
[16:22:08.832]                         }
[16:22:08.832]                       }
[16:22:08.832]                       invisible(muffled)
[16:22:08.832]                     }
[16:22:08.832]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.832]                   }
[16:22:08.832]                 }
[16:22:08.832]             }
[16:22:08.832]         }))
[16:22:08.832]     }, error = function(ex) {
[16:22:08.832]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.832]                 ...future.rng), started = ...future.startTime, 
[16:22:08.832]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.832]             version = "1.8"), class = "FutureResult")
[16:22:08.832]     }, finally = {
[16:22:08.832]         if (!identical(...future.workdir, getwd())) 
[16:22:08.832]             setwd(...future.workdir)
[16:22:08.832]         {
[16:22:08.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.832]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.832]             }
[16:22:08.832]             base::options(...future.oldOptions)
[16:22:08.832]             if (.Platform$OS.type == "windows") {
[16:22:08.832]                 old_names <- names(...future.oldEnvVars)
[16:22:08.832]                 envs <- base::Sys.getenv()
[16:22:08.832]                 names <- names(envs)
[16:22:08.832]                 common <- intersect(names, old_names)
[16:22:08.832]                 added <- setdiff(names, old_names)
[16:22:08.832]                 removed <- setdiff(old_names, names)
[16:22:08.832]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.832]                   envs[common]]
[16:22:08.832]                 NAMES <- toupper(changed)
[16:22:08.832]                 args <- list()
[16:22:08.832]                 for (kk in seq_along(NAMES)) {
[16:22:08.832]                   name <- changed[[kk]]
[16:22:08.832]                   NAME <- NAMES[[kk]]
[16:22:08.832]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.832]                     next
[16:22:08.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.832]                 }
[16:22:08.832]                 NAMES <- toupper(added)
[16:22:08.832]                 for (kk in seq_along(NAMES)) {
[16:22:08.832]                   name <- added[[kk]]
[16:22:08.832]                   NAME <- NAMES[[kk]]
[16:22:08.832]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.832]                     next
[16:22:08.832]                   args[[name]] <- ""
[16:22:08.832]                 }
[16:22:08.832]                 NAMES <- toupper(removed)
[16:22:08.832]                 for (kk in seq_along(NAMES)) {
[16:22:08.832]                   name <- removed[[kk]]
[16:22:08.832]                   NAME <- NAMES[[kk]]
[16:22:08.832]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.832]                     next
[16:22:08.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.832]                 }
[16:22:08.832]                 if (length(args) > 0) 
[16:22:08.832]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.832]             }
[16:22:08.832]             else {
[16:22:08.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.832]             }
[16:22:08.832]             {
[16:22:08.832]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.832]                   0L) {
[16:22:08.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.832]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.832]                   base::options(opts)
[16:22:08.832]                 }
[16:22:08.832]                 {
[16:22:08.832]                   {
[16:22:08.832]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.832]                     NULL
[16:22:08.832]                   }
[16:22:08.832]                   options(future.plan = NULL)
[16:22:08.832]                   if (is.na(NA_character_)) 
[16:22:08.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.832]                     .init = FALSE)
[16:22:08.832]                 }
[16:22:08.832]             }
[16:22:08.832]         }
[16:22:08.832]     })
[16:22:08.832]     if (TRUE) {
[16:22:08.832]         base::sink(type = "output", split = FALSE)
[16:22:08.832]         if (TRUE) {
[16:22:08.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.832]         }
[16:22:08.832]         else {
[16:22:08.832]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.832]         }
[16:22:08.832]         base::close(...future.stdout)
[16:22:08.832]         ...future.stdout <- NULL
[16:22:08.832]     }
[16:22:08.832]     ...future.result$conditions <- ...future.conditions
[16:22:08.832]     ...future.result$finished <- base::Sys.time()
[16:22:08.832]     ...future.result
[16:22:08.832] }
[16:22:08.835] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:22:08.835] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[16:22:08.835] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[16:22:08.835] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:22:08.836] MultisessionFuture started
[16:22:08.836] - Launch lazy future ... done
[16:22:08.836] run() for ‘MultisessionFuture’ ... done
[16:22:08.837] getGlobalsAndPackages() ...
[16:22:08.837] Searching for globals...
[16:22:08.838] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:22:08.838] Searching for globals ... DONE
[16:22:08.838] Resolving globals: FALSE
[16:22:08.839] The total size of the 1 globals is 56 bytes (56 bytes)
[16:22:08.839] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:22:08.839] - globals: [1] ‘kk’
[16:22:08.839] 
[16:22:08.839] getGlobalsAndPackages() ... DONE
[16:22:08.840] run() for ‘Future’ ...
[16:22:08.840] - state: ‘created’
[16:22:08.840] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:08.854] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:08.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:08.854]   - Field: ‘node’
[16:22:08.854]   - Field: ‘label’
[16:22:08.854]   - Field: ‘local’
[16:22:08.854]   - Field: ‘owner’
[16:22:08.854]   - Field: ‘envir’
[16:22:08.854]   - Field: ‘workers’
[16:22:08.854]   - Field: ‘packages’
[16:22:08.855]   - Field: ‘gc’
[16:22:08.855]   - Field: ‘conditions’
[16:22:08.855]   - Field: ‘persistent’
[16:22:08.855]   - Field: ‘expr’
[16:22:08.855]   - Field: ‘uuid’
[16:22:08.855]   - Field: ‘seed’
[16:22:08.855]   - Field: ‘version’
[16:22:08.855]   - Field: ‘result’
[16:22:08.855]   - Field: ‘asynchronous’
[16:22:08.855]   - Field: ‘calls’
[16:22:08.855]   - Field: ‘globals’
[16:22:08.856]   - Field: ‘stdout’
[16:22:08.856]   - Field: ‘earlySignal’
[16:22:08.856]   - Field: ‘lazy’
[16:22:08.856]   - Field: ‘state’
[16:22:08.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:08.856] - Launch lazy future ...
[16:22:08.856] Packages needed by the future expression (n = 0): <none>
[16:22:08.856] Packages needed by future strategies (n = 0): <none>
[16:22:08.857] {
[16:22:08.857]     {
[16:22:08.857]         {
[16:22:08.857]             ...future.startTime <- base::Sys.time()
[16:22:08.857]             {
[16:22:08.857]                 {
[16:22:08.857]                   {
[16:22:08.857]                     {
[16:22:08.857]                       base::local({
[16:22:08.857]                         has_future <- base::requireNamespace("future", 
[16:22:08.857]                           quietly = TRUE)
[16:22:08.857]                         if (has_future) {
[16:22:08.857]                           ns <- base::getNamespace("future")
[16:22:08.857]                           version <- ns[[".package"]][["version"]]
[16:22:08.857]                           if (is.null(version)) 
[16:22:08.857]                             version <- utils::packageVersion("future")
[16:22:08.857]                         }
[16:22:08.857]                         else {
[16:22:08.857]                           version <- NULL
[16:22:08.857]                         }
[16:22:08.857]                         if (!has_future || version < "1.8.0") {
[16:22:08.857]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:08.857]                             "", base::R.version$version.string), 
[16:22:08.857]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:08.857]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:08.857]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:08.857]                               "release", "version")], collapse = " "), 
[16:22:08.857]                             hostname = base::Sys.info()[["nodename"]])
[16:22:08.857]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:08.857]                             info)
[16:22:08.857]                           info <- base::paste(info, collapse = "; ")
[16:22:08.857]                           if (!has_future) {
[16:22:08.857]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:08.857]                               info)
[16:22:08.857]                           }
[16:22:08.857]                           else {
[16:22:08.857]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:08.857]                               info, version)
[16:22:08.857]                           }
[16:22:08.857]                           base::stop(msg)
[16:22:08.857]                         }
[16:22:08.857]                       })
[16:22:08.857]                     }
[16:22:08.857]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:08.857]                     base::options(mc.cores = 1L)
[16:22:08.857]                   }
[16:22:08.857]                   ...future.strategy.old <- future::plan("list")
[16:22:08.857]                   options(future.plan = NULL)
[16:22:08.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:08.857]                 }
[16:22:08.857]                 ...future.workdir <- getwd()
[16:22:08.857]             }
[16:22:08.857]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:08.857]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:08.857]         }
[16:22:08.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:08.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:08.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:08.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:08.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:08.857]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:08.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:08.857]             base::names(...future.oldOptions))
[16:22:08.857]     }
[16:22:08.857]     if (FALSE) {
[16:22:08.857]     }
[16:22:08.857]     else {
[16:22:08.857]         if (TRUE) {
[16:22:08.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:08.857]                 open = "w")
[16:22:08.857]         }
[16:22:08.857]         else {
[16:22:08.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:08.857]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:08.857]         }
[16:22:08.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:08.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:08.857]             base::sink(type = "output", split = FALSE)
[16:22:08.857]             base::close(...future.stdout)
[16:22:08.857]         }, add = TRUE)
[16:22:08.857]     }
[16:22:08.857]     ...future.frame <- base::sys.nframe()
[16:22:08.857]     ...future.conditions <- base::list()
[16:22:08.857]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:08.857]     if (FALSE) {
[16:22:08.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:08.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:08.857]     }
[16:22:08.857]     ...future.result <- base::tryCatch({
[16:22:08.857]         base::withCallingHandlers({
[16:22:08.857]             ...future.value <- base::withVisible(base::local({
[16:22:08.857]                 ...future.makeSendCondition <- base::local({
[16:22:08.857]                   sendCondition <- NULL
[16:22:08.857]                   function(frame = 1L) {
[16:22:08.857]                     if (is.function(sendCondition)) 
[16:22:08.857]                       return(sendCondition)
[16:22:08.857]                     ns <- getNamespace("parallel")
[16:22:08.857]                     if (exists("sendData", mode = "function", 
[16:22:08.857]                       envir = ns)) {
[16:22:08.857]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:08.857]                         envir = ns)
[16:22:08.857]                       envir <- sys.frame(frame)
[16:22:08.857]                       master <- NULL
[16:22:08.857]                       while (!identical(envir, .GlobalEnv) && 
[16:22:08.857]                         !identical(envir, emptyenv())) {
[16:22:08.857]                         if (exists("master", mode = "list", envir = envir, 
[16:22:08.857]                           inherits = FALSE)) {
[16:22:08.857]                           master <- get("master", mode = "list", 
[16:22:08.857]                             envir = envir, inherits = FALSE)
[16:22:08.857]                           if (inherits(master, c("SOCKnode", 
[16:22:08.857]                             "SOCK0node"))) {
[16:22:08.857]                             sendCondition <<- function(cond) {
[16:22:08.857]                               data <- list(type = "VALUE", value = cond, 
[16:22:08.857]                                 success = TRUE)
[16:22:08.857]                               parallel_sendData(master, data)
[16:22:08.857]                             }
[16:22:08.857]                             return(sendCondition)
[16:22:08.857]                           }
[16:22:08.857]                         }
[16:22:08.857]                         frame <- frame + 1L
[16:22:08.857]                         envir <- sys.frame(frame)
[16:22:08.857]                       }
[16:22:08.857]                     }
[16:22:08.857]                     sendCondition <<- function(cond) NULL
[16:22:08.857]                   }
[16:22:08.857]                 })
[16:22:08.857]                 withCallingHandlers({
[16:22:08.857]                   {
[16:22:08.857]                     Sys.sleep(0.1)
[16:22:08.857]                     kk
[16:22:08.857]                   }
[16:22:08.857]                 }, immediateCondition = function(cond) {
[16:22:08.857]                   sendCondition <- ...future.makeSendCondition()
[16:22:08.857]                   sendCondition(cond)
[16:22:08.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.857]                   {
[16:22:08.857]                     inherits <- base::inherits
[16:22:08.857]                     invokeRestart <- base::invokeRestart
[16:22:08.857]                     is.null <- base::is.null
[16:22:08.857]                     muffled <- FALSE
[16:22:08.857]                     if (inherits(cond, "message")) {
[16:22:08.857]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:08.857]                       if (muffled) 
[16:22:08.857]                         invokeRestart("muffleMessage")
[16:22:08.857]                     }
[16:22:08.857]                     else if (inherits(cond, "warning")) {
[16:22:08.857]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:08.857]                       if (muffled) 
[16:22:08.857]                         invokeRestart("muffleWarning")
[16:22:08.857]                     }
[16:22:08.857]                     else if (inherits(cond, "condition")) {
[16:22:08.857]                       if (!is.null(pattern)) {
[16:22:08.857]                         computeRestarts <- base::computeRestarts
[16:22:08.857]                         grepl <- base::grepl
[16:22:08.857]                         restarts <- computeRestarts(cond)
[16:22:08.857]                         for (restart in restarts) {
[16:22:08.857]                           name <- restart$name
[16:22:08.857]                           if (is.null(name)) 
[16:22:08.857]                             next
[16:22:08.857]                           if (!grepl(pattern, name)) 
[16:22:08.857]                             next
[16:22:08.857]                           invokeRestart(restart)
[16:22:08.857]                           muffled <- TRUE
[16:22:08.857]                           break
[16:22:08.857]                         }
[16:22:08.857]                       }
[16:22:08.857]                     }
[16:22:08.857]                     invisible(muffled)
[16:22:08.857]                   }
[16:22:08.857]                   muffleCondition(cond)
[16:22:08.857]                 })
[16:22:08.857]             }))
[16:22:08.857]             future::FutureResult(value = ...future.value$value, 
[16:22:08.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.857]                   ...future.rng), globalenv = if (FALSE) 
[16:22:08.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:08.857]                     ...future.globalenv.names))
[16:22:08.857]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:08.857]         }, condition = base::local({
[16:22:08.857]             c <- base::c
[16:22:08.857]             inherits <- base::inherits
[16:22:08.857]             invokeRestart <- base::invokeRestart
[16:22:08.857]             length <- base::length
[16:22:08.857]             list <- base::list
[16:22:08.857]             seq.int <- base::seq.int
[16:22:08.857]             signalCondition <- base::signalCondition
[16:22:08.857]             sys.calls <- base::sys.calls
[16:22:08.857]             `[[` <- base::`[[`
[16:22:08.857]             `+` <- base::`+`
[16:22:08.857]             `<<-` <- base::`<<-`
[16:22:08.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:08.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:08.857]                   3L)]
[16:22:08.857]             }
[16:22:08.857]             function(cond) {
[16:22:08.857]                 is_error <- inherits(cond, "error")
[16:22:08.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:08.857]                   NULL)
[16:22:08.857]                 if (is_error) {
[16:22:08.857]                   sessionInformation <- function() {
[16:22:08.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:08.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:08.857]                       search = base::search(), system = base::Sys.info())
[16:22:08.857]                   }
[16:22:08.857]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:08.857]                     cond$call), session = sessionInformation(), 
[16:22:08.857]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:08.857]                   signalCondition(cond)
[16:22:08.857]                 }
[16:22:08.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:08.857]                 "immediateCondition"))) {
[16:22:08.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:08.857]                   ...future.conditions[[length(...future.conditions) + 
[16:22:08.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:08.857]                   if (TRUE && !signal) {
[16:22:08.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.857]                     {
[16:22:08.857]                       inherits <- base::inherits
[16:22:08.857]                       invokeRestart <- base::invokeRestart
[16:22:08.857]                       is.null <- base::is.null
[16:22:08.857]                       muffled <- FALSE
[16:22:08.857]                       if (inherits(cond, "message")) {
[16:22:08.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.857]                         if (muffled) 
[16:22:08.857]                           invokeRestart("muffleMessage")
[16:22:08.857]                       }
[16:22:08.857]                       else if (inherits(cond, "warning")) {
[16:22:08.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.857]                         if (muffled) 
[16:22:08.857]                           invokeRestart("muffleWarning")
[16:22:08.857]                       }
[16:22:08.857]                       else if (inherits(cond, "condition")) {
[16:22:08.857]                         if (!is.null(pattern)) {
[16:22:08.857]                           computeRestarts <- base::computeRestarts
[16:22:08.857]                           grepl <- base::grepl
[16:22:08.857]                           restarts <- computeRestarts(cond)
[16:22:08.857]                           for (restart in restarts) {
[16:22:08.857]                             name <- restart$name
[16:22:08.857]                             if (is.null(name)) 
[16:22:08.857]                               next
[16:22:08.857]                             if (!grepl(pattern, name)) 
[16:22:08.857]                               next
[16:22:08.857]                             invokeRestart(restart)
[16:22:08.857]                             muffled <- TRUE
[16:22:08.857]                             break
[16:22:08.857]                           }
[16:22:08.857]                         }
[16:22:08.857]                       }
[16:22:08.857]                       invisible(muffled)
[16:22:08.857]                     }
[16:22:08.857]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.857]                   }
[16:22:08.857]                 }
[16:22:08.857]                 else {
[16:22:08.857]                   if (TRUE) {
[16:22:08.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:08.857]                     {
[16:22:08.857]                       inherits <- base::inherits
[16:22:08.857]                       invokeRestart <- base::invokeRestart
[16:22:08.857]                       is.null <- base::is.null
[16:22:08.857]                       muffled <- FALSE
[16:22:08.857]                       if (inherits(cond, "message")) {
[16:22:08.857]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:08.857]                         if (muffled) 
[16:22:08.857]                           invokeRestart("muffleMessage")
[16:22:08.857]                       }
[16:22:08.857]                       else if (inherits(cond, "warning")) {
[16:22:08.857]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:08.857]                         if (muffled) 
[16:22:08.857]                           invokeRestart("muffleWarning")
[16:22:08.857]                       }
[16:22:08.857]                       else if (inherits(cond, "condition")) {
[16:22:08.857]                         if (!is.null(pattern)) {
[16:22:08.857]                           computeRestarts <- base::computeRestarts
[16:22:08.857]                           grepl <- base::grepl
[16:22:08.857]                           restarts <- computeRestarts(cond)
[16:22:08.857]                           for (restart in restarts) {
[16:22:08.857]                             name <- restart$name
[16:22:08.857]                             if (is.null(name)) 
[16:22:08.857]                               next
[16:22:08.857]                             if (!grepl(pattern, name)) 
[16:22:08.857]                               next
[16:22:08.857]                             invokeRestart(restart)
[16:22:08.857]                             muffled <- TRUE
[16:22:08.857]                             break
[16:22:08.857]                           }
[16:22:08.857]                         }
[16:22:08.857]                       }
[16:22:08.857]                       invisible(muffled)
[16:22:08.857]                     }
[16:22:08.857]                     muffleCondition(cond, pattern = "^muffle")
[16:22:08.857]                   }
[16:22:08.857]                 }
[16:22:08.857]             }
[16:22:08.857]         }))
[16:22:08.857]     }, error = function(ex) {
[16:22:08.857]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:08.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:08.857]                 ...future.rng), started = ...future.startTime, 
[16:22:08.857]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:08.857]             version = "1.8"), class = "FutureResult")
[16:22:08.857]     }, finally = {
[16:22:08.857]         if (!identical(...future.workdir, getwd())) 
[16:22:08.857]             setwd(...future.workdir)
[16:22:08.857]         {
[16:22:08.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:08.857]                 ...future.oldOptions$nwarnings <- NULL
[16:22:08.857]             }
[16:22:08.857]             base::options(...future.oldOptions)
[16:22:08.857]             if (.Platform$OS.type == "windows") {
[16:22:08.857]                 old_names <- names(...future.oldEnvVars)
[16:22:08.857]                 envs <- base::Sys.getenv()
[16:22:08.857]                 names <- names(envs)
[16:22:08.857]                 common <- intersect(names, old_names)
[16:22:08.857]                 added <- setdiff(names, old_names)
[16:22:08.857]                 removed <- setdiff(old_names, names)
[16:22:08.857]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:08.857]                   envs[common]]
[16:22:08.857]                 NAMES <- toupper(changed)
[16:22:08.857]                 args <- list()
[16:22:08.857]                 for (kk in seq_along(NAMES)) {
[16:22:08.857]                   name <- changed[[kk]]
[16:22:08.857]                   NAME <- NAMES[[kk]]
[16:22:08.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.857]                     next
[16:22:08.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.857]                 }
[16:22:08.857]                 NAMES <- toupper(added)
[16:22:08.857]                 for (kk in seq_along(NAMES)) {
[16:22:08.857]                   name <- added[[kk]]
[16:22:08.857]                   NAME <- NAMES[[kk]]
[16:22:08.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.857]                     next
[16:22:08.857]                   args[[name]] <- ""
[16:22:08.857]                 }
[16:22:08.857]                 NAMES <- toupper(removed)
[16:22:08.857]                 for (kk in seq_along(NAMES)) {
[16:22:08.857]                   name <- removed[[kk]]
[16:22:08.857]                   NAME <- NAMES[[kk]]
[16:22:08.857]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:08.857]                     next
[16:22:08.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:08.857]                 }
[16:22:08.857]                 if (length(args) > 0) 
[16:22:08.857]                   base::do.call(base::Sys.setenv, args = args)
[16:22:08.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:08.857]             }
[16:22:08.857]             else {
[16:22:08.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:08.857]             }
[16:22:08.857]             {
[16:22:08.857]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:08.857]                   0L) {
[16:22:08.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:08.857]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:08.857]                   base::options(opts)
[16:22:08.857]                 }
[16:22:08.857]                 {
[16:22:08.857]                   {
[16:22:08.857]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:08.857]                     NULL
[16:22:08.857]                   }
[16:22:08.857]                   options(future.plan = NULL)
[16:22:08.857]                   if (is.na(NA_character_)) 
[16:22:08.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:08.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:08.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:08.857]                     .init = FALSE)
[16:22:08.857]                 }
[16:22:08.857]             }
[16:22:08.857]         }
[16:22:08.857]     })
[16:22:08.857]     if (TRUE) {
[16:22:08.857]         base::sink(type = "output", split = FALSE)
[16:22:08.857]         if (TRUE) {
[16:22:08.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:08.857]         }
[16:22:08.857]         else {
[16:22:08.857]             ...future.result["stdout"] <- base::list(NULL)
[16:22:08.857]         }
[16:22:08.857]         base::close(...future.stdout)
[16:22:08.857]         ...future.stdout <- NULL
[16:22:08.857]     }
[16:22:08.857]     ...future.result$conditions <- ...future.conditions
[16:22:08.857]     ...future.result$finished <- base::Sys.time()
[16:22:08.857]     ...future.result
[16:22:08.857] }
[16:22:08.859] Poll #1 (0): usedNodes() = 2, workers = 2
[16:22:08.890] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[16:22:08.922] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[16:22:08.933] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.933] - Validating connection of MultisessionFuture
[16:22:08.933] - received message: FutureResult
[16:22:08.933] - Received FutureResult
[16:22:08.933] - Erased future from FutureRegistry
[16:22:08.933] result() for ClusterFuture ...
[16:22:08.933] - result already collected: FutureResult
[16:22:08.934] result() for ClusterFuture ... done
[16:22:08.934] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.934] result() for ClusterFuture ...
[16:22:08.934] - result already collected: FutureResult
[16:22:08.934] result() for ClusterFuture ... done
[16:22:08.934] result() for ClusterFuture ...
[16:22:08.934] - result already collected: FutureResult
[16:22:08.934] result() for ClusterFuture ... done
[16:22:08.935] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:22:08.935] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:22:08.935] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:22:08.935] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:22:08.936] MultisessionFuture started
[16:22:08.936] - Launch lazy future ... done
[16:22:08.936] run() for ‘MultisessionFuture’ ... done
[16:22:08.936] resolve() on list ...
[16:22:08.936]  recursive: 0
[16:22:08.937]  length: 3
[16:22:08.937] 
[16:22:08.937] Future #1
[16:22:08.937]  length: 2 (resolved future 1)
[16:22:08.939] receiveMessageFromWorker() for ClusterFuture ...
[16:22:08.939] - Validating connection of MultisessionFuture
[16:22:08.939] - received message: FutureResult
[16:22:08.939] - Received FutureResult
[16:22:08.939] - Erased future from FutureRegistry
[16:22:08.939] result() for ClusterFuture ...
[16:22:08.939] - result already collected: FutureResult
[16:22:08.940] result() for ClusterFuture ... done
[16:22:08.940] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:08.940] Future #2
[16:22:08.940]  length: 1 (resolved future 2)
[16:22:09.043] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.043] - Validating connection of MultisessionFuture
[16:22:09.043] - received message: FutureResult
[16:22:09.043] - Received FutureResult
[16:22:09.043] - Erased future from FutureRegistry
[16:22:09.044] result() for ClusterFuture ...
[16:22:09.044] - result already collected: FutureResult
[16:22:09.044] result() for ClusterFuture ... done
[16:22:09.044] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.044] Future #3
[16:22:09.044]  length: 0 (resolved future 3)
[16:22:09.044] resolve() on list ... DONE
[16:22:09.044] getGlobalsAndPackages() ...
[16:22:09.044] Searching for globals...
[16:22:09.045] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:22:09.046] Searching for globals ... DONE
[16:22:09.046] Resolving globals: FALSE
[16:22:09.046] The total size of the 1 globals is 56 bytes (56 bytes)
[16:22:09.046] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:22:09.047] - globals: [1] ‘kk’
[16:22:09.047] 
[16:22:09.047] getGlobalsAndPackages() ... DONE
[16:22:09.047] getGlobalsAndPackages() ...
[16:22:09.047] Searching for globals...
[16:22:09.048] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:22:09.048] Searching for globals ... DONE
[16:22:09.048] Resolving globals: FALSE
[16:22:09.049] The total size of the 1 globals is 56 bytes (56 bytes)
[16:22:09.049] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:22:09.049] - globals: [1] ‘kk’
[16:22:09.049] 
[16:22:09.049] getGlobalsAndPackages() ... DONE
[16:22:09.052] getGlobalsAndPackages() ...
[16:22:09.052] Searching for globals...
[16:22:09.054] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:22:09.054] Searching for globals ... DONE
[16:22:09.054] Resolving globals: FALSE
[16:22:09.054] The total size of the 1 globals is 56 bytes (56 bytes)
[16:22:09.055] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:22:09.055] - globals: [1] ‘kk’
[16:22:09.055] 
[16:22:09.055] getGlobalsAndPackages() ... DONE
[16:22:09.055] resolve() on list ...
[16:22:09.055]  recursive: 0
[16:22:09.055]  length: 3
[16:22:09.055] 
[16:22:09.056] run() for ‘Future’ ...
[16:22:09.056] - state: ‘created’
[16:22:09.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.070]   - Field: ‘node’
[16:22:09.070]   - Field: ‘label’
[16:22:09.070]   - Field: ‘local’
[16:22:09.070]   - Field: ‘owner’
[16:22:09.070]   - Field: ‘envir’
[16:22:09.071]   - Field: ‘workers’
[16:22:09.071]   - Field: ‘packages’
[16:22:09.071]   - Field: ‘gc’
[16:22:09.071]   - Field: ‘conditions’
[16:22:09.071]   - Field: ‘persistent’
[16:22:09.071]   - Field: ‘expr’
[16:22:09.071]   - Field: ‘uuid’
[16:22:09.071]   - Field: ‘seed’
[16:22:09.071]   - Field: ‘version’
[16:22:09.071]   - Field: ‘result’
[16:22:09.071]   - Field: ‘asynchronous’
[16:22:09.072]   - Field: ‘calls’
[16:22:09.072]   - Field: ‘globals’
[16:22:09.072]   - Field: ‘stdout’
[16:22:09.072]   - Field: ‘earlySignal’
[16:22:09.072]   - Field: ‘lazy’
[16:22:09.072]   - Field: ‘state’
[16:22:09.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.072] - Launch lazy future ...
[16:22:09.072] Packages needed by the future expression (n = 0): <none>
[16:22:09.073] Packages needed by future strategies (n = 0): <none>
[16:22:09.073] {
[16:22:09.073]     {
[16:22:09.073]         {
[16:22:09.073]             ...future.startTime <- base::Sys.time()
[16:22:09.073]             {
[16:22:09.073]                 {
[16:22:09.073]                   {
[16:22:09.073]                     {
[16:22:09.073]                       base::local({
[16:22:09.073]                         has_future <- base::requireNamespace("future", 
[16:22:09.073]                           quietly = TRUE)
[16:22:09.073]                         if (has_future) {
[16:22:09.073]                           ns <- base::getNamespace("future")
[16:22:09.073]                           version <- ns[[".package"]][["version"]]
[16:22:09.073]                           if (is.null(version)) 
[16:22:09.073]                             version <- utils::packageVersion("future")
[16:22:09.073]                         }
[16:22:09.073]                         else {
[16:22:09.073]                           version <- NULL
[16:22:09.073]                         }
[16:22:09.073]                         if (!has_future || version < "1.8.0") {
[16:22:09.073]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.073]                             "", base::R.version$version.string), 
[16:22:09.073]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.073]                               "release", "version")], collapse = " "), 
[16:22:09.073]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.073]                             info)
[16:22:09.073]                           info <- base::paste(info, collapse = "; ")
[16:22:09.073]                           if (!has_future) {
[16:22:09.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.073]                               info)
[16:22:09.073]                           }
[16:22:09.073]                           else {
[16:22:09.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.073]                               info, version)
[16:22:09.073]                           }
[16:22:09.073]                           base::stop(msg)
[16:22:09.073]                         }
[16:22:09.073]                       })
[16:22:09.073]                     }
[16:22:09.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.073]                     base::options(mc.cores = 1L)
[16:22:09.073]                   }
[16:22:09.073]                   ...future.strategy.old <- future::plan("list")
[16:22:09.073]                   options(future.plan = NULL)
[16:22:09.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.073]                 }
[16:22:09.073]                 ...future.workdir <- getwd()
[16:22:09.073]             }
[16:22:09.073]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.073]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.073]         }
[16:22:09.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.073]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.073]             base::names(...future.oldOptions))
[16:22:09.073]     }
[16:22:09.073]     if (FALSE) {
[16:22:09.073]     }
[16:22:09.073]     else {
[16:22:09.073]         if (TRUE) {
[16:22:09.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.073]                 open = "w")
[16:22:09.073]         }
[16:22:09.073]         else {
[16:22:09.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.073]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.073]         }
[16:22:09.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.073]             base::sink(type = "output", split = FALSE)
[16:22:09.073]             base::close(...future.stdout)
[16:22:09.073]         }, add = TRUE)
[16:22:09.073]     }
[16:22:09.073]     ...future.frame <- base::sys.nframe()
[16:22:09.073]     ...future.conditions <- base::list()
[16:22:09.073]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.073]     if (FALSE) {
[16:22:09.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.073]     }
[16:22:09.073]     ...future.result <- base::tryCatch({
[16:22:09.073]         base::withCallingHandlers({
[16:22:09.073]             ...future.value <- base::withVisible(base::local({
[16:22:09.073]                 ...future.makeSendCondition <- base::local({
[16:22:09.073]                   sendCondition <- NULL
[16:22:09.073]                   function(frame = 1L) {
[16:22:09.073]                     if (is.function(sendCondition)) 
[16:22:09.073]                       return(sendCondition)
[16:22:09.073]                     ns <- getNamespace("parallel")
[16:22:09.073]                     if (exists("sendData", mode = "function", 
[16:22:09.073]                       envir = ns)) {
[16:22:09.073]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.073]                         envir = ns)
[16:22:09.073]                       envir <- sys.frame(frame)
[16:22:09.073]                       master <- NULL
[16:22:09.073]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.073]                         !identical(envir, emptyenv())) {
[16:22:09.073]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.073]                           inherits = FALSE)) {
[16:22:09.073]                           master <- get("master", mode = "list", 
[16:22:09.073]                             envir = envir, inherits = FALSE)
[16:22:09.073]                           if (inherits(master, c("SOCKnode", 
[16:22:09.073]                             "SOCK0node"))) {
[16:22:09.073]                             sendCondition <<- function(cond) {
[16:22:09.073]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.073]                                 success = TRUE)
[16:22:09.073]                               parallel_sendData(master, data)
[16:22:09.073]                             }
[16:22:09.073]                             return(sendCondition)
[16:22:09.073]                           }
[16:22:09.073]                         }
[16:22:09.073]                         frame <- frame + 1L
[16:22:09.073]                         envir <- sys.frame(frame)
[16:22:09.073]                       }
[16:22:09.073]                     }
[16:22:09.073]                     sendCondition <<- function(cond) NULL
[16:22:09.073]                   }
[16:22:09.073]                 })
[16:22:09.073]                 withCallingHandlers({
[16:22:09.073]                   {
[16:22:09.073]                     Sys.sleep(0.1)
[16:22:09.073]                     kk
[16:22:09.073]                   }
[16:22:09.073]                 }, immediateCondition = function(cond) {
[16:22:09.073]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.073]                   sendCondition(cond)
[16:22:09.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.073]                   {
[16:22:09.073]                     inherits <- base::inherits
[16:22:09.073]                     invokeRestart <- base::invokeRestart
[16:22:09.073]                     is.null <- base::is.null
[16:22:09.073]                     muffled <- FALSE
[16:22:09.073]                     if (inherits(cond, "message")) {
[16:22:09.073]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.073]                       if (muffled) 
[16:22:09.073]                         invokeRestart("muffleMessage")
[16:22:09.073]                     }
[16:22:09.073]                     else if (inherits(cond, "warning")) {
[16:22:09.073]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.073]                       if (muffled) 
[16:22:09.073]                         invokeRestart("muffleWarning")
[16:22:09.073]                     }
[16:22:09.073]                     else if (inherits(cond, "condition")) {
[16:22:09.073]                       if (!is.null(pattern)) {
[16:22:09.073]                         computeRestarts <- base::computeRestarts
[16:22:09.073]                         grepl <- base::grepl
[16:22:09.073]                         restarts <- computeRestarts(cond)
[16:22:09.073]                         for (restart in restarts) {
[16:22:09.073]                           name <- restart$name
[16:22:09.073]                           if (is.null(name)) 
[16:22:09.073]                             next
[16:22:09.073]                           if (!grepl(pattern, name)) 
[16:22:09.073]                             next
[16:22:09.073]                           invokeRestart(restart)
[16:22:09.073]                           muffled <- TRUE
[16:22:09.073]                           break
[16:22:09.073]                         }
[16:22:09.073]                       }
[16:22:09.073]                     }
[16:22:09.073]                     invisible(muffled)
[16:22:09.073]                   }
[16:22:09.073]                   muffleCondition(cond)
[16:22:09.073]                 })
[16:22:09.073]             }))
[16:22:09.073]             future::FutureResult(value = ...future.value$value, 
[16:22:09.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.073]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.073]                     ...future.globalenv.names))
[16:22:09.073]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.073]         }, condition = base::local({
[16:22:09.073]             c <- base::c
[16:22:09.073]             inherits <- base::inherits
[16:22:09.073]             invokeRestart <- base::invokeRestart
[16:22:09.073]             length <- base::length
[16:22:09.073]             list <- base::list
[16:22:09.073]             seq.int <- base::seq.int
[16:22:09.073]             signalCondition <- base::signalCondition
[16:22:09.073]             sys.calls <- base::sys.calls
[16:22:09.073]             `[[` <- base::`[[`
[16:22:09.073]             `+` <- base::`+`
[16:22:09.073]             `<<-` <- base::`<<-`
[16:22:09.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.073]                   3L)]
[16:22:09.073]             }
[16:22:09.073]             function(cond) {
[16:22:09.073]                 is_error <- inherits(cond, "error")
[16:22:09.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.073]                   NULL)
[16:22:09.073]                 if (is_error) {
[16:22:09.073]                   sessionInformation <- function() {
[16:22:09.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.073]                       search = base::search(), system = base::Sys.info())
[16:22:09.073]                   }
[16:22:09.073]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.073]                     cond$call), session = sessionInformation(), 
[16:22:09.073]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.073]                   signalCondition(cond)
[16:22:09.073]                 }
[16:22:09.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.073]                 "immediateCondition"))) {
[16:22:09.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.073]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.073]                   if (TRUE && !signal) {
[16:22:09.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.073]                     {
[16:22:09.073]                       inherits <- base::inherits
[16:22:09.073]                       invokeRestart <- base::invokeRestart
[16:22:09.073]                       is.null <- base::is.null
[16:22:09.073]                       muffled <- FALSE
[16:22:09.073]                       if (inherits(cond, "message")) {
[16:22:09.073]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.073]                         if (muffled) 
[16:22:09.073]                           invokeRestart("muffleMessage")
[16:22:09.073]                       }
[16:22:09.073]                       else if (inherits(cond, "warning")) {
[16:22:09.073]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.073]                         if (muffled) 
[16:22:09.073]                           invokeRestart("muffleWarning")
[16:22:09.073]                       }
[16:22:09.073]                       else if (inherits(cond, "condition")) {
[16:22:09.073]                         if (!is.null(pattern)) {
[16:22:09.073]                           computeRestarts <- base::computeRestarts
[16:22:09.073]                           grepl <- base::grepl
[16:22:09.073]                           restarts <- computeRestarts(cond)
[16:22:09.073]                           for (restart in restarts) {
[16:22:09.073]                             name <- restart$name
[16:22:09.073]                             if (is.null(name)) 
[16:22:09.073]                               next
[16:22:09.073]                             if (!grepl(pattern, name)) 
[16:22:09.073]                               next
[16:22:09.073]                             invokeRestart(restart)
[16:22:09.073]                             muffled <- TRUE
[16:22:09.073]                             break
[16:22:09.073]                           }
[16:22:09.073]                         }
[16:22:09.073]                       }
[16:22:09.073]                       invisible(muffled)
[16:22:09.073]                     }
[16:22:09.073]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.073]                   }
[16:22:09.073]                 }
[16:22:09.073]                 else {
[16:22:09.073]                   if (TRUE) {
[16:22:09.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.073]                     {
[16:22:09.073]                       inherits <- base::inherits
[16:22:09.073]                       invokeRestart <- base::invokeRestart
[16:22:09.073]                       is.null <- base::is.null
[16:22:09.073]                       muffled <- FALSE
[16:22:09.073]                       if (inherits(cond, "message")) {
[16:22:09.073]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.073]                         if (muffled) 
[16:22:09.073]                           invokeRestart("muffleMessage")
[16:22:09.073]                       }
[16:22:09.073]                       else if (inherits(cond, "warning")) {
[16:22:09.073]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.073]                         if (muffled) 
[16:22:09.073]                           invokeRestart("muffleWarning")
[16:22:09.073]                       }
[16:22:09.073]                       else if (inherits(cond, "condition")) {
[16:22:09.073]                         if (!is.null(pattern)) {
[16:22:09.073]                           computeRestarts <- base::computeRestarts
[16:22:09.073]                           grepl <- base::grepl
[16:22:09.073]                           restarts <- computeRestarts(cond)
[16:22:09.073]                           for (restart in restarts) {
[16:22:09.073]                             name <- restart$name
[16:22:09.073]                             if (is.null(name)) 
[16:22:09.073]                               next
[16:22:09.073]                             if (!grepl(pattern, name)) 
[16:22:09.073]                               next
[16:22:09.073]                             invokeRestart(restart)
[16:22:09.073]                             muffled <- TRUE
[16:22:09.073]                             break
[16:22:09.073]                           }
[16:22:09.073]                         }
[16:22:09.073]                       }
[16:22:09.073]                       invisible(muffled)
[16:22:09.073]                     }
[16:22:09.073]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.073]                   }
[16:22:09.073]                 }
[16:22:09.073]             }
[16:22:09.073]         }))
[16:22:09.073]     }, error = function(ex) {
[16:22:09.073]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.073]                 ...future.rng), started = ...future.startTime, 
[16:22:09.073]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.073]             version = "1.8"), class = "FutureResult")
[16:22:09.073]     }, finally = {
[16:22:09.073]         if (!identical(...future.workdir, getwd())) 
[16:22:09.073]             setwd(...future.workdir)
[16:22:09.073]         {
[16:22:09.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.073]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.073]             }
[16:22:09.073]             base::options(...future.oldOptions)
[16:22:09.073]             if (.Platform$OS.type == "windows") {
[16:22:09.073]                 old_names <- names(...future.oldEnvVars)
[16:22:09.073]                 envs <- base::Sys.getenv()
[16:22:09.073]                 names <- names(envs)
[16:22:09.073]                 common <- intersect(names, old_names)
[16:22:09.073]                 added <- setdiff(names, old_names)
[16:22:09.073]                 removed <- setdiff(old_names, names)
[16:22:09.073]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.073]                   envs[common]]
[16:22:09.073]                 NAMES <- toupper(changed)
[16:22:09.073]                 args <- list()
[16:22:09.073]                 for (kk in seq_along(NAMES)) {
[16:22:09.073]                   name <- changed[[kk]]
[16:22:09.073]                   NAME <- NAMES[[kk]]
[16:22:09.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.073]                     next
[16:22:09.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.073]                 }
[16:22:09.073]                 NAMES <- toupper(added)
[16:22:09.073]                 for (kk in seq_along(NAMES)) {
[16:22:09.073]                   name <- added[[kk]]
[16:22:09.073]                   NAME <- NAMES[[kk]]
[16:22:09.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.073]                     next
[16:22:09.073]                   args[[name]] <- ""
[16:22:09.073]                 }
[16:22:09.073]                 NAMES <- toupper(removed)
[16:22:09.073]                 for (kk in seq_along(NAMES)) {
[16:22:09.073]                   name <- removed[[kk]]
[16:22:09.073]                   NAME <- NAMES[[kk]]
[16:22:09.073]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.073]                     next
[16:22:09.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.073]                 }
[16:22:09.073]                 if (length(args) > 0) 
[16:22:09.073]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.073]             }
[16:22:09.073]             else {
[16:22:09.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.073]             }
[16:22:09.073]             {
[16:22:09.073]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.073]                   0L) {
[16:22:09.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.073]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.073]                   base::options(opts)
[16:22:09.073]                 }
[16:22:09.073]                 {
[16:22:09.073]                   {
[16:22:09.073]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.073]                     NULL
[16:22:09.073]                   }
[16:22:09.073]                   options(future.plan = NULL)
[16:22:09.073]                   if (is.na(NA_character_)) 
[16:22:09.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.073]                     .init = FALSE)
[16:22:09.073]                 }
[16:22:09.073]             }
[16:22:09.073]         }
[16:22:09.073]     })
[16:22:09.073]     if (TRUE) {
[16:22:09.073]         base::sink(type = "output", split = FALSE)
[16:22:09.073]         if (TRUE) {
[16:22:09.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.073]         }
[16:22:09.073]         else {
[16:22:09.073]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.073]         }
[16:22:09.073]         base::close(...future.stdout)
[16:22:09.073]         ...future.stdout <- NULL
[16:22:09.073]     }
[16:22:09.073]     ...future.result$conditions <- ...future.conditions
[16:22:09.073]     ...future.result$finished <- base::Sys.time()
[16:22:09.073]     ...future.result
[16:22:09.073] }
[16:22:09.076] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:22:09.076] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:22:09.076] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:22:09.076] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:22:09.077] MultisessionFuture started
[16:22:09.077] - Launch lazy future ... done
[16:22:09.077] run() for ‘MultisessionFuture’ ... done
[16:22:09.087] run() for ‘Future’ ...
[16:22:09.088] - state: ‘created’
[16:22:09.088] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.102]   - Field: ‘node’
[16:22:09.102]   - Field: ‘label’
[16:22:09.102]   - Field: ‘local’
[16:22:09.102]   - Field: ‘owner’
[16:22:09.102]   - Field: ‘envir’
[16:22:09.102]   - Field: ‘workers’
[16:22:09.103]   - Field: ‘packages’
[16:22:09.103]   - Field: ‘gc’
[16:22:09.103]   - Field: ‘conditions’
[16:22:09.103]   - Field: ‘persistent’
[16:22:09.103]   - Field: ‘expr’
[16:22:09.103]   - Field: ‘uuid’
[16:22:09.103]   - Field: ‘seed’
[16:22:09.103]   - Field: ‘version’
[16:22:09.103]   - Field: ‘result’
[16:22:09.103]   - Field: ‘asynchronous’
[16:22:09.103]   - Field: ‘calls’
[16:22:09.104]   - Field: ‘globals’
[16:22:09.104]   - Field: ‘stdout’
[16:22:09.104]   - Field: ‘earlySignal’
[16:22:09.104]   - Field: ‘lazy’
[16:22:09.104]   - Field: ‘state’
[16:22:09.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.104] - Launch lazy future ...
[16:22:09.104] Packages needed by the future expression (n = 0): <none>
[16:22:09.104] Packages needed by future strategies (n = 0): <none>
[16:22:09.105] {
[16:22:09.105]     {
[16:22:09.105]         {
[16:22:09.105]             ...future.startTime <- base::Sys.time()
[16:22:09.105]             {
[16:22:09.105]                 {
[16:22:09.105]                   {
[16:22:09.105]                     {
[16:22:09.105]                       base::local({
[16:22:09.105]                         has_future <- base::requireNamespace("future", 
[16:22:09.105]                           quietly = TRUE)
[16:22:09.105]                         if (has_future) {
[16:22:09.105]                           ns <- base::getNamespace("future")
[16:22:09.105]                           version <- ns[[".package"]][["version"]]
[16:22:09.105]                           if (is.null(version)) 
[16:22:09.105]                             version <- utils::packageVersion("future")
[16:22:09.105]                         }
[16:22:09.105]                         else {
[16:22:09.105]                           version <- NULL
[16:22:09.105]                         }
[16:22:09.105]                         if (!has_future || version < "1.8.0") {
[16:22:09.105]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.105]                             "", base::R.version$version.string), 
[16:22:09.105]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.105]                               "release", "version")], collapse = " "), 
[16:22:09.105]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.105]                             info)
[16:22:09.105]                           info <- base::paste(info, collapse = "; ")
[16:22:09.105]                           if (!has_future) {
[16:22:09.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.105]                               info)
[16:22:09.105]                           }
[16:22:09.105]                           else {
[16:22:09.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.105]                               info, version)
[16:22:09.105]                           }
[16:22:09.105]                           base::stop(msg)
[16:22:09.105]                         }
[16:22:09.105]                       })
[16:22:09.105]                     }
[16:22:09.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.105]                     base::options(mc.cores = 1L)
[16:22:09.105]                   }
[16:22:09.105]                   ...future.strategy.old <- future::plan("list")
[16:22:09.105]                   options(future.plan = NULL)
[16:22:09.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.105]                 }
[16:22:09.105]                 ...future.workdir <- getwd()
[16:22:09.105]             }
[16:22:09.105]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.105]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.105]         }
[16:22:09.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.105]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.105]             base::names(...future.oldOptions))
[16:22:09.105]     }
[16:22:09.105]     if (FALSE) {
[16:22:09.105]     }
[16:22:09.105]     else {
[16:22:09.105]         if (TRUE) {
[16:22:09.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.105]                 open = "w")
[16:22:09.105]         }
[16:22:09.105]         else {
[16:22:09.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.105]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.105]         }
[16:22:09.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.105]             base::sink(type = "output", split = FALSE)
[16:22:09.105]             base::close(...future.stdout)
[16:22:09.105]         }, add = TRUE)
[16:22:09.105]     }
[16:22:09.105]     ...future.frame <- base::sys.nframe()
[16:22:09.105]     ...future.conditions <- base::list()
[16:22:09.105]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.105]     if (FALSE) {
[16:22:09.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.105]     }
[16:22:09.105]     ...future.result <- base::tryCatch({
[16:22:09.105]         base::withCallingHandlers({
[16:22:09.105]             ...future.value <- base::withVisible(base::local({
[16:22:09.105]                 ...future.makeSendCondition <- base::local({
[16:22:09.105]                   sendCondition <- NULL
[16:22:09.105]                   function(frame = 1L) {
[16:22:09.105]                     if (is.function(sendCondition)) 
[16:22:09.105]                       return(sendCondition)
[16:22:09.105]                     ns <- getNamespace("parallel")
[16:22:09.105]                     if (exists("sendData", mode = "function", 
[16:22:09.105]                       envir = ns)) {
[16:22:09.105]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.105]                         envir = ns)
[16:22:09.105]                       envir <- sys.frame(frame)
[16:22:09.105]                       master <- NULL
[16:22:09.105]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.105]                         !identical(envir, emptyenv())) {
[16:22:09.105]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.105]                           inherits = FALSE)) {
[16:22:09.105]                           master <- get("master", mode = "list", 
[16:22:09.105]                             envir = envir, inherits = FALSE)
[16:22:09.105]                           if (inherits(master, c("SOCKnode", 
[16:22:09.105]                             "SOCK0node"))) {
[16:22:09.105]                             sendCondition <<- function(cond) {
[16:22:09.105]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.105]                                 success = TRUE)
[16:22:09.105]                               parallel_sendData(master, data)
[16:22:09.105]                             }
[16:22:09.105]                             return(sendCondition)
[16:22:09.105]                           }
[16:22:09.105]                         }
[16:22:09.105]                         frame <- frame + 1L
[16:22:09.105]                         envir <- sys.frame(frame)
[16:22:09.105]                       }
[16:22:09.105]                     }
[16:22:09.105]                     sendCondition <<- function(cond) NULL
[16:22:09.105]                   }
[16:22:09.105]                 })
[16:22:09.105]                 withCallingHandlers({
[16:22:09.105]                   {
[16:22:09.105]                     Sys.sleep(0.1)
[16:22:09.105]                     kk
[16:22:09.105]                   }
[16:22:09.105]                 }, immediateCondition = function(cond) {
[16:22:09.105]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.105]                   sendCondition(cond)
[16:22:09.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.105]                   {
[16:22:09.105]                     inherits <- base::inherits
[16:22:09.105]                     invokeRestart <- base::invokeRestart
[16:22:09.105]                     is.null <- base::is.null
[16:22:09.105]                     muffled <- FALSE
[16:22:09.105]                     if (inherits(cond, "message")) {
[16:22:09.105]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.105]                       if (muffled) 
[16:22:09.105]                         invokeRestart("muffleMessage")
[16:22:09.105]                     }
[16:22:09.105]                     else if (inherits(cond, "warning")) {
[16:22:09.105]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.105]                       if (muffled) 
[16:22:09.105]                         invokeRestart("muffleWarning")
[16:22:09.105]                     }
[16:22:09.105]                     else if (inherits(cond, "condition")) {
[16:22:09.105]                       if (!is.null(pattern)) {
[16:22:09.105]                         computeRestarts <- base::computeRestarts
[16:22:09.105]                         grepl <- base::grepl
[16:22:09.105]                         restarts <- computeRestarts(cond)
[16:22:09.105]                         for (restart in restarts) {
[16:22:09.105]                           name <- restart$name
[16:22:09.105]                           if (is.null(name)) 
[16:22:09.105]                             next
[16:22:09.105]                           if (!grepl(pattern, name)) 
[16:22:09.105]                             next
[16:22:09.105]                           invokeRestart(restart)
[16:22:09.105]                           muffled <- TRUE
[16:22:09.105]                           break
[16:22:09.105]                         }
[16:22:09.105]                       }
[16:22:09.105]                     }
[16:22:09.105]                     invisible(muffled)
[16:22:09.105]                   }
[16:22:09.105]                   muffleCondition(cond)
[16:22:09.105]                 })
[16:22:09.105]             }))
[16:22:09.105]             future::FutureResult(value = ...future.value$value, 
[16:22:09.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.105]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.105]                     ...future.globalenv.names))
[16:22:09.105]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.105]         }, condition = base::local({
[16:22:09.105]             c <- base::c
[16:22:09.105]             inherits <- base::inherits
[16:22:09.105]             invokeRestart <- base::invokeRestart
[16:22:09.105]             length <- base::length
[16:22:09.105]             list <- base::list
[16:22:09.105]             seq.int <- base::seq.int
[16:22:09.105]             signalCondition <- base::signalCondition
[16:22:09.105]             sys.calls <- base::sys.calls
[16:22:09.105]             `[[` <- base::`[[`
[16:22:09.105]             `+` <- base::`+`
[16:22:09.105]             `<<-` <- base::`<<-`
[16:22:09.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.105]                   3L)]
[16:22:09.105]             }
[16:22:09.105]             function(cond) {
[16:22:09.105]                 is_error <- inherits(cond, "error")
[16:22:09.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.105]                   NULL)
[16:22:09.105]                 if (is_error) {
[16:22:09.105]                   sessionInformation <- function() {
[16:22:09.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.105]                       search = base::search(), system = base::Sys.info())
[16:22:09.105]                   }
[16:22:09.105]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.105]                     cond$call), session = sessionInformation(), 
[16:22:09.105]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.105]                   signalCondition(cond)
[16:22:09.105]                 }
[16:22:09.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.105]                 "immediateCondition"))) {
[16:22:09.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.105]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.105]                   if (TRUE && !signal) {
[16:22:09.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.105]                     {
[16:22:09.105]                       inherits <- base::inherits
[16:22:09.105]                       invokeRestart <- base::invokeRestart
[16:22:09.105]                       is.null <- base::is.null
[16:22:09.105]                       muffled <- FALSE
[16:22:09.105]                       if (inherits(cond, "message")) {
[16:22:09.105]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.105]                         if (muffled) 
[16:22:09.105]                           invokeRestart("muffleMessage")
[16:22:09.105]                       }
[16:22:09.105]                       else if (inherits(cond, "warning")) {
[16:22:09.105]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.105]                         if (muffled) 
[16:22:09.105]                           invokeRestart("muffleWarning")
[16:22:09.105]                       }
[16:22:09.105]                       else if (inherits(cond, "condition")) {
[16:22:09.105]                         if (!is.null(pattern)) {
[16:22:09.105]                           computeRestarts <- base::computeRestarts
[16:22:09.105]                           grepl <- base::grepl
[16:22:09.105]                           restarts <- computeRestarts(cond)
[16:22:09.105]                           for (restart in restarts) {
[16:22:09.105]                             name <- restart$name
[16:22:09.105]                             if (is.null(name)) 
[16:22:09.105]                               next
[16:22:09.105]                             if (!grepl(pattern, name)) 
[16:22:09.105]                               next
[16:22:09.105]                             invokeRestart(restart)
[16:22:09.105]                             muffled <- TRUE
[16:22:09.105]                             break
[16:22:09.105]                           }
[16:22:09.105]                         }
[16:22:09.105]                       }
[16:22:09.105]                       invisible(muffled)
[16:22:09.105]                     }
[16:22:09.105]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.105]                   }
[16:22:09.105]                 }
[16:22:09.105]                 else {
[16:22:09.105]                   if (TRUE) {
[16:22:09.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.105]                     {
[16:22:09.105]                       inherits <- base::inherits
[16:22:09.105]                       invokeRestart <- base::invokeRestart
[16:22:09.105]                       is.null <- base::is.null
[16:22:09.105]                       muffled <- FALSE
[16:22:09.105]                       if (inherits(cond, "message")) {
[16:22:09.105]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.105]                         if (muffled) 
[16:22:09.105]                           invokeRestart("muffleMessage")
[16:22:09.105]                       }
[16:22:09.105]                       else if (inherits(cond, "warning")) {
[16:22:09.105]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.105]                         if (muffled) 
[16:22:09.105]                           invokeRestart("muffleWarning")
[16:22:09.105]                       }
[16:22:09.105]                       else if (inherits(cond, "condition")) {
[16:22:09.105]                         if (!is.null(pattern)) {
[16:22:09.105]                           computeRestarts <- base::computeRestarts
[16:22:09.105]                           grepl <- base::grepl
[16:22:09.105]                           restarts <- computeRestarts(cond)
[16:22:09.105]                           for (restart in restarts) {
[16:22:09.105]                             name <- restart$name
[16:22:09.105]                             if (is.null(name)) 
[16:22:09.105]                               next
[16:22:09.105]                             if (!grepl(pattern, name)) 
[16:22:09.105]                               next
[16:22:09.105]                             invokeRestart(restart)
[16:22:09.105]                             muffled <- TRUE
[16:22:09.105]                             break
[16:22:09.105]                           }
[16:22:09.105]                         }
[16:22:09.105]                       }
[16:22:09.105]                       invisible(muffled)
[16:22:09.105]                     }
[16:22:09.105]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.105]                   }
[16:22:09.105]                 }
[16:22:09.105]             }
[16:22:09.105]         }))
[16:22:09.105]     }, error = function(ex) {
[16:22:09.105]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.105]                 ...future.rng), started = ...future.startTime, 
[16:22:09.105]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.105]             version = "1.8"), class = "FutureResult")
[16:22:09.105]     }, finally = {
[16:22:09.105]         if (!identical(...future.workdir, getwd())) 
[16:22:09.105]             setwd(...future.workdir)
[16:22:09.105]         {
[16:22:09.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.105]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.105]             }
[16:22:09.105]             base::options(...future.oldOptions)
[16:22:09.105]             if (.Platform$OS.type == "windows") {
[16:22:09.105]                 old_names <- names(...future.oldEnvVars)
[16:22:09.105]                 envs <- base::Sys.getenv()
[16:22:09.105]                 names <- names(envs)
[16:22:09.105]                 common <- intersect(names, old_names)
[16:22:09.105]                 added <- setdiff(names, old_names)
[16:22:09.105]                 removed <- setdiff(old_names, names)
[16:22:09.105]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.105]                   envs[common]]
[16:22:09.105]                 NAMES <- toupper(changed)
[16:22:09.105]                 args <- list()
[16:22:09.105]                 for (kk in seq_along(NAMES)) {
[16:22:09.105]                   name <- changed[[kk]]
[16:22:09.105]                   NAME <- NAMES[[kk]]
[16:22:09.105]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.105]                     next
[16:22:09.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.105]                 }
[16:22:09.105]                 NAMES <- toupper(added)
[16:22:09.105]                 for (kk in seq_along(NAMES)) {
[16:22:09.105]                   name <- added[[kk]]
[16:22:09.105]                   NAME <- NAMES[[kk]]
[16:22:09.105]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.105]                     next
[16:22:09.105]                   args[[name]] <- ""
[16:22:09.105]                 }
[16:22:09.105]                 NAMES <- toupper(removed)
[16:22:09.105]                 for (kk in seq_along(NAMES)) {
[16:22:09.105]                   name <- removed[[kk]]
[16:22:09.105]                   NAME <- NAMES[[kk]]
[16:22:09.105]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.105]                     next
[16:22:09.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.105]                 }
[16:22:09.105]                 if (length(args) > 0) 
[16:22:09.105]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.105]             }
[16:22:09.105]             else {
[16:22:09.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.105]             }
[16:22:09.105]             {
[16:22:09.105]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.105]                   0L) {
[16:22:09.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.105]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.105]                   base::options(opts)
[16:22:09.105]                 }
[16:22:09.105]                 {
[16:22:09.105]                   {
[16:22:09.105]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.105]                     NULL
[16:22:09.105]                   }
[16:22:09.105]                   options(future.plan = NULL)
[16:22:09.105]                   if (is.na(NA_character_)) 
[16:22:09.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.105]                     .init = FALSE)
[16:22:09.105]                 }
[16:22:09.105]             }
[16:22:09.105]         }
[16:22:09.105]     })
[16:22:09.105]     if (TRUE) {
[16:22:09.105]         base::sink(type = "output", split = FALSE)
[16:22:09.105]         if (TRUE) {
[16:22:09.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.105]         }
[16:22:09.105]         else {
[16:22:09.105]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.105]         }
[16:22:09.105]         base::close(...future.stdout)
[16:22:09.105]         ...future.stdout <- NULL
[16:22:09.105]     }
[16:22:09.105]     ...future.result$conditions <- ...future.conditions
[16:22:09.105]     ...future.result$finished <- base::Sys.time()
[16:22:09.105]     ...future.result
[16:22:09.105] }
[16:22:09.108] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:22:09.108] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[16:22:09.108] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[16:22:09.108] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:22:09.109] MultisessionFuture started
[16:22:09.109] - Launch lazy future ... done
[16:22:09.109] run() for ‘MultisessionFuture’ ... done
[16:22:09.120] run() for ‘Future’ ...
[16:22:09.120] - state: ‘created’
[16:22:09.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.134]   - Field: ‘node’
[16:22:09.134]   - Field: ‘label’
[16:22:09.134]   - Field: ‘local’
[16:22:09.134]   - Field: ‘owner’
[16:22:09.135]   - Field: ‘envir’
[16:22:09.135]   - Field: ‘workers’
[16:22:09.135]   - Field: ‘packages’
[16:22:09.135]   - Field: ‘gc’
[16:22:09.135]   - Field: ‘conditions’
[16:22:09.135]   - Field: ‘persistent’
[16:22:09.135]   - Field: ‘expr’
[16:22:09.135]   - Field: ‘uuid’
[16:22:09.135]   - Field: ‘seed’
[16:22:09.135]   - Field: ‘version’
[16:22:09.135]   - Field: ‘result’
[16:22:09.136]   - Field: ‘asynchronous’
[16:22:09.136]   - Field: ‘calls’
[16:22:09.136]   - Field: ‘globals’
[16:22:09.136]   - Field: ‘stdout’
[16:22:09.136]   - Field: ‘earlySignal’
[16:22:09.136]   - Field: ‘lazy’
[16:22:09.136]   - Field: ‘state’
[16:22:09.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.136] - Launch lazy future ...
[16:22:09.137] Packages needed by the future expression (n = 0): <none>
[16:22:09.137] Packages needed by future strategies (n = 0): <none>
[16:22:09.137] {
[16:22:09.137]     {
[16:22:09.137]         {
[16:22:09.137]             ...future.startTime <- base::Sys.time()
[16:22:09.137]             {
[16:22:09.137]                 {
[16:22:09.137]                   {
[16:22:09.137]                     {
[16:22:09.137]                       base::local({
[16:22:09.137]                         has_future <- base::requireNamespace("future", 
[16:22:09.137]                           quietly = TRUE)
[16:22:09.137]                         if (has_future) {
[16:22:09.137]                           ns <- base::getNamespace("future")
[16:22:09.137]                           version <- ns[[".package"]][["version"]]
[16:22:09.137]                           if (is.null(version)) 
[16:22:09.137]                             version <- utils::packageVersion("future")
[16:22:09.137]                         }
[16:22:09.137]                         else {
[16:22:09.137]                           version <- NULL
[16:22:09.137]                         }
[16:22:09.137]                         if (!has_future || version < "1.8.0") {
[16:22:09.137]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.137]                             "", base::R.version$version.string), 
[16:22:09.137]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.137]                               "release", "version")], collapse = " "), 
[16:22:09.137]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.137]                             info)
[16:22:09.137]                           info <- base::paste(info, collapse = "; ")
[16:22:09.137]                           if (!has_future) {
[16:22:09.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.137]                               info)
[16:22:09.137]                           }
[16:22:09.137]                           else {
[16:22:09.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.137]                               info, version)
[16:22:09.137]                           }
[16:22:09.137]                           base::stop(msg)
[16:22:09.137]                         }
[16:22:09.137]                       })
[16:22:09.137]                     }
[16:22:09.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.137]                     base::options(mc.cores = 1L)
[16:22:09.137]                   }
[16:22:09.137]                   ...future.strategy.old <- future::plan("list")
[16:22:09.137]                   options(future.plan = NULL)
[16:22:09.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.137]                 }
[16:22:09.137]                 ...future.workdir <- getwd()
[16:22:09.137]             }
[16:22:09.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.137]         }
[16:22:09.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.137]             base::names(...future.oldOptions))
[16:22:09.137]     }
[16:22:09.137]     if (FALSE) {
[16:22:09.137]     }
[16:22:09.137]     else {
[16:22:09.137]         if (TRUE) {
[16:22:09.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.137]                 open = "w")
[16:22:09.137]         }
[16:22:09.137]         else {
[16:22:09.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.137]         }
[16:22:09.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.137]             base::sink(type = "output", split = FALSE)
[16:22:09.137]             base::close(...future.stdout)
[16:22:09.137]         }, add = TRUE)
[16:22:09.137]     }
[16:22:09.137]     ...future.frame <- base::sys.nframe()
[16:22:09.137]     ...future.conditions <- base::list()
[16:22:09.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.137]     if (FALSE) {
[16:22:09.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.137]     }
[16:22:09.137]     ...future.result <- base::tryCatch({
[16:22:09.137]         base::withCallingHandlers({
[16:22:09.137]             ...future.value <- base::withVisible(base::local({
[16:22:09.137]                 ...future.makeSendCondition <- base::local({
[16:22:09.137]                   sendCondition <- NULL
[16:22:09.137]                   function(frame = 1L) {
[16:22:09.137]                     if (is.function(sendCondition)) 
[16:22:09.137]                       return(sendCondition)
[16:22:09.137]                     ns <- getNamespace("parallel")
[16:22:09.137]                     if (exists("sendData", mode = "function", 
[16:22:09.137]                       envir = ns)) {
[16:22:09.137]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.137]                         envir = ns)
[16:22:09.137]                       envir <- sys.frame(frame)
[16:22:09.137]                       master <- NULL
[16:22:09.137]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.137]                         !identical(envir, emptyenv())) {
[16:22:09.137]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.137]                           inherits = FALSE)) {
[16:22:09.137]                           master <- get("master", mode = "list", 
[16:22:09.137]                             envir = envir, inherits = FALSE)
[16:22:09.137]                           if (inherits(master, c("SOCKnode", 
[16:22:09.137]                             "SOCK0node"))) {
[16:22:09.137]                             sendCondition <<- function(cond) {
[16:22:09.137]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.137]                                 success = TRUE)
[16:22:09.137]                               parallel_sendData(master, data)
[16:22:09.137]                             }
[16:22:09.137]                             return(sendCondition)
[16:22:09.137]                           }
[16:22:09.137]                         }
[16:22:09.137]                         frame <- frame + 1L
[16:22:09.137]                         envir <- sys.frame(frame)
[16:22:09.137]                       }
[16:22:09.137]                     }
[16:22:09.137]                     sendCondition <<- function(cond) NULL
[16:22:09.137]                   }
[16:22:09.137]                 })
[16:22:09.137]                 withCallingHandlers({
[16:22:09.137]                   {
[16:22:09.137]                     Sys.sleep(0.1)
[16:22:09.137]                     kk
[16:22:09.137]                   }
[16:22:09.137]                 }, immediateCondition = function(cond) {
[16:22:09.137]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.137]                   sendCondition(cond)
[16:22:09.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.137]                   {
[16:22:09.137]                     inherits <- base::inherits
[16:22:09.137]                     invokeRestart <- base::invokeRestart
[16:22:09.137]                     is.null <- base::is.null
[16:22:09.137]                     muffled <- FALSE
[16:22:09.137]                     if (inherits(cond, "message")) {
[16:22:09.137]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.137]                       if (muffled) 
[16:22:09.137]                         invokeRestart("muffleMessage")
[16:22:09.137]                     }
[16:22:09.137]                     else if (inherits(cond, "warning")) {
[16:22:09.137]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.137]                       if (muffled) 
[16:22:09.137]                         invokeRestart("muffleWarning")
[16:22:09.137]                     }
[16:22:09.137]                     else if (inherits(cond, "condition")) {
[16:22:09.137]                       if (!is.null(pattern)) {
[16:22:09.137]                         computeRestarts <- base::computeRestarts
[16:22:09.137]                         grepl <- base::grepl
[16:22:09.137]                         restarts <- computeRestarts(cond)
[16:22:09.137]                         for (restart in restarts) {
[16:22:09.137]                           name <- restart$name
[16:22:09.137]                           if (is.null(name)) 
[16:22:09.137]                             next
[16:22:09.137]                           if (!grepl(pattern, name)) 
[16:22:09.137]                             next
[16:22:09.137]                           invokeRestart(restart)
[16:22:09.137]                           muffled <- TRUE
[16:22:09.137]                           break
[16:22:09.137]                         }
[16:22:09.137]                       }
[16:22:09.137]                     }
[16:22:09.137]                     invisible(muffled)
[16:22:09.137]                   }
[16:22:09.137]                   muffleCondition(cond)
[16:22:09.137]                 })
[16:22:09.137]             }))
[16:22:09.137]             future::FutureResult(value = ...future.value$value, 
[16:22:09.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.137]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.137]                     ...future.globalenv.names))
[16:22:09.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.137]         }, condition = base::local({
[16:22:09.137]             c <- base::c
[16:22:09.137]             inherits <- base::inherits
[16:22:09.137]             invokeRestart <- base::invokeRestart
[16:22:09.137]             length <- base::length
[16:22:09.137]             list <- base::list
[16:22:09.137]             seq.int <- base::seq.int
[16:22:09.137]             signalCondition <- base::signalCondition
[16:22:09.137]             sys.calls <- base::sys.calls
[16:22:09.137]             `[[` <- base::`[[`
[16:22:09.137]             `+` <- base::`+`
[16:22:09.137]             `<<-` <- base::`<<-`
[16:22:09.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.137]                   3L)]
[16:22:09.137]             }
[16:22:09.137]             function(cond) {
[16:22:09.137]                 is_error <- inherits(cond, "error")
[16:22:09.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.137]                   NULL)
[16:22:09.137]                 if (is_error) {
[16:22:09.137]                   sessionInformation <- function() {
[16:22:09.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.137]                       search = base::search(), system = base::Sys.info())
[16:22:09.137]                   }
[16:22:09.137]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.137]                     cond$call), session = sessionInformation(), 
[16:22:09.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.137]                   signalCondition(cond)
[16:22:09.137]                 }
[16:22:09.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.137]                 "immediateCondition"))) {
[16:22:09.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.137]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.137]                   if (TRUE && !signal) {
[16:22:09.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.137]                     {
[16:22:09.137]                       inherits <- base::inherits
[16:22:09.137]                       invokeRestart <- base::invokeRestart
[16:22:09.137]                       is.null <- base::is.null
[16:22:09.137]                       muffled <- FALSE
[16:22:09.137]                       if (inherits(cond, "message")) {
[16:22:09.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.137]                         if (muffled) 
[16:22:09.137]                           invokeRestart("muffleMessage")
[16:22:09.137]                       }
[16:22:09.137]                       else if (inherits(cond, "warning")) {
[16:22:09.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.137]                         if (muffled) 
[16:22:09.137]                           invokeRestart("muffleWarning")
[16:22:09.137]                       }
[16:22:09.137]                       else if (inherits(cond, "condition")) {
[16:22:09.137]                         if (!is.null(pattern)) {
[16:22:09.137]                           computeRestarts <- base::computeRestarts
[16:22:09.137]                           grepl <- base::grepl
[16:22:09.137]                           restarts <- computeRestarts(cond)
[16:22:09.137]                           for (restart in restarts) {
[16:22:09.137]                             name <- restart$name
[16:22:09.137]                             if (is.null(name)) 
[16:22:09.137]                               next
[16:22:09.137]                             if (!grepl(pattern, name)) 
[16:22:09.137]                               next
[16:22:09.137]                             invokeRestart(restart)
[16:22:09.137]                             muffled <- TRUE
[16:22:09.137]                             break
[16:22:09.137]                           }
[16:22:09.137]                         }
[16:22:09.137]                       }
[16:22:09.137]                       invisible(muffled)
[16:22:09.137]                     }
[16:22:09.137]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.137]                   }
[16:22:09.137]                 }
[16:22:09.137]                 else {
[16:22:09.137]                   if (TRUE) {
[16:22:09.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.137]                     {
[16:22:09.137]                       inherits <- base::inherits
[16:22:09.137]                       invokeRestart <- base::invokeRestart
[16:22:09.137]                       is.null <- base::is.null
[16:22:09.137]                       muffled <- FALSE
[16:22:09.137]                       if (inherits(cond, "message")) {
[16:22:09.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.137]                         if (muffled) 
[16:22:09.137]                           invokeRestart("muffleMessage")
[16:22:09.137]                       }
[16:22:09.137]                       else if (inherits(cond, "warning")) {
[16:22:09.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.137]                         if (muffled) 
[16:22:09.137]                           invokeRestart("muffleWarning")
[16:22:09.137]                       }
[16:22:09.137]                       else if (inherits(cond, "condition")) {
[16:22:09.137]                         if (!is.null(pattern)) {
[16:22:09.137]                           computeRestarts <- base::computeRestarts
[16:22:09.137]                           grepl <- base::grepl
[16:22:09.137]                           restarts <- computeRestarts(cond)
[16:22:09.137]                           for (restart in restarts) {
[16:22:09.137]                             name <- restart$name
[16:22:09.137]                             if (is.null(name)) 
[16:22:09.137]                               next
[16:22:09.137]                             if (!grepl(pattern, name)) 
[16:22:09.137]                               next
[16:22:09.137]                             invokeRestart(restart)
[16:22:09.137]                             muffled <- TRUE
[16:22:09.137]                             break
[16:22:09.137]                           }
[16:22:09.137]                         }
[16:22:09.137]                       }
[16:22:09.137]                       invisible(muffled)
[16:22:09.137]                     }
[16:22:09.137]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.137]                   }
[16:22:09.137]                 }
[16:22:09.137]             }
[16:22:09.137]         }))
[16:22:09.137]     }, error = function(ex) {
[16:22:09.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.137]                 ...future.rng), started = ...future.startTime, 
[16:22:09.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.137]             version = "1.8"), class = "FutureResult")
[16:22:09.137]     }, finally = {
[16:22:09.137]         if (!identical(...future.workdir, getwd())) 
[16:22:09.137]             setwd(...future.workdir)
[16:22:09.137]         {
[16:22:09.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.137]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.137]             }
[16:22:09.137]             base::options(...future.oldOptions)
[16:22:09.137]             if (.Platform$OS.type == "windows") {
[16:22:09.137]                 old_names <- names(...future.oldEnvVars)
[16:22:09.137]                 envs <- base::Sys.getenv()
[16:22:09.137]                 names <- names(envs)
[16:22:09.137]                 common <- intersect(names, old_names)
[16:22:09.137]                 added <- setdiff(names, old_names)
[16:22:09.137]                 removed <- setdiff(old_names, names)
[16:22:09.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.137]                   envs[common]]
[16:22:09.137]                 NAMES <- toupper(changed)
[16:22:09.137]                 args <- list()
[16:22:09.137]                 for (kk in seq_along(NAMES)) {
[16:22:09.137]                   name <- changed[[kk]]
[16:22:09.137]                   NAME <- NAMES[[kk]]
[16:22:09.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.137]                     next
[16:22:09.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.137]                 }
[16:22:09.137]                 NAMES <- toupper(added)
[16:22:09.137]                 for (kk in seq_along(NAMES)) {
[16:22:09.137]                   name <- added[[kk]]
[16:22:09.137]                   NAME <- NAMES[[kk]]
[16:22:09.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.137]                     next
[16:22:09.137]                   args[[name]] <- ""
[16:22:09.137]                 }
[16:22:09.137]                 NAMES <- toupper(removed)
[16:22:09.137]                 for (kk in seq_along(NAMES)) {
[16:22:09.137]                   name <- removed[[kk]]
[16:22:09.137]                   NAME <- NAMES[[kk]]
[16:22:09.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.137]                     next
[16:22:09.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.137]                 }
[16:22:09.137]                 if (length(args) > 0) 
[16:22:09.137]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.137]             }
[16:22:09.137]             else {
[16:22:09.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.137]             }
[16:22:09.137]             {
[16:22:09.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.137]                   0L) {
[16:22:09.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.137]                   base::options(opts)
[16:22:09.137]                 }
[16:22:09.137]                 {
[16:22:09.137]                   {
[16:22:09.137]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.137]                     NULL
[16:22:09.137]                   }
[16:22:09.137]                   options(future.plan = NULL)
[16:22:09.137]                   if (is.na(NA_character_)) 
[16:22:09.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.137]                     .init = FALSE)
[16:22:09.137]                 }
[16:22:09.137]             }
[16:22:09.137]         }
[16:22:09.137]     })
[16:22:09.137]     if (TRUE) {
[16:22:09.137]         base::sink(type = "output", split = FALSE)
[16:22:09.137]         if (TRUE) {
[16:22:09.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.137]         }
[16:22:09.137]         else {
[16:22:09.137]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.137]         }
[16:22:09.137]         base::close(...future.stdout)
[16:22:09.137]         ...future.stdout <- NULL
[16:22:09.137]     }
[16:22:09.137]     ...future.result$conditions <- ...future.conditions
[16:22:09.137]     ...future.result$finished <- base::Sys.time()
[16:22:09.137]     ...future.result
[16:22:09.137] }
[16:22:09.139] Poll #1 (0): usedNodes() = 2, workers = 2
[16:22:09.171] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[16:22:09.181] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.182] - Validating connection of MultisessionFuture
[16:22:09.182] - received message: FutureResult
[16:22:09.182] - Received FutureResult
[16:22:09.182] - Erased future from FutureRegistry
[16:22:09.182] result() for ClusterFuture ...
[16:22:09.182] - result already collected: FutureResult
[16:22:09.182] result() for ClusterFuture ... done
[16:22:09.182] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.182] result() for ClusterFuture ...
[16:22:09.183] - result already collected: FutureResult
[16:22:09.183] result() for ClusterFuture ... done
[16:22:09.183] result() for ClusterFuture ...
[16:22:09.183] - result already collected: FutureResult
[16:22:09.183] result() for ClusterFuture ... done
[16:22:09.184] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:22:09.184] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:22:09.184] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:22:09.184] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:22:09.185] MultisessionFuture started
[16:22:09.185] - Launch lazy future ... done
[16:22:09.185] run() for ‘MultisessionFuture’ ... done
[16:22:09.206] Future #1
[16:22:09.206]  length: 2 (resolved future 1)
[16:22:09.211] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.211] - Validating connection of MultisessionFuture
[16:22:09.212] - received message: FutureResult
[16:22:09.212] - Received FutureResult
[16:22:09.212] - Erased future from FutureRegistry
[16:22:09.212] result() for ClusterFuture ...
[16:22:09.212] - result already collected: FutureResult
[16:22:09.212] result() for ClusterFuture ... done
[16:22:09.212] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.212] Future #2
[16:22:09.213]  length: 1 (resolved future 2)
[16:22:09.295] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.295] - Validating connection of MultisessionFuture
[16:22:09.295] - received message: FutureResult
[16:22:09.296] - Received FutureResult
[16:22:09.296] - Erased future from FutureRegistry
[16:22:09.296] result() for ClusterFuture ...
[16:22:09.296] - result already collected: FutureResult
[16:22:09.296] result() for ClusterFuture ... done
[16:22:09.296] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.296] Future #3
[16:22:09.296]  length: 0 (resolved future 3)
[16:22:09.296] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:22:09.297] resolve() on environment ...
[16:22:09.297]  recursive: 0
[16:22:09.298]  elements: [2] ‘a’, ‘b’
[16:22:09.298]  length: 1 (resolved future 1)
[16:22:09.298]  length: 0 (resolved future 2)
[16:22:09.298] resolve() on environment ... DONE
[16:22:09.298] getGlobalsAndPackages() ...
[16:22:09.298] Searching for globals...
[16:22:09.299] 
[16:22:09.299] Searching for globals ... DONE
[16:22:09.299] - globals: [0] <none>
[16:22:09.299] getGlobalsAndPackages() ... DONE
[16:22:09.299] run() for ‘Future’ ...
[16:22:09.299] - state: ‘created’
[16:22:09.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.314]   - Field: ‘node’
[16:22:09.314]   - Field: ‘label’
[16:22:09.314]   - Field: ‘local’
[16:22:09.314]   - Field: ‘owner’
[16:22:09.314]   - Field: ‘envir’
[16:22:09.314]   - Field: ‘workers’
[16:22:09.314]   - Field: ‘packages’
[16:22:09.314]   - Field: ‘gc’
[16:22:09.314]   - Field: ‘conditions’
[16:22:09.314]   - Field: ‘persistent’
[16:22:09.314]   - Field: ‘expr’
[16:22:09.315]   - Field: ‘uuid’
[16:22:09.315]   - Field: ‘seed’
[16:22:09.315]   - Field: ‘version’
[16:22:09.315]   - Field: ‘result’
[16:22:09.315]   - Field: ‘asynchronous’
[16:22:09.315]   - Field: ‘calls’
[16:22:09.315]   - Field: ‘globals’
[16:22:09.315]   - Field: ‘stdout’
[16:22:09.315]   - Field: ‘earlySignal’
[16:22:09.315]   - Field: ‘lazy’
[16:22:09.315]   - Field: ‘state’
[16:22:09.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.316] - Launch lazy future ...
[16:22:09.316] Packages needed by the future expression (n = 0): <none>
[16:22:09.316] Packages needed by future strategies (n = 0): <none>
[16:22:09.317] {
[16:22:09.317]     {
[16:22:09.317]         {
[16:22:09.317]             ...future.startTime <- base::Sys.time()
[16:22:09.317]             {
[16:22:09.317]                 {
[16:22:09.317]                   {
[16:22:09.317]                     {
[16:22:09.317]                       base::local({
[16:22:09.317]                         has_future <- base::requireNamespace("future", 
[16:22:09.317]                           quietly = TRUE)
[16:22:09.317]                         if (has_future) {
[16:22:09.317]                           ns <- base::getNamespace("future")
[16:22:09.317]                           version <- ns[[".package"]][["version"]]
[16:22:09.317]                           if (is.null(version)) 
[16:22:09.317]                             version <- utils::packageVersion("future")
[16:22:09.317]                         }
[16:22:09.317]                         else {
[16:22:09.317]                           version <- NULL
[16:22:09.317]                         }
[16:22:09.317]                         if (!has_future || version < "1.8.0") {
[16:22:09.317]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.317]                             "", base::R.version$version.string), 
[16:22:09.317]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.317]                               "release", "version")], collapse = " "), 
[16:22:09.317]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.317]                             info)
[16:22:09.317]                           info <- base::paste(info, collapse = "; ")
[16:22:09.317]                           if (!has_future) {
[16:22:09.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.317]                               info)
[16:22:09.317]                           }
[16:22:09.317]                           else {
[16:22:09.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.317]                               info, version)
[16:22:09.317]                           }
[16:22:09.317]                           base::stop(msg)
[16:22:09.317]                         }
[16:22:09.317]                       })
[16:22:09.317]                     }
[16:22:09.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.317]                     base::options(mc.cores = 1L)
[16:22:09.317]                   }
[16:22:09.317]                   ...future.strategy.old <- future::plan("list")
[16:22:09.317]                   options(future.plan = NULL)
[16:22:09.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.317]                 }
[16:22:09.317]                 ...future.workdir <- getwd()
[16:22:09.317]             }
[16:22:09.317]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.317]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.317]         }
[16:22:09.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.317]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.317]             base::names(...future.oldOptions))
[16:22:09.317]     }
[16:22:09.317]     if (FALSE) {
[16:22:09.317]     }
[16:22:09.317]     else {
[16:22:09.317]         if (TRUE) {
[16:22:09.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.317]                 open = "w")
[16:22:09.317]         }
[16:22:09.317]         else {
[16:22:09.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.317]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.317]         }
[16:22:09.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.317]             base::sink(type = "output", split = FALSE)
[16:22:09.317]             base::close(...future.stdout)
[16:22:09.317]         }, add = TRUE)
[16:22:09.317]     }
[16:22:09.317]     ...future.frame <- base::sys.nframe()
[16:22:09.317]     ...future.conditions <- base::list()
[16:22:09.317]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.317]     if (FALSE) {
[16:22:09.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.317]     }
[16:22:09.317]     ...future.result <- base::tryCatch({
[16:22:09.317]         base::withCallingHandlers({
[16:22:09.317]             ...future.value <- base::withVisible(base::local({
[16:22:09.317]                 ...future.makeSendCondition <- base::local({
[16:22:09.317]                   sendCondition <- NULL
[16:22:09.317]                   function(frame = 1L) {
[16:22:09.317]                     if (is.function(sendCondition)) 
[16:22:09.317]                       return(sendCondition)
[16:22:09.317]                     ns <- getNamespace("parallel")
[16:22:09.317]                     if (exists("sendData", mode = "function", 
[16:22:09.317]                       envir = ns)) {
[16:22:09.317]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.317]                         envir = ns)
[16:22:09.317]                       envir <- sys.frame(frame)
[16:22:09.317]                       master <- NULL
[16:22:09.317]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.317]                         !identical(envir, emptyenv())) {
[16:22:09.317]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.317]                           inherits = FALSE)) {
[16:22:09.317]                           master <- get("master", mode = "list", 
[16:22:09.317]                             envir = envir, inherits = FALSE)
[16:22:09.317]                           if (inherits(master, c("SOCKnode", 
[16:22:09.317]                             "SOCK0node"))) {
[16:22:09.317]                             sendCondition <<- function(cond) {
[16:22:09.317]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.317]                                 success = TRUE)
[16:22:09.317]                               parallel_sendData(master, data)
[16:22:09.317]                             }
[16:22:09.317]                             return(sendCondition)
[16:22:09.317]                           }
[16:22:09.317]                         }
[16:22:09.317]                         frame <- frame + 1L
[16:22:09.317]                         envir <- sys.frame(frame)
[16:22:09.317]                       }
[16:22:09.317]                     }
[16:22:09.317]                     sendCondition <<- function(cond) NULL
[16:22:09.317]                   }
[16:22:09.317]                 })
[16:22:09.317]                 withCallingHandlers({
[16:22:09.317]                   1
[16:22:09.317]                 }, immediateCondition = function(cond) {
[16:22:09.317]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.317]                   sendCondition(cond)
[16:22:09.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.317]                   {
[16:22:09.317]                     inherits <- base::inherits
[16:22:09.317]                     invokeRestart <- base::invokeRestart
[16:22:09.317]                     is.null <- base::is.null
[16:22:09.317]                     muffled <- FALSE
[16:22:09.317]                     if (inherits(cond, "message")) {
[16:22:09.317]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.317]                       if (muffled) 
[16:22:09.317]                         invokeRestart("muffleMessage")
[16:22:09.317]                     }
[16:22:09.317]                     else if (inherits(cond, "warning")) {
[16:22:09.317]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.317]                       if (muffled) 
[16:22:09.317]                         invokeRestart("muffleWarning")
[16:22:09.317]                     }
[16:22:09.317]                     else if (inherits(cond, "condition")) {
[16:22:09.317]                       if (!is.null(pattern)) {
[16:22:09.317]                         computeRestarts <- base::computeRestarts
[16:22:09.317]                         grepl <- base::grepl
[16:22:09.317]                         restarts <- computeRestarts(cond)
[16:22:09.317]                         for (restart in restarts) {
[16:22:09.317]                           name <- restart$name
[16:22:09.317]                           if (is.null(name)) 
[16:22:09.317]                             next
[16:22:09.317]                           if (!grepl(pattern, name)) 
[16:22:09.317]                             next
[16:22:09.317]                           invokeRestart(restart)
[16:22:09.317]                           muffled <- TRUE
[16:22:09.317]                           break
[16:22:09.317]                         }
[16:22:09.317]                       }
[16:22:09.317]                     }
[16:22:09.317]                     invisible(muffled)
[16:22:09.317]                   }
[16:22:09.317]                   muffleCondition(cond)
[16:22:09.317]                 })
[16:22:09.317]             }))
[16:22:09.317]             future::FutureResult(value = ...future.value$value, 
[16:22:09.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.317]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.317]                     ...future.globalenv.names))
[16:22:09.317]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.317]         }, condition = base::local({
[16:22:09.317]             c <- base::c
[16:22:09.317]             inherits <- base::inherits
[16:22:09.317]             invokeRestart <- base::invokeRestart
[16:22:09.317]             length <- base::length
[16:22:09.317]             list <- base::list
[16:22:09.317]             seq.int <- base::seq.int
[16:22:09.317]             signalCondition <- base::signalCondition
[16:22:09.317]             sys.calls <- base::sys.calls
[16:22:09.317]             `[[` <- base::`[[`
[16:22:09.317]             `+` <- base::`+`
[16:22:09.317]             `<<-` <- base::`<<-`
[16:22:09.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.317]                   3L)]
[16:22:09.317]             }
[16:22:09.317]             function(cond) {
[16:22:09.317]                 is_error <- inherits(cond, "error")
[16:22:09.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.317]                   NULL)
[16:22:09.317]                 if (is_error) {
[16:22:09.317]                   sessionInformation <- function() {
[16:22:09.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.317]                       search = base::search(), system = base::Sys.info())
[16:22:09.317]                   }
[16:22:09.317]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.317]                     cond$call), session = sessionInformation(), 
[16:22:09.317]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.317]                   signalCondition(cond)
[16:22:09.317]                 }
[16:22:09.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.317]                 "immediateCondition"))) {
[16:22:09.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.317]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.317]                   if (TRUE && !signal) {
[16:22:09.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.317]                     {
[16:22:09.317]                       inherits <- base::inherits
[16:22:09.317]                       invokeRestart <- base::invokeRestart
[16:22:09.317]                       is.null <- base::is.null
[16:22:09.317]                       muffled <- FALSE
[16:22:09.317]                       if (inherits(cond, "message")) {
[16:22:09.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.317]                         if (muffled) 
[16:22:09.317]                           invokeRestart("muffleMessage")
[16:22:09.317]                       }
[16:22:09.317]                       else if (inherits(cond, "warning")) {
[16:22:09.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.317]                         if (muffled) 
[16:22:09.317]                           invokeRestart("muffleWarning")
[16:22:09.317]                       }
[16:22:09.317]                       else if (inherits(cond, "condition")) {
[16:22:09.317]                         if (!is.null(pattern)) {
[16:22:09.317]                           computeRestarts <- base::computeRestarts
[16:22:09.317]                           grepl <- base::grepl
[16:22:09.317]                           restarts <- computeRestarts(cond)
[16:22:09.317]                           for (restart in restarts) {
[16:22:09.317]                             name <- restart$name
[16:22:09.317]                             if (is.null(name)) 
[16:22:09.317]                               next
[16:22:09.317]                             if (!grepl(pattern, name)) 
[16:22:09.317]                               next
[16:22:09.317]                             invokeRestart(restart)
[16:22:09.317]                             muffled <- TRUE
[16:22:09.317]                             break
[16:22:09.317]                           }
[16:22:09.317]                         }
[16:22:09.317]                       }
[16:22:09.317]                       invisible(muffled)
[16:22:09.317]                     }
[16:22:09.317]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.317]                   }
[16:22:09.317]                 }
[16:22:09.317]                 else {
[16:22:09.317]                   if (TRUE) {
[16:22:09.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.317]                     {
[16:22:09.317]                       inherits <- base::inherits
[16:22:09.317]                       invokeRestart <- base::invokeRestart
[16:22:09.317]                       is.null <- base::is.null
[16:22:09.317]                       muffled <- FALSE
[16:22:09.317]                       if (inherits(cond, "message")) {
[16:22:09.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.317]                         if (muffled) 
[16:22:09.317]                           invokeRestart("muffleMessage")
[16:22:09.317]                       }
[16:22:09.317]                       else if (inherits(cond, "warning")) {
[16:22:09.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.317]                         if (muffled) 
[16:22:09.317]                           invokeRestart("muffleWarning")
[16:22:09.317]                       }
[16:22:09.317]                       else if (inherits(cond, "condition")) {
[16:22:09.317]                         if (!is.null(pattern)) {
[16:22:09.317]                           computeRestarts <- base::computeRestarts
[16:22:09.317]                           grepl <- base::grepl
[16:22:09.317]                           restarts <- computeRestarts(cond)
[16:22:09.317]                           for (restart in restarts) {
[16:22:09.317]                             name <- restart$name
[16:22:09.317]                             if (is.null(name)) 
[16:22:09.317]                               next
[16:22:09.317]                             if (!grepl(pattern, name)) 
[16:22:09.317]                               next
[16:22:09.317]                             invokeRestart(restart)
[16:22:09.317]                             muffled <- TRUE
[16:22:09.317]                             break
[16:22:09.317]                           }
[16:22:09.317]                         }
[16:22:09.317]                       }
[16:22:09.317]                       invisible(muffled)
[16:22:09.317]                     }
[16:22:09.317]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.317]                   }
[16:22:09.317]                 }
[16:22:09.317]             }
[16:22:09.317]         }))
[16:22:09.317]     }, error = function(ex) {
[16:22:09.317]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.317]                 ...future.rng), started = ...future.startTime, 
[16:22:09.317]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.317]             version = "1.8"), class = "FutureResult")
[16:22:09.317]     }, finally = {
[16:22:09.317]         if (!identical(...future.workdir, getwd())) 
[16:22:09.317]             setwd(...future.workdir)
[16:22:09.317]         {
[16:22:09.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.317]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.317]             }
[16:22:09.317]             base::options(...future.oldOptions)
[16:22:09.317]             if (.Platform$OS.type == "windows") {
[16:22:09.317]                 old_names <- names(...future.oldEnvVars)
[16:22:09.317]                 envs <- base::Sys.getenv()
[16:22:09.317]                 names <- names(envs)
[16:22:09.317]                 common <- intersect(names, old_names)
[16:22:09.317]                 added <- setdiff(names, old_names)
[16:22:09.317]                 removed <- setdiff(old_names, names)
[16:22:09.317]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.317]                   envs[common]]
[16:22:09.317]                 NAMES <- toupper(changed)
[16:22:09.317]                 args <- list()
[16:22:09.317]                 for (kk in seq_along(NAMES)) {
[16:22:09.317]                   name <- changed[[kk]]
[16:22:09.317]                   NAME <- NAMES[[kk]]
[16:22:09.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.317]                     next
[16:22:09.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.317]                 }
[16:22:09.317]                 NAMES <- toupper(added)
[16:22:09.317]                 for (kk in seq_along(NAMES)) {
[16:22:09.317]                   name <- added[[kk]]
[16:22:09.317]                   NAME <- NAMES[[kk]]
[16:22:09.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.317]                     next
[16:22:09.317]                   args[[name]] <- ""
[16:22:09.317]                 }
[16:22:09.317]                 NAMES <- toupper(removed)
[16:22:09.317]                 for (kk in seq_along(NAMES)) {
[16:22:09.317]                   name <- removed[[kk]]
[16:22:09.317]                   NAME <- NAMES[[kk]]
[16:22:09.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.317]                     next
[16:22:09.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.317]                 }
[16:22:09.317]                 if (length(args) > 0) 
[16:22:09.317]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.317]             }
[16:22:09.317]             else {
[16:22:09.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.317]             }
[16:22:09.317]             {
[16:22:09.317]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.317]                   0L) {
[16:22:09.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.317]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.317]                   base::options(opts)
[16:22:09.317]                 }
[16:22:09.317]                 {
[16:22:09.317]                   {
[16:22:09.317]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.317]                     NULL
[16:22:09.317]                   }
[16:22:09.317]                   options(future.plan = NULL)
[16:22:09.317]                   if (is.na(NA_character_)) 
[16:22:09.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.317]                     .init = FALSE)
[16:22:09.317]                 }
[16:22:09.317]             }
[16:22:09.317]         }
[16:22:09.317]     })
[16:22:09.317]     if (TRUE) {
[16:22:09.317]         base::sink(type = "output", split = FALSE)
[16:22:09.317]         if (TRUE) {
[16:22:09.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.317]         }
[16:22:09.317]         else {
[16:22:09.317]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.317]         }
[16:22:09.317]         base::close(...future.stdout)
[16:22:09.317]         ...future.stdout <- NULL
[16:22:09.317]     }
[16:22:09.317]     ...future.result$conditions <- ...future.conditions
[16:22:09.317]     ...future.result$finished <- base::Sys.time()
[16:22:09.317]     ...future.result
[16:22:09.317] }
[16:22:09.319] MultisessionFuture started
[16:22:09.320] - Launch lazy future ... done
[16:22:09.320] run() for ‘MultisessionFuture’ ... done
[16:22:09.320] getGlobalsAndPackages() ...
[16:22:09.320] Searching for globals...
[16:22:09.320] 
[16:22:09.320] Searching for globals ... DONE
[16:22:09.321] - globals: [0] <none>
[16:22:09.321] getGlobalsAndPackages() ... DONE
[16:22:09.321] run() for ‘Future’ ...
[16:22:09.321] - state: ‘created’
[16:22:09.321] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.335] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.335]   - Field: ‘node’
[16:22:09.335]   - Field: ‘label’
[16:22:09.335]   - Field: ‘local’
[16:22:09.335]   - Field: ‘owner’
[16:22:09.335]   - Field: ‘envir’
[16:22:09.335]   - Field: ‘workers’
[16:22:09.335]   - Field: ‘packages’
[16:22:09.335]   - Field: ‘gc’
[16:22:09.336]   - Field: ‘conditions’
[16:22:09.336]   - Field: ‘persistent’
[16:22:09.336]   - Field: ‘expr’
[16:22:09.336]   - Field: ‘uuid’
[16:22:09.336]   - Field: ‘seed’
[16:22:09.336]   - Field: ‘version’
[16:22:09.336]   - Field: ‘result’
[16:22:09.336]   - Field: ‘asynchronous’
[16:22:09.336]   - Field: ‘calls’
[16:22:09.336]   - Field: ‘globals’
[16:22:09.337]   - Field: ‘stdout’
[16:22:09.337]   - Field: ‘earlySignal’
[16:22:09.337]   - Field: ‘lazy’
[16:22:09.337]   - Field: ‘state’
[16:22:09.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.337] - Launch lazy future ...
[16:22:09.337] Packages needed by the future expression (n = 0): <none>
[16:22:09.337] Packages needed by future strategies (n = 0): <none>
[16:22:09.338] {
[16:22:09.338]     {
[16:22:09.338]         {
[16:22:09.338]             ...future.startTime <- base::Sys.time()
[16:22:09.338]             {
[16:22:09.338]                 {
[16:22:09.338]                   {
[16:22:09.338]                     {
[16:22:09.338]                       base::local({
[16:22:09.338]                         has_future <- base::requireNamespace("future", 
[16:22:09.338]                           quietly = TRUE)
[16:22:09.338]                         if (has_future) {
[16:22:09.338]                           ns <- base::getNamespace("future")
[16:22:09.338]                           version <- ns[[".package"]][["version"]]
[16:22:09.338]                           if (is.null(version)) 
[16:22:09.338]                             version <- utils::packageVersion("future")
[16:22:09.338]                         }
[16:22:09.338]                         else {
[16:22:09.338]                           version <- NULL
[16:22:09.338]                         }
[16:22:09.338]                         if (!has_future || version < "1.8.0") {
[16:22:09.338]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.338]                             "", base::R.version$version.string), 
[16:22:09.338]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.338]                               "release", "version")], collapse = " "), 
[16:22:09.338]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.338]                             info)
[16:22:09.338]                           info <- base::paste(info, collapse = "; ")
[16:22:09.338]                           if (!has_future) {
[16:22:09.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.338]                               info)
[16:22:09.338]                           }
[16:22:09.338]                           else {
[16:22:09.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.338]                               info, version)
[16:22:09.338]                           }
[16:22:09.338]                           base::stop(msg)
[16:22:09.338]                         }
[16:22:09.338]                       })
[16:22:09.338]                     }
[16:22:09.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.338]                     base::options(mc.cores = 1L)
[16:22:09.338]                   }
[16:22:09.338]                   ...future.strategy.old <- future::plan("list")
[16:22:09.338]                   options(future.plan = NULL)
[16:22:09.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.338]                 }
[16:22:09.338]                 ...future.workdir <- getwd()
[16:22:09.338]             }
[16:22:09.338]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.338]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.338]         }
[16:22:09.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.338]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.338]             base::names(...future.oldOptions))
[16:22:09.338]     }
[16:22:09.338]     if (FALSE) {
[16:22:09.338]     }
[16:22:09.338]     else {
[16:22:09.338]         if (TRUE) {
[16:22:09.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.338]                 open = "w")
[16:22:09.338]         }
[16:22:09.338]         else {
[16:22:09.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.338]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.338]         }
[16:22:09.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.338]             base::sink(type = "output", split = FALSE)
[16:22:09.338]             base::close(...future.stdout)
[16:22:09.338]         }, add = TRUE)
[16:22:09.338]     }
[16:22:09.338]     ...future.frame <- base::sys.nframe()
[16:22:09.338]     ...future.conditions <- base::list()
[16:22:09.338]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.338]     if (FALSE) {
[16:22:09.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.338]     }
[16:22:09.338]     ...future.result <- base::tryCatch({
[16:22:09.338]         base::withCallingHandlers({
[16:22:09.338]             ...future.value <- base::withVisible(base::local({
[16:22:09.338]                 ...future.makeSendCondition <- base::local({
[16:22:09.338]                   sendCondition <- NULL
[16:22:09.338]                   function(frame = 1L) {
[16:22:09.338]                     if (is.function(sendCondition)) 
[16:22:09.338]                       return(sendCondition)
[16:22:09.338]                     ns <- getNamespace("parallel")
[16:22:09.338]                     if (exists("sendData", mode = "function", 
[16:22:09.338]                       envir = ns)) {
[16:22:09.338]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.338]                         envir = ns)
[16:22:09.338]                       envir <- sys.frame(frame)
[16:22:09.338]                       master <- NULL
[16:22:09.338]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.338]                         !identical(envir, emptyenv())) {
[16:22:09.338]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.338]                           inherits = FALSE)) {
[16:22:09.338]                           master <- get("master", mode = "list", 
[16:22:09.338]                             envir = envir, inherits = FALSE)
[16:22:09.338]                           if (inherits(master, c("SOCKnode", 
[16:22:09.338]                             "SOCK0node"))) {
[16:22:09.338]                             sendCondition <<- function(cond) {
[16:22:09.338]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.338]                                 success = TRUE)
[16:22:09.338]                               parallel_sendData(master, data)
[16:22:09.338]                             }
[16:22:09.338]                             return(sendCondition)
[16:22:09.338]                           }
[16:22:09.338]                         }
[16:22:09.338]                         frame <- frame + 1L
[16:22:09.338]                         envir <- sys.frame(frame)
[16:22:09.338]                       }
[16:22:09.338]                     }
[16:22:09.338]                     sendCondition <<- function(cond) NULL
[16:22:09.338]                   }
[16:22:09.338]                 })
[16:22:09.338]                 withCallingHandlers({
[16:22:09.338]                   2
[16:22:09.338]                 }, immediateCondition = function(cond) {
[16:22:09.338]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.338]                   sendCondition(cond)
[16:22:09.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.338]                   {
[16:22:09.338]                     inherits <- base::inherits
[16:22:09.338]                     invokeRestart <- base::invokeRestart
[16:22:09.338]                     is.null <- base::is.null
[16:22:09.338]                     muffled <- FALSE
[16:22:09.338]                     if (inherits(cond, "message")) {
[16:22:09.338]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.338]                       if (muffled) 
[16:22:09.338]                         invokeRestart("muffleMessage")
[16:22:09.338]                     }
[16:22:09.338]                     else if (inherits(cond, "warning")) {
[16:22:09.338]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.338]                       if (muffled) 
[16:22:09.338]                         invokeRestart("muffleWarning")
[16:22:09.338]                     }
[16:22:09.338]                     else if (inherits(cond, "condition")) {
[16:22:09.338]                       if (!is.null(pattern)) {
[16:22:09.338]                         computeRestarts <- base::computeRestarts
[16:22:09.338]                         grepl <- base::grepl
[16:22:09.338]                         restarts <- computeRestarts(cond)
[16:22:09.338]                         for (restart in restarts) {
[16:22:09.338]                           name <- restart$name
[16:22:09.338]                           if (is.null(name)) 
[16:22:09.338]                             next
[16:22:09.338]                           if (!grepl(pattern, name)) 
[16:22:09.338]                             next
[16:22:09.338]                           invokeRestart(restart)
[16:22:09.338]                           muffled <- TRUE
[16:22:09.338]                           break
[16:22:09.338]                         }
[16:22:09.338]                       }
[16:22:09.338]                     }
[16:22:09.338]                     invisible(muffled)
[16:22:09.338]                   }
[16:22:09.338]                   muffleCondition(cond)
[16:22:09.338]                 })
[16:22:09.338]             }))
[16:22:09.338]             future::FutureResult(value = ...future.value$value, 
[16:22:09.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.338]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.338]                     ...future.globalenv.names))
[16:22:09.338]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.338]         }, condition = base::local({
[16:22:09.338]             c <- base::c
[16:22:09.338]             inherits <- base::inherits
[16:22:09.338]             invokeRestart <- base::invokeRestart
[16:22:09.338]             length <- base::length
[16:22:09.338]             list <- base::list
[16:22:09.338]             seq.int <- base::seq.int
[16:22:09.338]             signalCondition <- base::signalCondition
[16:22:09.338]             sys.calls <- base::sys.calls
[16:22:09.338]             `[[` <- base::`[[`
[16:22:09.338]             `+` <- base::`+`
[16:22:09.338]             `<<-` <- base::`<<-`
[16:22:09.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.338]                   3L)]
[16:22:09.338]             }
[16:22:09.338]             function(cond) {
[16:22:09.338]                 is_error <- inherits(cond, "error")
[16:22:09.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.338]                   NULL)
[16:22:09.338]                 if (is_error) {
[16:22:09.338]                   sessionInformation <- function() {
[16:22:09.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.338]                       search = base::search(), system = base::Sys.info())
[16:22:09.338]                   }
[16:22:09.338]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.338]                     cond$call), session = sessionInformation(), 
[16:22:09.338]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.338]                   signalCondition(cond)
[16:22:09.338]                 }
[16:22:09.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.338]                 "immediateCondition"))) {
[16:22:09.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.338]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.338]                   if (TRUE && !signal) {
[16:22:09.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.338]                     {
[16:22:09.338]                       inherits <- base::inherits
[16:22:09.338]                       invokeRestart <- base::invokeRestart
[16:22:09.338]                       is.null <- base::is.null
[16:22:09.338]                       muffled <- FALSE
[16:22:09.338]                       if (inherits(cond, "message")) {
[16:22:09.338]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.338]                         if (muffled) 
[16:22:09.338]                           invokeRestart("muffleMessage")
[16:22:09.338]                       }
[16:22:09.338]                       else if (inherits(cond, "warning")) {
[16:22:09.338]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.338]                         if (muffled) 
[16:22:09.338]                           invokeRestart("muffleWarning")
[16:22:09.338]                       }
[16:22:09.338]                       else if (inherits(cond, "condition")) {
[16:22:09.338]                         if (!is.null(pattern)) {
[16:22:09.338]                           computeRestarts <- base::computeRestarts
[16:22:09.338]                           grepl <- base::grepl
[16:22:09.338]                           restarts <- computeRestarts(cond)
[16:22:09.338]                           for (restart in restarts) {
[16:22:09.338]                             name <- restart$name
[16:22:09.338]                             if (is.null(name)) 
[16:22:09.338]                               next
[16:22:09.338]                             if (!grepl(pattern, name)) 
[16:22:09.338]                               next
[16:22:09.338]                             invokeRestart(restart)
[16:22:09.338]                             muffled <- TRUE
[16:22:09.338]                             break
[16:22:09.338]                           }
[16:22:09.338]                         }
[16:22:09.338]                       }
[16:22:09.338]                       invisible(muffled)
[16:22:09.338]                     }
[16:22:09.338]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.338]                   }
[16:22:09.338]                 }
[16:22:09.338]                 else {
[16:22:09.338]                   if (TRUE) {
[16:22:09.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.338]                     {
[16:22:09.338]                       inherits <- base::inherits
[16:22:09.338]                       invokeRestart <- base::invokeRestart
[16:22:09.338]                       is.null <- base::is.null
[16:22:09.338]                       muffled <- FALSE
[16:22:09.338]                       if (inherits(cond, "message")) {
[16:22:09.338]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.338]                         if (muffled) 
[16:22:09.338]                           invokeRestart("muffleMessage")
[16:22:09.338]                       }
[16:22:09.338]                       else if (inherits(cond, "warning")) {
[16:22:09.338]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.338]                         if (muffled) 
[16:22:09.338]                           invokeRestart("muffleWarning")
[16:22:09.338]                       }
[16:22:09.338]                       else if (inherits(cond, "condition")) {
[16:22:09.338]                         if (!is.null(pattern)) {
[16:22:09.338]                           computeRestarts <- base::computeRestarts
[16:22:09.338]                           grepl <- base::grepl
[16:22:09.338]                           restarts <- computeRestarts(cond)
[16:22:09.338]                           for (restart in restarts) {
[16:22:09.338]                             name <- restart$name
[16:22:09.338]                             if (is.null(name)) 
[16:22:09.338]                               next
[16:22:09.338]                             if (!grepl(pattern, name)) 
[16:22:09.338]                               next
[16:22:09.338]                             invokeRestart(restart)
[16:22:09.338]                             muffled <- TRUE
[16:22:09.338]                             break
[16:22:09.338]                           }
[16:22:09.338]                         }
[16:22:09.338]                       }
[16:22:09.338]                       invisible(muffled)
[16:22:09.338]                     }
[16:22:09.338]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.338]                   }
[16:22:09.338]                 }
[16:22:09.338]             }
[16:22:09.338]         }))
[16:22:09.338]     }, error = function(ex) {
[16:22:09.338]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.338]                 ...future.rng), started = ...future.startTime, 
[16:22:09.338]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.338]             version = "1.8"), class = "FutureResult")
[16:22:09.338]     }, finally = {
[16:22:09.338]         if (!identical(...future.workdir, getwd())) 
[16:22:09.338]             setwd(...future.workdir)
[16:22:09.338]         {
[16:22:09.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.338]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.338]             }
[16:22:09.338]             base::options(...future.oldOptions)
[16:22:09.338]             if (.Platform$OS.type == "windows") {
[16:22:09.338]                 old_names <- names(...future.oldEnvVars)
[16:22:09.338]                 envs <- base::Sys.getenv()
[16:22:09.338]                 names <- names(envs)
[16:22:09.338]                 common <- intersect(names, old_names)
[16:22:09.338]                 added <- setdiff(names, old_names)
[16:22:09.338]                 removed <- setdiff(old_names, names)
[16:22:09.338]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.338]                   envs[common]]
[16:22:09.338]                 NAMES <- toupper(changed)
[16:22:09.338]                 args <- list()
[16:22:09.338]                 for (kk in seq_along(NAMES)) {
[16:22:09.338]                   name <- changed[[kk]]
[16:22:09.338]                   NAME <- NAMES[[kk]]
[16:22:09.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.338]                     next
[16:22:09.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.338]                 }
[16:22:09.338]                 NAMES <- toupper(added)
[16:22:09.338]                 for (kk in seq_along(NAMES)) {
[16:22:09.338]                   name <- added[[kk]]
[16:22:09.338]                   NAME <- NAMES[[kk]]
[16:22:09.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.338]                     next
[16:22:09.338]                   args[[name]] <- ""
[16:22:09.338]                 }
[16:22:09.338]                 NAMES <- toupper(removed)
[16:22:09.338]                 for (kk in seq_along(NAMES)) {
[16:22:09.338]                   name <- removed[[kk]]
[16:22:09.338]                   NAME <- NAMES[[kk]]
[16:22:09.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.338]                     next
[16:22:09.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.338]                 }
[16:22:09.338]                 if (length(args) > 0) 
[16:22:09.338]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.338]             }
[16:22:09.338]             else {
[16:22:09.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.338]             }
[16:22:09.338]             {
[16:22:09.338]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.338]                   0L) {
[16:22:09.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.338]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.338]                   base::options(opts)
[16:22:09.338]                 }
[16:22:09.338]                 {
[16:22:09.338]                   {
[16:22:09.338]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.338]                     NULL
[16:22:09.338]                   }
[16:22:09.338]                   options(future.plan = NULL)
[16:22:09.338]                   if (is.na(NA_character_)) 
[16:22:09.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.338]                     .init = FALSE)
[16:22:09.338]                 }
[16:22:09.338]             }
[16:22:09.338]         }
[16:22:09.338]     })
[16:22:09.338]     if (TRUE) {
[16:22:09.338]         base::sink(type = "output", split = FALSE)
[16:22:09.338]         if (TRUE) {
[16:22:09.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.338]         }
[16:22:09.338]         else {
[16:22:09.338]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.338]         }
[16:22:09.338]         base::close(...future.stdout)
[16:22:09.338]         ...future.stdout <- NULL
[16:22:09.338]     }
[16:22:09.338]     ...future.result$conditions <- ...future.conditions
[16:22:09.338]     ...future.result$finished <- base::Sys.time()
[16:22:09.338]     ...future.result
[16:22:09.338] }
[16:22:09.341] MultisessionFuture started
[16:22:09.341] - Launch lazy future ... done
[16:22:09.341] run() for ‘MultisessionFuture’ ... done
[16:22:09.342] resolve() on environment ...
[16:22:09.342]  recursive: 0
[16:22:09.343]  elements: [3] ‘a’, ‘b’, ‘c’
[16:22:09.343] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.344] - Validating connection of MultisessionFuture
[16:22:09.344] - received message: FutureResult
[16:22:09.344] - Received FutureResult
[16:22:09.344] - Erased future from FutureRegistry
[16:22:09.344] result() for ClusterFuture ...
[16:22:09.344] - result already collected: FutureResult
[16:22:09.344] result() for ClusterFuture ... done
[16:22:09.344] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.344] Future #1
[16:22:09.345]  length: 2 (resolved future 1)
[16:22:09.345] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.345] - Validating connection of MultisessionFuture
[16:22:09.345] - received message: FutureResult
[16:22:09.345] - Received FutureResult
[16:22:09.345] - Erased future from FutureRegistry
[16:22:09.346] result() for ClusterFuture ...
[16:22:09.346] - result already collected: FutureResult
[16:22:09.346] result() for ClusterFuture ... done
[16:22:09.346] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.346] Future #2
[16:22:09.346]  length: 1 (resolved future 2)
[16:22:09.346]  length: 0 (resolved future 3)
[16:22:09.346] resolve() on environment ... DONE
[16:22:09.347] getGlobalsAndPackages() ...
[16:22:09.347] Searching for globals...
[16:22:09.347] - globals found: [1] ‘{’
[16:22:09.348] Searching for globals ... DONE
[16:22:09.348] Resolving globals: FALSE
[16:22:09.348] 
[16:22:09.348] 
[16:22:09.348] getGlobalsAndPackages() ... DONE
[16:22:09.348] run() for ‘Future’ ...
[16:22:09.349] - state: ‘created’
[16:22:09.349] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.362]   - Field: ‘node’
[16:22:09.362]   - Field: ‘label’
[16:22:09.363]   - Field: ‘local’
[16:22:09.363]   - Field: ‘owner’
[16:22:09.363]   - Field: ‘envir’
[16:22:09.363]   - Field: ‘workers’
[16:22:09.363]   - Field: ‘packages’
[16:22:09.363]   - Field: ‘gc’
[16:22:09.363]   - Field: ‘conditions’
[16:22:09.363]   - Field: ‘persistent’
[16:22:09.363]   - Field: ‘expr’
[16:22:09.363]   - Field: ‘uuid’
[16:22:09.363]   - Field: ‘seed’
[16:22:09.364]   - Field: ‘version’
[16:22:09.364]   - Field: ‘result’
[16:22:09.364]   - Field: ‘asynchronous’
[16:22:09.364]   - Field: ‘calls’
[16:22:09.364]   - Field: ‘globals’
[16:22:09.364]   - Field: ‘stdout’
[16:22:09.364]   - Field: ‘earlySignal’
[16:22:09.364]   - Field: ‘lazy’
[16:22:09.364]   - Field: ‘state’
[16:22:09.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.365] - Launch lazy future ...
[16:22:09.365] Packages needed by the future expression (n = 0): <none>
[16:22:09.365] Packages needed by future strategies (n = 0): <none>
[16:22:09.365] {
[16:22:09.365]     {
[16:22:09.365]         {
[16:22:09.365]             ...future.startTime <- base::Sys.time()
[16:22:09.365]             {
[16:22:09.365]                 {
[16:22:09.365]                   {
[16:22:09.365]                     {
[16:22:09.365]                       base::local({
[16:22:09.365]                         has_future <- base::requireNamespace("future", 
[16:22:09.365]                           quietly = TRUE)
[16:22:09.365]                         if (has_future) {
[16:22:09.365]                           ns <- base::getNamespace("future")
[16:22:09.365]                           version <- ns[[".package"]][["version"]]
[16:22:09.365]                           if (is.null(version)) 
[16:22:09.365]                             version <- utils::packageVersion("future")
[16:22:09.365]                         }
[16:22:09.365]                         else {
[16:22:09.365]                           version <- NULL
[16:22:09.365]                         }
[16:22:09.365]                         if (!has_future || version < "1.8.0") {
[16:22:09.365]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.365]                             "", base::R.version$version.string), 
[16:22:09.365]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.365]                               "release", "version")], collapse = " "), 
[16:22:09.365]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.365]                             info)
[16:22:09.365]                           info <- base::paste(info, collapse = "; ")
[16:22:09.365]                           if (!has_future) {
[16:22:09.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.365]                               info)
[16:22:09.365]                           }
[16:22:09.365]                           else {
[16:22:09.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.365]                               info, version)
[16:22:09.365]                           }
[16:22:09.365]                           base::stop(msg)
[16:22:09.365]                         }
[16:22:09.365]                       })
[16:22:09.365]                     }
[16:22:09.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.365]                     base::options(mc.cores = 1L)
[16:22:09.365]                   }
[16:22:09.365]                   ...future.strategy.old <- future::plan("list")
[16:22:09.365]                   options(future.plan = NULL)
[16:22:09.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.365]                 }
[16:22:09.365]                 ...future.workdir <- getwd()
[16:22:09.365]             }
[16:22:09.365]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.365]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.365]         }
[16:22:09.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.365]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.365]             base::names(...future.oldOptions))
[16:22:09.365]     }
[16:22:09.365]     if (FALSE) {
[16:22:09.365]     }
[16:22:09.365]     else {
[16:22:09.365]         if (TRUE) {
[16:22:09.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.365]                 open = "w")
[16:22:09.365]         }
[16:22:09.365]         else {
[16:22:09.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.365]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.365]         }
[16:22:09.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.365]             base::sink(type = "output", split = FALSE)
[16:22:09.365]             base::close(...future.stdout)
[16:22:09.365]         }, add = TRUE)
[16:22:09.365]     }
[16:22:09.365]     ...future.frame <- base::sys.nframe()
[16:22:09.365]     ...future.conditions <- base::list()
[16:22:09.365]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.365]     if (FALSE) {
[16:22:09.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.365]     }
[16:22:09.365]     ...future.result <- base::tryCatch({
[16:22:09.365]         base::withCallingHandlers({
[16:22:09.365]             ...future.value <- base::withVisible(base::local({
[16:22:09.365]                 ...future.makeSendCondition <- base::local({
[16:22:09.365]                   sendCondition <- NULL
[16:22:09.365]                   function(frame = 1L) {
[16:22:09.365]                     if (is.function(sendCondition)) 
[16:22:09.365]                       return(sendCondition)
[16:22:09.365]                     ns <- getNamespace("parallel")
[16:22:09.365]                     if (exists("sendData", mode = "function", 
[16:22:09.365]                       envir = ns)) {
[16:22:09.365]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.365]                         envir = ns)
[16:22:09.365]                       envir <- sys.frame(frame)
[16:22:09.365]                       master <- NULL
[16:22:09.365]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.365]                         !identical(envir, emptyenv())) {
[16:22:09.365]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.365]                           inherits = FALSE)) {
[16:22:09.365]                           master <- get("master", mode = "list", 
[16:22:09.365]                             envir = envir, inherits = FALSE)
[16:22:09.365]                           if (inherits(master, c("SOCKnode", 
[16:22:09.365]                             "SOCK0node"))) {
[16:22:09.365]                             sendCondition <<- function(cond) {
[16:22:09.365]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.365]                                 success = TRUE)
[16:22:09.365]                               parallel_sendData(master, data)
[16:22:09.365]                             }
[16:22:09.365]                             return(sendCondition)
[16:22:09.365]                           }
[16:22:09.365]                         }
[16:22:09.365]                         frame <- frame + 1L
[16:22:09.365]                         envir <- sys.frame(frame)
[16:22:09.365]                       }
[16:22:09.365]                     }
[16:22:09.365]                     sendCondition <<- function(cond) NULL
[16:22:09.365]                   }
[16:22:09.365]                 })
[16:22:09.365]                 withCallingHandlers({
[16:22:09.365]                   {
[16:22:09.365]                     1
[16:22:09.365]                   }
[16:22:09.365]                 }, immediateCondition = function(cond) {
[16:22:09.365]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.365]                   sendCondition(cond)
[16:22:09.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.365]                   {
[16:22:09.365]                     inherits <- base::inherits
[16:22:09.365]                     invokeRestart <- base::invokeRestart
[16:22:09.365]                     is.null <- base::is.null
[16:22:09.365]                     muffled <- FALSE
[16:22:09.365]                     if (inherits(cond, "message")) {
[16:22:09.365]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.365]                       if (muffled) 
[16:22:09.365]                         invokeRestart("muffleMessage")
[16:22:09.365]                     }
[16:22:09.365]                     else if (inherits(cond, "warning")) {
[16:22:09.365]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.365]                       if (muffled) 
[16:22:09.365]                         invokeRestart("muffleWarning")
[16:22:09.365]                     }
[16:22:09.365]                     else if (inherits(cond, "condition")) {
[16:22:09.365]                       if (!is.null(pattern)) {
[16:22:09.365]                         computeRestarts <- base::computeRestarts
[16:22:09.365]                         grepl <- base::grepl
[16:22:09.365]                         restarts <- computeRestarts(cond)
[16:22:09.365]                         for (restart in restarts) {
[16:22:09.365]                           name <- restart$name
[16:22:09.365]                           if (is.null(name)) 
[16:22:09.365]                             next
[16:22:09.365]                           if (!grepl(pattern, name)) 
[16:22:09.365]                             next
[16:22:09.365]                           invokeRestart(restart)
[16:22:09.365]                           muffled <- TRUE
[16:22:09.365]                           break
[16:22:09.365]                         }
[16:22:09.365]                       }
[16:22:09.365]                     }
[16:22:09.365]                     invisible(muffled)
[16:22:09.365]                   }
[16:22:09.365]                   muffleCondition(cond)
[16:22:09.365]                 })
[16:22:09.365]             }))
[16:22:09.365]             future::FutureResult(value = ...future.value$value, 
[16:22:09.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.365]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.365]                     ...future.globalenv.names))
[16:22:09.365]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.365]         }, condition = base::local({
[16:22:09.365]             c <- base::c
[16:22:09.365]             inherits <- base::inherits
[16:22:09.365]             invokeRestart <- base::invokeRestart
[16:22:09.365]             length <- base::length
[16:22:09.365]             list <- base::list
[16:22:09.365]             seq.int <- base::seq.int
[16:22:09.365]             signalCondition <- base::signalCondition
[16:22:09.365]             sys.calls <- base::sys.calls
[16:22:09.365]             `[[` <- base::`[[`
[16:22:09.365]             `+` <- base::`+`
[16:22:09.365]             `<<-` <- base::`<<-`
[16:22:09.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.365]                   3L)]
[16:22:09.365]             }
[16:22:09.365]             function(cond) {
[16:22:09.365]                 is_error <- inherits(cond, "error")
[16:22:09.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.365]                   NULL)
[16:22:09.365]                 if (is_error) {
[16:22:09.365]                   sessionInformation <- function() {
[16:22:09.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.365]                       search = base::search(), system = base::Sys.info())
[16:22:09.365]                   }
[16:22:09.365]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.365]                     cond$call), session = sessionInformation(), 
[16:22:09.365]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.365]                   signalCondition(cond)
[16:22:09.365]                 }
[16:22:09.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.365]                 "immediateCondition"))) {
[16:22:09.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.365]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.365]                   if (TRUE && !signal) {
[16:22:09.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.365]                     {
[16:22:09.365]                       inherits <- base::inherits
[16:22:09.365]                       invokeRestart <- base::invokeRestart
[16:22:09.365]                       is.null <- base::is.null
[16:22:09.365]                       muffled <- FALSE
[16:22:09.365]                       if (inherits(cond, "message")) {
[16:22:09.365]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.365]                         if (muffled) 
[16:22:09.365]                           invokeRestart("muffleMessage")
[16:22:09.365]                       }
[16:22:09.365]                       else if (inherits(cond, "warning")) {
[16:22:09.365]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.365]                         if (muffled) 
[16:22:09.365]                           invokeRestart("muffleWarning")
[16:22:09.365]                       }
[16:22:09.365]                       else if (inherits(cond, "condition")) {
[16:22:09.365]                         if (!is.null(pattern)) {
[16:22:09.365]                           computeRestarts <- base::computeRestarts
[16:22:09.365]                           grepl <- base::grepl
[16:22:09.365]                           restarts <- computeRestarts(cond)
[16:22:09.365]                           for (restart in restarts) {
[16:22:09.365]                             name <- restart$name
[16:22:09.365]                             if (is.null(name)) 
[16:22:09.365]                               next
[16:22:09.365]                             if (!grepl(pattern, name)) 
[16:22:09.365]                               next
[16:22:09.365]                             invokeRestart(restart)
[16:22:09.365]                             muffled <- TRUE
[16:22:09.365]                             break
[16:22:09.365]                           }
[16:22:09.365]                         }
[16:22:09.365]                       }
[16:22:09.365]                       invisible(muffled)
[16:22:09.365]                     }
[16:22:09.365]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.365]                   }
[16:22:09.365]                 }
[16:22:09.365]                 else {
[16:22:09.365]                   if (TRUE) {
[16:22:09.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.365]                     {
[16:22:09.365]                       inherits <- base::inherits
[16:22:09.365]                       invokeRestart <- base::invokeRestart
[16:22:09.365]                       is.null <- base::is.null
[16:22:09.365]                       muffled <- FALSE
[16:22:09.365]                       if (inherits(cond, "message")) {
[16:22:09.365]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.365]                         if (muffled) 
[16:22:09.365]                           invokeRestart("muffleMessage")
[16:22:09.365]                       }
[16:22:09.365]                       else if (inherits(cond, "warning")) {
[16:22:09.365]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.365]                         if (muffled) 
[16:22:09.365]                           invokeRestart("muffleWarning")
[16:22:09.365]                       }
[16:22:09.365]                       else if (inherits(cond, "condition")) {
[16:22:09.365]                         if (!is.null(pattern)) {
[16:22:09.365]                           computeRestarts <- base::computeRestarts
[16:22:09.365]                           grepl <- base::grepl
[16:22:09.365]                           restarts <- computeRestarts(cond)
[16:22:09.365]                           for (restart in restarts) {
[16:22:09.365]                             name <- restart$name
[16:22:09.365]                             if (is.null(name)) 
[16:22:09.365]                               next
[16:22:09.365]                             if (!grepl(pattern, name)) 
[16:22:09.365]                               next
[16:22:09.365]                             invokeRestart(restart)
[16:22:09.365]                             muffled <- TRUE
[16:22:09.365]                             break
[16:22:09.365]                           }
[16:22:09.365]                         }
[16:22:09.365]                       }
[16:22:09.365]                       invisible(muffled)
[16:22:09.365]                     }
[16:22:09.365]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.365]                   }
[16:22:09.365]                 }
[16:22:09.365]             }
[16:22:09.365]         }))
[16:22:09.365]     }, error = function(ex) {
[16:22:09.365]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.365]                 ...future.rng), started = ...future.startTime, 
[16:22:09.365]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.365]             version = "1.8"), class = "FutureResult")
[16:22:09.365]     }, finally = {
[16:22:09.365]         if (!identical(...future.workdir, getwd())) 
[16:22:09.365]             setwd(...future.workdir)
[16:22:09.365]         {
[16:22:09.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.365]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.365]             }
[16:22:09.365]             base::options(...future.oldOptions)
[16:22:09.365]             if (.Platform$OS.type == "windows") {
[16:22:09.365]                 old_names <- names(...future.oldEnvVars)
[16:22:09.365]                 envs <- base::Sys.getenv()
[16:22:09.365]                 names <- names(envs)
[16:22:09.365]                 common <- intersect(names, old_names)
[16:22:09.365]                 added <- setdiff(names, old_names)
[16:22:09.365]                 removed <- setdiff(old_names, names)
[16:22:09.365]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.365]                   envs[common]]
[16:22:09.365]                 NAMES <- toupper(changed)
[16:22:09.365]                 args <- list()
[16:22:09.365]                 for (kk in seq_along(NAMES)) {
[16:22:09.365]                   name <- changed[[kk]]
[16:22:09.365]                   NAME <- NAMES[[kk]]
[16:22:09.365]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.365]                     next
[16:22:09.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.365]                 }
[16:22:09.365]                 NAMES <- toupper(added)
[16:22:09.365]                 for (kk in seq_along(NAMES)) {
[16:22:09.365]                   name <- added[[kk]]
[16:22:09.365]                   NAME <- NAMES[[kk]]
[16:22:09.365]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.365]                     next
[16:22:09.365]                   args[[name]] <- ""
[16:22:09.365]                 }
[16:22:09.365]                 NAMES <- toupper(removed)
[16:22:09.365]                 for (kk in seq_along(NAMES)) {
[16:22:09.365]                   name <- removed[[kk]]
[16:22:09.365]                   NAME <- NAMES[[kk]]
[16:22:09.365]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.365]                     next
[16:22:09.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.365]                 }
[16:22:09.365]                 if (length(args) > 0) 
[16:22:09.365]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.365]             }
[16:22:09.365]             else {
[16:22:09.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.365]             }
[16:22:09.365]             {
[16:22:09.365]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.365]                   0L) {
[16:22:09.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.365]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.365]                   base::options(opts)
[16:22:09.365]                 }
[16:22:09.365]                 {
[16:22:09.365]                   {
[16:22:09.365]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.365]                     NULL
[16:22:09.365]                   }
[16:22:09.365]                   options(future.plan = NULL)
[16:22:09.365]                   if (is.na(NA_character_)) 
[16:22:09.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.365]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.365]                     .init = FALSE)
[16:22:09.365]                 }
[16:22:09.365]             }
[16:22:09.365]         }
[16:22:09.365]     })
[16:22:09.365]     if (TRUE) {
[16:22:09.365]         base::sink(type = "output", split = FALSE)
[16:22:09.365]         if (TRUE) {
[16:22:09.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.365]         }
[16:22:09.365]         else {
[16:22:09.365]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.365]         }
[16:22:09.365]         base::close(...future.stdout)
[16:22:09.365]         ...future.stdout <- NULL
[16:22:09.365]     }
[16:22:09.365]     ...future.result$conditions <- ...future.conditions
[16:22:09.365]     ...future.result$finished <- base::Sys.time()
[16:22:09.365]     ...future.result
[16:22:09.365] }
[16:22:09.368] MultisessionFuture started
[16:22:09.368] - Launch lazy future ... done
[16:22:09.368] run() for ‘MultisessionFuture’ ... done
[16:22:09.369] getGlobalsAndPackages() ...
[16:22:09.369] Searching for globals...
[16:22:09.369] - globals found: [1] ‘{’
[16:22:09.369] Searching for globals ... DONE
[16:22:09.370] Resolving globals: FALSE
[16:22:09.370] 
[16:22:09.370] 
[16:22:09.370] getGlobalsAndPackages() ... DONE
[16:22:09.370] run() for ‘Future’ ...
[16:22:09.370] - state: ‘created’
[16:22:09.370] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.394]   - Field: ‘node’
[16:22:09.394]   - Field: ‘label’
[16:22:09.394]   - Field: ‘local’
[16:22:09.394]   - Field: ‘owner’
[16:22:09.394]   - Field: ‘envir’
[16:22:09.394]   - Field: ‘workers’
[16:22:09.394]   - Field: ‘packages’
[16:22:09.395]   - Field: ‘gc’
[16:22:09.395]   - Field: ‘conditions’
[16:22:09.395]   - Field: ‘persistent’
[16:22:09.395]   - Field: ‘expr’
[16:22:09.395]   - Field: ‘uuid’
[16:22:09.395]   - Field: ‘seed’
[16:22:09.395]   - Field: ‘version’
[16:22:09.395]   - Field: ‘result’
[16:22:09.395]   - Field: ‘asynchronous’
[16:22:09.395]   - Field: ‘calls’
[16:22:09.395]   - Field: ‘globals’
[16:22:09.396]   - Field: ‘stdout’
[16:22:09.396]   - Field: ‘earlySignal’
[16:22:09.396]   - Field: ‘lazy’
[16:22:09.396]   - Field: ‘state’
[16:22:09.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.396] - Launch lazy future ...
[16:22:09.396] Packages needed by the future expression (n = 0): <none>
[16:22:09.396] Packages needed by future strategies (n = 0): <none>
[16:22:09.397] {
[16:22:09.397]     {
[16:22:09.397]         {
[16:22:09.397]             ...future.startTime <- base::Sys.time()
[16:22:09.397]             {
[16:22:09.397]                 {
[16:22:09.397]                   {
[16:22:09.397]                     {
[16:22:09.397]                       base::local({
[16:22:09.397]                         has_future <- base::requireNamespace("future", 
[16:22:09.397]                           quietly = TRUE)
[16:22:09.397]                         if (has_future) {
[16:22:09.397]                           ns <- base::getNamespace("future")
[16:22:09.397]                           version <- ns[[".package"]][["version"]]
[16:22:09.397]                           if (is.null(version)) 
[16:22:09.397]                             version <- utils::packageVersion("future")
[16:22:09.397]                         }
[16:22:09.397]                         else {
[16:22:09.397]                           version <- NULL
[16:22:09.397]                         }
[16:22:09.397]                         if (!has_future || version < "1.8.0") {
[16:22:09.397]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.397]                             "", base::R.version$version.string), 
[16:22:09.397]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.397]                               "release", "version")], collapse = " "), 
[16:22:09.397]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.397]                             info)
[16:22:09.397]                           info <- base::paste(info, collapse = "; ")
[16:22:09.397]                           if (!has_future) {
[16:22:09.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.397]                               info)
[16:22:09.397]                           }
[16:22:09.397]                           else {
[16:22:09.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.397]                               info, version)
[16:22:09.397]                           }
[16:22:09.397]                           base::stop(msg)
[16:22:09.397]                         }
[16:22:09.397]                       })
[16:22:09.397]                     }
[16:22:09.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.397]                     base::options(mc.cores = 1L)
[16:22:09.397]                   }
[16:22:09.397]                   ...future.strategy.old <- future::plan("list")
[16:22:09.397]                   options(future.plan = NULL)
[16:22:09.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.397]                 }
[16:22:09.397]                 ...future.workdir <- getwd()
[16:22:09.397]             }
[16:22:09.397]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.397]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.397]         }
[16:22:09.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.397]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.397]             base::names(...future.oldOptions))
[16:22:09.397]     }
[16:22:09.397]     if (FALSE) {
[16:22:09.397]     }
[16:22:09.397]     else {
[16:22:09.397]         if (TRUE) {
[16:22:09.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.397]                 open = "w")
[16:22:09.397]         }
[16:22:09.397]         else {
[16:22:09.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.397]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.397]         }
[16:22:09.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.397]             base::sink(type = "output", split = FALSE)
[16:22:09.397]             base::close(...future.stdout)
[16:22:09.397]         }, add = TRUE)
[16:22:09.397]     }
[16:22:09.397]     ...future.frame <- base::sys.nframe()
[16:22:09.397]     ...future.conditions <- base::list()
[16:22:09.397]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.397]     if (FALSE) {
[16:22:09.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.397]     }
[16:22:09.397]     ...future.result <- base::tryCatch({
[16:22:09.397]         base::withCallingHandlers({
[16:22:09.397]             ...future.value <- base::withVisible(base::local({
[16:22:09.397]                 ...future.makeSendCondition <- base::local({
[16:22:09.397]                   sendCondition <- NULL
[16:22:09.397]                   function(frame = 1L) {
[16:22:09.397]                     if (is.function(sendCondition)) 
[16:22:09.397]                       return(sendCondition)
[16:22:09.397]                     ns <- getNamespace("parallel")
[16:22:09.397]                     if (exists("sendData", mode = "function", 
[16:22:09.397]                       envir = ns)) {
[16:22:09.397]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.397]                         envir = ns)
[16:22:09.397]                       envir <- sys.frame(frame)
[16:22:09.397]                       master <- NULL
[16:22:09.397]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.397]                         !identical(envir, emptyenv())) {
[16:22:09.397]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.397]                           inherits = FALSE)) {
[16:22:09.397]                           master <- get("master", mode = "list", 
[16:22:09.397]                             envir = envir, inherits = FALSE)
[16:22:09.397]                           if (inherits(master, c("SOCKnode", 
[16:22:09.397]                             "SOCK0node"))) {
[16:22:09.397]                             sendCondition <<- function(cond) {
[16:22:09.397]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.397]                                 success = TRUE)
[16:22:09.397]                               parallel_sendData(master, data)
[16:22:09.397]                             }
[16:22:09.397]                             return(sendCondition)
[16:22:09.397]                           }
[16:22:09.397]                         }
[16:22:09.397]                         frame <- frame + 1L
[16:22:09.397]                         envir <- sys.frame(frame)
[16:22:09.397]                       }
[16:22:09.397]                     }
[16:22:09.397]                     sendCondition <<- function(cond) NULL
[16:22:09.397]                   }
[16:22:09.397]                 })
[16:22:09.397]                 withCallingHandlers({
[16:22:09.397]                   {
[16:22:09.397]                     2
[16:22:09.397]                   }
[16:22:09.397]                 }, immediateCondition = function(cond) {
[16:22:09.397]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.397]                   sendCondition(cond)
[16:22:09.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.397]                   {
[16:22:09.397]                     inherits <- base::inherits
[16:22:09.397]                     invokeRestart <- base::invokeRestart
[16:22:09.397]                     is.null <- base::is.null
[16:22:09.397]                     muffled <- FALSE
[16:22:09.397]                     if (inherits(cond, "message")) {
[16:22:09.397]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.397]                       if (muffled) 
[16:22:09.397]                         invokeRestart("muffleMessage")
[16:22:09.397]                     }
[16:22:09.397]                     else if (inherits(cond, "warning")) {
[16:22:09.397]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.397]                       if (muffled) 
[16:22:09.397]                         invokeRestart("muffleWarning")
[16:22:09.397]                     }
[16:22:09.397]                     else if (inherits(cond, "condition")) {
[16:22:09.397]                       if (!is.null(pattern)) {
[16:22:09.397]                         computeRestarts <- base::computeRestarts
[16:22:09.397]                         grepl <- base::grepl
[16:22:09.397]                         restarts <- computeRestarts(cond)
[16:22:09.397]                         for (restart in restarts) {
[16:22:09.397]                           name <- restart$name
[16:22:09.397]                           if (is.null(name)) 
[16:22:09.397]                             next
[16:22:09.397]                           if (!grepl(pattern, name)) 
[16:22:09.397]                             next
[16:22:09.397]                           invokeRestart(restart)
[16:22:09.397]                           muffled <- TRUE
[16:22:09.397]                           break
[16:22:09.397]                         }
[16:22:09.397]                       }
[16:22:09.397]                     }
[16:22:09.397]                     invisible(muffled)
[16:22:09.397]                   }
[16:22:09.397]                   muffleCondition(cond)
[16:22:09.397]                 })
[16:22:09.397]             }))
[16:22:09.397]             future::FutureResult(value = ...future.value$value, 
[16:22:09.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.397]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.397]                     ...future.globalenv.names))
[16:22:09.397]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.397]         }, condition = base::local({
[16:22:09.397]             c <- base::c
[16:22:09.397]             inherits <- base::inherits
[16:22:09.397]             invokeRestart <- base::invokeRestart
[16:22:09.397]             length <- base::length
[16:22:09.397]             list <- base::list
[16:22:09.397]             seq.int <- base::seq.int
[16:22:09.397]             signalCondition <- base::signalCondition
[16:22:09.397]             sys.calls <- base::sys.calls
[16:22:09.397]             `[[` <- base::`[[`
[16:22:09.397]             `+` <- base::`+`
[16:22:09.397]             `<<-` <- base::`<<-`
[16:22:09.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.397]                   3L)]
[16:22:09.397]             }
[16:22:09.397]             function(cond) {
[16:22:09.397]                 is_error <- inherits(cond, "error")
[16:22:09.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.397]                   NULL)
[16:22:09.397]                 if (is_error) {
[16:22:09.397]                   sessionInformation <- function() {
[16:22:09.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.397]                       search = base::search(), system = base::Sys.info())
[16:22:09.397]                   }
[16:22:09.397]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.397]                     cond$call), session = sessionInformation(), 
[16:22:09.397]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.397]                   signalCondition(cond)
[16:22:09.397]                 }
[16:22:09.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.397]                 "immediateCondition"))) {
[16:22:09.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.397]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.397]                   if (TRUE && !signal) {
[16:22:09.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.397]                     {
[16:22:09.397]                       inherits <- base::inherits
[16:22:09.397]                       invokeRestart <- base::invokeRestart
[16:22:09.397]                       is.null <- base::is.null
[16:22:09.397]                       muffled <- FALSE
[16:22:09.397]                       if (inherits(cond, "message")) {
[16:22:09.397]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.397]                         if (muffled) 
[16:22:09.397]                           invokeRestart("muffleMessage")
[16:22:09.397]                       }
[16:22:09.397]                       else if (inherits(cond, "warning")) {
[16:22:09.397]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.397]                         if (muffled) 
[16:22:09.397]                           invokeRestart("muffleWarning")
[16:22:09.397]                       }
[16:22:09.397]                       else if (inherits(cond, "condition")) {
[16:22:09.397]                         if (!is.null(pattern)) {
[16:22:09.397]                           computeRestarts <- base::computeRestarts
[16:22:09.397]                           grepl <- base::grepl
[16:22:09.397]                           restarts <- computeRestarts(cond)
[16:22:09.397]                           for (restart in restarts) {
[16:22:09.397]                             name <- restart$name
[16:22:09.397]                             if (is.null(name)) 
[16:22:09.397]                               next
[16:22:09.397]                             if (!grepl(pattern, name)) 
[16:22:09.397]                               next
[16:22:09.397]                             invokeRestart(restart)
[16:22:09.397]                             muffled <- TRUE
[16:22:09.397]                             break
[16:22:09.397]                           }
[16:22:09.397]                         }
[16:22:09.397]                       }
[16:22:09.397]                       invisible(muffled)
[16:22:09.397]                     }
[16:22:09.397]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.397]                   }
[16:22:09.397]                 }
[16:22:09.397]                 else {
[16:22:09.397]                   if (TRUE) {
[16:22:09.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.397]                     {
[16:22:09.397]                       inherits <- base::inherits
[16:22:09.397]                       invokeRestart <- base::invokeRestart
[16:22:09.397]                       is.null <- base::is.null
[16:22:09.397]                       muffled <- FALSE
[16:22:09.397]                       if (inherits(cond, "message")) {
[16:22:09.397]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.397]                         if (muffled) 
[16:22:09.397]                           invokeRestart("muffleMessage")
[16:22:09.397]                       }
[16:22:09.397]                       else if (inherits(cond, "warning")) {
[16:22:09.397]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.397]                         if (muffled) 
[16:22:09.397]                           invokeRestart("muffleWarning")
[16:22:09.397]                       }
[16:22:09.397]                       else if (inherits(cond, "condition")) {
[16:22:09.397]                         if (!is.null(pattern)) {
[16:22:09.397]                           computeRestarts <- base::computeRestarts
[16:22:09.397]                           grepl <- base::grepl
[16:22:09.397]                           restarts <- computeRestarts(cond)
[16:22:09.397]                           for (restart in restarts) {
[16:22:09.397]                             name <- restart$name
[16:22:09.397]                             if (is.null(name)) 
[16:22:09.397]                               next
[16:22:09.397]                             if (!grepl(pattern, name)) 
[16:22:09.397]                               next
[16:22:09.397]                             invokeRestart(restart)
[16:22:09.397]                             muffled <- TRUE
[16:22:09.397]                             break
[16:22:09.397]                           }
[16:22:09.397]                         }
[16:22:09.397]                       }
[16:22:09.397]                       invisible(muffled)
[16:22:09.397]                     }
[16:22:09.397]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.397]                   }
[16:22:09.397]                 }
[16:22:09.397]             }
[16:22:09.397]         }))
[16:22:09.397]     }, error = function(ex) {
[16:22:09.397]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.397]                 ...future.rng), started = ...future.startTime, 
[16:22:09.397]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.397]             version = "1.8"), class = "FutureResult")
[16:22:09.397]     }, finally = {
[16:22:09.397]         if (!identical(...future.workdir, getwd())) 
[16:22:09.397]             setwd(...future.workdir)
[16:22:09.397]         {
[16:22:09.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.397]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.397]             }
[16:22:09.397]             base::options(...future.oldOptions)
[16:22:09.397]             if (.Platform$OS.type == "windows") {
[16:22:09.397]                 old_names <- names(...future.oldEnvVars)
[16:22:09.397]                 envs <- base::Sys.getenv()
[16:22:09.397]                 names <- names(envs)
[16:22:09.397]                 common <- intersect(names, old_names)
[16:22:09.397]                 added <- setdiff(names, old_names)
[16:22:09.397]                 removed <- setdiff(old_names, names)
[16:22:09.397]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.397]                   envs[common]]
[16:22:09.397]                 NAMES <- toupper(changed)
[16:22:09.397]                 args <- list()
[16:22:09.397]                 for (kk in seq_along(NAMES)) {
[16:22:09.397]                   name <- changed[[kk]]
[16:22:09.397]                   NAME <- NAMES[[kk]]
[16:22:09.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.397]                     next
[16:22:09.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.397]                 }
[16:22:09.397]                 NAMES <- toupper(added)
[16:22:09.397]                 for (kk in seq_along(NAMES)) {
[16:22:09.397]                   name <- added[[kk]]
[16:22:09.397]                   NAME <- NAMES[[kk]]
[16:22:09.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.397]                     next
[16:22:09.397]                   args[[name]] <- ""
[16:22:09.397]                 }
[16:22:09.397]                 NAMES <- toupper(removed)
[16:22:09.397]                 for (kk in seq_along(NAMES)) {
[16:22:09.397]                   name <- removed[[kk]]
[16:22:09.397]                   NAME <- NAMES[[kk]]
[16:22:09.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.397]                     next
[16:22:09.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.397]                 }
[16:22:09.397]                 if (length(args) > 0) 
[16:22:09.397]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.397]             }
[16:22:09.397]             else {
[16:22:09.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.397]             }
[16:22:09.397]             {
[16:22:09.397]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.397]                   0L) {
[16:22:09.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.397]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.397]                   base::options(opts)
[16:22:09.397]                 }
[16:22:09.397]                 {
[16:22:09.397]                   {
[16:22:09.397]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.397]                     NULL
[16:22:09.397]                   }
[16:22:09.397]                   options(future.plan = NULL)
[16:22:09.397]                   if (is.na(NA_character_)) 
[16:22:09.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.397]                     .init = FALSE)
[16:22:09.397]                 }
[16:22:09.397]             }
[16:22:09.397]         }
[16:22:09.397]     })
[16:22:09.397]     if (TRUE) {
[16:22:09.397]         base::sink(type = "output", split = FALSE)
[16:22:09.397]         if (TRUE) {
[16:22:09.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.397]         }
[16:22:09.397]         else {
[16:22:09.397]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.397]         }
[16:22:09.397]         base::close(...future.stdout)
[16:22:09.397]         ...future.stdout <- NULL
[16:22:09.397]     }
[16:22:09.397]     ...future.result$conditions <- ...future.conditions
[16:22:09.397]     ...future.result$finished <- base::Sys.time()
[16:22:09.397]     ...future.result
[16:22:09.397] }
[16:22:09.400] MultisessionFuture started
[16:22:09.400] - Launch lazy future ... done
[16:22:09.400] run() for ‘MultisessionFuture’ ... done
[16:22:09.401] resolve() on environment ...
[16:22:09.401]  recursive: 0
[16:22:09.402]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:22:09.402] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.402] - Validating connection of MultisessionFuture
[16:22:09.403] - received message: FutureResult
[16:22:09.403] - Received FutureResult
[16:22:09.403] - Erased future from FutureRegistry
[16:22:09.403] result() for ClusterFuture ...
[16:22:09.403] - result already collected: FutureResult
[16:22:09.403] result() for ClusterFuture ... done
[16:22:09.403] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.403] Future #1
[16:22:09.403]  length: 2 (resolved future 1)
[16:22:09.404] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.404] - Validating connection of MultisessionFuture
[16:22:09.404] - received message: FutureResult
[16:22:09.404] - Received FutureResult
[16:22:09.404] - Erased future from FutureRegistry
[16:22:09.404] result() for ClusterFuture ...
[16:22:09.405] - result already collected: FutureResult
[16:22:09.405] result() for ClusterFuture ... done
[16:22:09.405] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.405] Future #2
[16:22:09.405]  length: 1 (resolved future 2)
[16:22:09.405]  length: 0 (resolved future 3)
[16:22:09.405] resolve() on environment ... DONE
[16:22:09.406] getGlobalsAndPackages() ...
[16:22:09.406] Searching for globals...
[16:22:09.406] - globals found: [1] ‘{’
[16:22:09.406] Searching for globals ... DONE
[16:22:09.406] Resolving globals: FALSE
[16:22:09.407] 
[16:22:09.407] 
[16:22:09.407] getGlobalsAndPackages() ... DONE
[16:22:09.407] run() for ‘Future’ ...
[16:22:09.407] - state: ‘created’
[16:22:09.407] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.421] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.421]   - Field: ‘node’
[16:22:09.421]   - Field: ‘label’
[16:22:09.421]   - Field: ‘local’
[16:22:09.422]   - Field: ‘owner’
[16:22:09.422]   - Field: ‘envir’
[16:22:09.422]   - Field: ‘workers’
[16:22:09.422]   - Field: ‘packages’
[16:22:09.422]   - Field: ‘gc’
[16:22:09.422]   - Field: ‘conditions’
[16:22:09.422]   - Field: ‘persistent’
[16:22:09.422]   - Field: ‘expr’
[16:22:09.422]   - Field: ‘uuid’
[16:22:09.422]   - Field: ‘seed’
[16:22:09.422]   - Field: ‘version’
[16:22:09.423]   - Field: ‘result’
[16:22:09.423]   - Field: ‘asynchronous’
[16:22:09.423]   - Field: ‘calls’
[16:22:09.423]   - Field: ‘globals’
[16:22:09.423]   - Field: ‘stdout’
[16:22:09.423]   - Field: ‘earlySignal’
[16:22:09.423]   - Field: ‘lazy’
[16:22:09.423]   - Field: ‘state’
[16:22:09.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.423] - Launch lazy future ...
[16:22:09.424] Packages needed by the future expression (n = 0): <none>
[16:22:09.424] Packages needed by future strategies (n = 0): <none>
[16:22:09.424] {
[16:22:09.424]     {
[16:22:09.424]         {
[16:22:09.424]             ...future.startTime <- base::Sys.time()
[16:22:09.424]             {
[16:22:09.424]                 {
[16:22:09.424]                   {
[16:22:09.424]                     {
[16:22:09.424]                       base::local({
[16:22:09.424]                         has_future <- base::requireNamespace("future", 
[16:22:09.424]                           quietly = TRUE)
[16:22:09.424]                         if (has_future) {
[16:22:09.424]                           ns <- base::getNamespace("future")
[16:22:09.424]                           version <- ns[[".package"]][["version"]]
[16:22:09.424]                           if (is.null(version)) 
[16:22:09.424]                             version <- utils::packageVersion("future")
[16:22:09.424]                         }
[16:22:09.424]                         else {
[16:22:09.424]                           version <- NULL
[16:22:09.424]                         }
[16:22:09.424]                         if (!has_future || version < "1.8.0") {
[16:22:09.424]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.424]                             "", base::R.version$version.string), 
[16:22:09.424]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.424]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.424]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.424]                               "release", "version")], collapse = " "), 
[16:22:09.424]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.424]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.424]                             info)
[16:22:09.424]                           info <- base::paste(info, collapse = "; ")
[16:22:09.424]                           if (!has_future) {
[16:22:09.424]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.424]                               info)
[16:22:09.424]                           }
[16:22:09.424]                           else {
[16:22:09.424]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.424]                               info, version)
[16:22:09.424]                           }
[16:22:09.424]                           base::stop(msg)
[16:22:09.424]                         }
[16:22:09.424]                       })
[16:22:09.424]                     }
[16:22:09.424]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.424]                     base::options(mc.cores = 1L)
[16:22:09.424]                   }
[16:22:09.424]                   ...future.strategy.old <- future::plan("list")
[16:22:09.424]                   options(future.plan = NULL)
[16:22:09.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.424]                 }
[16:22:09.424]                 ...future.workdir <- getwd()
[16:22:09.424]             }
[16:22:09.424]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.424]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.424]         }
[16:22:09.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.424]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.424]             base::names(...future.oldOptions))
[16:22:09.424]     }
[16:22:09.424]     if (FALSE) {
[16:22:09.424]     }
[16:22:09.424]     else {
[16:22:09.424]         if (TRUE) {
[16:22:09.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.424]                 open = "w")
[16:22:09.424]         }
[16:22:09.424]         else {
[16:22:09.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.424]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.424]         }
[16:22:09.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.424]             base::sink(type = "output", split = FALSE)
[16:22:09.424]             base::close(...future.stdout)
[16:22:09.424]         }, add = TRUE)
[16:22:09.424]     }
[16:22:09.424]     ...future.frame <- base::sys.nframe()
[16:22:09.424]     ...future.conditions <- base::list()
[16:22:09.424]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.424]     if (FALSE) {
[16:22:09.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.424]     }
[16:22:09.424]     ...future.result <- base::tryCatch({
[16:22:09.424]         base::withCallingHandlers({
[16:22:09.424]             ...future.value <- base::withVisible(base::local({
[16:22:09.424]                 ...future.makeSendCondition <- base::local({
[16:22:09.424]                   sendCondition <- NULL
[16:22:09.424]                   function(frame = 1L) {
[16:22:09.424]                     if (is.function(sendCondition)) 
[16:22:09.424]                       return(sendCondition)
[16:22:09.424]                     ns <- getNamespace("parallel")
[16:22:09.424]                     if (exists("sendData", mode = "function", 
[16:22:09.424]                       envir = ns)) {
[16:22:09.424]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.424]                         envir = ns)
[16:22:09.424]                       envir <- sys.frame(frame)
[16:22:09.424]                       master <- NULL
[16:22:09.424]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.424]                         !identical(envir, emptyenv())) {
[16:22:09.424]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.424]                           inherits = FALSE)) {
[16:22:09.424]                           master <- get("master", mode = "list", 
[16:22:09.424]                             envir = envir, inherits = FALSE)
[16:22:09.424]                           if (inherits(master, c("SOCKnode", 
[16:22:09.424]                             "SOCK0node"))) {
[16:22:09.424]                             sendCondition <<- function(cond) {
[16:22:09.424]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.424]                                 success = TRUE)
[16:22:09.424]                               parallel_sendData(master, data)
[16:22:09.424]                             }
[16:22:09.424]                             return(sendCondition)
[16:22:09.424]                           }
[16:22:09.424]                         }
[16:22:09.424]                         frame <- frame + 1L
[16:22:09.424]                         envir <- sys.frame(frame)
[16:22:09.424]                       }
[16:22:09.424]                     }
[16:22:09.424]                     sendCondition <<- function(cond) NULL
[16:22:09.424]                   }
[16:22:09.424]                 })
[16:22:09.424]                 withCallingHandlers({
[16:22:09.424]                   {
[16:22:09.424]                     1
[16:22:09.424]                   }
[16:22:09.424]                 }, immediateCondition = function(cond) {
[16:22:09.424]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.424]                   sendCondition(cond)
[16:22:09.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.424]                   {
[16:22:09.424]                     inherits <- base::inherits
[16:22:09.424]                     invokeRestart <- base::invokeRestart
[16:22:09.424]                     is.null <- base::is.null
[16:22:09.424]                     muffled <- FALSE
[16:22:09.424]                     if (inherits(cond, "message")) {
[16:22:09.424]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.424]                       if (muffled) 
[16:22:09.424]                         invokeRestart("muffleMessage")
[16:22:09.424]                     }
[16:22:09.424]                     else if (inherits(cond, "warning")) {
[16:22:09.424]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.424]                       if (muffled) 
[16:22:09.424]                         invokeRestart("muffleWarning")
[16:22:09.424]                     }
[16:22:09.424]                     else if (inherits(cond, "condition")) {
[16:22:09.424]                       if (!is.null(pattern)) {
[16:22:09.424]                         computeRestarts <- base::computeRestarts
[16:22:09.424]                         grepl <- base::grepl
[16:22:09.424]                         restarts <- computeRestarts(cond)
[16:22:09.424]                         for (restart in restarts) {
[16:22:09.424]                           name <- restart$name
[16:22:09.424]                           if (is.null(name)) 
[16:22:09.424]                             next
[16:22:09.424]                           if (!grepl(pattern, name)) 
[16:22:09.424]                             next
[16:22:09.424]                           invokeRestart(restart)
[16:22:09.424]                           muffled <- TRUE
[16:22:09.424]                           break
[16:22:09.424]                         }
[16:22:09.424]                       }
[16:22:09.424]                     }
[16:22:09.424]                     invisible(muffled)
[16:22:09.424]                   }
[16:22:09.424]                   muffleCondition(cond)
[16:22:09.424]                 })
[16:22:09.424]             }))
[16:22:09.424]             future::FutureResult(value = ...future.value$value, 
[16:22:09.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.424]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.424]                     ...future.globalenv.names))
[16:22:09.424]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.424]         }, condition = base::local({
[16:22:09.424]             c <- base::c
[16:22:09.424]             inherits <- base::inherits
[16:22:09.424]             invokeRestart <- base::invokeRestart
[16:22:09.424]             length <- base::length
[16:22:09.424]             list <- base::list
[16:22:09.424]             seq.int <- base::seq.int
[16:22:09.424]             signalCondition <- base::signalCondition
[16:22:09.424]             sys.calls <- base::sys.calls
[16:22:09.424]             `[[` <- base::`[[`
[16:22:09.424]             `+` <- base::`+`
[16:22:09.424]             `<<-` <- base::`<<-`
[16:22:09.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.424]                   3L)]
[16:22:09.424]             }
[16:22:09.424]             function(cond) {
[16:22:09.424]                 is_error <- inherits(cond, "error")
[16:22:09.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.424]                   NULL)
[16:22:09.424]                 if (is_error) {
[16:22:09.424]                   sessionInformation <- function() {
[16:22:09.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.424]                       search = base::search(), system = base::Sys.info())
[16:22:09.424]                   }
[16:22:09.424]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.424]                     cond$call), session = sessionInformation(), 
[16:22:09.424]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.424]                   signalCondition(cond)
[16:22:09.424]                 }
[16:22:09.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.424]                 "immediateCondition"))) {
[16:22:09.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.424]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.424]                   if (TRUE && !signal) {
[16:22:09.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.424]                     {
[16:22:09.424]                       inherits <- base::inherits
[16:22:09.424]                       invokeRestart <- base::invokeRestart
[16:22:09.424]                       is.null <- base::is.null
[16:22:09.424]                       muffled <- FALSE
[16:22:09.424]                       if (inherits(cond, "message")) {
[16:22:09.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.424]                         if (muffled) 
[16:22:09.424]                           invokeRestart("muffleMessage")
[16:22:09.424]                       }
[16:22:09.424]                       else if (inherits(cond, "warning")) {
[16:22:09.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.424]                         if (muffled) 
[16:22:09.424]                           invokeRestart("muffleWarning")
[16:22:09.424]                       }
[16:22:09.424]                       else if (inherits(cond, "condition")) {
[16:22:09.424]                         if (!is.null(pattern)) {
[16:22:09.424]                           computeRestarts <- base::computeRestarts
[16:22:09.424]                           grepl <- base::grepl
[16:22:09.424]                           restarts <- computeRestarts(cond)
[16:22:09.424]                           for (restart in restarts) {
[16:22:09.424]                             name <- restart$name
[16:22:09.424]                             if (is.null(name)) 
[16:22:09.424]                               next
[16:22:09.424]                             if (!grepl(pattern, name)) 
[16:22:09.424]                               next
[16:22:09.424]                             invokeRestart(restart)
[16:22:09.424]                             muffled <- TRUE
[16:22:09.424]                             break
[16:22:09.424]                           }
[16:22:09.424]                         }
[16:22:09.424]                       }
[16:22:09.424]                       invisible(muffled)
[16:22:09.424]                     }
[16:22:09.424]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.424]                   }
[16:22:09.424]                 }
[16:22:09.424]                 else {
[16:22:09.424]                   if (TRUE) {
[16:22:09.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.424]                     {
[16:22:09.424]                       inherits <- base::inherits
[16:22:09.424]                       invokeRestart <- base::invokeRestart
[16:22:09.424]                       is.null <- base::is.null
[16:22:09.424]                       muffled <- FALSE
[16:22:09.424]                       if (inherits(cond, "message")) {
[16:22:09.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.424]                         if (muffled) 
[16:22:09.424]                           invokeRestart("muffleMessage")
[16:22:09.424]                       }
[16:22:09.424]                       else if (inherits(cond, "warning")) {
[16:22:09.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.424]                         if (muffled) 
[16:22:09.424]                           invokeRestart("muffleWarning")
[16:22:09.424]                       }
[16:22:09.424]                       else if (inherits(cond, "condition")) {
[16:22:09.424]                         if (!is.null(pattern)) {
[16:22:09.424]                           computeRestarts <- base::computeRestarts
[16:22:09.424]                           grepl <- base::grepl
[16:22:09.424]                           restarts <- computeRestarts(cond)
[16:22:09.424]                           for (restart in restarts) {
[16:22:09.424]                             name <- restart$name
[16:22:09.424]                             if (is.null(name)) 
[16:22:09.424]                               next
[16:22:09.424]                             if (!grepl(pattern, name)) 
[16:22:09.424]                               next
[16:22:09.424]                             invokeRestart(restart)
[16:22:09.424]                             muffled <- TRUE
[16:22:09.424]                             break
[16:22:09.424]                           }
[16:22:09.424]                         }
[16:22:09.424]                       }
[16:22:09.424]                       invisible(muffled)
[16:22:09.424]                     }
[16:22:09.424]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.424]                   }
[16:22:09.424]                 }
[16:22:09.424]             }
[16:22:09.424]         }))
[16:22:09.424]     }, error = function(ex) {
[16:22:09.424]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.424]                 ...future.rng), started = ...future.startTime, 
[16:22:09.424]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.424]             version = "1.8"), class = "FutureResult")
[16:22:09.424]     }, finally = {
[16:22:09.424]         if (!identical(...future.workdir, getwd())) 
[16:22:09.424]             setwd(...future.workdir)
[16:22:09.424]         {
[16:22:09.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.424]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.424]             }
[16:22:09.424]             base::options(...future.oldOptions)
[16:22:09.424]             if (.Platform$OS.type == "windows") {
[16:22:09.424]                 old_names <- names(...future.oldEnvVars)
[16:22:09.424]                 envs <- base::Sys.getenv()
[16:22:09.424]                 names <- names(envs)
[16:22:09.424]                 common <- intersect(names, old_names)
[16:22:09.424]                 added <- setdiff(names, old_names)
[16:22:09.424]                 removed <- setdiff(old_names, names)
[16:22:09.424]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.424]                   envs[common]]
[16:22:09.424]                 NAMES <- toupper(changed)
[16:22:09.424]                 args <- list()
[16:22:09.424]                 for (kk in seq_along(NAMES)) {
[16:22:09.424]                   name <- changed[[kk]]
[16:22:09.424]                   NAME <- NAMES[[kk]]
[16:22:09.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.424]                     next
[16:22:09.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.424]                 }
[16:22:09.424]                 NAMES <- toupper(added)
[16:22:09.424]                 for (kk in seq_along(NAMES)) {
[16:22:09.424]                   name <- added[[kk]]
[16:22:09.424]                   NAME <- NAMES[[kk]]
[16:22:09.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.424]                     next
[16:22:09.424]                   args[[name]] <- ""
[16:22:09.424]                 }
[16:22:09.424]                 NAMES <- toupper(removed)
[16:22:09.424]                 for (kk in seq_along(NAMES)) {
[16:22:09.424]                   name <- removed[[kk]]
[16:22:09.424]                   NAME <- NAMES[[kk]]
[16:22:09.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.424]                     next
[16:22:09.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.424]                 }
[16:22:09.424]                 if (length(args) > 0) 
[16:22:09.424]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.424]             }
[16:22:09.424]             else {
[16:22:09.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.424]             }
[16:22:09.424]             {
[16:22:09.424]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.424]                   0L) {
[16:22:09.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.424]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.424]                   base::options(opts)
[16:22:09.424]                 }
[16:22:09.424]                 {
[16:22:09.424]                   {
[16:22:09.424]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.424]                     NULL
[16:22:09.424]                   }
[16:22:09.424]                   options(future.plan = NULL)
[16:22:09.424]                   if (is.na(NA_character_)) 
[16:22:09.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.424]                     .init = FALSE)
[16:22:09.424]                 }
[16:22:09.424]             }
[16:22:09.424]         }
[16:22:09.424]     })
[16:22:09.424]     if (TRUE) {
[16:22:09.424]         base::sink(type = "output", split = FALSE)
[16:22:09.424]         if (TRUE) {
[16:22:09.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.424]         }
[16:22:09.424]         else {
[16:22:09.424]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.424]         }
[16:22:09.424]         base::close(...future.stdout)
[16:22:09.424]         ...future.stdout <- NULL
[16:22:09.424]     }
[16:22:09.424]     ...future.result$conditions <- ...future.conditions
[16:22:09.424]     ...future.result$finished <- base::Sys.time()
[16:22:09.424]     ...future.result
[16:22:09.424] }
[16:22:09.427] MultisessionFuture started
[16:22:09.427] - Launch lazy future ... done
[16:22:09.427] run() for ‘MultisessionFuture’ ... done
[16:22:09.428] getGlobalsAndPackages() ...
[16:22:09.428] Searching for globals...
[16:22:09.428] - globals found: [1] ‘{’
[16:22:09.428] Searching for globals ... DONE
[16:22:09.429] Resolving globals: FALSE
[16:22:09.429] 
[16:22:09.429] 
[16:22:09.429] getGlobalsAndPackages() ... DONE
[16:22:09.429] run() for ‘Future’ ...
[16:22:09.429] - state: ‘created’
[16:22:09.429] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.444] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.444] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.445]   - Field: ‘node’
[16:22:09.445]   - Field: ‘label’
[16:22:09.445]   - Field: ‘local’
[16:22:09.445]   - Field: ‘owner’
[16:22:09.445]   - Field: ‘envir’
[16:22:09.445]   - Field: ‘workers’
[16:22:09.445]   - Field: ‘packages’
[16:22:09.445]   - Field: ‘gc’
[16:22:09.445]   - Field: ‘conditions’
[16:22:09.445]   - Field: ‘persistent’
[16:22:09.446]   - Field: ‘expr’
[16:22:09.446]   - Field: ‘uuid’
[16:22:09.446]   - Field: ‘seed’
[16:22:09.446]   - Field: ‘version’
[16:22:09.446]   - Field: ‘result’
[16:22:09.446]   - Field: ‘asynchronous’
[16:22:09.446]   - Field: ‘calls’
[16:22:09.446]   - Field: ‘globals’
[16:22:09.446]   - Field: ‘stdout’
[16:22:09.446]   - Field: ‘earlySignal’
[16:22:09.446]   - Field: ‘lazy’
[16:22:09.447]   - Field: ‘state’
[16:22:09.447] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.447] - Launch lazy future ...
[16:22:09.447] Packages needed by the future expression (n = 0): <none>
[16:22:09.447] Packages needed by future strategies (n = 0): <none>
[16:22:09.448] {
[16:22:09.448]     {
[16:22:09.448]         {
[16:22:09.448]             ...future.startTime <- base::Sys.time()
[16:22:09.448]             {
[16:22:09.448]                 {
[16:22:09.448]                   {
[16:22:09.448]                     {
[16:22:09.448]                       base::local({
[16:22:09.448]                         has_future <- base::requireNamespace("future", 
[16:22:09.448]                           quietly = TRUE)
[16:22:09.448]                         if (has_future) {
[16:22:09.448]                           ns <- base::getNamespace("future")
[16:22:09.448]                           version <- ns[[".package"]][["version"]]
[16:22:09.448]                           if (is.null(version)) 
[16:22:09.448]                             version <- utils::packageVersion("future")
[16:22:09.448]                         }
[16:22:09.448]                         else {
[16:22:09.448]                           version <- NULL
[16:22:09.448]                         }
[16:22:09.448]                         if (!has_future || version < "1.8.0") {
[16:22:09.448]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.448]                             "", base::R.version$version.string), 
[16:22:09.448]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.448]                               "release", "version")], collapse = " "), 
[16:22:09.448]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.448]                             info)
[16:22:09.448]                           info <- base::paste(info, collapse = "; ")
[16:22:09.448]                           if (!has_future) {
[16:22:09.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.448]                               info)
[16:22:09.448]                           }
[16:22:09.448]                           else {
[16:22:09.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.448]                               info, version)
[16:22:09.448]                           }
[16:22:09.448]                           base::stop(msg)
[16:22:09.448]                         }
[16:22:09.448]                       })
[16:22:09.448]                     }
[16:22:09.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.448]                     base::options(mc.cores = 1L)
[16:22:09.448]                   }
[16:22:09.448]                   ...future.strategy.old <- future::plan("list")
[16:22:09.448]                   options(future.plan = NULL)
[16:22:09.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.448]                 }
[16:22:09.448]                 ...future.workdir <- getwd()
[16:22:09.448]             }
[16:22:09.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.448]         }
[16:22:09.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.448]             base::names(...future.oldOptions))
[16:22:09.448]     }
[16:22:09.448]     if (FALSE) {
[16:22:09.448]     }
[16:22:09.448]     else {
[16:22:09.448]         if (TRUE) {
[16:22:09.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.448]                 open = "w")
[16:22:09.448]         }
[16:22:09.448]         else {
[16:22:09.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.448]         }
[16:22:09.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.448]             base::sink(type = "output", split = FALSE)
[16:22:09.448]             base::close(...future.stdout)
[16:22:09.448]         }, add = TRUE)
[16:22:09.448]     }
[16:22:09.448]     ...future.frame <- base::sys.nframe()
[16:22:09.448]     ...future.conditions <- base::list()
[16:22:09.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.448]     if (FALSE) {
[16:22:09.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.448]     }
[16:22:09.448]     ...future.result <- base::tryCatch({
[16:22:09.448]         base::withCallingHandlers({
[16:22:09.448]             ...future.value <- base::withVisible(base::local({
[16:22:09.448]                 ...future.makeSendCondition <- base::local({
[16:22:09.448]                   sendCondition <- NULL
[16:22:09.448]                   function(frame = 1L) {
[16:22:09.448]                     if (is.function(sendCondition)) 
[16:22:09.448]                       return(sendCondition)
[16:22:09.448]                     ns <- getNamespace("parallel")
[16:22:09.448]                     if (exists("sendData", mode = "function", 
[16:22:09.448]                       envir = ns)) {
[16:22:09.448]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.448]                         envir = ns)
[16:22:09.448]                       envir <- sys.frame(frame)
[16:22:09.448]                       master <- NULL
[16:22:09.448]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.448]                         !identical(envir, emptyenv())) {
[16:22:09.448]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.448]                           inherits = FALSE)) {
[16:22:09.448]                           master <- get("master", mode = "list", 
[16:22:09.448]                             envir = envir, inherits = FALSE)
[16:22:09.448]                           if (inherits(master, c("SOCKnode", 
[16:22:09.448]                             "SOCK0node"))) {
[16:22:09.448]                             sendCondition <<- function(cond) {
[16:22:09.448]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.448]                                 success = TRUE)
[16:22:09.448]                               parallel_sendData(master, data)
[16:22:09.448]                             }
[16:22:09.448]                             return(sendCondition)
[16:22:09.448]                           }
[16:22:09.448]                         }
[16:22:09.448]                         frame <- frame + 1L
[16:22:09.448]                         envir <- sys.frame(frame)
[16:22:09.448]                       }
[16:22:09.448]                     }
[16:22:09.448]                     sendCondition <<- function(cond) NULL
[16:22:09.448]                   }
[16:22:09.448]                 })
[16:22:09.448]                 withCallingHandlers({
[16:22:09.448]                   {
[16:22:09.448]                     2
[16:22:09.448]                   }
[16:22:09.448]                 }, immediateCondition = function(cond) {
[16:22:09.448]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.448]                   sendCondition(cond)
[16:22:09.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.448]                   {
[16:22:09.448]                     inherits <- base::inherits
[16:22:09.448]                     invokeRestart <- base::invokeRestart
[16:22:09.448]                     is.null <- base::is.null
[16:22:09.448]                     muffled <- FALSE
[16:22:09.448]                     if (inherits(cond, "message")) {
[16:22:09.448]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.448]                       if (muffled) 
[16:22:09.448]                         invokeRestart("muffleMessage")
[16:22:09.448]                     }
[16:22:09.448]                     else if (inherits(cond, "warning")) {
[16:22:09.448]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.448]                       if (muffled) 
[16:22:09.448]                         invokeRestart("muffleWarning")
[16:22:09.448]                     }
[16:22:09.448]                     else if (inherits(cond, "condition")) {
[16:22:09.448]                       if (!is.null(pattern)) {
[16:22:09.448]                         computeRestarts <- base::computeRestarts
[16:22:09.448]                         grepl <- base::grepl
[16:22:09.448]                         restarts <- computeRestarts(cond)
[16:22:09.448]                         for (restart in restarts) {
[16:22:09.448]                           name <- restart$name
[16:22:09.448]                           if (is.null(name)) 
[16:22:09.448]                             next
[16:22:09.448]                           if (!grepl(pattern, name)) 
[16:22:09.448]                             next
[16:22:09.448]                           invokeRestart(restart)
[16:22:09.448]                           muffled <- TRUE
[16:22:09.448]                           break
[16:22:09.448]                         }
[16:22:09.448]                       }
[16:22:09.448]                     }
[16:22:09.448]                     invisible(muffled)
[16:22:09.448]                   }
[16:22:09.448]                   muffleCondition(cond)
[16:22:09.448]                 })
[16:22:09.448]             }))
[16:22:09.448]             future::FutureResult(value = ...future.value$value, 
[16:22:09.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.448]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.448]                     ...future.globalenv.names))
[16:22:09.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.448]         }, condition = base::local({
[16:22:09.448]             c <- base::c
[16:22:09.448]             inherits <- base::inherits
[16:22:09.448]             invokeRestart <- base::invokeRestart
[16:22:09.448]             length <- base::length
[16:22:09.448]             list <- base::list
[16:22:09.448]             seq.int <- base::seq.int
[16:22:09.448]             signalCondition <- base::signalCondition
[16:22:09.448]             sys.calls <- base::sys.calls
[16:22:09.448]             `[[` <- base::`[[`
[16:22:09.448]             `+` <- base::`+`
[16:22:09.448]             `<<-` <- base::`<<-`
[16:22:09.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.448]                   3L)]
[16:22:09.448]             }
[16:22:09.448]             function(cond) {
[16:22:09.448]                 is_error <- inherits(cond, "error")
[16:22:09.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.448]                   NULL)
[16:22:09.448]                 if (is_error) {
[16:22:09.448]                   sessionInformation <- function() {
[16:22:09.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.448]                       search = base::search(), system = base::Sys.info())
[16:22:09.448]                   }
[16:22:09.448]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.448]                     cond$call), session = sessionInformation(), 
[16:22:09.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.448]                   signalCondition(cond)
[16:22:09.448]                 }
[16:22:09.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.448]                 "immediateCondition"))) {
[16:22:09.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.448]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.448]                   if (TRUE && !signal) {
[16:22:09.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.448]                     {
[16:22:09.448]                       inherits <- base::inherits
[16:22:09.448]                       invokeRestart <- base::invokeRestart
[16:22:09.448]                       is.null <- base::is.null
[16:22:09.448]                       muffled <- FALSE
[16:22:09.448]                       if (inherits(cond, "message")) {
[16:22:09.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.448]                         if (muffled) 
[16:22:09.448]                           invokeRestart("muffleMessage")
[16:22:09.448]                       }
[16:22:09.448]                       else if (inherits(cond, "warning")) {
[16:22:09.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.448]                         if (muffled) 
[16:22:09.448]                           invokeRestart("muffleWarning")
[16:22:09.448]                       }
[16:22:09.448]                       else if (inherits(cond, "condition")) {
[16:22:09.448]                         if (!is.null(pattern)) {
[16:22:09.448]                           computeRestarts <- base::computeRestarts
[16:22:09.448]                           grepl <- base::grepl
[16:22:09.448]                           restarts <- computeRestarts(cond)
[16:22:09.448]                           for (restart in restarts) {
[16:22:09.448]                             name <- restart$name
[16:22:09.448]                             if (is.null(name)) 
[16:22:09.448]                               next
[16:22:09.448]                             if (!grepl(pattern, name)) 
[16:22:09.448]                               next
[16:22:09.448]                             invokeRestart(restart)
[16:22:09.448]                             muffled <- TRUE
[16:22:09.448]                             break
[16:22:09.448]                           }
[16:22:09.448]                         }
[16:22:09.448]                       }
[16:22:09.448]                       invisible(muffled)
[16:22:09.448]                     }
[16:22:09.448]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.448]                   }
[16:22:09.448]                 }
[16:22:09.448]                 else {
[16:22:09.448]                   if (TRUE) {
[16:22:09.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.448]                     {
[16:22:09.448]                       inherits <- base::inherits
[16:22:09.448]                       invokeRestart <- base::invokeRestart
[16:22:09.448]                       is.null <- base::is.null
[16:22:09.448]                       muffled <- FALSE
[16:22:09.448]                       if (inherits(cond, "message")) {
[16:22:09.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.448]                         if (muffled) 
[16:22:09.448]                           invokeRestart("muffleMessage")
[16:22:09.448]                       }
[16:22:09.448]                       else if (inherits(cond, "warning")) {
[16:22:09.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.448]                         if (muffled) 
[16:22:09.448]                           invokeRestart("muffleWarning")
[16:22:09.448]                       }
[16:22:09.448]                       else if (inherits(cond, "condition")) {
[16:22:09.448]                         if (!is.null(pattern)) {
[16:22:09.448]                           computeRestarts <- base::computeRestarts
[16:22:09.448]                           grepl <- base::grepl
[16:22:09.448]                           restarts <- computeRestarts(cond)
[16:22:09.448]                           for (restart in restarts) {
[16:22:09.448]                             name <- restart$name
[16:22:09.448]                             if (is.null(name)) 
[16:22:09.448]                               next
[16:22:09.448]                             if (!grepl(pattern, name)) 
[16:22:09.448]                               next
[16:22:09.448]                             invokeRestart(restart)
[16:22:09.448]                             muffled <- TRUE
[16:22:09.448]                             break
[16:22:09.448]                           }
[16:22:09.448]                         }
[16:22:09.448]                       }
[16:22:09.448]                       invisible(muffled)
[16:22:09.448]                     }
[16:22:09.448]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.448]                   }
[16:22:09.448]                 }
[16:22:09.448]             }
[16:22:09.448]         }))
[16:22:09.448]     }, error = function(ex) {
[16:22:09.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.448]                 ...future.rng), started = ...future.startTime, 
[16:22:09.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.448]             version = "1.8"), class = "FutureResult")
[16:22:09.448]     }, finally = {
[16:22:09.448]         if (!identical(...future.workdir, getwd())) 
[16:22:09.448]             setwd(...future.workdir)
[16:22:09.448]         {
[16:22:09.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.448]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.448]             }
[16:22:09.448]             base::options(...future.oldOptions)
[16:22:09.448]             if (.Platform$OS.type == "windows") {
[16:22:09.448]                 old_names <- names(...future.oldEnvVars)
[16:22:09.448]                 envs <- base::Sys.getenv()
[16:22:09.448]                 names <- names(envs)
[16:22:09.448]                 common <- intersect(names, old_names)
[16:22:09.448]                 added <- setdiff(names, old_names)
[16:22:09.448]                 removed <- setdiff(old_names, names)
[16:22:09.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.448]                   envs[common]]
[16:22:09.448]                 NAMES <- toupper(changed)
[16:22:09.448]                 args <- list()
[16:22:09.448]                 for (kk in seq_along(NAMES)) {
[16:22:09.448]                   name <- changed[[kk]]
[16:22:09.448]                   NAME <- NAMES[[kk]]
[16:22:09.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.448]                     next
[16:22:09.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.448]                 }
[16:22:09.448]                 NAMES <- toupper(added)
[16:22:09.448]                 for (kk in seq_along(NAMES)) {
[16:22:09.448]                   name <- added[[kk]]
[16:22:09.448]                   NAME <- NAMES[[kk]]
[16:22:09.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.448]                     next
[16:22:09.448]                   args[[name]] <- ""
[16:22:09.448]                 }
[16:22:09.448]                 NAMES <- toupper(removed)
[16:22:09.448]                 for (kk in seq_along(NAMES)) {
[16:22:09.448]                   name <- removed[[kk]]
[16:22:09.448]                   NAME <- NAMES[[kk]]
[16:22:09.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.448]                     next
[16:22:09.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.448]                 }
[16:22:09.448]                 if (length(args) > 0) 
[16:22:09.448]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.448]             }
[16:22:09.448]             else {
[16:22:09.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.448]             }
[16:22:09.448]             {
[16:22:09.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.448]                   0L) {
[16:22:09.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.448]                   base::options(opts)
[16:22:09.448]                 }
[16:22:09.448]                 {
[16:22:09.448]                   {
[16:22:09.448]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.448]                     NULL
[16:22:09.448]                   }
[16:22:09.448]                   options(future.plan = NULL)
[16:22:09.448]                   if (is.na(NA_character_)) 
[16:22:09.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.448]                     .init = FALSE)
[16:22:09.448]                 }
[16:22:09.448]             }
[16:22:09.448]         }
[16:22:09.448]     })
[16:22:09.448]     if (TRUE) {
[16:22:09.448]         base::sink(type = "output", split = FALSE)
[16:22:09.448]         if (TRUE) {
[16:22:09.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.448]         }
[16:22:09.448]         else {
[16:22:09.448]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.448]         }
[16:22:09.448]         base::close(...future.stdout)
[16:22:09.448]         ...future.stdout <- NULL
[16:22:09.448]     }
[16:22:09.448]     ...future.result$conditions <- ...future.conditions
[16:22:09.448]     ...future.result$finished <- base::Sys.time()
[16:22:09.448]     ...future.result
[16:22:09.448] }
[16:22:09.450] MultisessionFuture started
[16:22:09.451] - Launch lazy future ... done
[16:22:09.451] run() for ‘MultisessionFuture’ ... done
[16:22:09.452] resolve() on environment ...
[16:22:09.452]  recursive: 0
[16:22:09.453]  elements: [3] ‘a’
[16:22:09.453] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.453] - Validating connection of MultisessionFuture
[16:22:09.453] - received message: FutureResult
[16:22:09.454] - Received FutureResult
[16:22:09.454] - Erased future from FutureRegistry
[16:22:09.454] result() for ClusterFuture ...
[16:22:09.454] - result already collected: FutureResult
[16:22:09.454] result() for ClusterFuture ... done
[16:22:09.454] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.454] Future #1
[16:22:09.454]  length: 2 (resolved future 1)
[16:22:09.455] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.455] - Validating connection of MultisessionFuture
[16:22:09.455] - received message: FutureResult
[16:22:09.455] - Received FutureResult
[16:22:09.455] - Erased future from FutureRegistry
[16:22:09.455] result() for ClusterFuture ...
[16:22:09.455] - result already collected: FutureResult
[16:22:09.455] result() for ClusterFuture ... done
[16:22:09.455] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.456] Future #2
[16:22:09.456]  length: 1 (resolved future 2)
[16:22:09.456]  length: 0 (resolved future 3)
[16:22:09.456] resolve() on environment ... DONE
[16:22:09.456] resolve() on environment ...
[16:22:09.456]  recursive: 0
[16:22:09.457]  elements: [3] ‘b’
[16:22:09.457] Future #1
[16:22:09.457]  length: 2 (resolved future 1)
[16:22:09.457] Future #2
[16:22:09.457]  length: 1 (resolved future 2)
[16:22:09.457]  length: 0 (resolved future 3)
[16:22:09.458] resolve() on environment ... DONE
[16:22:09.458] resolve() on environment ...
[16:22:09.458]  recursive: 0
[16:22:09.459]  elements: [3] ‘c’
[16:22:09.459] Future #1
[16:22:09.459]  length: 2 (resolved future 1)
[16:22:09.459] Future #2
[16:22:09.459]  length: 1 (resolved future 2)
[16:22:09.459]  length: 0 (resolved future 3)
[16:22:09.459] resolve() on environment ... DONE
[16:22:09.460] resolve() on environment ...
[16:22:09.460]  recursive: 0
[16:22:09.460]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:22:09.460] Future #1
[16:22:09.460] result() for ClusterFuture ...
[16:22:09.460] - result already collected: FutureResult
[16:22:09.461] result() for ClusterFuture ... done
[16:22:09.461] result() for ClusterFuture ...
[16:22:09.461] - result already collected: FutureResult
[16:22:09.461] result() for ClusterFuture ... done
[16:22:09.461]  length: 2 (resolved future 1)
[16:22:09.461] Future #2
[16:22:09.461] result() for ClusterFuture ...
[16:22:09.461] - result already collected: FutureResult
[16:22:09.461] result() for ClusterFuture ... done
[16:22:09.461] result() for ClusterFuture ...
[16:22:09.461] - result already collected: FutureResult
[16:22:09.462] result() for ClusterFuture ... done
[16:22:09.462]  length: 1 (resolved future 2)
[16:22:09.462]  length: 0 (resolved future 3)
[16:22:09.462] resolve() on environment ... DONE
[16:22:09.462] resolve() on environment ...
[16:22:09.462]  recursive: 99
[16:22:09.463]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:22:09.463] Future #1
[16:22:09.463] result() for ClusterFuture ...
[16:22:09.463] - result already collected: FutureResult
[16:22:09.463] result() for ClusterFuture ... done
[16:22:09.463] result() for ClusterFuture ...
[16:22:09.463] - result already collected: FutureResult
[16:22:09.464] result() for ClusterFuture ... done
[16:22:09.464] A MultisessionFuture was resolved
[16:22:09.464]  length: 2 (resolved future 1)
[16:22:09.464] Future #2
[16:22:09.464] result() for ClusterFuture ...
[16:22:09.464] - result already collected: FutureResult
[16:22:09.464] result() for ClusterFuture ... done
[16:22:09.464] result() for ClusterFuture ...
[16:22:09.464] - result already collected: FutureResult
[16:22:09.464] result() for ClusterFuture ... done
[16:22:09.465] A MultisessionFuture was resolved
[16:22:09.465]  length: 1 (resolved future 2)
[16:22:09.465]  length: 0 (resolved future 3)
[16:22:09.465] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:22:09.466] resolve() on list environment ...
[16:22:09.466]  recursive: 0
[16:22:09.466]  length: 2
[16:22:09.466]  elements: ‘a’, ‘b’
[16:22:09.466]  length: 1 (resolved future 1)
[16:22:09.466]  length: 0 (resolved future 2)
[16:22:09.467] resolve() on list environment ... DONE
[16:22:09.467] getGlobalsAndPackages() ...
[16:22:09.467] Searching for globals...
[16:22:09.467] 
[16:22:09.467] Searching for globals ... DONE
[16:22:09.467] - globals: [0] <none>
[16:22:09.467] getGlobalsAndPackages() ... DONE
[16:22:09.468] run() for ‘Future’ ...
[16:22:09.468] - state: ‘created’
[16:22:09.468] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.481] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.482]   - Field: ‘node’
[16:22:09.482]   - Field: ‘label’
[16:22:09.482]   - Field: ‘local’
[16:22:09.482]   - Field: ‘owner’
[16:22:09.482]   - Field: ‘envir’
[16:22:09.482]   - Field: ‘workers’
[16:22:09.482]   - Field: ‘packages’
[16:22:09.482]   - Field: ‘gc’
[16:22:09.482]   - Field: ‘conditions’
[16:22:09.483]   - Field: ‘persistent’
[16:22:09.483]   - Field: ‘expr’
[16:22:09.483]   - Field: ‘uuid’
[16:22:09.483]   - Field: ‘seed’
[16:22:09.483]   - Field: ‘version’
[16:22:09.483]   - Field: ‘result’
[16:22:09.483]   - Field: ‘asynchronous’
[16:22:09.483]   - Field: ‘calls’
[16:22:09.483]   - Field: ‘globals’
[16:22:09.483]   - Field: ‘stdout’
[16:22:09.483]   - Field: ‘earlySignal’
[16:22:09.484]   - Field: ‘lazy’
[16:22:09.484]   - Field: ‘state’
[16:22:09.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.484] - Launch lazy future ...
[16:22:09.484] Packages needed by the future expression (n = 0): <none>
[16:22:09.484] Packages needed by future strategies (n = 0): <none>
[16:22:09.485] {
[16:22:09.485]     {
[16:22:09.485]         {
[16:22:09.485]             ...future.startTime <- base::Sys.time()
[16:22:09.485]             {
[16:22:09.485]                 {
[16:22:09.485]                   {
[16:22:09.485]                     {
[16:22:09.485]                       base::local({
[16:22:09.485]                         has_future <- base::requireNamespace("future", 
[16:22:09.485]                           quietly = TRUE)
[16:22:09.485]                         if (has_future) {
[16:22:09.485]                           ns <- base::getNamespace("future")
[16:22:09.485]                           version <- ns[[".package"]][["version"]]
[16:22:09.485]                           if (is.null(version)) 
[16:22:09.485]                             version <- utils::packageVersion("future")
[16:22:09.485]                         }
[16:22:09.485]                         else {
[16:22:09.485]                           version <- NULL
[16:22:09.485]                         }
[16:22:09.485]                         if (!has_future || version < "1.8.0") {
[16:22:09.485]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.485]                             "", base::R.version$version.string), 
[16:22:09.485]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.485]                               "release", "version")], collapse = " "), 
[16:22:09.485]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.485]                             info)
[16:22:09.485]                           info <- base::paste(info, collapse = "; ")
[16:22:09.485]                           if (!has_future) {
[16:22:09.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.485]                               info)
[16:22:09.485]                           }
[16:22:09.485]                           else {
[16:22:09.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.485]                               info, version)
[16:22:09.485]                           }
[16:22:09.485]                           base::stop(msg)
[16:22:09.485]                         }
[16:22:09.485]                       })
[16:22:09.485]                     }
[16:22:09.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.485]                     base::options(mc.cores = 1L)
[16:22:09.485]                   }
[16:22:09.485]                   ...future.strategy.old <- future::plan("list")
[16:22:09.485]                   options(future.plan = NULL)
[16:22:09.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.485]                 }
[16:22:09.485]                 ...future.workdir <- getwd()
[16:22:09.485]             }
[16:22:09.485]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.485]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.485]         }
[16:22:09.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.485]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.485]             base::names(...future.oldOptions))
[16:22:09.485]     }
[16:22:09.485]     if (FALSE) {
[16:22:09.485]     }
[16:22:09.485]     else {
[16:22:09.485]         if (TRUE) {
[16:22:09.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.485]                 open = "w")
[16:22:09.485]         }
[16:22:09.485]         else {
[16:22:09.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.485]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.485]         }
[16:22:09.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.485]             base::sink(type = "output", split = FALSE)
[16:22:09.485]             base::close(...future.stdout)
[16:22:09.485]         }, add = TRUE)
[16:22:09.485]     }
[16:22:09.485]     ...future.frame <- base::sys.nframe()
[16:22:09.485]     ...future.conditions <- base::list()
[16:22:09.485]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.485]     if (FALSE) {
[16:22:09.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.485]     }
[16:22:09.485]     ...future.result <- base::tryCatch({
[16:22:09.485]         base::withCallingHandlers({
[16:22:09.485]             ...future.value <- base::withVisible(base::local({
[16:22:09.485]                 ...future.makeSendCondition <- base::local({
[16:22:09.485]                   sendCondition <- NULL
[16:22:09.485]                   function(frame = 1L) {
[16:22:09.485]                     if (is.function(sendCondition)) 
[16:22:09.485]                       return(sendCondition)
[16:22:09.485]                     ns <- getNamespace("parallel")
[16:22:09.485]                     if (exists("sendData", mode = "function", 
[16:22:09.485]                       envir = ns)) {
[16:22:09.485]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.485]                         envir = ns)
[16:22:09.485]                       envir <- sys.frame(frame)
[16:22:09.485]                       master <- NULL
[16:22:09.485]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.485]                         !identical(envir, emptyenv())) {
[16:22:09.485]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.485]                           inherits = FALSE)) {
[16:22:09.485]                           master <- get("master", mode = "list", 
[16:22:09.485]                             envir = envir, inherits = FALSE)
[16:22:09.485]                           if (inherits(master, c("SOCKnode", 
[16:22:09.485]                             "SOCK0node"))) {
[16:22:09.485]                             sendCondition <<- function(cond) {
[16:22:09.485]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.485]                                 success = TRUE)
[16:22:09.485]                               parallel_sendData(master, data)
[16:22:09.485]                             }
[16:22:09.485]                             return(sendCondition)
[16:22:09.485]                           }
[16:22:09.485]                         }
[16:22:09.485]                         frame <- frame + 1L
[16:22:09.485]                         envir <- sys.frame(frame)
[16:22:09.485]                       }
[16:22:09.485]                     }
[16:22:09.485]                     sendCondition <<- function(cond) NULL
[16:22:09.485]                   }
[16:22:09.485]                 })
[16:22:09.485]                 withCallingHandlers({
[16:22:09.485]                   1
[16:22:09.485]                 }, immediateCondition = function(cond) {
[16:22:09.485]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.485]                   sendCondition(cond)
[16:22:09.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.485]                   {
[16:22:09.485]                     inherits <- base::inherits
[16:22:09.485]                     invokeRestart <- base::invokeRestart
[16:22:09.485]                     is.null <- base::is.null
[16:22:09.485]                     muffled <- FALSE
[16:22:09.485]                     if (inherits(cond, "message")) {
[16:22:09.485]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.485]                       if (muffled) 
[16:22:09.485]                         invokeRestart("muffleMessage")
[16:22:09.485]                     }
[16:22:09.485]                     else if (inherits(cond, "warning")) {
[16:22:09.485]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.485]                       if (muffled) 
[16:22:09.485]                         invokeRestart("muffleWarning")
[16:22:09.485]                     }
[16:22:09.485]                     else if (inherits(cond, "condition")) {
[16:22:09.485]                       if (!is.null(pattern)) {
[16:22:09.485]                         computeRestarts <- base::computeRestarts
[16:22:09.485]                         grepl <- base::grepl
[16:22:09.485]                         restarts <- computeRestarts(cond)
[16:22:09.485]                         for (restart in restarts) {
[16:22:09.485]                           name <- restart$name
[16:22:09.485]                           if (is.null(name)) 
[16:22:09.485]                             next
[16:22:09.485]                           if (!grepl(pattern, name)) 
[16:22:09.485]                             next
[16:22:09.485]                           invokeRestart(restart)
[16:22:09.485]                           muffled <- TRUE
[16:22:09.485]                           break
[16:22:09.485]                         }
[16:22:09.485]                       }
[16:22:09.485]                     }
[16:22:09.485]                     invisible(muffled)
[16:22:09.485]                   }
[16:22:09.485]                   muffleCondition(cond)
[16:22:09.485]                 })
[16:22:09.485]             }))
[16:22:09.485]             future::FutureResult(value = ...future.value$value, 
[16:22:09.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.485]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.485]                     ...future.globalenv.names))
[16:22:09.485]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.485]         }, condition = base::local({
[16:22:09.485]             c <- base::c
[16:22:09.485]             inherits <- base::inherits
[16:22:09.485]             invokeRestart <- base::invokeRestart
[16:22:09.485]             length <- base::length
[16:22:09.485]             list <- base::list
[16:22:09.485]             seq.int <- base::seq.int
[16:22:09.485]             signalCondition <- base::signalCondition
[16:22:09.485]             sys.calls <- base::sys.calls
[16:22:09.485]             `[[` <- base::`[[`
[16:22:09.485]             `+` <- base::`+`
[16:22:09.485]             `<<-` <- base::`<<-`
[16:22:09.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.485]                   3L)]
[16:22:09.485]             }
[16:22:09.485]             function(cond) {
[16:22:09.485]                 is_error <- inherits(cond, "error")
[16:22:09.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.485]                   NULL)
[16:22:09.485]                 if (is_error) {
[16:22:09.485]                   sessionInformation <- function() {
[16:22:09.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.485]                       search = base::search(), system = base::Sys.info())
[16:22:09.485]                   }
[16:22:09.485]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.485]                     cond$call), session = sessionInformation(), 
[16:22:09.485]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.485]                   signalCondition(cond)
[16:22:09.485]                 }
[16:22:09.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.485]                 "immediateCondition"))) {
[16:22:09.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.485]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.485]                   if (TRUE && !signal) {
[16:22:09.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.485]                     {
[16:22:09.485]                       inherits <- base::inherits
[16:22:09.485]                       invokeRestart <- base::invokeRestart
[16:22:09.485]                       is.null <- base::is.null
[16:22:09.485]                       muffled <- FALSE
[16:22:09.485]                       if (inherits(cond, "message")) {
[16:22:09.485]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.485]                         if (muffled) 
[16:22:09.485]                           invokeRestart("muffleMessage")
[16:22:09.485]                       }
[16:22:09.485]                       else if (inherits(cond, "warning")) {
[16:22:09.485]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.485]                         if (muffled) 
[16:22:09.485]                           invokeRestart("muffleWarning")
[16:22:09.485]                       }
[16:22:09.485]                       else if (inherits(cond, "condition")) {
[16:22:09.485]                         if (!is.null(pattern)) {
[16:22:09.485]                           computeRestarts <- base::computeRestarts
[16:22:09.485]                           grepl <- base::grepl
[16:22:09.485]                           restarts <- computeRestarts(cond)
[16:22:09.485]                           for (restart in restarts) {
[16:22:09.485]                             name <- restart$name
[16:22:09.485]                             if (is.null(name)) 
[16:22:09.485]                               next
[16:22:09.485]                             if (!grepl(pattern, name)) 
[16:22:09.485]                               next
[16:22:09.485]                             invokeRestart(restart)
[16:22:09.485]                             muffled <- TRUE
[16:22:09.485]                             break
[16:22:09.485]                           }
[16:22:09.485]                         }
[16:22:09.485]                       }
[16:22:09.485]                       invisible(muffled)
[16:22:09.485]                     }
[16:22:09.485]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.485]                   }
[16:22:09.485]                 }
[16:22:09.485]                 else {
[16:22:09.485]                   if (TRUE) {
[16:22:09.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.485]                     {
[16:22:09.485]                       inherits <- base::inherits
[16:22:09.485]                       invokeRestart <- base::invokeRestart
[16:22:09.485]                       is.null <- base::is.null
[16:22:09.485]                       muffled <- FALSE
[16:22:09.485]                       if (inherits(cond, "message")) {
[16:22:09.485]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.485]                         if (muffled) 
[16:22:09.485]                           invokeRestart("muffleMessage")
[16:22:09.485]                       }
[16:22:09.485]                       else if (inherits(cond, "warning")) {
[16:22:09.485]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.485]                         if (muffled) 
[16:22:09.485]                           invokeRestart("muffleWarning")
[16:22:09.485]                       }
[16:22:09.485]                       else if (inherits(cond, "condition")) {
[16:22:09.485]                         if (!is.null(pattern)) {
[16:22:09.485]                           computeRestarts <- base::computeRestarts
[16:22:09.485]                           grepl <- base::grepl
[16:22:09.485]                           restarts <- computeRestarts(cond)
[16:22:09.485]                           for (restart in restarts) {
[16:22:09.485]                             name <- restart$name
[16:22:09.485]                             if (is.null(name)) 
[16:22:09.485]                               next
[16:22:09.485]                             if (!grepl(pattern, name)) 
[16:22:09.485]                               next
[16:22:09.485]                             invokeRestart(restart)
[16:22:09.485]                             muffled <- TRUE
[16:22:09.485]                             break
[16:22:09.485]                           }
[16:22:09.485]                         }
[16:22:09.485]                       }
[16:22:09.485]                       invisible(muffled)
[16:22:09.485]                     }
[16:22:09.485]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.485]                   }
[16:22:09.485]                 }
[16:22:09.485]             }
[16:22:09.485]         }))
[16:22:09.485]     }, error = function(ex) {
[16:22:09.485]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.485]                 ...future.rng), started = ...future.startTime, 
[16:22:09.485]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.485]             version = "1.8"), class = "FutureResult")
[16:22:09.485]     }, finally = {
[16:22:09.485]         if (!identical(...future.workdir, getwd())) 
[16:22:09.485]             setwd(...future.workdir)
[16:22:09.485]         {
[16:22:09.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.485]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.485]             }
[16:22:09.485]             base::options(...future.oldOptions)
[16:22:09.485]             if (.Platform$OS.type == "windows") {
[16:22:09.485]                 old_names <- names(...future.oldEnvVars)
[16:22:09.485]                 envs <- base::Sys.getenv()
[16:22:09.485]                 names <- names(envs)
[16:22:09.485]                 common <- intersect(names, old_names)
[16:22:09.485]                 added <- setdiff(names, old_names)
[16:22:09.485]                 removed <- setdiff(old_names, names)
[16:22:09.485]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.485]                   envs[common]]
[16:22:09.485]                 NAMES <- toupper(changed)
[16:22:09.485]                 args <- list()
[16:22:09.485]                 for (kk in seq_along(NAMES)) {
[16:22:09.485]                   name <- changed[[kk]]
[16:22:09.485]                   NAME <- NAMES[[kk]]
[16:22:09.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.485]                     next
[16:22:09.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.485]                 }
[16:22:09.485]                 NAMES <- toupper(added)
[16:22:09.485]                 for (kk in seq_along(NAMES)) {
[16:22:09.485]                   name <- added[[kk]]
[16:22:09.485]                   NAME <- NAMES[[kk]]
[16:22:09.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.485]                     next
[16:22:09.485]                   args[[name]] <- ""
[16:22:09.485]                 }
[16:22:09.485]                 NAMES <- toupper(removed)
[16:22:09.485]                 for (kk in seq_along(NAMES)) {
[16:22:09.485]                   name <- removed[[kk]]
[16:22:09.485]                   NAME <- NAMES[[kk]]
[16:22:09.485]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.485]                     next
[16:22:09.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.485]                 }
[16:22:09.485]                 if (length(args) > 0) 
[16:22:09.485]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.485]             }
[16:22:09.485]             else {
[16:22:09.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.485]             }
[16:22:09.485]             {
[16:22:09.485]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.485]                   0L) {
[16:22:09.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.485]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.485]                   base::options(opts)
[16:22:09.485]                 }
[16:22:09.485]                 {
[16:22:09.485]                   {
[16:22:09.485]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.485]                     NULL
[16:22:09.485]                   }
[16:22:09.485]                   options(future.plan = NULL)
[16:22:09.485]                   if (is.na(NA_character_)) 
[16:22:09.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.485]                     .init = FALSE)
[16:22:09.485]                 }
[16:22:09.485]             }
[16:22:09.485]         }
[16:22:09.485]     })
[16:22:09.485]     if (TRUE) {
[16:22:09.485]         base::sink(type = "output", split = FALSE)
[16:22:09.485]         if (TRUE) {
[16:22:09.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.485]         }
[16:22:09.485]         else {
[16:22:09.485]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.485]         }
[16:22:09.485]         base::close(...future.stdout)
[16:22:09.485]         ...future.stdout <- NULL
[16:22:09.485]     }
[16:22:09.485]     ...future.result$conditions <- ...future.conditions
[16:22:09.485]     ...future.result$finished <- base::Sys.time()
[16:22:09.485]     ...future.result
[16:22:09.485] }
[16:22:09.487] MultisessionFuture started
[16:22:09.488] - Launch lazy future ... done
[16:22:09.488] run() for ‘MultisessionFuture’ ... done
[16:22:09.488] getGlobalsAndPackages() ...
[16:22:09.488] Searching for globals...
[16:22:09.488] 
[16:22:09.488] Searching for globals ... DONE
[16:22:09.488] - globals: [0] <none>
[16:22:09.489] getGlobalsAndPackages() ... DONE
[16:22:09.489] run() for ‘Future’ ...
[16:22:09.489] - state: ‘created’
[16:22:09.489] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.502] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.502]   - Field: ‘node’
[16:22:09.502]   - Field: ‘label’
[16:22:09.503]   - Field: ‘local’
[16:22:09.503]   - Field: ‘owner’
[16:22:09.503]   - Field: ‘envir’
[16:22:09.503]   - Field: ‘workers’
[16:22:09.503]   - Field: ‘packages’
[16:22:09.503]   - Field: ‘gc’
[16:22:09.503]   - Field: ‘conditions’
[16:22:09.503]   - Field: ‘persistent’
[16:22:09.503]   - Field: ‘expr’
[16:22:09.503]   - Field: ‘uuid’
[16:22:09.504]   - Field: ‘seed’
[16:22:09.504]   - Field: ‘version’
[16:22:09.504]   - Field: ‘result’
[16:22:09.504]   - Field: ‘asynchronous’
[16:22:09.504]   - Field: ‘calls’
[16:22:09.504]   - Field: ‘globals’
[16:22:09.504]   - Field: ‘stdout’
[16:22:09.504]   - Field: ‘earlySignal’
[16:22:09.504]   - Field: ‘lazy’
[16:22:09.504]   - Field: ‘state’
[16:22:09.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.505] - Launch lazy future ...
[16:22:09.505] Packages needed by the future expression (n = 0): <none>
[16:22:09.505] Packages needed by future strategies (n = 0): <none>
[16:22:09.505] {
[16:22:09.505]     {
[16:22:09.505]         {
[16:22:09.505]             ...future.startTime <- base::Sys.time()
[16:22:09.505]             {
[16:22:09.505]                 {
[16:22:09.505]                   {
[16:22:09.505]                     {
[16:22:09.505]                       base::local({
[16:22:09.505]                         has_future <- base::requireNamespace("future", 
[16:22:09.505]                           quietly = TRUE)
[16:22:09.505]                         if (has_future) {
[16:22:09.505]                           ns <- base::getNamespace("future")
[16:22:09.505]                           version <- ns[[".package"]][["version"]]
[16:22:09.505]                           if (is.null(version)) 
[16:22:09.505]                             version <- utils::packageVersion("future")
[16:22:09.505]                         }
[16:22:09.505]                         else {
[16:22:09.505]                           version <- NULL
[16:22:09.505]                         }
[16:22:09.505]                         if (!has_future || version < "1.8.0") {
[16:22:09.505]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.505]                             "", base::R.version$version.string), 
[16:22:09.505]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.505]                               "release", "version")], collapse = " "), 
[16:22:09.505]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.505]                             info)
[16:22:09.505]                           info <- base::paste(info, collapse = "; ")
[16:22:09.505]                           if (!has_future) {
[16:22:09.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.505]                               info)
[16:22:09.505]                           }
[16:22:09.505]                           else {
[16:22:09.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.505]                               info, version)
[16:22:09.505]                           }
[16:22:09.505]                           base::stop(msg)
[16:22:09.505]                         }
[16:22:09.505]                       })
[16:22:09.505]                     }
[16:22:09.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.505]                     base::options(mc.cores = 1L)
[16:22:09.505]                   }
[16:22:09.505]                   ...future.strategy.old <- future::plan("list")
[16:22:09.505]                   options(future.plan = NULL)
[16:22:09.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.505]                 }
[16:22:09.505]                 ...future.workdir <- getwd()
[16:22:09.505]             }
[16:22:09.505]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.505]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.505]         }
[16:22:09.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.505]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.505]             base::names(...future.oldOptions))
[16:22:09.505]     }
[16:22:09.505]     if (FALSE) {
[16:22:09.505]     }
[16:22:09.505]     else {
[16:22:09.505]         if (TRUE) {
[16:22:09.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.505]                 open = "w")
[16:22:09.505]         }
[16:22:09.505]         else {
[16:22:09.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.505]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.505]         }
[16:22:09.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.505]             base::sink(type = "output", split = FALSE)
[16:22:09.505]             base::close(...future.stdout)
[16:22:09.505]         }, add = TRUE)
[16:22:09.505]     }
[16:22:09.505]     ...future.frame <- base::sys.nframe()
[16:22:09.505]     ...future.conditions <- base::list()
[16:22:09.505]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.505]     if (FALSE) {
[16:22:09.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.505]     }
[16:22:09.505]     ...future.result <- base::tryCatch({
[16:22:09.505]         base::withCallingHandlers({
[16:22:09.505]             ...future.value <- base::withVisible(base::local({
[16:22:09.505]                 ...future.makeSendCondition <- base::local({
[16:22:09.505]                   sendCondition <- NULL
[16:22:09.505]                   function(frame = 1L) {
[16:22:09.505]                     if (is.function(sendCondition)) 
[16:22:09.505]                       return(sendCondition)
[16:22:09.505]                     ns <- getNamespace("parallel")
[16:22:09.505]                     if (exists("sendData", mode = "function", 
[16:22:09.505]                       envir = ns)) {
[16:22:09.505]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.505]                         envir = ns)
[16:22:09.505]                       envir <- sys.frame(frame)
[16:22:09.505]                       master <- NULL
[16:22:09.505]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.505]                         !identical(envir, emptyenv())) {
[16:22:09.505]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.505]                           inherits = FALSE)) {
[16:22:09.505]                           master <- get("master", mode = "list", 
[16:22:09.505]                             envir = envir, inherits = FALSE)
[16:22:09.505]                           if (inherits(master, c("SOCKnode", 
[16:22:09.505]                             "SOCK0node"))) {
[16:22:09.505]                             sendCondition <<- function(cond) {
[16:22:09.505]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.505]                                 success = TRUE)
[16:22:09.505]                               parallel_sendData(master, data)
[16:22:09.505]                             }
[16:22:09.505]                             return(sendCondition)
[16:22:09.505]                           }
[16:22:09.505]                         }
[16:22:09.505]                         frame <- frame + 1L
[16:22:09.505]                         envir <- sys.frame(frame)
[16:22:09.505]                       }
[16:22:09.505]                     }
[16:22:09.505]                     sendCondition <<- function(cond) NULL
[16:22:09.505]                   }
[16:22:09.505]                 })
[16:22:09.505]                 withCallingHandlers({
[16:22:09.505]                   2
[16:22:09.505]                 }, immediateCondition = function(cond) {
[16:22:09.505]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.505]                   sendCondition(cond)
[16:22:09.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.505]                   {
[16:22:09.505]                     inherits <- base::inherits
[16:22:09.505]                     invokeRestart <- base::invokeRestart
[16:22:09.505]                     is.null <- base::is.null
[16:22:09.505]                     muffled <- FALSE
[16:22:09.505]                     if (inherits(cond, "message")) {
[16:22:09.505]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.505]                       if (muffled) 
[16:22:09.505]                         invokeRestart("muffleMessage")
[16:22:09.505]                     }
[16:22:09.505]                     else if (inherits(cond, "warning")) {
[16:22:09.505]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.505]                       if (muffled) 
[16:22:09.505]                         invokeRestart("muffleWarning")
[16:22:09.505]                     }
[16:22:09.505]                     else if (inherits(cond, "condition")) {
[16:22:09.505]                       if (!is.null(pattern)) {
[16:22:09.505]                         computeRestarts <- base::computeRestarts
[16:22:09.505]                         grepl <- base::grepl
[16:22:09.505]                         restarts <- computeRestarts(cond)
[16:22:09.505]                         for (restart in restarts) {
[16:22:09.505]                           name <- restart$name
[16:22:09.505]                           if (is.null(name)) 
[16:22:09.505]                             next
[16:22:09.505]                           if (!grepl(pattern, name)) 
[16:22:09.505]                             next
[16:22:09.505]                           invokeRestart(restart)
[16:22:09.505]                           muffled <- TRUE
[16:22:09.505]                           break
[16:22:09.505]                         }
[16:22:09.505]                       }
[16:22:09.505]                     }
[16:22:09.505]                     invisible(muffled)
[16:22:09.505]                   }
[16:22:09.505]                   muffleCondition(cond)
[16:22:09.505]                 })
[16:22:09.505]             }))
[16:22:09.505]             future::FutureResult(value = ...future.value$value, 
[16:22:09.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.505]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.505]                     ...future.globalenv.names))
[16:22:09.505]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.505]         }, condition = base::local({
[16:22:09.505]             c <- base::c
[16:22:09.505]             inherits <- base::inherits
[16:22:09.505]             invokeRestart <- base::invokeRestart
[16:22:09.505]             length <- base::length
[16:22:09.505]             list <- base::list
[16:22:09.505]             seq.int <- base::seq.int
[16:22:09.505]             signalCondition <- base::signalCondition
[16:22:09.505]             sys.calls <- base::sys.calls
[16:22:09.505]             `[[` <- base::`[[`
[16:22:09.505]             `+` <- base::`+`
[16:22:09.505]             `<<-` <- base::`<<-`
[16:22:09.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.505]                   3L)]
[16:22:09.505]             }
[16:22:09.505]             function(cond) {
[16:22:09.505]                 is_error <- inherits(cond, "error")
[16:22:09.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.505]                   NULL)
[16:22:09.505]                 if (is_error) {
[16:22:09.505]                   sessionInformation <- function() {
[16:22:09.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.505]                       search = base::search(), system = base::Sys.info())
[16:22:09.505]                   }
[16:22:09.505]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.505]                     cond$call), session = sessionInformation(), 
[16:22:09.505]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.505]                   signalCondition(cond)
[16:22:09.505]                 }
[16:22:09.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.505]                 "immediateCondition"))) {
[16:22:09.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.505]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.505]                   if (TRUE && !signal) {
[16:22:09.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.505]                     {
[16:22:09.505]                       inherits <- base::inherits
[16:22:09.505]                       invokeRestart <- base::invokeRestart
[16:22:09.505]                       is.null <- base::is.null
[16:22:09.505]                       muffled <- FALSE
[16:22:09.505]                       if (inherits(cond, "message")) {
[16:22:09.505]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.505]                         if (muffled) 
[16:22:09.505]                           invokeRestart("muffleMessage")
[16:22:09.505]                       }
[16:22:09.505]                       else if (inherits(cond, "warning")) {
[16:22:09.505]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.505]                         if (muffled) 
[16:22:09.505]                           invokeRestart("muffleWarning")
[16:22:09.505]                       }
[16:22:09.505]                       else if (inherits(cond, "condition")) {
[16:22:09.505]                         if (!is.null(pattern)) {
[16:22:09.505]                           computeRestarts <- base::computeRestarts
[16:22:09.505]                           grepl <- base::grepl
[16:22:09.505]                           restarts <- computeRestarts(cond)
[16:22:09.505]                           for (restart in restarts) {
[16:22:09.505]                             name <- restart$name
[16:22:09.505]                             if (is.null(name)) 
[16:22:09.505]                               next
[16:22:09.505]                             if (!grepl(pattern, name)) 
[16:22:09.505]                               next
[16:22:09.505]                             invokeRestart(restart)
[16:22:09.505]                             muffled <- TRUE
[16:22:09.505]                             break
[16:22:09.505]                           }
[16:22:09.505]                         }
[16:22:09.505]                       }
[16:22:09.505]                       invisible(muffled)
[16:22:09.505]                     }
[16:22:09.505]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.505]                   }
[16:22:09.505]                 }
[16:22:09.505]                 else {
[16:22:09.505]                   if (TRUE) {
[16:22:09.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.505]                     {
[16:22:09.505]                       inherits <- base::inherits
[16:22:09.505]                       invokeRestart <- base::invokeRestart
[16:22:09.505]                       is.null <- base::is.null
[16:22:09.505]                       muffled <- FALSE
[16:22:09.505]                       if (inherits(cond, "message")) {
[16:22:09.505]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.505]                         if (muffled) 
[16:22:09.505]                           invokeRestart("muffleMessage")
[16:22:09.505]                       }
[16:22:09.505]                       else if (inherits(cond, "warning")) {
[16:22:09.505]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.505]                         if (muffled) 
[16:22:09.505]                           invokeRestart("muffleWarning")
[16:22:09.505]                       }
[16:22:09.505]                       else if (inherits(cond, "condition")) {
[16:22:09.505]                         if (!is.null(pattern)) {
[16:22:09.505]                           computeRestarts <- base::computeRestarts
[16:22:09.505]                           grepl <- base::grepl
[16:22:09.505]                           restarts <- computeRestarts(cond)
[16:22:09.505]                           for (restart in restarts) {
[16:22:09.505]                             name <- restart$name
[16:22:09.505]                             if (is.null(name)) 
[16:22:09.505]                               next
[16:22:09.505]                             if (!grepl(pattern, name)) 
[16:22:09.505]                               next
[16:22:09.505]                             invokeRestart(restart)
[16:22:09.505]                             muffled <- TRUE
[16:22:09.505]                             break
[16:22:09.505]                           }
[16:22:09.505]                         }
[16:22:09.505]                       }
[16:22:09.505]                       invisible(muffled)
[16:22:09.505]                     }
[16:22:09.505]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.505]                   }
[16:22:09.505]                 }
[16:22:09.505]             }
[16:22:09.505]         }))
[16:22:09.505]     }, error = function(ex) {
[16:22:09.505]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.505]                 ...future.rng), started = ...future.startTime, 
[16:22:09.505]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.505]             version = "1.8"), class = "FutureResult")
[16:22:09.505]     }, finally = {
[16:22:09.505]         if (!identical(...future.workdir, getwd())) 
[16:22:09.505]             setwd(...future.workdir)
[16:22:09.505]         {
[16:22:09.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.505]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.505]             }
[16:22:09.505]             base::options(...future.oldOptions)
[16:22:09.505]             if (.Platform$OS.type == "windows") {
[16:22:09.505]                 old_names <- names(...future.oldEnvVars)
[16:22:09.505]                 envs <- base::Sys.getenv()
[16:22:09.505]                 names <- names(envs)
[16:22:09.505]                 common <- intersect(names, old_names)
[16:22:09.505]                 added <- setdiff(names, old_names)
[16:22:09.505]                 removed <- setdiff(old_names, names)
[16:22:09.505]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.505]                   envs[common]]
[16:22:09.505]                 NAMES <- toupper(changed)
[16:22:09.505]                 args <- list()
[16:22:09.505]                 for (kk in seq_along(NAMES)) {
[16:22:09.505]                   name <- changed[[kk]]
[16:22:09.505]                   NAME <- NAMES[[kk]]
[16:22:09.505]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.505]                     next
[16:22:09.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.505]                 }
[16:22:09.505]                 NAMES <- toupper(added)
[16:22:09.505]                 for (kk in seq_along(NAMES)) {
[16:22:09.505]                   name <- added[[kk]]
[16:22:09.505]                   NAME <- NAMES[[kk]]
[16:22:09.505]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.505]                     next
[16:22:09.505]                   args[[name]] <- ""
[16:22:09.505]                 }
[16:22:09.505]                 NAMES <- toupper(removed)
[16:22:09.505]                 for (kk in seq_along(NAMES)) {
[16:22:09.505]                   name <- removed[[kk]]
[16:22:09.505]                   NAME <- NAMES[[kk]]
[16:22:09.505]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.505]                     next
[16:22:09.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.505]                 }
[16:22:09.505]                 if (length(args) > 0) 
[16:22:09.505]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.505]             }
[16:22:09.505]             else {
[16:22:09.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.505]             }
[16:22:09.505]             {
[16:22:09.505]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.505]                   0L) {
[16:22:09.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.505]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.505]                   base::options(opts)
[16:22:09.505]                 }
[16:22:09.505]                 {
[16:22:09.505]                   {
[16:22:09.505]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.505]                     NULL
[16:22:09.505]                   }
[16:22:09.505]                   options(future.plan = NULL)
[16:22:09.505]                   if (is.na(NA_character_)) 
[16:22:09.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.505]                     .init = FALSE)
[16:22:09.505]                 }
[16:22:09.505]             }
[16:22:09.505]         }
[16:22:09.505]     })
[16:22:09.505]     if (TRUE) {
[16:22:09.505]         base::sink(type = "output", split = FALSE)
[16:22:09.505]         if (TRUE) {
[16:22:09.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.505]         }
[16:22:09.505]         else {
[16:22:09.505]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.505]         }
[16:22:09.505]         base::close(...future.stdout)
[16:22:09.505]         ...future.stdout <- NULL
[16:22:09.505]     }
[16:22:09.505]     ...future.result$conditions <- ...future.conditions
[16:22:09.505]     ...future.result$finished <- base::Sys.time()
[16:22:09.505]     ...future.result
[16:22:09.505] }
[16:22:09.508] MultisessionFuture started
[16:22:09.508] - Launch lazy future ... done
[16:22:09.508] run() for ‘MultisessionFuture’ ... done
[16:22:09.509] resolve() on list environment ...
[16:22:09.510]  recursive: 0
[16:22:09.510]  length: 3
[16:22:09.511]  elements: ‘a’, ‘b’, ‘c’
[16:22:09.511] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.511] - Validating connection of MultisessionFuture
[16:22:09.511] - received message: FutureResult
[16:22:09.511] - Received FutureResult
[16:22:09.512] - Erased future from FutureRegistry
[16:22:09.512] result() for ClusterFuture ...
[16:22:09.512] - result already collected: FutureResult
[16:22:09.512] result() for ClusterFuture ... done
[16:22:09.512] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.512] Future #1
[16:22:09.512]  length: 2 (resolved future 1)
[16:22:09.513] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.513] - Validating connection of MultisessionFuture
[16:22:09.513] - received message: FutureResult
[16:22:09.513] - Received FutureResult
[16:22:09.513] - Erased future from FutureRegistry
[16:22:09.513] result() for ClusterFuture ...
[16:22:09.513] - result already collected: FutureResult
[16:22:09.513] result() for ClusterFuture ... done
[16:22:09.513] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.514] Future #2
[16:22:09.514]  length: 1 (resolved future 2)
[16:22:09.514]  length: 0 (resolved future 3)
[16:22:09.514] resolve() on list environment ... DONE
[16:22:09.514] getGlobalsAndPackages() ...
[16:22:09.515] Searching for globals...
[16:22:09.518] - globals found: [1] ‘{’
[16:22:09.518] Searching for globals ... DONE
[16:22:09.519] Resolving globals: FALSE
[16:22:09.519] 
[16:22:09.519] 
[16:22:09.519] getGlobalsAndPackages() ... DONE
[16:22:09.519] run() for ‘Future’ ...
[16:22:09.520] - state: ‘created’
[16:22:09.520] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.534] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.534]   - Field: ‘node’
[16:22:09.534]   - Field: ‘label’
[16:22:09.534]   - Field: ‘local’
[16:22:09.534]   - Field: ‘owner’
[16:22:09.535]   - Field: ‘envir’
[16:22:09.535]   - Field: ‘workers’
[16:22:09.535]   - Field: ‘packages’
[16:22:09.535]   - Field: ‘gc’
[16:22:09.535]   - Field: ‘conditions’
[16:22:09.535]   - Field: ‘persistent’
[16:22:09.535]   - Field: ‘expr’
[16:22:09.535]   - Field: ‘uuid’
[16:22:09.535]   - Field: ‘seed’
[16:22:09.535]   - Field: ‘version’
[16:22:09.535]   - Field: ‘result’
[16:22:09.536]   - Field: ‘asynchronous’
[16:22:09.536]   - Field: ‘calls’
[16:22:09.536]   - Field: ‘globals’
[16:22:09.536]   - Field: ‘stdout’
[16:22:09.536]   - Field: ‘earlySignal’
[16:22:09.536]   - Field: ‘lazy’
[16:22:09.536]   - Field: ‘state’
[16:22:09.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.536] - Launch lazy future ...
[16:22:09.537] Packages needed by the future expression (n = 0): <none>
[16:22:09.537] Packages needed by future strategies (n = 0): <none>
[16:22:09.537] {
[16:22:09.537]     {
[16:22:09.537]         {
[16:22:09.537]             ...future.startTime <- base::Sys.time()
[16:22:09.537]             {
[16:22:09.537]                 {
[16:22:09.537]                   {
[16:22:09.537]                     {
[16:22:09.537]                       base::local({
[16:22:09.537]                         has_future <- base::requireNamespace("future", 
[16:22:09.537]                           quietly = TRUE)
[16:22:09.537]                         if (has_future) {
[16:22:09.537]                           ns <- base::getNamespace("future")
[16:22:09.537]                           version <- ns[[".package"]][["version"]]
[16:22:09.537]                           if (is.null(version)) 
[16:22:09.537]                             version <- utils::packageVersion("future")
[16:22:09.537]                         }
[16:22:09.537]                         else {
[16:22:09.537]                           version <- NULL
[16:22:09.537]                         }
[16:22:09.537]                         if (!has_future || version < "1.8.0") {
[16:22:09.537]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.537]                             "", base::R.version$version.string), 
[16:22:09.537]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.537]                               "release", "version")], collapse = " "), 
[16:22:09.537]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.537]                             info)
[16:22:09.537]                           info <- base::paste(info, collapse = "; ")
[16:22:09.537]                           if (!has_future) {
[16:22:09.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.537]                               info)
[16:22:09.537]                           }
[16:22:09.537]                           else {
[16:22:09.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.537]                               info, version)
[16:22:09.537]                           }
[16:22:09.537]                           base::stop(msg)
[16:22:09.537]                         }
[16:22:09.537]                       })
[16:22:09.537]                     }
[16:22:09.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.537]                     base::options(mc.cores = 1L)
[16:22:09.537]                   }
[16:22:09.537]                   ...future.strategy.old <- future::plan("list")
[16:22:09.537]                   options(future.plan = NULL)
[16:22:09.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.537]                 }
[16:22:09.537]                 ...future.workdir <- getwd()
[16:22:09.537]             }
[16:22:09.537]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.537]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.537]         }
[16:22:09.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.537]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.537]             base::names(...future.oldOptions))
[16:22:09.537]     }
[16:22:09.537]     if (FALSE) {
[16:22:09.537]     }
[16:22:09.537]     else {
[16:22:09.537]         if (TRUE) {
[16:22:09.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.537]                 open = "w")
[16:22:09.537]         }
[16:22:09.537]         else {
[16:22:09.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.537]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.537]         }
[16:22:09.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.537]             base::sink(type = "output", split = FALSE)
[16:22:09.537]             base::close(...future.stdout)
[16:22:09.537]         }, add = TRUE)
[16:22:09.537]     }
[16:22:09.537]     ...future.frame <- base::sys.nframe()
[16:22:09.537]     ...future.conditions <- base::list()
[16:22:09.537]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.537]     if (FALSE) {
[16:22:09.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.537]     }
[16:22:09.537]     ...future.result <- base::tryCatch({
[16:22:09.537]         base::withCallingHandlers({
[16:22:09.537]             ...future.value <- base::withVisible(base::local({
[16:22:09.537]                 ...future.makeSendCondition <- base::local({
[16:22:09.537]                   sendCondition <- NULL
[16:22:09.537]                   function(frame = 1L) {
[16:22:09.537]                     if (is.function(sendCondition)) 
[16:22:09.537]                       return(sendCondition)
[16:22:09.537]                     ns <- getNamespace("parallel")
[16:22:09.537]                     if (exists("sendData", mode = "function", 
[16:22:09.537]                       envir = ns)) {
[16:22:09.537]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.537]                         envir = ns)
[16:22:09.537]                       envir <- sys.frame(frame)
[16:22:09.537]                       master <- NULL
[16:22:09.537]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.537]                         !identical(envir, emptyenv())) {
[16:22:09.537]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.537]                           inherits = FALSE)) {
[16:22:09.537]                           master <- get("master", mode = "list", 
[16:22:09.537]                             envir = envir, inherits = FALSE)
[16:22:09.537]                           if (inherits(master, c("SOCKnode", 
[16:22:09.537]                             "SOCK0node"))) {
[16:22:09.537]                             sendCondition <<- function(cond) {
[16:22:09.537]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.537]                                 success = TRUE)
[16:22:09.537]                               parallel_sendData(master, data)
[16:22:09.537]                             }
[16:22:09.537]                             return(sendCondition)
[16:22:09.537]                           }
[16:22:09.537]                         }
[16:22:09.537]                         frame <- frame + 1L
[16:22:09.537]                         envir <- sys.frame(frame)
[16:22:09.537]                       }
[16:22:09.537]                     }
[16:22:09.537]                     sendCondition <<- function(cond) NULL
[16:22:09.537]                   }
[16:22:09.537]                 })
[16:22:09.537]                 withCallingHandlers({
[16:22:09.537]                   {
[16:22:09.537]                     1
[16:22:09.537]                   }
[16:22:09.537]                 }, immediateCondition = function(cond) {
[16:22:09.537]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.537]                   sendCondition(cond)
[16:22:09.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.537]                   {
[16:22:09.537]                     inherits <- base::inherits
[16:22:09.537]                     invokeRestart <- base::invokeRestart
[16:22:09.537]                     is.null <- base::is.null
[16:22:09.537]                     muffled <- FALSE
[16:22:09.537]                     if (inherits(cond, "message")) {
[16:22:09.537]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.537]                       if (muffled) 
[16:22:09.537]                         invokeRestart("muffleMessage")
[16:22:09.537]                     }
[16:22:09.537]                     else if (inherits(cond, "warning")) {
[16:22:09.537]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.537]                       if (muffled) 
[16:22:09.537]                         invokeRestart("muffleWarning")
[16:22:09.537]                     }
[16:22:09.537]                     else if (inherits(cond, "condition")) {
[16:22:09.537]                       if (!is.null(pattern)) {
[16:22:09.537]                         computeRestarts <- base::computeRestarts
[16:22:09.537]                         grepl <- base::grepl
[16:22:09.537]                         restarts <- computeRestarts(cond)
[16:22:09.537]                         for (restart in restarts) {
[16:22:09.537]                           name <- restart$name
[16:22:09.537]                           if (is.null(name)) 
[16:22:09.537]                             next
[16:22:09.537]                           if (!grepl(pattern, name)) 
[16:22:09.537]                             next
[16:22:09.537]                           invokeRestart(restart)
[16:22:09.537]                           muffled <- TRUE
[16:22:09.537]                           break
[16:22:09.537]                         }
[16:22:09.537]                       }
[16:22:09.537]                     }
[16:22:09.537]                     invisible(muffled)
[16:22:09.537]                   }
[16:22:09.537]                   muffleCondition(cond)
[16:22:09.537]                 })
[16:22:09.537]             }))
[16:22:09.537]             future::FutureResult(value = ...future.value$value, 
[16:22:09.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.537]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.537]                     ...future.globalenv.names))
[16:22:09.537]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.537]         }, condition = base::local({
[16:22:09.537]             c <- base::c
[16:22:09.537]             inherits <- base::inherits
[16:22:09.537]             invokeRestart <- base::invokeRestart
[16:22:09.537]             length <- base::length
[16:22:09.537]             list <- base::list
[16:22:09.537]             seq.int <- base::seq.int
[16:22:09.537]             signalCondition <- base::signalCondition
[16:22:09.537]             sys.calls <- base::sys.calls
[16:22:09.537]             `[[` <- base::`[[`
[16:22:09.537]             `+` <- base::`+`
[16:22:09.537]             `<<-` <- base::`<<-`
[16:22:09.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.537]                   3L)]
[16:22:09.537]             }
[16:22:09.537]             function(cond) {
[16:22:09.537]                 is_error <- inherits(cond, "error")
[16:22:09.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.537]                   NULL)
[16:22:09.537]                 if (is_error) {
[16:22:09.537]                   sessionInformation <- function() {
[16:22:09.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.537]                       search = base::search(), system = base::Sys.info())
[16:22:09.537]                   }
[16:22:09.537]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.537]                     cond$call), session = sessionInformation(), 
[16:22:09.537]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.537]                   signalCondition(cond)
[16:22:09.537]                 }
[16:22:09.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.537]                 "immediateCondition"))) {
[16:22:09.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.537]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.537]                   if (TRUE && !signal) {
[16:22:09.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.537]                     {
[16:22:09.537]                       inherits <- base::inherits
[16:22:09.537]                       invokeRestart <- base::invokeRestart
[16:22:09.537]                       is.null <- base::is.null
[16:22:09.537]                       muffled <- FALSE
[16:22:09.537]                       if (inherits(cond, "message")) {
[16:22:09.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.537]                         if (muffled) 
[16:22:09.537]                           invokeRestart("muffleMessage")
[16:22:09.537]                       }
[16:22:09.537]                       else if (inherits(cond, "warning")) {
[16:22:09.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.537]                         if (muffled) 
[16:22:09.537]                           invokeRestart("muffleWarning")
[16:22:09.537]                       }
[16:22:09.537]                       else if (inherits(cond, "condition")) {
[16:22:09.537]                         if (!is.null(pattern)) {
[16:22:09.537]                           computeRestarts <- base::computeRestarts
[16:22:09.537]                           grepl <- base::grepl
[16:22:09.537]                           restarts <- computeRestarts(cond)
[16:22:09.537]                           for (restart in restarts) {
[16:22:09.537]                             name <- restart$name
[16:22:09.537]                             if (is.null(name)) 
[16:22:09.537]                               next
[16:22:09.537]                             if (!grepl(pattern, name)) 
[16:22:09.537]                               next
[16:22:09.537]                             invokeRestart(restart)
[16:22:09.537]                             muffled <- TRUE
[16:22:09.537]                             break
[16:22:09.537]                           }
[16:22:09.537]                         }
[16:22:09.537]                       }
[16:22:09.537]                       invisible(muffled)
[16:22:09.537]                     }
[16:22:09.537]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.537]                   }
[16:22:09.537]                 }
[16:22:09.537]                 else {
[16:22:09.537]                   if (TRUE) {
[16:22:09.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.537]                     {
[16:22:09.537]                       inherits <- base::inherits
[16:22:09.537]                       invokeRestart <- base::invokeRestart
[16:22:09.537]                       is.null <- base::is.null
[16:22:09.537]                       muffled <- FALSE
[16:22:09.537]                       if (inherits(cond, "message")) {
[16:22:09.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.537]                         if (muffled) 
[16:22:09.537]                           invokeRestart("muffleMessage")
[16:22:09.537]                       }
[16:22:09.537]                       else if (inherits(cond, "warning")) {
[16:22:09.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.537]                         if (muffled) 
[16:22:09.537]                           invokeRestart("muffleWarning")
[16:22:09.537]                       }
[16:22:09.537]                       else if (inherits(cond, "condition")) {
[16:22:09.537]                         if (!is.null(pattern)) {
[16:22:09.537]                           computeRestarts <- base::computeRestarts
[16:22:09.537]                           grepl <- base::grepl
[16:22:09.537]                           restarts <- computeRestarts(cond)
[16:22:09.537]                           for (restart in restarts) {
[16:22:09.537]                             name <- restart$name
[16:22:09.537]                             if (is.null(name)) 
[16:22:09.537]                               next
[16:22:09.537]                             if (!grepl(pattern, name)) 
[16:22:09.537]                               next
[16:22:09.537]                             invokeRestart(restart)
[16:22:09.537]                             muffled <- TRUE
[16:22:09.537]                             break
[16:22:09.537]                           }
[16:22:09.537]                         }
[16:22:09.537]                       }
[16:22:09.537]                       invisible(muffled)
[16:22:09.537]                     }
[16:22:09.537]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.537]                   }
[16:22:09.537]                 }
[16:22:09.537]             }
[16:22:09.537]         }))
[16:22:09.537]     }, error = function(ex) {
[16:22:09.537]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.537]                 ...future.rng), started = ...future.startTime, 
[16:22:09.537]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.537]             version = "1.8"), class = "FutureResult")
[16:22:09.537]     }, finally = {
[16:22:09.537]         if (!identical(...future.workdir, getwd())) 
[16:22:09.537]             setwd(...future.workdir)
[16:22:09.537]         {
[16:22:09.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.537]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.537]             }
[16:22:09.537]             base::options(...future.oldOptions)
[16:22:09.537]             if (.Platform$OS.type == "windows") {
[16:22:09.537]                 old_names <- names(...future.oldEnvVars)
[16:22:09.537]                 envs <- base::Sys.getenv()
[16:22:09.537]                 names <- names(envs)
[16:22:09.537]                 common <- intersect(names, old_names)
[16:22:09.537]                 added <- setdiff(names, old_names)
[16:22:09.537]                 removed <- setdiff(old_names, names)
[16:22:09.537]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.537]                   envs[common]]
[16:22:09.537]                 NAMES <- toupper(changed)
[16:22:09.537]                 args <- list()
[16:22:09.537]                 for (kk in seq_along(NAMES)) {
[16:22:09.537]                   name <- changed[[kk]]
[16:22:09.537]                   NAME <- NAMES[[kk]]
[16:22:09.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.537]                     next
[16:22:09.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.537]                 }
[16:22:09.537]                 NAMES <- toupper(added)
[16:22:09.537]                 for (kk in seq_along(NAMES)) {
[16:22:09.537]                   name <- added[[kk]]
[16:22:09.537]                   NAME <- NAMES[[kk]]
[16:22:09.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.537]                     next
[16:22:09.537]                   args[[name]] <- ""
[16:22:09.537]                 }
[16:22:09.537]                 NAMES <- toupper(removed)
[16:22:09.537]                 for (kk in seq_along(NAMES)) {
[16:22:09.537]                   name <- removed[[kk]]
[16:22:09.537]                   NAME <- NAMES[[kk]]
[16:22:09.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.537]                     next
[16:22:09.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.537]                 }
[16:22:09.537]                 if (length(args) > 0) 
[16:22:09.537]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.537]             }
[16:22:09.537]             else {
[16:22:09.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.537]             }
[16:22:09.537]             {
[16:22:09.537]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.537]                   0L) {
[16:22:09.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.537]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.537]                   base::options(opts)
[16:22:09.537]                 }
[16:22:09.537]                 {
[16:22:09.537]                   {
[16:22:09.537]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.537]                     NULL
[16:22:09.537]                   }
[16:22:09.537]                   options(future.plan = NULL)
[16:22:09.537]                   if (is.na(NA_character_)) 
[16:22:09.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.537]                     .init = FALSE)
[16:22:09.537]                 }
[16:22:09.537]             }
[16:22:09.537]         }
[16:22:09.537]     })
[16:22:09.537]     if (TRUE) {
[16:22:09.537]         base::sink(type = "output", split = FALSE)
[16:22:09.537]         if (TRUE) {
[16:22:09.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.537]         }
[16:22:09.537]         else {
[16:22:09.537]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.537]         }
[16:22:09.537]         base::close(...future.stdout)
[16:22:09.537]         ...future.stdout <- NULL
[16:22:09.537]     }
[16:22:09.537]     ...future.result$conditions <- ...future.conditions
[16:22:09.537]     ...future.result$finished <- base::Sys.time()
[16:22:09.537]     ...future.result
[16:22:09.537] }
[16:22:09.540] MultisessionFuture started
[16:22:09.540] - Launch lazy future ... done
[16:22:09.540] run() for ‘MultisessionFuture’ ... done
[16:22:09.541] getGlobalsAndPackages() ...
[16:22:09.541] Searching for globals...
[16:22:09.541] - globals found: [1] ‘{’
[16:22:09.541] Searching for globals ... DONE
[16:22:09.542] Resolving globals: FALSE
[16:22:09.542] 
[16:22:09.542] 
[16:22:09.542] getGlobalsAndPackages() ... DONE
[16:22:09.542] run() for ‘Future’ ...
[16:22:09.542] - state: ‘created’
[16:22:09.542] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.556] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.556] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.556]   - Field: ‘node’
[16:22:09.556]   - Field: ‘label’
[16:22:09.556]   - Field: ‘local’
[16:22:09.556]   - Field: ‘owner’
[16:22:09.556]   - Field: ‘envir’
[16:22:09.557]   - Field: ‘workers’
[16:22:09.557]   - Field: ‘packages’
[16:22:09.557]   - Field: ‘gc’
[16:22:09.557]   - Field: ‘conditions’
[16:22:09.557]   - Field: ‘persistent’
[16:22:09.557]   - Field: ‘expr’
[16:22:09.557]   - Field: ‘uuid’
[16:22:09.557]   - Field: ‘seed’
[16:22:09.557]   - Field: ‘version’
[16:22:09.557]   - Field: ‘result’
[16:22:09.557]   - Field: ‘asynchronous’
[16:22:09.558]   - Field: ‘calls’
[16:22:09.558]   - Field: ‘globals’
[16:22:09.558]   - Field: ‘stdout’
[16:22:09.558]   - Field: ‘earlySignal’
[16:22:09.558]   - Field: ‘lazy’
[16:22:09.558]   - Field: ‘state’
[16:22:09.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.558] - Launch lazy future ...
[16:22:09.558] Packages needed by the future expression (n = 0): <none>
[16:22:09.559] Packages needed by future strategies (n = 0): <none>
[16:22:09.559] {
[16:22:09.559]     {
[16:22:09.559]         {
[16:22:09.559]             ...future.startTime <- base::Sys.time()
[16:22:09.559]             {
[16:22:09.559]                 {
[16:22:09.559]                   {
[16:22:09.559]                     {
[16:22:09.559]                       base::local({
[16:22:09.559]                         has_future <- base::requireNamespace("future", 
[16:22:09.559]                           quietly = TRUE)
[16:22:09.559]                         if (has_future) {
[16:22:09.559]                           ns <- base::getNamespace("future")
[16:22:09.559]                           version <- ns[[".package"]][["version"]]
[16:22:09.559]                           if (is.null(version)) 
[16:22:09.559]                             version <- utils::packageVersion("future")
[16:22:09.559]                         }
[16:22:09.559]                         else {
[16:22:09.559]                           version <- NULL
[16:22:09.559]                         }
[16:22:09.559]                         if (!has_future || version < "1.8.0") {
[16:22:09.559]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.559]                             "", base::R.version$version.string), 
[16:22:09.559]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.559]                               "release", "version")], collapse = " "), 
[16:22:09.559]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.559]                             info)
[16:22:09.559]                           info <- base::paste(info, collapse = "; ")
[16:22:09.559]                           if (!has_future) {
[16:22:09.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.559]                               info)
[16:22:09.559]                           }
[16:22:09.559]                           else {
[16:22:09.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.559]                               info, version)
[16:22:09.559]                           }
[16:22:09.559]                           base::stop(msg)
[16:22:09.559]                         }
[16:22:09.559]                       })
[16:22:09.559]                     }
[16:22:09.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.559]                     base::options(mc.cores = 1L)
[16:22:09.559]                   }
[16:22:09.559]                   ...future.strategy.old <- future::plan("list")
[16:22:09.559]                   options(future.plan = NULL)
[16:22:09.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.559]                 }
[16:22:09.559]                 ...future.workdir <- getwd()
[16:22:09.559]             }
[16:22:09.559]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.559]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.559]         }
[16:22:09.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.559]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.559]             base::names(...future.oldOptions))
[16:22:09.559]     }
[16:22:09.559]     if (FALSE) {
[16:22:09.559]     }
[16:22:09.559]     else {
[16:22:09.559]         if (TRUE) {
[16:22:09.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.559]                 open = "w")
[16:22:09.559]         }
[16:22:09.559]         else {
[16:22:09.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.559]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.559]         }
[16:22:09.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.559]             base::sink(type = "output", split = FALSE)
[16:22:09.559]             base::close(...future.stdout)
[16:22:09.559]         }, add = TRUE)
[16:22:09.559]     }
[16:22:09.559]     ...future.frame <- base::sys.nframe()
[16:22:09.559]     ...future.conditions <- base::list()
[16:22:09.559]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.559]     if (FALSE) {
[16:22:09.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.559]     }
[16:22:09.559]     ...future.result <- base::tryCatch({
[16:22:09.559]         base::withCallingHandlers({
[16:22:09.559]             ...future.value <- base::withVisible(base::local({
[16:22:09.559]                 ...future.makeSendCondition <- base::local({
[16:22:09.559]                   sendCondition <- NULL
[16:22:09.559]                   function(frame = 1L) {
[16:22:09.559]                     if (is.function(sendCondition)) 
[16:22:09.559]                       return(sendCondition)
[16:22:09.559]                     ns <- getNamespace("parallel")
[16:22:09.559]                     if (exists("sendData", mode = "function", 
[16:22:09.559]                       envir = ns)) {
[16:22:09.559]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.559]                         envir = ns)
[16:22:09.559]                       envir <- sys.frame(frame)
[16:22:09.559]                       master <- NULL
[16:22:09.559]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.559]                         !identical(envir, emptyenv())) {
[16:22:09.559]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.559]                           inherits = FALSE)) {
[16:22:09.559]                           master <- get("master", mode = "list", 
[16:22:09.559]                             envir = envir, inherits = FALSE)
[16:22:09.559]                           if (inherits(master, c("SOCKnode", 
[16:22:09.559]                             "SOCK0node"))) {
[16:22:09.559]                             sendCondition <<- function(cond) {
[16:22:09.559]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.559]                                 success = TRUE)
[16:22:09.559]                               parallel_sendData(master, data)
[16:22:09.559]                             }
[16:22:09.559]                             return(sendCondition)
[16:22:09.559]                           }
[16:22:09.559]                         }
[16:22:09.559]                         frame <- frame + 1L
[16:22:09.559]                         envir <- sys.frame(frame)
[16:22:09.559]                       }
[16:22:09.559]                     }
[16:22:09.559]                     sendCondition <<- function(cond) NULL
[16:22:09.559]                   }
[16:22:09.559]                 })
[16:22:09.559]                 withCallingHandlers({
[16:22:09.559]                   {
[16:22:09.559]                     2
[16:22:09.559]                   }
[16:22:09.559]                 }, immediateCondition = function(cond) {
[16:22:09.559]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.559]                   sendCondition(cond)
[16:22:09.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.559]                   {
[16:22:09.559]                     inherits <- base::inherits
[16:22:09.559]                     invokeRestart <- base::invokeRestart
[16:22:09.559]                     is.null <- base::is.null
[16:22:09.559]                     muffled <- FALSE
[16:22:09.559]                     if (inherits(cond, "message")) {
[16:22:09.559]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.559]                       if (muffled) 
[16:22:09.559]                         invokeRestart("muffleMessage")
[16:22:09.559]                     }
[16:22:09.559]                     else if (inherits(cond, "warning")) {
[16:22:09.559]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.559]                       if (muffled) 
[16:22:09.559]                         invokeRestart("muffleWarning")
[16:22:09.559]                     }
[16:22:09.559]                     else if (inherits(cond, "condition")) {
[16:22:09.559]                       if (!is.null(pattern)) {
[16:22:09.559]                         computeRestarts <- base::computeRestarts
[16:22:09.559]                         grepl <- base::grepl
[16:22:09.559]                         restarts <- computeRestarts(cond)
[16:22:09.559]                         for (restart in restarts) {
[16:22:09.559]                           name <- restart$name
[16:22:09.559]                           if (is.null(name)) 
[16:22:09.559]                             next
[16:22:09.559]                           if (!grepl(pattern, name)) 
[16:22:09.559]                             next
[16:22:09.559]                           invokeRestart(restart)
[16:22:09.559]                           muffled <- TRUE
[16:22:09.559]                           break
[16:22:09.559]                         }
[16:22:09.559]                       }
[16:22:09.559]                     }
[16:22:09.559]                     invisible(muffled)
[16:22:09.559]                   }
[16:22:09.559]                   muffleCondition(cond)
[16:22:09.559]                 })
[16:22:09.559]             }))
[16:22:09.559]             future::FutureResult(value = ...future.value$value, 
[16:22:09.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.559]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.559]                     ...future.globalenv.names))
[16:22:09.559]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.559]         }, condition = base::local({
[16:22:09.559]             c <- base::c
[16:22:09.559]             inherits <- base::inherits
[16:22:09.559]             invokeRestart <- base::invokeRestart
[16:22:09.559]             length <- base::length
[16:22:09.559]             list <- base::list
[16:22:09.559]             seq.int <- base::seq.int
[16:22:09.559]             signalCondition <- base::signalCondition
[16:22:09.559]             sys.calls <- base::sys.calls
[16:22:09.559]             `[[` <- base::`[[`
[16:22:09.559]             `+` <- base::`+`
[16:22:09.559]             `<<-` <- base::`<<-`
[16:22:09.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.559]                   3L)]
[16:22:09.559]             }
[16:22:09.559]             function(cond) {
[16:22:09.559]                 is_error <- inherits(cond, "error")
[16:22:09.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.559]                   NULL)
[16:22:09.559]                 if (is_error) {
[16:22:09.559]                   sessionInformation <- function() {
[16:22:09.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.559]                       search = base::search(), system = base::Sys.info())
[16:22:09.559]                   }
[16:22:09.559]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.559]                     cond$call), session = sessionInformation(), 
[16:22:09.559]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.559]                   signalCondition(cond)
[16:22:09.559]                 }
[16:22:09.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.559]                 "immediateCondition"))) {
[16:22:09.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.559]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.559]                   if (TRUE && !signal) {
[16:22:09.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.559]                     {
[16:22:09.559]                       inherits <- base::inherits
[16:22:09.559]                       invokeRestart <- base::invokeRestart
[16:22:09.559]                       is.null <- base::is.null
[16:22:09.559]                       muffled <- FALSE
[16:22:09.559]                       if (inherits(cond, "message")) {
[16:22:09.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.559]                         if (muffled) 
[16:22:09.559]                           invokeRestart("muffleMessage")
[16:22:09.559]                       }
[16:22:09.559]                       else if (inherits(cond, "warning")) {
[16:22:09.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.559]                         if (muffled) 
[16:22:09.559]                           invokeRestart("muffleWarning")
[16:22:09.559]                       }
[16:22:09.559]                       else if (inherits(cond, "condition")) {
[16:22:09.559]                         if (!is.null(pattern)) {
[16:22:09.559]                           computeRestarts <- base::computeRestarts
[16:22:09.559]                           grepl <- base::grepl
[16:22:09.559]                           restarts <- computeRestarts(cond)
[16:22:09.559]                           for (restart in restarts) {
[16:22:09.559]                             name <- restart$name
[16:22:09.559]                             if (is.null(name)) 
[16:22:09.559]                               next
[16:22:09.559]                             if (!grepl(pattern, name)) 
[16:22:09.559]                               next
[16:22:09.559]                             invokeRestart(restart)
[16:22:09.559]                             muffled <- TRUE
[16:22:09.559]                             break
[16:22:09.559]                           }
[16:22:09.559]                         }
[16:22:09.559]                       }
[16:22:09.559]                       invisible(muffled)
[16:22:09.559]                     }
[16:22:09.559]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.559]                   }
[16:22:09.559]                 }
[16:22:09.559]                 else {
[16:22:09.559]                   if (TRUE) {
[16:22:09.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.559]                     {
[16:22:09.559]                       inherits <- base::inherits
[16:22:09.559]                       invokeRestart <- base::invokeRestart
[16:22:09.559]                       is.null <- base::is.null
[16:22:09.559]                       muffled <- FALSE
[16:22:09.559]                       if (inherits(cond, "message")) {
[16:22:09.559]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.559]                         if (muffled) 
[16:22:09.559]                           invokeRestart("muffleMessage")
[16:22:09.559]                       }
[16:22:09.559]                       else if (inherits(cond, "warning")) {
[16:22:09.559]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.559]                         if (muffled) 
[16:22:09.559]                           invokeRestart("muffleWarning")
[16:22:09.559]                       }
[16:22:09.559]                       else if (inherits(cond, "condition")) {
[16:22:09.559]                         if (!is.null(pattern)) {
[16:22:09.559]                           computeRestarts <- base::computeRestarts
[16:22:09.559]                           grepl <- base::grepl
[16:22:09.559]                           restarts <- computeRestarts(cond)
[16:22:09.559]                           for (restart in restarts) {
[16:22:09.559]                             name <- restart$name
[16:22:09.559]                             if (is.null(name)) 
[16:22:09.559]                               next
[16:22:09.559]                             if (!grepl(pattern, name)) 
[16:22:09.559]                               next
[16:22:09.559]                             invokeRestart(restart)
[16:22:09.559]                             muffled <- TRUE
[16:22:09.559]                             break
[16:22:09.559]                           }
[16:22:09.559]                         }
[16:22:09.559]                       }
[16:22:09.559]                       invisible(muffled)
[16:22:09.559]                     }
[16:22:09.559]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.559]                   }
[16:22:09.559]                 }
[16:22:09.559]             }
[16:22:09.559]         }))
[16:22:09.559]     }, error = function(ex) {
[16:22:09.559]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.559]                 ...future.rng), started = ...future.startTime, 
[16:22:09.559]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.559]             version = "1.8"), class = "FutureResult")
[16:22:09.559]     }, finally = {
[16:22:09.559]         if (!identical(...future.workdir, getwd())) 
[16:22:09.559]             setwd(...future.workdir)
[16:22:09.559]         {
[16:22:09.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.559]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.559]             }
[16:22:09.559]             base::options(...future.oldOptions)
[16:22:09.559]             if (.Platform$OS.type == "windows") {
[16:22:09.559]                 old_names <- names(...future.oldEnvVars)
[16:22:09.559]                 envs <- base::Sys.getenv()
[16:22:09.559]                 names <- names(envs)
[16:22:09.559]                 common <- intersect(names, old_names)
[16:22:09.559]                 added <- setdiff(names, old_names)
[16:22:09.559]                 removed <- setdiff(old_names, names)
[16:22:09.559]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.559]                   envs[common]]
[16:22:09.559]                 NAMES <- toupper(changed)
[16:22:09.559]                 args <- list()
[16:22:09.559]                 for (kk in seq_along(NAMES)) {
[16:22:09.559]                   name <- changed[[kk]]
[16:22:09.559]                   NAME <- NAMES[[kk]]
[16:22:09.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.559]                     next
[16:22:09.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.559]                 }
[16:22:09.559]                 NAMES <- toupper(added)
[16:22:09.559]                 for (kk in seq_along(NAMES)) {
[16:22:09.559]                   name <- added[[kk]]
[16:22:09.559]                   NAME <- NAMES[[kk]]
[16:22:09.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.559]                     next
[16:22:09.559]                   args[[name]] <- ""
[16:22:09.559]                 }
[16:22:09.559]                 NAMES <- toupper(removed)
[16:22:09.559]                 for (kk in seq_along(NAMES)) {
[16:22:09.559]                   name <- removed[[kk]]
[16:22:09.559]                   NAME <- NAMES[[kk]]
[16:22:09.559]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.559]                     next
[16:22:09.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.559]                 }
[16:22:09.559]                 if (length(args) > 0) 
[16:22:09.559]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.559]             }
[16:22:09.559]             else {
[16:22:09.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.559]             }
[16:22:09.559]             {
[16:22:09.559]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.559]                   0L) {
[16:22:09.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.559]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.559]                   base::options(opts)
[16:22:09.559]                 }
[16:22:09.559]                 {
[16:22:09.559]                   {
[16:22:09.559]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.559]                     NULL
[16:22:09.559]                   }
[16:22:09.559]                   options(future.plan = NULL)
[16:22:09.559]                   if (is.na(NA_character_)) 
[16:22:09.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.559]                     .init = FALSE)
[16:22:09.559]                 }
[16:22:09.559]             }
[16:22:09.559]         }
[16:22:09.559]     })
[16:22:09.559]     if (TRUE) {
[16:22:09.559]         base::sink(type = "output", split = FALSE)
[16:22:09.559]         if (TRUE) {
[16:22:09.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.559]         }
[16:22:09.559]         else {
[16:22:09.559]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.559]         }
[16:22:09.559]         base::close(...future.stdout)
[16:22:09.559]         ...future.stdout <- NULL
[16:22:09.559]     }
[16:22:09.559]     ...future.result$conditions <- ...future.conditions
[16:22:09.559]     ...future.result$finished <- base::Sys.time()
[16:22:09.559]     ...future.result
[16:22:09.559] }
[16:22:09.562] MultisessionFuture started
[16:22:09.562] - Launch lazy future ... done
[16:22:09.562] run() for ‘MultisessionFuture’ ... done
[16:22:09.563] resolve() on list environment ...
[16:22:09.563]  recursive: 0
[16:22:09.564]  length: 3
[16:22:09.564]  elements: ‘a’, ‘b’, ‘c’
[16:22:09.565] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.565] - Validating connection of MultisessionFuture
[16:22:09.565] - received message: FutureResult
[16:22:09.565] - Received FutureResult
[16:22:09.565] - Erased future from FutureRegistry
[16:22:09.565] result() for ClusterFuture ...
[16:22:09.566] - result already collected: FutureResult
[16:22:09.566] result() for ClusterFuture ... done
[16:22:09.566] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.566] Future #1
[16:22:09.566]  length: 2 (resolved future 1)
[16:22:09.566] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.566] - Validating connection of MultisessionFuture
[16:22:09.567] - received message: FutureResult
[16:22:09.567] - Received FutureResult
[16:22:09.567] - Erased future from FutureRegistry
[16:22:09.567] result() for ClusterFuture ...
[16:22:09.567] - result already collected: FutureResult
[16:22:09.567] result() for ClusterFuture ... done
[16:22:09.567] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.567] Future #2
[16:22:09.567]  length: 1 (resolved future 2)
[16:22:09.567]  length: 0 (resolved future 3)
[16:22:09.568] resolve() on list environment ... DONE
[16:22:09.568] getGlobalsAndPackages() ...
[16:22:09.568] Searching for globals...
[16:22:09.569] - globals found: [1] ‘{’
[16:22:09.569] Searching for globals ... DONE
[16:22:09.569] Resolving globals: FALSE
[16:22:09.569] 
[16:22:09.569] 
[16:22:09.569] getGlobalsAndPackages() ... DONE
[16:22:09.570] run() for ‘Future’ ...
[16:22:09.570] - state: ‘created’
[16:22:09.570] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.587]   - Field: ‘node’
[16:22:09.587]   - Field: ‘label’
[16:22:09.587]   - Field: ‘local’
[16:22:09.587]   - Field: ‘owner’
[16:22:09.587]   - Field: ‘envir’
[16:22:09.587]   - Field: ‘workers’
[16:22:09.587]   - Field: ‘packages’
[16:22:09.587]   - Field: ‘gc’
[16:22:09.587]   - Field: ‘conditions’
[16:22:09.588]   - Field: ‘persistent’
[16:22:09.588]   - Field: ‘expr’
[16:22:09.588]   - Field: ‘uuid’
[16:22:09.588]   - Field: ‘seed’
[16:22:09.588]   - Field: ‘version’
[16:22:09.588]   - Field: ‘result’
[16:22:09.588]   - Field: ‘asynchronous’
[16:22:09.588]   - Field: ‘calls’
[16:22:09.588]   - Field: ‘globals’
[16:22:09.588]   - Field: ‘stdout’
[16:22:09.588]   - Field: ‘earlySignal’
[16:22:09.589]   - Field: ‘lazy’
[16:22:09.589]   - Field: ‘state’
[16:22:09.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.589] - Launch lazy future ...
[16:22:09.589] Packages needed by the future expression (n = 0): <none>
[16:22:09.589] Packages needed by future strategies (n = 0): <none>
[16:22:09.590] {
[16:22:09.590]     {
[16:22:09.590]         {
[16:22:09.590]             ...future.startTime <- base::Sys.time()
[16:22:09.590]             {
[16:22:09.590]                 {
[16:22:09.590]                   {
[16:22:09.590]                     {
[16:22:09.590]                       base::local({
[16:22:09.590]                         has_future <- base::requireNamespace("future", 
[16:22:09.590]                           quietly = TRUE)
[16:22:09.590]                         if (has_future) {
[16:22:09.590]                           ns <- base::getNamespace("future")
[16:22:09.590]                           version <- ns[[".package"]][["version"]]
[16:22:09.590]                           if (is.null(version)) 
[16:22:09.590]                             version <- utils::packageVersion("future")
[16:22:09.590]                         }
[16:22:09.590]                         else {
[16:22:09.590]                           version <- NULL
[16:22:09.590]                         }
[16:22:09.590]                         if (!has_future || version < "1.8.0") {
[16:22:09.590]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.590]                             "", base::R.version$version.string), 
[16:22:09.590]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.590]                               "release", "version")], collapse = " "), 
[16:22:09.590]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.590]                             info)
[16:22:09.590]                           info <- base::paste(info, collapse = "; ")
[16:22:09.590]                           if (!has_future) {
[16:22:09.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.590]                               info)
[16:22:09.590]                           }
[16:22:09.590]                           else {
[16:22:09.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.590]                               info, version)
[16:22:09.590]                           }
[16:22:09.590]                           base::stop(msg)
[16:22:09.590]                         }
[16:22:09.590]                       })
[16:22:09.590]                     }
[16:22:09.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.590]                     base::options(mc.cores = 1L)
[16:22:09.590]                   }
[16:22:09.590]                   ...future.strategy.old <- future::plan("list")
[16:22:09.590]                   options(future.plan = NULL)
[16:22:09.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.590]                 }
[16:22:09.590]                 ...future.workdir <- getwd()
[16:22:09.590]             }
[16:22:09.590]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.590]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.590]         }
[16:22:09.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.590]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.590]             base::names(...future.oldOptions))
[16:22:09.590]     }
[16:22:09.590]     if (FALSE) {
[16:22:09.590]     }
[16:22:09.590]     else {
[16:22:09.590]         if (TRUE) {
[16:22:09.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.590]                 open = "w")
[16:22:09.590]         }
[16:22:09.590]         else {
[16:22:09.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.590]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.590]         }
[16:22:09.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.590]             base::sink(type = "output", split = FALSE)
[16:22:09.590]             base::close(...future.stdout)
[16:22:09.590]         }, add = TRUE)
[16:22:09.590]     }
[16:22:09.590]     ...future.frame <- base::sys.nframe()
[16:22:09.590]     ...future.conditions <- base::list()
[16:22:09.590]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.590]     if (FALSE) {
[16:22:09.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.590]     }
[16:22:09.590]     ...future.result <- base::tryCatch({
[16:22:09.590]         base::withCallingHandlers({
[16:22:09.590]             ...future.value <- base::withVisible(base::local({
[16:22:09.590]                 ...future.makeSendCondition <- base::local({
[16:22:09.590]                   sendCondition <- NULL
[16:22:09.590]                   function(frame = 1L) {
[16:22:09.590]                     if (is.function(sendCondition)) 
[16:22:09.590]                       return(sendCondition)
[16:22:09.590]                     ns <- getNamespace("parallel")
[16:22:09.590]                     if (exists("sendData", mode = "function", 
[16:22:09.590]                       envir = ns)) {
[16:22:09.590]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.590]                         envir = ns)
[16:22:09.590]                       envir <- sys.frame(frame)
[16:22:09.590]                       master <- NULL
[16:22:09.590]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.590]                         !identical(envir, emptyenv())) {
[16:22:09.590]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.590]                           inherits = FALSE)) {
[16:22:09.590]                           master <- get("master", mode = "list", 
[16:22:09.590]                             envir = envir, inherits = FALSE)
[16:22:09.590]                           if (inherits(master, c("SOCKnode", 
[16:22:09.590]                             "SOCK0node"))) {
[16:22:09.590]                             sendCondition <<- function(cond) {
[16:22:09.590]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.590]                                 success = TRUE)
[16:22:09.590]                               parallel_sendData(master, data)
[16:22:09.590]                             }
[16:22:09.590]                             return(sendCondition)
[16:22:09.590]                           }
[16:22:09.590]                         }
[16:22:09.590]                         frame <- frame + 1L
[16:22:09.590]                         envir <- sys.frame(frame)
[16:22:09.590]                       }
[16:22:09.590]                     }
[16:22:09.590]                     sendCondition <<- function(cond) NULL
[16:22:09.590]                   }
[16:22:09.590]                 })
[16:22:09.590]                 withCallingHandlers({
[16:22:09.590]                   {
[16:22:09.590]                     1
[16:22:09.590]                   }
[16:22:09.590]                 }, immediateCondition = function(cond) {
[16:22:09.590]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.590]                   sendCondition(cond)
[16:22:09.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.590]                   {
[16:22:09.590]                     inherits <- base::inherits
[16:22:09.590]                     invokeRestart <- base::invokeRestart
[16:22:09.590]                     is.null <- base::is.null
[16:22:09.590]                     muffled <- FALSE
[16:22:09.590]                     if (inherits(cond, "message")) {
[16:22:09.590]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.590]                       if (muffled) 
[16:22:09.590]                         invokeRestart("muffleMessage")
[16:22:09.590]                     }
[16:22:09.590]                     else if (inherits(cond, "warning")) {
[16:22:09.590]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.590]                       if (muffled) 
[16:22:09.590]                         invokeRestart("muffleWarning")
[16:22:09.590]                     }
[16:22:09.590]                     else if (inherits(cond, "condition")) {
[16:22:09.590]                       if (!is.null(pattern)) {
[16:22:09.590]                         computeRestarts <- base::computeRestarts
[16:22:09.590]                         grepl <- base::grepl
[16:22:09.590]                         restarts <- computeRestarts(cond)
[16:22:09.590]                         for (restart in restarts) {
[16:22:09.590]                           name <- restart$name
[16:22:09.590]                           if (is.null(name)) 
[16:22:09.590]                             next
[16:22:09.590]                           if (!grepl(pattern, name)) 
[16:22:09.590]                             next
[16:22:09.590]                           invokeRestart(restart)
[16:22:09.590]                           muffled <- TRUE
[16:22:09.590]                           break
[16:22:09.590]                         }
[16:22:09.590]                       }
[16:22:09.590]                     }
[16:22:09.590]                     invisible(muffled)
[16:22:09.590]                   }
[16:22:09.590]                   muffleCondition(cond)
[16:22:09.590]                 })
[16:22:09.590]             }))
[16:22:09.590]             future::FutureResult(value = ...future.value$value, 
[16:22:09.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.590]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.590]                     ...future.globalenv.names))
[16:22:09.590]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.590]         }, condition = base::local({
[16:22:09.590]             c <- base::c
[16:22:09.590]             inherits <- base::inherits
[16:22:09.590]             invokeRestart <- base::invokeRestart
[16:22:09.590]             length <- base::length
[16:22:09.590]             list <- base::list
[16:22:09.590]             seq.int <- base::seq.int
[16:22:09.590]             signalCondition <- base::signalCondition
[16:22:09.590]             sys.calls <- base::sys.calls
[16:22:09.590]             `[[` <- base::`[[`
[16:22:09.590]             `+` <- base::`+`
[16:22:09.590]             `<<-` <- base::`<<-`
[16:22:09.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.590]                   3L)]
[16:22:09.590]             }
[16:22:09.590]             function(cond) {
[16:22:09.590]                 is_error <- inherits(cond, "error")
[16:22:09.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.590]                   NULL)
[16:22:09.590]                 if (is_error) {
[16:22:09.590]                   sessionInformation <- function() {
[16:22:09.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.590]                       search = base::search(), system = base::Sys.info())
[16:22:09.590]                   }
[16:22:09.590]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.590]                     cond$call), session = sessionInformation(), 
[16:22:09.590]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.590]                   signalCondition(cond)
[16:22:09.590]                 }
[16:22:09.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.590]                 "immediateCondition"))) {
[16:22:09.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.590]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.590]                   if (TRUE && !signal) {
[16:22:09.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.590]                     {
[16:22:09.590]                       inherits <- base::inherits
[16:22:09.590]                       invokeRestart <- base::invokeRestart
[16:22:09.590]                       is.null <- base::is.null
[16:22:09.590]                       muffled <- FALSE
[16:22:09.590]                       if (inherits(cond, "message")) {
[16:22:09.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.590]                         if (muffled) 
[16:22:09.590]                           invokeRestart("muffleMessage")
[16:22:09.590]                       }
[16:22:09.590]                       else if (inherits(cond, "warning")) {
[16:22:09.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.590]                         if (muffled) 
[16:22:09.590]                           invokeRestart("muffleWarning")
[16:22:09.590]                       }
[16:22:09.590]                       else if (inherits(cond, "condition")) {
[16:22:09.590]                         if (!is.null(pattern)) {
[16:22:09.590]                           computeRestarts <- base::computeRestarts
[16:22:09.590]                           grepl <- base::grepl
[16:22:09.590]                           restarts <- computeRestarts(cond)
[16:22:09.590]                           for (restart in restarts) {
[16:22:09.590]                             name <- restart$name
[16:22:09.590]                             if (is.null(name)) 
[16:22:09.590]                               next
[16:22:09.590]                             if (!grepl(pattern, name)) 
[16:22:09.590]                               next
[16:22:09.590]                             invokeRestart(restart)
[16:22:09.590]                             muffled <- TRUE
[16:22:09.590]                             break
[16:22:09.590]                           }
[16:22:09.590]                         }
[16:22:09.590]                       }
[16:22:09.590]                       invisible(muffled)
[16:22:09.590]                     }
[16:22:09.590]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.590]                   }
[16:22:09.590]                 }
[16:22:09.590]                 else {
[16:22:09.590]                   if (TRUE) {
[16:22:09.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.590]                     {
[16:22:09.590]                       inherits <- base::inherits
[16:22:09.590]                       invokeRestart <- base::invokeRestart
[16:22:09.590]                       is.null <- base::is.null
[16:22:09.590]                       muffled <- FALSE
[16:22:09.590]                       if (inherits(cond, "message")) {
[16:22:09.590]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.590]                         if (muffled) 
[16:22:09.590]                           invokeRestart("muffleMessage")
[16:22:09.590]                       }
[16:22:09.590]                       else if (inherits(cond, "warning")) {
[16:22:09.590]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.590]                         if (muffled) 
[16:22:09.590]                           invokeRestart("muffleWarning")
[16:22:09.590]                       }
[16:22:09.590]                       else if (inherits(cond, "condition")) {
[16:22:09.590]                         if (!is.null(pattern)) {
[16:22:09.590]                           computeRestarts <- base::computeRestarts
[16:22:09.590]                           grepl <- base::grepl
[16:22:09.590]                           restarts <- computeRestarts(cond)
[16:22:09.590]                           for (restart in restarts) {
[16:22:09.590]                             name <- restart$name
[16:22:09.590]                             if (is.null(name)) 
[16:22:09.590]                               next
[16:22:09.590]                             if (!grepl(pattern, name)) 
[16:22:09.590]                               next
[16:22:09.590]                             invokeRestart(restart)
[16:22:09.590]                             muffled <- TRUE
[16:22:09.590]                             break
[16:22:09.590]                           }
[16:22:09.590]                         }
[16:22:09.590]                       }
[16:22:09.590]                       invisible(muffled)
[16:22:09.590]                     }
[16:22:09.590]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.590]                   }
[16:22:09.590]                 }
[16:22:09.590]             }
[16:22:09.590]         }))
[16:22:09.590]     }, error = function(ex) {
[16:22:09.590]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.590]                 ...future.rng), started = ...future.startTime, 
[16:22:09.590]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.590]             version = "1.8"), class = "FutureResult")
[16:22:09.590]     }, finally = {
[16:22:09.590]         if (!identical(...future.workdir, getwd())) 
[16:22:09.590]             setwd(...future.workdir)
[16:22:09.590]         {
[16:22:09.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.590]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.590]             }
[16:22:09.590]             base::options(...future.oldOptions)
[16:22:09.590]             if (.Platform$OS.type == "windows") {
[16:22:09.590]                 old_names <- names(...future.oldEnvVars)
[16:22:09.590]                 envs <- base::Sys.getenv()
[16:22:09.590]                 names <- names(envs)
[16:22:09.590]                 common <- intersect(names, old_names)
[16:22:09.590]                 added <- setdiff(names, old_names)
[16:22:09.590]                 removed <- setdiff(old_names, names)
[16:22:09.590]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.590]                   envs[common]]
[16:22:09.590]                 NAMES <- toupper(changed)
[16:22:09.590]                 args <- list()
[16:22:09.590]                 for (kk in seq_along(NAMES)) {
[16:22:09.590]                   name <- changed[[kk]]
[16:22:09.590]                   NAME <- NAMES[[kk]]
[16:22:09.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.590]                     next
[16:22:09.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.590]                 }
[16:22:09.590]                 NAMES <- toupper(added)
[16:22:09.590]                 for (kk in seq_along(NAMES)) {
[16:22:09.590]                   name <- added[[kk]]
[16:22:09.590]                   NAME <- NAMES[[kk]]
[16:22:09.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.590]                     next
[16:22:09.590]                   args[[name]] <- ""
[16:22:09.590]                 }
[16:22:09.590]                 NAMES <- toupper(removed)
[16:22:09.590]                 for (kk in seq_along(NAMES)) {
[16:22:09.590]                   name <- removed[[kk]]
[16:22:09.590]                   NAME <- NAMES[[kk]]
[16:22:09.590]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.590]                     next
[16:22:09.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.590]                 }
[16:22:09.590]                 if (length(args) > 0) 
[16:22:09.590]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.590]             }
[16:22:09.590]             else {
[16:22:09.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.590]             }
[16:22:09.590]             {
[16:22:09.590]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.590]                   0L) {
[16:22:09.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.590]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.590]                   base::options(opts)
[16:22:09.590]                 }
[16:22:09.590]                 {
[16:22:09.590]                   {
[16:22:09.590]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.590]                     NULL
[16:22:09.590]                   }
[16:22:09.590]                   options(future.plan = NULL)
[16:22:09.590]                   if (is.na(NA_character_)) 
[16:22:09.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.590]                     .init = FALSE)
[16:22:09.590]                 }
[16:22:09.590]             }
[16:22:09.590]         }
[16:22:09.590]     })
[16:22:09.590]     if (TRUE) {
[16:22:09.590]         base::sink(type = "output", split = FALSE)
[16:22:09.590]         if (TRUE) {
[16:22:09.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.590]         }
[16:22:09.590]         else {
[16:22:09.590]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.590]         }
[16:22:09.590]         base::close(...future.stdout)
[16:22:09.590]         ...future.stdout <- NULL
[16:22:09.590]     }
[16:22:09.590]     ...future.result$conditions <- ...future.conditions
[16:22:09.590]     ...future.result$finished <- base::Sys.time()
[16:22:09.590]     ...future.result
[16:22:09.590] }
[16:22:09.592] MultisessionFuture started
[16:22:09.593] - Launch lazy future ... done
[16:22:09.593] run() for ‘MultisessionFuture’ ... done
[16:22:09.593] getGlobalsAndPackages() ...
[16:22:09.593] Searching for globals...
[16:22:09.594] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:22:09.594] Searching for globals ... DONE
[16:22:09.594] Resolving globals: FALSE
[16:22:09.595] 
[16:22:09.595] 
[16:22:09.595] getGlobalsAndPackages() ... DONE
[16:22:09.595] run() for ‘Future’ ...
[16:22:09.595] - state: ‘created’
[16:22:09.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.609]   - Field: ‘node’
[16:22:09.609]   - Field: ‘label’
[16:22:09.609]   - Field: ‘local’
[16:22:09.609]   - Field: ‘owner’
[16:22:09.609]   - Field: ‘envir’
[16:22:09.609]   - Field: ‘workers’
[16:22:09.609]   - Field: ‘packages’
[16:22:09.609]   - Field: ‘gc’
[16:22:09.610]   - Field: ‘conditions’
[16:22:09.610]   - Field: ‘persistent’
[16:22:09.610]   - Field: ‘expr’
[16:22:09.610]   - Field: ‘uuid’
[16:22:09.610]   - Field: ‘seed’
[16:22:09.610]   - Field: ‘version’
[16:22:09.610]   - Field: ‘result’
[16:22:09.610]   - Field: ‘asynchronous’
[16:22:09.610]   - Field: ‘calls’
[16:22:09.610]   - Field: ‘globals’
[16:22:09.611]   - Field: ‘stdout’
[16:22:09.611]   - Field: ‘earlySignal’
[16:22:09.611]   - Field: ‘lazy’
[16:22:09.611]   - Field: ‘state’
[16:22:09.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.611] - Launch lazy future ...
[16:22:09.611] Packages needed by the future expression (n = 0): <none>
[16:22:09.611] Packages needed by future strategies (n = 0): <none>
[16:22:09.612] {
[16:22:09.612]     {
[16:22:09.612]         {
[16:22:09.612]             ...future.startTime <- base::Sys.time()
[16:22:09.612]             {
[16:22:09.612]                 {
[16:22:09.612]                   {
[16:22:09.612]                     {
[16:22:09.612]                       base::local({
[16:22:09.612]                         has_future <- base::requireNamespace("future", 
[16:22:09.612]                           quietly = TRUE)
[16:22:09.612]                         if (has_future) {
[16:22:09.612]                           ns <- base::getNamespace("future")
[16:22:09.612]                           version <- ns[[".package"]][["version"]]
[16:22:09.612]                           if (is.null(version)) 
[16:22:09.612]                             version <- utils::packageVersion("future")
[16:22:09.612]                         }
[16:22:09.612]                         else {
[16:22:09.612]                           version <- NULL
[16:22:09.612]                         }
[16:22:09.612]                         if (!has_future || version < "1.8.0") {
[16:22:09.612]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.612]                             "", base::R.version$version.string), 
[16:22:09.612]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.612]                               "release", "version")], collapse = " "), 
[16:22:09.612]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.612]                             info)
[16:22:09.612]                           info <- base::paste(info, collapse = "; ")
[16:22:09.612]                           if (!has_future) {
[16:22:09.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.612]                               info)
[16:22:09.612]                           }
[16:22:09.612]                           else {
[16:22:09.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.612]                               info, version)
[16:22:09.612]                           }
[16:22:09.612]                           base::stop(msg)
[16:22:09.612]                         }
[16:22:09.612]                       })
[16:22:09.612]                     }
[16:22:09.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.612]                     base::options(mc.cores = 1L)
[16:22:09.612]                   }
[16:22:09.612]                   ...future.strategy.old <- future::plan("list")
[16:22:09.612]                   options(future.plan = NULL)
[16:22:09.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.612]                 }
[16:22:09.612]                 ...future.workdir <- getwd()
[16:22:09.612]             }
[16:22:09.612]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.612]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.612]         }
[16:22:09.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.612]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.612]             base::names(...future.oldOptions))
[16:22:09.612]     }
[16:22:09.612]     if (FALSE) {
[16:22:09.612]     }
[16:22:09.612]     else {
[16:22:09.612]         if (TRUE) {
[16:22:09.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.612]                 open = "w")
[16:22:09.612]         }
[16:22:09.612]         else {
[16:22:09.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.612]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.612]         }
[16:22:09.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.612]             base::sink(type = "output", split = FALSE)
[16:22:09.612]             base::close(...future.stdout)
[16:22:09.612]         }, add = TRUE)
[16:22:09.612]     }
[16:22:09.612]     ...future.frame <- base::sys.nframe()
[16:22:09.612]     ...future.conditions <- base::list()
[16:22:09.612]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.612]     if (FALSE) {
[16:22:09.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.612]     }
[16:22:09.612]     ...future.result <- base::tryCatch({
[16:22:09.612]         base::withCallingHandlers({
[16:22:09.612]             ...future.value <- base::withVisible(base::local({
[16:22:09.612]                 ...future.makeSendCondition <- base::local({
[16:22:09.612]                   sendCondition <- NULL
[16:22:09.612]                   function(frame = 1L) {
[16:22:09.612]                     if (is.function(sendCondition)) 
[16:22:09.612]                       return(sendCondition)
[16:22:09.612]                     ns <- getNamespace("parallel")
[16:22:09.612]                     if (exists("sendData", mode = "function", 
[16:22:09.612]                       envir = ns)) {
[16:22:09.612]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.612]                         envir = ns)
[16:22:09.612]                       envir <- sys.frame(frame)
[16:22:09.612]                       master <- NULL
[16:22:09.612]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.612]                         !identical(envir, emptyenv())) {
[16:22:09.612]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.612]                           inherits = FALSE)) {
[16:22:09.612]                           master <- get("master", mode = "list", 
[16:22:09.612]                             envir = envir, inherits = FALSE)
[16:22:09.612]                           if (inherits(master, c("SOCKnode", 
[16:22:09.612]                             "SOCK0node"))) {
[16:22:09.612]                             sendCondition <<- function(cond) {
[16:22:09.612]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.612]                                 success = TRUE)
[16:22:09.612]                               parallel_sendData(master, data)
[16:22:09.612]                             }
[16:22:09.612]                             return(sendCondition)
[16:22:09.612]                           }
[16:22:09.612]                         }
[16:22:09.612]                         frame <- frame + 1L
[16:22:09.612]                         envir <- sys.frame(frame)
[16:22:09.612]                       }
[16:22:09.612]                     }
[16:22:09.612]                     sendCondition <<- function(cond) NULL
[16:22:09.612]                   }
[16:22:09.612]                 })
[16:22:09.612]                 withCallingHandlers({
[16:22:09.612]                   {
[16:22:09.612]                     Sys.sleep(0.5)
[16:22:09.612]                     2
[16:22:09.612]                   }
[16:22:09.612]                 }, immediateCondition = function(cond) {
[16:22:09.612]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.612]                   sendCondition(cond)
[16:22:09.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.612]                   {
[16:22:09.612]                     inherits <- base::inherits
[16:22:09.612]                     invokeRestart <- base::invokeRestart
[16:22:09.612]                     is.null <- base::is.null
[16:22:09.612]                     muffled <- FALSE
[16:22:09.612]                     if (inherits(cond, "message")) {
[16:22:09.612]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.612]                       if (muffled) 
[16:22:09.612]                         invokeRestart("muffleMessage")
[16:22:09.612]                     }
[16:22:09.612]                     else if (inherits(cond, "warning")) {
[16:22:09.612]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.612]                       if (muffled) 
[16:22:09.612]                         invokeRestart("muffleWarning")
[16:22:09.612]                     }
[16:22:09.612]                     else if (inherits(cond, "condition")) {
[16:22:09.612]                       if (!is.null(pattern)) {
[16:22:09.612]                         computeRestarts <- base::computeRestarts
[16:22:09.612]                         grepl <- base::grepl
[16:22:09.612]                         restarts <- computeRestarts(cond)
[16:22:09.612]                         for (restart in restarts) {
[16:22:09.612]                           name <- restart$name
[16:22:09.612]                           if (is.null(name)) 
[16:22:09.612]                             next
[16:22:09.612]                           if (!grepl(pattern, name)) 
[16:22:09.612]                             next
[16:22:09.612]                           invokeRestart(restart)
[16:22:09.612]                           muffled <- TRUE
[16:22:09.612]                           break
[16:22:09.612]                         }
[16:22:09.612]                       }
[16:22:09.612]                     }
[16:22:09.612]                     invisible(muffled)
[16:22:09.612]                   }
[16:22:09.612]                   muffleCondition(cond)
[16:22:09.612]                 })
[16:22:09.612]             }))
[16:22:09.612]             future::FutureResult(value = ...future.value$value, 
[16:22:09.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.612]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.612]                     ...future.globalenv.names))
[16:22:09.612]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.612]         }, condition = base::local({
[16:22:09.612]             c <- base::c
[16:22:09.612]             inherits <- base::inherits
[16:22:09.612]             invokeRestart <- base::invokeRestart
[16:22:09.612]             length <- base::length
[16:22:09.612]             list <- base::list
[16:22:09.612]             seq.int <- base::seq.int
[16:22:09.612]             signalCondition <- base::signalCondition
[16:22:09.612]             sys.calls <- base::sys.calls
[16:22:09.612]             `[[` <- base::`[[`
[16:22:09.612]             `+` <- base::`+`
[16:22:09.612]             `<<-` <- base::`<<-`
[16:22:09.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.612]                   3L)]
[16:22:09.612]             }
[16:22:09.612]             function(cond) {
[16:22:09.612]                 is_error <- inherits(cond, "error")
[16:22:09.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.612]                   NULL)
[16:22:09.612]                 if (is_error) {
[16:22:09.612]                   sessionInformation <- function() {
[16:22:09.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.612]                       search = base::search(), system = base::Sys.info())
[16:22:09.612]                   }
[16:22:09.612]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.612]                     cond$call), session = sessionInformation(), 
[16:22:09.612]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.612]                   signalCondition(cond)
[16:22:09.612]                 }
[16:22:09.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.612]                 "immediateCondition"))) {
[16:22:09.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.612]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.612]                   if (TRUE && !signal) {
[16:22:09.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.612]                     {
[16:22:09.612]                       inherits <- base::inherits
[16:22:09.612]                       invokeRestart <- base::invokeRestart
[16:22:09.612]                       is.null <- base::is.null
[16:22:09.612]                       muffled <- FALSE
[16:22:09.612]                       if (inherits(cond, "message")) {
[16:22:09.612]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.612]                         if (muffled) 
[16:22:09.612]                           invokeRestart("muffleMessage")
[16:22:09.612]                       }
[16:22:09.612]                       else if (inherits(cond, "warning")) {
[16:22:09.612]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.612]                         if (muffled) 
[16:22:09.612]                           invokeRestart("muffleWarning")
[16:22:09.612]                       }
[16:22:09.612]                       else if (inherits(cond, "condition")) {
[16:22:09.612]                         if (!is.null(pattern)) {
[16:22:09.612]                           computeRestarts <- base::computeRestarts
[16:22:09.612]                           grepl <- base::grepl
[16:22:09.612]                           restarts <- computeRestarts(cond)
[16:22:09.612]                           for (restart in restarts) {
[16:22:09.612]                             name <- restart$name
[16:22:09.612]                             if (is.null(name)) 
[16:22:09.612]                               next
[16:22:09.612]                             if (!grepl(pattern, name)) 
[16:22:09.612]                               next
[16:22:09.612]                             invokeRestart(restart)
[16:22:09.612]                             muffled <- TRUE
[16:22:09.612]                             break
[16:22:09.612]                           }
[16:22:09.612]                         }
[16:22:09.612]                       }
[16:22:09.612]                       invisible(muffled)
[16:22:09.612]                     }
[16:22:09.612]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.612]                   }
[16:22:09.612]                 }
[16:22:09.612]                 else {
[16:22:09.612]                   if (TRUE) {
[16:22:09.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.612]                     {
[16:22:09.612]                       inherits <- base::inherits
[16:22:09.612]                       invokeRestart <- base::invokeRestart
[16:22:09.612]                       is.null <- base::is.null
[16:22:09.612]                       muffled <- FALSE
[16:22:09.612]                       if (inherits(cond, "message")) {
[16:22:09.612]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.612]                         if (muffled) 
[16:22:09.612]                           invokeRestart("muffleMessage")
[16:22:09.612]                       }
[16:22:09.612]                       else if (inherits(cond, "warning")) {
[16:22:09.612]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.612]                         if (muffled) 
[16:22:09.612]                           invokeRestart("muffleWarning")
[16:22:09.612]                       }
[16:22:09.612]                       else if (inherits(cond, "condition")) {
[16:22:09.612]                         if (!is.null(pattern)) {
[16:22:09.612]                           computeRestarts <- base::computeRestarts
[16:22:09.612]                           grepl <- base::grepl
[16:22:09.612]                           restarts <- computeRestarts(cond)
[16:22:09.612]                           for (restart in restarts) {
[16:22:09.612]                             name <- restart$name
[16:22:09.612]                             if (is.null(name)) 
[16:22:09.612]                               next
[16:22:09.612]                             if (!grepl(pattern, name)) 
[16:22:09.612]                               next
[16:22:09.612]                             invokeRestart(restart)
[16:22:09.612]                             muffled <- TRUE
[16:22:09.612]                             break
[16:22:09.612]                           }
[16:22:09.612]                         }
[16:22:09.612]                       }
[16:22:09.612]                       invisible(muffled)
[16:22:09.612]                     }
[16:22:09.612]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.612]                   }
[16:22:09.612]                 }
[16:22:09.612]             }
[16:22:09.612]         }))
[16:22:09.612]     }, error = function(ex) {
[16:22:09.612]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.612]                 ...future.rng), started = ...future.startTime, 
[16:22:09.612]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.612]             version = "1.8"), class = "FutureResult")
[16:22:09.612]     }, finally = {
[16:22:09.612]         if (!identical(...future.workdir, getwd())) 
[16:22:09.612]             setwd(...future.workdir)
[16:22:09.612]         {
[16:22:09.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.612]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.612]             }
[16:22:09.612]             base::options(...future.oldOptions)
[16:22:09.612]             if (.Platform$OS.type == "windows") {
[16:22:09.612]                 old_names <- names(...future.oldEnvVars)
[16:22:09.612]                 envs <- base::Sys.getenv()
[16:22:09.612]                 names <- names(envs)
[16:22:09.612]                 common <- intersect(names, old_names)
[16:22:09.612]                 added <- setdiff(names, old_names)
[16:22:09.612]                 removed <- setdiff(old_names, names)
[16:22:09.612]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.612]                   envs[common]]
[16:22:09.612]                 NAMES <- toupper(changed)
[16:22:09.612]                 args <- list()
[16:22:09.612]                 for (kk in seq_along(NAMES)) {
[16:22:09.612]                   name <- changed[[kk]]
[16:22:09.612]                   NAME <- NAMES[[kk]]
[16:22:09.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.612]                     next
[16:22:09.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.612]                 }
[16:22:09.612]                 NAMES <- toupper(added)
[16:22:09.612]                 for (kk in seq_along(NAMES)) {
[16:22:09.612]                   name <- added[[kk]]
[16:22:09.612]                   NAME <- NAMES[[kk]]
[16:22:09.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.612]                     next
[16:22:09.612]                   args[[name]] <- ""
[16:22:09.612]                 }
[16:22:09.612]                 NAMES <- toupper(removed)
[16:22:09.612]                 for (kk in seq_along(NAMES)) {
[16:22:09.612]                   name <- removed[[kk]]
[16:22:09.612]                   NAME <- NAMES[[kk]]
[16:22:09.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.612]                     next
[16:22:09.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.612]                 }
[16:22:09.612]                 if (length(args) > 0) 
[16:22:09.612]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.612]             }
[16:22:09.612]             else {
[16:22:09.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.612]             }
[16:22:09.612]             {
[16:22:09.612]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.612]                   0L) {
[16:22:09.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.612]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.612]                   base::options(opts)
[16:22:09.612]                 }
[16:22:09.612]                 {
[16:22:09.612]                   {
[16:22:09.612]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.612]                     NULL
[16:22:09.612]                   }
[16:22:09.612]                   options(future.plan = NULL)
[16:22:09.612]                   if (is.na(NA_character_)) 
[16:22:09.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.612]                     .init = FALSE)
[16:22:09.612]                 }
[16:22:09.612]             }
[16:22:09.612]         }
[16:22:09.612]     })
[16:22:09.612]     if (TRUE) {
[16:22:09.612]         base::sink(type = "output", split = FALSE)
[16:22:09.612]         if (TRUE) {
[16:22:09.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.612]         }
[16:22:09.612]         else {
[16:22:09.612]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.612]         }
[16:22:09.612]         base::close(...future.stdout)
[16:22:09.612]         ...future.stdout <- NULL
[16:22:09.612]     }
[16:22:09.612]     ...future.result$conditions <- ...future.conditions
[16:22:09.612]     ...future.result$finished <- base::Sys.time()
[16:22:09.612]     ...future.result
[16:22:09.612] }
[16:22:09.615] MultisessionFuture started
[16:22:09.615] - Launch lazy future ... done
[16:22:09.615] run() for ‘MultisessionFuture’ ... done
[16:22:09.616] getGlobalsAndPackages() ...
[16:22:09.616] Searching for globals...
[16:22:09.616] - globals found: [1] ‘{’
[16:22:09.617] Searching for globals ... DONE
[16:22:09.617] Resolving globals: FALSE
[16:22:09.617] 
[16:22:09.617] 
[16:22:09.617] getGlobalsAndPackages() ... DONE
[16:22:09.617] run() for ‘Future’ ...
[16:22:09.617] - state: ‘created’
[16:22:09.618] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:22:09.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:22:09.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:22:09.631]   - Field: ‘node’
[16:22:09.631]   - Field: ‘label’
[16:22:09.631]   - Field: ‘local’
[16:22:09.632]   - Field: ‘owner’
[16:22:09.632]   - Field: ‘envir’
[16:22:09.632]   - Field: ‘workers’
[16:22:09.632]   - Field: ‘packages’
[16:22:09.632]   - Field: ‘gc’
[16:22:09.632]   - Field: ‘conditions’
[16:22:09.632]   - Field: ‘persistent’
[16:22:09.632]   - Field: ‘expr’
[16:22:09.632]   - Field: ‘uuid’
[16:22:09.632]   - Field: ‘seed’
[16:22:09.633]   - Field: ‘version’
[16:22:09.633]   - Field: ‘result’
[16:22:09.633]   - Field: ‘asynchronous’
[16:22:09.633]   - Field: ‘calls’
[16:22:09.633]   - Field: ‘globals’
[16:22:09.633]   - Field: ‘stdout’
[16:22:09.633]   - Field: ‘earlySignal’
[16:22:09.633]   - Field: ‘lazy’
[16:22:09.633]   - Field: ‘state’
[16:22:09.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:22:09.634] - Launch lazy future ...
[16:22:09.634] Packages needed by the future expression (n = 0): <none>
[16:22:09.634] Packages needed by future strategies (n = 0): <none>
[16:22:09.634] {
[16:22:09.634]     {
[16:22:09.634]         {
[16:22:09.634]             ...future.startTime <- base::Sys.time()
[16:22:09.634]             {
[16:22:09.634]                 {
[16:22:09.634]                   {
[16:22:09.634]                     {
[16:22:09.634]                       base::local({
[16:22:09.634]                         has_future <- base::requireNamespace("future", 
[16:22:09.634]                           quietly = TRUE)
[16:22:09.634]                         if (has_future) {
[16:22:09.634]                           ns <- base::getNamespace("future")
[16:22:09.634]                           version <- ns[[".package"]][["version"]]
[16:22:09.634]                           if (is.null(version)) 
[16:22:09.634]                             version <- utils::packageVersion("future")
[16:22:09.634]                         }
[16:22:09.634]                         else {
[16:22:09.634]                           version <- NULL
[16:22:09.634]                         }
[16:22:09.634]                         if (!has_future || version < "1.8.0") {
[16:22:09.634]                           info <- base::c(r_version = base::gsub("R version ", 
[16:22:09.634]                             "", base::R.version$version.string), 
[16:22:09.634]                             platform = base::sprintf("%s (%s-bit)", 
[16:22:09.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:22:09.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:22:09.634]                               "release", "version")], collapse = " "), 
[16:22:09.634]                             hostname = base::Sys.info()[["nodename"]])
[16:22:09.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:22:09.634]                             info)
[16:22:09.634]                           info <- base::paste(info, collapse = "; ")
[16:22:09.634]                           if (!has_future) {
[16:22:09.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:22:09.634]                               info)
[16:22:09.634]                           }
[16:22:09.634]                           else {
[16:22:09.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:22:09.634]                               info, version)
[16:22:09.634]                           }
[16:22:09.634]                           base::stop(msg)
[16:22:09.634]                         }
[16:22:09.634]                       })
[16:22:09.634]                     }
[16:22:09.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:22:09.634]                     base::options(mc.cores = 1L)
[16:22:09.634]                   }
[16:22:09.634]                   ...future.strategy.old <- future::plan("list")
[16:22:09.634]                   options(future.plan = NULL)
[16:22:09.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:22:09.634]                 }
[16:22:09.634]                 ...future.workdir <- getwd()
[16:22:09.634]             }
[16:22:09.634]             ...future.oldOptions <- base::as.list(base::.Options)
[16:22:09.634]             ...future.oldEnvVars <- base::Sys.getenv()
[16:22:09.634]         }
[16:22:09.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:22:09.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:22:09.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:22:09.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:22:09.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:22:09.634]             future.stdout.windows.reencode = NULL, width = 80L)
[16:22:09.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:22:09.634]             base::names(...future.oldOptions))
[16:22:09.634]     }
[16:22:09.634]     if (FALSE) {
[16:22:09.634]     }
[16:22:09.634]     else {
[16:22:09.634]         if (TRUE) {
[16:22:09.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:22:09.634]                 open = "w")
[16:22:09.634]         }
[16:22:09.634]         else {
[16:22:09.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:22:09.634]                 windows = "NUL", "/dev/null"), open = "w")
[16:22:09.634]         }
[16:22:09.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:22:09.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:22:09.634]             base::sink(type = "output", split = FALSE)
[16:22:09.634]             base::close(...future.stdout)
[16:22:09.634]         }, add = TRUE)
[16:22:09.634]     }
[16:22:09.634]     ...future.frame <- base::sys.nframe()
[16:22:09.634]     ...future.conditions <- base::list()
[16:22:09.634]     ...future.rng <- base::globalenv()$.Random.seed
[16:22:09.634]     if (FALSE) {
[16:22:09.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:22:09.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:22:09.634]     }
[16:22:09.634]     ...future.result <- base::tryCatch({
[16:22:09.634]         base::withCallingHandlers({
[16:22:09.634]             ...future.value <- base::withVisible(base::local({
[16:22:09.634]                 ...future.makeSendCondition <- base::local({
[16:22:09.634]                   sendCondition <- NULL
[16:22:09.634]                   function(frame = 1L) {
[16:22:09.634]                     if (is.function(sendCondition)) 
[16:22:09.634]                       return(sendCondition)
[16:22:09.634]                     ns <- getNamespace("parallel")
[16:22:09.634]                     if (exists("sendData", mode = "function", 
[16:22:09.634]                       envir = ns)) {
[16:22:09.634]                       parallel_sendData <- get("sendData", mode = "function", 
[16:22:09.634]                         envir = ns)
[16:22:09.634]                       envir <- sys.frame(frame)
[16:22:09.634]                       master <- NULL
[16:22:09.634]                       while (!identical(envir, .GlobalEnv) && 
[16:22:09.634]                         !identical(envir, emptyenv())) {
[16:22:09.634]                         if (exists("master", mode = "list", envir = envir, 
[16:22:09.634]                           inherits = FALSE)) {
[16:22:09.634]                           master <- get("master", mode = "list", 
[16:22:09.634]                             envir = envir, inherits = FALSE)
[16:22:09.634]                           if (inherits(master, c("SOCKnode", 
[16:22:09.634]                             "SOCK0node"))) {
[16:22:09.634]                             sendCondition <<- function(cond) {
[16:22:09.634]                               data <- list(type = "VALUE", value = cond, 
[16:22:09.634]                                 success = TRUE)
[16:22:09.634]                               parallel_sendData(master, data)
[16:22:09.634]                             }
[16:22:09.634]                             return(sendCondition)
[16:22:09.634]                           }
[16:22:09.634]                         }
[16:22:09.634]                         frame <- frame + 1L
[16:22:09.634]                         envir <- sys.frame(frame)
[16:22:09.634]                       }
[16:22:09.634]                     }
[16:22:09.634]                     sendCondition <<- function(cond) NULL
[16:22:09.634]                   }
[16:22:09.634]                 })
[16:22:09.634]                 withCallingHandlers({
[16:22:09.634]                   {
[16:22:09.634]                     3
[16:22:09.634]                   }
[16:22:09.634]                 }, immediateCondition = function(cond) {
[16:22:09.634]                   sendCondition <- ...future.makeSendCondition()
[16:22:09.634]                   sendCondition(cond)
[16:22:09.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.634]                   {
[16:22:09.634]                     inherits <- base::inherits
[16:22:09.634]                     invokeRestart <- base::invokeRestart
[16:22:09.634]                     is.null <- base::is.null
[16:22:09.634]                     muffled <- FALSE
[16:22:09.634]                     if (inherits(cond, "message")) {
[16:22:09.634]                       muffled <- grepl(pattern, "muffleMessage")
[16:22:09.634]                       if (muffled) 
[16:22:09.634]                         invokeRestart("muffleMessage")
[16:22:09.634]                     }
[16:22:09.634]                     else if (inherits(cond, "warning")) {
[16:22:09.634]                       muffled <- grepl(pattern, "muffleWarning")
[16:22:09.634]                       if (muffled) 
[16:22:09.634]                         invokeRestart("muffleWarning")
[16:22:09.634]                     }
[16:22:09.634]                     else if (inherits(cond, "condition")) {
[16:22:09.634]                       if (!is.null(pattern)) {
[16:22:09.634]                         computeRestarts <- base::computeRestarts
[16:22:09.634]                         grepl <- base::grepl
[16:22:09.634]                         restarts <- computeRestarts(cond)
[16:22:09.634]                         for (restart in restarts) {
[16:22:09.634]                           name <- restart$name
[16:22:09.634]                           if (is.null(name)) 
[16:22:09.634]                             next
[16:22:09.634]                           if (!grepl(pattern, name)) 
[16:22:09.634]                             next
[16:22:09.634]                           invokeRestart(restart)
[16:22:09.634]                           muffled <- TRUE
[16:22:09.634]                           break
[16:22:09.634]                         }
[16:22:09.634]                       }
[16:22:09.634]                     }
[16:22:09.634]                     invisible(muffled)
[16:22:09.634]                   }
[16:22:09.634]                   muffleCondition(cond)
[16:22:09.634]                 })
[16:22:09.634]             }))
[16:22:09.634]             future::FutureResult(value = ...future.value$value, 
[16:22:09.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.634]                   ...future.rng), globalenv = if (FALSE) 
[16:22:09.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:22:09.634]                     ...future.globalenv.names))
[16:22:09.634]                 else NULL, started = ...future.startTime, version = "1.8")
[16:22:09.634]         }, condition = base::local({
[16:22:09.634]             c <- base::c
[16:22:09.634]             inherits <- base::inherits
[16:22:09.634]             invokeRestart <- base::invokeRestart
[16:22:09.634]             length <- base::length
[16:22:09.634]             list <- base::list
[16:22:09.634]             seq.int <- base::seq.int
[16:22:09.634]             signalCondition <- base::signalCondition
[16:22:09.634]             sys.calls <- base::sys.calls
[16:22:09.634]             `[[` <- base::`[[`
[16:22:09.634]             `+` <- base::`+`
[16:22:09.634]             `<<-` <- base::`<<-`
[16:22:09.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:22:09.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:22:09.634]                   3L)]
[16:22:09.634]             }
[16:22:09.634]             function(cond) {
[16:22:09.634]                 is_error <- inherits(cond, "error")
[16:22:09.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:22:09.634]                   NULL)
[16:22:09.634]                 if (is_error) {
[16:22:09.634]                   sessionInformation <- function() {
[16:22:09.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:22:09.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:22:09.634]                       search = base::search(), system = base::Sys.info())
[16:22:09.634]                   }
[16:22:09.634]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:22:09.634]                     cond$call), session = sessionInformation(), 
[16:22:09.634]                     timestamp = base::Sys.time(), signaled = 0L)
[16:22:09.634]                   signalCondition(cond)
[16:22:09.634]                 }
[16:22:09.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:22:09.634]                 "immediateCondition"))) {
[16:22:09.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:22:09.634]                   ...future.conditions[[length(...future.conditions) + 
[16:22:09.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:22:09.634]                   if (TRUE && !signal) {
[16:22:09.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.634]                     {
[16:22:09.634]                       inherits <- base::inherits
[16:22:09.634]                       invokeRestart <- base::invokeRestart
[16:22:09.634]                       is.null <- base::is.null
[16:22:09.634]                       muffled <- FALSE
[16:22:09.634]                       if (inherits(cond, "message")) {
[16:22:09.634]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.634]                         if (muffled) 
[16:22:09.634]                           invokeRestart("muffleMessage")
[16:22:09.634]                       }
[16:22:09.634]                       else if (inherits(cond, "warning")) {
[16:22:09.634]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.634]                         if (muffled) 
[16:22:09.634]                           invokeRestart("muffleWarning")
[16:22:09.634]                       }
[16:22:09.634]                       else if (inherits(cond, "condition")) {
[16:22:09.634]                         if (!is.null(pattern)) {
[16:22:09.634]                           computeRestarts <- base::computeRestarts
[16:22:09.634]                           grepl <- base::grepl
[16:22:09.634]                           restarts <- computeRestarts(cond)
[16:22:09.634]                           for (restart in restarts) {
[16:22:09.634]                             name <- restart$name
[16:22:09.634]                             if (is.null(name)) 
[16:22:09.634]                               next
[16:22:09.634]                             if (!grepl(pattern, name)) 
[16:22:09.634]                               next
[16:22:09.634]                             invokeRestart(restart)
[16:22:09.634]                             muffled <- TRUE
[16:22:09.634]                             break
[16:22:09.634]                           }
[16:22:09.634]                         }
[16:22:09.634]                       }
[16:22:09.634]                       invisible(muffled)
[16:22:09.634]                     }
[16:22:09.634]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.634]                   }
[16:22:09.634]                 }
[16:22:09.634]                 else {
[16:22:09.634]                   if (TRUE) {
[16:22:09.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:22:09.634]                     {
[16:22:09.634]                       inherits <- base::inherits
[16:22:09.634]                       invokeRestart <- base::invokeRestart
[16:22:09.634]                       is.null <- base::is.null
[16:22:09.634]                       muffled <- FALSE
[16:22:09.634]                       if (inherits(cond, "message")) {
[16:22:09.634]                         muffled <- grepl(pattern, "muffleMessage")
[16:22:09.634]                         if (muffled) 
[16:22:09.634]                           invokeRestart("muffleMessage")
[16:22:09.634]                       }
[16:22:09.634]                       else if (inherits(cond, "warning")) {
[16:22:09.634]                         muffled <- grepl(pattern, "muffleWarning")
[16:22:09.634]                         if (muffled) 
[16:22:09.634]                           invokeRestart("muffleWarning")
[16:22:09.634]                       }
[16:22:09.634]                       else if (inherits(cond, "condition")) {
[16:22:09.634]                         if (!is.null(pattern)) {
[16:22:09.634]                           computeRestarts <- base::computeRestarts
[16:22:09.634]                           grepl <- base::grepl
[16:22:09.634]                           restarts <- computeRestarts(cond)
[16:22:09.634]                           for (restart in restarts) {
[16:22:09.634]                             name <- restart$name
[16:22:09.634]                             if (is.null(name)) 
[16:22:09.634]                               next
[16:22:09.634]                             if (!grepl(pattern, name)) 
[16:22:09.634]                               next
[16:22:09.634]                             invokeRestart(restart)
[16:22:09.634]                             muffled <- TRUE
[16:22:09.634]                             break
[16:22:09.634]                           }
[16:22:09.634]                         }
[16:22:09.634]                       }
[16:22:09.634]                       invisible(muffled)
[16:22:09.634]                     }
[16:22:09.634]                     muffleCondition(cond, pattern = "^muffle")
[16:22:09.634]                   }
[16:22:09.634]                 }
[16:22:09.634]             }
[16:22:09.634]         }))
[16:22:09.634]     }, error = function(ex) {
[16:22:09.634]         base::structure(base::list(value = NULL, visible = NULL, 
[16:22:09.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:22:09.634]                 ...future.rng), started = ...future.startTime, 
[16:22:09.634]             finished = Sys.time(), session_uuid = NA_character_, 
[16:22:09.634]             version = "1.8"), class = "FutureResult")
[16:22:09.634]     }, finally = {
[16:22:09.634]         if (!identical(...future.workdir, getwd())) 
[16:22:09.634]             setwd(...future.workdir)
[16:22:09.634]         {
[16:22:09.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:22:09.634]                 ...future.oldOptions$nwarnings <- NULL
[16:22:09.634]             }
[16:22:09.634]             base::options(...future.oldOptions)
[16:22:09.634]             if (.Platform$OS.type == "windows") {
[16:22:09.634]                 old_names <- names(...future.oldEnvVars)
[16:22:09.634]                 envs <- base::Sys.getenv()
[16:22:09.634]                 names <- names(envs)
[16:22:09.634]                 common <- intersect(names, old_names)
[16:22:09.634]                 added <- setdiff(names, old_names)
[16:22:09.634]                 removed <- setdiff(old_names, names)
[16:22:09.634]                 changed <- common[...future.oldEnvVars[common] != 
[16:22:09.634]                   envs[common]]
[16:22:09.634]                 NAMES <- toupper(changed)
[16:22:09.634]                 args <- list()
[16:22:09.634]                 for (kk in seq_along(NAMES)) {
[16:22:09.634]                   name <- changed[[kk]]
[16:22:09.634]                   NAME <- NAMES[[kk]]
[16:22:09.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.634]                     next
[16:22:09.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.634]                 }
[16:22:09.634]                 NAMES <- toupper(added)
[16:22:09.634]                 for (kk in seq_along(NAMES)) {
[16:22:09.634]                   name <- added[[kk]]
[16:22:09.634]                   NAME <- NAMES[[kk]]
[16:22:09.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.634]                     next
[16:22:09.634]                   args[[name]] <- ""
[16:22:09.634]                 }
[16:22:09.634]                 NAMES <- toupper(removed)
[16:22:09.634]                 for (kk in seq_along(NAMES)) {
[16:22:09.634]                   name <- removed[[kk]]
[16:22:09.634]                   NAME <- NAMES[[kk]]
[16:22:09.634]                   if (name != NAME && is.element(NAME, old_names)) 
[16:22:09.634]                     next
[16:22:09.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:22:09.634]                 }
[16:22:09.634]                 if (length(args) > 0) 
[16:22:09.634]                   base::do.call(base::Sys.setenv, args = args)
[16:22:09.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:22:09.634]             }
[16:22:09.634]             else {
[16:22:09.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:22:09.634]             }
[16:22:09.634]             {
[16:22:09.634]                 if (base::length(...future.futureOptionsAdded) > 
[16:22:09.634]                   0L) {
[16:22:09.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:22:09.634]                   base::names(opts) <- ...future.futureOptionsAdded
[16:22:09.634]                   base::options(opts)
[16:22:09.634]                 }
[16:22:09.634]                 {
[16:22:09.634]                   {
[16:22:09.634]                     base::options(mc.cores = ...future.mc.cores.old)
[16:22:09.634]                     NULL
[16:22:09.634]                   }
[16:22:09.634]                   options(future.plan = NULL)
[16:22:09.634]                   if (is.na(NA_character_)) 
[16:22:09.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:22:09.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:22:09.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:22:09.634]                     .init = FALSE)
[16:22:09.634]                 }
[16:22:09.634]             }
[16:22:09.634]         }
[16:22:09.634]     })
[16:22:09.634]     if (TRUE) {
[16:22:09.634]         base::sink(type = "output", split = FALSE)
[16:22:09.634]         if (TRUE) {
[16:22:09.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:22:09.634]         }
[16:22:09.634]         else {
[16:22:09.634]             ...future.result["stdout"] <- base::list(NULL)
[16:22:09.634]         }
[16:22:09.634]         base::close(...future.stdout)
[16:22:09.634]         ...future.stdout <- NULL
[16:22:09.634]     }
[16:22:09.634]     ...future.result$conditions <- ...future.conditions
[16:22:09.634]     ...future.result$finished <- base::Sys.time()
[16:22:09.634]     ...future.result
[16:22:09.634] }
[16:22:09.636] Poll #1 (0): usedNodes() = 2, workers = 2
[16:22:09.647] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.647] - Validating connection of MultisessionFuture
[16:22:09.647] - received message: FutureResult
[16:22:09.648] - Received FutureResult
[16:22:09.648] - Erased future from FutureRegistry
[16:22:09.648] result() for ClusterFuture ...
[16:22:09.648] - result already collected: FutureResult
[16:22:09.648] result() for ClusterFuture ... done
[16:22:09.648] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.648] result() for ClusterFuture ...
[16:22:09.648] - result already collected: FutureResult
[16:22:09.648] result() for ClusterFuture ... done
[16:22:09.648] result() for ClusterFuture ...
[16:22:09.649] - result already collected: FutureResult
[16:22:09.649] result() for ClusterFuture ... done
[16:22:09.650] MultisessionFuture started
[16:22:09.650] - Launch lazy future ... done
[16:22:09.650] run() for ‘MultisessionFuture’ ... done
[16:22:09.650] resolve() on list environment ...
[16:22:09.650]  recursive: 0
[16:22:09.651]  length: 4
[16:22:09.651]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:22:09.651] Future #1
[16:22:09.651]  length: 3 (resolved future 1)
[16:22:09.662] receiveMessageFromWorker() for ClusterFuture ...
[16:22:09.663] - Validating connection of MultisessionFuture
[16:22:09.663] - received message: FutureResult
[16:22:09.663] - Received FutureResult
[16:22:09.663] - Erased future from FutureRegistry
[16:22:09.663] result() for ClusterFuture ...
[16:22:09.663] - result already collected: FutureResult
[16:22:09.663] result() for ClusterFuture ... done
[16:22:09.663] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:09.663] Future #3
[16:22:09.664]  length: 2 (resolved future 3)
[16:22:09.664]  length: 1 (resolved future 4)
[16:22:10.127] receiveMessageFromWorker() for ClusterFuture ...
[16:22:10.127] - Validating connection of MultisessionFuture
[16:22:10.128] - received message: FutureResult
[16:22:10.128] - Received FutureResult
[16:22:10.128] - Erased future from FutureRegistry
[16:22:10.128] result() for ClusterFuture ...
[16:22:10.128] - result already collected: FutureResult
[16:22:10.128] result() for ClusterFuture ... done
[16:22:10.128] receiveMessageFromWorker() for ClusterFuture ... done
[16:22:10.128] Future #2
[16:22:10.128]  length: 0 (resolved future 2)
[16:22:10.129] resolve() on list environment ... DONE
[16:22:10.129] resolve() on list environment ...
[16:22:10.129]  recursive: 0
[16:22:10.130]  length: 4
[16:22:10.130]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:22:10.130] Future #1
[16:22:10.130]  length: 3 (resolved future 1)
[16:22:10.130] Future #2
[16:22:10.130]  length: 2 (resolved future 2)
[16:22:10.130] Future #3
[16:22:10.130]  length: 1 (resolved future 3)
[16:22:10.131]  length: 0 (resolved future 4)
[16:22:10.131] resolve() on list environment ... DONE
[16:22:10.131] resolve() on list environment ...
[16:22:10.131]  recursive: 0
[16:22:10.132]  length: 4
[16:22:10.132]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:22:10.135] Future #1
[16:22:10.135]  length: 3 (resolved future 1)
[16:22:10.135] Future #2
[16:22:10.136]  length: 2 (resolved future 2)
[16:22:10.136] Future #3
[16:22:10.136]  length: 1 (resolved future 3)
[16:22:10.136]  length: 0 (resolved future 4)
[16:22:10.136] resolve() on list environment ... DONE
[16:22:10.137] resolve() on list environment ...
[16:22:10.137]  recursive: 0
[16:22:10.138]  length: 4
[16:22:10.138]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:22:10.138] Future #1
[16:22:10.138]  length: 3 (resolved future 1)
[16:22:10.138] Future #2
[16:22:10.138]  length: 2 (resolved future 2)
[16:22:10.138] Future #3
[16:22:10.138]  length: 1 (resolved future 3)
[16:22:10.138]  length: 0 (resolved future 4)
[16:22:10.139] resolve() on list environment ... DONE
[16:22:10.139] resolve() on list environment ...
[16:22:10.139]  recursive: 0
[16:22:10.140]  length: 4
[16:22:10.140]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:22:10.140] Future #1
[16:22:10.140] result() for ClusterFuture ...
[16:22:10.140] - result already collected: FutureResult
[16:22:10.140] result() for ClusterFuture ... done
[16:22:10.140] result() for ClusterFuture ...
[16:22:10.140] - result already collected: FutureResult
[16:22:10.140] result() for ClusterFuture ... done
[16:22:10.141]  length: 3 (resolved future 1)
[16:22:10.141] Future #2
[16:22:10.141] result() for ClusterFuture ...
[16:22:10.141] - result already collected: FutureResult
[16:22:10.141] result() for ClusterFuture ... done
[16:22:10.141] result() for ClusterFuture ...
[16:22:10.141] - result already collected: FutureResult
[16:22:10.141] result() for ClusterFuture ... done
[16:22:10.141]  length: 2 (resolved future 2)
[16:22:10.141] Future #3
[16:22:10.142] result() for ClusterFuture ...
[16:22:10.142] - result already collected: FutureResult
[16:22:10.142] result() for ClusterFuture ... done
[16:22:10.142] result() for ClusterFuture ...
[16:22:10.142] - result already collected: FutureResult
[16:22:10.142] result() for ClusterFuture ... done
[16:22:10.142]  length: 1 (resolved future 3)
[16:22:10.142]  length: 0 (resolved future 4)
[16:22:10.142] resolve() on list environment ... DONE
[16:22:10.143] resolve() on list environment ...
[16:22:10.143]  recursive: 99
[16:22:10.143]  length: 4
[16:22:10.143]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:22:10.144] Future #1
[16:22:10.144] result() for ClusterFuture ...
[16:22:10.144] - result already collected: FutureResult
[16:22:10.144] result() for ClusterFuture ... done
[16:22:10.144] result() for ClusterFuture ...
[16:22:10.144] - result already collected: FutureResult
[16:22:10.144] result() for ClusterFuture ... done
[16:22:10.144] A MultisessionFuture was resolved
[16:22:10.144]  length: 3 (resolved future 1)
[16:22:10.144] Future #2
[16:22:10.145] result() for ClusterFuture ...
[16:22:10.145] - result already collected: FutureResult
[16:22:10.145] result() for ClusterFuture ... done
[16:22:10.145] result() for ClusterFuture ...
[16:22:10.145] - result already collected: FutureResult
[16:22:10.145] result() for ClusterFuture ... done
[16:22:10.145] A MultisessionFuture was resolved
[16:22:10.145]  length: 2 (resolved future 2)
[16:22:10.145] Future #3
[16:22:10.145] result() for ClusterFuture ...
[16:22:10.146] - result already collected: FutureResult
[16:22:10.146] result() for ClusterFuture ... done
[16:22:10.146] result() for ClusterFuture ...
[16:22:10.146] - result already collected: FutureResult
[16:22:10.146] result() for ClusterFuture ... done
[16:22:10.146] A MultisessionFuture was resolved
[16:22:10.146]  length: 1 (resolved future 3)
[16:22:10.146]  length: 0 (resolved future 4)
[16:22:10.146] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[16:22:10.149] resolve() on list ...
[16:22:10.150]  recursive: 0
[16:22:10.150]  length: 3
[16:22:10.150] 
[16:22:10.150]  length: 2 (resolved future 1)
[16:22:10.150]  length: 1 (resolved future 2)
[16:22:10.150]  length: 0 (resolved future 3)
[16:22:10.150] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[16:22:10.151] plan(): Setting new future strategy stack:
[16:22:10.151] List of future strategies:
[16:22:10.151] 1. FutureStrategy:
[16:22:10.151]    - args: function (..., envir = parent.frame())
[16:22:10.151]    - tweaked: FALSE
[16:22:10.151]    - call: future::plan(oplan)
[16:22:10.152] plan(): nbrOfWorkers() = 1
> 
